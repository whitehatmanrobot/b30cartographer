G, AddRef)(void);
	STDMETHOD_(ULONG, Release)(void);

	//
	//
	ULONG AddRef(void) const;
	ULONG Release(void) const;
	
protected:
	
	virtual ~CRefCount() = 0;

private:

	CRefCount(const CRefCount &);
	const CRefCount & operator=(const CRefCount &);
	UINT operator==(const CRefCount &);
	
	mutable UINT m_uiRefCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mitutil.rc
//
#define IDS_BAD_UNICODE_CHAR            12700
#define IDS_BAD_CODE_PAGE               12701
#define IDS_UIVAL_ON                    12702
#define IDS_UIVAL_OFF                   12703
#define IDS_UIVAL_TRUE                  12704
#define IDS_UIVAL_FALSE                 12705
#define IDS_UIVAL_YES                   12706
#define IDS_UIVAL_NO                    12707
#define IDS_UIVAL_BLOB                  12708
#define IDS_HEX_MUST_BE_4DIGITS         12709
#define IDS_INVALID_ESCAPE              12710

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\path.h ===
//////////////////////////////////////////////////////////////////////
// PATH.H
//
// Definition of CPath and CDir objects.
//
// History
// =======
// Date			Who			What
// ----			---			----
// 07-May-93	mattg		Created
// 12-May-93	danw		Add operator = and GetDisplayName
// 20-May-93	mattg		Added CDir object
// 22-May-93	danw		Added ConstructObject and DestructObject
//								for collections.
// 11-Jul-93	mattg		Added many new methods to CPath and CDir
//							Also "TCHAR'ified"
// 20-Jul-93    danw        Added relativization functions.
//////////////////////////////////////////////////////////////////////

#ifndef __PATH_H__
#define __PATH_H__

#ifndef _INC_DIRECT
#include <direct.h>
#endif

#ifndef _INC_IO
#include <io.h>
#endif

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

#ifndef _WIN32
#include <ctype.h>
#endif

#ifndef _INC_STAT
#include <sys\stat.h>
#endif

#pragma warning(disable : 4275 4251)


size_t RemoveNewlines(_TCHAR *);

//
// Compatible_GetFileAttributesEx
// g_pGetFileAttributesEx initially points to a function that chooses the new win32 api,
// GetFileAttributesEx if supported, or selects a compatible function that uses FindFirstFile.
//
extern BOOL AFX_DATA (WINAPI *g_pGetFileAttributesEx)( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation);
__inline BOOL Compatible_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation)
{
	return (*g_pGetFileAttributesEx)( lpFileName, fInfoLevelId, lpFileInformation);
}


//////////////////////////////////////////////////////////////////////
// Classes defined in this file

// CObject
	class CPath;
	class CDir;
//////////////////////////////////////////////////////////////////////
// Scan a path in see if it contains special charaters that would
// required it to be quoted:
BOOL ScanPathForSpecialCharacters (const TCHAR *pPath);
//////////////////////////////////////////////////////////////////////
// CPath
class LTAPIENTRY CPath : public CObject
{
	DECLARE_DYNAMIC(CPath)

	friend	class		CDir;

	friend	static VOID		ConstructElement(CPath *);
	friend	static VOID		DestructElement(CPath *);

protected:
	// Data
			CString		m_strCanon;
			int		m_ichLastSlash;	// used to quickly extract only dir or filename
			BOOL		m_Flags;
			enum	PathFlags
				{
					eIsActualCase = 1,
					eWantsRelative = 2,
				};
				// Canonicalized representation of pathname.
			static CMapStringToString c_DirCaseMap;
public:
	// Constructors, destructors, initialization methods
	inline				CPath() { m_ichLastSlash = -1; m_Flags = 0;}
	inline				CPath(const CPath & path)
							 {
								 m_strCanon = path.m_strCanon;
								 m_ichLastSlash = path.m_ichLastSlash;
								 m_Flags = path.m_Flags;
							 }
	virtual				~CPath();

	inline	BOOL		GetAlwaysRelative() const { return ((m_Flags & eWantsRelative) != 0); }
	inline	void		SetAlwaysRelative(BOOL bWantsRel = TRUE) { m_Flags =
			(bWantsRel) ? m_Flags | eWantsRelative : m_Flags & ~eWantsRelative;}

	inline	BOOL		IsInit() const { ASSERT(this!=NULL); return (m_ichLastSlash > 0); }

			BOOL		Create(const TCHAR *);
				// Initialize the object, given a filename.  The resulting
				// canonicalized filename will be relative to the current
				// directory.  For example, if the current directory is
				// C:\TEST and the argument is "FOO.C", the resulting
				// canonicalized filename will be "C:\TEST\FOO.C".  If the
				// argument is "..\FOO.C", the resulting canonicalized
				// filename will be "C:\FOO.C".

			BOOL		CreateFromDirAndFilename(const CDir &, const TCHAR *);
				// Initialize the object given a directory (CDir object) and
				// a filename.  This behaves exactly the same as the Create()
				// method, except that the Create() method canonicalizes the
				// filename relative to the CURRENT directory, whereas this
				// method canonicalizes the filename relative to the SPECIFIED
				// directory.

			BOOL		CreateTemporaryName(const CDir &, BOOL fKeep = TRUE);
				// Initialize the object given a directory.  The resulting
				// object will represent a UNIQUE filename in that directory.
				// This is useful for creating temporary filenames.
				//
				// WARNING
				// -------
				// After this method returns, the filename represented by this
				// object will EXIST ON DISK as a zero length file.  This is
				// to prevent subsequent calls to this method from returning
				// the same filename (this method checks to make sure it
				// doesn't return the name of an existing file).  IT IS YOUR
				// RESPONSIBILITY to delete the file one way or another.
				//
				// If you don't want this behavior, pass FALSE for 'fKeep',
				// and the file will not exist on disk.  Be aware, though,
				// that if you do this, subsequent calls to this method may
				// return the same filename.

			BOOL		ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharacters(m_strCanon);
						}
				// Scan the pathname for special character.  We cache this
				// information.

	inline  CPath &		operator =(const CPath & path)
						{
							ASSERT(path.IsInit());
							m_strCanon = path.m_strCanon;
							m_ichLastSlash = path.m_ichLastSlash;
							m_Flags = path.m_Flags;
							return(*this);
						}
				// Assignment operator.

	// Query methods
	inline	const TCHAR * GetFileName() const
					{
						ASSERT(IsInit());
						ASSERT(m_ichLastSlash==m_strCanon.ReverseFind('\\'));
						return ((const TCHAR *)m_strCanon + m_ichLastSlash + 1);
					}

				// Return a pointer to the filename part of the canonicalized
				// pathname, i.e., the filename with no leading drive or path
				// information. Return whole string if no backslash (not init).
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

			VOID		PostFixNumber();
				// Modifies the path by postfixing a number on the end of the path's
				// basename. If there is no number on the end of the path's basename
				// then the number 1 is postfixed. Otherwise if there already is a
				// number on the end of the path's basename then that number is
				// incremented by 1 and postfixed on the end of the basename (less the
				// original number).
				//
				// e.g. foo.cpp -> foo1.cpp -> foo2.cpp -> foo3.cpp
			
			VOID		GetBaseNameString(CString &) const;
				// Creates a CString representing the base name of the fully
				// canonicalized pathname.  For example, the base name of
				// the pathname "C:\FOO\BAR.C" is "BAR".
				//
				// This method can't return a pointer to internal data like
				// some of the other methods since it would have to remove
				// the extension in order to do so.

			VOID  		GetDisplayNameString(
										CString &,
										int cchMax = 16,
										BOOL bTakeAllAsDefault = FALSE
										) const;
				// Creates a CString representing the name of the file
				// shortened to cchMax CHARACTERS (TCHARs, not bytes) or
				// less.  Only the actual characters are counted; the
				// terminating '\0' is not considered, so
				// CString::GetLength() on the result MAY return as much as
				// cchMax.  If cchMax is less than the length of the base
				// filename, the resulting CString will be empty, unless
				// bTakeAllAsDefault is TRUE, in which the base name is
				// copied in, regardless of length.
				//
				// As an example, "C:\SOMEDIR\OTHERDIR\SUBDIR\SPECIAL\FOO.C"
				// will be shortened to "C:\...\SPECIAL\FOO.C" if cchMax is 25.

		inline	const TCHAR * GetExtension() const
					{
						ASSERT(IsInit());
						int iDot = m_strCanon.ReverseFind(_T('.'));
 						if (iDot < m_ichLastSlash)
							iDot = m_strCanon.GetLength();
						const TCHAR * retval = ((const TCHAR *)m_strCanon) + iDot;
 						return retval;
					}

				// Return a pointer to the extension part of the canonicalized
				// pathname.  Returns a pointer to the '.' character of the
				// extension.  If the filename doesn't have an extension,
				// the pointer returned will point to the terminating '\0'.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

	inline	const TCHAR * GetFullPath() const { return(m_strCanon); }
				// Return a pointer to the full (canonicalized) pathname.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!
	inline	const TCHAR * GetFullPath(CString & strPath) const { return(strPath = m_strCanon); }

	inline	BOOL		IsActualCase() const { ASSERT(this!=NULL); return ((m_Flags & eIsActualCase)!=0); }
	void GetActualCase(BOOL bEntirePath = FALSE);
				// Adjusts the paths case to match the actual path and filename
				// on disk.
	void SetActualCase(LPCTSTR pszFileCase); 
				// Adjusts the paths case to match the actual path and filename
				// on disk, where pszFileCase already contains the correct case
				// for just the filename portion.
	static void ResetDirMap();

	inline				operator const TCHAR *() const { return(m_strCanon); }
				// Return the fully canonicalized filename as a (const TCHAR *).
				// Same thing as GetFullPath(), but more convenient in some
				// cases.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

	inline	BOOL		IsUNC() const { return(m_strCanon[0] == _T('\\')); }
				// Returns TRUE if the pathname is UNC (e.g.,
				// "\\server\share\file"), FALSE if not.

	inline BOOL IsEmpty() const { return (m_strCanon.IsEmpty()); }

	// Comparison methods

			int			operator ==(const CPath &) const;
				// Returns 1 if the two CPaths are identical, 0 if they are
				// different.

	inline	int			operator !=(const CPath & path) const { return(!(operator ==(path))); }
				// Returns 1 if the two CPaths are different, 0 if they are
				// identical.

	// Modification methods

			VOID		ChangeFileName(const TCHAR *);
				// Changes the file name to that specified by the
				// (const TCHAR *) argument.  The directory portion of the
				// pathname remains unchanged.  DO NOT pass in anything
				// other than a simple filename, i.e., do not pass in
				// anything with path modifiers.

			VOID		ChangeExtension(const TCHAR *);
				// Changes the extension of the pathname to be that specified
				// by the (const TCHAR *) argument.  The argument can either be
				// of the form ".EXT" or "EXT".  If the current pathname has
				// no extension, this is equivalent to adding the new extension.

			BOOL 		GetRelativeName (const CDir&, CString&, BOOL bQuote = FALSE, BOOL bIgnoreAlwaysRelative = FALSE) const;
				// Makes the path name relative to the supplied directory and
				// placed the result in strResult.  Function will only go
				// down from the supplied directy (no ..'s).  Returns TRUE if
				// relativization was successful, or FALSE if not (e.g. if
				// string doesn't start with ".\" or ..\ or at least \).
				//
				// Thus, if the base directory is c:\sushi\vcpp32:
				//
				//  s:\sushi\vcpp32\c\fmake.c => s:\sushi\vcpp32\c\fmake.c
				//  c:\sushi\vcpp32\c\fmake.c => .\fmake.c
				//  c:\dolftool\bin\cl.exe    => \dolftool\bin\cl.exe
				//	\\danwhite\tmp\test.cpp   => \\danwhite\tmp\test.cpp

				// Thus, if the base directory is \\danwhite\c$\sushi\vcpp32:
				//
				// \\danwhite\c$\dolftool\bin\cl.exe => \dolftool\bin\cl.exe
				// \\danwhite\tmp\test.cpp           => \\danwhite\tmp\test.cpp

				// If bQuote is true, then quotes are put around the relative
				// file name. (Useful for writing the filename out to a file)

				// If (!bIgnoreAlwaysRelative && GetAlwaysRelative()) is TRUE
				// and if the file is on the same drive we will ALWAYS
				// relativize it. Thus for the base dir c:\sushi\vcpp32
				//  c:\dolftool\bin\cl.exe    => ..\..\dolftool\bin\cl.exe

			BOOL        CreateFromDirAndRelative (const CDir&, const TCHAR *);
				// THIS FUNCTION IS OBSOLETE.  New code should use
				// CreateFromDirAndFilename().  The only difference between
				// that function and this one is that this one will
				// automatically remove quotes from around the relative
				// path name (if present).


	// Miscellaneous methods
	inline	BOOL		IsReadOnlyOnDisk() const
						{
							HANDLE	h;

							ASSERT(IsInit());
							h = CreateFile(m_strCanon, GENERIC_WRITE,
								FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL, NULL);

							if (h == INVALID_HANDLE_VALUE && GetLastError() != ERROR_FILE_NOT_FOUND)
								return TRUE;

							if (h != INVALID_HANDLE_VALUE)
								CloseHandle(h);

							return FALSE;
						}
				// Returns TRUE if the filename represented by this object
				// is read-only on disk, FALSE if not.  NOT guaranteed to
				// work in all circumstances -- for example, will not return
				// TRUE for a file on a floppy drive that has been write-
				// protected.  I don't know of any way to get this information
				// from NT (GetFileAttributes doesn't work; GetVolumeInformation
				// doesn't work; _access just calls GetFileAttributes; etc.).
				// This method WILL correctly detect:
				//		- Files marked as read-only
				//		- Files on read-only network drives

	inline	BOOL		ExistsOnDisk() const
						{
							ASSERT(IsInit());
							return(_access(m_strCanon, 00) != -1);
						}
				// Returns TRUE if the filename represented by this object
				// exists on disk, FALSE if not.

	inline	BOOL		CanCreateOnDisk(BOOL fOverwriteOK = FALSE) const
						{
							ASSERT(IsInit());
							if (!fOverwriteOK && ExistsOnDisk())
								return(FALSE);
							int hFile = _creat(m_strCanon, _S_IREAD | _S_IWRITE);
							BOOL fCreate = (hFile != -1);
							if (fCreate)
							{
								VERIFY(_close(hFile) == 0);
								VERIFY(_unlink(m_strCanon) == 0);
							}
							return(fCreate);
						}
				// Returns TRUE if the filename represented by this object
				// can be created on disk, FALSE if not.

	inline	BOOL		DeleteFromDisk() const
						{
							ASSERT(IsInit());
#ifdef _WIN32
							return(DeleteFile((TCHAR *)(const TCHAR *)m_strCanon));
#else
							return(remove(m_strCanon) != -1);
#endif
						}
				// Removes the file represented by this object from the disk.

	BOOL GetFileTime(LPFILETIME lpftLastWrite);
	BOOL GetFileTime(CString& rstrLastWrite, DWORD dwFlags = DATE_SHORTDATE);
	// Returns the last modified time, as either an FILETIME struct or a string
};
//	Creation and destruction functions used by CMapPathToOb:

extern const CString AFX_DATA pthEmptyString;

static inline VOID ConstructElement(CPath * pNewData)
{
	memcpy(&pNewData->m_strCanon, &pthEmptyString, sizeof(CString));
}

static inline VOID DestructElement(CPath * pOldData)
{
	pOldData->m_strCanon.Empty();
}


//	File Name Utility Functions
//		These are redundant and could be replaced with use of CPath, but are
//		kept since they are easier to use and already exist in VRES.

// Remove the drive and directory from a file name.
CString StripPath(LPCTSTR szFilePath);

// Remove the name part of a file path.  Return just the drive and directory.
CString StripName(LPCTSTR szFilePath);

// Get only the extension of a file path.
CString GetExtension(LPCTSTR szFilePath);

// Return the path to szFilePath relative to szDirectory.  (e.g. if szFilePath
// is "C:\FOO\BAR\CDR.CAR" and szDirectory is "C:\FOO", then "BAR\CDR.CAR"
// is returned.  This will never use '..'; if szFilePath is not in szDirectory
// or a sub-directory, then szFilePath is returned unchanged.
//
CString GetRelativeName(LPCTSTR szFilePath, LPCTSTR szDirectory = NULL);

// Makes a file path look like in MRU.
CString GetDisplayName(LPCTSTR szFilePath, int nMaxDisplayLength,
	LPCTSTR szDirectory = NULL);

BOOL FileExists(LPCTSTR szFilePath);
BOOL IsFileWritable(LPCTSTR szFilePath);

UINT SushiGetFileTitle(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);

//////////////////////////////////////////////////////////////////////
// CDir
//
// The CDir object represents a file system directory on some disk.
//
// A CDir object can be created to represent the current directory,
// to represent the directory of a CPath object (i.e., the directory
// in which a file resides), and to represent a temporary directory.
// Note that a CDir object CANNOT be created given an arbitrary string --
// this is intentional, since this should not be necessary.
//
// The string representation of a CDir object (e.g., operator const TCHAR *())
// MAY or MAY NOT end in '\'.  The root directory of a local drive (e.g., C:)
// will end in '\' ("C:\"), while other directories on a local drive will
// not ("C:\OTHERDIR").  The root directory on a REMOTE drive will NOT end
// in '\' ("\\server\share").  Don't make any assumptions about whether or
// not the string representation ends in '\'.
//
// See also several CPath methods which use CDir objects.

class LTAPIENTRY CDir : public CObject
{
	DECLARE_DYNAMIC(CDir)

	friend	class		CPath;

	friend	static VOID		ConstructElement(CDir *);
	friend	static VOID		DestructElement(CDir *);

protected:
			CString		m_strDir;
				// Directory name, including drive letter or
				// server/share.  Do NOT make any assumptions
				// about whether or not this ends in '\'!

			// Creates multi level directories just fine
			BOOL MakeDirectory(LPCTSTR lpszPathName) const;
public:
	// Constructors, destructors, initialization methods
	inline				CDir() {}
	inline				CDir(const CDir & dir) { m_strDir = dir.m_strDir; }
	virtual				~CDir();

			BOOL		CreateFromCurrent();
				// Initialize from the current working directory.  This
				// may fail if the current working directory is unknown
				// or invalid.

			BOOL		CreateFromPath(const CPath &);
				// Initialize based on the directory of the specified
				// CPath object.  That is, if the CPath object represents
				// the file "C:\FOO\BAR\BLIX.C", the resulting directory
				// for this object will be "C:\FOO\BAR".  Returns FALSE
				// on failure.

			BOOL		CreateFromPath(const TCHAR *pszPath);
				// Initialize based on the directory of the specified
				// string.  That is, if the string contains the file name
				// "C:\FOO\BAR\BLIX.C", the generated directory for this
				// string will be "C:\FOO\BAR".  Returns FALSE on failure.

			BOOL		CreateTemporaryName();
				// Initialize this object to represent a temporary directory
				// on disk (e.g., "C:\TMP").

			inline BOOL		CreateFromString(const TCHAR * sz)
					{
						return  CreateFromStringEx(sz, FALSE);
					}	
				// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
				// do not use this method when another would suffice!

			BOOL		CreateFromStringEx(const TCHAR * sz, BOOL fRootRelative);
				// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
				// do not use this method when another would suffice!
				// same as CreateFromString with minor change. Not treating as bug fix to CFS
				// due to lateness in VC 4.0 project time

				// if fRootRelative true, treat dir ending with colon as relative not root dir 
				// (actual correct handling)


			BOOL		ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharacters(m_strDir);
						}
				// Scan the pathname for special character.  We cache this information.

	inline	CDir &		operator =(const CDir & dir)
						{
							m_strDir = dir.m_strDir;
							return(*this);
						}
				// Assignment operator.

	// Query methods

	inline				operator const TCHAR *() const { return(m_strDir); }
				// Return the directory name as a (const TCHAR *) string.

	inline int GetLength() const { return m_strDir.GetLength(); }
	      // Returns the length of the directory name

	// Miscellaneous methods

	BOOL	MakeCurrent() const;
				// Make this object the current working directory.  May fail
				// if the directory no longer exists (e.g., a floppy drive).

	inline	BOOL		ExistsOnDisk() const
						{
							// Tests if the directory exists.  We return FALSE
							// if <m_strDir> exists but is not a directory
							struct _stat statDir;
							if (_stat(m_strDir, &statDir) == -1)
								return FALSE;		 // Not found.
							else if (!(statDir.st_mode & _S_IFDIR))
								return FALSE;		 // Not a directory.
							else
								return TRUE;
						}
				// Returns TRUE if the directory represented by this object
				// exists on disk, FALSE if not.

	inline	BOOL		CreateOnDisk() const { return MakeDirectory(m_strDir); }
				// Creates the directory on disk.  If this fails, returns
				// FALSE.  If the directory already existed on disk, returns
				// TRUE (i.e., that is not an error condition).

	inline	BOOL		RemoveFromDisk() const { return RemoveDirectory(m_strDir); }
				// Removes the directory from the disk.  If this fails for
				// any reason (directory does not exist, directory is not
				// empty, etc.), returns FALSE.

			BOOL		IsRootDir() const;
				// Returns TRUE if the directory represented by this object
				// is a root directory (e.g., "C:\"), FALSE if not.  Note that
				// calling this method will NOT tell you whether or not the
				// string representation ends in '\', since "\\server\share"
				// is a root directory, and does not end in '\'.

	inline	BOOL		IsUNC() const { return(m_strDir[0] == _T('\\')); }
				// Returns TRUE if this is a UNC directory, FALSE if not.

			VOID		AppendSubdirName(const TCHAR *);
				// Adds a subdirectory name.  For example, if this object
				// currently represents "C:\FOO\BAR", and the argument is
				// "$AUTSAV$", the resulting object represents
				// "C:\FOO\BAR\$AUTSAV$".
				//
				// WARNING: This method does NO validation of the result --
				// it does not check for illegal characters, or for a
				// directory name that is too long.  In particular, don't
				// pass "DIR1/DIR2" as an argument, since no conversion
				// (of '/' to '\') will occur.

			VOID		RemoveLastSubdirName();
				// Removes the last component of the directory name.  For
				// example, if this object currently represents
				// "C:\FOO\BAR\$AUTSAV$", after this method it will
				// represent "C:\FOO\BAR".  If you try to call this method
				// when the object represents a root directory (e.g., "C:\"),
				// it will ASSERT.

	// Comparison methods

			int			operator ==(const CDir &) const;
				// Returns 1 if the two CDirs are identical, 0 if they are
				// different.

	inline	int			operator !=(const CDir & dir) const { return(!(operator ==(dir))); }
				// Returns 1 if the two CDirs are different, 0 if they are
				// identical.
};

//	Creation and destruction functions used by CMapDirToOb:

static inline VOID ConstructElement(CDir * pNewData)
{
	memcpy(&pNewData->m_strDir, &pthEmptyString, sizeof(CString));
}

static inline VOID DestructElement(CDir * pOldData)
{
	pOldData->m_strDir.Empty();
}

///////////////////////////////////////////////////////////////////////////////
//	CCurDir
//		This class is used to switch the current drive/directory during the
//		life of the object and to restore the previous dirve/directory upon
//		destruction.

class LTAPIENTRY CCurDir : CDir
{
public:
	CCurDir(const char* szPath, BOOL bFile = FALSE);
	CCurDir(const CDir& dir);
	CCurDir();	// just saves the current directory and resets it
	~CCurDir();

	CDir m_dir;
};


///////////////////////////////////////////////////////////////////////////////
//	CFileOpenReturn
//		This class represents the return value from the Common Dialogs
//		File.Open.  It handles both single and multiple select types.
//

class LTAPIENTRY CFileOpenReturn : CObject
{
	BOOL		m_bSingle;
	BOOL		m_bBufferInUse;
	BOOL		m_bArrayHasChanged;

	int			m_cbData;
	_TCHAR * 	m_pchData;

	// Multiple Files
	CPtrArray	m_rgszNames;

public:
	CFileOpenReturn (const _TCHAR * szRawString = NULL);
	~CFileOpenReturn ();

	inline BOOL IsSingle () const;
	inline BOOL IsDirty() const;
	inline BOOL BufferOverflow () const;
	//inline int  GetLength () const;

	// GetBuffer gives permission for something else to directly change the buffer
	// ReleaseBuffer signifies that the something else is done with it.
	_TCHAR * GetBuffer (int cbBufferNew);
	inline void ReleaseBuffer ();

	// allows the object to be re-initialized
	void ReInit (const _TCHAR * szRawString);

	// This supports the dynamic file extension update in OnFileNameOK().
	void ChangeExtension (int i, const CString& szExt);

	void CopyBuffer (_TCHAR * szTarget);

	// This is the function to use to get at the user's selections,
	// whether single or multiple.
	BOOL GetPathname (int i, CString& strPath) const;

private:
	void GenArrayFromBuffer ();
	void GenBufferFromArray ();
	void ClearNamesArray ();
	void SetBuffer (const _TCHAR * szRawString);	
};


inline BOOL CFileOpenReturn::IsSingle () const
{
	return m_bSingle;
}

inline BOOL CFileOpenReturn::IsDirty() const
{
	return m_bArrayHasChanged;
}

inline BOOL CFileOpenReturn::BufferOverflow () const
{
	return m_cbData == 2 && m_pchData[0] == '?';
}

///// ReleaseBuffer - Tell object we're done changing the buffer
//
//	Processes the raw string
//
///
inline void CFileOpenReturn::ReleaseBuffer ()
{
	m_bBufferInUse = FALSE;
	GenArrayFromBuffer ();
}

///////////////////////////////////////////////////////////////////////////////
//	Smart case helpers.
//		These functions are used to do smart casing of paths and file extensions.

extern BOOL GetActualFileCase( CString& rFilename, LPCTSTR lpszDir = NULL );
extern LPCTSTR GetExtensionCase( LPCTSTR lpszFilename, LPCTSTR lpszExtension );

extern BOOL GetDisplayFile(CString &rFilename, CDC *pDC, int &cxPels); // truncates from left

/////////////////////////////////////////////////////////////////////////////
#pragma warning(default : 4275 4251)

#endif // __PATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\passtr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: passtr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Default constructor for a Pascal string.  Sets the length to zero, with
//  no storage.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::CPascalString()
{
	//
	//  The string data class is initialized by it's constructor.
	//
	LTASSERT(m_blbData.GetBlobSize() == 0);

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Casting operator to convert a CPascalString to a blob.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::operator const CLocCOWBlob &(void)
		const
{
	return m_blbData;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator - CPascalString to CPascalString.  
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &                     // Allows a=b=c;
CPascalString::operator=(
		const CPascalString &pstrSource)  // Source string
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData = ((const CLocCOWBlob &)pstrSource);
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Copy constructor for CPascalString's
//  
//-----------------------------------------------------------------------------
inline
CPascalString::CPascalString(
		const CPascalString &pstrSource)
{
	LTASSERT(pstrSource.m_blbData.GetWriteCount() == 0);
	 
	operator=(pstrSource);

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator - Wide character C String to CPascalString.  The string
//  is COPIED into the CPascalString.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &             //  Allows a=b=c;
CPascalString::operator=(
		const WCHAR *wszSource)   //  Source, zero terminated string
{
	SetString(wszSource, wcslen(wszSource));

	return *this;
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Appends a CPascalString to the current string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &			        // Allows a=b+=c syntax
CPascalString::operator+=(
		const CPascalString &pstrTail)	// Pascal string to append
{
	AppendBuffer(pstrTail, pstrTail.GetStringLength());
	
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Append a NUL terminated Unicode string to a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Allows a-b+=L"Hi There" syntax
CPascalString::operator+=(
		const WCHAR *szTail)			// NUL terminated string to append
{
	AppendBuffer(szTail, wcslen(szTail));
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Append a Unicode character to a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Allows a-b+=L"Hi There" syntax
CPascalString::operator+=(
		const WCHAR wch)			// WCHAR to append
{
	AppendBuffer(&wch, 1);
	return *this;
}



//-----------------------------------------------------------------------------
//  
//  Comparison function for Pascal strings.
//  
//-----------------------------------------------------------------------------
inline
BOOL                                                // TRUE (1) if the same
CPascalString::IsEqualTo(
		const CPascalString &pstrOtherString) const // String to compare to
{
	return m_blbData == (const CLocCOWBlob &)pstrOtherString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CPascalString::operator==(
		const CPascalString &pstrOtherString) // String to compare
		const
{
	return IsEqualTo(pstrOtherString);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator != - just the negative of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int                                                 // TRUE (1) if *not* equal
CPascalString::operator!=(
		const CPascalString &pstrOtherString) const // String to compare
{

	return !IsEqualTo(pstrOtherString);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator for NUL terminated WCHAR strings.
//  
//-----------------------------------------------------------------------------
inline
int
CPascalString::operator==(
		const WCHAR *pwch)
		const
{
	return (wcscmp(*this, pwch) == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator for NUL termninated WCHAR strings.
//  
//-----------------------------------------------------------------------------
inline int
CPascalString::operator!=(
		const WCHAR *pwch)
		const
{
	return (wcscmp(*this, pwch) != 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is there anything in the string?  This is different from a string of zero
//  length.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CPascalString::IsNull(void)
		const
{
	return ((const void *)m_blbData == NULL);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the length of the pascal string.  If the length is zero, there may be
//  no storage associated with the string.  Use IsNull to check for storage.
//  
//-----------------------------------------------------------------------------
inline
UINT                                         // length of the string.
CPascalString::GetStringLength(void) const
{
	UINT uiBufferSize;

	uiBufferSize = m_blbData.GetBlobSize();
	LTASSERT((uiBufferSize % sizeof(WCHAR)) == 0);
	
	return (uiBufferSize != 0 ? (uiBufferSize/sizeof(WCHAR)-1): 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set the length of the pascal string.  String contents are not preserved
//  
//-----------------------------------------------------------------------------
inline
void                                         // length of the string.
CPascalString::SetStringLength(UINT uNewSize)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.SetBlobSize((uNewSize + 1) * sizeof(WCHAR));
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	*(GetStringPointer() + uNewSize) = L'\0';
	ReleaseStringPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Realloc a string - set true size
//  
//-----------------------------------------------------------------------------
inline
void                                         // length of the string.
CPascalString::ReallocString(UINT uNewSize)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.ReallocBlob((uNewSize +  1) * sizeof(WCHAR));
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	*(GetStringPointer() + uNewSize) = L'\0';
	ReleaseStringPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  As an optimization, the user can ask the Pascal string to reserve some
//  memory for future growth.  This would allow incremental additions to be
//  very efficent.  The reported size of the string is not changed - only the
//  amount of storage reserved for the string.
//
//  If the user requests less space than is already allocated, nothing
//  happens.
//
//-----------------------------------------------------------------------------
inline
void
CPascalString::ReserveStorage(
		UINT nMinSize)					// Size (in chars) to reserve for
{
	if (nMinSize > GetStringLength())
	{
		UINT uiCurSize;

		uiCurSize = GetStringLength();
		ReallocString(nMinSize);
		ReallocString(uiCurSize);
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get a pointer to the storage for the string.  This may be NULL if the
//  string has length 0.  This pointer should be considered INVALID if any
//  other assignment operation is performed on the Pascal string.  Calling
//  this dis-ables teh COW behavior of the CPascalString.
//  
//-----------------------------------------------------------------------------
inline
WCHAR *
CPascalString::GetStringPointer(void)
{
	return (WCHAR *)m_blbData.GetPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Anytime you do a GetStringPointer, use ReleaseStringPointer to allow
//  the PascalString to revert to COW behavior.  Once you call this, the
//  pointer from GetStringPointer is INVALID.
//  
//-----------------------------------------------------------------------------
inline
void
CPascalString::ReleaseStringPointer(void)
{
	m_blbData.ReleasePointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Casting operator version of GetString pointer.  Cast a CPascalString to
//  const WCHAR *, and you get a pointer to the string.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::operator const WCHAR *(void) const
{
	return (const WCHAR *)(const void *)(m_blbData);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Cleanup on the string.  Sets the length to zero, and remove all storage.
//  This is different than assigning a NULL string - that is a string of
//  length 1, consisting of the NUL (zero) character.
//  
//-----------------------------------------------------------------------------
inline
void
CPascalString::ClearString(void)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.SetBlobSize(0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor for a Pascal string.  Frees up the current storage.  After
//  a Pascal string goes out of scope, all pointers to the internal storage
//  are invalid.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::~CPascalString()
{
	LTASSERTONLY(AssertValid());
	DEBUGONLY(--m_UsageCounter);
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Serialize for a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
void CPascalString::Serialize(CArchive &ar)
{
	if (ar.IsStoring())
	{
		Store(ar);
	}
	else
	{
		Load(ar);
	}
}



inline
void
CPascalString::Store(
		CArchive &ar)
		const
{
	LTASSERT(ar.IsStoring());
	LTASSERTONLY(AssertValid());

	//
	//  HACK HACK HACK
	//  Emulate Old Espresso 3.0 serialization.
	m_blbData.Store(ar);
	
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Helper function - comparison operator for a NUL terminated WCHAR string
//  and a CPascalString.
//  
//-----------------------------------------------------------------------------
inline
int
operator==(
		const WCHAR *pwch,
		const CPascalString &pstr)
{
	return (wcscmp(pwch, pstr) == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Helper function - comparison operator for a NUL terminated WCHAR string
//  and a CPascalString.
//  
//-----------------------------------------------------------------------------
inline
int
operator!=(
		const WCHAR *pwch,
		const CPascalString &pstr)
{
	return (wcscmp(pwch, pstr) != 0);
}



inline
int CPascalString::operator!=(
		const _bstr_t &bsOther)
		const
{
	return !(operator==(bsOther));
}



inline
int
operator==(
		const _bstr_t &bsOther,
		const CPascalString &pstr)
{
	return pstr == bsOther;
}



inline
int
operator!=(
		const _bstr_t &bsOther,
		const CPascalString &pstr)
{
	return pstr != bsOther;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\redvisit.inl ===
//-----------------------------------------------------------------------------
//  
//  File: redvisit.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
 
inline
CRichEditDeltaVisitor::CRichEditDeltaVisitor(
	CRichEditCtrl & red) :
	m_red(red)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\reghelp.h ===
//******************************************************************************
//
// RegHelp.h : Collection of Registry helping functions
//
// Copyright (C) 1994-1997 by Microsoft Corporation
// All rights reserved.
//
//******************************************************************************

#if !defined(MITUTIL_RegHelp_h_INCLUDED)
#define MITUTIL_RegHelp_h_INCLUDED

#pragma once

//------------------------------------------------------------------------------
class LTAPIENTRY CRegHelp
{
public:
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, CString & stValue);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, DWORD & dwNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, long & nNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, BOOL & fNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, VARIANT_BOOL & fNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, GUID & guid);
};

#endif // MITUTIL_RegHelp_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\smartptr.h ===
//-----------------------------------------------------------------------------
//  
//  File: smartptr.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_SMARTPTR_H
#define ESPUTIL_SMARTPTR_H



template<class T>
class SmartPtr
{
public:
	NOTHROW SmartPtr();
	NOTHROW SmartPtr(T *);

	NOTHROW T & operator*(void) const;
	NOTHROW T * operator->(void) const;
	NOTHROW T* Extract(void);
	NOTHROW T* GetPointer(void);
	NOTHROW const T * GetPointer(void) const;
	NOTHROW BOOL IsNull(void) const;
	
	void operator=(T *);
	operator T* &(void);

	NOTHROW ~SmartPtr();
	
private:
	T *m_pObject;

	SmartPtr(const SmartPtr<T> &);
	void operator=(const SmartPtr<T> &);
	
	//
	//  This hackery prevents Smart Pointer from being on the heap
	//
	void operator delete(void *);
};

#include "smartptr.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\smartptr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: smartptr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

template <class T>
SmartPtr< T >::SmartPtr()
{
	m_pObject = NULL;
}



template <class T>
SmartPtr< T >::SmartPtr(
		T *pObject)
{
	m_pObject = pObject;
}



template <class T>
T &
SmartPtr< T >::operator*(void)
		const
{
	LTASSERT(m_pObject != NULL);
	return *m_pObject;
}



template <class T>
T *
SmartPtr< T >::operator->(void)
		const
{
	LTASSERT(m_pObject != NULL);
	
	return m_pObject;
}


template <class  T>
T *
SmartPtr< T >::Extract(void)
{
	T *pObj = m_pObject;
	m_pObject = NULL;

	return pObj;
}



template <class T>
T*
SmartPtr< T >::GetPointer(void)
{
	return m_pObject;
}


template <class T>
const T*
SmartPtr< T >::GetPointer(void) const
{
	return m_pObject;
}


template <class T>
BOOL
SmartPtr< T >::IsNull(void)
		const
{
	return m_pObject == NULL;
}



template <class T>
void
SmartPtr< T >::operator=(
		T *pObject)
{
	LTASSERT(m_pObject == NULL);

	if (m_pObject != NULL)
	{
		delete m_pObject;
	}
	m_pObject = pObject;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  This should only be used to init a smart pointer.
//  
//-----------------------------------------------------------------------------
template <class T>
SmartPtr< T >::operator T * & (void)
{
	LTASSERT(m_pObject == NULL);
	
	return m_pObject;
}


template <class T>
void
SmartPtr< T >::operator delete(
		void *)
{
	LTASSERT(m_pObject != NULL);

	delete m_pObject;
	m_pObject = NULL;
}



template <class T>
SmartPtr< T >::~SmartPtr()
{
	if (m_pObject != NULL)
	{
		delete m_pObject;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\stacktrace.h ===
//-----------------------------------------------------------------------------
//  
//  File: stacktrace.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Provides a mechanism for generating stacktraces and converting them to
//  human readable form.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_STACKTRACE_H
#define ESPUTIL_STACKTRACE_H


const UINT MODULE_NAME_LEN = 64;
const UINT SYMBOL_NAME_LEN = 128;


//
//  'human readable' form of a stack-frame.  Provides module and function name.
namespace LocStudio {

struct SYMBOL_INFO
{
	DWORD dwAddress;
	DWORD dwOffset;
    TCHAR szModule[MODULE_NAME_LEN];
    TCHAR szSymbol[SYMBOL_NAME_LEN];
	BOOL fSymbolLocated;
};

} // namespace LocStudio

#pragma warning(disable:4275)

//
//  How we return a complete human readable stack walk.
//
class LTAPIENTRY CSymbolList : public CTypedPtrList<CPtrList, LocStudio::SYMBOL_INFO *>
{
public:
	CSymbolList();

	void Clear(void);
	~CSymbolList();

private:
	CSymbolList(const CSymbolList &);
	void operator=(const CSymbolList &);
};

#pragma warning(default:4275)	

//
//  Class for generating stack traces.  Provides both native (compact) data
//  (in case you want to store it for later), and a human (versbose) form.
//
#pragma warning(disable : 4251)
class LTAPIENTRY CStackTrace
{
public:
	CStackTrace();

	~CStackTrace();

	void CreateStackTrace(void);
	void CreateStackTrace(UINT nSkip, UINT nTotal);
	void SetAddresses(const CDWordArray &);
	
	const CDWordArray &GetAddresses(void) const;

	void GetSymbolList(CSymbolList &) const;
	
private:
	CStackTrace(const CStackTrace &);
	void operator=(const CStackTrace &);

	CDWordArray m_adwAddresses;
};
#pragma warning(default : 4251)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\smartref.h ===
//-----------------------------------------------------------------------------
//  
//  File: SmartRef.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_SmartRef_H
#define ESPUTIL_SmartRef_H


template<class T>
class SmartRef
{
private:
	T *m_pInterface;

public:
	NOTHROW SmartRef()
	{
		m_pInterface = NULL;
	}

	//  Compiler bug, must be inline!
	NOTHROW SmartRef(T *pI) {m_pInterface = pI;};
	NOTHROW SmartRef(const SmartRef<T> &);

	NOTHROW T * operator->(void)
	{
		LTASSERT(m_pInterface != NULL);
		return m_pInterface;
	}
	
	NOTHROW const T * operator->(void) const
	{
		LTASSERT(m_pInterface != NULL);
		return m_pInterface;
	}
	
	NOTHROW T & operator*(void)
	{
		LTASSERT(m_pInterface != NULL);
		return *m_pInterface;
	}
	NOTHROW T * Extract(void)
	{
		return ExtractImpl();
	};
	
	NOTHROW T * GetInterface(BOOL fAddRef = FALSE)	
	{
		return GetInterfaceImpl(fAddRef);
	};

	NOTHROW const T * GetInterface(void) const
	{
		return m_pInterface;
	}
	
	NOTHROW BOOL IsNull(void) const
	{
		return m_pInterface == NULL;
	}
	
	NOTHROW ~SmartRef()
	{
		if (m_pInterface != NULL)
		{
			m_pInterface->Release();
		}
	}

	void operator=(T* pOther)
	{
		opEqImpl(pOther);
	}
	void operator=(const SmartRef<T> &other);

	T ** operator&(void);
	operator T* &(void) {return opTpRef();};
	
private:
	void operator delete(void *);

	NOTHROW T * ExtractImpl(void);
	NOTHROW T * GetInterfaceImpl(BOOL fAddRef);
	NOTHROW T * & opTpRef(void);
	void opEqImpl(T* pOther);

};

#include "SmartRef.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\stringblast.h ===
//******************************************************************************
//
// StringBlast.h: Microsoft LocStudio
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(MITUTIL__StringBlast_h__INCLUDED)
#define MITUTIL__StringBlast_h__INCLUDED

//------------------------------------------------------------------------------
struct LTAPIENTRY StringBlast
{
// Fast Win32 conversions
	static CLString MakeString(_bstr_t bstrSrc);
	static CLString MakeString(const CPascalString & pasSrc);
	static CLString MakeStringFromBStr(BSTR bstrSrc);
	static CLString MakeStringFromWide(const wchar_t * szwSrc);

	static _bstr_t MakeBStr(const char * szBuffer);
	static _bstr_t MakeBStrFromWide(const wchar_t * wszBuffer);
	static _bstr_t MakeBStr(const CLString & stSrc);
	static _bstr_t MakeBStrFromBStr(BSTR bstrSrc);
	static _bstr_t MakeBStr(const CPascalString & pasSrc);
	static _bstr_t MakeBStr(HINSTANCE hDll, UINT nStringID);

	// Use these functions when you need to get a raw BSTR
	static BSTR MakeDetachedBStr(const char * szBuffer);
	static BSTR MakeDetachedBStrFromWide(const wchar_t * wszBuffer);
	static BSTR MakeDetachedBStr(const CLString & stSrc);

};

#endif // MITUTIL__StringBlast_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_)
#define AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_

#pragma once


// StrigBlast requires the CString implicit conversions.
#ifdef _LS_NO_IMPLICIT
#undef _LS_NO_IMPLICIT
#endif // #ifdef _LS_NO_IMPLICIT

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxtempl.h>
#include <afxdisp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\smartref.inl ===
//-----------------------------------------------------------------------------
//  
//  File: SmartRef.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 



template <class T>
SmartRef< T >::SmartRef(
		const SmartRef<T> &other)
{
	m_pInterface = const_cast<T *>(other.m_pInterface);
	m_pInterface->AddRef();
}



template <class T>
void
SmartRef< T >::operator=(
		const SmartRef<T> &pInterface)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
	}
	m_pInterface = ((SmartRef<T> &)pInterface).GetInterface(TRUE);
}



template <class T>
T **
SmartRef< T >::operator&(void)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
		m_pInterface = NULL;
	}

	return &m_pInterface;
}



template <class T>
T *
SmartRef< T >::ExtractImpl(void)
{
	T *pInterface = m_pInterface;
	m_pInterface = NULL;
	return pInterface;
}


template <class T>
T *
SmartRef< T >::GetInterfaceImpl(
	BOOL fAddRef /*= FALSE*/)
{
	// Should never ask to AddRef with a NULL pointer

	LTASSERT(!fAddRef || NULL != m_pInterface);

	if (fAddRef)
	{
		m_pInterface->AddRef();
	}

	return m_pInterface;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
// This should only be used to init a smart pointer.
// 
//-----------------------------------------------------------------------------
template <class T>
T * &
SmartRef< T >::opTpRef(void)
{
	LTASSERT(m_pInterface == NULL);
	
	return m_pInterface;
}


template <class T>
void
SmartRef< T >::opEqImpl(
		T *pOther)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
	}
	m_pInterface = pOther;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\stringtokenizer.h ===
//-----------------------------------------------------------------------------
//  
//  File: StringTokenizer.h
//  Copyright (C) 1997 Microsoft Corporation
//  All rights reserved.
//
//  This file declares the CStringTokenizer class, which implements simple
//  linear tokenization of a String. The set of delimiters, which defaults
//  to common whitespace characters, may be specified at creation time or on a 
//  per-token basis.
//  Example usage:
//	CString s = "a test string";
//	CStringTokenizer st = new CStringTokenizer(s);
//	while (st.hasMoreTokens())
//  {
//		cout << st.nextToken() << endl;
//	}
//-----------------------------------------------------------------------------
#pragma once

#ifndef StringTokenizer_h
#define StringTokenizer_h

class LTAPIENTRY CStringTokenizer 
{
public:
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer with default delimiters
//-----------------------------------------------------------------------------
  CStringTokenizer();
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer with default delimiters
//   str - in, the string to be tokenized
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer
//   str - in, the string to be tokenized
//   delimiters - in, the delimiters; null terminated
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str, const WCHAR* delimiters);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer
//   str - in, the string to be tokenized
//   delimiters - in, the delimiters; null terminated
//   returnTokens - in, TRUE indicates return delimiter as token
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str,
                   const WCHAR* delimiters,
                   BOOL  returnTokens);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// destructs this tokenizer
//-----------------------------------------------------------------------------
  virtual ~CStringTokenizer();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// configure whether return delimiter as token
//   returnTokens - in, TRUE indicates return delimiter as token
//-----------------------------------------------------------------------------
  void setReturnTokens(BOOL returnTokens);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// sets delimiters
//   delimiters - in, the delimiters; null terminated
//-----------------------------------------------------------------------------
  void setDelimiters(const WCHAR* delimiters);

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// parse a string to be tokenized
//   str - in, the null terminated string
//-----------------------------------------------------------------------------
  void parse(const WCHAR* str);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// checks whether there are more tokens
//-----------------------------------------------------------------------------
  BOOL hasMoreTokens();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// get next token
//   length - out, the length of the token
//   return the pointer to the begining of the token
//-----------------------------------------------------------------------------
  const WCHAR* nextToken(unsigned int & length);

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// count total number of tokens
//-----------------------------------------------------------------------------
  int     countTokens();

private:
  void skipDelimiters();
  int  IsDelimiter(WCHAR ch) const;

  int          m_currentPosition;
  int          m_maxPosition;
  const WCHAR* m_str;
  WCHAR*       m_delimiters;
  int          m_lenDelimiters;
  BOOL         m_retTokens;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\strlist.h ===
//-----------------------------------------------------------------------------
//  
//  File: strlist.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_STRLIST_H
#define ESPUTIL_STRLIST_H


const UINT NO_INDEX = (DWORD) -1;
	
template<class T>
class CLocThingList
{
	
public:
	NOTHROW CLocThingList();

	UINT NOTHROW GetIndex(void) const;
	const CArray<T, T&> &GetStringArray(void) const;
	BOOL NOTHROW AdditionsAllowed(void) const;

	void SetThingList(const CArray<T, T&> &);
	UINT AddThing(T &);
	void InsertThing(UINT idxInsert, T & tNew);
	BOOL DeleteThing(UINT);
	BOOL NOTHROW SetIndex(UINT);
	void NOTHROW SetAdditionsAllowed(BOOL);
	UINT GetSize();

	const CLocThingList<T> &operator=(const CLocThingList<T> &);
	int NOTHROW operator==(const CLocThingList<T> &) const;
	int NOTHROW operator!=(const CLocThingList<T> &) const;
	
	NOTHROW ~CLocThingList();

private:
	CLocThingList(const CLocThingList<T> &);

	UINT m_uiIndex;
	CArray<T, T&> m_aThings;
	BOOL m_fAdditionsAllowed;
};

#include "strlist.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\strlist.inl ===
//-----------------------------------------------------------------------------
//  
//  File: strlist.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

template <class T>
CLocThingList<T>::CLocThingList()
{
	m_fAdditionsAllowed = FALSE;
	m_uiIndex = NO_INDEX;
}


template <class T>
UINT
CLocThingList<T>::GetIndex(void)
		const
{
	return m_uiIndex;
}



template <class T>
const CArray<T, T&> &
CLocThingList<T>::GetStringArray(void)
		const
{
	return m_aThings;
}



template <class T>
BOOL
CLocThingList<T>::AdditionsAllowed(void)
		const
{
	return m_fAdditionsAllowed;
}



template <class T>
void
CLocThingList<T>::SetThingList(
		const CArray<T, T&> &aNewThings)
{
	UINT uiNewSize = aNewThings.GetSize();
	
	m_aThings.SetSize(uiNewSize);

	for (UINT i=0; i<uiNewSize; i++)
	{
		m_aThings[i] = aNewThings[i];
	}
}



template <class T>
inline
UINT
CLocThingList<T>::AddThing(
		T &NewThing)
{
	return m_aThings.Add(NewThing);
}


template <class T>
inline
void
CLocThingList<T>::InsertThing(
		UINT idxInsert, 
		T & tNew
		)
{
	m_aThings.InsertAt(idxInsert, tNew);
}


template <class T>
inline
BOOL
CLocThingList<T>::DeleteThing(
		UINT iIndex)
{
    BOOL fRetVal = FALSE;
	if (iIndex < GetSize())
	{
		m_aThings.RemoveAt(iIndex);
		fRetVal = TRUE;
	}
	return fRetVal;	
}



template <class T>
inline
BOOL
CLocThingList<T>::SetIndex(
		UINT uiNewIndex)
{
	m_uiIndex = uiNewIndex;
	return FALSE;
}



template <class T>
inline
void
CLocThingList<T>::SetAdditionsAllowed(
		BOOL fAllowed)
{
	m_fAdditionsAllowed = fAllowed;
}


template <class T>
inline
UINT
CLocThingList<T>::GetSize()
{
	return m_aThings.GetSize();
}


template <class T>
const CLocThingList<T> &
CLocThingList<T>::operator=(
		const CLocThingList<T>& slOther)
{
	SetThingList(slOther.GetStringArray());
	SetIndex(slOther.GetIndex());

	SetAdditionsAllowed(slOther.AdditionsAllowed());
	
	return *this;
}


template <class T>
CLocThingList<T>::~CLocThingList()
{
	m_aThings.SetSize(0);
}

template <class T>
inline
int 
CLocThingList<T>::operator==(
		const CLocThingList<T>& list)
		const
{
	if (m_uiIndex != list.m_uiIndex
		|| m_fAdditionsAllowed != list.m_fAdditionsAllowed
		|| m_aThings.GetSize() != list.m_aThings.GetSize())
	{
		return 0;
	}

	for (int i=m_aThings.GetUpperBound(); i>=0; i--)
	{
		if (m_aThings[i] != list.m_aThings[i])
		{
			return 0;
		}
	}
	
	return 1;
}

template <class T>
inline
int 
CLocThingList<T>::operator!=(
		const CLocThingList<T>& list)
		const
{
	return !(operator==(list));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\uiopthelp.h ===
//-----------------------------------------------------------------------------
//  
//  File: uiopthelp.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Class used to represent a single 'option'.
//
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
#pragma once

//
// Base structure
//
struct UI_OPTS_BASE
{
	TCHAR* pszName;				   // internal name of the option 
	UINT nDisplayName;			   // string id of the display name
	UINT nDisplayHelp;			   // string id of the help string
	PFNOnValidateUIOption pfnVal;    // function to call during validation. 
	                               // This may be null
	WORD wStorageTypes;			   // storage type of option	
	CLocUIOptionDef::ControlType wReadOnly;	  // ReadOnly value
	CLocUIOptionDef::ControlType wVisible;	  // Visible value
};



// Structures of option data

//
// BOOL options
//

struct UI_OPTS_BOOL
{
	UI_OPTS_BASE base;                // base class data 
	BOOL bDefValue;				   // default value of the option
	CLocUIOption::EditorType et;     // type of BOOL option
};

//
//  PICK options
//

struct UI_OPTS_PICK
{
	UI_OPTS_BASE base;                // base class data 
	DWORD dwDefValue;			   // default value of the option
	BOOL bAdd;					   // allow additions to the list	
	UINT nListEntries;             // list of entries to pick from
	                               // Each entry is separated by \n
	                               // The last entry does not have a \n
};

const TCHAR UI_PICK_TERMINATOR = _T('\n');

// 
// DWORD options

struct UI_OPTS_DWORD
{
	UI_OPTS_BASE base;                // base class data 
	DWORD dwDefValue;			   // default value of the option
	CLocUIOption::EditorType et;     // type of DWORD option
};


//
// String options
//
struct UI_OPTS_STR
{
	UI_OPTS_BASE base;                // base class data 
	UINT nDefValue;				   // string table entry for default value 
	CLocUIOption::EditorType et;
};


//
//  String list options
//

struct UI_OPTS_STRLIST
{
	UI_OPTS_BASE base;					// base class data 
	UINT nDefList;						// Each entry is separated by \n
										// The last entry does not have a \n
};


//
// File Name options
//
struct UI_OPTS_FILENAME
{
	UI_OPTS_BASE base;                // base class data 
	UINT nExtensions;	    		  // The default extensions to the UI
	UINT nDefValue;			  	      // string table entry for default value 
};


//
// Helper class definition
//

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUIOptionImpHelper : public CObject
{
public:

	CLocUIOptionImpHelper(HINSTANCE hInst);

	void GetOptions(CLocUIOptionSet *pOptionSet, UINT nDesc, UINT nHelp);
	
	void SetBools(const UI_OPTS_BOOL* pBools, int nCntBools);
	void SetPicks(const UI_OPTS_PICK* pPicks, int nCntPicks);
	void SetDwords(const UI_OPTS_DWORD* pDwords, int nCntDwords);
	void SetStrs(const UI_OPTS_STR* pStrs, int nCntStrs);
	void SetStrLists(const UI_OPTS_STRLIST* pStrLists, int nCntStrLists);
	void SetFNames(const UI_OPTS_FILENAME* pFNames, int nCntFNames);

	void AssertValid(void) const;

protected:
	HINSTANCE m_hInst;

	const UI_OPTS_BOOL* m_pBools;
	int m_nCntBools;

	const UI_OPTS_PICK* m_pPicks;
	int m_nCntPicks;

	const UI_OPTS_DWORD* m_pDwords;
	int m_nCntDwords;

	const UI_OPTS_STR* m_pStrs;
	int m_nCntStrs;

	const UI_OPTS_STRLIST* m_pStrLists;
	int m_nCntStrLists;

	const UI_OPTS_FILENAME* m_pFNames;
	int m_nCntFNames;

	void GetBoolOptions(CLocUIOptionSet* pOptionSet);
	void GetPicksOptions(CLocUIOptionSet* pOptionSet);
	void GetDwordsOptions(CLocUIOptionSet* pOptionSet);
	void GetStrsOptions(CLocUIOptionSet* pOptionSet);
	void GetStrListsOptions(CLocUIOptionSet* pOptionSet);
	void GetFNamesOptions(CLocUIOptionSet* pOptionSet);

	void GetListFromId(UINT nId, CPasStringList& pasList);
	void GetStringFromId(UINT nId, CPascalString& pas);
};

#pragma warning(default : 4275)

//
// Helper macros for building data structures
//
// The _EXT versions of the macros allow setting the less common
// attributes (readonly and visible)
//


// BOOL
#define BEGIN_LOC_UI_OPTIONS_BOOL(var) \
const UI_OPTS_BOOL var[] =    \
{								 

#define LOC_UI_OPTIONS_BOOL_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, et}

#define LOC_UI_OPTIONS_BOOL_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, et}

#define END_LOC_UI_OPTIONS_BOOL() \
}                             



// Pick
#define BEGIN_LOC_UI_OPTIONS_PICK(var) \
const UI_OPTS_PICK var[] = \
{

#define LOC_UI_OPTIONS_PICK_ENTRY(name, def, add, list, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, add, list}

#define LOC_UI_OPTIONS_PICK_ENTRY_EXT(name, def, add, list, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, add, list}

#define END_LOC_UI_OPTIONS_PICK() \
}


// DWORD
#define BEGIN_LOC_UI_OPTIONS_DWORD(var) \
const UI_OPTS_DWORD var[] =    \
{								 

#define LOC_UI_OPTIONS_DWORD_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault},def, et}

#define LOC_UI_OPTIONS_DWORD_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible},def, et}

#define END_LOC_UI_OPTIONS_DWORD() \
}


// String
#define BEGIN_LOC_UI_OPTIONS_STR(var) \
const UI_OPTS_STR var[] =    \
{								 

#define LOC_UI_OPTIONS_STR_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, et}

#define LOC_UI_OPTIONS_STR_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, et}

#define END_LOC_UI_OPTIONS_STR() \
}


// String List
#define BEGIN_LOC_UI_OPTIONS_STRLIST(var) \
const UI_OPTS_STRLIST var[] =    \
{								 

#define LOC_UI_OPTIONS_STRLIST_ENTRY(name, def, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def}

#define LOC_UI_OPTIONS_STRLIST_ENTRY_EXT(name, def, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def}

#define END_LOC_UI_OPTIONS_STRLIST() \
}

// File Names
#define BEGIN_LOC_UI_OPTIONS_FILENAME(var) \
const UI_OPTS_FILENAME var[] =    \
{								 

#define LOC_UI_OPTIONS_FILENAME_ENTRY(name, def, id, idHelp, idExt, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, idExt, def}

#define LOC_UI_OPTIONS_FILENAME_ENTRY_EXT(name, def, id, idHelp, idExt, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, idExt, def}

#define END_LOC_UI_OPTIONS_FILENAME() \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\uioptions.inl ===
//-----------------------------------------------------------------------------
//  
//  File: uioptions.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------




inline
CLocUIOption::CLocUIOption()
{
	m_hDescDll = NULL;
	m_hHelpDll = NULL;
	m_idsDesc = 0;
	m_idsHelp = 0;
	m_etEditor = etNone;

	m_wStorageTypes = 0;
	m_uiDisplayOrder = 0;

	m_pParent = NULL;
}



inline
void
CLocUIOption::SetDescription(
		const HINSTANCE hDll,
		UINT nDescriptionID)
{
	m_hDescDll = hDll;
	m_idsDesc = nDescriptionID;
}



inline
void
CLocUIOption::SetHelpText(
		const HINSTANCE hDll,
		UINT nHelpTextId)
{
	m_hHelpDll = hDll;
	m_idsHelp = nHelpTextId;
}



inline
void
CLocUIOption::SetEditor(
		EditorType et)
{
	m_etEditor = et;
}


inline
void
CLocUIOption::SetStorageTypes(
		WORD wStorageTypes)
{
	m_wStorageTypes = wStorageTypes;
}



inline 
CLocUIOption::EditorType
CLocUIOption::GetEditor(void) 
		const
{
	return m_etEditor;
}



inline
void
CLocUIOption::GetDescription(
		CLString &strDesc)
		const
{
	LTASSERT(m_hDescDll != NULL);
	LTASSERT(m_idsDesc != 0);
	
	strDesc.LoadString(m_hDescDll, m_idsDesc);
}



inline
void
CLocUIOption::GetHelpText(
		CLString &strHelp)
		const
{
	LTASSERT(m_hHelpDll != NULL);
	LTASSERT(m_idsHelp != 0);

	strHelp.LoadString(m_hHelpDll, m_idsHelp);
}



inline
WORD
CLocUIOption::GetStorageTypes(void)
		const
{
	return m_wStorageTypes;
}



inline
void
CLocUIOption::SetParent(
		CLocUIOptionSet *pParent)
{
	m_pParent = pParent;
}



inline
const CLocUIOptionSet *
CLocUIOption::GetParent(void)
		const
{
	return m_pParent;
}



inline
const CLocUIOptionData &
CLocUIOption::GetOptionValues(void) const
{
	return m_Values;
}



inline
CLocUIOptionData &
CLocUIOption::GetOptionValues(void)
{
	return m_Values;
}

inline
void CLocUIOptionDef::SetReadOnly(
	ControlType ct)
{
	m_ctReadOnly = ct;		
}	

inline
void CLocUIOptionDef::SetVisible(
	ControlType ct)
{
	m_ctVisible = ct;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\uioptions.h ===
//-----------------------------------------------------------------------------
//  
//  File: uioptions.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


class CReport;

#pragma warning(disable : 4251)

class LTAPIENTRY CLocUIOptionData
{
public:

	enum OptVal
	{
		ovCurrent,
		ovDefault,
		ovUser,
		ovOverride
	};
	
	CLocOptionVal *GetOptionValue(OptVal);

	CLocOptionVal *GetOptionValue(OptVal) const;
	
	void SetOptionValue(OptVal, CLocOptionVal *);
	BOOL Purge(void);
	
private:
	SmartRef<CLocOptionVal> m_spCurrentVal;
	SmartRef<CLocOptionVal> m_spUserVal;
	SmartRef<CLocOptionVal> m_spOverrideVal;
};


class CLocUIOptionSet;

class LTAPIENTRY CLocUIOption: public CLocOptionVal
{
public:
	CLocUIOption();

	void AssertValid(void) const;

	//
	//  New editor types should go at the END, so that old parsers
	//  can still use the ENUM without being re-compiled..
	//
	enum EditorType
	{
		etNone,
		etInteger,						// Maps to lvtInteger
		etUINT,							// Maps to lvtInteger
		etString,						// Maps to lvtString
		etFileName,						// Maps to lvtFileName
		etDirName,						// Maps to lvtString
		etStringList,					// Maps to lvtStringList
		etPickOne,						// Maps to lvtStringList
		etCheckBox,						// Maps to lvtBOOL
		etTrueFalse,					// Maps to lvtBOOL
		etYesNo,						// Maps to lvtBOOL
		etOnOff,						// Maps to lvtBOOL
		etCustom,						// Custom editor
	};

	//
	//  Used as bit flags to indicate where the option can be stored.
	enum StorageType
	{
		stUser = 0x0001,
		stOverride = 0x0002
	};

	enum OptionCode
	{
		ocNoError,
		ocUnknownOption,
		ocInvalidValue,
		ocInvalidType
	};

	void NOTHROW SetDescription(const HINSTANCE hDll, UINT nDescriptionID);
	void NOTHROW SetHelpText(const HINSTANCE hDll, UINT nHelpTextId);
	void NOTHROW SetEditor(EditorType);
	void NOTHROW SetStorageTypes(WORD);
	void NOTHROW SetDisplayOrder(UINT);
	
	void NOTHROW GetDescription(CLString &) const;
	void NOTHROW GetHelpText(CLString &) const;
	EditorType NOTHROW GetEditor(void) const;
	WORD NOTHROW GetStorageTypes(void) const;
	UINT NOTHROW GetDisplayOrder(void) const;
	CLocUIOptionData::OptVal GetOptionValLocation(void) const;
	
	virtual BOOL IsReadOnly(void) const = 0;
	virtual BOOL IsVisible(void) const = 0;
	virtual const CLString &GetGroupName(void) const = 0;
	virtual OptionCode ValidateOption(CReport *, 
		const CLocVariant& var) const = 0;
	virtual void FormatDisplayString(const CLocVariant& var, 
		CLString& strOut, BOOL fVerbose = FALSE) = 0;
	virtual void EditCustom(CWnd* pWndParent, CLocVariant& var) = 0;

protected:
	virtual ~CLocUIOption();

	friend class CLocUIOptionSet;
	friend class CLocOptionManager;
	friend class CUpdateOptionValCallback;
	
	void SetParent(CLocUIOptionSet *);
	const CLocUIOptionSet *GetParent(void) const;

	const CLocUIOptionData &GetOptionValues(void) const;
	CLocUIOptionData &GetOptionValues(void);
	
private:
	HINSTANCE m_hDescDll, m_hHelpDll;
	UINT m_idsDesc, m_idsHelp;
	EditorType m_etEditor;
	WORD m_wStorageTypes;
	UINT m_uiDisplayOrder;
	
	CLocUIOptionSet *m_pParent;
	CLocUIOptionData m_Values;
};


// Validate callback function
// This function will be called during the ValidateOption handling.

typedef CLocUIOption::OptionCode (*PFNOnValidateUIOption)
	(const CLocUIOption *pOption, CReport *pReport, const CLocVariant&);
 
class LTAPIENTRY CLocUIOptionDef : public CLocUIOption
{
public:
	CLocUIOptionDef();
	
	enum ControlType
	{
		ctDefault,
		ctAlways,
		ctNever
	};
	
	void SetReadOnly(ControlType);
	void SetVisible(ControlType);
	
	virtual BOOL IsReadOnly(void) const;
	virtual BOOL IsVisible(void) const;
	virtual const CLString &GetGroupName(void) const;
	virtual OptionCode ValidateOption(CReport *, 
		const CLocVariant& var) const;
	virtual void FormatDisplayString(const CLocVariant& var, 
		CLString& strOut, BOOL fVerbose = FALSE);
	virtual void EditCustom(CWnd* pWndParent, CLocVariant& var);

	void SetValidationFunction(PFNOnValidateUIOption);
	
private:
	ControlType m_ctReadOnly;
	ControlType m_ctVisible;
	PFNOnValidateUIOption m_pfnValidate;
};

	

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUIOptionList :
	public CTypedPtrList<CPtrList, CLocUIOption *>
{
public:
	NOTHROW CLocUIOptionList();

	void AssertValid(void) const;

	NOTHROW ~CLocUIOptionList();
 
private:
	CLocUIOptionList(const CLocUIOptionList &);

	void operator=(const CLocUIOptionList &);
};

#pragma warning(default: 4275 4251)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uioptions.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\uioptset.h ===
//-----------------------------------------------------------------------------
//  
//  File: uioptset.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class CLocUIOption;
class CLocUIOptionList;

class LTAPIENTRY CLocUIOptionEnumCallback : public CObject
{
public:
	CLocUIOptionEnumCallback() {};

	void AssertValid(void) const;
			
	virtual BOOL ProcessOption(CLocUIOption *) = 0;
	virtual BOOL ProcessOption(const CLocUIOption *) = 0;
	
private:
	CLocUIOptionEnumCallback(const CLocUIOptionEnumCallback &);
	void operator=(int);
};


class LTAPIENTRY CLocUIOptionSet;

class LTAPIENTRY CLocUIOptionSetList :
	public CTypedPtrList<CPtrList, CLocUIOptionSet *>
{
public:
	NOTHROW CLocUIOptionSetList() {};

	void AssertValid(void) const;

	NOTHROW ~CLocUIOptionSetList();

private:
	CLocUIOptionSetList(const CLocUIOptionSetList &);
	void operator=(const CLocUIOptionSetList &);
};


//
//  This is used to control the order of the tabs displayed in the options
//  dialog.
enum OptionSetDisplayOrder
{
	osDefault = 50
};



class LTAPIENTRY CLocUIOptionSet : public CRefCount, public CObject
{
public:
	NOTHROW CLocUIOptionSet();

	void AssertValid(void) const;
	
	NOTHROW void AddOption(CLocUIOption *);
	NOTHROW void AddOptionSet(CLocUIOptionSet *);
	NOTHROW void RemoveOptionSet(const TCHAR *);
	
	NOTHROW const CLocUIOptionList & GetOptionList(void) const;
	NOTHROW const CLocUIOptionSetList & GetOptionSets(void) const;
	NOTHROW BOOL FindUIOption(const TCHAR *, CLocUIOption *&pOption);
	NOTHROW BOOL FindUIOption(const TCHAR *, const CLocUIOption *&pOption) const;
	
	NOTHROW void SetDescription(const HINSTANCE hDescDll, UINT idsDesc);
	NOTHROW void SetDescription(const CLString &);
	NOTHROW void SetHelpText(const HINSTANCE hHelpDll, UINT idsHelp);
	NOTHROW void SetHelpText(const CLString &);
	NOTHROW void SetHelpID(UINT);
	void SetGroupName(const TCHAR *);
	NOTHROW void SetDisplayOrder(UINT);
	
	NOTHROW void GetDescription(CLString &) const;
	NOTHROW void GetHelpText(CLString &) const;
	NOTHROW UINT GetHelpID(void) const;
	NOTHROW BOOL IsEmpty(void) const;
	const CLString &GetGroupName(void) const;
	NOTHROW UINT GetDisplayOrder(void) const;
	
	virtual BOOL IsReadOnly(void) const = 0;
	virtual BOOL IsVisible(void) const = 0;
		
	BOOL EnumOptions(CLocUIOptionEnumCallback *);
	BOOL EnumOptions(CLocUIOptionEnumCallback *) const;
	
	virtual void OnChange(void) const = 0;
	
protected:
	NOTHROW virtual ~CLocUIOptionSet();

	void SetParent(const CLocUIOptionSet *);
	const CLocUIOptionSet *GetParent(void) const;

private:
	CLocUIOptionList m_olOptions;
	CLocUIOptionSetList m_oslSubOptions;
	CLString m_strDesc, m_strHelp;
	UINT m_idHelp;
	const CLocUIOptionSet *m_pParent;
	CLString m_strGroup;
	UINT m_uiDisplayOrder;
	
	CLocUIOptionSet(const CLocUIOptionSet &);
	void operator=(const CLocUIOptionSet &);
};


class LTAPIENTRY CLocUIOptionSetDef : public CLocUIOptionSet
{
public:
	CLocUIOptionSetDef();

	enum ControlType
	{
		ctDefault,
		ctAlways,
		ctNever
	};
	
	void SetReadOnly(ControlType);
	void SetVisible(ControlType);

	virtual BOOL IsReadOnly(void) const;
	virtual BOOL IsVisible(void) const;

	virtual void OnChange(void) const;

	const CLocUIOptionSetDef & operator=(const CLocUIOptionSetDef &);
	
private:
	ControlType m_ctReadOnly;
	ControlType m_ctVisible;
};

#pragma warning(default: 4275)
 
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uioptset.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\uioptset.inl ===
//-----------------------------------------------------------------------------
//  
//  File: uioptset.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline		
void
CLocUIOptionSet::AddOption(
		CLocUIOption *pOption)
{
	m_olOptions.AddTail(pOption);

	pOption->SetParent(this);
}



inline
void
CLocUIOptionSet::AddOptionSet(
		CLocUIOptionSet *pOptionSet)
{
	m_oslSubOptions.AddTail(pOptionSet);

	pOptionSet->SetParent(this);
}


inline
const CLocUIOptionList &
CLocUIOptionSet::GetOptionList(void)
		const
{
	return m_olOptions;
}


inline
const CLocUIOptionSetList &
CLocUIOptionSet::GetOptionSets(void)
		const
{
	return m_oslSubOptions;
}



inline
const CLString &
CLocUIOptionSet::GetGroupName(void)
		const
{
	if (GetParent() != NULL)
	{
		return GetParent()->GetGroupName();
	}
	else
	{
		return m_strGroup;
	}
}

inline
UINT 
CLocUIOptionSet::GetDisplayOrder()
	 const
{
	return m_uiDisplayOrder;	
}	


inline
void
CLocUIOptionSet::SetDescription(
		const HINSTANCE hDll,
		UINT idsDesc)
{
	m_strDesc.LoadString(hDll, idsDesc);
}



inline
void
CLocUIOptionSet::SetDescription(
		const CLString &strDesc)
{
	m_strDesc = strDesc;
}


inline
void
CLocUIOptionSet::SetHelpText(
		const HINSTANCE hDll,
		UINT idsHelp)
{
	m_strHelp.LoadString(hDll, idsHelp);
}



inline
void
CLocUIOptionSet::SetHelpID(UINT uiHelpId)
{
	m_idHelp = uiHelpId;
}



inline
void
CLocUIOptionSet::SetGroupName(
		const TCHAR *szGroupName)
{
	m_strGroup = szGroupName;
}




inline
void
CLocUIOptionSet::SetHelpText(
		const CLString &strHelp)
{
	m_strHelp = strHelp;
}



inline
void
CLocUIOptionSet::GetDescription(
		CLString &strDesc)
		const
{
	strDesc = m_strDesc;
}



inline
void
CLocUIOptionSet::GetHelpText(
		CLString &strHelp)
		const
{
	strHelp = m_strHelp;
}



inline
UINT
CLocUIOptionSet::GetHelpID(void)
		const
{
	return m_idHelp;
}



inline
BOOL
CLocUIOptionSet::IsEmpty(void)
		const
{
	return m_olOptions.IsEmpty() && m_oslSubOptions.IsEmpty();
}


inline
void
CLocUIOptionSet::SetParent(
		const CLocUIOptionSet *pParent)
{
	m_pParent = pParent;
}

inline
void 
CLocUIOptionSet::SetDisplayOrder(
	UINT uiDisplayOrder)
{
	m_uiDisplayOrder = uiDisplayOrder;
}	


inline
const
CLocUIOptionSet *
CLocUIOptionSet::GetParent(void)
		const
{
	return m_pParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\worddiff.inl ===
//-----------------------------------------------------------------------------
//  
//  File: worddiff.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Implementation of CWordDiff
//-----------------------------------------------------------------------------
 
#include "ltdebug.h"

inline
CWordDiff::CWordDiff(
	CDifference::ChangeType type, 
	int nOldPos,
	int nNewPos,
	bool bIsFirst,
	bool bIsLast,
	_bstr_t bstrWord,
	const wchar_t * pwszPrefix,
	const wchar_t * pwszSufix) :
	m_ChangeType(type), m_Word(bstrWord), m_pwszPrefix(pwszPrefix),
	m_pwszSufix(pwszSufix), m_bIsFirst(bIsFirst), m_bIsLast(bIsLast),
	m_nOldPos(nOldPos), m_nNewPos(nNewPos)

{
	LTASSERT(pwszPrefix != NULL);
	LTASSERT(pwszSufix != NULL);
	LTASSERT(nOldPos >= -1);
	LTASSERT(nNewPos >= -1);
}

inline
CDifference::ChangeType 
CWordDiff::GetChangeType() 
const
{
	return m_ChangeType;
}

inline
const wchar_t * 
CWordDiff::GetUnit() 
const
{
	return m_Word;
}

inline
int 
CWordDiff::GetOldUnitPosition() 
const 
{
	return m_nOldPos;
}

inline
int 
CWordDiff::GetNewUnitPosition() 
const
{
	return m_nNewPos;
}

inline
const wchar_t * 
CWordDiff::GetPrefix() 
const
{
	return m_pwszPrefix;
}

inline
const wchar_t * 
CWordDiff::GetSufix() 
const
{
	return m_pwszSufix;
}

inline
bool 
CWordDiff::IsFirst() 
const
{
	return m_bIsFirst;
}

inline
bool 
CWordDiff::IsLast() 
const
{
	return m_bIsLast;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parseman\pdesc.h ===
//-----------------------------------------------------------------------------
//  
//  File: pdesc.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PARSEMAN_PDESC_H
#define PARSEMAN_PDESC_H

typedef CTypedPtrList<CPtrList, EnumInfo *> FileDescriptionList;

//
//  This class is used to gather all the file descriptions before
//  we write them into the registry.  
//
class CFileDescriptionsCallback : public CEnumCallback
{
public:
	CFileDescriptionsCallback();
	
	BOOL ProcessEnum(const EnumInfo &);
	
	const FileDescriptionList &GetFileDescriptions(void) const;
	
	~CFileDescriptionsCallback();
	
private:
	FileDescriptionList m_FileDescriptions;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parseman\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by parseman.rc
//
#define IDS_PARSEMAN_CONTEXT            12700
#define IDS_BAD_VERSION                 12701
#define IDS_FILT_ALL_FILES              12702
#define IDS_DEBUG_MISMATCH              12703

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\worddiff.h ===
//-----------------------------------------------------------------------------
//  
//  File: worddiff.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of the CWordDiff
//-----------------------------------------------------------------------------
 
#ifndef WORDDIFF_H
#define WORDDIFF_H

typedef _bstr_t CWordUnit;

class CWordDiff : public CDifference
{
public:
	CWordDiff(ChangeType type, 
		int nOldPos,
		int nNewPos,
		bool bIsFirst,
		bool bIsLast,
		_bstr_t bstrWord,
		const wchar_t * pwszPrefix,
		const wchar_t * pwszSufix);

	virtual ChangeType GetChangeType() const;	// types of change that caused the difference
	virtual const wchar_t * GetUnit() const; // comparison unit (0-terminated string)
	virtual int GetOldUnitPosition() const; // 0-based position in old sequence. -1 if Added
	virtual int GetNewUnitPosition() const;	// 0-based position in new sequence. -1 if Deleted
	virtual const wchar_t * GetPrefix() const; //prpend this string to unit string
	virtual const wchar_t * GetSufix() const; //append this string to unit string
	virtual bool IsFirst() const; //is this first difference in delta?
	virtual bool IsLast() const; //is this last difference in delta?

private:
	ChangeType m_ChangeType;
	CWordUnit m_Word;
	const wchar_t * m_pwszPrefix;
	const wchar_t * m_pwszSufix;
	bool m_bIsFirst;
	bool m_bIsLast;
	int m_nOldPos;
	int m_nNewPos;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "worddiff.inl"
#endif

#endif  //  WORDDIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parseman\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>
#include <afxtempl.h>

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parseman\pinfo.h ===
//-----------------------------------------------------------------------------
//  
//  File: pinfo.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Class that holds information about a parser.
//  
//-----------------------------------------------------------------------------
 
#ifndef PINFO_H
#define PINFO_H


class CLocParserManager;

class CLocParserInfo;
typedef CTypedPtrList<CPtrList, CLocParserInfo *> CLocParserList;

#pragma warning(disable : 4251)

interface ILocParser;
interface ILocStringValidation;

class LTAPIENTRY CLocParserInfo : public CLObject
{
public:

	void AssertValid(void) const;

	const CLString &GetParserName(void) const;
	const CLString &GetParserDescription(void) const;
	const CLString &GetParserHelp(void) const;
	ParserId GetParserId(void) const;
	BOOL GetDllVersion(CLString &) const;
	const CLocExtensionList &GetExtensionList() const;
	const CLocParserList &GetSubParserList(void) const;

	~CLocParserInfo();

protected:
	friend CLocParserManager;
	
	CLocParserInfo();

	HINSTANCE GetParserHandle(void) const;
	ILocParser * GetParserPointer(void) const;
	ILocStringValidation *GetValidationPointer(void);
	
	BOOL LoadParserDll(void);
	BOOL InitSubParsers(ILocParser *);
	
	BOOL FreeParserDll(void);
	BOOL AttemptUnload(void);
	
	BOOL IsLoaded(void) const;
	
	void SetParserName(const CLString &);
	void SetParserDescription(const CLString &);
	void SetParserHelp(const CLString &);
	
	void SetParserId(ParserId);
	BOOL SetExtensionList(const CLString  &);
	void AddSubParser(CLocParserInfo *);
	void AddExtensions(const CLocExtensionList &);
	CLocParserList &GetSubParserList(void);

	clock_t GetLastAccessTime(void) const;
	
	static BOOL LoadParserDll(const CLString &strFileName,
			CReporter *pReporter, HMODULE &hDll, ILocParser *&pLocParser);
	static BOOL GetParserObjects(CReporter *, CLoadLibrary &, ILocParser *&);
	
private:
	
	CLString m_strParserName;
	CLString m_strParserDescription;
	CLString m_strParserHelp;
	CLocExtensionList m_elExtList;
	ParserId m_pidParserId;
	HINSTANCE m_hParserDll;
	ILocParser *m_pParserObject;
	ILocStringValidation *m_pValidationObject;
	BOOL m_fLoadAttempted;
	BOOL m_fValidationTried;
	UINT m_uiSubParserUsageCount;
	mutable clock_t m_tLastAccess;
	
	CLocParserList m_pSubParsers;
};

#pragma warning(default : 4251)



#endif  // PINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parseman\unloader.h ===
//-----------------------------------------------------------------------------
//  
//  File: uloader.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

class CParserUnloader : public CFlushMemory
{
public:
	CParserUnloader(BOOL fDelete);
	
	void FlushMemory(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parseman\pmanager.h ===
//-----------------------------------------------------------------------------
//  
//  File: pmanager.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Owner: MHotchin
//  
//-----------------------------------------------------------------------------
 
#ifndef PMANAGER_H
#define PMANAGER_H


#pragma warning(disable : 4251)

typedef CTypedPtrMap<CMapWordToPtr, ParserId, CLocParserInfo *> CLocParserMap;
typedef CTypedPtrMap<CMapStringToPtr, CString, CLocParserList *> CLocExtMap;
typedef CTypedPtrList<CPtrList, EnumInfo *> FileDescriptionList;

interface ILocFile;
struct ParserInfo;

class CParserUnloader;

class LTAPIENTRY CLocParserManager : public CLObject
{
	friend CLocParserInfo;
public:
	CLocParserManager();
	
	void AssertValid(void) const;
	
	BOOL InitParserManager(IUnknown *);
	static BOOL ReloadRegistry(void);
	static void UnloadParsers(void);
	static void UnloadUnusedParsers(void);
	
	static void GetManagerVersion(DWORD &dwMajor, DWORD &dwMinor, BOOL &fDebug);
	static BOOL AddParserToSystem(const CLString &);
	static const CLocParserInfo *GetParserInfo(ParserId pid, ParserId pidParent);
	static BOOL RemoveParserFromSystem(ParserId pid, ParserId pidParent);
	static UINT FindParsers(void);
	
	static BOOL GetLocParser(ParserId, ILocParser *&);
	static BOOL GetLocFile(const CFileSpec &, ParserId, FileType,
			ILocFile *&, CReporter &);
	static BOOL FindLocFile(const CPascalString &, CLocParserIdArray &);
	static BOOL GetStringValidation(ParserId, ILocStringValidation *&);
	
	static const CLocParserList &GetParserList(void);

	static void GetParserFilterString(CLString &);

	~CLocParserManager();

protected:
	static void RemoveCurrentInfo(void);
	static BOOL LoadParserInfo(const HKEY &, CLocParserInfo *&);
	static BOOL LoadMasterParserInfo(const HKEY &);
	static BOOL LoadSubParsers(const HKEY &, CLocParserInfo *);
	static BOOL WriteFileTypes(const HKEY &, const FileDescriptionList &);
	
	static BOOL OpenParserSubKey(HKEY &, ParserId, ParserId);
	static BOOL AddParserToRegistry(const CLString &, const ParserInfo &,
			const FileDescriptionList &);

	static void AddToFilter(const CLocParserInfo *, const CLocExtensionList &);

private:
	static LONG             m_lRefCount;    // 
	static CLocParserMap    m_ParserMap;    // Associative map, ID -> Parser.
	static CLocParserList   m_ParserList;   // List of open parser DLL's.
	static CLocParserList   m_SubParserList;// list of all sub-parsers.
	static CLocExtMap       m_ExtensionMap;	// Associative map, extension->parser.
	static CLString         m_strFilter;    // Filter list for parser files.
	static IUnknown *       m_pUnknown;
	static CParserUnloader  m_Unloader;
};


//
//  Undecorated versions of these functions for GetProcAddress users...
//
extern "C"
{
	LTAPIENTRY HRESULT AddParserToSystem(const TCHAR *strFileName);
	LTAPIENTRY HRESULT RemoveParserFromSystem(ParserId pid, ParserId pidParent);
}

		
#pragma warning(default : 4251)

#endif // PMANAGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\locbinary.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocBinary.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCBINARY_H)
#define PARSUTIL_LOCBINARY_H


#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocBinary : public ILocBinary, public CPULocChild
{
// Construction
public:
	CPULocBinary(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//
	// ILocBinary interface
	//
	BOOL STDMETHODCALLTYPE CreateBinaryObject(BinaryId,	CLocBinary * REFERENCE);
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\locchild.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocChild.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCCHILD_H)
#define PARSUTIL_LOCCHILD_H


#pragma warning(disable : 4275)


class CPULocParser;

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocChild : public CLUnknown, public CLObject
{
// Construction
public:
	CPULocChild(CPULocParser * pParent);
	virtual ~CPULocChild();

// Data
private:
	CPULocParser * m_pParent;

// Attributes
public:
	CPULocParser * GetParent() const;

// COM Interfaces
public:

// Overrides
public:

// Implementation
protected:

	//  CLObject

	virtual void AssertValid(void) const;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\parsutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: ParsUtil.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------

#if !defined (__ParsUtil_h__)
#define __ParsUtil_h__

void IncrementClassCount();
void DecrementClassCount();

extern HMODULE g_hDll;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by PARSUTIL.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxcoll.h>		// MFC collection support
#include <afxtempl.h>		// MFC template support

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\locversion.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocVersion.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCVERSION_H)
#define PARSUTIL_LOCVERSION_H

#include "LocChild.h"

#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocVersion : public CPULocChild, public ILocVersion
{
// Construction
public:
	CPULocVersion(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocVersion
	void STDMETHODCALLTYPE GetParserVersion(DWORD &dwMajor, DWORD &dwMinor,
			BOOL &fDebug) const;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\locstrval.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocStrVal.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCSTRVAL_H)
#define PARSUTIL_LOCSTRVAL_H

#include "LocChild.h"

#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocStringValidation : public CPULocChild, public ILocStringValidation
{
// Construction
public:
	CPULocStringValidation(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocStringValidation
	CVC::ValidationCode STDMETHODCALLTYPE ValidateString(
			const CLocTypeId &ltiType, const CLocTranslation &trTrans,
			CReporter *pReporter, const CContext &context);
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\locparser.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocParser.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCPARSER_H)
#define PARSUTIL_LOCPARSER_H


#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocParser : public ILocParser, public CLObject
{
// Construction
public:
	CPULocParser(HINSTANCE hDll);
	virtual ~CPULocParser();

// Data
private:
	ULONG				m_ulRefCount;	// COM reference count
	HINSTANCE			m_hInst;		// Instance Handle

	BOOL				m_fEnableVersion;
	BOOL				m_fEnableBinary;
	BOOL				m_fEnableStrVal;

// COM Interfaces
public:

	//  IUnknown standard interface.
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID * ppvObj);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocParser interface implementation
	HRESULT STDMETHODCALLTYPE Init(IUnknown *);
	HRESULT STDMETHODCALLTYPE CreateFileInstance(ILocFile * REFERENCE, FileType);
	void STDMETHODCALLTYPE GetParserInfo(ParserInfo &) const;
	void STDMETHODCALLTYPE GetFileDescriptions(CEnumCallback &) const;

// Operations
public:

// Implementation
protected:
	BOOL EnableInterface(REFIID riid, BOOL fEnable = TRUE);
	virtual BOOL IsInterfaceEnabled(REFIID riid) const;

// Overrides
public:

	// IUnknown
	virtual HRESULT OnQueryInterface(REFIID riid, LPVOID * ppvObj);

	// ILocParser
	virtual HRESULT OnInit(IUnknown *);
	virtual HRESULT OnCreateFileInstance(ILocFile * &, FileType) = 0;
	virtual void OnGetParserInfo(ParserInfo &) const = 0;
	virtual void OnGetFileDescriptions(CEnumCallback &) const = 0;

	// ILocVersion
	virtual void OnGetParserVersion(DWORD &dwMajor,	DWORD &dwMinor,
			BOOL &fDebug) const = 0;

	// ILocBinary
	virtual BOOL OnCreateBinaryObject(BinaryId id, CLocBinary * REFERENCE pBinary);

	// ILocStringValidation
	virtual CVC::ValidationCode OnValidateString(const CLocTypeId &ltiType,
			const CLocTranslation &, CReporter *pReporter,
			const CContext &context) = 0;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\pbase\idupdate.h ===
//-----------------------------------------------------------------------------
//  
//  File: idupdate.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PBASE_IDUPDATE_H
#define PBASE_IDUPDATE_H

extern const IID IID_ILocIDUpdate;

DECLARE_INTERFACE_(ILocIDUpdate, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  ID Update methods.
	//
	STDMETHOD_(BOOL, RequiresUpdate)(THIS_ FileType) PURE;
	STDMETHOD_(FileType, GetUpdatedFileType)(THIS_ FileType) PURE;

	STDMETHOD_(BOOL, GetOldUniqueId)(THIS_ CLocUniqueId REFERENCE) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\pbase\imgres32.h ===
//-----------------------------------------------------------------------------
//  
//  File: ImgRes32.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//	Declaration of ILocRes32Image. 
//	This interface allows to convert the localizable items of a resource 
//	into a res32 image, and viceversa.
//  
//-----------------------------------------------------------------------------

#ifndef IMGRES32_H
#define IMGRES32_H


struct Res32FontInfo
{
	WORD wLength;			//Structure length
	WORD wPointSize;		
	WORD wWeight;
	WORD wStyle;
	CPascalString pasName;
};

class CLocItemPtrArray;
class CFile;

extern const IID IID_ILocRes32Image;

DECLARE_INTERFACE_(ILocRes32Image, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//Builds a Res32 file image of a resource from the resource's CLocItem objects
	//Inputs:
	//	- A pointer to a CLocItemPtrArray object containing the CLocItem objects of
	//	a resource (like a dialog or a menu).
	//	- An array index to the root item of the resource.
	//	- An array index to the selected item of the resource.
	//	- The resource's language id.
	//	- A pointer to an existing empty CFile.
	//  - A pointer to a Res32FontInfo structure
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- The CFile object has the res32 image of the resource.
	//	- The CLocItemPtrArray object has its items ordered by physical
	//	location in the res32 image.	
	//Return:
	//	TRUE if the image was created successfully. FALSE, otherwise.
	STDMETHOD_(BOOL, MakeRes32Image)(THIS_ CLocItemPtrArray *, int, int, 
		LangId, CFile *, Res32FontInfo*, CLocItemHandler *) PURE;

	//Breaks the Res32 image of a resource into the corresponding CLocItem objects.
	//Inputs:
	//	- A pointer to a CFile object containing the res32 image of a resource.
	//	- The resource's language id.
	//	- A pointer to a CLocItemPtrArray containing the CLocItem objects of the
 	//	resource. The items are expected to be ordered by position in the res32 image.
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- The items in the CLocItemPtrArray object are updated with the new data from
 	//	the res32 image.
	//Return:
	//	TRUE if the imaged could be parsed and if the items could be updated successfully.
	//	FALSE, otherwise.
	STDMETHOD_(BOOL, CrackRes32Image)(THIS_ CFile *, LangId, CLocItemPtrArray *, CLocItemHandler *) PURE;
};



#endif  // IMGRES32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\pbase\binary.h ===
//-----------------------------------------------------------------------------
//  
//  File: Binary.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//  Class to hold 'binary' (non-string) information about a localizable item.
//  
//-----------------------------------------------------------------------------

#ifndef BINARY_H
#define BINARY_H


//
//  Binary interface.  Parsers provide an implementation of this in order
//  to create binary objects for other users.
//
extern const IID IID_ILocBinary;

DECLARE_INTERFACE_(ILocBinary, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(BOOL, CreateBinaryObject)(THIS_ BinaryId, CLocBinary *REFERENCE) PURE;
};



#endif  // BINARY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\pbase\iresobj.h ===
//-----------------------------------------------------------------------------
//  
//  File: IResObj.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//	Declaration of ILocRes32Image. 
//	This interface allows to convert the localizable items of a resource 
//	into a res32 image, and viceversa.
//  
//-----------------------------------------------------------------------------

#ifndef IRESOBJ_H
#define IRESOBJ_H


class CLocItemPtrArray;
class CFile;
class CResObj;
class CLocItem;

extern const IID IID_ICreateResObj;

DECLARE_INTERFACE_(ICreateResObj, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	// Creates a CResObj for win32 resoruce processing
	//Inputs:
	//	- A pointer to a CLocItem object containing the type and Id of the item
	//	- The size of the resource.
	//	- An void pointer to unknown data to be passed from enumeration to generate
	//Return:
	//	- A CResObj pointer or NULL if the type is not recognized
	STDMETHOD_(CResObj *, CreateResObj)(THIS_ CLocItem * pLocItem,
		DWORD dwSize, void * pvHeader) PURE;
};
#endif  // IRESOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\pbase\mnemonic.h ===
//-----------------------------------------------------------------------------
//  
//  File: Mnemonic.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//	Declaration of ILocMnemonics. 
//	This interface allows to retrieve the mnemonics (aka hotkeys) of a 
//	resource
//
//	Owner: EduardoF
//  
//-----------------------------------------------------------------------------

#ifndef MNEMONIC_H
#define MNEMONIC_H


extern const IID IID_ILocMnemonics;

DECLARE_INTERFACE_(ILocMnemonics, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//Gets the mnemonics (aka hotkeys) in the resource array of locitems.
	//Inputs:
	//	- A pointer to a CLocItemPtrArray object containing the CLocItem objects of
	//	a resource (like a dialog or a menu).
	//	- An array index to the root item of the resource.
	//	- An array index to the selected item of the resource.
	//	- The resource's language id.
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- A 'CHotkeysMap' map containing the mnemonics.
	//Return:
	//	TRUE if the mnemonics could be retrieved successfully. FALSE, otherwise.
	STDMETHOD_(BOOL, GetMnemonics)
			(THIS_ CLocItemPtrArray &, int, int, LangId, CReporter * pReporter, 
			CMnemonicsMap &) PURE;

};



#endif  // MNEMONIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\pbase\locfile.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocFile.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//  Operations we can perforn on a localizable file.
//  
//-----------------------------------------------------------------------------

#ifndef PBASE_LOCFILE_H
#define PBASE_LOCFILE_H


class CLocItemHandler;


extern const IID IID_ILocFile;


DECLARE_INTERFACE_(ILocFile, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  ILocFile methods.
	//
	STDMETHOD_(BOOL, OpenFile)(THIS_ const CFileSpec REFERENCE,
			CReporter REFERENCE) PURE;
	STDMETHOD_(FileType, GetFileType)(THIS) const PURE;
	STDMETHOD_(void, GetFileTypeDescription)(THIS_ CLString REFERENCE)
		const PURE;
	STDMETHOD_(BOOL, GetAssociatedFiles)(THIS_ CStringList REFERENCE)
		const PURE;

	STDMETHOD_(BOOL, EnumerateFile)(THIS_ CLocItemHandler REFERENCE,
			const CLocLangId &, const DBID REFERENCE) PURE;
	STDMETHOD_(BOOL, GenerateFile)(THIS_ const CPascalString REFERENCE,
			CLocItemHandler REFERENCE, const CLocLangId REFERENCE,
			const CLocLangId REFERENCE, const DBID REFERENCE) PURE;
};


#endif //  PBASE_LOCFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\pbase\pstrval.h ===
//-----------------------------------------------------------------------------
//  
//  File: pstrval.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  String Validation interface.
//
//  Owner: MHotchin
//  
//-----------------------------------------------------------------------------
 
#ifndef PBASE_PSTRVAL_H
#define PBASE_PSTRVAL_H

extern const IID IID_ILocStringValidation;

DECLARE_INTERFACE_(ILocStringValidation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(CVC::ValidationCode, ValidateString)
		(THIS_ const CLocTypeId REFERENCE, const CLocString REFERENCE,
				CReporter *) PURE;
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\pbase\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\pbase\parseapi.h ===
//-----------------------------------------------------------------------------
//  
//  File: parseapi.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Main interface to a file parser DLL.
//
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
#ifndef PARSEAPI_H
#define PARSEAPI_H


extern const IID IID_ILocParser;
extern const IID IID_ILocParser_20;

struct ParserInfo
{
	CArray<PUID, PUID &> aParserIds;
	CLString strDescription;
	CLocExtensionList elExtensions;
	CLString strHelp;
};


DECLARE_INTERFACE_(ILocParser, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  LocParser methods.
	//
	STDMETHOD(Init)(THIS_ IUnknown *) PURE;
	
	STDMETHOD(CreateFileInstance)(THIS_ ILocFile *REFERENCE, FileType) PURE;

	STDMETHOD_(void, GetParserInfo)(THIS_ ParserInfo REFERENCE)
		CONST_METHOD PURE;
	STDMETHOD_(void, GetFileDescriptions)(THIS_ CEnumCallback &)
		CONST_METHOD PURE;
};


//
//  Here for DOCUMENTATION only.  Implementors should export the following
//  functions from every Parser DLL.
//
static const char * szParserEntryPointName = "DllGetParserCLSID";
typedef void (STDAPICALLTYPE *PFNParserEntryPoint)(CLSID REFERENCE);

STDAPI_(void) DllGetParserCLSID(CLSID REFERENCE);


static const char * szParserRegisterEntryPointName = "DllRegisterParser";
typedef HRESULT (STDAPICALLTYPE *PFNParserRegisterEntryPoint)(void);

STDAPI DllRegisterParser(void);


static const char *szParserUnregisterEntryPointName = "DllUnregisterParser";
typedef HRESULT (STDAPICALLTYPE *PFNParserUnregisterEntryPoint)(void);

STDAPI DllUnregisterParser(void);

//
//  Implementors also need to implement the DllGetClassObject function.
//  An optional (but RECOMMENDED) function is DllCanUnloadNow.
//  See the OLE 2 reference manual for details about these functions.
//

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
STDAPI DllCanUnloadNow(void);


#endif // PARSEAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\pbase\pversion.h ===
//-----------------------------------------------------------------------------
//  
//  File: pversion.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PVERSION_H
#define PVERSION_H

extern const IID IID_ILocVersion;

extern const DWORD dwCurrentMajorVersion;
extern const DWORD dwCurrentMinorVersion;
#ifdef _DEBUG
const BOOL fCurrentDebugMode = TRUE;
#else
const BOOL fCurrentDebugMode = FALSE;
#endif

DECLARE_INTERFACE_(ILocVersion, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//
	//
	STDMETHOD_(void, GetParserVersion)(
			THIS_ DWORD REFERENCE dwMajor,
			DWORD REFERENCE dwMinor,
			BOOL REFERENCE fDebug)
		CONST_METHOD PURE;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\pbase\subparse.h ===
//-----------------------------------------------------------------------------
//  
//  File: SubParse.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef PBASE_SUBPARSE_H
#define PBASE_SUBPARSE_H


extern const IID IID_ILocSubParserManager;

typedef CTypedPtrArray<CPtrArray, ILocParser *> ILocSubParserArray;

DECLARE_INTERFACE_(ILocSubParserManager, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD(InitSubParsers)(THIS_ ILocSubParserArray REFERENCE)
		CONST_METHOD PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\prodver\prodver.h ===
#define rmj 4
#define rmm 2
#define rup 169
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\pbase\updatelog.h ===
//-----------------------------------------------------------------------------
//  
//  File: updatelog.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PBASE_UPDATELOG_H
#define PBASE_UPDATELOG_H


extern const IID IID_ILocUpdateLog;

DECLARE_INTERFACE_(ILocUpdateLog, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(BOOL, ReportItemDifferences)
		(THIS_ const CLocItem *pOldItem, const CLocItem *pNewItem,
				CItemInfo *, CLogFile *) PURE;
};


struct __declspec(uuid("{6005AF23-EE76-11d0-A599-00C04FC2C6D8}")) ILocUpdateLog;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\about.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       about.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "about.h"
#include "bitmap.h"

#define EDIT_CONTROL_CRLF  _T("\r\r\n")

//
// This file implements the About Properties used by the snap-in manager
//

CSnapinAbout::CSnapinAbout()
{
    TRACE_METHOD(CSnapinAbout, CSnapinAbout);

    CommonContruct();
}

void CSnapinAbout::CommonContruct()
{
    m_bBasicInfo = FALSE;
    m_bFullInfo = FALSE;
    m_cMask = RGB(0,0,0);
    m_hrObjectStatus = S_OK;
}


BOOL CSnapinAbout::GetInformation(CLSID& clsid, int nType)
{
    TRACE_METHOD(CSnapinAbout, GetInformation);

    if (m_bFullInfo == TRUE || m_bBasicInfo == TRUE)
    {
        TRACE(_T("Destroying old Snapin information\n"));

        // Preserve the snapin name, it can't be reloaded from
        // the snapin ISnapinAbout interface
        LPOLESTR strTemp = m_lpszSnapinName.Detach();
        CSnapinAbout::~CSnapinAbout();
        m_lpszSnapinName.Attach(strTemp);
    }

    m_bFullInfo = m_bBasicInfo = FALSE;

    // Create the interface and get the snap-in information
    ISnapinAboutPtr spAboutInfo;
    m_hrObjectStatus = spAboutInfo.CreateInstance(clsid, NULL, MMC_CLSCTX_INPROC);

    if (FAILED(m_hrObjectStatus))
        return FALSE;

    // Basic info (required to display snapin node)
    HBITMAP hbmSmallImage;
    HBITMAP hbmSmallImageOpen;
    HBITMAP hbmLargeImage;

    if (SUCCEEDED(spAboutInfo->GetStaticFolderImage (&hbmSmallImage,
													 &hbmSmallImageOpen,
													 &hbmLargeImage,
													 &m_cMask)))
    {
        /*
         * Bug 249817: The bitmaps are out parameters, so the caller (MMC)
         * should own them and be responsible for destroying them.
         * Unfortunately, the docs for ISnapinAbout::GetStaticFolderImage
         * specifically instruct the snap-in to destroy them when the
         * ISnapinAbout interface is released.  We have to make copies instead.
         */
        m_SmallImage     = CopyBitmap (hbmSmallImage);
        m_SmallImageOpen = CopyBitmap (hbmSmallImageOpen);
        m_LargeImage     = CopyBitmap (hbmLargeImage);
    }

    m_bBasicInfo = TRUE;

    if (nType == BASIC_INFO)
        return TRUE;

    // Full information (required for About box)

    HICON hTemp;

    /*
     * Bug 249817: The icon is an out parameter, so the caller (MMC)
     * should own it and be responsible for destroying it.
     * Unfortunately, the docs for ISnapinAbout::GetSnapinImage
     * specifically instruct the snap-in to destroy it when the
     * ISnapinAbout interface is released.  We have to make a copy instead.
     */
    if (SUCCEEDED(spAboutInfo->GetSnapinImage(&hTemp)))
        m_AppIcon.Attach(CopyIcon(hTemp));

    LPOLESTR strTemp;

    if (SUCCEEDED(spAboutInfo->GetSnapinDescription(&strTemp)))
        m_lpszDescription.Attach(strTemp);

    if (SUCCEEDED(spAboutInfo->GetProvider(&strTemp)))
        m_lpszCompanyName.Attach(strTemp);

    if (SUCCEEDED(spAboutInfo->GetSnapinVersion(&strTemp)))
        m_lpszVersion.Attach(strTemp);

    m_bFullInfo = TRUE;

    return TRUE;
}


void CSnapinAbout::ShowAboutBox()
{
    TRACE_METHOD(CSnapinAbout, Show);

    CSnapinAboutDialog dlg(this);
    dlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CSnapinAboutPage message handlers

LRESULT CSnapinAboutDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // hook up controls
    DECLARE_SC(sc, TEXT("CSnapinAboutDialog::OnInitDialog"));
    sc = ScCheckPointers(m_pAboutInfo, E_UNEXPECTED);
    if (sc)
        return TRUE;

    // Title should be set "About <SnapinName>"
    // Raid# 661363: This does not work for some languages
    // where the <SnapinName> needs to appear after the equivalent
    // for "About". The fix is to obtain the title not by concatenation
    // but by string construction using the IDS_ABOUT resource as 
    // a format specifier. For English, for example, the format 
    // specifier is "About %s"

    // Format Specifier
    tstring szfmtAbout;
    bool bRet = szfmtAbout.LoadString(GetStringModule(), IDS_ABOUT);
    if (!bRet)
        return TRUE;

    USES_CONVERSION;
    // <Snapin Name>
    tstring szSnapin;
    LPCOLESTR lpszSnapinName = m_pAboutInfo->GetSnapinName();    
    if (lpszSnapinName)
    {
        szSnapin = OLE2CT(lpszSnapinName);
    }    
    else
    {
        bRet = szSnapin.LoadString(GetStringModule(), IDS_SNAPINSTR);
        if (!bRet)
            return TRUE;
    }

    // Construct the title
    WTL::CString szTitle;
    szTitle.Format (szfmtAbout.data(), szSnapin.data());

    SetWindowText(szTitle);
    
    HWND hwndSnapinInfo = ::GetDlgItem(*this, IDC_SNAPIN_INFO);

    sc = ScCheckPointers(hwndSnapinInfo, E_UNEXPECTED);
    if (sc)
        return TRUE;

    m_SnapinInfo.Attach(hwndSnapinInfo);

    if (lpszSnapinName)
    {
        m_SnapinInfo.AppendText(OLE2CT(lpszSnapinName));
        m_SnapinInfo.AppendText(EDIT_CONTROL_CRLF);
    }

    LPCOLESTR lpszCompanyName = m_pAboutInfo->GetCompanyName();
    if (lpszCompanyName)
    {
        m_SnapinInfo.AppendText(OLE2CT(lpszCompanyName));
        m_SnapinInfo.AppendText(EDIT_CONTROL_CRLF);
    }

    LPCOLESTR lpszVersion = m_pAboutInfo->GetVersion();
    if (lpszVersion)
    {
        tstring szVersion;
        bRet = szVersion.LoadString(GetStringModule(), IDS_VERSION);
        if (!bRet)
            return TRUE;

        m_SnapinInfo.AppendText(szVersion.data());
        m_SnapinInfo.AppendText(OLE2CT(lpszVersion));
    }

    HWND hwndSnapinDesc = ::GetDlgItem(*this, IDC_SNAPIN_DESC);
    sc = ScCheckPointers(hwndSnapinDesc, E_UNEXPECTED);
    if (sc)
        return TRUE;

    m_SnapinDesc.Attach(hwndSnapinDesc);

    LPCOLESTR lpszDescription = m_pAboutInfo->GetDescription();

    sc = ScSetDescriptionUIText(m_SnapinDesc, lpszDescription ? OLE2CT(lpszDescription) : _T(""));
    if (sc)
        return TRUE;

    // App icon
    HICON hAppIcon = m_pAboutInfo->GetSnapinIcon();
    if (hAppIcon)
    {
        HWND const icon = ::GetDlgItem(*this, IDC_APPICON);
        ASSERT(icon != NULL);
        m_hIcon.Attach(icon);
        m_hIcon.SetIcon(hAppIcon);
    }

    return TRUE;
}


LRESULT
CSnapinAboutDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndDialog(IDOK);
    return TRUE;
}

LRESULT
CSnapinAboutDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndDialog(IDCANCEL);
    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:      ScSetDescriptionUIText
//
//  Synopsis:    Given a edit control window & description text. Insert
//               the text into the control and enable scrollbar if needed.
//
//  Arguments:   [hwndSnapinDescEdit] - The edit control window handle.
//               [lpszDescription]    - The description text (cant be NULL).
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC ScSetDescriptionUIText(HWND hwndSnapinDescEdit, LPCTSTR lpszDescription)
{
    DECLARE_SC(sc, TEXT("ScSetDescriptionUIText"));
    sc = ScCheckPointers(hwndSnapinDescEdit, lpszDescription);
    if (sc)
        return sc;

    // 1. Attach the window to WTL::CEdit object.
    WTL::CEdit wndsnapinDesc(hwndSnapinDescEdit);

    // 2. Insert the text into the window.
    wndsnapinDesc.SetWindowText(lpszDescription);

	/*
	 * 3. The description control may need scroll bar.
	 *    This is determined below, if ( (# of lines * height of one line) > rectangle-height).
	 */

    // 3a)  turn-off scroll & do the calculation, so that scroll-bar width does not
    // modify linecount below.
    wndsnapinDesc.ShowScrollBar(SB_VERT, FALSE);

    WTL::CDC dc(wndsnapinDesc.GetWindowDC());
    if (dc.IsNull())
        return (sc = E_UNEXPECTED);

    TEXTMETRIC  tm;

    // 3b) Calculate height of a single line.
    HFONT hOldFont = dc.SelectFont(wndsnapinDesc.GetFont());
    dc.GetTextMetrics(&tm);
    int cyLineHeight = tm.tmHeight + tm.tmExternalLeading;

    // 3c) Calculate edit box dimensions in logical units.
    WTL::CRect rect;
    wndsnapinDesc.GetRect(&rect);
    dc.DPtoLP(&rect);

    int nLines = wndsnapinDesc.GetLineCount();

    // 3d) If the total text height exceeds edit box height so turn on scroll.
    if ( (nLines * cyLineHeight) > rect.Height())
        wndsnapinDesc.ShowScrollBar(SB_VERT, TRUE);

    dc.SelectFont(hOldFont);

	wndsnapinDesc.SetSel(0, 0);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\about.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       about.h
//
//--------------------------------------------------------------------------

#ifndef _ABOUT_H
#define _ABOUT_H

#include "util.h"

class CSnapinAbout;

SC ScSetDescriptionUIText(HWND hwndSnapinDescEdit, LPCTSTR lpszDescription);

/////////////////////////////////////////////////////////////////////////////
// CSnapinAboutDialog

class CSnapinAboutDialog : public CDialogImpl<CSnapinAboutDialog>
{
	typedef CSnapinAboutDialog               ThisClass;
    typedef CDialogImpl<CSnapinAboutDialog>  BaseClass;
public:
    enum { IDD = IDD_SNAPIN_ABOUT };

    CSnapinAboutDialog(CSnapinAbout *pSnapinAbout) : m_pAboutInfo(pSnapinAbout) {}

    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER    (WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER (IDOK,          OnOK)
        COMMAND_ID_HANDLER (IDCANCEL,      OnCancel)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK        (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
    CSnapinAbout*   m_pAboutInfo;

    WTL::CStatic    m_hIcon;
	WTL::CEdit      m_SnapinInfo;
	WTL::CEdit      m_SnapinDesc;
};

class CSnapinAbout
{
	// smart handle for icons
	class CIcon
	{
	public:
		CIcon() : m_hIcon(NULL) {}
		~CIcon() { DeleteObject(); }
	
		void Attach(HICON hIcon) { DeleteObject(); m_hIcon = hIcon; }
		operator HICON() { return m_hIcon; }
	
		void DeleteObject() { if (m_hIcon != NULL) ::DestroyIcon(m_hIcon); m_hIcon = NULL; }
	
	private:
		HICON m_hIcon;
	};
	
	// smart pointer for CoTaskMem allocated OLESTR
	typedef CCoTaskMemPtr<OLECHAR> CCtmOleStrPtr;

// Constructor/Destructor
public:
    CSnapinAbout();

// Interfaces
public:
    void    ShowAboutBox();
    BOOL    GetBasicInformation(CLSID& clsid)
                { return GetInformation(clsid, BASIC_INFO); }
    BOOL    GetSnapinInformation(CLSID& clsid)
                { return GetInformation(clsid, FULL_INFO); }
    BOOL    HasBasicInformation() {return m_bBasicInfo;}
    BOOL    HasInformation() {return m_bFullInfo;}
    void    GetSmallImages(HBITMAP* hImage, HBITMAP* hImageOpen, COLORREF* cMask)
            {
                *hImage     = m_SmallImage;
                *hImageOpen = m_SmallImageOpen;
                *cMask      = m_cMask;
            }

    void    GetLargeImage(HBITMAP* hImage, COLORREF* cMask)
            {
                *hImage = m_LargeImage;
                *cMask  = m_cMask;
            }

    const LPOLESTR  GetCompanyName() {return m_lpszCompanyName;};
    const LPOLESTR  GetDescription() {return m_lpszDescription;};
    const LPOLESTR  GetVersion() {return m_lpszVersion;};
    const LPOLESTR  GetSnapinName() {return m_lpszSnapinName;};
    const HICON     GetSnapinIcon() { return m_AppIcon; }
    const HRESULT   GetObjectStatus() { return m_hrObjectStatus; }

public: // Not published by about object, name derived from console
    void SetSnapinName(LPCOLESTR lpszName)
        {
            ASSERT(lpszName != NULL);
            m_lpszSnapinName.Delete(); // delete any existing name
            m_lpszSnapinName.Attach(CoTaskDupString(lpszName));
        }

private:
    void CommonContruct();

    enum INFORMATION_TYPE
    {
        BASIC_INFO,
        FULL_INFO
    };
    BOOL GetInformation(CLSID& clsid, int nType);

// Attributes
private:
    BOOL            m_bBasicInfo;       // TRUE if basic info is loaded
    BOOL            m_bFullInfo;        // TRUE if all snapin info is loaded

    CCtmOleStrPtr   m_lpszSnapinName;   // Snap-in name Note: this is not exposed by the snap-in.
    CCtmOleStrPtr   m_lpszCompanyName;  // Company Name (Provider)
    CCtmOleStrPtr   m_lpszDescription;  // Description box text
    CCtmOleStrPtr   m_lpszVersion;      // Version string

    CIcon           m_AppIcon;          // Property page icon
    WTL::CBitmap    m_SmallImage;       // Small image for scope and result pane
	WTL::CBitmap    m_SmallImageOpen;   // Open image for scope pane.
	WTL::CBitmap    m_LargeImage;       // Large image for result pane
    COLORREF        m_cMask;
    HRESULT         m_hrObjectStatus;     // Result from object creation
};

#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\addsnpin.cpp ===
// AddSnpIn.cpp : implementation file
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      AddSnpIn.cpp
//
//  Contents:  Add snapin manager
//
//  History:   20-Sept-96 WayneSc    Created
//--------------------------------------------------------------------------


#include "stdafx.h"
#include <stdio.h>
#include "winreg.h"
#include "macros.h"
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
#include "ndmgr.h"
#include "nodemgr.h"
#include "strings.h"

//using namespace AMC;
using namespace MMC_ATL;

#include "AddSnpIn.h"
#include "policy.h"
#include "msimodul.h"
#include "process.h"
#include "siprop.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define BITMAPS_COUNT 5

#define __PDC_UNAVAILABLE

#include "about.h"

// GUID for looking up snap-in components
const TCHAR* g_szMMCSnapInGuid = TEXT("{374F2F70-060F-11d2-B9A8-0060977B1D78}");

HRESULT AmcNodeWizard(MID_LIST NewNodeType, CMTNode* pNode, HWND hWnd);
void EnableButton(HWND hwndDialog, int iCtrlID, BOOL bEnable);

/////////////////////////////////////////////////////////////////////////////
#ifdef DBG
CTraceTag tagAboutInfoThread    (TEXT("Snapin Manager"), TEXT("CAboutInfo"));
CTraceTag tagSnapinManager      (TEXT("Snapin Manager"), TEXT("CSnapinManager"));
CTraceTag tagSnapinManagerThread(TEXT("Snapin Manager"), TEXT("Snapin Manager Thread"));
#endif //DBG
/////////////////////////////////////////////////////////////////////////////

//TEMP TEMP TEMP
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#ifndef __PDC_UNAVAILABLE

typedef struct tag_teststr
{
    TCHAR   szCLSID[64];
} TESTSTR;

static TESTSTR s_teststr[] =
{
 {_T("{12345601-EA27-11CF-ADCF-00AA00A80033}")},
 {_T("{19876201-EA27-11CF-ADCF-00AA00A80033}")},
 {_T("{1eeeeeee-d390-11cf-b607-00c04fd8d565}")},
};

#endif //__PDC_UNAVAILABLE


//############################################################################
//############################################################################
//
//  Debug routines
//
//############################################################################
//############################################################################

#ifdef DBG


void CSnapinInfoCache::Dump(void)
{

    TRACE(_T("===========Dump of SnapinInfoCache ===============\n"));
    POSITION pos = GetStartPosition();
    while(pos != NULL)
    {
        PSNAPININFO pSnapInfo;
        GUID clsid;
        TCHAR* pszAction;

        GetNextAssoc(pos, clsid, pSnapInfo);

        if (pSnapInfo->IsUsed() && (pSnapInfo->GetSnapIn() == NULL))
            pszAction = _T("Add");
        else if (!pSnapInfo->IsUsed() && (pSnapInfo->GetSnapIn() != NULL))
            pszAction = _T("Remove");
        else
            continue;

        TRACE(_T("\n"));
        TRACE(_T("%s: %s\n"), pSnapInfo->GetSnapinName(), pszAction);

        PEXTENSIONLINK pExt = pSnapInfo->GetExtensions();
        while (pExt)
        {
            if (pExt->IsChanged())
            {
                pszAction = pExt->GetState() ? _T("Add") : _T("Remove");
                TRACE(_T("   %s: %s\n"), pExt->GetSnapinInfo()->GetSnapinName(),pszAction);
            }
            pExt = pExt->Next();
        }
    }
}

#endif // DBG


//############################################################################
//############################################################################
//
//  Implementation of class CCheckList
//
//############################################################################
//############################################################################

LRESULT CCheckList::OnKeyDown( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    bHandled = FALSE;
    int iItem;

    if ((int)wParam == VK_SPACE)
    {
        // Is the focused item selected ?
        if ( (iItem = GetNextItem(-1, LVNI_FOCUSED|LVNI_SELECTED)) >= 0)
        {
            // if so, set all selected and enabled items to the opposite state
            BOOL bNewState = !GetItemCheck(iItem);

            iItem = -1;
            while( (iItem = GetNextItem(iItem, LVNI_SELECTED)) >= 0)
            {
                BOOL bEnable;
                GetItemCheck(iItem, &bEnable);

                if (bEnable)
                    SetItemCheck(iItem, bNewState);
            }
        }
        else
        {
            if ( (iItem = GetNextItem(-1, LVNI_FOCUSED)) >= 0)
            {
                BOOL bEnable;
                GetItemCheck(iItem, &bEnable);

                if (bEnable)
                    ToggleItemCheck(iItem);

                SetItemState(iItem, LVIS_SELECTED, LVIS_SELECTED);
            }
        }

        bHandled = TRUE;
    }

    return 0;
}

LRESULT CCheckList::OnLButtonDown( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    LV_HITTESTINFO info;

    info.pt.x = LOWORD( lParam );
    info.pt.y = HIWORD( lParam );

    int iItem = HitTest( &info );

    if( iItem >= 0 && (info.flags & LVHT_ONITEMSTATEICON))
    {
       BOOL bEnable;
       GetItemCheck(iItem, &bEnable);

       if (bEnable)
           ToggleItemCheck(iItem);

       bHandled = TRUE;
    }
    else
    {
        bHandled = FALSE;
    }

    return 0;
}

LRESULT CCheckList::OnLButtonDblClk( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    LV_HITTESTINFO info;

    info.pt.x = LOWORD( lParam );
    info.pt.y = HIWORD( lParam );

    int iItem = HitTest( &info );
    if( iItem >= 0 )
    {
        BOOL bEnable;
        GetItemCheck(iItem, &bEnable);

        if (bEnable)
            ToggleItemCheck(iItem);
    }

    return 0;
}

//############################################################################
//############################################################################
//
//  Implementation of class CAboutInfoThread
//
//############################################################################
//############################################################################

CAboutInfoThread::~CAboutInfoThread()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CAboutInfoThread);

    Trace(tagAboutInfoThread, TEXT("CAboutInfoThread::~CAboutInfoThread"));

    // Make sure the thread is dead before MMC quits
    if (m_hThread != NULL)
    {
        PostThreadMessage(m_uThreadID, WM_QUIT, 0, 0);

        MSG msg;
        while (TRUE)
        {
            // Wait either for the thread to be signaled or any input event.
            DWORD dwStat = MsgWaitForMultipleObjects(1, &m_hThread, FALSE, INFINITE, QS_ALLINPUT);

            if (WAIT_OBJECT_0 == dwStat)
                break;  // The thread is signaled.

            // There is one or more window message available.
            // Dispatch them and wait.
            if (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        CloseHandle(m_hThread);
        CloseHandle(m_hEvent);
    }
}



//-----------------------------------------------------------------------------
// CAboutInfoThread::StartThread
//
// Start the thread
//-----------------------------------------------------------------------------

BOOL CAboutInfoThread::StartThread()
{
    // If thread exists, just return
    if (m_hThread != NULL)
        return TRUE;

    BOOL bRet = FALSE;
    do // False loop
    {
        // Create start event
        m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (m_hEvent == NULL)
            break;

        // Start the thread
        m_hThread = (HANDLE)_beginthreadex(NULL, 0, ThreadProc, this, 0, &m_uThreadID);
        if (m_hThread == NULL)
            break;

        // Wait for start event
        DWORD dwEvStat = WaitForSingleObject(m_hEvent, 10000);
        if (dwEvStat != WAIT_OBJECT_0)
            break;

        bRet = TRUE;
    }
    while (0);

    ASSERT(bRet);

    // Clean up on failure
    if (!bRet)
    {
        if (m_hEvent)
        {
            CloseHandle(m_hEvent);
            m_hEvent = NULL;
        }

        if (m_hThread)
        {
            CloseHandle(m_hThread);
            m_hThread = NULL;
        }
    }

    return bRet;
}

BOOL CAboutInfoThread::PostRequest(CSnapinInfo* pSnapInfo, HWND hWndNotify)
{
    // make sure thread is active
    if (!StartThread())
        return FALSE;

    // Ref the info object to keep it alive until the thread releases it
    pSnapInfo->AddRef();

    BOOL bRet = PostThreadMessage(m_uThreadID, MSG_LOADABOUT_REQUEST,
                                    (WPARAM)pSnapInfo, LPARAM(hWndNotify));

    // if failed to post, delete the ref
    if (!bRet)
        pSnapInfo->Release();

    return bRet;
}

unsigned _stdcall CAboutInfoThread::ThreadProc(void* pVoid )
{
    // Do a PeekMessage to create the message queue
    MSG msg;
    PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

    // Then signal that thread is started
    CAboutInfoThread* pThis = reinterpret_cast<CAboutInfoThread*>(pVoid);
    ASSERT(pThis->m_hEvent != NULL);
    SetEvent(pThis->m_hEvent);

    CoInitialize(NULL);

    // Mesage loop
    while (TRUE)
    {
        long lStat = GetMessage(&msg, NULL, 0, 0);

        // zero => WM_QUIT received, so exit thread function
        if (lStat == 0)
            break;

        if (lStat > 0)
        {
            // Only process thread message of the expected type
            if (msg.hwnd == NULL && msg.message == MSG_LOADABOUT_REQUEST)
            {
                // Get SnapinInfo instance
                PSNAPININFO pSnapinInfo = reinterpret_cast<PSNAPININFO>(msg.wParam);
                ASSERT(pSnapinInfo != NULL);

                // Get the requested items
                pSnapinInfo->LoadAboutInfo();

                // Release our ref to the info
                pSnapinInfo->Release();

                // Send completion notification (if window still exists)
                if (msg.lParam != NULL && IsWindow((HWND)msg.lParam))
                    PostMessage((HWND)msg.lParam, MSG_LOADABOUT_COMPLETE,
                                (WPARAM)pSnapinInfo, (LPARAM)0);
            }
            else
            {
                DispatchMessage(&msg);
            }
        }
    } // WHILE (TRUE)

    Trace(tagSnapinManagerThread, TEXT("Snapin manager thread about to exit"));

    CoUninitialize();

    return 0;
}


//############################################################################
//############################################################################
//
//  Implementation of class CSnapinInfo
//
//############################################################################
//############################################################################

//-----------------------------------------------------------------------------
// CSnapinInfo::~CSnapinInfo
//
// Destructor
//-----------------------------------------------------------------------------
CSnapinInfo::~CSnapinInfo()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinInfo);

    // Delete all the extension links
    PEXTENSIONLINK pExt = m_pExtensions;
    PEXTENSIONLINK pNext;

    while (pExt != NULL)
    {
        pNext = pExt->Next();
        delete pExt;
        pExt = pNext;
    }
}


//-----------------------------------------------------------------------------
// CSnapinInfo::InitFromMMCReg
//
// Initialize the snapin info from the supplied registry key. The caller is
// responsible for openning and closing the key.
//-----------------------------------------------------------------------------
BOOL CSnapinInfo::InitFromMMCReg(GUID& clsid, CRegKeyEx& regkey, BOOL bPermitted)
{
    TCHAR   szValue[MAX_PATH];
    long    lStat;
    DWORD   dwCnt;
    DWORD   dwType;
    LPOLESTR lpsz;

    USES_CONVERSION;

    // save class ID
    m_clsid = clsid;

    // Save permission
    m_bPolicyPermission = bPermitted;

    // Get name string
	WTL::CString strName;
    SC sc = ScGetSnapinNameFromRegistry (regkey, strName);
    if (!sc.IsError())
    {
        SetSnapinName(T2COLE(strName));
    }
	else
	{
		// need to protect ourselves from the invalid snapin registration.
		// see windows bug #401220	( ntbugs9 5/23/2001 )
		OLECHAR szCLSID[40];
		int iRet = StringFromGUID2(GetCLSID(), szCLSID, countof(szCLSID));
		if (iRet == 0)
	        SetSnapinName( L"" );
		else
	        SetSnapinName( szCLSID );
	}

    // get "About" class ID
    dwCnt = sizeof(szValue);
    lStat = RegQueryValueEx(regkey, g_szAbout, NULL, &dwType, (LPBYTE)szValue, &dwCnt);
    if (lStat == ERROR_SUCCESS && dwType == REG_SZ)
    {
        if (CLSIDFromString( T2OLE(szValue), &m_clsidAbout) == S_OK)
        {
            m_bAboutValid = TRUE;
        }
        else
        {
            ASSERT(FALSE);
        }
    }

    MMC_ATL::CRegKey TestKey;

    // Test for StandAlone key
    m_bStandAlone = FALSE;
    lStat = TestKey.Open(regkey, g_szStandAlone, KEY_READ);
    if (lStat == ERROR_SUCCESS)
    {
        m_bStandAlone = TRUE;
        TestKey.Close();
    }

    // Test for NodeTypes key to see if extendable
    m_bExtendable = FALSE;
    lStat = TestKey.Open(regkey, g_szNodeTypes, KEY_READ);
    if (lStat == ERROR_SUCCESS)
    {
        m_bExtendable = TRUE;
        TestKey.Close();
    }

    // Mark registered snap-ins as installed
    m_bInstalled = TRUE;

    return TRUE;
}

//-----------------------------------------------------------------------------
// CSnapinInfo::InitFromComponentReg
//
// Initialize the snapin info from component registry information. This is done
// for snap-in that are not yet installed on the local machine.
//-----------------------------------------------------------------------------
BOOL CSnapinInfo::InitFromComponentReg(GUID& clsid, LPCTSTR pszName, BOOL bStandAlone,  BOOL bPermitted)
{

    USES_CONVERSION;

    // save class ID
    m_clsid = clsid;

    // Save permission
    m_bPolicyPermission = bPermitted;

    // Set name string
    ASSERT(pszName != NULL);
    SetSnapinName(T2COLE(pszName));

    // stand-alone or extension
    m_bStandAlone = bStandAlone;

    // With no information, must assume that it could be extendable
    m_bExtendable = TRUE;

    return TRUE;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinInfo::ScInstall
 *
 * PURPOSE: Call the installer to install this snap-in. If the install works then
 *          update the snap-in info from the MMC registry.
 *          If loading an extension snap-in the clsid of extended snap-in must be
 *          provided.
 *
 * PARAMETERS:
 *    CLSID* pclsidPrimaryComp :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CSnapinInfo::ScInstall(CLSID* pclsidPrimaryComp)
{
    DECLARE_SC(sc, TEXT("CSnapinInfo::Install"));

    USES_CONVERSION;

    LPCTSTR pszPrimaryCLSID;
    OLECHAR szCLSIDPrimary[40];

    if (pclsidPrimaryComp != NULL)
    {
        int iRet = StringFromGUID2(*pclsidPrimaryComp, szCLSIDPrimary, countof(szCLSIDPrimary));
        if (iRet == 0)
            return(sc = E_UNEXPECTED);

        pszPrimaryCLSID = OLE2T(szCLSIDPrimary);
    }
    else
    {
        pszPrimaryCLSID = g_szMMCSnapInGuid;
    }

    OLECHAR szCLSID[40];
    int iRet = StringFromGUID2(GetCLSID(), szCLSID, countof(szCLSID));
    if (iRet == 0)
        return(sc = E_UNEXPECTED);

    TCHAR szCompPath[MAX_PATH];
    DWORD dwPathCnt = MAX_PATH;

    // install the snapin on the machine
    sc.FromWin32(MsiModule().ProvideQualifiedComponent(pszPrimaryCLSID, OLE2T(szCLSID), INSTALLMODE_DEFAULT, szCompPath, &dwPathCnt));
    if (sc)
        return sc;

    // the caller should call CSnapinManager::ScLoadSnapinInfo to update all the snapin info objects

    return sc;
}


//--------------------------------------------------------------------
// CSnapinInfo::AttachSnapIn
//
// Attach to the CSnapin associated with this info. If the snapin has
// active extensions, then add extension links for them. Recursively
// call AttachSnapIn for any extension snapins linked to.
//--------------------------------------------------------------------
void  CSnapinInfo::AttachSnapIn(CSnapIn* pSnapIn, CSnapinInfoCache& InfoCache)
{
    // If already attached, nothing to do
    if (m_spSnapin != NULL)
    {
        ASSERT(m_spSnapin == pSnapIn); // Better be the same one!
        return;
    }

    // Save ref to snapin
    m_spSnapin = pSnapIn;

    // If not extendable, there's nothing more to do
    if (!IsExtendable())
        return;

    // If required extensions not yet loaded, do it now
    if (!pSnapIn->RequiredExtensionsLoaded() && IsPermittedByPolicy())
    {
        // Create instance of snapin
        IComponentDataPtr spICD;
        HRESULT hr = CreateSnapIn(m_clsid, &spICD, FALSE);
        ASSERT(SUCCEEDED(hr) && spICD != NULL);

        if (SUCCEEDED(hr) && spICD != NULL)
        {
            // Load required extensions into snapin cache
            LoadRequiredExtensions(pSnapIn, spICD);
        }
    }

    // Copy state of Enable All flags
    SetEnableAllExtensions(pSnapIn->AreAllExtensionsEnabled());


    // Do for all snapin's extensions
    CExtSI* pSnapInExt  = pSnapIn->GetExtensionSnapIn();
    while (pSnapInExt != NULL)
    {
        // Find snapin info entry for the extension snapin
        PSNAPININFO pSnapInfo = InfoCache.FindEntry(pSnapInExt->GetSnapIn()->GetSnapInCLSID());

        if (pSnapInfo != NULL)
        {
            // Create new link and add to list
            PEXTENSIONLINK pNewExt = new CExtensionLink(pSnapInfo);
            pNewExt->SetNext(m_pExtensions);
            m_pExtensions = pNewExt;

            // Initialize to ON
            pNewExt->SetInitialState(CExtensionLink::EXTEN_ON);
            pNewExt->SetState(CExtensionLink::EXTEN_ON);

            // Copy Required state
            pNewExt->SetRequired(pSnapInExt->IsRequired());

            // recursively connect the extension snapin info to its snapin
            pSnapInfo->AttachSnapIn(pSnapInExt->GetSnapIn(), InfoCache);
        }

        pSnapInExt = pSnapInExt->Next();
    }
}

//--------------------------------------------------------------------
// CSnapinInfo::LoadImages
//
// Get small bitmap images from the snapin and add them to the image list.
//--------------------------------------------------------------------
void CSnapinInfo::LoadImages( WTL::CImageList iml )
{
    DECLARE_SC(sc, TEXT("CSnapinInfo::LoadImages"));

    // if already loaded, just return
    if (m_iImage != -1)
        return;

    // try to get images from the snap-in About object
    // Get basic info from snapin
    if (HasAbout() && !HasBasicInformation())
    {
        GetBasicInformation(m_clsidAbout);
    }

    ASSERT(iml != NULL);

    // get the small bitmaps
    HBITMAP hImage = NULL;
    HBITMAP hOpenImage = NULL;
    COLORREF cMask;
    GetSmallImages(&hImage, &hOpenImage, &cMask);

    // Add to the image list
    if (hImage != NULL)
        m_iImage = iml.Add(hImage, cMask);

	/*
	 * if the snap-in didn't give us an open image, just use the "closed" image
	 */
    if (hOpenImage != NULL)
        m_iOpenImage = iml.Add(hOpenImage, cMask);
	else
		m_iOpenImage = m_iImage;

    // if couldn't get from snap-in, try getting default icon from CLSID key
    if (m_iImage == -1)
        do // dummy loop
        {
            USES_CONVERSION;

            OLECHAR szCLSID[40];
            int iRet = StringFromGUID2(GetCLSID(), szCLSID, countof(szCLSID));
            if (iRet == 0)
            {
                (sc = E_UNEXPECTED).TraceAndClear();
                break;
            }

            CStr strKeyName(TEXT("CLSID\\"));
            strKeyName += W2T(szCLSID);
            strKeyName += TEXT("\\DefaultIcon");

            CRegKeyEx regKey;
            sc = regKey.ScOpen (HKEY_CLASSES_ROOT, strKeyName, KEY_QUERY_VALUE);
            if (sc)
			{
				sc.Clear();
                break;
			}

            TCHAR szIconPath[MAX_PATH];
            DWORD dwSize = sizeof(szIconPath);
            DWORD dwType;

            sc = regKey.ScQueryValue (NULL, &dwType, szIconPath, &dwSize);
            if (sc)
			{
				sc.Clear();
                break;
			}

			if (dwType != REG_SZ)
				break;

            // Icon path has the form <file path>,<icon index>
            // if no index, use default of zero
            int nIconIndex = 0;

            TCHAR *pcComma = _tcsrchr(szIconPath, TEXT(','));
            if (pcComma != NULL)
            {
                // terminate path name at ','
                *(pcComma++) = TEXT('\0');

                // Convert rest of string to an index value
                if ((*pcComma != '-') && *pcComma < TEXT('0') || *pcComma > TEXT('9'))
                {
                    ASSERT(FALSE);
                    break;
                }

                nIconIndex = _ttoi(pcComma);
            }

            HICON hiconSmall;

            UINT nIcons = ExtractIconEx(szIconPath, nIconIndex, NULL, &hiconSmall, 1);
            if (nIcons != 1 || hiconSmall == NULL)
                break;

            // Add to image list (returns -1 on failure)
            m_iImage = m_iOpenImage = iml.AddIcon(hiconSmall);
            ASSERT(m_iImage != -1);

            DestroyIcon(hiconSmall);

        } while (0); // Dummy loop


    // Use default images on failure
    if (m_iImage == -1)
	{
		WTL::CBitmap bmp;
		VERIFY (bmp.LoadBitmap (IDB_FOLDER_16));
		m_iImage = iml.Add (bmp, RGB (255, 0, 255));
	}

    if (m_iOpenImage == -1)
	{
		WTL::CBitmap bmp;
		VERIFY (bmp.LoadBitmap (IDB_FOLDEROPEN_16));
		m_iOpenImage = iml.Add (bmp, RGB (255, 0, 255));
	}
}


//--------------------------------------------------------------------
// CSnapinInfo::ShowAboutPages
//
// Show About property pages for this snapin
//--------------------------------------------------------------------
void CSnapinInfo::ShowAboutPages(HWND hWndParent)
{
    // Load information if not already there
    if (m_bAboutValid && !HasInformation())
    {
        GetSnapinInformation(m_clsidAbout);
    }

    // If it's there, show it
    if (HasInformation())
    {
        ShowAboutBox();
    }
}

//--------------------------------------------------------------------
// CSnapinInfo::AddUseRef
//
// Handle increment of use count. If count was zero, then set all
// READY extensions to the ON state. Note this can cascade as
// activated links cause other SnapinInfo ref counts to increment.
//--------------------------------------------------------------------
void CSnapinInfo::AddUseRef(void)
{
    // If first reference, activate all READY extensions
    if (m_nUseCnt++ == 0)
    {
        PEXTENSIONLINK pExt = GetExtensions();
        while(pExt != NULL)
        {
            if (pExt->GetState() == CExtensionLink::EXTEN_READY)
                pExt->SetState(CExtensionLink::EXTEN_ON);
            pExt = pExt->Next();
        }
    }
}

//--------------------------------------------------------------------
// CSnapinInfo::DeleteUseRef
//
// Handle decrement of use count. If count reaches zero, then
// set all ON extensions to a READY state. Note this can cascade as
// deactivated links cause other SnapinInfo ref counts to drop.
//--------------------------------------------------------------------
void CSnapinInfo::DeleteUseRef(void)
{
    ASSERT(m_nUseCnt > 0);

    // If no more references, turn off all extensions
    if (--m_nUseCnt == 0)
    {
        PEXTENSIONLINK pExt = GetExtensions();
        while(pExt != NULL)
        {
            if (pExt->GetState() == CExtensionLink::EXTEN_ON)
                pExt->SetState(CExtensionLink::EXTEN_READY);
            pExt = pExt->Next();
        }
    }
}


//--------------------------------------------------------------------
// CSnapinInfo::GetAvailableExtensions
//
// Return list of available extensions for this snapin.
// On first call, create the list from the registry.
//--------------------------------------------------------------------
PEXTENSIONLINK CSnapinInfo::GetAvailableExtensions(CSnapinInfoCache* pInfoCache,CPolicy* pMMCPolicy)
{
    DECLARE_SC(sc, TEXT("CSnapinInfo::GetAvailableExtensions"));

    // if already loaded, return the pointer
    if (m_bExtensionsLoaded)
        return m_pExtensions;

    // set flag even on failure, so we don't keep retrying
    m_bExtensionsLoaded = TRUE;

    // call service to get extension CLSIDs
    CExtensionsCache  ExtCache;
    HRESULT hr = MMCGetExtensionsForSnapIn(m_clsid, ExtCache);
    if (FAILED(hr))
        return NULL;

    // Create an extension link for each one found
    CExtensionsCacheIterator ExtIter(ExtCache);
    for (; ExtIter.IsEnd() == FALSE; ExtIter.Advance())
    {
        // if can't be used statically, skip it
        if ((ExtIter.GetValue() & CExtSI::EXT_TYPE_STATIC) == 0)
            continue;

        GUID clsid = ExtIter.GetKey();

        // See if extension is already in the list
        PEXTENSIONLINK pExt = FindExtension(clsid);

        // if link isn't present
        if (pExt == NULL)
        {
            // Locate snapin info for the extension
            PSNAPININFO pSnapInfo = pInfoCache->FindEntry(clsid);
            ASSERT(pSnapInfo != NULL);

            if (pSnapInfo)
            {
                // Create new link and add to list
                PEXTENSIONLINK pNewExt = new CExtensionLink(pSnapInfo);
                ASSERT(pNewExt != NULL);

                pNewExt->SetNext(m_pExtensions);
                m_pExtensions = pNewExt;

                // Save extension type flags
                pNewExt->SetExtTypes(ExtIter.GetValue());
            }
        }
        else
        {
            pExt->SetExtTypes(ExtIter.GetValue());
        }
    }

    // If no installer module present, return now
    if (!MsiModule().IsPresent())
        return m_pExtensions;

    // Enumerate uninstalled extensions for this snap-in
    DWORD dwQualifCnt;
    DWORD dwAppDataCnt;
    TCHAR szQualifBuf[MAX_PATH];
    TCHAR szAppDataBuf[MAX_PATH];

    USES_CONVERSION;

    OLECHAR szSnapInGUID[40];
    int iRet = StringFromGUID2(m_clsid, szSnapInGUID, countof(szSnapInGUID));
    if (iRet == 0)
    {
        sc = E_UNEXPECTED;
        return m_pExtensions;
    }

    LPTSTR pszSnapInGUID = OLE2T(szSnapInGUID);

    // Snap-in extension components are registerd as qualifiers of the snap-in component
    for (int iIndex = 0; TRUE; iIndex++)
    {
        dwQualifCnt = dwAppDataCnt = MAX_PATH;
        szQualifBuf[0] = szAppDataBuf[0] = 0;

        UINT uRet = MsiModule().EnumComponentQualifiers(pszSnapInGUID, iIndex, szQualifBuf, &dwQualifCnt,
                                                szAppDataBuf, &dwAppDataCnt);

        ASSERT(uRet == ERROR_SUCCESS || uRet == ERROR_NO_MORE_ITEMS || uRet == ERROR_UNKNOWN_COMPONENT);
        if (uRet != ERROR_SUCCESS)
            break;

        ASSERT(dwQualifCnt != 0);
        ASSERT(dwAppDataCnt != 0);

        GUID clsidExt;
        HRESULT hr = CLSIDFromString(T2OLE(szQualifBuf), &clsidExt);
        ASSERT(SUCCEEDED(hr));

        // Skip it if this extension has already been found
        if (FindExtension(clsidExt) != NULL)
            continue;

        // Locate snap-in info for extension
        PSNAPININFO pSnapInfo = pInfoCache->FindEntry(clsidExt);

        // if extension is not in the MMC registry, create a snapin info for it
        if (pSnapInfo == NULL)
        {
            pSnapInfo = new CSnapinInfo;
            ASSERT(pSnapInfo != NULL);

            ASSERT(pMMCPolicy != NULL);
            BOOL bPermission = pMMCPolicy->IsPermittedSnapIn(clsidExt);

            if (pSnapInfo->InitFromComponentReg(clsidExt, szAppDataBuf, FALSE, bPermission))
            {
                pInfoCache->AddEntry(pSnapInfo);
            }
            else
            {
                delete pSnapInfo;
                pSnapInfo = NULL;
            }
        }

        if (pSnapInfo != NULL)
        {
            // Create new link and add to list
            PEXTENSIONLINK pNewExt = new CExtensionLink(pSnapInfo);
            ASSERT(pNewExt != NULL);

            pNewExt->SetNext(m_pExtensions);
            m_pExtensions = pNewExt;

            // Since we don't know, assume that extension can be static or dynamic
            pNewExt->SetExtTypes(CExtSI::EXT_TYPE_STATIC|CExtSI::EXT_TYPE_DYNAMIC);
        }
    }

    return m_pExtensions;
}


//---------------------------------------------------------------------------
// CSnapinInfo::FindExtension
//
// Search snap-in's extension list for an extension with the specified CLSID.
// If foudn, return a pointer to it, else return NULL.
//----------------------------------------------------------------------------
CExtensionLink* CSnapinInfo::FindExtension(CLSID& clsid)
{
    PEXTENSIONLINK pExt = m_pExtensions;

    while (pExt != NULL)
    {
        if (IsEqualCLSID(clsid, pExt->GetSnapinInfo()->GetCLSID()))
            break;

        pExt = pExt->Next();
    }

    return pExt;
}


//############################################################################
//############################################################################
//
//  Implementation of class CExtensionLink
//
//############################################################################
//############################################################################

//---------------------------------------------------------------------------
// CExtensionLink::SetState
//
// Set state of extension link. If state changes to or from EXTEN_ON, add or
// remove a reference to the extension snapin info.
//----------------------------------------------------------------------------
void CExtensionLink::SetState(EXTENSION_STATE eNewState)
{
    if (eNewState == m_eCurState)
        return;

    EXTENSION_STATE eOldState = m_eCurState;
    m_eCurState = eNewState;

    ASSERT(m_pSnapInfo != NULL);

    if (eNewState == EXTEN_ON)
    {
        m_pSnapInfo->AddUseRef();
    }
    else if (eOldState == EXTEN_ON)
    {
        m_pSnapInfo->DeleteUseRef();
    }
}


//############################################################################
//############################################################################
//
//  Implementation of class CManagerNode
//
//############################################################################
//############################################################################

//-------------------------------------------------------------------
// CManagerNode::~CManagerNode
//-------------------------------------------------------------------
CManagerNode::~CManagerNode()
{
    // Delete ref to snapin info
    if (m_pSnapInfo)
    {
        m_pSnapInfo->DeleteUseRef();
    }

    // Delete all child nodes
    POSITION pos = m_ChildList.GetHeadPosition();
    while (pos != NULL)
    {
        PMANAGERNODE pmgNode = m_ChildList.GetNext(pos);
        delete pmgNode;
    }
}


//--------------------------------------------------------------------
// CManagerNode::AddChild
//
// Add a child node to this node.
//--------------------------------------------------------------------
VOID CManagerNode::AddChild(PMANAGERNODE pmgNode)
{
    ASSERT(pmgNode != NULL);

    // up link to parent
    pmgNode->m_pmgnParent = this;

    // set indent level for combo box display
    pmgNode->m_iIndent = m_iIndent + 1;

    // add node to CList
    m_ChildList.AddTail(pmgNode);
}


//--------------------------------------------------------------------
// CManagerNode::RemoveChild
//
// Remove a child node from this node
//--------------------------------------------------------------------
VOID CManagerNode::RemoveChild(PMANAGERNODE pmgNode)
{
    ASSERT(pmgNode && pmgNode->m_pmgnParent == this);

    // delete child from CList
    POSITION pos = m_ChildList.Find(pmgNode);
    ASSERT(pos != NULL);

    m_ChildList.RemoveAt(pos);
}


//############################################################################
//############################################################################
//
//  Implementation of class CNewTreeNode
//
//############################################################################
//############################################################################

//-----------------------------------------------------------------------
// CNewTreeNode::AddChild
//
// Add a child node to this node.
//------------------------------------------------------------------------
VOID CNewTreeNode::AddChild(PNEWTREENODE pntNode)
{
    ASSERT(pntNode != NULL);

    // up link to parent
    pntNode->m_pParent = this;

    // Add child node to end of linked
    if (m_pChild == NULL)
    {
        m_pChild = pntNode;
    }
    else
    {
         PNEWTREENODE pChild= m_pChild;
         while (pChild->m_pNext != NULL)
            pChild = pChild->m_pNext;

         pChild->m_pNext = pntNode;
    }
}

//----------------------------------------------------------------------
// CNewTreeNode::RemoveChild
//
// Remove a child node from this node
//----------------------------------------------------------------------
VOID CNewTreeNode::RemoveChild(PNEWTREENODE pntNode)
{
    ASSERT(pntNode && pntNode->m_pParent == this);

    // locate child node in linked list and unlink it
    if (m_pChild == pntNode)
    {
        m_pChild = pntNode->m_pNext;
    }
    else
    {
        PNEWTREENODE pChild = m_pChild;
        while (pChild && pChild->m_pNext != pntNode)
        {
            pChild = pChild->m_pNext;
        }

        ASSERT(pChild != NULL);
        pChild->m_pNext = pntNode->m_pNext;
    }
}


//############################################################################
//############################################################################
//
//  Implementation of class CSnapinManager
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapinManager);



//-------------------------------------------------------------------------
// CSnapinManager::CSnapinManager
//
// Constructor
//--------------------------------------------------------------------------
CSnapinManager::CSnapinManager(CMTNode *pmtNode) :
                m_pmtNode(pmtNode),
                m_proppStandAlone(this),
                m_proppExtension(this),
                m_bInitialized(false)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapinManager);

    static TCHAR titleBuffer[ 256 ] = {0};
    ::LoadString( GetStringModule(), ID_SNP_MANAGER_TITLE, titleBuffer, countof(titleBuffer) );
    m_psh.pszCaption = titleBuffer;

    ASSERT(m_pmtNode != NULL);

    // Add the property pages
    AddPage( m_proppStandAlone );
    AddPage( m_proppExtension );

    // hide the Apply button
    m_psh.dwFlags |= PSH_NOAPPLYNOW;

    m_pMMCPolicy = NULL;

    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapinManager);
}


//-------------------------------------------------------------------------
// CSnapinManager::~CSnapinManager
//
// Destructor
//-------------------------------------------------------------------------
CSnapinManager::~CSnapinManager()
{
    DECLARE_SC(sc, TEXT("CSnapinManager::~CSnapinManager"));

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinManager);

    Trace(tagSnapinManager, TEXT("CSnapinManager::~CSnapinManager"));


    // Delete all manager nodes
    if (m_mgNodeList.GetCount() > 0)
    {
        ASSERT(m_mgNodeList.GetCount() == 1);
        delete m_mgNodeList.GetHead();
        m_mgNodeList.RemoveAll();
    }

    // Delete added nodes
    POSITION pos = m_NewNodesList.GetHeadPosition();
    while (pos!=NULL)
    {
        delete m_NewNodesList.GetNext(pos);
    }
    m_NewNodesList.RemoveAll();

    // Clear deleted node list
    m_mtnDeletedNodesList.RemoveAll();

    // Free snapin info cache
    GUID guid;
    PSNAPININFO pSnapInfo;

    pos = m_SnapinInfoCache.GetStartPosition();
    while(pos != NULL)
    {
        m_SnapinInfoCache.GetNextAssoc(pos, guid, pSnapInfo);
        pSnapInfo->Release();
    }
    m_SnapinInfoCache.RemoveAll();

    if (m_pMMCPolicy)
        delete m_pMMCPolicy;

    // destroy imagelist
    m_iml.Destroy();

    // purge the snapin cache, since we released all references
    // and some snapins should die
    CSnapInsCache* pSnapInCache = theApp.GetSnapInsCache();
    sc = ScCheckPointers( pSnapInCache, E_UNEXPECTED );
    if ( !sc.IsError() )
        pSnapInCache->Purge();

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinManager);
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinManager::ScGetSnapinInfo
//
//  Synopsis:    Given Class-id or prog-id or name of a snapin, return
//               the snapins's CSnapinInfo object. (Assumes the
//               CSnapinInfoCache is already populated).
//
//  Arguments:   [szSnapinNameOrCLSIDOrProgID] - [In] snapin name or class-id or prog-id.
//               [ppSnapinInfo]                - [Out] param to return CSnapinInfo value.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapinManager::ScGetSnapinInfo(LPCWSTR szSnapinNameOrCLSIDOrProgID, CSnapinInfo **ppSnapinInfo)
{
    DECLARE_SC(sc, _T("CSnapinManager::ScFindSnapinAndInitSnapinInfo"));
    sc = ScCheckPointers(szSnapinNameOrCLSIDOrProgID, ppSnapinInfo);
    if (sc)
        return sc;

    // 0. The given string may be snapin name, class-id or prog-id.

    // 1. convert the string to a CLSID
    CLSID SnapinCLSID;
    sc = CLSIDFromString( const_cast<LPWSTR>(szSnapinNameOrCLSIDOrProgID), &SnapinCLSID);

    // 2. improper formatting. try to interpret the string as a ProgID
    if(sc == SC(CO_E_CLASSSTRING))
        sc = CLSIDFromProgID( const_cast<LPWSTR>(szSnapinNameOrCLSIDOrProgID), &SnapinCLSID);

    // 3. If class-id is extracted successfully find the CSnapinInfo in the cache and return.
    if (! sc.IsError())
    {
        *ppSnapinInfo = m_SnapinInfoCache.FindEntry(SnapinCLSID);
        return sc;
    }

    // 4. Else interpret the string as snapin name.

    USES_CONVERSION;

    const tstring& strSnapinName = OLE2CT(szSnapinNameOrCLSIDOrProgID);
    // This assumes the snapincache is populated.
    POSITION pos  = m_SnapinInfoCache.GetStartPosition();
    while(pos != NULL)
    {
	    GUID guid;
        PSNAPININFO pTempSnapInfo = NULL;
        m_SnapinInfoCache.GetNextAssoc(pos, guid, pTempSnapInfo);

        sc = ScCheckPointers(pTempSnapInfo, E_UNEXPECTED);
        if (sc)
            return sc;

        // Match the name. (Exact match).

        if ( CSTR_EQUAL == CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                          strSnapinName.data() , -1, OLE2CT(pTempSnapInfo->GetSnapinName()), -1))
        {
			*ppSnapinInfo = pTempSnapInfo;
			return sc;
        }
    }

    return (sc = MMC_E_SNAPINNOTFOUND);
}


/*+-------------------------------------------------------------------------*
 *
 * CSnapinManager::ScAddSnapin
 *
 * PURPOSE: Adds the snapin specified by pSnapinInfo to the console file,
 *          below Console Root.
 *          TODO: Allow the caller to specify the parent node.
 *
 * PARAMETERS:
 *    szSnapinNameOrCLSIDOrProgID : [IN] Specifies the snapin to be added (class-id
 *                                       or prog-id or full name).
 *    pProperties                 : [IN] Any properties.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CSnapinManager::ScAddSnapin(LPCWSTR szSnapinNameOrCLSIDOrProgID, SnapIn* pParentSnapinNode, Properties *pProperties)
{
    DECLARE_SC(sc, TEXT("CSnapinManager::ScAddSnapin"));

    CSnapinStandAlonePage   dlgStandalonePage(this);

    sc = ScInitialize();
    if (sc)
        return sc;

    // Above ScInitialize has populated CSnapinInfoCache, now is a good time
    // to get CSnapinInfo for given snapin
    CSnapinInfo *pSnapinInfo = NULL;
    sc = ScGetSnapinInfo(szSnapinNameOrCLSIDOrProgID, &pSnapinInfo);
    if (sc)
        return sc;

    sc = ScCheckPointers(pSnapinInfo, E_UNEXPECTED);
    if (sc)
        return sc;

    // Set the given properties in the SnapinInfo.
    pSnapinInfo->SetInitProperties(pProperties);

    // Set the node under which this snapin will be added as console root)
    PMANAGERNODE pmgNodeParent = NULL;

    // If a parent snapin under which this snapin should be added is given then
    // get the parent MANAGERNODE (else it is console root as above).
    if (pParentSnapinNode)
    {
        // Get the MTNode for this snapin root.
        CMTSnapInNode *pMTSnapinNode = NULL;

        sc = CMTSnapInNode::ScGetCMTSnapinNode(pParentSnapinNode, &pMTSnapinNode);
        if (sc)
            return sc;

        // Find the MANAGERNODE from MTNode.
        pmgNodeParent = FindManagerNode(m_mgNodeList, static_cast<CMTNode*>(pMTSnapinNode));
        if (! pmgNodeParent)
            return (sc = E_UNEXPECTED);
    }
	else
		pmgNodeParent = m_mgNodeList.GetHead();

    sc = dlgStandalonePage.ScAddOneSnapin(pmgNodeParent, pSnapinInfo);
    if(sc)
        return sc;

    // Caller must provide master tree before each DoModal
    m_pmtNode = NULL;

    // Apply changes
    UpdateSnapInCache();

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinManager::FindManagerNode
//
//  Synopsis:    Given MTNode of a snapin, find the managernode
//
//  Arguments:   [mgNodeList] - the MANAGERNODE list.
//               [pMTNode]    - the CMTNode* whose MANAGERNODE representation is needed.
//
//  Returns:     The CManagerNode ptr or NULL.
//
//--------------------------------------------------------------------
PMANAGERNODE CSnapinManager::FindManagerNode(const ManagerNodeList& mgNodeList, CMTNode *pMTNode)
{
    PMANAGERNODE pmgNode = NULL;

    POSITION pos = mgNodeList.GetHeadPosition();
    while (pos)
    {
        pmgNode = mgNodeList.GetNext(pos);

        if (pmgNode->m_pmtNode == pMTNode)
        {
            return pmgNode;
        }

        // One standalone snapin can be added below another.
        pmgNode = FindManagerNode(pmgNode->m_ChildList, pMTNode);

        if (pmgNode)
            return pmgNode;
    }

    return NULL;
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinManager::ScRemoveSnapin
//
//  Synopsis:    Remove the snapin represented by given CMTNode*.
//
//  Arguments:   [pMTNode] - the snapin to be removed.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapinManager::ScRemoveSnapin (CMTNode *pMTNode)
{
    DECLARE_SC(sc, _T("CSnapinManager::ScRemoveSnapin"));

    CSnapinStandAlonePage   dlgStandalonePage(this);

    sc = ScInitialize();
    if (sc)
        return sc;

    // Find the MANAGERNODE from MTNode.
    PMANAGERNODE pmgNode = FindManagerNode(m_mgNodeList, pMTNode);
    if (! pmgNode)
        return (sc = E_UNEXPECTED);

    // Remove the snapin.
    sc = dlgStandalonePage.ScRemoveOneSnapin(pmgNode, /*iItem*/ -1, /*bVisible*/ false);
    if(sc)
        return sc;

    delete pmgNode;

    // Apply changes
    UpdateSnapInCache();

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinManager::ScInitialize
//
//  Synopsis:    Initialize the snapin mgr object by loading snapin-info
//               MTNode tree & creating imagelist for snapins.
//
//  Arguments:
//
//  Returns:     SC
//
// Note: Should be called only once per CSnapinManager instance.
//
//--------------------------------------------------------------------
SC CSnapinManager::ScInitialize ()
{
    DECLARE_SC(sc, _T("CSnapinManager::ScInitialize"));

    sc = ScCheckPointers(m_pmtNode, E_UNEXPECTED);
    if (sc)
        return sc;

    // If already initialized just Reload the MTNode tree.
    if (m_bInitialized)
    {
        if (!LoadMTNodeTree(NULL, m_pmtNode))
            return (sc = E_FAIL);

        return sc;
    }

    m_pMMCPolicy = new CPolicy;
    sc = ScCheckPointers(m_pMMCPolicy, E_OUTOFMEMORY);
    if (sc)
        return sc;

    sc = m_pMMCPolicy->ScInit();
    if (sc)
        return sc;

    sc = ScLoadSnapinInfo();
    if (sc)
        return sc;

    // Create the image list
    if (!m_iml.Create (16/*cx*/, 16/*cy*/, ILC_COLOR | ILC_MASK, 16/*nInitial*/, 16/*cGrow*/))
        return (sc = E_FAIL);

    if (!LoadMTNodeTree(NULL, m_pmtNode))
        return (sc = E_FAIL);

    m_bInitialized = true;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinManager::ScEnableAllExtensions
//
//  Synopsis:    Enable all the extensions for the given snapin
//
//  Arguments:   [clsidSnapin] - Snapin clsid for which extensions be enabled.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapinManager::ScEnableAllExtensions (const CLSID& clsidSnapin, BOOL bEnable)
{
    DECLARE_SC(sc, _T("CSnapinManager::ScEnableAllExtensions"));

    sc = ScInitialize();
    if (sc)
        return sc;

    // Get the snapin's SnapinInfo.
    CSnapinInfo *pSnapinInfo = m_SnapinInfoCache.FindEntry(clsidSnapin);
    sc = ScCheckPointers(pSnapinInfo, E_UNEXPECTED);
    if (sc)
        return sc;

    if (!pSnapinInfo->IsUsed())
        return (ScFromMMC(MMC_E_SnapinNotAdded));

    PEXTENSIONLINK pExt = pSnapinInfo->GetAvailableExtensions(&m_SnapinInfoCache, m_pMMCPolicy);
    if (!pExt)
        return (sc = S_FALSE); // No extensions

    pSnapinInfo->SetEnableAllExtensions(bEnable);

    // if enabling all extensions, turn on all installed extensions
    if (pSnapinInfo->AreAllExtensionsEnabled())
    {
        PEXTENSIONLINK pExt = pSnapinInfo->GetExtensions();
        while (pExt != NULL)
        {
            if (pExt->GetSnapinInfo()->IsInstalled())
                pExt->SetState(CExtensionLink::EXTEN_ON);

            pExt = pExt->Next();
        }
    }

    // Update the snapin mgr's snapin cache.
    UpdateSnapInCache();

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinManager::ScEnableExtension
//
//  Synopsis:    Enable or disable an extension.
//
//  Arguments:   [clsidPrimarySnapin] -
//               [clsidExtension]     - snapin to be enabled/disabled
//               [bEnable]            - Enable or disable
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapinManager::ScEnableExtension (const CLSID& clsidPrimarySnapin,
                                      const CLSID& clsidExtension,
                                      bool bEnable)
{
    DECLARE_SC(sc, _T("CSnapinManager::ScEnableExtension"));

    sc = ScInitialize();
    if (sc)
        return sc;

    // Get the snapin's SnapinInfo.
    CSnapinInfo *pSnapinInfo = m_SnapinInfoCache.FindEntry(clsidPrimarySnapin);
    sc = ScCheckPointers(pSnapinInfo, E_UNEXPECTED);
    if (sc)
        return sc;

    if (!pSnapinInfo->IsUsed())
        return (ScFromMMC(MMC_E_SnapinNotAdded));

    // If disable make sure all extensions are not enabled.
    if ( (!bEnable) && (pSnapinInfo->AreAllExtensionsEnabled()) )
        return ScFromMMC(MMC_E_CannotDisableExtension);

    // Load the extensions for the primary.
    PEXTENSIONLINK pExt = pSnapinInfo->GetAvailableExtensions(&m_SnapinInfoCache, m_pMMCPolicy);
    if (!pExt)
        return (sc = S_FALSE); // No extensions

    // Find our extension.
    while (pExt)
    {
        CSnapinInfo *pExtSnapinInfo = pExt->GetSnapinInfo();
        sc = ScCheckPointers(pExtSnapinInfo, E_UNEXPECTED);
        if (sc)
            return sc;

        if (pExtSnapinInfo->GetCLSID() == clsidExtension)
            break;

        pExt = pExt->Next();
    }

    sc = ScCheckPointers(pExt, E_UNEXPECTED);
    if (sc)
        return sc;

    pExt->SetState(bEnable ? CExtensionLink::EXTEN_ON : CExtensionLink::EXTEN_OFF);

    // Update the snapin mgr's snapin cache.
    UpdateSnapInCache();

    return (sc);
}


//--------------------------------------------------------------------------
// CSnapinManager::DoModal
//
// Initialize local data structures and present the manager property sheet.
// Return user selection (OK or Cancel).
//
// Note: Should be called only once per CSnapinManager instance.
//
//-------------------------------------------------------------------------
int CSnapinManager::DoModal()
{
    DECLARE_SC(sc, TEXT("CSnapinManager::DoModal"));

    int iResp = 0; // 0 is failure

    sc = ScCheckPointers(m_pmtNode, E_UNEXPECTED);
    if (sc)
        return iResp;

    // init ComboBoxEx window class
    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC   = ICC_USEREX_CLASSES;

    if (!InitCommonControlsEx(&icex))
    {
        sc = E_FAIL;
        return iResp;
    }

    sc = ScInitialize();
    if (sc)
        return iResp;

    // Do the property sheet
    iResp = CPropertySheet::DoModal();

    // Caller must provide master tree before each DoModal
    m_pmtNode = NULL;

    if (iResp == IDOK)
    {
        // Apply changes
        UpdateSnapInCache();
    }

    // Delete all manager nodes
    ASSERT(m_mgNodeList.GetCount() == 1);
    delete m_mgNodeList.GetHead();
    m_mgNodeList.RemoveAll();

    return iResp;
}


//----------------------------------------------------------------------
// CSnapinManager::UpdateSnapInCache
//
// Apply changes recorded in the SnapinInfo cache to the SnapinCache.
//----------------------------------------------------------------------
void CSnapinManager::UpdateSnapInCache(void)
{
    CSnapInsCache* pSnapInCache = theApp.GetSnapInsCache();
    ASSERT(pSnapInCache != NULL);

    GUID guid;
    PSNAPININFO pSnapInfo;
    POSITION pos;

    // First create any new snapins
    pos  = m_SnapinInfoCache.GetStartPosition();
    while(pos != NULL)
    {
        m_SnapinInfoCache.GetNextAssoc(pos, guid, pSnapInfo);

        // if snapin is ref'd but doesn't exist yet
        if (pSnapInfo->IsUsed() && pSnapInfo->GetSnapIn() == NULL)
        {
              CSnapInPtr spSnapIn;
              SC sc = pSnapInCache->ScGetSnapIn(pSnapInfo->GetCLSID(), &spSnapIn);
              ASSERT(!sc.IsError());
              if (!sc.IsError())
                  pSnapInfo->SetSnapIn(spSnapIn);
        }
    }

    // Next add or remove all changed extensions
    pos = m_SnapinInfoCache.GetStartPosition();
    while(pos != NULL)
    {
        m_SnapinInfoCache.GetNextAssoc(pos, guid, pSnapInfo);
        CSnapIn* pSnapIn = pSnapInfo->GetSnapIn();

        if (pSnapInfo->IsUsed())
        {
            // Update state of Enable All flag
            pSnapIn->SetAllExtensionsEnabled(pSnapInfo->AreAllExtensionsEnabled());

            // Error to override the snap-in's  enable
            ASSERT(!(pSnapIn->DoesSnapInEnableAll() && !pSnapIn->AreAllExtensionsEnabled()));
        }

        PEXTENSIONLINK pExt = pSnapInfo->GetExtensions();
        while (pExt)
        {
            // if extension added or removed
            if (pExt->IsChanged())
            {
                CSnapIn* pExtSnapIn = pExt->GetSnapinInfo()->GetSnapIn();
                ASSERT(pExtSnapIn != NULL);

                // Apply change to SnapIn
                if (pExtSnapIn)
                {
                    if (pExt->GetState() == CExtensionLink::EXTEN_ON)
                    {
                        CExtSI* pExtSI = pSnapIn->AddExtension(pExtSnapIn);
                        ASSERT(pExtSI != NULL);
                        pExtSI->SetExtensionTypes(pExt->GetExtTypes());
                        pExt->SetInitialState(CExtensionLink::EXTEN_ON);
                    }
                    else
                    {
                        pSnapIn->MarkExtensionDeleted(pExtSnapIn);
                        pExt->SetInitialState(CExtensionLink::EXTEN_OFF);
                    }
                }

                // if namespace extension changed, mark SnapIn as changed
                if (pExt->GetExtTypes() & CExtSI::EXT_TYPE_NAMESPACE)
                {
                    pSnapIn->SetNameSpaceChanged();
                }

                // Change in extension set the help collection dirty.
                pSnapInCache->SetHelpCollectionDirty();

            }
            pExt = pExt->Next();
        }
    }


    // Propagate snapin change flags up the tree
    // This is needed in case an extension that extends another extension has changed
    BOOL bChange;
    do
    {
        bChange = FALSE;

        pos = m_SnapinInfoCache.GetStartPosition();
        while(pos != NULL)
        {
            m_SnapinInfoCache.GetNextAssoc(pos, guid, pSnapInfo);
            CSnapIn* pSnapIn = pSnapInfo->GetSnapIn();

            if (pSnapIn && !pSnapIn->HasNameSpaceChanged())
            {
                PEXTENSIONLINK pExt = pSnapInfo->GetExtensions();
                while (pExt)
                {
                    CSnapIn* pExtSnapIn = pExt->GetSnapinInfo()->GetSnapIn();

                    if (pExtSnapIn && pExtSnapIn->HasNameSpaceChanged())
                    {
                        pSnapIn->SetNameSpaceChanged();
                        bChange = TRUE;
                        break;
                    }
                    pExt = pExt->Next();
                }
            }
        }
    } while (bChange);


    //  Next release snapin info refs to snapins that aren't used
    pos  = m_SnapinInfoCache.GetStartPosition();
    while(pos != NULL)
    {
        m_SnapinInfoCache.GetNextAssoc(pos, guid, pSnapInfo);

        // if snapin exists, but isn't ref'd
        if (pSnapInfo->GetSnapIn() != NULL && !pSnapInfo->IsUsed())
        {
            pSnapInfo->DetachSnapIn();
        }
    }

#ifdef DBG
    pSnapInCache->DebugDump();
#endif

}


//----------------------------------------------------------------------
// CSnapinManager::LoadSnapinInfo
//
// Read snapin registry information. Create a snapin info object for
// each registered snapin and place in CMap indexed by snapin CLSID.
// Then enumerate snap-ins that are registered as components, but are
// not in the MMC snap-in registry. These are snap-in that will have to
// be downloaded/installed when created.
//----------------------------------------------------------------------
SC CSnapinManager::ScLoadSnapinInfo(void)
{
    DECLARE_SC(sc, TEXT("CSnapinManager::LoadSnapinInfo"));

    GUID  SnapinCLSID;
    MMC_ATL::CRegKey SnapinKey;
    CRegKeyEx ItemKey;
    long    lStat;
    TCHAR   szItemKey[MAX_PATH];

    USES_CONVERSION;

    // open MMC\Snapins key
    lStat = SnapinKey.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY, KEY_READ);
    ASSERT(lStat == ERROR_SUCCESS);

    if (lStat == ERROR_SUCCESS)
    {
        DWORD dwIndex = 0;
        DWORD dwLen = countof(szItemKey);

        // enumerate all snapin keys
        while (RegEnumKeyEx(SnapinKey, dwIndex, szItemKey, &dwLen,
                            NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
        {
            sc = CLSIDFromString( T2OLE(szItemKey), &SnapinCLSID);
            if (!sc)
            {
                // Open the snapin key and create a SnapinInfo object
                // from it. Add the object to the cache (CMap)
                lStat = ItemKey.Open(SnapinKey, szItemKey, KEY_READ);
                ASSERT(lStat == ERROR_SUCCESS);
                if (lStat == ERROR_SUCCESS)
                {
                    BOOL bPermission = m_pMMCPolicy->IsPermittedSnapIn(SnapinCLSID);

                    // Don't create a new entry if a CSnapinInfo object already exists; just re-initialize it
                    PSNAPININFO pSnapInfo = m_SnapinInfoCache.FindEntry(SnapinCLSID);
                    if(pSnapInfo != NULL)
                    {
                        //re-initialize it
                        if(!pSnapInfo->InitFromMMCReg(SnapinCLSID, ItemKey, bPermission))
                            return (sc=E_FAIL);
                    }
                    else
                    {
                        // create a new object
                        pSnapInfo = new CSnapinInfo;
                        sc = ScCheckPointers(pSnapInfo, E_OUTOFMEMORY);
                        if(sc)
                            return sc;

                        if (pSnapInfo->InitFromMMCReg(SnapinCLSID, ItemKey, bPermission))
                        {
                            m_SnapinInfoCache.AddEntry(pSnapInfo);
                        }
                        else
                        {
                            delete pSnapInfo;
                        }
                    }


                    ItemKey.Close();
                }
            }

            dwIndex++;
            dwLen = MAX_PATH;
        }
    }

    // If no installer module present, return now
    if (!MsiModule().IsPresent())
        return sc;

    // Enumerate standalone snapin components
    DWORD dwQualifCnt;
    DWORD dwAppDataCnt;
    TCHAR szQualifBuf[MAX_PATH];
    TCHAR szAppDataBuf[MAX_PATH];

    // enumerate all standalone snap-in components and create snap info entries
    for (int iIndex = 0; TRUE; iIndex++)
    {
        dwQualifCnt = dwAppDataCnt = MAX_PATH;
        szQualifBuf[0] = szAppDataBuf[0] = 0;

        UINT uRet = MsiModule().EnumComponentQualifiers(const_cast<TCHAR*>(g_szMMCSnapInGuid),
                iIndex, szQualifBuf, &dwQualifCnt, szAppDataBuf, &dwAppDataCnt);

        ASSERT(uRet == ERROR_SUCCESS || uRet == ERROR_NO_MORE_ITEMS
                || uRet == ERROR_UNKNOWN_COMPONENT || uRet == ERROR_CALL_NOT_IMPLEMENTED);

        if (uRet != ERROR_SUCCESS)
            break;

        ASSERT(dwQualifCnt != 0);
        ASSERT(dwAppDataCnt != 0);

        sc = CLSIDFromString(T2OLE(szQualifBuf), &SnapinCLSID);
        if (sc)
        {
            sc.TraceAndClear();
            continue;
        }

        // Skip if this snap-in was already found in the MMC registry
        if (m_SnapinInfoCache.FindEntry(SnapinCLSID) != NULL)
            continue;

        PSNAPININFO pSnapInfo = new CSnapinInfo;

        BOOL bPermission = m_pMMCPolicy->IsPermittedSnapIn(SnapinCLSID);

        if (pSnapInfo->InitFromComponentReg(SnapinCLSID, szAppDataBuf, TRUE, bPermission))
        {
            m_SnapinInfoCache.AddEntry(pSnapInfo);
        }
        else
        {
            delete pSnapInfo;
        }

    }

    return sc;
}


//---------------------------------------------------------------------------
// CSnapinManager::LoadMTNodeTree
//
// Recursively walk the static portion of the master tree provided by and
// create a parallel tree of manager nodes.
//---------------------------------------------------------------------------
BOOL CSnapinManager::LoadMTNodeTree(PMANAGERNODE pmgnParent, CMTNode* pmtNode)
{
    ManagerNodeList* pChildList;
    int iIndent;

    // Determine child list to add to
    if (pmgnParent == NULL)
    {
        pChildList = &m_mgNodeList;
        iIndent = 0;
    }
    else
    {
        pChildList = &pmgnParent->m_ChildList;
        iIndent = pmgnParent->m_iIndent + 1;
    }

    // Do for all nodes
    while (pmtNode != NULL)
    {
        // Only walk static portions
        if (pmtNode->IsStaticNode())
        {
            // Create a manager node
            PMANAGERNODE pmgNode = new CManagerNode;
			if ( pmgNode == NULL )
				return FALSE;

            pmgNode->m_pmtNode = pmtNode;
            pmgNode->m_pmgnParent = pmgnParent;
            pmgNode->m_iIndent = iIndent;

			tstring strName = pmtNode->GetDisplayName();
            pmgNode->m_strValue = strName.data();

            // See if this node is provided by a snapin
            CSnapIn* pSnapin = pmtNode->GetPrimarySnapIn();

            if (pSnapin)
            {
                pmgNode->m_nType = ADDSNP_SNAPIN;

                // get snapin's CLSID and use it to look up the snapin info object
                PSNAPININFO pSnapInfo = m_SnapinInfoCache.FindEntry(
                                            pmtNode->GetPrimarySnapInCLSID());
                if (pSnapInfo)
                {
                    // link node to snapin info
                    pmgNode->m_pSnapInfo = pSnapInfo;
                    pSnapInfo->AddUseRef();

                    // Link snapin to snapin info
                    pSnapInfo->AttachSnapIn(pSnapin, m_SnapinInfoCache);

                    // get images from snapin
                    pSnapInfo->LoadImages(m_iml);
                    pmgNode->m_iImage = pSnapInfo->GetImage();
                    pmgNode->m_iOpenImage = pSnapInfo->GetOpenImage();
                }
            }
            else
            {
                pmgNode->m_nType = ADDSNP_STATICNODE;

                // for built-ins, get image info directly from node
                pmgNode->m_iImage = pmtNode->GetImage();
                pmgNode->m_iOpenImage = pmtNode->GetOpenImage();
            }

            // add node to child list
            pChildList->AddTail(pmgNode);

            // add all children of this node
            if (!LoadMTNodeTree(pmgNode, pmtNode->Child()))
				return FALSE;
        }

        // go on to node next sibling
        pmtNode = pmtNode->Next();
    }

    return TRUE;
}






//############################################################################
//############################################################################
//
//  Implementation of class CSnapinStandAlonePage
//
//############################################################################
//############################################################################


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::CSnapinStandAlonePage()
//
//  Contructor
//----------------------------------------------------------------------------

CSnapinStandAlonePage::CSnapinStandAlonePage(CSnapinManager* pManager) :
            m_pManager(pManager),
            m_pmgnParent(NULL),
            m_pmgnChild(NULL),
            m_dlgAdd(pManager, this)
{
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::~CSnapinStandAlonePage()
//
//  Destructor
//----------------------------------------------------------------------------
CSnapinStandAlonePage::~CSnapinStandAlonePage()
{
    m_snpComboBox.Detach();
    m_snpListCtrl.Detach();
}

//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnInitDialog
//
//  Initialize the property page controls.
//----------------------------------------------------------------------------
LRESULT CSnapinStandAlonePage::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    static TBBUTTON tbBtn[] =
        {{ 0, ID_SNP_UP, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 0 }};

    // Attach control objects to control windows
    m_snpComboBox.Attach( ::GetDlgItem(m_hWnd, IDC_SNAPIN_COMBOEX ) );
    m_snpListCtrl.Attach( ::GetDlgItem(m_hWnd, IDC_SNAPIN_ADDED_LIST) );


    // The following code is needed because a toolbar created by the dialog resource
    // won't accept any buttons. This should be investigated further.

    // Get rect from dummy placeholder control
    HWND hWndStatic = GetDlgItem(IDC_TOOLBAR);
    ASSERT(hWndStatic != NULL);

    RECT rc;
    ::GetWindowRect( hWndStatic, &rc);
    ::ScreenToClient( m_hWnd, (LPPOINT)&rc);
    ::ScreenToClient( m_hWnd, ((LPPOINT)&rc)+1);

	// for RLT locales this mapping may produce wrong
	// result ( since client coordinated are mirrored)
	// following is to fix that:
    if (GetExStyle() & WS_EX_LAYOUTRTL) {
        // Swap left and right
		LONG temp = rc.left;
		rc.left = rc.right;
		rc.right = temp;
    }

    // Create a toolbar with the same coordiantes
//    BOOL bStat = m_ToolbarCtrl.Create( WS_VISIBLE|WS_CHILD|TBSTYLE_TOOLTIPS|CCS_NORESIZE|CCS_NODIVIDER, rc, this, 1);
//    ASSERT(bStat);
    HWND hToolBar = ::CreateWindow( TOOLBARCLASSNAME, _T( "" ), WS_VISIBLE|WS_CHILD|TBSTYLE_TOOLTIPS|TBSTYLE_TRANSPARENT|CCS_NORESIZE|CCS_NODIVIDER,
                                        rc.left, rc.top, ( rc.right - rc.left ), ( rc.bottom - rc.top ), *this, (HMENU) IDC_TOOLBAR,
                                        _Module.GetModuleInstance(), NULL );
    ASSERT( hToolBar );
    ::SendMessage( hToolBar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0L );
    m_ToolbarCtrl.Attach( hToolBar );

    int iStat = m_ToolbarCtrl.AddBitmap( 1, IDB_SNP_MANAGER );
    ASSERT(iStat != -1);

    BOOL bStat = m_ToolbarCtrl.AddButtons( 1, tbBtn );
    ASSERT(bStat);

    // attach image list to the combo box and list view controls
    m_snpComboBox.SetImageList(m_pManager->m_iml);
    m_snpListCtrl.SetImageList(m_pManager->m_iml, LVSIL_SMALL);

  // Apply workarounds for NT4 comboboxex bugs
    m_snpComboBox.FixUp();

    // Load combo box list with current node tree
    AddNodeListToTree(m_pManager->m_mgNodeList);

    // Add single column to list box
    m_snpListCtrl.GetClientRect(&rc);

    LV_COLUMN lvc;
    lvc.mask = LVCF_WIDTH | LVCF_SUBITEM;
    lvc.cx = rc.right - rc.left - GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 0;

    int iCol = m_snpListCtrl.InsertColumn(0, &lvc);
    ASSERT(iCol == 0);

    // Select the first node as the current parent
    PMANAGERNODE pmgNode = m_pManager->m_mgNodeList.GetHead();

    if (pmgNode != NULL)
        SelectParentNodeItem(pmgNode);

    // Turn off the scroll bar in description edit box.
	::ShowScrollBar(GetDlgItem(IDC_SNAPIN_DESCR), SB_VERT, FALSE);

    return TRUE;
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::AddNodeListToTree
//
// Populate the ComboBoxEx control from the manager node tree.
//----------------------------------------------------------------------------
VOID CSnapinStandAlonePage::AddNodeListToTree(ManagerNodeList& NodeList)
{
    COMBOBOXEXITEM ComboItem;

    ComboItem.mask = CBEIF_INDENT | CBEIF_LPARAM | CBEIF_IMAGE | CBEIF_TEXT | CBEIF_SELECTEDIMAGE;
    ComboItem.iItem = -1;

    // Add each node in list to the combo box
    POSITION pos = NodeList.GetHeadPosition();
    while (pos != NULL)
    {
        PMANAGERNODE pmgNode = NodeList.GetNext(pos);

        ComboItem.iIndent        = pmgNode->m_iIndent;
        ComboItem.iImage         = pmgNode->m_iImage;
        ComboItem.iSelectedImage = pmgNode->m_iOpenImage;
        ComboItem.lParam         = reinterpret_cast<LPARAM>(pmgNode);
        ComboItem.pszText        = const_cast<LPTSTR>((LPCTSTR)pmgNode->m_strValue);

        m_snpComboBox.InsertItem(&ComboItem);

        // Add node's children directly under the node
        AddNodeListToTree(pmgNode->m_ChildList);
    }
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::AddChildToTree
//
//  Add new manager node to ComboBoxEx control
//----------------------------------------------------------------------------

int CSnapinStandAlonePage::AddChildToTree(PMANAGERNODE pmgNode)
{
    COMBOBOXEXITEM ComboItem;

    PMANAGERNODE pmgnParent = pmgNode->m_pmgnParent;
    ASSERT(pmgnParent != NULL);


    // Get item index of parent
    ComboItem.mask = CBEIF_LPARAM;
    ComboItem.lParam = (LPARAM)pmgnParent;
    int iItem = m_snpComboBox.FindItem(&ComboItem);
    ASSERT(iItem != -1);

    // Locate index of next sibling (or higher) node
    iItem = m_snpComboBox.FindNextBranch(iItem);

    // Insert new node at that position
    ComboItem.mask           = CBEIF_INDENT | CBEIF_LPARAM | CBEIF_IMAGE | CBEIF_TEXT | CBEIF_SELECTEDIMAGE;
    ComboItem.iItem          = iItem;
    ComboItem.iIndent        = pmgNode->m_iIndent;
    ComboItem.iImage         = pmgNode->m_iImage;
    ComboItem.iSelectedImage = pmgNode->m_iOpenImage;
    ComboItem.lParam         = (LPARAM)pmgNode;
    ComboItem.pszText        = const_cast<LPTSTR>((LPCTSTR)pmgNode->m_strValue);

    iItem = m_snpComboBox.InsertItem(&ComboItem);
    ASSERT(iItem != -1);

    return iItem;
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::DisplayChildList
//
//  Display a list of nodes in the listbox control. This is called whenever
//  the current parent node is changed.
//----------------------------------------------------------------------------

VOID CSnapinStandAlonePage::DisplayChildList(ManagerNodeList& NodeList)
{

    // Clear old list
    m_snpListCtrl.DeleteAllItems();

    int iIndex = 0;

    // Add each node from the list
    POSITION pos = NodeList.GetHeadPosition();
    while (pos != NULL)
    {
        PMANAGERNODE pmgNode = NodeList.GetNext(pos);
        AddChildToList(pmgNode, iIndex++);
    }

    // Clear current selection
    SetupChildNode(NULL);

    // Set focus to the first item
    m_snpListCtrl.SetItemState(0, LVIS_FOCUSED, LVIS_FOCUSED);
}




//----------------------------------------------------------------------------
// CSnapinStandAlonePage::AddChildToList
//
//  Add a manager node to the listview control.
//----------------------------------------------------------------------------
int CSnapinStandAlonePage::AddChildToList(PMANAGERNODE pmgNode, int iIndex)
{
    LV_ITEM LVItem;

    LVItem.mask     = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    LVItem.iItem    = (iIndex >= 0) ? iIndex : m_snpListCtrl.GetItemCount();
    LVItem.iSubItem = 0;
    LVItem.iImage   = pmgNode->m_iImage;
    LVItem.pszText  = const_cast<LPTSTR>((LPCTSTR)pmgNode->m_strValue);
    LVItem.lParam   = reinterpret_cast<LPARAM>(pmgNode);

    iIndex = m_snpListCtrl.InsertItem(&LVItem);
    ASSERT (iIndex != -1);

    return iIndex;
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnTreeItemSelect
//
// Handle selection of item from ComboBoxEx control. Make the selected
// item the current parent node.
//----------------------------------------------------------------------------
LRESULT CSnapinStandAlonePage::OnTreeItemSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iItem = m_snpComboBox.GetCurSel();
    ASSERT(iItem >= 0);
    if (iItem < 0)
        return 0;

    COMBOBOXEXITEM ComboItem;
    ComboItem.mask = CBEIF_LPARAM;
    ComboItem.iItem = iItem;

    BOOL bStat = m_snpComboBox.GetItem(&ComboItem);
    ASSERT(bStat);

    PMANAGERNODE pMgrNode = reinterpret_cast<PMANAGERNODE>(ComboItem.lParam);
    ASSERT(pMgrNode != NULL);

    SetupParentNode(pMgrNode);

    return 0;
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnTreeUp
//
// Handle activation of folder-up button. Make parent of the current parent
// node the new current parent.
//----------------------------------------------------------------------------

LRESULT CSnapinStandAlonePage::OnTreeUp( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    ASSERT(m_pmgnParent != NULL && m_pmgnParent->m_pmgnParent != NULL);

    SelectParentNodeItem(m_pmgnParent->m_pmgnParent);

    return 0;
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::SelectParentNodeItem
//
// Handle selection of item from ComboBoxEx control. Make the selected
// item the current parent node.
//----------------------------------------------------------------------------

void CSnapinStandAlonePage::SelectParentNodeItem(PMANAGERNODE pMgrNode)
{
    // Locate node entry in the dropdown combo box
    COMBOBOXEXITEM ComboItem;
    ComboItem.mask = CBEIF_LPARAM;
    ComboItem.lParam = reinterpret_cast<LPARAM>(pMgrNode);

    int iComboItem = m_snpComboBox.FindItem(&ComboItem);
    ASSERT(iComboItem != -1);
    if (iComboItem < 0)
        return;

    // Select the combo box entry
    m_snpComboBox.SetCurSel(iComboItem);

    SetupParentNode(pMgrNode);
}


/*+-------------------------------------------------------------------------*
 *
 * CSnapinStandAlonePage::SetupParentNode
 *
 * PURPOSE: Setup a manger node as the current parent.
 *
 * PARAMETERS:
 *    PMANAGERNODE  pMgrNode :
 *    bool          bVisible : false if this dialog is not being shown.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CSnapinStandAlonePage::SetupParentNode(PMANAGERNODE pMgrNode, bool bVisible)
{
    ASSERT(pMgrNode != NULL);

    // Set node as current parent
    m_pmgnParent = pMgrNode;

    if(!bVisible)
        return;

    // Display children in list view
    DisplayChildList(pMgrNode->m_ChildList);

    // Enable folder-up button if current parent has a parent
    m_ToolbarCtrl.EnableButton(ID_SNP_UP,( pMgrNode->m_pmgnParent != NULL));

    // Present selection to Visual Test (It can't get it through the ComboBoxEx)
    TCHAR VTBuf[100];
    (void) StringCchPrintf(VTBuf,countof(VTBuf), _T("%d,%s\0"), pMgrNode->m_iIndent, pMgrNode->m_strValue);
    ::SetWindowText( GetDlgItem(IDC_VTHELPER), VTBuf );
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::SetupChildNode
//
// Setup a manger node as the current child.
//----------------------------------------------------------------------------

void CSnapinStandAlonePage::SetupChildNode(PMANAGERNODE pMgrNode)
{
    // Set node as current child
    m_pmgnChild = pMgrNode;

    // Enable/disable Delete button
    EnableButton(m_hWnd, IDC_SNAPIN_MANAGER_DELETE, m_snpListCtrl.GetSelectedCount() != 0);

    // Enable/disable About button
    EnableButton(m_hWnd, IDC_SNAPIN_ABOUT, m_pmgnChild && m_pmgnChild->HasAboutInfo());
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnListItemChanged
//
// Handle selection of item from listview control. Update description text
// and Delete button state.
//----------------------------------------------------------------------------

LRESULT CSnapinStandAlonePage::OnListItemChanged( int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pnmh;
    PMANAGERNODE pmgNode = NULL;

    // if item selected
    if (~pNMListView->uOldState & pNMListView->uNewState & LVIS_SELECTED)
    {
        // get description text from snapin info
        pmgNode = (PMANAGERNODE)pNMListView->lParam;

        // Get description text if any available
        LPOLESTR lpsz = NULL;
        if (pmgNode->GetSnapinInfo())
        {
            pmgNode->GetSnapinInfo()->LoadAboutInfo();
            lpsz = pmgNode->GetSnapinInfo()->GetDescription();
        }

        // display in description window
        USES_CONVERSION;
        SC sc = ScSetDescriptionUIText(GetDlgItem(IDC_SNAPIN_DESCR), lpsz ? OLE2CT(lpsz ): _T(""));
        if (sc)
            sc.TraceAndClear();

        // Make node the current child
        SetupChildNode(pmgNode);
     }
     else
     {
        SetupChildNode(NULL);
     }

     return 0;
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnListItemDblClick
//
// Handle double click of listview item. Make the selected node the current
// parent node.
//----------------------------------------------------------------------------

LRESULT CSnapinStandAlonePage::OnListItemDblClick( int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{
    // Get the selected item
    int iItem = m_snpListCtrl.GetNextItem(-1, LVNI_SELECTED);
    if (iItem < 0)
        return 0;

    // Get the item data (ManagerNode pointer)
    PMANAGERNODE pmgNode = reinterpret_cast<PMANAGERNODE>(m_snpListCtrl.GetItemData(iItem));

    // Select this node as the current parent
    SelectParentNodeItem(pmgNode);

    return 0;
}

//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnListKeyDown
//
// Handle double click of listview item. Make the selected node the current
// parent node.
//----------------------------------------------------------------------------

LRESULT CSnapinStandAlonePage::OnListKeyDown( int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{
    LV_KEYDOWN* pNotify = reinterpret_cast<LV_KEYDOWN*>(pnmh);

    if (pNotify->wVKey == VK_DELETE)
    {
        OnDeleteSnapin( 1, IDC_SNAPIN_MANAGER_DELETE, (HWND)GetDlgItem(IDC_SNAPIN_MANAGER_DELETE), bHandled );
    }
    else
    {
        bHandled = FALSE;
    }

    return 0;
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnAddSnapin
//
// Handle activation of Add Snapin button. Bring up the Add dialog and create
// a NewTreeNode for the selected snapin type.
//----------------------------------------------------------------------------

LRESULT CSnapinStandAlonePage::OnAddSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    ASSERT(m_pmgnParent != NULL);

    // display the Add dialog
    GetAddDialog().DoModal();

    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinStandAlonePage::ScAddOneSnapin
 *
 * PURPOSE: Called to add a single snapin underneath the specified node.
 *          Does not use the UI.
 *
 * PARAMETERS:
 *    PMANAGERNODE  pmgNodeParent:  The parent node to add this below
 *    PSNAPININFO   pSnapInfo :     The snapin to add.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CSnapinStandAlonePage::ScAddOneSnapin(PMANAGERNODE pmgNodeParent, PSNAPININFO pSnapInfo)
{
    DECLARE_SC(sc, TEXT("CSnapinStandAlonePage::ScAddOneSnapin"));

    // check parameters
    if( (NULL == pmgNodeParent) || (NULL == pSnapInfo) )
    {
        sc = E_POINTER;
        return sc;
    }

    // set up the parent node pointer
    SetupParentNode(pmgNodeParent, false /*bVisible*/);

    // add the snapin.
    sc = AddOneSnapin(pSnapInfo, false /*bVisual*/);
    if (sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinStandAlonePage::AddOneSnapin
 *
 * PURPOSE: This method is called from the add snap-in dialog each time the user requests
 *          to add a snap-in node. The method creates the node and adds it to the
 *          snap-in manager's copy of the master tree.
 *
 * PARAMETERS:
 *    PSNAPININFO  pSnapInfo :
 *    bool         bVisible :   true if the addition is being done with
 *                             the snapin manager being visible, false
 *                             if the addition is being done by automation.
 *
 * RETURNS:
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT CSnapinStandAlonePage::AddOneSnapin(PSNAPININFO pSnapInfo, bool bVisible)
{
    DECLARE_SC(sc, TEXT("CSnapinStandAlonePage::AddOneSnapin"));

    if (pSnapInfo == NULL)
        return S_FALSE;

    // If this snapin type is not currrently in use
    if (pSnapInfo->GetSnapIn() == NULL)
    {
        // ensure that the snapin is in the cache so if the user
        // requests help from the wizard pages, the help collection
        // will contain this snapin's topics
        CSnapInsCache* pSnapInCache = theApp.GetSnapInsCache();
        ASSERT(pSnapInCache != NULL);

        // use a smart pointer because we don't need to hold it once
        // the cache entry is created
        CSnapInPtr spSnapIn;
        sc = pSnapInCache->ScFindSnapIn(pSnapInfo->GetCLSID(), &spSnapIn);
        if (sc)
        {
            sc = pSnapInCache->ScGetSnapIn(pSnapInfo->GetCLSID(), &spSnapIn);
            if(sc)
                sc.TraceAndClear();  // not a big issue - we can ignore it
                                    // - just normaly shouldn't be so

            // Set stand-alone change, to invalidate help collection
            pSnapInCache->SetHelpCollectionDirty();
        }
    }

    // If component is not installed yet, do it now
    if (!pSnapInfo->IsInstalled())
    {
        // 1. install the component
        sc = pSnapInfo->ScInstall(NULL);
        if(sc)
            return sc.ToHr();

        // 2. update all the snapin info objects from the registry. This is because installing a
        // single msi package may install several snapins.
        sc = ScCheckPointers(m_pManager, E_UNEXPECTED);
        if(sc)
            return sc.ToHr();

        sc = m_pManager->ScLoadSnapinInfo();
        if(sc)
            return sc.ToHr();
    }

    // Run wizard to get component data
    // (returns a ref'd interface)
    HWND hWndParent = NULL;
    if(bVisible)
    {
        hWndParent = GetAddDialog().m_hWnd;
    }
    else
    {
        hWndParent = ::GetDesktopWindow();
    }

    IComponentDataPtr   spIComponentData;
    PropertiesPtr       spSnapinProps;

    sc = ScRunSnapinWizard (pSnapInfo->GetCLSID(),
                               hWndParent,
                               pSnapInfo->GetInitProperties(),
                               *&spIComponentData,
                               *&spSnapinProps);
    if (sc)
        return (sc.ToHr());

    // if the creation succeeded
    if (spIComponentData != NULL)
    {
        // Create new tree node
        CNewTreeNode* pNewTreeNode = new CNewTreeNode;
        if (pNewTreeNode == NULL)
            return ((sc = E_OUTOFMEMORY).ToHr());

        // if snapin node
        pNewTreeNode->m_spIComponentData = spIComponentData;
        pNewTreeNode->m_clsidSnapIn      = pSnapInfo->GetCLSID();
        pNewTreeNode->m_spSnapinProps    = spSnapinProps;

        // must be child of existing MT node or another new node
        ASSERT(m_pmgnParent->m_pmtNode || m_pmgnParent->m_pNewNode);

        // If adding to existing node
        if (m_pmgnParent->m_pmtNode)
        {
            // Add directly to new nodes list
            pNewTreeNode->m_pmtNode = m_pmgnParent->m_pmtNode;
            m_pManager->m_NewNodesList.AddTail(pNewTreeNode);
        }
        else
        {
            // Add as child to new node
            pNewTreeNode->m_pParent = m_pmgnParent->m_pNewNode;
            m_pmgnParent->m_pNewNode->AddChild(pNewTreeNode);
        }

        // Create new manger node
        PMANAGERNODE pmgNode = new CManagerNode;
        pmgNode->m_pNewNode = pNewTreeNode;

        pSnapInfo->AddUseRef();
        pmgNode->m_pSnapInfo = pSnapInfo;
        pmgNode->m_nType = ADDSNP_SNAPIN;

        // if this snapin type isn't currently in use
        if (pSnapInfo->GetSnapIn() == NULL)
        {
            // if so, get the snapin's cache entry so we can
            // determine its required extensions.
            CSnapInsCache* pSnapInCache = theApp.GetSnapInsCache();
            ASSERT(pSnapInCache != NULL);

            CSnapInPtr spSnapIn;
            SC sc = pSnapInCache->ScGetSnapIn(pSnapInfo->GetCLSID(), &spSnapIn);
            ASSERT(!sc.IsError());

            if (!sc.IsError())
            {   // Load the extensions then call AttachSnapIn so snapin manager
                // will load the required extensions from the cache and turn
                // them on by default. (Do the load here to prevent AttachSnapIn
                // from creating another instance of the snapin.)
                LoadRequiredExtensions(spSnapIn, spIComponentData);
                pSnapInfo->AttachSnapIn(spSnapIn, m_pManager->m_SnapinInfoCache);
            }
        }
        if(bVisible)
        {
            // Get images from snapin
            pSnapInfo->LoadImages(m_pManager->m_iml);
            pmgNode->m_iImage = pSnapInfo->GetImage();
            pmgNode->m_iOpenImage = pSnapInfo->GetOpenImage();
        }

        // get display name from component data
        if ( FAILED(LoadRootDisplayName(spIComponentData, pmgNode->m_strValue)) )
        {
            ASSERT(FALSE);
            pmgNode->m_strValue = pSnapInfo->GetSnapinName();
        }

        // Add to manager node tree, listview and combobox controls
        m_pmgnParent->AddChild(pmgNode);

        if(bVisible)
        {
            AddChildToTree(pmgNode);

            int iIndex = AddChildToList(pmgNode);

            // Give focus to new item and make it visible
            m_snpListCtrl.EnsureVisible(iIndex, FALSE);
            m_snpListCtrl.SetItemState(iIndex,LVIS_FOCUSED,LVIS_FOCUSED);
        }
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:      CSnapinStandAlonePage::ScRemoveOneSnapin
//
//  Synopsis:    Removes the snapin from the snapin manager data structures.
//
//  Arguments:   [pmgNode]  - The (MANAGERNODE of) snapin to be removed.
//               [iItem]    - index of the snapin in snapin mgr,
//                            valid only if snapin mgr is visible.
//               [bVisible] - Snapin mgr UI is visible/hidden.
//
//  Returns:     SC
//
//  Note:        The caller should delete PMANAGERNODE passed else memory will leak.
//
//--------------------------------------------------------------------
SC
CSnapinStandAlonePage::ScRemoveOneSnapin (
    PMANAGERNODE pmgNode,
    int          iItem,
    bool bVisible /*= true*/)
{
    DECLARE_SC(sc, _T("CSnapinStandAlonePage::ScRemoveOneSnapin"));
    sc = ScCheckPointers(pmgNode);
    if (sc)
        return sc;

    sc = ScCheckPointers(m_pManager, pmgNode->m_pmgnParent, E_UNEXPECTED);
    if (sc)
        return sc;

    // If existing MT node
    if (pmgNode->m_pmtNode != NULL)
    {
        // Add MT node to delete list
        m_pManager->m_mtnDeletedNodesList.AddTail(pmgNode->m_pmtNode);

        // Delete any new nodes attached to this one
        POSITION pos = m_pManager->m_NewNodesList.GetHeadPosition();
        while (pos)
        {
            POSITION posTemp = pos;

            PNEWTREENODE pNew = m_pManager->m_NewNodesList.GetNext(pos);
            sc = ScCheckPointers(pNew, E_UNEXPECTED);
            if (sc)
                return sc;

            if (pNew->m_pmtNode == pmgNode->m_pmtNode)
            {
                m_pManager->m_NewNodesList.RemoveAt(posTemp);
                delete pNew;  // delete and release IComponent
            }
        }
    }
    else // if new node
    {
        PNEWTREENODE pNew = pmgNode->m_pNewNode;

        // This is a new node.
        if (NULL == pNew)
            return (sc = E_UNEXPECTED);

        // If child of an existing MT node?
        if (pNew->GetMTNode())
        {
            // Locate in new node list
            POSITION pos = m_pManager->m_NewNodesList.Find(pNew);
            if(pos == NULL)
                return (sc = E_UNEXPECTED);

            // delete this item and all it's children
            m_pManager->m_NewNodesList.RemoveAt(pos);
            delete pNew; // delete and release IComponent
        }
        else // child of new node
        {
            if (NULL == pNew->Parent())
                return (sc = E_UNEXPECTED);

            pNew->Parent()->RemoveChild(pNew);
            delete pNew;
        }
    }

    // Remove from manager tree
    pmgNode->m_pmgnParent->RemoveChild(pmgNode);

    CSnapInsCache* pSnapInCache = theApp.GetSnapInsCache();
    sc = ScCheckPointers(pSnapInCache, E_UNEXPECTED);
    if (sc)
        return sc;

    // Snapin removed set help collection invalid.
    pSnapInCache->SetHelpCollectionDirty();

    if (bVisible)
    {
        m_snpListCtrl.DeleteItem(iItem);

        // Remove item and all children from combo box
        COMBOBOXEXITEM ComboItem;
        ComboItem.mask = CBEIF_LPARAM;
        ComboItem.lParam = (LPARAM)pmgNode;
        int iCombo = m_snpComboBox.FindItem(&ComboItem);

        ASSERT(iCombo != -1);
        m_snpComboBox.DeleteBranch(iCombo);
    }

    return (sc);
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnDeleteSnapin
//
// Handle activation of Delete button. Delete all selected snapins.
// item the current parent node.
//----------------------------------------------------------------------------

LRESULT CSnapinStandAlonePage::OnDeleteSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    DECLARE_SC(sc, _T("CSnapinStandAlonePage::OnDeleteSnapin"));

    BOOL bChildren = FALSE;

    // Check if any of the selected node have children
    int iItem = -1;
    while ((iItem = m_snpListCtrl.GetNextItem(iItem, LVNI_SELECTED)) >= 0)
    {
        PMANAGERNODE pmgNode = (PMANAGERNODE)m_snpListCtrl.GetItemData(iItem);
        if (!pmgNode->m_ChildList.IsEmpty())
        {
            bChildren = TRUE;
            break;
        }
    }

    // If so, give user a chance to cancel
    if (bChildren)
    {
        CStr strTitle;
        strTitle.LoadString(GetStringModule(), SNP_DELETE_TITLE);

        CStr strText;
        strText.LoadString(GetStringModule(), SNP_DELETE_TEXT);

        if (MessageBox(strText, strTitle, MB_ICONQUESTION|MB_YESNO) != IDYES)
        {
            return 0;
        }
    }

    // Do for all selected items in listview
    int iLastDelete = -1;
    iItem = -1;
    while ((iItem = m_snpListCtrl.GetNextItem(iItem, LVNI_SELECTED)) >= 0)
    {
        // get manager node from item
        PMANAGERNODE pmgNode = (PMANAGERNODE)m_snpListCtrl.GetItemData(iItem);

        sc = ScRemoveOneSnapin(pmgNode, iItem, true);
        if (sc)
            return 0;

        // destroy the removed node (and its children)
        delete pmgNode;

        iLastDelete = iItem;
        iItem--;
    }

    // if items deleted, set focus near last deleted item
    if (iLastDelete != -1)
    {
        int nCnt = m_snpListCtrl.GetItemCount();
        if (nCnt > 0)
        {
            // if deleted the last item, backup to previous one
            if (iLastDelete >= nCnt)
                iLastDelete = nCnt - 1;

            m_snpListCtrl.SetItemState(iLastDelete, LVIS_FOCUSED, LVIS_FOCUSED);
        }
    }

    SetupChildNode(NULL);

    // Clear description text
    sc = ScSetDescriptionUIText(GetDlgItem(IDC_SNAPIN_DESCR), _T(""));
    if (sc)
        sc.TraceAndClear();

    return 0;
}

//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnAboutSnapin
//
// Handle activation of About button. Display About dialog for the selected
// child node's snapin.
//----------------------------------------------------------------------------
LRESULT CSnapinStandAlonePage::OnAboutSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if (m_pmgnChild && m_pmgnChild->HasAboutInfo())
        m_pmgnChild->GetSnapinInfo()->ShowAboutPages(m_pManager->m_hWnd);

    return 0;
}

//----------------------------------------------------------------------------
// CSnapinStandAlonePage::ScRunSnapinWizard
//
// Run Snapin wizard to create snapin instance and return the IComponentData.
//----------------------------------------------------------------------------
SC CSnapinStandAlonePage::ScRunSnapinWizard (
    const CLSID&        clsid,              /* I:snap-in to create          */
    HWND                hwndParent,         /* I:parent of wizard           */
    Properties*         pInitProps,         /* I:properties to init with    */
    IComponentData*&    rpComponentData,    /* O:snap-in's IComponentData   */
    Properties*&        rpSnapinProps)      /* O:snap-in's properties       */
{
    DECLARE_SC (sc, _T("CSnapinStandAlonePage::ScRunSnapinWizard"));

    rpComponentData = NULL;
    rpSnapinProps   = NULL;

    /*
     * create a new node manager for the snap-in
     */
    IUnknownPtr pIunkNodemgr;
    sc = pIunkNodemgr.CreateInstance(CLSID_NodeInit, NULL, MMC_CLSCTX_INPROC);
    if (sc)
        return (sc);

    if (pIunkNodemgr == NULL)
        return (sc = E_UNEXPECTED);

    /*
     * create the snap-in
     */
    sc = CreateSnapIn(clsid, &rpComponentData, false);
    if (sc)
        return (sc);

    if (rpComponentData == NULL)
        return (sc = E_UNEXPECTED);


    /*-----------------------------------------------------------------
     * From this point on a failure isn't considered catastrophic.  If
     * anything fails, we'll return at that point, but return success.
     */


    /*
     * if we got properties to initialize with, see if the snap-in
     * supports ISnapinProperties
     */
    ISnapinPropertiesPtr spISP;

    if (pInitProps && ((spISP = rpComponentData) != NULL))
    {
        CComObject<CSnapinProperties>* pSnapinProps;
        CComObject<CSnapinProperties>::CreateInstance (&pSnapinProps);

        /*
         * Initialize the snap-in with the initial properties.  If the
         * snap-in fails to initialize, we'll release the CSnapinProperties
         * we created (because the spSnapinProps smart pointer will go out
         * of scope), but we won't return failure.
         */
        if (pSnapinProps != NULL)
        {
            /*
             * add a ref here, if ScInitialize fails, the balancing
             * Release will delete the Properties object
             */
            pSnapinProps->AddRef();

            if (!pSnapinProps->ScInitialize(spISP, pInitProps, NULL).IsError())
            {
                /*        `
                 * If we get here, the snap-in's ISnapinProperties was
                 * initilialized correctly.  Put a ref on for the client.
                 */
                rpSnapinProps = pSnapinProps;
                rpSnapinProps->AddRef();
            }

            /*
             * release the ref we put on above, if ScInitialize failed,
             * this release will delete the Properties
             */
            pSnapinProps->Release();
        }
    }


    /*
     * get the snap-in's data object
     */
    IDataObjectPtr pIDataObject;
    sc = rpComponentData->QueryDataObject(NULL, CCT_SNAPIN_MANAGER, &pIDataObject);
    if (sc.IsError() || (pIDataObject == NULL))
        return (sc);

    IPropertySheetProviderPtr pIPSP = pIunkNodemgr;

    if (pIPSP == NULL)
        return (sc);

    IPropertySheetCallbackPtr pIPSC = pIunkNodemgr;

    if (pIPSC == NULL)
        return (sc);

    // determine which pointer to use
    IExtendPropertySheetPtr     spExtend  = rpComponentData;
    IExtendPropertySheet2Ptr    spExtend2 = rpComponentData;

    IExtendPropertySheet* pIPSE;

    if (spExtend2 != NULL)
        pIPSE = spExtend2;
    else
        pIPSE = spExtend;

    // Snap-in may not have a property sheet to set the properties of the snap-in
    if (pIPSE == NULL)
        return (sc);

    do
    {
        // Create the PropertySheet , FALSE = WIZARD
        sc = pIPSP->CreatePropertySheet( L"", FALSE, NULL, pIDataObject, MMC_PSO_NEWWIZARDTYPE);
        if(sc.ToHr() != S_OK)
            break;

        // Add Primary pages without notify handle
        sc = pIPSP->AddPrimaryPages(rpComponentData, FALSE, NULL, FALSE);

        if (sc.ToHr() == S_OK)
        {
            // Show the property sheet
            sc = pIPSP->Show((LONG_PTR)hwndParent, 0);
            if (sc.ToHr() != S_OK)
                break;
        }
        else
        {
            // force the property sheet to be destroyed
            pIPSP->Show(-1, 0);

            // abort if snapin had a failure
            if (sc)
                break;
        }

        return sc;
    }
    while (0);

    // already checked for NULL above, but repeating the check here
    if(rpComponentData != NULL)
    {
        rpComponentData->Release();
        rpComponentData = NULL;
    }

    return (sc);
}

//############################################################################
//############################################################################
//
//  Implementation of class CSnapinExtensionPage
//
//############################################################################
//############################################################################



//----------------------------------------------------------------------------
// CSnapinExtensionPage::~CSnapinExtensionPage
//
//  Destructor
//----------------------------------------------------------------------------
CSnapinExtensionPage::~CSnapinExtensionPage()
{
    m_ilCheckbox.Destroy();
    m_SnapComboBox.Detach();
    m_ExtListCtrl.Detach();
}


//----------------------------------------------------------------------------
// CSnapinExtensionPage::OnInitDialog
//
//  Initialize the property page controls.
//----------------------------------------------------------------------------
LRESULT CSnapinExtensionPage::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    // Attach control objects to control windows
    m_SnapComboBox.Attach( ::GetDlgItem(m_hWnd, IDC_SNAPIN_COMBOEX ) );
    m_ExtListCtrl.SubclassWindow( ::GetDlgItem( *this, IDC_EXTENSION_LIST ) );

    // attach shared image list to both listviews
    m_SnapComboBox.SetImageList(m_pManager->m_iml);
    m_ExtListCtrl.SetImageList(m_pManager->m_iml, LVSIL_SMALL);

    // Add single column to list box
    RECT rc;
    m_ExtListCtrl.GetClientRect(&rc);

    LV_COLUMN lvc;
    lvc.mask = LVCF_WIDTH | LVCF_SUBITEM;
    lvc.cx = rc.right - rc.left - GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 0;

    int iCol = m_ExtListCtrl.InsertColumn(0, &lvc);
    ASSERT(iCol == 0);

    // Load checkbox images
    if (m_ilCheckbox.Create(IDB_CHECKBOX, 16, 3, RGB(255,0,255)))
    {
        // Set background color to match list control, so checkboxes aren't drawn transparently
        m_ilCheckbox.SetBkColor(m_ExtListCtrl.GetBkColor());
        m_ExtListCtrl.SetImageList(m_ilCheckbox, LVSIL_STATE);
    }
    else
    {
        ASSERT(FALSE); // Unable to create imagelist
    }

    // Apply workarounds for NT4 comboboxex bugs
    m_SnapComboBox.FixUp();

    // Turn off the scroll bar in description edit box.
	::ShowScrollBar(GetDlgItem(IDC_SNAPIN_DESCR), SB_VERT, FALSE);

    return 0;
}


//--------------------------------------------------------------------------
// CSnapinExtensionPage::OnSetActive
//
// Update the data
//--------------------------------------------------------------------------
BOOL CSnapinExtensionPage::OnSetActive()
{
    BC::OnSetActive();

    BuildSnapinList();

    return TRUE;
}


//-------------------------------------------------------------------------
// CSnapinExtensionPage::OnSnapinDropDown
//
// Called when snapin dropdown is about to be displayed. Rebuilds the list
// if the update flag is set.
//-------------------------------------------------------------------------
LRESULT CSnapinExtensionPage::OnSnapinDropDown( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if (m_bUpdateSnapinList)
    {
        BuildSnapinList();
    }

    return 0;
}


//--------------------------------------------------------------------------
// CSnapinExtensionPage::OnSnapinSelect
//
// Handle selection of snapin from combobox. Make it the current snapin
// and display its extension list.
//--------------------------------------------------------------------------
LRESULT CSnapinExtensionPage::OnSnapinSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iItem = m_SnapComboBox.GetCurSel();
    ASSERT(iItem >= 0);
    if (iItem < 0)
        return 0;

    PSNAPININFO pSnapInfo = reinterpret_cast<PSNAPININFO>(m_SnapComboBox.GetItemDataPtr(iItem));
    ASSERT((LONG_PTR)pSnapInfo != -1);

    m_pCurSnapInfo = pSnapInfo;
    BuildExtensionList(pSnapInfo);

    return 0;
}


//----------------------------------------------------------------------------
// CSnapinExtensionPage::OnAboutSnapin
//
// Handle activation of About button. Display About dialog for the selected
// extension's snapin.
//----------------------------------------------------------------------------
LRESULT CSnapinExtensionPage::OnAboutSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if (m_pExtLink && m_pExtLink->GetSnapinInfo()->HasAbout())
    {
        m_pExtLink->GetSnapinInfo()->ShowAboutPages(m_hWnd);
    }

    return 0;
}

//----------------------------------------------------------------------------
// CSnapinExtensionPage::OnDownloadSnapin
//
// Handle activation of Download button. Download the selected extension
// snapin.
//----------------------------------------------------------------------------
LRESULT CSnapinExtensionPage::OnDownloadSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    DECLARE_SC(sc, TEXT("CSnapinExtensionPage::OnDownloadSnapin"));

    ASSERT(m_pExtLink && m_pExtLink->GetSnapinInfo());

    // 1. install the component
    sc = m_pExtLink->GetSnapinInfo()->ScInstall(&m_pCurSnapInfo->GetCLSID());
    if(sc)
        return 0;

    // 2. update all the snapin info objects from the registry. This is because installing a
    // single msi package may install several snapins.
    sc = ScCheckPointers(m_pManager, E_UNEXPECTED);
    if(sc)
        return 0;

    sc = m_pManager->ScLoadSnapinInfo();
    if(sc)
        return 0;

    // Better to update the individual extention
    // For now, just rebuild the list
    BuildExtensionList(m_pCurSnapInfo);

    return 0;
}

//----------------------------------------------------------------------------
// CSnapinExtensionPage::BuildSnapinList
//
// Load the combo box with the existing snapins and extensions
//----------------------------------------------------------------------------
void CSnapinExtensionPage::BuildSnapinList()
{
    CSnapinInfoCache* pInfoCache = &m_pManager->m_SnapinInfoCache;

    // Clear the items
    m_SnapComboBox.ResetContent();

    COMBOBOXEXITEM ComboItem;
    ComboItem.mask = CBEIF_LPARAM | CBEIF_IMAGE | CBEIF_TEXT | CBEIF_SELECTEDIMAGE;

    int iCount = 0;

    // Do for all snapinfo objects
    POSITION pos = pInfoCache->GetStartPosition();
    while (pos != NULL)
    {
        USES_CONVERSION;
        GUID clsid;
        PSNAPININFO pSnapInfo;

        pInfoCache->GetNextAssoc(pos, clsid, pSnapInfo);
        ASSERT(pSnapInfo != NULL);

        // Only show snapins that are used and have extensions available
        if (pSnapInfo->IsUsed() && pSnapInfo->IsPermittedByPolicy() &&
            pSnapInfo->GetAvailableExtensions(pInfoCache, m_pManager->m_pMMCPolicy))
        {
            ComboItem.lParam = reinterpret_cast<LPARAM>(pSnapInfo);
            pSnapInfo->LoadImages(m_pManager->m_iml);
            ComboItem.iImage = pSnapInfo->GetImage();
            ComboItem.iSelectedImage = pSnapInfo->GetOpenImage();
            ComboItem.pszText = OLE2T(pSnapInfo->GetSnapinName());

            // CComboBoxEx doesn't support CBS_SORT and has no add method, only insert
            // So we need to find the insertion point ourselves. Because it's a short
            // list, just do a linear search.
            int iInsert;
            for (iInsert = 0; iInsert < iCount; iInsert++)
            {
                PSNAPININFO pSnapEntry = reinterpret_cast<PSNAPININFO>(m_SnapComboBox.GetItemData(iInsert));

				// need to protect ourselves from the invalid snapin registration.
				// see windows bug #401220	( ntbugs9 5/23/2001 )
				if ( NULL == pSnapInfo->GetSnapinName() || NULL == pSnapEntry->GetSnapinName() )
					break;

                if( wcscmp( pSnapInfo->GetSnapinName(), pSnapEntry->GetSnapinName() ) < 0)
                    break;
            }
            ComboItem.iItem = iInsert;

            int iItem = m_SnapComboBox.InsertItem(&ComboItem);
            if (iItem != -1)
            {
                iCount++;
            }
            else
            {
                ASSERT(FALSE);
            }
        }
    }


    int iSelect = -1;

    // if any items in list
    if (iCount > 0)
    {
        // try to get index of previously selected snapin
        if (m_pCurSnapInfo) {
            for (int iFind = 0; iFind < iCount; iFind++)
            {
                if (m_SnapComboBox.GetItemData(iFind) == reinterpret_cast<LPARAM>(m_pCurSnapInfo))
                    iSelect = iFind;
            }
        }

        // if not in list any more, select first item by default
        if (iSelect == -1)
        {
            m_pCurSnapInfo = reinterpret_cast<PSNAPININFO>(m_SnapComboBox.GetItemData(0));
            iSelect = 0;
        }

        m_SnapComboBox.SetCurSel(iSelect);
        m_SnapComboBox.EnableWindow(TRUE);
    }
    else
    {
        // NT 4.0 comctl32 has a bug that displays garbage characters in an empty
        // comboboxex control, so create a phoney item with an blank name.
        // The control is disabled, so the user can't select the item.

        ComboItem.mask = CBEIF_TEXT;
        ComboItem.pszText = _T("");
        ComboItem.iItem = 0;
        m_SnapComboBox.InsertItem(&ComboItem);
        m_SnapComboBox.SetCurSel(0);

        m_pCurSnapInfo = NULL;
        m_SnapComboBox.EnableWindow(FALSE);
    }

    ::EnableWindow(GetDlgItem(IDC_SNAPIN_LABEL), (iCount > 0));

    BuildExtensionList(m_pCurSnapInfo);

    // reset update flag
    m_bUpdateSnapinList = FALSE;
}


//----------------------------------------------------------------------------
// CSnapinExtensionPage::BuildExtensionList
//
// Load list control with available extensions for a snapin.
//----------------------------------------------------------------------------
void CSnapinExtensionPage::BuildExtensionList(PSNAPININFO pSnapInfo)
{
    // Clear the list
    m_ExtListCtrl.DeleteAllItems();

    if (pSnapInfo != NULL)
    {
        LV_ITEM LVItem;
        LVItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE | LVIF_STATE;
        LVItem.stateMask =  LVIS_STATEIMAGEMASK;
        LVItem.iItem = 0;
        LVItem.iSubItem = 0;

        CStr strNotInst;

        // Do for all extensions
        PEXTENSIONLINK pExt = pSnapInfo->GetExtensions();
        while (pExt != NULL)
        {
            PSNAPININFO pExtInfo = pExt->GetSnapinInfo();

            // if permitted by policy
            if (pExtInfo->IsPermittedByPolicy())
            {
                LVItem.lParam = reinterpret_cast<LPARAM>(pExt);
                pExtInfo->LoadImages(m_pManager->m_iml);
                LVItem.iImage = pExtInfo->GetImage();

                USES_CONVERSION;
                CStr strName = OLE2T(pExtInfo->GetSnapinName());

                if (!pExtInfo->IsInstalled())
                {
                    if (strNotInst.IsEmpty())
                        strNotInst.LoadString(GetStringModule(), IDS_NOT_INSTALLED);

                    strName += _T(" ");
                    strName += strNotInst;
                }

                LVItem.pszText = const_cast<LPTSTR>((LPCTSTR)strName);

                // Due to a bug in the ListView code, the checkbox state must be off
                // for insertions to prevent an OFF transition notification
                LVItem.state = CCheckList::CHECKOFF_STATE;

                int iIndex = m_ExtListCtrl.InsertItem(&LVItem);
                ASSERT (iIndex != -1);

                if (iIndex >= 0)
                {
                    // Set checkbox if extension is ON
                    if (pExt->GetState() == CExtensionLink::EXTEN_ON)
                    {
                        // Disable checkbox if it is required by snap-in
                        // or is not installed or all extensiosn are enabled
                        m_ExtListCtrl.SetItemCheck(iIndex, TRUE,
                                    !( pExt->IsRequired() || !pExtInfo->IsInstalled() ||
                                       pSnapInfo->AreAllExtensionsEnabled()) );
                    }
                    else
                    {
                        // if extension is not installed, then disable it
                        if (!pExtInfo->IsInstalled())
                            m_ExtListCtrl.SetItemCheck(iIndex, FALSE, FALSE);
                    }

                    LVItem.iItem++;
                }
            }

            pExt = pExt->Next();
        }

        // Set focus to the first item
        m_ExtListCtrl.SetItemState(0, LVIS_FOCUSED, LVIS_FOCUSED);

        // Provide name of current snapin to Visual Test (it can't get it from a ComboBoxEx)
        USES_CONVERSION;
        ::SetWindowText( GetDlgItem(IDC_VTHELPER), OLE2CT(pSnapInfo->GetSnapinName()) );
    }

    // Set state of "Enable All" checkbox for this snap-in
    BOOL bState = pSnapInfo && pSnapInfo->AreAllExtensionsEnabled();
    ::SendMessage(GetDlgItem(IDC_SNAPIN_ENABLEALL), BM_SETCHECK, (WPARAM)bState, 0);

    // Enable "Enable All" checkbox if it isn't controled by the snap-in
    BOOL bEnable = pSnapInfo &&
                    !(pSnapInfo->GetSnapIn() && pSnapInfo->GetSnapIn()->DoesSnapInEnableAll());
    ::EnableWindow(GetDlgItem(IDC_SNAPIN_ENABLEALL), bEnable);

    // Enable window if extendable snapin selected
    bEnable = pSnapInfo && pSnapInfo->GetExtensions();

    m_ExtListCtrl.EnableWindow(bEnable);
    ::EnableWindow(GetDlgItem(IDC_EXTENSION_LABEL),    bEnable);
    ::EnableWindow(GetDlgItem(IDC_SNAPIN_DESCR_LABEL), bEnable);
    ::EnableWindow(GetDlgItem(IDC_SNAPIN_DESCR),       bEnable);

    // disable "About" and "Download" until extension is selected
    EnableButton(m_hWnd, IDC_SNAPIN_ABOUT, FALSE);
    EnableButton(m_hWnd, IDC_SNAPIN_DOWNLOAD, FALSE);

    // Clear the description text
    SC sc = ScSetDescriptionUIText(GetDlgItem(IDC_SNAPIN_DESCR), _T(""));
    if (sc)
        sc.TraceAndClear();
}


//----------------------------------------------------------------------------
// CSnapinExtensionPage::OnEnableAllChange
//
// Handle change to "enable all extensions" checkbox
//----------------------------------------------------------------------------
LRESULT CSnapinExtensionPage::OnEnableAllChanged( WORD wNotifyCode, WORD wID, HWND hWndCtrl, BOOL& bHandled )
{
    if (m_pCurSnapInfo)
    {
        m_pCurSnapInfo->SetEnableAllExtensions(!m_pCurSnapInfo->AreAllExtensionsEnabled());

        // if enabling all extensions, turn on all installed extensions
        if (m_pCurSnapInfo->AreAllExtensionsEnabled())
        {
            PEXTENSIONLINK pExt = m_pCurSnapInfo->GetExtensions();
            while (pExt != NULL)
            {
                if (pExt->GetSnapinInfo()->IsInstalled())
                    pExt->SetState(CExtensionLink::EXTEN_ON);

                pExt = pExt->Next();
            }
        }

        BuildExtensionList(m_pCurSnapInfo);
    }

    return 0;
}


//----------------------------------------------------------------------------
// CSnapinExtensionPage::OnExtensionChange
//
// Handle change to extension item
//----------------------------------------------------------------------------
LRESULT CSnapinExtensionPage::OnExtensionChanged( int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pnmh;
    PEXTENSIONLINK pExt = (PEXTENSIONLINK)pNMListView->lParam;
    ASSERT(pExt != NULL);

    // if selection state change
    if ( (pNMListView->uOldState ^ pNMListView->uNewState) & LVIS_SELECTED)
    {
        LPOLESTR lpsz = NULL;

        // if selected
        if (pNMListView->uNewState & LVIS_SELECTED)
        {
            // Get description text if any
            if (pExt->GetSnapinInfo())
            {
                pExt->GetSnapinInfo()->LoadAboutInfo();
                lpsz = pExt->GetSnapinInfo()->GetDescription();
            }

            // Save current selection
            m_pExtLink = pExt;
        }
        else
        {
            m_pExtLink = NULL;
        }

        // Update description field
        USES_CONVERSION;
        SC sc = ScSetDescriptionUIText(GetDlgItem(IDC_SNAPIN_DESCR), lpsz ? OLE2T(lpsz) : _T(""));
        if (sc)
            sc.TraceAndClear();
    }

    // if image state change
    if ((pNMListView->uOldState ^ pNMListView->uNewState) & LVIS_STATEIMAGEMASK)
    {
        // Set extension state based on check state
        if ((pNMListView->uNewState & LVIS_STATEIMAGEMASK) == CCheckList::CHECKON_STATE)
        {
            pExt->SetState(CExtensionLink::EXTEN_ON);
        }
        else if ((pNMListView->uNewState & LVIS_STATEIMAGEMASK) == CCheckList::CHECKOFF_STATE)
        {
            pExt->SetState(CExtensionLink::EXTEN_OFF);
        }

        // Trigger rebuild of extendable snapins
        m_bUpdateSnapinList = TRUE;
    }

    // Enable/disable About button
    EnableButton(m_hWnd, IDC_SNAPIN_ABOUT, (m_pExtLink && m_pExtLink->GetSnapinInfo()->HasAbout()));

    // Enable/disable Download button
    EnableButton(m_hWnd, IDC_SNAPIN_DOWNLOAD, (m_pExtLink && !m_pExtLink->GetSnapinInfo()->IsInstalled()));

    return 0;
}


//############################################################################
//############################################################################
//
//  Implementation of class CSnapinManagerAdd
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapinManagerAdd);


//----------------------------------------------------------------------------
// CSnapinManagerAdd::CSnapinManagerAdd
//
// Constructor
//----------------------------------------------------------------------------
CSnapinManagerAdd::CSnapinManagerAdd(CSnapinManager* pManager, CSnapinStandAlonePage* pStandAlonePage)
{
    ASSERT(pManager != NULL);

    m_pListCtrl = NULL;
    m_pManager = pManager;
    m_pStandAlonePage = pStandAlonePage;

    m_pInfoSelected = NULL;
    m_bDoOnce = TRUE;

    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapinManagerAdd);
}


//----------------------------------------------------------------------------
// CSnapinManagerAdd::CSnapinManagerAdd
//
// Destructor
//----------------------------------------------------------------------------
CSnapinManagerAdd::~CSnapinManagerAdd()
{
    delete m_pListCtrl;

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinManagerAdd);
}


//----------------------------------------------------------------------------
// CSnapinManagerAdd::OnInitDialog
//
// Initialize the listview control. Load it with the available snapins.
//----------------------------------------------------------------------------
LRESULT CSnapinManagerAdd::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Move the dialog a single pixel. This disables the default centering
    // so that the coordinates specified in the dialog resource are used.
    RECT rc;
    GetWindowRect(&rc);
    ::OffsetRect(&rc, 1, 1);
    MoveWindow(&rc);

    InitCommonControls();

    m_pListCtrl = new WTL::CListViewCtrl;
    ASSERT(m_pListCtrl != NULL);
	// check the pointer before using it
	// prefix bug #294766 ntbug9 6/27/01
	if ( m_pListCtrl == NULL )
	{
		// get out as quickly as you can
		EndDialog(IDCANCEL);
		return TRUE;
	}

    // Attach list control to member object
    m_pListCtrl->Attach( ::GetDlgItem( m_hWnd, IDC_SNAPIN_LV ) );

    // Attach shared imagelist to it
    m_pListCtrl->SetImageList( m_pManager->m_iml, LVSIL_SMALL );

    // Setup Snap-in and Vendor columns
    m_pListCtrl->GetClientRect(&rc);

    // Adjust width if there will be a vertical scrollbar
    if (m_pListCtrl->GetCountPerPage() < m_pManager->m_SnapinInfoCache.GetCount())
        rc.right -= GetSystemMetrics(SM_CXVSCROLL);

    LV_COLUMN lvc;
    lvc.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

    CStr temp;
    temp.LoadString(GetStringModule(), IDS_SNAPINSTR);
    lvc.pszText = const_cast<LPTSTR>((LPCTSTR)temp);

    lvc.cx = (rc.right*3)/5;
    lvc.iSubItem = 0;

    int iCol = m_pListCtrl->InsertColumn(0, &lvc);
    ASSERT(iCol == 0);

    temp.LoadString(GetStringModule(), IDS_VENDOR);
    lvc.pszText = const_cast<LPTSTR>((LPCTSTR)temp);

    lvc.cx = rc.right - lvc.cx;
    lvc.iSubItem = 1;

    iCol = m_pListCtrl->InsertColumn(1, &lvc);
    ASSERT(iCol == 1);

    m_iGetInfoIndex = -1;

    // Load snapin items
    BuildSnapinList();

    // Turn off the scroll bar in description edit box.
	::ShowScrollBar(GetDlgItem(IDC_SNAPIN_DESCR), SB_VERT, FALSE);

    return TRUE;
}

//----------------------------------------------------------------------------
// CSnapinManagerAdd::BuildSnapinList
//
// Add item to listview for each standalone snapin in the snapin info cache.
//----------------------------------------------------------------------------
void CSnapinManagerAdd::BuildSnapinList()
{
    USES_CONVERSION;
    CSnapinInfoCache* pCache = &m_pManager->m_SnapinInfoCache;

    LV_ITEM LVItem;
    LVItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    LVItem.iItem = 0;
    LVItem.iSubItem = 0;

    POSITION pos = pCache->GetStartPosition();
    while (pos != NULL)
    {
        GUID clsid;
        PSNAPININFO pSnapInfo;

        pCache->GetNextAssoc(pos, clsid, pSnapInfo);
        ASSERT(pSnapInfo != NULL);

        if (pSnapInfo->IsStandAlone() && pSnapInfo->IsPermittedByPolicy())
        {
            // Set image to callback to defer costly image access from ISnapinHelp object.
            LVItem.iImage = I_IMAGECALLBACK ;
            LVItem.pszText = OLE2T( pSnapInfo->GetSnapinName() );
            LVItem.lParam = reinterpret_cast<LPARAM>(pSnapInfo);

            int iIndex = m_pListCtrl->InsertItem(&LVItem);
            ASSERT(iIndex != -1);

            LVItem.iItem++;
        }
    }

    // LV_Item for setting vendor column
    LV_ITEM LVItem2;
    LVItem2.mask = LVIF_TEXT;
    LVItem2.iSubItem = 1;
    LVItem2.pszText = _T("");

    // select the first item
    LVItem.mask = LVIF_STATE;
    LVItem.state = LVIS_SELECTED|LVIS_FOCUSED;
    LVItem.stateMask = LVIS_SELECTED|LVIS_FOCUSED;
    LVItem.iItem = 0;
    m_pListCtrl->SetItem(&LVItem);

    // Post a NULL completion msg to kick off info collection
    PostMessage(MSG_LOADABOUT_COMPLETE, 0, 0);
}


//--------------------------------------------------------------------------
// CSnapinManagerAdd::OnShowWindow
//
// First time dialog is shown, position it offset from its parent
//--------------------------------------------------------------------------
LRESULT CSnapinManagerAdd::OnShowWindow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    BOOL bShow = (BOOL) wParam;
    int nStatus = (int) lParam;

    ::ShowWindow(m_hWnd, bShow);

    // Repos window below of Snapin Manager window
    if (bShow == TRUE && m_bDoOnce == FALSE)
    {
        RECT rc;
        GetWindowRect(&rc);
        ::SetWindowPos(m_hWnd, HWND_TOP, rc.left+14, rc.top+21, 0, 0, SWP_NOSIZE|SWP_NOZORDER);
        m_bDoOnce=FALSE;
    }

    return TRUE;
}

//--------------------------------------------------------------------------
// CSnapinManagerAdd::OnGetDispInfo
//
// Handle deferred loading of item image and vendor information
//--------------------------------------------------------------------------
LRESULT CSnapinManagerAdd::OnGetDispInfo(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    DECLARE_SC(sc, TEXT("CSnapinManagerAdd::OnGetDispInfo"));
    sc = ScCheckPointers(pNMHDR);
    if(sc)
        return 0;

    NMLVDISPINFO* pNMDispInfo = (NMLVDISPINFO*)pNMHDR;

    PSNAPININFO pSnapInfo = reinterpret_cast<PSNAPININFO>(pNMDispInfo->item.lParam);

    sc = ScCheckPointers(pSnapInfo);
    if(sc)
        return 0;

    switch (pNMDispInfo->item.iSubItem)
    {
    case 0:
        // Should only request image for primary item
        ASSERT(pNMDispInfo->item.mask == LVIF_IMAGE);

        // if don't have images yet
        if (pSnapInfo->GetImage() == -1)
        {
            // if snapin supports about
            if (pSnapInfo->HasAbout())
            {
                // use folder for now, background thread will get the image
                pNMDispInfo->item.iImage = eStockImage_Folder;
            }
            else
            {
                // Load images now (will get from MSI database)
                pSnapInfo->LoadImages(m_pManager->m_iml);
                pNMDispInfo->item.iImage = pSnapInfo->GetImage();
            }
        }
        else
        {
           pNMDispInfo->item.iImage = pSnapInfo->GetImage();
        }
        break;

    case 1:
        {
            // Should only request text for sub item
            ASSERT(pNMDispInfo->item.mask == LVIF_TEXT);
            ASSERT(pNMDispInfo->item.pszText != NULL);

            USES_CONVERSION;

            if (pSnapInfo->IsInstalled())
            {
                if (pSnapInfo->GetCompanyName() != NULL)
                {
                    sc = StringCchCopy(pNMDispInfo->item.pszText, pNMDispInfo->item.cchTextMax, OLE2T(pSnapInfo->GetCompanyName()));
                    if(sc)
                        return 0;
                }
                else
                {
                   pNMDispInfo->item.pszText[0] = 0;
                }
            }
            else
            {
                // if snap-in is not installed, display "Not Installed in vendor column
                if (m_strNotInstalled.IsEmpty())
                    m_strNotInstalled.LoadString(GetStringModule(), IDS_NOT_INSTALLED2);

                sc = StringCchCopy(pNMDispInfo->item.pszText, pNMDispInfo->item.cchTextMax, m_strNotInstalled);
                if(sc)
                    return 0;

            }
            break;
        }

    default:
        ASSERT(FALSE);
        return 0;
    }

    bHandled = TRUE;

    return 0;
}

LRESULT CSnapinManagerAdd::OnLoadAboutComplete(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // If real request just completed, do completion processing
    if (wParam != 0)
    {
        PSNAPININFO pSnapInfo = reinterpret_cast<PSNAPININFO>(wParam);

        // If About object exists but didn't provide a ISnapinAbout interface
        // it probably didn't register a threading model so can't be created on
        // a secondary thread. Give it another try on the main thread.
        if (pSnapInfo->GetObjectStatus() == E_NOINTERFACE)
        {
            // Reset error state first or LoadAboutInfo() won't try again
            pSnapInfo->ResetAboutInfo();
            pSnapInfo->LoadAboutInfo();
        }

        // Locate snapin item in list
        LV_FINDINFO find;
        find.flags = LVFI_PARAM;
        find.lParam = wParam;

        int iIndex = m_pListCtrl->FindItem(&find, -1);
        ASSERT(iIndex >= 0);

        // Force update of list item
        pSnapInfo->LoadImages(m_pManager->m_iml);
        m_pListCtrl->Update(iIndex);

        // If item is currently selected
        if (pSnapInfo == m_pInfoSelected)
        {
            // Update the description field
            USES_CONVERSION;
            LPOLESTR lpsz = m_pInfoSelected->GetDescription();

            SC sc = ScSetDescriptionUIText(::GetDlgItem(m_hWnd, IDC_SNAPIN_DESCR), lpsz ? OLE2T(lpsz) : _T(""));
            if (sc)
                sc.TraceAndClear();
        }
    }

    PSNAPININFO pInfoNext = NULL;

    // If selected item doesn't have info, it has first priority
    if (m_pInfoSelected != NULL && m_pInfoSelected->HasAbout() && !m_pInfoSelected->HasInformation())
    {
        pInfoNext = m_pInfoSelected;
    }
    else
    {
        // Else starting with first visible item find snapin that needs info
        int iVisible = m_pListCtrl->GetTopIndex();
        int iItemMax = min(m_pListCtrl->GetItemCount(), iVisible + m_pListCtrl->GetCountPerPage());

        for (int i=0; i<iItemMax; i++)
        {
            LPARAM lParam = m_pListCtrl->GetItemData(i);
            PSNAPININFO pSnapInfo = reinterpret_cast<PSNAPININFO>(lParam);

            if (pSnapInfo->HasAbout() && !pSnapInfo->HasInformation())
            {
                pInfoNext = pSnapInfo;
                break;
            }
        }
    }

    // If all visible items handled, continue through the full list
    if (pInfoNext == NULL)
    {
        // Locate next snap-in
        int iCnt = m_pListCtrl->GetItemCount();
        while (++m_iGetInfoIndex < iCnt)
        {
            LPARAM lParam = m_pListCtrl->GetItemData(m_iGetInfoIndex);
            PSNAPININFO pSnapInfo = reinterpret_cast<PSNAPININFO>(lParam);

            if (pSnapInfo->HasAbout() && !pSnapInfo->HasInformation())
            {
                pInfoNext = pSnapInfo;
                break;
            }
        }
    }

    // if item found, post the info request
    if (pInfoNext != NULL)
        m_pManager->m_AboutInfoThread.PostRequest(pInfoNext, m_hWnd);

    bHandled = TRUE;
    return 0;
}


//--------------------------------------------------------------------------
// CSnapinManagerAdd::OnItemChanged
//
// Handle selection of listview item. Display description text for item.
//--------------------------------------------------------------------------

LRESULT CSnapinManagerAdd::OnItemChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    LPOLESTR lpsz = NULL;

    // if select change
    if ((pNMListView->uOldState ^ pNMListView->uNewState) & LVIS_SELECTED)
    {
        if (pNMListView->uNewState & LVIS_SELECTED)
        {

            m_pInfoSelected = reinterpret_cast<PSNAPININFO>(pNMListView->lParam);

            // get description text from snapin info
            if (m_pInfoSelected->HasInformation() || !m_pInfoSelected->HasAbout())
                lpsz = m_pInfoSelected->GetDescription();
        }
        else
        {
            m_pInfoSelected = NULL;
        }

        // display description
        USES_CONVERSION;
        SC sc = ScSetDescriptionUIText(::GetDlgItem(m_hWnd, IDC_SNAPIN_DESCR), lpsz ? OLE2T(lpsz) : _T(""));
        if (sc)
            sc.TraceAndClear();
     }

    return TRUE;
}


//--------------------------------------------------------------------------
// CSnapinManagerAdd::OnListDblClick
//
// Handle double click in listview. If item selected, do OK processing.
//--------------------------------------------------------------------------
LRESULT CSnapinManagerAdd::OnListDblClick(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{

    // Get mouse position in screen co-ord
    POINT pt;
    DWORD dwPos=GetMessagePos();
    pt.x=LOWORD(dwPos);
    pt.y=HIWORD(dwPos);

    // Find position in result control
    m_pListCtrl->ScreenToClient(&pt);

    // Check for tree object hit
    UINT fHit;
    int iItem = m_pListCtrl->HitTest(pt, &fHit);

    if (iItem!=-1)
    {
        HRESULT hr = m_pStandAlonePage->AddOneSnapin(m_pInfoSelected);
    }


    return TRUE;
}


LRESULT CSnapinManagerAdd::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    WORD wID = LOWORD(wParam);

    switch (wID)
    {
    case IDOK:
        m_pStandAlonePage->AddOneSnapin(m_pInfoSelected);
        break;

    case IDCANCEL:
        EndDialog(wID);
        break;

    default:
        bHandled=FALSE;
    }

    return TRUE;
}


LRESULT CSnapinManagerAdd::OnSysCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (wParam == SC_CLOSE)
        EndDialog(IDCANCEL);
    else
        bHandled=FALSE;

    return TRUE;
}


//--------------------------------------------------------------------------
// EnableButton
//
// Enables or disables a dialog control. If the control has the focus when
// it is disabled, the focus is moved to the next control
//--------------------------------------------------------------------------
void EnableButton(HWND hwndDialog, int iCtrlID, BOOL bEnable)
{
    HWND hWndCtrl = ::GetDlgItem(hwndDialog, iCtrlID);
    ASSERT(::IsWindow(hWndCtrl));

    if (!bEnable && ::GetFocus() == hWndCtrl)
    {
        HWND hWndNextCtrl = ::GetNextDlgTabItem(hwndDialog, hWndCtrl, FALSE);
        if (hWndNextCtrl != NULL && hWndNextCtrl != hWndCtrl)
        {
            ::SetFocus(hWndNextCtrl);
        }
    }

    ::EnableWindow(hWndCtrl, bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\addsnpin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       addsnpin.h
//
//--------------------------------------------------------------------------

// AddSnpIn.h : header file
//

/*
 * CSnapinInfo:
 *    This object represents a snapin entry in the registry. So if same snapin
 *    is added several times to a console they will all refer to same instance
 *    of this object. This object has a linked list of extensions.
 *
 * CExtensionLink:
 *    This object represents an extension snapin. So if an extension extends
 *    two different snapins then there are two instances of this object for
 *    each extension. Each CExtensionLink refers to underlying snapin through
 *    CSnapinInfo. So for the two extensions there will be two CExtensionLink
 *    objects but only one CSnapinInfo object.
 *
 * CSnapinManager:
 *    Has a SnapinInfoCache, standalone & extension pages, policy objects.
 *    It can initialize by populating snapininfo cache, loading mtnode tree
 *    And update the snapin-info cache if there are any changes.
 *
 */

/////////////////////////////////////////////////////////////////////////////
// CSnapinManager dialog

#ifndef __ADDSNPIN_H__
#define __ADDSNPIN_H__

#include "dlgs.h"


#include "ccomboex.h"
#include "regutil.h"  // need HashKey(GUID&) function
#include "about.h"

#define BMP_EXTENSION   0
#define BMP_DIRECTORY   0

#define ADDSNP_ROOTFOLDER   1
#define ADDSNP_SNAPIN       2
#define ADDSNP_EXTENSIONUI  3
#define ADDSNP_EXTENSION    4
#define ADDSNP_STATICNODE   5

#define MSG_LOADABOUT_REQUEST (WM_USER + 100)
#define MSG_LOADABOUT_COMPLETE (WM_USER + 101)

class CSnapinManager;
class CSnapinStandAlonePage;
class CSnapinExtensionPage;
class CSnapinManagerAdd;
class CSnapinInfo;
class CSnapinInfoCache;
class CNewTreeNode;
class CManagerNode;
class CExtensionLink;
class CPolicy;
class CAboutInfoThread;

//-----------------------------------------------------
// CCheckList class
//
// Helper class for listview with checkboxes
//-----------------------------------------------------

class CCheckList : public MMC_ATL::CWindowImpl<CCheckList, WTL::CListViewCtrl>
{
public:
    DECLARE_WND_SUPERCLASS (NULL, WTL::CListViewCtrl::GetWndClassName())

BEGIN_MSG_MAP(CCheckList)
    MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
    MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDblClk )
    MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown )
END_MSG_MAP()

    LRESULT OnKeyDown( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnLButtonDblClk( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnLButtonDown( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

public:
    enum
    {
        CHECKOFF_STATE   = INDEXTOSTATEIMAGEMASK(1),
        CHECKON_STATE    = INDEXTOSTATEIMAGEMASK(2),
        DISABLEOFF_STATE = INDEXTOSTATEIMAGEMASK(3),
        DISABLEON_STATE =  INDEXTOSTATEIMAGEMASK(4)
    };


    BOOL GetItemCheck(int iItem, BOOL* pbEnable = NULL)
    {
        ASSERT(::IsWindow(m_hWnd));
        ASSERT(iItem >= 0 && iItem < GetItemCount());

        int iState = GetItemState(iItem, LVIS_STATEIMAGEMASK);
        if (pbEnable != NULL)
            *pbEnable = (iState <= CHECKON_STATE);

        return (iState == CHECKON_STATE || iState == DISABLEON_STATE);
    }


    void SetItemCheck(int iItem, BOOL bState, BOOL bEnable = TRUE)
    {
        ASSERT(::IsWindow(m_hWnd));
        ASSERT(iItem >= 0 && iItem < GetItemCount());

        int iState = bState ? CHECKON_STATE : CHECKOFF_STATE;
        if (!bEnable)
            iState += (DISABLEOFF_STATE - CHECKOFF_STATE);

        SetItemState(iItem, iState, LVIS_STATEIMAGEMASK);
    }


    void ToggleItemCheck(int iItem)
    {
       ASSERT(::IsWindow(m_hWnd));
       ASSERT(iItem >= 0 && iItem < GetItemCount());

       SetItemState(iItem, GetItemState(iItem, LVIS_STATEIMAGEMASK)^(CHECKON_STATE^CHECKOFF_STATE), LVIS_STATEIMAGEMASK);
    }
};

//-----------------------------------------------------
// CAboutInfoThread
//
// This class handles the creation/deletion of the
// AboutInfo thread. One static instance of this class
// must be defined in addsnpin.cpp.
//-----------------------------------------------------
class CAboutInfoThread
{
public:
    CAboutInfoThread()
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CAboutInfoThread);
        m_hThread = NULL;
        m_hEvent = NULL;
        m_uThreadID = 0;
    }

    ~CAboutInfoThread();

    BOOL StartThread();
    BOOL PostRequest(CSnapinInfo* pSnapInfo, HWND hWndNotify);

private:
    static unsigned _stdcall ThreadProc(void* pVoid);
    HANDLE m_hThread;           // thread handle
    HANDLE m_hEvent;            // start event
    unsigned m_uThreadID;       // thread ID
};

//-----------------------------------------------------
// CSnapinInfo class
//
// Contains the registry information for a snapin.
// Also provides access to the ISnapinAbout information.
//-----------------------------------------------------

typedef CSnapinInfo* PSNAPININFO;

class CSnapinInfo : public CSnapinAbout
{
    friend class CSnapinInfoCache;

public:
    // Constructor/Destructor
    CSnapinInfo (Properties* pInitProps = NULL) :
        m_lRefCnt           (0),
        m_nUseCnt           (0),
        m_iImage            (-1),
        m_iOpenImage        (-1),
        m_spSnapin          (NULL),
        m_pExtensions       (NULL),
        m_spInitProps       (pInitProps),
        m_bAboutValid       (false),
        m_bStandAlone       (false),
        m_bExtendable       (false),
        m_bExtensionsLoaded (false),
        m_bEnableAllExts    (false),
        m_bInstalled        (false),
        m_bPolicyPermission (false)
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapinInfo);
    }

   ~CSnapinInfo();

private:
    // Attributes
    long     m_lRefCnt;                 // COM-type ref count (controls lifetime)
    int      m_nUseCnt;                 // Number of node and extension references
    GUID     m_clsid;                   // snapin CLSID
    GUID     m_clsidAbout;              // About  CLSID
    int      m_iImage;                  // small icon image index
    int      m_iOpenImage;              // index of open image
    CSnapInPtr m_spSnapin;              // ptr to CSnapIn (if snapin in use prior
                                        // to this manager session)
    CExtensionLink* m_pExtensions;      // linked list of extensions
    PropertiesPtr   m_spInitProps;      // properties to initialize with

    bool     m_bAboutValid       : 1;   // TRUE if About CLSID is valid
    bool     m_bStandAlone       : 1;   // TRUE if snapin is standalone
    bool     m_bExtendable       : 1;   // TRUE if snapin can be extended
    bool     m_bExtensionsLoaded : 1;   // Available extensions loaded
    bool     m_bEnableAllExts    : 1;   // TRUE if all extensions enabled
    bool     m_bInstalled        : 1;   // TRUE if snap-in is installed locally
    bool     m_bPolicyPermission : 1;   // Says if current user can use the snapin

public:
    // Operations
    BOOL  InitFromMMCReg(GUID& clsid, CRegKeyEx& regkey, BOOL bPermitted);
    BOOL  InitFromComponentReg(GUID& clsid, LPCTSTR pszName, BOOL bStandAlone, BOOL bPermitted);

    ULONG AddRef(void)
    {
        return InterlockedIncrement(&m_lRefCnt);
    }

    ULONG Release(void)
    {
        LONG lRet = InterlockedDecrement(&m_lRefCnt);
        ASSERT(lRet >= 0);

        if (lRet == 0)
            delete this;

        return static_cast<ULONG>(lRet);
    }

    void  AddUseRef(void);
    void  DeleteUseRef(void);

    GUID& GetCLSID(void) { return m_clsid; }
    void  LoadImages( WTL::CImageList iml );
    int   GetImage(void) { return m_iImage; }
    int   GetOpenImage(void) { return m_iOpenImage; }

    BOOL  IsStandAlone(void) { return m_bStandAlone; }
    BOOL  IsExtendable(void) { return m_bExtendable; }
    BOOL  IsUsed(void) { return (m_nUseCnt != 0); }
    BOOL  AreAllExtensionsEnabled(void) { return m_bEnableAllExts; }
    BOOL  IsInstalled(void) { return m_bInstalled; }

    CSnapIn* GetSnapIn(void) { return m_spSnapin; }
    void  SetSnapIn(CSnapIn* pSnapIn) { m_spSnapin = pSnapIn; }
    void  AttachSnapIn(CSnapIn* pSnapIn, CSnapinInfoCache& InfoCache);
    void  DetachSnapIn() { m_spSnapin = NULL; }
    void SetEnableAllExtensions(BOOL bState) { m_bEnableAllExts = bState; }
    SC    ScInstall(CLSID* pclsidPrimary);

    BOOL  HasAbout(void) { return m_bAboutValid; }
   // const LPOLESTR GetDescription(void);
    void  ShowAboutPages(HWND hWndParent);

    BOOL  IsPermittedByPolicy() { return m_bPolicyPermission; }


    BOOL LoadAboutInfo()
    {
        if (m_bAboutValid && !HasInformation())
        {
           BOOL bStat = GetSnapinInformation(m_clsidAbout);

           // if failure, About object is not really valid
           if (!bStat)
                m_bAboutValid = FALSE;
        }
        return HasInformation();
    }

    void ResetAboutInfo() { m_bAboutValid = TRUE; }

    CExtensionLink* GetExtensions(void) { return m_pExtensions; }
    CExtensionLink* FindExtension(CLSID& ExtCLSID);
    CExtensionLink* GetAvailableExtensions(CSnapinInfoCache* pInfoCache, CPolicy *pMMCPolicy);
    Properties*     GetInitProperties() const {return m_spInitProps; }
    void            SetInitProperties(Properties *pInitProps) { m_spInitProps = pInitProps;}
};

// CMap for holding all CSnapinInfo objects indexed by CLSID
class CSnapinInfoCache : public CMap<GUID, const GUID&, PSNAPININFO, PSNAPININFO>
{
public:
    // Constructor
    CSnapinInfoCache(void) 
    { 
        DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapinInfoCache);
        InitHashTable(31); 
    }

    ~CSnapinInfoCache()
    {
        DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinInfoCache);
    }

    // Operators
    void AddEntry(CSnapinInfo* pSnapInfo)
    {
        SetAt(pSnapInfo->m_clsid, pSnapInfo);
        pSnapInfo->AddRef();
    }
    CSnapinInfo* FindEntry( const GUID& clsid);
#ifdef DBG
    void Dump(void);
#else
    void Dump(void) {}
#endif

};

inline CSnapinInfo* CSnapinInfoCache::FindEntry(const GUID& rclsid)
{
    CSnapinInfo* pSnapInfo = NULL;
    Lookup(rclsid, pSnapInfo);
    return pSnapInfo;
}

template<>
inline UINT HashKey(const GUID& guid)
{
    unsigned short* Values = (unsigned short *)&guid;

    return (Values[0] ^ Values[1] ^ Values[2] ^ Values[3] ^
            Values[4] ^ Values[5] ^ Values[6] ^ Values[7]);
}

//-----------------------------------------------------
// CExtensionLink class
//
// Represents one link from a snapin to an extension.
// Each CSnapinInfo object maintains a list of these.
//-----------------------------------------------------

typedef CExtensionLink* PEXTENSIONLINK;

class CExtensionLink
{
public:
    typedef enum _EXTENSION_STATE
    {
        EXTEN_OFF,
        EXTEN_READY,
        EXTEN_ON
    } EXTENSION_STATE;

    // Constructor/Destructor
    CExtensionLink(CSnapinInfo* pSnapInfo) :
                    m_pSnapInfo(pSnapInfo), m_pNext(NULL), m_iExtTypes(0),
                    m_eOrigState(EXTEN_OFF), m_bRequired(FALSE), m_eCurState(EXTEN_OFF) {}
private:

    // Attributes
    EXTENSION_STATE  m_eOrigState;    // Original state of link
    EXTENSION_STATE  m_eCurState;     // Current state
    BOOL             m_bRequired;     // Is a required extension
    int              m_iExtTypes;     // Extension type flags (from class CExtSI)
    CSnapinInfo*     m_pSnapInfo;     // ptr to extension snapin info
    PEXTENSIONLINK   m_pNext;         // ptr to next extension link

public:
    // Operations
    void SetInitialState(EXTENSION_STATE eState) { m_eOrigState = eState; }
    void SetState(EXTENSION_STATE eState);
    void SetExtTypes(int iExtTypes) { m_iExtTypes = iExtTypes; }
    int GetExtTypes() { return m_iExtTypes; }
    void SetNext(CExtensionLink* pExtNext) { m_pNext = pExtNext; }
    EXTENSION_STATE GetState(void) { return m_eCurState; }
    CSnapinInfo* GetSnapinInfo(void) { return m_pSnapInfo; }
    BOOL IsChanged(void)
    { return (m_eOrigState == EXTEN_ON && m_eCurState != EXTEN_ON) ||
             (m_eOrigState != EXTEN_ON && m_eCurState == EXTEN_ON);
    }
    BOOL IsRequired(void) { return m_bRequired; }
    void SetRequired(BOOL bState = TRUE) { m_bRequired = bState; }
    PEXTENSIONLINK Next(void) { return m_pNext; }
};

//-----------------------------------------------------
// CNewTreeNode class
//
// Holds information for a new node created by the
// snapin manager. The objects are kept in a NewNodeList
// owned by the CSnapinManager. The list is passed to
// the scope tree handler to create the real nodes.
//-----------------------------------------------------

class  CNewTreeNode
{
public:
    // Contructor / Destructor
    CNewTreeNode() : m_pmtNode(NULL), m_pNext(NULL),
                     m_pChild(NULL), m_pParent(NULL), m_pmtNewNode(NULL),
                     m_pmtNewSnapInNode(NULL)
    {};

    ~CNewTreeNode() { if (m_pmtNewNode) m_pmtNewNode->Release(); delete Child(); delete Next(); }

public:
    // Operators
    PNEWTREENODE Next() { return m_pNext; }
    PNEWTREENODE Child() { return m_pChild; }
    PNEWTREENODE Parent() { return m_pParent;}
    CMTNode*     GetMTNode() {return m_pmtNode;}
    VOID         AddChild(PNEWTREENODE pntNode);
    VOID         RemoveChild(PNEWTREENODE pntNode);

public:
    // Attributes
    CMTNode*            m_pmtNode;     // pointer to parent MTNode (NULL if child of new node)
    PNEWTREENODE        m_pNext;       // pointer to next sibling
    PNEWTREENODE        m_pChild;      // pointer to first child
    PNEWTREENODE        m_pParent;     // pointer to new node parent (NULL if child of MTNode)

    //Specific node data
    IComponentDataPtr   m_spIComponentData;  // pointer to the snapin's IComponentData (if snapin)
    CLSID               m_clsidSnapIn;       // snapin CLSID (if snapin)
    CMTNode*            m_pmtNewNode;        // Pointer to new node (if not snapin node)

    PropertiesPtr       m_spSnapinProps;        // pointer to the snap-in's properties
    CMTSnapInNode*      m_pmtNewSnapInNode;     // new snap-in node
};


//------------------------------------------------------
// CManagerNode class
//
// Primary object that node manager handles. Each object
// represents one static standalone node. The objects
// are linked in a tree structure owned by the
// CSnapinManager class.
//------------------------------------------------------

typedef CManagerNode* PMANAGERNODE;
typedef CList <PMANAGERNODE, PMANAGERNODE> ManagerNodeList;

class CManagerNode
{
public:
    // Constructor / Destructor
    CManagerNode(): m_nType(0), m_pmtNode(NULL),
                    m_pSnapInfo(NULL), m_pNewNode(NULL) {}
    ~CManagerNode();

public:
    // Attributes
    PMANAGERNODE    m_pmgnParent;    // pointer to parent node
    ManagerNodeList m_ChildList;     // Child node list

    CStr            m_strValue;       // Display name string
    int             m_nType;          // node type (ADDNSP_SNAPIN or ADDSNP_STATICNODE)

    CMTNode*        m_pmtNode;        // pointer to MTNode (for existing node only)
    PNEWTREENODE    m_pNewNode;       // pointer to new tree node (for new nodes only)
    PSNAPININFO     m_pSnapInfo;      // pointer Snapin information

    int             m_iImage;         // image list indices
    int             m_iOpenImage;
    int             m_iIndent;        // indentation level for tree view

    // Operators
    VOID AddChild(PMANAGERNODE pmgnNode);
    VOID RemoveChild(PMANAGERNODE pmgnNode);
    PSNAPININFO GetSnapinInfo(void) { return m_pSnapInfo; }
    BOOL HasAboutInfo(void) { return (m_pSnapInfo && m_pSnapInfo->HasAbout()); }

};

/*+-------------------------------------------------------------------------*
 * class CSnapinManagerAdd
 *
 *
 * PURPOSE: Dialog for selecting type of snapin to add. Called by
 *          CSnapinStandAlonePage to enable the user to select a page. When the user
 *          selects a snapin, calls back into the CSnapinStandAlonePage to add
 *          the snapin.
 *
 * NOTE:    This object does not know about where in the tree the snapin will
 *          be added. That is handled by the CSnapinStandalone page.
 ************************************************************************/
class CSnapinManagerAdd : public CDialogImpl<CSnapinManagerAdd>
{

// Constructor/Destrcutor
public:
     CSnapinManagerAdd(CSnapinManager* pManager, CSnapinStandAlonePage* pStandAlonePage);
    ~CSnapinManagerAdd();

//MSGMAP
public:
    BEGIN_MSG_MAP(CSnapinManagerAdd)
//        MESSAGE_HANDLER(WM_SHOWWINDOW, OnShowWindow)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_COMMAND, OnCommand)
        MESSAGE_HANDLER(WM_SYSCOMMAND, OnSysCommand);
        CONTEXT_HELP_HANDLER()
        MESSAGE_HANDLER(MSG_LOADABOUT_COMPLETE, OnLoadAboutComplete)
        NOTIFY_HANDLER(IDC_SNAPIN_LV, LVN_ITEMCHANGED, OnItemChanged)
        NOTIFY_HANDLER(IDC_SNAPIN_LV, LVN_GETDISPINFO, OnGetDispInfo)
        NOTIFY_HANDLER(IDC_SNAPIN_LV, NM_DBLCLK, OnListDblClick)
    END_MSG_MAP()

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_SNAPIN_MANAGER_ADD);

// Operators
    PSNAPININFO SelectedInfo() { return m_pInfoSelected; }

public:
    // Operators
    enum { IDD = IDD_SNAPIN_MANAGER_ADD };

// Generated message map functions
protected:
    LRESULT OnShowWindow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSysCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    LRESULT OnGetDispInfo(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    LRESULT OnListDblClick(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    LRESULT OnLoadAboutComplete(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);


    void BuildSnapinList();

    // Attributes
    CSnapinManager* m_pManager;               // Pointer to owning manager
    CSnapinStandAlonePage* m_pStandAlonePage; // Pointer to calling page
    WTL::CListViewCtrl*  m_pListCtrl;         // snapin listview
    BOOL        m_bDoOnce;                    // TRUE first time through ShowWindow
    PSNAPININFO m_pInfoSelected;              // Selected snapin info
    int         m_iGetInfoIndex;              // index of snapin with pending About info
    CStr        m_strNotInstalled;            // string to display for uninstalled snap-ins
};

//------------------------------------------------------
// CSnapinStandAlonePage class
//
// The property page for adding/removing standalone
// snapin nodes.
//------------------------------------------------------

class CSnapinStandAlonePage : public WTL::CPropertyPageImpl<CSnapinStandAlonePage>
{

public:
    typedef WTL::CPropertyPageImpl<CSnapinStandAlonePage> BC;

    // Constructor/destructor
    CSnapinStandAlonePage(CSnapinManager* pManager);
    ~CSnapinStandAlonePage();

    enum { IDD = IDD_SNAPIN_STANDALONE_PROPP };

private:
    CSnapinManagerAdd& GetAddDialog()  {return m_dlgAdd;}

private:
    // attributes
    CSnapinManager*    m_pManager;      // pointer to owning snapin manager
    CSnapinManagerAdd  m_dlgAdd;       // pointer to add dialog
    WTL::CListViewCtrl m_snpListCtrl;   // listview for displaying child nodes
    CComboBoxEx2       m_snpComboBox;   // combobox for selecting parent node
    WTL::CToolBarCtrl     m_ToolbarCtrl;   // toolbar for folder-up button
    PMANAGERNODE       m_pmgnParent;    // currently selcted parent node
    PMANAGERNODE       m_pmgnChild;     // currently selcted child node


protected:
    BEGIN_MSG_MAP( CSnapinStandAlonePage )
        COMMAND_HANDLER(IDC_SNAPIN_COMBOEX, CBN_SELENDOK, OnTreeItemSelect)
        NOTIFY_HANDLER(IDC_SNAPIN_ADDED_LIST, LVN_ITEMCHANGED, OnListItemChanged)
        NOTIFY_HANDLER(IDC_SNAPIN_ADDED_LIST, LVN_KEYDOWN, OnListKeyDown)
        NOTIFY_HANDLER(IDC_SNAPIN_ADDED_LIST, NM_DBLCLK, OnListItemDblClick)
        COMMAND_ID_HANDLER(ID_SNP_UP, OnTreeUp)
        COMMAND_ID_HANDLER(IDC_SNAPIN_MANAGER_ADD, OnAddSnapin)
        COMMAND_ID_HANDLER(IDC_SNAPIN_MANAGER_DELETE, OnDeleteSnapin)
        COMMAND_ID_HANDLER(IDC_SNAPIN_ABOUT, OnAboutSnapin)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CONTEXT_HELP_HANDLER()
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_SNAPIN_STANDALONE_PROPP);

    // operations
    LRESULT OnTreeItemSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnListItemChanged( int idCtrl, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnListKeyDown( int idCtrl, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnListItemDblClick( int idCtrl, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnTreeUp( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnAddSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnDeleteSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnAboutSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

    VOID AddNodeListToTree(ManagerNodeList& NodeList);
    int  AddChildToTree(PMANAGERNODE pMgrNode);
    VOID DisplayChildList(ManagerNodeList& NodeList);
    int  AddChildToList(PMANAGERNODE pMgrNode, int iIndex = -1);
    VOID SelectParentNodeItem(PMANAGERNODE pMgrNode);
    VOID SetupParentNode(PMANAGERNODE pMgrNode, bool bVisible = true);
    VOID SetupChildNode(PMANAGERNODE pMgrNode);

    SC ScRunSnapinWizard (const CLSID& clsid, HWND hwndParent,
                          Properties* pInitProps,
                          IComponentData*& rpComponentData,
                          Properties*& rpSnapinProps);

public:
    HRESULT AddOneSnapin(CSnapinInfo* pSnapInfo, bool bVisible = true);
    SC      ScAddOneSnapin(PMANAGERNODE pmgNodeParent, PSNAPININFO pSnapInfo);

    SC      ScRemoveOneSnapin(PMANAGERNODE pmgNodeTobeRemoved, int iItem, bool bVisible = true);
};



//------------------------------------------------------
// CSnapinExtensionPage class
//
// The property page configuring snapin extensions.
//------------------------------------------------------

class CSnapinExtensionPage : public WTL::CPropertyPageImpl<CSnapinExtensionPage>
{

public:
    typedef WTL::CPropertyPageImpl<CSnapinExtensionPage> BC;

    // Constructor/destructor
    CSnapinExtensionPage(CSnapinManager* pManager) :
                m_pManager(pManager), m_pCurSnapInfo(NULL), m_pExtLink(NULL) {}

    ~CSnapinExtensionPage();

    enum { IDD = IDD_SNAPIN_EXTENSION_PROPP };

private:
    // Attributes

    CSnapinManager* m_pManager;          // ptr to owning manager
    CComboBoxEx2 m_SnapComboBox;          // combobox for selecting snapin
    CCheckList       m_ExtListCtrl;      // list of extensions
    PSNAPININFO     m_pCurSnapInfo;      // currently selected snapin
    PEXTENSIONLINK  m_pExtLink;          // currently selected extension
    BOOL            m_bUpdateSnapinList; // TRUE if snapin list may have changed
    WTL::CImageList m_ilCheckbox;        // checkbox image list

protected:
    BEGIN_MSG_MAP(CSnapinExtensPage)
        COMMAND_HANDLER( IDC_SNAPIN_COMBOEX, CBN_SELENDOK, OnSnapinSelect )
        COMMAND_HANDLER( IDC_SNAPIN_COMBOEX, CBN_DROPDOWN, OnSnapinDropDown )
        COMMAND_HANDLER( IDC_SNAPIN_ENABLEALL, BN_CLICKED, OnEnableAllChanged )
        COMMAND_ID_HANDLER( IDC_SNAPIN_ABOUT, OnAboutSnapin )
        COMMAND_ID_HANDLER( IDC_SNAPIN_DOWNLOAD, OnDownloadSnapin )
        NOTIFY_HANDLER( IDC_EXTENSION_LIST, LVN_ITEMCHANGED, OnExtensionChanged )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CONTEXT_HELP_HANDLER()
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_SNAPIN_EXTENSION_PROPP);

    // Operations
    LRESULT OnSnapinSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnExtensionChanged( int idCtrl, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnEnableAllChanged( WORD wNotifyCode, WORD wID, HWND hWndCtrl, BOOL& bHandled );
    LRESULT OnSnapinDropDown( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnAboutSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnDownloadSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    BOOL OnSetActive(void);

    void BuildSnapinList(void);
    void BuildExtensionList(PSNAPININFO pSnapInfo);
};


//------------------------------------------------------
// CSnapinManager class
//
// Top level mannger object.
//------------------------------------------------------

typedef CList<CMTNode*, CMTNode*> MTNodesList;

class CSnapinManager : public WTL::CPropertySheet
{
    friend class CSnapinStandAlonePage;
    friend class CSnapinExtensionPage;
    friend class CSnapinManagerAdd;

    DECLARE_NOT_COPIABLE   (CSnapinManager)
    DECLARE_NOT_ASSIGNABLE (CSnapinManager)

public:
    // Constructor/Destructor
    CSnapinManager(CMTNode *pmtNode);
    ~CSnapinManager();

    // Attributes
    typedef CList<CSnapIn*, CSnapIn*> SNPList; // TEMP TEMP
    SNPList     m_snpSnapinChangedList;        // List of modified snapins
    MTNodesList m_mtnDeletedNodesList;         // List of delted MT ndoes
    NewNodeList m_NewNodesList;                // Tree of added nodes

    // Operators
    virtual int  DoModal(void);

    MTNodesList* GetDeletedNodesList(void) { return &m_mtnDeletedNodesList; }
    NewNodeList* GetNewNodes(void) { return &m_NewNodesList; }
    SNPList*     GetSnapinChangedList(void) { return &m_snpSnapinChangedList; }
    HRESULT      LoadAboutInfoAsync(PSNAPININFO pSnapInfo, HWND hWndNotify);
    CSnapinInfoCache &GetSnapinInfoCache()  {return m_SnapinInfoCache;}

    SC           ScInitialize();
public:
    // object method operations
    SC          ScAddSnapin(LPCWSTR szSnapinNameOrCLSIDOrProgID, SnapIn* pParentSnapinNode, Properties *pProperties);
    SC          ScRemoveSnapin(CMTNode *pMTNode);
    SC          ScEnableAllExtensions(const CLSID& clsidSnapin, BOOL bEnable);
    SC          ScEnableExtension(const CLSID& clsidPrimarySnapin, const CLSID& clsidExtension, bool bEnable);

protected:
    // Operations
    BOOL LoadMTNodeTree(PMANAGERNODE pmgnParent, CMTNode* pMTNode);
    SC   ScLoadSnapinInfo(void);
    void UpdateSnapInCache();
    PMANAGERNODE FindManagerNode(const ManagerNodeList& mgNodeList, CMTNode *pMTNode);
    SC    ScGetSnapinInfo(LPCWSTR szSnapinNameOrCLSIDOrProgID, CSnapinInfo **ppSnapinInfo);


    // Attributes
    WTL::CImageList  m_iml;                    // imagelist shared by all controls
    CMTNode*         m_pmtNode;                // Root node of master tree
    ManagerNodeList  m_mgNodeList;             // List of manager nodes
    CSnapinInfoCache m_SnapinInfoCache;        // Cache of snapin info objects
    CAboutInfoThread m_AboutInfoThread;        // Worker thread class
    bool             m_bInitialized : 1;       // Should initialize only once.

private:
    // Attributes
    CSnapinStandAlonePage  m_proppStandAlone;   // Standalone property page
    CSnapinExtensionPage   m_proppExtension;    // Extensions property page
    CPolicy               *m_pMMCPolicy;

};


int CALLBACK _ListViewCompareFunc(LPARAM lParam1,LPARAM lParam2,LPARAM lParamSort);

#endif  // __ADDSNPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\cmenu.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cmenu.cpp
//
//--------------------------------------------------------------------------

// cmenu.cpp : Implementation of IContextMenuProvider and DLL registration.

#include "stdafx.h"
#include "oncmenu.h"
#include "menuitem.h"
#include "constatbar.h"
#include "regutil.h"
#include "moreutil.h"
#include "multisel.h"
#include "cmenuinfo.h"
#include "conview.h"
#include "scopndcb.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*+-------------------------------------------------------------------------*
 * class CNativeExtendContextMenu
 *
 *
 * PURPOSE: implements IExtendContextMenu by forwarding calls to CContextMenu
 *          but does not affect lifetime of CContextMenu
 *
 *+-------------------------------------------------------------------------*/
class CNativeExtendContextMenu :
    public CTiedComObject<CContextMenu>,
    public CComObjectRoot,
    public IExtendContextMenu  // this is used so that menu items can be executed uniformly.
{
protected:
    typedef CNativeExtendContextMenu ThisClass;
    typedef CContextMenu CMyTiedObject;

public:

    // com entry points
    BEGIN_COM_MAP(ThisClass)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass)

    // IExtendContexMenu methods
    MMC_METHOD3( AddMenuItems, LPDATAOBJECT, LPCONTEXTMENUCALLBACK, long * );
    MMC_METHOD2( Command, long, LPDATAOBJECT );
};

//############################################################################
//############################################################################
//
//  Implementation of methods on CNodeInitObject that
//  forward to CContextMenu
//
//############################################################################
//############################################################################

CContextMenu *
CNodeInitObject::GetContextMenu()
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::GetContextMenu"));

    if(m_spContextMenu == NULL)
    {
        // check internal pointers
        sc = ScCheckPointers(m_spScopeTree, E_UNEXPECTED);
        if (sc)
            return NULL;

        // get scopetree and call back pointers
        CScopeTree* const pScopeTree =
            dynamic_cast<CScopeTree*>(m_spScopeTree.GetInterfacePtr());

        // if the menu is created by component data, it does not have the node.
        // in that case menu is created by passing NULL pointers to some parameters.
        // Menu should never need those pointers in the mentioned case
        CNodeCallback* pNodeCallback = NULL;
        if ( m_pNode != NULL )
        {
            // check other required pointers
            sc = ScCheckPointers(m_pNode->GetViewData(), E_UNEXPECTED);
            if (sc)
                return NULL;

            pNodeCallback =
                dynamic_cast<CNodeCallback *>(m_pNode->GetViewData()->GetNodeCallback());
        }

        // create context menu
        CContextMenu *pContextMenu = NULL;
        sc = CContextMenu::ScCreateContextMenuForScopeNode(m_pNode, pNodeCallback, pScopeTree,
                                                           &m_spContextMenu, pContextMenu);
        if (sc)
            return NULL;

        sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
        if (sc)
            return NULL;

        return pContextMenu;
    }

    return dynamic_cast<CContextMenu *>(m_spContextMenu.GetInterfacePtr());
}


STDMETHODIMP
CNodeInitObject::AddItem(CONTEXTMENUITEM * pItem)
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::AddItem"));

    CContextMenu *pContextMenu = GetContextMenu();

    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pContextMenu->ScAddItem(pItem, true/*bPassCommandBackToSnapin*/);

    return sc.ToHr();
}



STDMETHODIMP
CNodeInitObject::EmptyMenuList ()
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::EmptyMenuList"));

    if (m_spContextMenu == NULL)
        return S_OK;

    CContextMenu *pContextMenu = GetContextMenu();

    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pContextMenu->EmptyMenuList();

    return sc.ToHr();
}

STDMETHODIMP
CNodeInitObject::AddThirdPartyExtensionItems(IDataObject* piDataObject )
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::AddThirdPartyExtensionItems"));

    CContextMenu *pContextMenu = GetContextMenu();

    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pContextMenu->AddThirdPartyExtensionItems(piDataObject);

    return sc.ToHr();
}

STDMETHODIMP
CNodeInitObject::AddPrimaryExtensionItems(IUnknown* piCallback, IDataObject* piDataObject )
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::AddPrimaryExtensionItems"));

    CContextMenu *pContextMenu = GetContextMenu();

    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pContextMenu->AddPrimaryExtensionItems(piCallback, piDataObject);

    return sc.ToHr();
}

STDMETHODIMP
CNodeInitObject::ShowContextMenu(HWND hwndParent, LONG xPos, LONG yPos, LONG* plSelected)
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::ShowContextMenu"));

    CContextMenu *pContextMenu = GetContextMenu();

    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    pContextMenu->SetStatusBar(GetStatusBar()); // wire up the status bar.

    sc = pContextMenu->ShowContextMenu(hwndParent, xPos, yPos, plSelected);

    return sc.ToHr();
}


//############################################################################
//############################################################################
//
// Implementation of CCommandSink
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CCommandSink
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
class CCommandSink : public CWindowImpl<CCommandSink>
{
// Construction
public:
    CCommandSink( CContextMenu& nodemgr, WTL::CMenu& menu, CConsoleStatusBar * pStatusbar);
    virtual ~CCommandSink();
    BOOL Init();


    LRESULT OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    BEGIN_MSG_MAP(CCommandSink)
        MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
    END_MSG_MAP()

private:
    CContextMenu& m_nodemgr;
    const WTL::CMenu& m_menu;
    CConsoleStatusBar * m_pStatusBar;
};

CCommandSink::CCommandSink( CContextMenu& nodemgr, WTL::CMenu& menu, CConsoleStatusBar * pStatusbar)
:   m_nodemgr( nodemgr ),
    m_menu( menu ),
    m_pStatusBar(pStatusbar)
{
}

CCommandSink::~CCommandSink()
{
}

BOOL CCommandSink::Init()
{

    RECT rcPos = {0,0,0,0};

    Create(NULL, rcPos, _T("ACFx:CxtMenuSink"), WS_POPUP);

    return TRUE;
}



LRESULT CCommandSink::OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    UINT nItemID = (UINT) LOWORD(wParam);   // menu item or submenu index
    UINT nFlags = (UINT) HIWORD(wParam); // menu flags
    HMENU hSysMenu = (HMENU) lParam;          // handle of menu clicked
    TRACE(_T("CCommandSink::OnMenuSelect: nItemID=%d, nFlags=0x%X, hSysMenu=0x%X\n"), nItemID, nFlags, hSysMenu);

    if ( 0xFFFF == nFlags && NULL == hSysMenu )
    {
        /*
         * The system has closed the menu so
         * clear the status bar text, if there's any there.
         */
        if (m_pStatusBar != NULL)
            m_pStatusBar->ScSetStatusText (NULL);

        return 0; // as per Win32 ProgRef
    }

    if ( 0 == nItemID && !(nFlags & MF_POPUP) )
        return 0; // no item selected

    CMenuItem* pmenuitem = NULL;
    if (nFlags & MF_POPUP)
    {
        if ( hSysMenu == m_menu.m_hMenu )
        {
            // We assume menu's cannot be longer than 256 chars
            TCHAR szMenu[256];
            MENUITEMINFO  menuItemInfo;
            menuItemInfo.cbSize = sizeof(MENUITEMINFO);
            menuItemInfo.fMask = MIIM_TYPE;
            menuItemInfo.fType = MFT_STRING;
            menuItemInfo.cch   = 256;
            menuItemInfo.dwTypeData = szMenu;
            ::GetMenuItemInfo(hSysMenu, nItemID, TRUE, &menuItemInfo);
            ASSERT(256 >= (menuItemInfo.cch+1));
            pmenuitem = m_nodemgr.FindNthItemInSubmenu( NULL, nItemID, szMenu );
        }
        else
            pmenuitem = m_nodemgr.FindNthItemInSubmenu( hSysMenu, nItemID, NULL );
    }
    else
        pmenuitem = m_nodemgr.FindMenuItem( nItemID );
    if ( NULL == pmenuitem )
    {
        ASSERT( FALSE );
        return 0;
    }

    if(m_pStatusBar)
        m_pStatusBar->ScSetStatusText( pmenuitem->GetMenuItemStatusBarText() );
    return 0;
}

//############################################################################
//############################################################################
//
// CContextMenu methods - continued from oncmenu.cpp
// These methods were originally in this file and I dont want to move
// them and break history - vivekj
//
//############################################################################
//############################################################################

//+-------------------------------------------------------------------
//
//  Member:      CContextMenu::EmptyMenuList
//
//  Synopsis:    Clear the context menu.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CContextMenu::EmptyMenuList ()
{
    DECLARE_SC(sc, _T("IContextMenuProvider::EmptyMenuList"));

    START_CRITSEC_BOTH

    delete m_pmenuitemRoot;
    m_pmenuitemRoot = NULL;
    m_nNextMenuItemID = MENUITEM_BASE_ID;

    ReleaseSnapinList();
    m_fAddedThirdPartyExtensions = FALSE;
    m_MaxPrimaryOwnerID = OWNERID_PRIMARY_MIN;
    m_MaxThirdPartyOwnerID = OWNERID_THIRD_PARTY_MIN;
    m_CurrentExtensionOwnerID = OWNERID_NATIVE;

    m_fPrimaryInsertionFlags = 0;
    m_fThirdPartyInsertionFlags = 0;

    END_CRITSEC_BOTH

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::RemoveAccelerators
 *
 * PURPOSE: Removes the accelerators from a context menu item name
 *
 * PARAMETERS:
 *    CStr & str :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
RemoveAccelerators(tstring &str)
{
    // in some locales , the accelerators appear at the end eg:  Start (&s). Therefore, remove anything after (&
    int i =  str.find(TEXT( "(&" ));

    if (i != tstring::npos)
        str.erase (i); // remove the waste left over after and including the string "(&"

    tstring::iterator itToTrim = std::remove (str.begin(), str.end(), _T('&'));

    // remove the waste left over after removing accelerator markers
    str.erase (itToTrim, str.end());
}


//+-------------------------------------------------------------------
//
//  Member:      CContextMenu::AddItem
//
//  Synopsis:    Add a menu item to context menu.
//
//  Arguments:   CONTEXTMENUITEM*
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CContextMenu::AddItem( CONTEXTMENUITEM* pItem )
{
    DECLARE_SC(sc, _T("IContextMenuCallback::AddItem"));

    return ( sc = ScAddItem( pItem ) ).ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CContextMenu::ScAddItem
//
//  Synopsis:    Add a menu item to context menu.
//
//  Arguments:   CONTEXTMENUITEM*
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CContextMenu::ScAddItem( CONTEXTMENUITEM* pItem, bool bPassCommandBackToSnapin /*= false*/ )
{
    DECLARE_SC(sc, _T("IContextMenuCallback::ScAddItem"));

    if (NULL == pItem)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL CONTEXTMENUITEM ptr"), sc);
        return sc;
    }


    // added a non-langugage independent context menu item. Cook up a language independent ID.
    // get the menu text and strip out accelerator markers
    tstring strLanguageIndependentName;

    if(pItem->strName)
    {
        USES_CONVERSION;
        strLanguageIndependentName = OLE2CT(pItem->strName);
        RemoveAccelerators(strLanguageIndependentName);
    }

#ifdef DBG
    TRACE(_T("CContextMenu::AddItem name \"%ls\" statusbartext \"%ls\" commandID %ld submenuID %ld flags %ld special %ld\n"),
        SAFEDBGBSTR(pItem->strName),
        SAFEDBGBSTR(pItem->strStatusBarText),
        pItem->lCommandID,
        pItem->lInsertionPointID,
        pItem->fFlags,
        pItem->fSpecialFlags);
#endif

    // leaves critsec claim for DoAddMenuItem

    USES_CONVERSION;
    sc = DoAddMenuItem(   OLE2CT(pItem->strName),
                          OLE2CT(pItem->strStatusBarText),
                          strLanguageIndependentName.data(),
                          pItem->lCommandID,
                          pItem->lInsertionPointID,
                          pItem->fFlags,
                          pItem->fSpecialFlags,
                          m_CurrentExtensionOwnerID,
                          NULL,
                          bPassCommandBackToSnapin );

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CContextMenu::AddItem
//
//  Synopsis:    Add a menu item to context menu.
//
//  Arguments:   CONTEXTMENUITEM2* - includes a language independent name
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CContextMenu::AddItem( CONTEXTMENUITEM2* pItem )
{
    DECLARE_SC(sc, _T("IContextMenuCallback::AddItem"));

    if (NULL == pItem)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL CONTEXTMENUITEM ptr"), sc);
        return sc.ToHr();
    }

    // No language-independent-id ?
    if ( (pItem->strLanguageIndependentName == NULL) ||
         (wcscmp(pItem->strLanguageIndependentName, L"") == 0) )
    {
        // and it is neither a separator nor insertion point.
        if ( !(MF_SEPARATOR & pItem->fFlags) &&
             !(CCM_SPECIAL_INSERTION_POINT & pItem->fSpecialFlags) )
        {
            sc = E_INVALIDARG;
            TraceSnapinError(_T("NULL language-indexpendent-id passed"), sc);
            return sc.ToHr();
        }
    }

#ifdef DBG
    TRACE(_T("CContextMenu::AddItem name \"%ls\" statusbartext \"%ls\" languageIndependentName \"%ls\" commandID %ld submenuID %ld flags %ld special %ld\n"),
        SAFEDBGBSTR(pItem->strName),
        SAFEDBGBSTR(pItem->strStatusBarText),
        SAFEDBGBSTR(pItem->strLanguageIndependentName),
        pItem->lCommandID,
        pItem->lInsertionPointID,
        pItem->fFlags,
        pItem->fSpecialFlags
        );
#endif

    // leaves critsec claim for DoAddMenuItem

    USES_CONVERSION;
    sc = DoAddMenuItem(   OLE2CT(pItem->strName),
                          OLE2CT(pItem->strStatusBarText),
                          OLE2CT(pItem->strLanguageIndependentName),
                          pItem->lCommandID,
                          pItem->lInsertionPointID,
                          pItem->fFlags,
                          pItem->fSpecialFlags,
                          m_CurrentExtensionOwnerID );


    return sc.ToHr();
}



//+-------------------------------------------------------------------
//
//  Member:      CContextMenu::AddPrimaryExtensionItems
//
//  Synopsis:    Ask primary snapin to add menu items.
//
//  Arguments:   [piExtension]
//               [piDataobject]
//
//  Note:        claims critsec
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CContextMenu::AddPrimaryExtensionItems (
                IUnknown*    piExtension,
                IDataObject* piDataObject )
{
    DECLARE_SC(sc, _T("IContextMenuProvider::AddPrimaryExtensionItems"));

    if (NULL == piExtension)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL IUnknown ptr"), sc);
        return sc.ToHr();
    }

    if (NULL == piDataObject)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL IDataObject ptr"), sc);
        return sc.ToHr();
    }

    // control reentrant access to this
    if (!m_fAddingPrimaryExtensionItems)
    {
        m_fAddingPrimaryExtensionItems = true;

        //HRESULT hr = ExtractObjectTypeCStr( piDataObject, &m_strObjectGUID );
        //ASSERT( SUCCEEDED(hr) );

        START_CRITSEC_SNAPIN;
        sc = ScAddSnapinToList_IUnknown( piExtension, piDataObject, m_MaxPrimaryOwnerID++ );
        END_CRITSEC_SNAPIN;

        m_fAddingPrimaryExtensionItems = false;

        // Clear view menu allowed flag
        // A second call may be made to AddPrimaryExtensionItems to handle the other item
        // types only, so the view items must be disabled after the first call.
        m_fPrimaryInsertionFlags &= ~CCM_INSERTIONALLOWED_VIEW;
        if (sc)
            return sc.ToHr();
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CContextMenu::AddThirdPartyExtensionItems
//
//  Synopsis:    Ask extensions to add comtext menu items.
//
//  Arguments:   IDataObject*
//
//  Note:        claims critsec, potentially for a considerable period of time
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CContextMenu::AddThirdPartyExtensionItems (
                IDataObject* piDataObject )
{
    DECLARE_SC(sc, _T("IContextMenuProvider::AddThirdPartyExtensionItems"));

    if (NULL == piDataObject)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL piDataObject"), sc);
        return sc.ToHr();
    }

    START_CRITSEC_SNAPIN;

    // Extensions may only be added once, otherwise return S_FALSE
    if (m_fAddedThirdPartyExtensions == TRUE)
    {
        sc = S_FALSE;
        TraceNodeMgrLegacy(_T("CContextMenu::AddThirdPartyExtensionItems>> Menu already extended"), sc);
        return sc.ToHr();
    }

    m_fAddedThirdPartyExtensions = TRUE;

    do // not a loop
    {
        CExtensionsIterator it;
        sc = it.ScInitialize(piDataObject, g_szContextMenu);
        if (sc)
        {
            sc = S_FALSE;
            break;
        }

        BOOL fProblem = FALSE;

        for (; it.IsEnd() == FALSE; it.Advance())
        {
            sc = ScAddSnapinToList_GUID(it.GetCLSID(), piDataObject,
                                        m_MaxThirdPartyOwnerID++);

            if (sc)
                fProblem = TRUE;    // Continue even on error.
        }

        if (fProblem == TRUE)
            sc = S_FALSE;

    } while (0);

    END_CRITSEC_SNAPIN;

    return sc.ToHr();
}


// claims critsec, potentially for a considerable period of time
STDMETHODIMP CContextMenu::AddMultiSelectExtensionItems (
                 LONG_PTR lMultiSelection)
{
    
    if (lMultiSelection == 0)
        return E_INVALIDARG;

    CMultiSelection* pMS = reinterpret_cast<CMultiSelection*>(lMultiSelection);
    ASSERT(pMS != NULL);

    TRACE_METHOD(CContextMenu,AddThirdPartyExtensionItems);
    TRACE(_T("CContextMenu::AddThirdPartyExtensionItems"));

    START_CRITSEC_SNAPIN;

    // Extensions may only be added once, otherwise return S_FALSE
    if (m_fAddedThirdPartyExtensions == TRUE)
    {
        TRACE(_T("CContextMenu::AddThirdPartyExtensionItems>> Menu already extended"));
        return S_FALSE;
    }

    m_fAddedThirdPartyExtensions = TRUE;

    do // not a loop
    {
        CList<CLSID, CLSID&> snapinClsidList;
        HRESULT hr = pMS->GetExtensionSnapins(g_szContextMenu, snapinClsidList);
        BREAK_ON_FAIL(hr);

        POSITION pos = snapinClsidList.GetHeadPosition();
        if (pos == NULL)
            break;

        CLSID clsid;

        IDataObjectPtr spDataObject;
        hr = pMS->GetMultiSelDataObject(&spDataObject);
        ASSERT(SUCCEEDED(hr));
        BREAK_ON_FAIL(hr);

        BOOL fProblem = FALSE;

        while (pos)
        {
            clsid = snapinClsidList.GetNext(pos);
            hr = ScAddSnapinToList_GUID(clsid, spDataObject,
                                        m_MaxThirdPartyOwnerID++).ToHr();
            CHECK_HRESULT(hr);
            if (FAILED(hr))
                fProblem = TRUE;    // Continue even on error.
        }

        if (fProblem == TRUE)
            hr = S_FALSE;

    } while (0);

    END_CRITSEC_SNAPIN;

    return S_OK;

}

// Worker function, called recursively by FindMenuItem
// critsec should already be claimed
// If fFindSubmenu, then nMenuItemID is actually an HMENU
CMenuItem* FindWorker( MenuItemList& list, LONG_PTR nMenuItemID, BOOL fFindSubmenu )
{
    POSITION pos = list.GetHeadPosition();
    while(pos)
    {
        CMenuItem* pItem = list.GetNext(pos);
        if ( !fFindSubmenu && pItem->GetMenuItemID() == nMenuItemID )
        {
            // Found a match
            return pItem;
        } else
        if ( pItem->HasChildList() )
        {
            if ( fFindSubmenu &&
                 pItem->GetPopupMenuHandle() == (HMENU)nMenuItemID &&
                 !pItem->IsSpecialInsertionPoint() ) // "insertion point" is not real menu
                return pItem;
            pItem = FindWorker( pItem->GetMenuItemSubmenu(), nMenuItemID, fFindSubmenu );
            if (NULL != pItem)
                return pItem;
        }
    }

    return NULL;
}

MenuItemList* CContextMenu::GetMenuItemList()
{
    if (NULL == m_pmenuitemRoot)
        m_pmenuitemRoot = new CRootMenuItem;

    if (m_pmenuitemRoot == NULL)
    {
        return NULL;
    }

    return &m_pmenuitemRoot->GetMenuItemSubmenu();
}

// critsec should already be claimed
CMenuItem* CContextMenu::FindMenuItem( LONG_PTR nMenuItemID, BOOL fFindSubmenu )
{
	DECLARE_SC(sc, TEXT("CContextMenu::FindMenuItem"));

    if (0 == nMenuItemID || CCM_INSERTIONPOINTID_ROOT_MENU == nMenuItemID)
        return m_pmenuitemRoot;
    else
	{
		MenuItemList* plist = GetMenuItemList();
		sc = ScCheckPointers( plist );
		if (sc)
			return NULL;

        return FindWorker( *plist, nMenuItemID, fFindSubmenu );
	}
}

/*+-------------------------------------------------------------------------*
 *
 * ReverseFindWorker
 *
 * PURPOSE:  Worker function, called recursively by ReverseFindMenuItem
 *           critsec should already be claimed
 *
 * PARAMETERS:
 *    MenuItemList&  list :
 *    long           nCommandID :
 *    MENU_OWNER_ID  ownerID :
 *    CStr &         strPath :
 *
 * RETURNS:
 *    CMenuItem*
 *
 *+-------------------------------------------------------------------------*/
CMenuItem*
ReverseFindWorker( MenuItemList& list, long nCommandID, MENU_OWNER_ID ownerID, CStr &strPath, CStr &strLanguageIndependentPath )
{
    POSITION pos = list.GetHeadPosition();
    while(pos)
    {
        CMenuItem* pItem = list.GetNext(pos);
        if (    pItem->GetCommandID() == nCommandID
            &&  (    (pItem->GetMenuItemOwner() == ownerID)
                  || IsSharedInsertionPointID(nCommandID)
                )
           )
        {
            // Found a match - add it to the path and return
            strPath                     = pItem->GetPath();
            strLanguageIndependentPath  = pItem->GetLanguageIndependentPath();

            return pItem;
        }
        else if ( pItem->HasChildList() )
        {
            pItem = ReverseFindWorker( pItem->GetMenuItemSubmenu(), nCommandID, ownerID, strPath, strLanguageIndependentPath );
            if (NULL != pItem)
            {
                return pItem;
            }
        }
    }

    return NULL;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ReverseFindMenuItem
 *
 * PURPOSE: Searches for the specified menu item. Also builds up the
 *          path to the menu item in strPath.
 *
 * NOTE:    critsec should already be claimed
 *
 * PARAMETERS:
 *    long           nCommandID :
 *    MENU_OWNER_ID  ownerID :
 *    CStr &         strPath :
 *
 * RETURNS:
 *    CMenuItem*
 *
 *+-------------------------------------------------------------------------*/
CMenuItem*
CContextMenu::ReverseFindMenuItem( long nCommandID, MENU_OWNER_ID ownerID, CStr &strPath, CStr &strLanguageIndependentPath)
{
	DECLARE_SC(sc, TEXT("CContextMenu::ReverseFindMenuItem"));

    strPath = TEXT(""); // initialize

    if (CCM_INSERTIONPOINTID_ROOT_MENU == nCommandID)
        return m_pmenuitemRoot;
    else
	{
		MenuItemList* plist = GetMenuItemList();
		sc = ScCheckPointers( plist );
		if (sc)
			return NULL;

        return ReverseFindWorker( *plist, nCommandID, ownerID, strPath, strLanguageIndependentPath);
	}
}

//
// Find Nth item in specified menu/submenu
//
CMenuItem* CContextMenu::FindNthItemInSubmenu( HMENU hmenuParent, UINT iPosition, LPTSTR lpszMenuName )
{
    // locate menu/submenu
    MenuItemList* plist = GetMenuItemList();
    if ( NULL != hmenuParent )
    {
        CMenuItem* pParent = FindMenuItem( (LONG_PTR)hmenuParent, TRUE );
        if ( NULL == pParent )
        {
            ASSERT( FALSE );
            return NULL;
        }
        plist = &pParent->GetMenuItemSubmenu();
    }
    if ( NULL == plist )
    {
        ASSERT( FALSE );
        return NULL;
    }

    // find the Nth item
    POSITION pos = plist->GetHeadPosition();

    if (NULL != lpszMenuName)
    {
        while(pos)
        {
            CMenuItem* pItem = plist->GetNext(pos);
            if (! _tcscmp(lpszMenuName, pItem->GetMenuItemName() ))
            {
                // Found the match
                return pItem;
            }
        }
    }
    else
    {
        while(pos)
        {
            CMenuItem* pItem = plist->GetNext(pos);
            if ( 0 == iPosition-- )
            {
                // Found a match
                return pItem;
            }
        }
    }


    ASSERT( FALSE );
    return NULL;
}

// claims critsec
STDMETHODIMP CContextMenu::DoAddMenuItem(LPCTSTR lpszName,
                                            LPCTSTR lpszStatusBarText,
                                            LPCTSTR lpszLanguageIndependentName,
                                            LONG lCommandID,
                                            LONG lInsertionPointID,
                                            LONG fFlags,
                                            LONG fSpecialFlags,
                                            MENU_OWNER_ID ownerID,
                                            CMenuItem** ppMenuItem /* = NULL */,
                                            bool bPassCommandBackToSnapin /*= false*/ )
{
    DECLARE_SC(sc, TEXT("CContextMenu::DoAddMenuItem"));
    
    // init out param
    if (ppMenuItem)
        *ppMenuItem = NULL;

    // Save test flag now because special flags are modified below
    BOOL bTestOnly = fSpecialFlags & CCM_SPECIAL_TESTONLY;

    if ( OWNERID_INVALID == ownerID )
    {
        TRACE(_T("CContextMenu::DoAddMenuItem(): invalid ownerid"));
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    if (  (CCM_SPECIAL_SEPARATOR & fSpecialFlags)?0:1
          + ((CCM_SPECIAL_SUBMENU|CCM_SPECIAL_DEFAULT_ITEM) & fSpecialFlags)?0:1
          + (CCM_SPECIAL_INSERTION_POINT & fSpecialFlags)?0:1
          > 1 )
    {
        TRACE(_T("CContextMenu::DoAddMenuItem(): invalid combination of special flags"));
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    if (CCM_SPECIAL_SEPARATOR & fSpecialFlags)
    {
        lpszName = NULL;
        lpszStatusBarText = NULL;
        lCommandID = 0;
        fFlags = MF_SEPARATOR | MF_GRAYED | MF_DISABLED;
    }
    if ( CCM_SPECIAL_INSERTION_POINT & fSpecialFlags )
    {
        fFlags = NULL; // be sure to clear MF_POPUP
        fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;
    }
    if ( (CCM_SPECIAL_SUBMENU & fSpecialFlags) && !(MF_POPUP & fFlags) )
    {
        TRACE(_T("CContextMenu::DoAddMenuItem(): CCM_SPECIAL_SUBMENU requires MF_POPUP"));
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    if ( (MF_OWNERDRAW|MF_BITMAP) & fFlags )
    {
        TRACE(_T("CContextMenu::DoAddMenuItem(): MF_OWNERDRAW and MF_BITMAP are invalid"));
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    else if ( !(MF_SEPARATOR & fFlags) &&
              !(CCM_SPECIAL_INSERTION_POINT & fSpecialFlags) &&
              NULL == lpszName )
    {
        TRACE(_T("CContextMenu::DoAddMenuItem(): invalid menuitem text\n"));
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    // note that NULL==lpszStatusBarText is permitted

    START_CRITSEC_MENU;

    //
    // An insertion point of 0 is interpreted the same as CCM_INSERTIONPOINTID_ROOT_MENU
    //
    if (0 == lInsertionPointID)
        lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU;

    //
    // Check that the insertion point ID specified is legal for this customer
    //
    do // false loop
    {
        if ( !IsSpecialInsertionPointID(lInsertionPointID) )
            break;
        if ( IsReservedInsertionPointID(lInsertionPointID) )
        {
            TRACE(_T("CContextMenu::DoAddMenuItem(): using reserved insertion point ID\n"));
            return E_INVALIDARG;
        }
        if ( !IsSharedInsertionPointID(lInsertionPointID) )
            break;
        if ( !IsAddPrimaryInsertionPointID(lInsertionPointID) )
        {
            if ( IsPrimaryOwnerID(ownerID) )
            {
                TRACE(_T("CContextMenu::DoAddMenuItem(): not addprimary insertion point ID\n"));
                return E_INVALIDARG;
            }
        }
        if ( !IsAdd3rdPartyInsertionPointID(lInsertionPointID) )
        {
            if ( IsThirdPartyOwnerID(ownerID) )
            {
                TRACE(_T("CContextMenu::DoAddMenuItem(): not add3rdpartyinsertion point ID\n"));
                return E_INVALIDARG;
            }
        }
    } while (FALSE); // false loop


    //
    // Check that the command ID specified is legal for this customer
    //
    if ( (MF_POPUP & fFlags) || (CCM_SPECIAL_INSERTION_POINT & fSpecialFlags) )
    {
        do // false loop
        {
            if ( !IsSpecialInsertionPointID(lCommandID) )
                break;
            if ( IsReservedInsertionPointID(lCommandID) )
            {
                TRACE(_T("CContextMenu::DoAddMenuItem(): adding reserved insertion point ID\n"));
                ASSERT(FALSE);
                return E_INVALIDARG;
            }
            if ( !IsSharedInsertionPointID(lCommandID) )
                break;
            if ( IsThirdPartyOwnerID(ownerID) )
            {
                TRACE(_T("CContextMenu::DoAddMenuItem(): 3rdparty cannot add shared insertion point"));
                ASSERT(FALSE);
                return E_INVALIDARG;
            }
            else if ( IsPrimaryOwnerID(ownerID) )
            {
                if ( !IsCreatePrimaryInsertionPointID(lCommandID) )
                {
                    TRACE(_T("CContextMenu::DoAddMenuItem(): only system for new !PRIMARYCREATE submenu"));
                    ASSERT(FALSE);
                    return E_INVALIDARG;
                }
            }
            else if ( IsSystemOwnerID(ownerID) )
            {
                if ( IsCreatePrimaryInsertionPointID(lCommandID) )
                {
                    TRACE(_T("CContextMenu::DoAddMenuItem(): only primary extension for new PRIMARYCREATE submenu"));
                    ASSERT(FALSE);
                    return E_INVALIDARG;
                }
            }
        } while (FALSE); // false loop
    }
    else if ( !(CCM_SPECIAL_SEPARATOR & fSpecialFlags) )
    {
        if ( IsReservedCommandID(lCommandID) )
        {
            TRACE(_T("CContextMenu::DoAddMenuItem(): no new RESERVED menu items"));
            ASSERT(FALSE);
            return E_INVALIDARG;
        }
    }

    if (NULL == m_pmenuitemRoot)
        m_pmenuitemRoot = new CRootMenuItem;

    CStr strPath, strLanguageIndependentPath; // this builds up the path of the menu item.

    CMenuItem* pParent = ReverseFindMenuItem( lInsertionPointID, ownerID, strPath, strLanguageIndependentPath);
    if (NULL == pParent)
    {
        TRACE(_T("CContextMenu::DoAddMenuItem(): submenu with command ID %ld owner %ld does not exist"), lInsertionPointID, ownerID );
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    MenuItemList& rMenuList = pParent->GetMenuItemSubmenu();

   // If this is only a test add, return with success now
   if (bTestOnly)
       return S_OK;

   // get the data object and IExtendContextMenu pointer to set in the item.
   IExtendContextMenuPtr spExtendContextMenu;
   IDataObject*          pDataObject = NULL;   // This is used JUST to hold on to the object until Command completes.

   // locate the IExtendContextMenu of the snapin.
   {
       // The selected item was added by an extension
       SnapinStruct* psnapin = FindSnapin( ownerID );

       if(psnapin != NULL)
       {
           pDataObject = psnapin->m_pIDataObject;

           spExtendContextMenu = psnapin->pIExtendContextMenu;
       }
       else
       {
           CTiedComObjectCreator<CNativeExtendContextMenu>::
                                ScCreateAndConnect(*this, spExtendContextMenu);
           // built in items are handled by CContextMenu itself.
       }
   }

    // compute the language independent and language dependent paths for the context menu item.
    CStr strLanguageIndependentName = lpszLanguageIndependentName;
    tstring tstrName                = lpszName ? lpszName : TEXT("");

    RemoveAccelerators(tstrName);

    CStr strName;

    strName = tstrName.data(); // got to standardise on either tstring or CStr

    // add a "->" separator to the path if needed
    if(!strPath.IsEmpty() && !strName.IsEmpty())
       strPath +=  _T("->");
    strPath +=  strName;

    // add a "->" separator to the language independent path if needed
    if(!strLanguageIndependentPath.IsEmpty() && !strLanguageIndependentName.IsEmpty())
       strLanguageIndependentPath +=  _T("->");
    strLanguageIndependentPath +=  strLanguageIndependentName;


    CMenuItem* pItem = new CMenuItem(
        lpszName,
        lpszStatusBarText,
        lpszLanguageIndependentName,
        (LPCTSTR)strPath,
        (LPCTSTR)strLanguageIndependentPath,
        lCommandID,
        m_nNextMenuItemID++,
        fFlags,
        ownerID,
        spExtendContextMenu,
        pDataObject,
        fSpecialFlags,
        bPassCommandBackToSnapin);
    ASSERT( pItem );
    if (pItem == NULL)
        return E_OUTOFMEMORY;

    rMenuList.AddTail(pItem);

    // If this is a system defined insertion point, update the insertion flags
    if (IsSharedInsertionPointID(lCommandID) && !IsCreatePrimaryInsertionPointID(lCommandID))
    {
        long fFlag = ( 1L << (lCommandID & CCM_INSERTIONPOINTID_MASK_FLAGINDEX));

        if (IsAddPrimaryInsertionPointID(lCommandID))
           m_fPrimaryInsertionFlags |= fFlag;

        if (IsAdd3rdPartyInsertionPointID(lCommandID))
           m_fThirdPartyInsertionFlags |= fFlag;
    }

    // return the item if required
    if (ppMenuItem)
        *ppMenuItem = pItem;

    END_CRITSEC_MENU;

    return S_OK;

}

// APP HACK. Workarounding dependency on older FP where they were QI'ing for IConsole from
// IContextMenuCallback, which was working in MMC 1.2, but cannot work in mmc 2.0
// See bug 200621 (Windows bugs (ntbug9) 11/15/2000)
#define WORKAROUND_FOR_FP_REQUIRED

#if defined (WORKAROUND_FOR_FP_REQUIRED)
	/***************************************************************************\
	 *
	 * CLASS:  CWorkaroundWrapperForFrontPageMenu
	 *
	 * PURPOSE: Used from subclassed MMC's IExtendContextMenu interface for FrontPage.
	 *			Contains (in com sense) IContextMenuCallback2 and IContextMenuCallback by forwarding
	 *			them to original interface, but in addition supports QI for IConsole.
	 *			This is a requirement for older FrontPage to work
	 *
	\***************************************************************************/
    class CWorkaroundWrapperForFrontPageMenu :
        public IContextMenuCallback,
        public IContextMenuCallback2,
        public IConsole2,                   // workaround for bug 200621. This is a dummy implementation of IConsole2
        public CComObjectRoot
    {
		friend class CWorkaroundMMCWrapperForFrontPageMenu;
        // pointer to context menu object
        IContextMenuCallbackPtr     m_spIContextMenuCallback;
        IContextMenuCallback2Ptr    m_spIContextMenuCallback2;
    public:

        typedef CWorkaroundWrapperForFrontPageMenu ThisClass;

        // com entry points
        BEGIN_COM_MAP(ThisClass)
            COM_INTERFACE_ENTRY(IContextMenuCallback) // the IContextMenuProvider and IContextMenu
            COM_INTERFACE_ENTRY(IContextMenuCallback2)
            COM_INTERFACE_ENTRY(IConsole)
            COM_INTERFACE_ENTRY(IConsole2)
        END_COM_MAP()

		// just forward...
        STDMETHOD(AddItem) ( CONTEXTMENUITEM* pItem )
        {
            if ( m_spIContextMenuCallback == NULL )
                return E_UNEXPECTED;

            return m_spIContextMenuCallback->AddItem( pItem );
        }

		// just forward...
        STDMETHOD(AddItem) ( CONTEXTMENUITEM2* pItem )
        {
            if ( m_spIContextMenuCallback2 == NULL )
                return E_UNEXPECTED;

            return m_spIContextMenuCallback2->AddItem( pItem );
        }

        // IConsole2 methods - DUMMY - workaround for bug 200621
        STDMETHOD(SetHeader)( LPHEADERCTRL pHeader)			                                        {return E_NOTIMPL;}
        STDMETHOD(SetToolbar)( LPTOOLBAR pToolbar)			                                        {return E_NOTIMPL;}
        STDMETHOD(QueryResultView)( LPUNKNOWN* pUnknown)			                                {return E_NOTIMPL;}
        STDMETHOD(QueryScopeImageList)( LPIMAGELIST* ppImageList)			                        {return E_NOTIMPL;}
        STDMETHOD(QueryResultImageList)( LPIMAGELIST* ppImageList)			                        {return E_NOTIMPL;}
        STDMETHOD(UpdateAllViews)( LPDATAOBJECT lpDataObject,LPARAM data,LONG_PTR hint)	            {return E_NOTIMPL;}
        STDMETHOD(MessageBox)( LPCWSTR lpszText,  LPCWSTR lpszTitle,UINT fuStyle,  int* piRetval)	{return E_NOTIMPL;}
        STDMETHOD(QueryConsoleVerb)( LPCONSOLEVERB * ppConsoleVerb)			                        {return E_NOTIMPL;}
        STDMETHOD(SelectScopeItem)( HSCOPEITEM hScopeItem)			                                {return E_NOTIMPL;}
        STDMETHOD(GetMainWindow)( HWND* phwnd)			
        {
			if (!phwnd)
				return E_INVALIDARG;
            *phwnd = (CScopeTree::GetScopeTree() ? CScopeTree::GetScopeTree()->GetMainWindow() : NULL);
            return S_OK;
        }
        STDMETHOD(NewWindow)( HSCOPEITEM hScopeItem,  unsigned long lOptions)			            {return E_NOTIMPL;}
        STDMETHOD(Expand)( HSCOPEITEM hItem,  BOOL bExpand)			                                {return E_NOTIMPL;}
        STDMETHOD(IsTaskpadViewPreferred)()			                                                {return E_NOTIMPL;}
        STDMETHOD(SetStatusText )( LPOLESTR pszStatusText)			                                {return E_NOTIMPL;}
    };

	/***************************************************************************\
	 *
	 * CLASS:  CWorkaroundMMCWrapperForFrontPageMenu
	 *
	 * PURPOSE: Subclasses MMC's IExtendContextMenu interface for FrontPage.
	 *			Contains ( in com sense) IExtendContextMenu; Forwards calls to default MMC implementation,
	 *			but for AddMenuItems gives itself as a callback interface.
	 *			[ main purpose to have this object is to avoid changing main MMC functions	]
	 *			[ to implement this workaround												]
	 *
	\***************************************************************************/
    class CWorkaroundMMCWrapperForFrontPageMenu :
        public IExtendContextMenu,
        public CComObjectRoot
    {
        // pointer to context menu object
        IExtendContextMenuPtr       m_spExtendContextMenu;
        CNode                      *m_pNode;
    public:

        typedef CWorkaroundMMCWrapperForFrontPageMenu ThisClass;

		// this method is null for all snapins, but FrontPage
		// for FrontPage it wraps and replaces spIUnknown paramter
        static SC ScSubclassFP(const CLSID& clsid,IUnknownPtr &spIUnknown)
        {
            DECLARE_SC(sc, TEXT("CWorkaroundMMCWrapperForFrontPageMenu::ScSubclassFP"));

            static const CLSID CLSID_Fpsrvmmc = { 0xFF5903A8, 0x78D6, 0x11D1,
                                                { 0x92, 0xF6, 0x00, 0x60, 0x97, 0xB0, 0x10, 0x56 } };
            // only required intercept one clsid
            if ( clsid != CLSID_Fpsrvmmc )
                return sc;

            // create self
            typedef CComObject<CWorkaroundMMCWrapperForFrontPageMenu> ThisComObj_t;

            ThisComObj_t *pObj = NULL;
            sc = ThisComObj_t::CreateInstance(&pObj);
            if (sc)
                return sc;

            // cast to avoid member access problems (workarounding compiler)
            ThisClass *pThis = pObj;

            sc = ScCheckPointers( pThis, E_UNEXPECTED );
            if (sc)
                return sc;

            // maintain the lifetime in case of accident
            IUnknownPtr spThis = pThis->GetUnknown();

            // grab on snapin's interface
            pThis->m_spExtendContextMenu = spIUnknown;
            sc = ScCheckPointers( pThis->m_spExtendContextMenu, E_UNEXPECTED );
            if (sc)
                return sc;

            // substitute the snapin (in-out parameter)
            spIUnknown = spThis;
            return sc;
        }

        // com entry points
        BEGIN_COM_MAP(ThisClass)
            COM_INTERFACE_ENTRY(IExtendContextMenu)
        END_COM_MAP()

		// AddMenuItems is the method this object exists for.
		// If we got here, mmc is about to ask FrontPage to add its items to context menu.
		// We'll wrap the callback interface given by MMC with the object implementing
		// phony IConsole - this is required for older FP to work
        STDMETHOD(AddMenuItems)( LPDATAOBJECT piDataObject, LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed )
        {
			DECLARE_SC(sc, TEXT("CWorkaroundMMCWrapperForFrontPageMenu::AddMenuItems"));

            IContextMenuCallbackPtr		spIContextMenuCallback = piCallback;
            IContextMenuCallback2Ptr	spIContextMenuCallback2 = piCallback;
            if ( m_spExtendContextMenu == NULL || spIContextMenuCallback == NULL || spIContextMenuCallback2 == NULL )
                return E_UNEXPECTED;

            // create a wrapper for FP
            typedef CComObject<CWorkaroundWrapperForFrontPageMenu> WrapperComObj_t;

            WrapperComObj_t *pObj = NULL;
            sc = WrapperComObj_t::CreateInstance(&pObj);
            if (sc)
                return sc.ToHr();

            // cast to avoid member access problems (workarounding compiler)
            CWorkaroundWrapperForFrontPageMenu *pWrapper = pObj;

            sc = ScCheckPointers( pWrapper, E_UNEXPECTED );
            if (sc)
                return sc.ToHr();

            // maintain the lifetime in case of accident
            IUnknownPtr spWrapper = pWrapper->GetUnknown();

            // grab on snapin's interface
            pWrapper->m_spIContextMenuCallback   = spIContextMenuCallback;
            pWrapper->m_spIContextMenuCallback2  = spIContextMenuCallback2;

            // call snapin on behave on mmc, but pass itself as callback
            sc = m_spExtendContextMenu->AddMenuItems( piDataObject, pWrapper, pInsertionAllowed );
			// fall thru even on error - need to release interfaces

            // reset callback interfaces - not valid after the call anyway...
			// this will let context menu go, and prevent FP from suicide (AV);
			// Following this all calls to IContextMenuCallback would fail,
			// but that's ok, since it is not legal to call them after AddMenuItems.
            pWrapper->m_spIContextMenuCallback   = NULL;
            pWrapper->m_spIContextMenuCallback2  = NULL;

            return sc.ToHr();
        }

		// simply forward....
        STDMETHOD(Command)(long lCommandID, LPDATAOBJECT piDataObject)
        {
            ASSERT( m_spExtendContextMenu != NULL );
            if ( m_spExtendContextMenu == NULL )
                return E_UNEXPECTED;

            return m_spExtendContextMenu->Command(lCommandID, piDataObject);
        }

    };
#endif // defined (WORKAROUND_FOR_FP_REQUIRED)


// critsec should already be claimed
SC CContextMenu::ScAddSnapinToList_GUID(
        const CLSID& clsid,
        IDataObject* piDataObject,
        MENU_OWNER_ID ownerID )
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddSnapinToList_GUID"));

    // cocreate extension
    IUnknownPtr spIUnknown;
    sc = ::CoCreateInstance(clsid, NULL, MMC_CLSCTX_INPROC,
                            IID_IUnknown, (LPVOID*)&spIUnknown);
    if (sc)
        return sc;

#if defined (WORKAROUND_FOR_FP_REQUIRED)
    sc = CWorkaroundMMCWrapperForFrontPageMenu::ScSubclassFP(clsid, spIUnknown);
#endif // defined (WORKAROUND_FOR_FP_REQUIRED)

    // get IExtendContextMenu interface
    IExtendContextMenuPtr spIExtendContextMenu = spIUnknown;
    sc = ScCheckPointers(spIExtendContextMenu, E_NOINTERFACE);
    if (sc)
        return sc;

    // add menu items
    sc = ScAddSnapinToList_IExtendContextMenu(spIExtendContextMenu,
                                              piDataObject, ownerID );
    if (sc)
        return sc;

    return sc;
}

// does not AddRef() or Release() interface pointer
// critsec should already be claimed
SC CContextMenu::ScAddSnapinToList_IUnknown(
        IUnknown* piExtension,
        IDataObject* piDataObject,
        MENU_OWNER_ID ownerID )
{
    DECLARE_SC(sc, TEXT("CContextMenu::AddSnapinToList_IUnknown"));

    // parameter check
    sc = ScCheckPointers(piExtension);
    if (sc)
        return sc;

    IExtendContextMenuPtr spIExtendContextMenu = piExtension;
    if (spIExtendContextMenu == NULL)
        return sc; // snapin does not extend context menus

    // add menu items
    sc =  ScAddSnapinToList_IExtendContextMenu( spIExtendContextMenu, piDataObject, ownerID );
    if (sc)
        return sc;

    return sc;
}

// Interface pointer is Release()d when menu list is emptied
// critsec should already be claimed
SC CContextMenu::ScAddSnapinToList_IExtendContextMenu(
        IExtendContextMenu* pIExtendContextMenu,
        IDataObject* piDataObject,
        MENU_OWNER_ID ownerID )
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddSnapinToList_IExtendContextMenu"));

    // parameter check
    sc = ScCheckPointers(pIExtendContextMenu);
    if (sc)
        return sc;

    SnapinStruct* psnapstruct = new SnapinStruct( pIExtendContextMenu, piDataObject, ownerID );
    sc = ScCheckPointers(psnapstruct, E_OUTOFMEMORY);
    if (sc)
        return sc;

    m_SnapinList->AddTail(psnapstruct);

    m_CurrentExtensionOwnerID = ownerID;

    long fInsertionFlags = IsPrimaryOwnerID(ownerID) ? m_fPrimaryInsertionFlags : m_fThirdPartyInsertionFlags;

    // if view items are requested, then allow only view items
    // view item requests go to the IComponent. If other item types are allowed there
    // will be a second pass through this code directed to the IComponentData.
    long lTempFlags = fInsertionFlags;
    if ( fInsertionFlags & CCM_INSERTIONALLOWED_VIEW )
        lTempFlags = CCM_INSERTIONALLOWED_VIEW;

    //catch all exceptions to show diagnostics to aid end-user in debugging
    //exception is rethrown after diagnostics
    try
    {
        sc = pIExtendContextMenu->AddMenuItems( piDataObject, this, &lTempFlags );
#ifdef DBG
        if (sc)
            TraceSnapinError(_T("IExtendContextMenu::AddMenuItems failed"), sc);
#endif
    }
    catch (...)  
    {
        if (DOBJ_CUSTOMOCX == piDataObject)
        {
            ASSERT( FALSE && "IExtendContextMenu::AddMenuItem of IComponent is called with DOBJ_CUSTOMOCX; snapin potentially derefed this custom data object. Please handle special dataobjects in your snapin.");
        }
        else if (DOBJ_CUSTOMWEB == piDataObject)
        {
            ASSERT( FALSE && "IExtendContextMenu::AddMenuItem of IComponent is called with DOBJ_CUSTOMWEB; snapin potentially derefed this custom data object. Please handle special dataobjects in your snapin.");
        }
        else
        {
            ASSERT( FALSE && "IExtendContextMenu::AddMenuItem implemented by snapin has thrown an exception.");
        }

        throw;
    }

    m_CurrentExtensionOwnerID = OWNERID_NATIVE;
    if (sc)
        return sc;

    // Primary snapin is allowed to clear extension snapin insertion flags
    if ( IsPrimaryOwnerID(ownerID) )
        m_fThirdPartyInsertionFlags &= fInsertionFlags;

    return sc;
}

// All snapin interface pointers are Release()d
// critsec should already be claimed
void CContextMenu::ReleaseSnapinList()
{
    ASSERT(m_SnapinList != NULL);
    if (m_SnapinList != NULL && m_SnapinList->GetCount() != 0)
    {
        POSITION pos = m_SnapinList->GetHeadPosition();

        while(pos)
        {
            SnapinStruct* pItem = (SnapinStruct*)m_SnapinList->GetNext(pos);
            ASSERT_OBJECTPTR( pItem );
            delete pItem;
        }

        m_SnapinList->RemoveAll();
    }
}

// critsec should already be claimed
SnapinStruct* CContextMenu::FindSnapin( MENU_OWNER_ID ownerID )
{
    ASSERT(m_SnapinList != NULL);
    if (m_SnapinList != NULL && m_SnapinList->GetCount() != 0)
    {
        POSITION pos = m_SnapinList->GetHeadPosition();

        while(pos)
        {
            SnapinStruct* pItem = (SnapinStruct*)m_SnapinList->GetNext(pos);
            ASSERT( NULL != pItem );
            if ( ownerID == pItem->m_OwnerID )
                return pItem;
        }
    }
    return NULL;
}

// Worker function, called recursively by ShowContextMenu
// critsec should already be claimed
HRESULT CollapseInsertionPoints( CMenuItem* pmenuitemParent )
{
    ASSERT( NULL != pmenuitemParent && !pmenuitemParent->IsSpecialInsertionPoint() );
    MenuItemList& rMenuList = pmenuitemParent->GetMenuItemSubmenu();

    POSITION pos = rMenuList.GetHeadPosition();
    while(pos)
    {
        POSITION posThisItem = pos;
        CMenuItem* pItem = (rMenuList.GetNext(pos));
        ASSERT( pItem != NULL );
        if ( pItem->IsPopupMenu() )
        {
            ASSERT( !pItem->IsSpecialInsertionPoint() );
            HRESULT hr = CollapseInsertionPoints( pItem );
            if ( FAILED(hr) )
            {
                ASSERT( FALSE );
                return hr;
            }
            continue;
        }
        if ( !pItem->IsSpecialInsertionPoint() )
            continue;

        // we found an insertion point, move its items into this list
        MenuItemList& rInsertedList = pItem->GetMenuItemSubmenu();

        POSITION posInsertAfterThis = posThisItem;
        while ( !rInsertedList.IsEmpty() )
        {
            CMenuItem* pInsertedItem = rInsertedList.RemoveHead();
            posInsertAfterThis = rMenuList.InsertAfter( posInsertAfterThis, pInsertedItem );
        }

        // delete the insertion point item
        rMenuList.RemoveAt(posThisItem);
        delete pItem;

        // restart at head of list, in case of recursive insertion points
        pos = rMenuList.GetHeadPosition();
    }

    return S_OK;
}

// Worker function, called recursively by ShowContextMenu
// critsec should already be claimed and CollapseInsertionPoints should have been called
HRESULT CollapseSpecialSeparators( CMenuItem* pmenuitemParent )
{
    ASSERT( NULL != pmenuitemParent && !pmenuitemParent->IsSpecialInsertionPoint() );
    MenuItemList& rMenuList = pmenuitemParent->GetMenuItemSubmenu();
    CMenuItem* pItem = NULL;

    BOOL fLastItemWasReal = FALSE;
    POSITION pos = rMenuList.GetHeadPosition();
    POSITION posThisItem = pos;
    while(pos)
    {
        posThisItem = pos;
        pItem = (rMenuList.GetNext(pos));
        ASSERT( pItem != NULL );
        ASSERT( !pItem->IsSpecialInsertionPoint() );
        if ( pItem->IsPopupMenu() )
        {
            ASSERT( !pItem->IsSpecialSeparator() );
            HRESULT hr = CollapseSpecialSeparators( pItem );
            if ( FAILED(hr) )
            {
                ASSERT( FALSE );
                return hr;
            }
            fLastItemWasReal = TRUE;
            continue;
        }

        if ( !pItem->IsSpecialSeparator() )
        {
            fLastItemWasReal = TRUE;
            continue;
        }
        if ( fLastItemWasReal )
        {
            fLastItemWasReal = FALSE;
            continue;
        }

        // Found two consecutive special separators, or special seperator as first item
        // delete the insertion point item
        rMenuList.RemoveAt(posThisItem);
        delete pItem;
    }

    if ( !fLastItemWasReal && !rMenuList.IsEmpty() )
    {
        // Found special separator as last item
        delete rMenuList.RemoveTail();
    }

    return S_OK;
}

// Worker function, called recursively by ShowContextMenu
// critsec should already be claimed
HRESULT BuildContextMenu(   WTL::CMenu& menu,
                            CMenuItem* pmenuitemParent )
{
    MenuItemList& rMenuList = pmenuitemParent->GetMenuItemSubmenu();

    int  nCount = 0;
    bool fInsertedItemSinceLastSeparator = false;
    POSITION pos = rMenuList.GetHeadPosition();

    while(pos)
    {
        CMenuItem* pItem = (rMenuList.GetNext(pos));
        ASSERT( pItem != NULL );
        ASSERT( !pItem->IsSpecialInsertionPoint() );

        UINT_PTR nCommandID = pItem->GetMenuItemID();
        long     nFlags     = pItem->GetMenuItemFlags();

        /*
         * special processing for submenus
         */
        if ( pItem->IsPopupMenu() )
        {
            // add items to a submenu
            WTL::CMenu submenu;
            VERIFY( submenu.CreatePopupMenu() );
            HRESULT hr = BuildContextMenu( submenu, pItem );
            if ( FAILED(hr) )
                return hr;
            HMENU hSubmenu = submenu.Detach();
            ASSERT( NULL != hSubmenu );
            nCommandID = (UINT_PTR)hSubmenu;
            pItem->SetPopupMenuHandle( hSubmenu );

            if ( pItem->IsSpecialSubmenu() )
            {
                MenuItemList& rChildMenuList = pItem->GetMenuItemSubmenu();

                if ( rChildMenuList.IsEmpty() )
                {
                    // Bug 151435: remove instead of disabling unused submenus
                    // pItem->SetMenuItemFlags(nFlags | (MF_GRAYED|MF_DISABLED));
                    ::DestroyMenu(hSubmenu);
                    continue;
                }
            }

            fInsertedItemSinceLastSeparator = true;
        }

        /*
         * special processing for separators
         */
        else if (nFlags & MF_SEPARATOR)
        {
            /*
             * if we haven't inserted an item since the last separator,
             * we don't want to insert this one or we'll have consecutive
             * separators, or an unnecessary separator at the top of the menu
             */
            if (!fInsertedItemSinceLastSeparator)
                continue;

            /*
             * if there aren't any more items after this separator,
             * we don't want to insert this one or we'll have an
             * unnecessary separator at the bottom of the menu
             */
            if (pos == NULL)
                continue;

            fInsertedItemSinceLastSeparator = false;
        }

        /*
         * just a normal menu item
         */
        else
        {
            fInsertedItemSinceLastSeparator = true;
        }

        if (!menu.AppendMenu(nFlags, nCommandID, pItem->GetMenuItemName()))
        {
#ifdef DBG
            TRACE(_T("BuildContextMenu: AppendMenu(%ld, %ld, \"%s\") reports error\n"),
                nFlags,
                nCommandID,
                SAFEDBGTCHAR(pItem->GetMenuItemName()) );
#endif

            ASSERT( FALSE );
            return E_UNEXPECTED;
        }

        if (pItem->IsSpecialItemDefault())
        {
            VERIFY( ::SetMenuDefaultItem(menu, nCount, TRUE) );
        }

        ++nCount;
    }

    return S_OK;
}


/*+-------------------------------------------------------------------------*
 * CContextMenu::BuildContextMenu
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      WTL::CMenu &  menu:
 *
 * RETURNS:
 *      HRESULT
/*+-------------------------------------------------------------------------*/
HRESULT
CContextMenu::BuildContextMenu(WTL::CMenu &menu)
{
    HRESULT hr = S_OK;

    hr = ::CollapseInsertionPoints( m_pmenuitemRoot );
    if ( FAILED(hr) )
        return hr;

    hr = ::CollapseSpecialSeparators( m_pmenuitemRoot );
    if ( FAILED(hr) )
        return hr;

    hr = ::BuildContextMenu( menu, m_pmenuitemRoot );
    if ( FAILED(hr) )
        return hr;

    UINT iItems = menu.GetMenuItemCount();
    if ((UINT)-1 == iItems)
    {
        TRACE(_T("CContextMenu::BuildContextMenu(): itemcount error"));
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }
    else if (0 >= iItems)
    {
        TRACE(_T("CContextMenu::BuildContextMenu(): no items added"));
        return S_OK;
    }

    return hr;
}


/*+-------------------------------------------------------------------------*
 * CContextMenu::ShowContextMenu
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      WND     hwndParent:
 *      LONG    xPos:
 *      LONG    yPos:
 *      LONG*   plSelected:
 *
 * RETURNS:
 *      HRESULT
/*+-------------------------------------------------------------------------*/
STDMETHODIMP
CContextMenu::ShowContextMenu(  HWND hwndParent, LONG xPos,
                                LONG yPos, LONG* plSelected)
{
	return (ShowContextMenuEx (hwndParent, xPos, yPos, NULL/*prcExclude*/,
							   true/*bAllowDefaultMenuItem*/, plSelected));
}


STDMETHODIMP
CContextMenu::ShowContextMenuEx(HWND hwndParent, LONG xPos,
                                LONG yPos, LPCRECT prcExclude,
								bool bAllowDefaultMenuItem, LONG* plSelected)
{
    DECLARE_SC(sc, _T("IContextMenuProvider::ShowContextMenuEx"));
    if (NULL == plSelected)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL selected ptr"), sc);
        return sc.ToHr();
    }

    *plSelected = 0;

    WTL::CMenu menu;
    VERIFY( menu.CreatePopupMenu() );

    START_CRITSEC_BOTH;

    if (NULL == m_pmenuitemRoot)
        return sc.ToHr();

    sc = BuildContextMenu(menu);    // build the context menu
    if (sc)
        return sc.ToHr();

    CMenuItem* pItem = NULL;
    LONG lSelected = 0;

    CConsoleStatusBar *pStatusBar = GetStatusBar();

    // At this point, pStatusBar should be non-NULL, either because
    // 1) This function was called by CNodeInitObject, which calls SetStatusBar() first,
    // or 2) by the object model, where m_pNode is always non-NULL.
    ASSERT(pStatusBar);

    // set up the menu command sink and hook up the status bar.
    CCommandSink comsink( *this, menu, pStatusBar);
    if ( !comsink.Init() )
    {
        sc = E_UNEXPECTED;
        TraceNodeMgrLegacy(_T("CContextMenu::ShowContextMenuEx(): comsink error\n"), sc);
        return sc.ToHr();
    }

	/*
	 * if we got an exclusion rectangle, set up a TPMPARAMS to specify it
	 */
	TPMPARAMS* ptpm = NULL;
	TPMPARAMS  tpm;

	if (prcExclude != NULL)
	{
		tpm.cbSize    = sizeof(tpm);
		tpm.rcExclude = *prcExclude;
		ptpm          = &tpm;
	}

	/*
	 * Bug 139708: menu bar popups shouldn't have default menu items.  If
	 * we can't have one on this popup, remove any default item now.
	 */
	if (!bAllowDefaultMenuItem)
		SetMenuDefaultItem (menu, -1, false);

    lSelected = menu.TrackPopupMenuEx(
        TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON | TPM_LEFTBUTTON | TPM_VERTICAL,
        xPos,
        yPos,
        comsink.m_hWnd, // CODEWORK can we eliminate this?
        ptpm );

    comsink.DestroyWindow();

    pItem = (0 == lSelected) ? NULL : FindMenuItem( lSelected );

    if ( pItem != NULL )
    {
        // execute the menu item
        sc = ExecuteMenuItem(pItem);
        if(sc)
            return sc.ToHr();

        // in some cases we'll need to pass command to the sanpin
        if ( pItem->NeedsToPassCommandBackToSnapin() )
            *plSelected = pItem->GetCommandID();
    }
    else
        ASSERT( 0 == lSelected ); // no items selected.

    END_CRITSEC_BOTH;

    return sc.ToHr();
}

HRESULT
CContextMenu::ExecuteMenuItem(CMenuItem *pItem)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ExecuteMenuItem"));

    sc = ScCheckPointers(pItem);
    if(sc)
        return sc.ToHr();

    // execute it;
    sc = pItem->ScExecute();
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\ccomboex.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ccomboex.cpp
//
//--------------------------------------------------------------------------

// CComboex.cpp

#include "stdafx.h"
#include "ccomboex.h"

BOOL CComboBoxEx2::FindItem(COMBOBOXEXITEM* pComboItem, int nStart)
{
    ASSERT(pComboItem != NULL);
    ASSERT(nStart >= -1);

    // Only suport lparam search for now
    ASSERT(pComboItem->mask == CBEIF_LPARAM);

    int nItems = GetCount();

    COMBOBOXEXITEM ComboItem;
    ComboItem.mask = CBEIF_LPARAM;

    for (int iItem = nStart+1; iItem < nItems; iItem++)
    {
        ComboItem.iItem = iItem;
        BOOL bStat = GetItem(&ComboItem);
        ASSERT(bStat);

        if (ComboItem.lParam == pComboItem->lParam)
            return iItem;
    }
        
    return -1;
}

//+-------------------------------------------------------
//
// FindNextBranch(iItem)
//
// This function returns the index of the next item which
// is not within the branch rooted at iItem. If no next
// branch is found, the fucntion returns the item count. 
//+------------------------------------------------------- 
 
int CComboBoxEx2::FindNextBranch(int iItem)
{
    int nItems = GetCount();
    ASSERT(iItem >= 0 && iItem < nItems);

    COMBOBOXEXITEM ComboItem;
    ComboItem.mask = CBEIF_INDENT;

    // Get indent of start item
    ComboItem.iItem = iItem;
    BOOL bStat = GetItem(&ComboItem);
    ASSERT(bStat);
    int iIndent = ComboItem.iIndent;

    // Locate next item with LE indent  
    while (++iItem < nItems)
    {
        ComboItem.iItem = iItem;
        BOOL bStat = GetItem(&ComboItem);
        ASSERT(bStat);

        if (ComboItem.iIndent <= iIndent)
            return iItem;
    }

    return nItems;
}


//+------------------------------------------------------
//
// DeleteBranch
//
// This function deletes the item as the specified index
// and all children of the item.
//+------------------------------------------------------
void CComboBoxEx2::DeleteBranch(int iItem)
{
    int iNextBranch = FindNextBranch(iItem);

    for (int i=iItem; i< iNextBranch; i++)
    {
        DeleteItem(iItem);
    }
}

//+------------------------------------------------------
//
// FixUp
//
// This function is a workaround for two bugs in the NT4
// version of comctl32.dll. First it turns off the 
// nointegralheight style of the inner combo box, which
// the comboxex code forces on during creation. Next it
// adjusts the size of the outer comboboxex wnd to be the 
// same size as the inner combobox wnd. Without this the 
// outer box cuts off the bottom of the inner box. 
//+------------------------------------------------------

void CComboBoxEx2::FixUp()
{
    ASSERT(::IsWindow(m_hWnd));

    HWND hWndCombo = GetComboControl();
    ASSERT(::IsWindow(hWndCombo));

    ::SetWindowLong( hWndCombo, GWL_STYLE, ::GetWindowLong( hWndCombo, GWL_STYLE ) & ~CBS_NOINTEGRALHEIGHT );

    RECT rc;
    ::GetWindowRect(hWndCombo,&rc);
    SetWindowPos(NULL, 0, 0, rc.right - rc.left, rc.bottom - rc.top, SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOREPOSITION|SWP_NOZORDER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\ccomboex.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ccomboex.h
//
//--------------------------------------------------------------------------

// ccomboex.h - Class wrapper for ComboBoxEx control


#ifndef _CCOMBOEX_H_
#define _CCOMBOEX_H_

class CComboBoxEx2 : public WTL::CComboBox
{
public:

    WTL::CImageList SetImageList ( WTL::CImageList ImageList );

    int InsertItem ( COMBOBOXEXITEM* pItem );

    int DeleteItem ( int iItem ); 

    BOOL GetItem ( COMBOBOXEXITEM* pItem );

    int FindItem ( COMBOBOXEXITEM* pItem, int nStart = -1 );

    int FindNextBranch ( int iItem );

    void DeleteBranch ( int iItem );

    HWND GetComboControl( void );

    void FixUp( void );
};

                    
inline WTL::CImageList CComboBoxEx2::SetImageList( WTL::CImageList ImageList)
{
    ASSERT(::IsWindow(m_hWnd));
     
    HIMAGELIST himlOld = (HIMAGELIST) SendMessage(CBEM_SETIMAGELIST, 0, (LPARAM)(ImageList.m_hImageList));
    return (WTL::CImageList (himlOld));
}


inline int CComboBoxEx2::InsertItem(COMBOBOXEXITEM* pItem)
{
    ASSERT(::IsWindow(m_hWnd));
    ASSERT(pItem != NULL);
     
    return SendMessage(CBEM_INSERTITEM, (WPARAM)0, (LPARAM)pItem); 
}

inline int CComboBoxEx2::DeleteItem(int iItem)
{
    ASSERT(::IsWindow(m_hWnd));
    return SendMessage(CBEM_DELETEITEM, (WPARAM)iItem, (LPARAM)0);
}

inline BOOL CComboBoxEx2::GetItem(COMBOBOXEXITEM* pItem)
{
    ASSERT(::IsWindow(m_hWnd));
    ASSERT(pItem != NULL);
     
    return SendMessage(CBEM_GETITEM, (WPARAM)0, (LPARAM)pItem); 
}

inline HWND CComboBoxEx2::GetComboControl(void)
{
    ASSERT(::IsWindow(m_hWnd));
    return (HWND)SendMessage(CBEM_GETCOMBOCONTROL, (WPARAM)0, (LPARAM)0);
}
 
#endif // _CCOMBOEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\coldata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      coldata.cpp
//
//  Contents:  Access Column Persistence data.
//
//  History:   25-Jan-99 AnandhaG    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "columninfo.h"
#include "colwidth.h"

CColumnData::CColumnData()
{
}

CColumnData::~CColumnData()
{
}

//+-------------------------------------------------------------------
//
//  Member:     GetColumnData
//
//  Synopsis:   Helper function to retrieve the column data for a
//              given column-id.
//
//  Arguments:  [pColID]         - Column-Set identifier.
//              [columnSetData]  - CColumnSetData, used to return the
//                                 persisted column information.
//
//  Returns:    S_OK - if data found else S_FALSE.
//
//  History:    01-25-1999   AnandhaG   Created
//              05-04-1999   AnandhaG   Changed first param to SColumnSetID.
//
//--------------------------------------------------------------------
HRESULT CColumnData::GetColumnData(SColumnSetID* pColID, CColumnSetData& columnSetData)
{
    HRESULT hr  = E_FAIL;

    do
    {
        CNodeInitObject* pNodeInit = dynamic_cast<CNodeInitObject*>(this);
        if (! pNodeInit)
            break;

        CViewData* pCV = pNodeInit->m_pNode->GetViewData();
        if (! pCV)
            break;

        CLSID clsidSnapin;
        hr = pNodeInit->GetSnapinCLSID(clsidSnapin);

        if (FAILED(hr))
        {
            ASSERT(FALSE);
            hr = E_FAIL;
            break;
        }

        // Get the persisted column data.
        BOOL bRet = pCV->RetrieveColumnData( clsidSnapin, *pColID, columnSetData);

        // No data.
        if (! bRet)
        {
            hr = S_FALSE;
            break;
        }

        hr = S_OK;

    } while ( FALSE );

    return hr;

}

//+-------------------------------------------------------------------
//
//  Member:     SetColumnData
//
//  Synopsis:   Helper function to set the column data for a
//              given column-id.
//
//  Arguments:  [pColID]         - Column-Set identifier.
//              [columnSetData]  - CColumnSetData, that should be
//                                 persisted.
//
//  Returns:    S_OK - if data is persisted else S_FALSE.
//
//  History:    01-25-1999   AnandhaG   Created
//              05-04-1999   AnandhaG   Changed first param to SColumnSetID.
//
//--------------------------------------------------------------------
HRESULT CColumnData::SetColumnData(SColumnSetID* pColID, CColumnSetData& columnSetData)
{

    HRESULT hr = E_FAIL;

    do
    {
        CNodeInitObject* pNodeInit = dynamic_cast<CNodeInitObject*>(this);
        if (! pNodeInit)
            break;

        CViewData* pCV = pNodeInit->m_pNode->GetViewData();
        if (! pCV)
            break;

        CLSID clsidSnapin;
        hr = pNodeInit->GetSnapinCLSID(clsidSnapin);

        if (FAILED(hr))
        {
            ASSERT(FALSE);
            hr = E_FAIL;
            break;
        }

        // Copy the data into the internal data structures.
        BOOL bRet = pCV->SaveColumnData( clsidSnapin, *pColID, columnSetData);

        if (! bRet)
        {
            hr = E_FAIL;
            break;
        }

        hr = S_OK;

    } while ( FALSE );

    return hr;

}

//+-------------------------------------------------------------------
//
//  Member:     SetColumnConfigData
//
//  Synopsis:   Method snapin can call to set the column data for a
//              given column-id.
//              Any sort data that was persisted will be cleared by
//              this call.
//
//  Arguments:  [pColID]       - Column-Set identifier.
//              [pcolSetData]  - Column data that should be persisted.
//
//  Returns:    S_OK - if data is persisted else S_FALSE.
//
//  History:    01-25-1999   AnandhaG   Created
//              05-04-1999   AnandhaG   Changed first param to SColumnSetID.
//
//--------------------------------------------------------------------
STDMETHODIMP CColumnData::SetColumnConfigData(SColumnSetID* pColID,
                                              MMC_COLUMN_SET_DATA* pColSetData)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IColumnData::SetColumnConfigData"));

    if (NULL == pColID)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL SColumnSetID ptr"), sc);
        return sc.ToHr();
    }

    if (NULL == pColSetData)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL MMC_COLUMN_SET_DATA ptr"), sc);
        return sc.ToHr();
    }

    sc = S_FALSE;

    CColumnInfoList  colInfoList;

    for (int i = 0; i < pColSetData->nNumCols; i++)
    {
		CColumnInfo      colInfo;
        MMC_COLUMN_DATA* pColData = &(pColSetData->pColData[i]);
        colInfo.SetColWidth(pColData->nWidth);
        colInfo.SetColHidden( HDI_HIDDEN & pColData->dwFlags);
        colInfo.SetColIndex(pColData->nColIndex);

        if ( (colInfo.GetColIndex() == 0) && colInfo.IsColHidden() )
            return (sc = E_INVALIDARG).ToHr();

        // Add the CColumnInfo to the list.
        colInfoList.push_back(colInfo);
    }

    CColumnSetData   columnSetData;
    columnSetData.set_ColumnInfoList(colInfoList);
    sc = SetColumnData(pColID, columnSetData);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     GetColumnConfigData
//
//  Synopsis:   Method snapin can call to retrieve the column data for a
//              given column-id.
//
//  Arguments:  [pColID]       - Column-Set identifier.
//              [ppcolSetData] - Persisted column-data that is returned.
//
//  Returns:    S_OK - if data is found else S_FALSE.
//
//  History:    01-25-1999   AnandhaG   Created
//              05-04-1999   AnandhaG   Changed first param to SColumnSetID.
//
//--------------------------------------------------------------------
STDMETHODIMP CColumnData::GetColumnConfigData(SColumnSetID* pColID,
                                              MMC_COLUMN_SET_DATA** ppColSetData)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IColumnData::GetColumnConfigData"));

    if (NULL == pColID)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL SColumnSetID ptr"), sc);
        return sc.ToHr();
    }

    if (NULL == ppColSetData)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL MMC_COLUMN_SET_DATA ptr"), sc);
        return sc.ToHr();
    }

    sc = S_FALSE;
    *ppColSetData = NULL;

    CColumnSetData columnSetData;
    sc = GetColumnData(pColID, columnSetData);

    if (S_OK != sc.ToHr())
        return sc.ToHr();        // data doesnt exist.

    CColumnInfoList* pColInfoList = columnSetData.get_ColumnInfoList();
    CColumnInfo      colInfo;

    int nNumCols = pColInfoList->size();

    if (nNumCols <= 0)
    {
        sc = S_FALSE;
        return sc.ToHr();
    }

    // Allocate memory, copy & return the data.
    int cb       = sizeof(MMC_COLUMN_SET_DATA) + sizeof(MMC_COLUMN_DATA) * nNumCols;
    BYTE* pb     = (BYTE*)::CoTaskMemAlloc(cb);

    if (! pb)
    {
        sc = E_OUTOFMEMORY;
        return sc.ToHr();
    }

    *ppColSetData             = (MMC_COLUMN_SET_DATA*)pb;
    (*ppColSetData)->cbSize   = sizeof(MMC_COLUMN_SET_DATA);
    (*ppColSetData)->nNumCols = nNumCols;
    (*ppColSetData)->pColData = (MMC_COLUMN_DATA*)(pb + sizeof(MMC_COLUMN_SET_DATA));

    CColumnInfoList::iterator itColInfo;

    int i = 0;
    MMC_COLUMN_DATA* pColData     = (*ppColSetData)->pColData;
    for (itColInfo = pColInfoList->begin();itColInfo != pColInfoList->end(); itColInfo++, i++)
    {
        pColData[i].nWidth    = (*itColInfo).GetColWidth();
        pColData[i].dwFlags   = (*itColInfo).IsColHidden() ? HDI_HIDDEN : 0;
        pColData[i].nColIndex = (*itColInfo).GetColIndex();
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     SetColumnSortData
//
//  Synopsis:   Method snapin can call to set the sort data for a
//              given column-id.
//              Any column config data (width, order...) that was
//              persisted will not be affected by this call.
//
//  Arguments:  [pColID]       - Column-Set identifier.
//              [pcolSorData]  - Sort data that should be persisted.
//
//  Returns:    S_OK - if data is persisted else S_FALSE.
//
//  History:    01-25-1999   AnandhaG   Created
//              05-04-1999   AnandhaG   Changed first param to SColumnSetID.
//
//--------------------------------------------------------------------
STDMETHODIMP CColumnData::SetColumnSortData(SColumnSetID* pColID,
                                            MMC_SORT_SET_DATA* pColSortData)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IColumnData::SetColumnSortData"));

    if (NULL == pColID)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL SColumnSetID ptr"), sc);
        return sc.ToHr();
    }

    if (NULL == pColSortData)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL MMC_COLUMN_SET_DATA ptr"), sc);
        return sc.ToHr();
    }

    sc = S_FALSE;

    // First get old data. We need to preserve the width, view info.
    CColumnSetData   columnSetData;
    sc = GetColumnData(pColID, columnSetData);

    if (sc)
        return sc.ToHr();

    CColumnSortList* pColSortList    = columnSetData.get_ColumnSortList();
    pColSortList->clear();

    // For MMC version 1.2 we do only single column sorting.
    if (pColSortData->nNumItems > 1)
    {
        sc = S_FALSE;
        return sc.ToHr();
    }

    CColumnSortInfo  colSortInfo;

    for (int i = 0; i < pColSortData->nNumItems; i++)
    {
        MMC_SORT_DATA* pSortData = &(pColSortData->pSortData[i]);
        ::ZeroMemory(&colSortInfo, sizeof(colSortInfo));
        colSortInfo.m_nCol = pSortData->nColIndex;
        colSortInfo.m_dwSortOptions = pSortData->dwSortOptions;
        colSortInfo.m_lpUserParam   = pSortData->ulReserved;

        // Add the CColumnSortInfo to the list.
        pColSortList->push_back(colSortInfo);
    }

    sc = SetColumnData(pColID, columnSetData);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     GetColumnSortData
//
//  Synopsis:   Method snapin can call to retrieve the column sort data
//              for a given column-id.
//
//  Arguments:  [pColID]        - Column-Set identifier.
//              [ppcolSortData] - Persisted column-sort-data that is returned.
//
//  Returns:    S_OK - if data is found else S_FALSE.
//
//  History:    01-25-1999   AnandhaG   Created
//              05-04-1999   AnandhaG   Changed first param to SColumnSetID.
//
//--------------------------------------------------------------------
STDMETHODIMP CColumnData::GetColumnSortData(SColumnSetID* pColID,
                                            MMC_SORT_SET_DATA** ppColSortData)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IColumnData::SetColumnSortData"));

    if (NULL == pColID)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL SColumnSetID ptr"), sc);
        return sc.ToHr();
    }

    if (NULL == ppColSortData)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL MMC_COLUMN_SET_DATA ptr"), sc);
        return sc.ToHr();
    }

    sc = S_FALSE;
    *ppColSortData = NULL;

    CColumnSetData columnSetData;
    sc = GetColumnData(pColID, columnSetData);

    if (S_OK != sc.ToHr())
        return sc.ToHr();

    CColumnSortList* pColSortList    = columnSetData.get_ColumnSortList();
    CColumnSortInfo  colSortInfo;

    int nNumItems = pColSortList->size();

    if (nNumItems <= 0)
    {
        sc = S_FALSE;
        return sc.ToHr();
    }

    // For MMC 1.2 we sort on only one column.
    ASSERT(nNumItems == 1);

    int cb       = sizeof(MMC_SORT_SET_DATA) + sizeof(MMC_SORT_DATA) * nNumItems;
    BYTE* pb     = (BYTE*)::CoTaskMemAlloc(cb);

    if (! pb)
    {
        sc = E_OUTOFMEMORY;
        return sc.ToHr();
    }

    *ppColSortData              = (MMC_SORT_SET_DATA*)pb;
    (*ppColSortData)->cbSize    = sizeof(MMC_SORT_SET_DATA);
    (*ppColSortData)->nNumItems = nNumItems;
    (*ppColSortData)->pSortData = (MMC_SORT_DATA*)(pb + sizeof(MMC_SORT_SET_DATA));

    CColumnSortList::iterator itSortInfo;

    int i = 0;
    MMC_SORT_DATA* pSortData     = (*ppColSortData)->pSortData;
    for (itSortInfo = pColSortList->begin();itSortInfo != pColSortList->end(); itSortInfo++, i++)
    {
        pSortData[i].nColIndex     = (*itSortInfo).m_nCol;
        pSortData[i].dwSortOptions = (*itSortInfo).m_dwSortOptions;
        pSortData[i].ulReserved    = (*itSortInfo).m_lpUserParam;
    }

    sc = S_OK;

    return sc.ToHr();
}

HRESULT WINAPI ColumnInterfaceFunc(void* pv, REFIID riid, LPVOID* ppv, DWORD_PTR dw)
{
    *ppv = NULL;

    ASSERT(IID_IColumnData == riid);

    CColumnData* pColData = (CColumnData*)(pv);
    CNodeInitObject* pNodeInit = dynamic_cast<CNodeInitObject*>(pColData);

    if (pNodeInit && pNodeInit->GetComponent())
    {
        IColumnData* pIColData = dynamic_cast<IColumnData*>(pNodeInit);
        pIColData->AddRef();
        *ppv = static_cast<void*>(pIColData);

        return S_OK;
    }

    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\coldata.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       coldata.h
//
//  Contents:   Classes to access persisted column data.
//
//  Classes:    CColumnData
//
//  History:    25-Jan-99 AnandhaG     Created
//
//--------------------------------------------------------------------

#ifndef COLDATA_H
#define COLDATA_H

class CNodeInitObject;

/////////////////////////////////////////////////////////////////////////////
// CColumnData
class CColumnData : public IColumnData
{
public:
    CColumnData();
    ~CColumnData();

IMPLEMENTS_SNAPIN_NAME_FOR_DEBUG()

public:
    // IColumnData members.
    STDMETHOD(SetColumnConfigData)(SColumnSetID* pColID,MMC_COLUMN_SET_DATA*  pColSetData);
    STDMETHOD(GetColumnConfigData)(SColumnSetID* pColID,MMC_COLUMN_SET_DATA** ppColSetData);
    STDMETHOD(SetColumnSortData)(SColumnSetID* pColID,MMC_SORT_SET_DATA*  pColSortData);
    STDMETHOD(GetColumnSortData)(SColumnSetID* pColID,MMC_SORT_SET_DATA** ppColSortData);

private:
    HRESULT GetColumnData(SColumnSetID* pColID, CColumnSetData& columnSetData);
    HRESULT SetColumnData(SColumnSetID* pColID, CColumnSetData& columnSetData);
};

HRESULT WINAPI ColumnInterfaceFunc(void* pv, REFIID riid, LPVOID* ppv, DWORD_PTR dw);

#endif /* COLDATA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\colwidth.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      colwidth.cpp
//
//  Contents:  Column Persistence data structures and property pages
//             implementation.
//
//  History:   16-Oct-98 AnandhaG    Created
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "colwidth.h"
#include "macros.h"
#include "comdbg.h"
#include "columninfo.h"

#define MAX_COLUMNS_PERSISTED 50

//+-------------------------------------------------------------------
//
//  Class:      ViewToColSetDataMapPersistor (wrapper, helper)
//
//  Purpose:    wraps ViewToColSetDataMap implementing XML persistence
//              map is persisted as linear list
//
// see "Data structures used to persist column information" comment
// int file colwidth.h for more information
//--------------------------------------------------------------------
class ViewToColSetDataMapPersistor : public XMLListCollectionBase
{
public:
    ViewToColSetDataMapPersistor(ViewToColSetDataMap &map, ColSetDataList &list)
                                : m_map(map),  m_list(list) {}

    DEFINE_XML_TYPE(XML_TAG_COLUMN_SET);
    virtual void  Persist(CPersistor &persistor);
    virtual void  OnNewElement(CPersistor& persistor);
private:
    ViewToColSetDataMap &m_map;     // wrapped map
    ColSetDataList      &m_list;    // value list to persist actual information
};

//+-------------------------------------------------------------------
//
//  Class:      ColSetIDToViewTableMapPersistor (wrapper, helper)
//
//  Purpose:    wraps ColSetIDToViewTableMap implementing XML persistence
//              map is persisted as linear list
//
// see "Data structures used to persist column information" comment
// int file colwidth.h for more information
//--------------------------------------------------------------------
class ColSetIDToViewTableMapPersistor : public XMLListCollectionBase
{
public:
    ColSetIDToViewTableMapPersistor(ColSetIDToViewTableMap &map, ColSetDataList &list)
                                    : m_map(map),  m_list(list) {}

    DEFINE_XML_TYPE(XML_TAG_COLUMN_PERIST_ENTRY);
    virtual void  Persist(CPersistor &persistor);
    virtual void  OnNewElement(CPersistor& persistor);
private:
    ColSetIDToViewTableMap &m_map;  // wrapped map
    ColSetDataList         &m_list; // value list to persist actual information
};

//+-------------------------------------------------------------------
//
//  Class:      SnapinToColSetIDMapPersistor (wrapper, helper)
//
//  Purpose:    wraps SnapinToColSetIDMap implementing XML persistence
//              map is persisted as linear list
//
// see "Data structures used to persist column information" comment
// int file colwidth.h for more information
//--------------------------------------------------------------------
class SnapinToColSetIDMapPersistor : public XMLListCollectionBase
{
public:
    SnapinToColSetIDMapPersistor(SnapinToColSetIDMap &map, ColSetDataList &list)
                               : m_map(map),  m_list(list) {}

    DEFINE_XML_TYPE(XML_TAG_COLUMN_PERIST_ENTRY);
    virtual void  Persist(CPersistor &persistor);
    virtual void  OnNewElement(CPersistor& persistor);

    // prior-to-save cleanup
    SC ScPurgeUnusedColumnData();
private:
    SnapinToColSetIDMap &m_map;     // wrapped map
    ColSetDataList      &m_list;    // value list to persist actual information
};

//+-------------------------------------------------------------------
//
//  Member:     ReadSerialObject
//
//  Synopsis:   Read the given version of CColumnSortInfo object from
//              the given stream.
//
//  Arguments:  [stm]      - The input stream.
//              [nVersion] - version of CColumnSortInfo to be read.
//
//                          The format is :
//                              INT        column index
//                              DWORD      Sort options
//                              ULONG_PTR  Any user (snapin) param
//
//--------------------------------------------------------------------
HRESULT CColumnSortInfo::ReadSerialObject(IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/)
{
    HRESULT hr = S_FALSE;   // assume bad version

    if (GetVersion() >= nVersion)
    {
        try
        {
            stm >> m_nCol;

            // In version we stored just ascending or descending flag
            if (1 == nVersion)
            {
                BYTE bAscend;
                stm >> bAscend;
                m_dwSortOptions |= (bAscend ? 0 : RSI_DESCENDING);
            }
            else if (nVersion > 1)
            {
                // Versions greater than 1 has these sort data which
                // includes ascend/descend flags and a user param.
                stm >> m_dwSortOptions;
                stm >> m_lpUserParam;
            }

            hr = S_OK;
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CColumnSortInfo::Persist
//
//  Synopsis:   Persists object data
//
//  Arguments:
//
//  History:    10-10-1999   AudriusZ   Created
//
//--------------------------------------------------------------------
void CColumnSortInfo::Persist(CPersistor &persistor)
{
    persistor.PersistAttribute(XML_ATTR_COLUMN_SORT_INFO_COLMN,  m_nCol) ;

    static const EnumLiteral sortOptions[] =
    {
        { RSI_DESCENDING,      XML_BITFLAG_COL_SORT_DESCENDING },
        { RSI_NOSORTICON,      XML_BITFLAG_COL_SORT_NOSORTICON },
    };

    CXMLBitFlags optionPersistor(m_dwSortOptions, sortOptions, countof(sortOptions));

    persistor.PersistAttribute(XML_ATTR_COLUMN_SORT_INFO_OPTNS, optionPersistor) ;
}

//+-------------------------------------------------------------------
//
//  Member:     ReadSerialObject
//
//  Synopsis:   Reads CColumnSortList data from stream.
//
//  Format:     number of columns : each CColumnSortInfo entry.
//
//  Arguments:  [stm]      - The input stream.
//              [nVersion] - Version of CColumnSortList to be read.
//
//
//--------------------------------------------------------------------
HRESULT CColumnSortList::ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/)
{
    HRESULT hr = S_FALSE;   // assume bad version

    if (GetVersion() == nVersion)
    {
        try
        {
            // Number of columns.
            DWORD dwCols;
            stm >> dwCols;

            clear();

            for (int i = 0; i < dwCols; i++)
            {
                CColumnSortInfo colSortEntry;

                // Read data into colSortEntry structure.
                if (colSortEntry.Read(stm) != S_OK)
                    continue;

                push_back(colSortEntry);
            }

            hr = S_OK;
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}

/***************************************************************************\
 *
 * METHOD:  CColumnSortList::Persist
 *
 * PURPOSE: persists object to XML
 *
 * PARAMETERS:
 *    CPersistor& persistor [in/out] persistor to persist under
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CColumnSortList::PersistSortList(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CColumnSortList::PersistSortList"));

    if (persistor.IsLoading())
    {
        clear();
        CColumnSortInfo sortInfo;
        if (persistor.HasElement(sortInfo.GetXMLType(), NULL))
        {
            persistor.Persist(sortInfo);
            insert(end(), sortInfo);
        }
    }
    else
    {
        if (size() > 1)
            sc.Throw(E_UNEXPECTED);
        else if (size())
            persistor.Persist(*begin());
    }
}

//+-------------------------------------------------------------------
//
//  Member:     ReadSerialObject
//
//  Synopsis:   Read CColumnSetData data from the stream.
//
//  Arguments:  [stm]      - The input stream.
//              [nVersion] - Version of CColumnSetData structure.
//
//  Format :    CColumnInfoList : CColumnSortList
//
//
//--------------------------------------------------------------------
HRESULT CColumnSetData::ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/)
{
    HRESULT hr = S_FALSE;   // assume bad version

    if (GetVersion() == nVersion)
    {
        try
        {
            do  // not a loop
            {
                // Read the rank
                stm >> m_dwRank;

                // Read the CColumnInfoList
                hr = get_ColumnInfoList()->Read(stm);
                if (hr != S_OK)
                    break;

                // Read the CColumnSortList
                hr = get_ColumnSortList()->Read(stm);
                if (hr != S_OK)
                    break;

                ASSERT (hr == S_OK);

            } while (false);
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CColumnSetData::Persist
//
//  Synopsis:   Persists object data
//
//  Arguments:
//
//  History:    10-10-1999   AudriusZ   Created
//
//--------------------------------------------------------------------
void CColumnSetData::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CColumnSetData::Persist"));

    sc = ScCheckPointers(get_ColumnInfoList(), get_ColumnSortList());
    if (sc)
        sc.Throw();

    persistor.PersistAttribute(XML_ATTR_COLUMN_SET_RANK,  m_dwRank);

    // Write CColumnInfoList
    persistor.Persist(*get_ColumnInfoList());
    // Write CColumnSortList
    get_ColumnSortList()->PersistSortList(persistor);
}

//------------------------------------------------------------------
// class CColumnPersistInfo
//------------------------------------------------------------------
CColumnPersistInfo::CColumnPersistInfo() :
    m_bInitialized(FALSE), m_dwMaxItems(MAX_COLUMNS_PERSISTED),
    m_bDirty(FALSE)
{
}

CColumnPersistInfo::~CColumnPersistInfo()
{
}

//+-------------------------------------------------------------------
//
//  Member:     RetrieveColumnData
//
//  Synopsis:   Copy and return the persisted column information
//              for given column id and view id.
//
//  Arguments:  [refSnapinCLSID] - Snapin Guid
//              [SColumnSetID]       - Column Set Identifier.
//              [nViewID]        - View ID.
//              [columnSetData]  - CColumnSetData, used to return the
//                                 persisted column information.
//
//  Returns:    TRUE - Loaded successfully.
//
//  History:    10-16-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
BOOL CColumnPersistInfo::RetrieveColumnData( const CLSID& refSnapinCLSID,
                                            const SColumnSetID& colID,
                                            INT nViewID,
                                            CColumnSetData& columnSetData)
{
    BOOL bFound = FALSE;

    // Make sure we are initialized.
    if (!m_bInitialized && !Init())
    {
        ASSERT(FALSE);
        return bFound;
    }

    // Construct CColumnSetID.
    CColumnSetID colSetID(colID);

    // Use the snapin clsid to get the ColSetIDToViewTableMap.
    SnapinToColSetIDMap::iterator        itSnapins;
    itSnapins = m_spSnapinsMap->find(refSnapinCLSID);
    if (itSnapins == m_spSnapinsMap->end())
        return bFound;

    // The ColSetIDToViewTableMap is a simple map.
    ColSetIDToViewTableMap::iterator      itColSetIDMap;
    ColSetIDToViewTableMap& colSetIDMap = itSnapins->second;

    // Get the data for colSetID.
    itColSetIDMap = colSetIDMap.find(colSetID);
    if (colSetIDMap.end() == itColSetIDMap)
        return bFound;

    ViewToColSetDataMap& viewData = itColSetIDMap->second;
    ViewToColSetDataMap::iterator itViews;

    // See if our view is present.
    itViews = viewData.find(nViewID);
    if (viewData.end() != itViews)
    {
        // Found the item.
        bFound = TRUE;
        ItColSetDataList itColSetData = itViews->second;

        // Copy the data.
        columnSetData = *itColSetData;

        // So move this item to the top of the queue.
        m_spColSetList->erase(itColSetData);

        itColSetData = m_spColSetList->insert(m_spColSetList->begin(), columnSetData);
        itViews->second = itColSetData;
    }

    return bFound;
}

//+-------------------------------------------------------------------
//
//  Member:     SaveColumnData
//
//  Synopsis:   Save/Modify the column information for persistence into
//              CColumnPersistInfo.
//
//  Arguments:
//              [refSnapinCLSID] - Snapin Guid.
//              [SColumnSetID]       - Column Set Identifier.
//              [nViewID]        - View ID.
//              [columnSetData]  - CColumnSetData, Column data.
//
//  Returns:    TRUE - Saved successfully.
//
//  History:    10-16-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
BOOL CColumnPersistInfo::SaveColumnData( const CLSID& refSnapinCLSID,
                                         const SColumnSetID& colID,
                                         INT nViewID,
                                         CColumnSetData& columnSetData)
{
    // Make sure we are init
    if (!m_bInitialized && !Init())
    {
        ASSERT(FALSE);
        return FALSE;
    }

    // Construct the CColumnSetID.
    CColumnSetID colSetID(colID);

    // Garbage collect if the number of items in the list is 40% more then pre-set limit.
    if (m_spColSetList->size() >= (m_dwMaxItems * (1 + COLUMNS_MAXLIMIT)) )
        GarbageCollectItems();

    // Insert this item to the top of the queue.
    ItColSetDataList itColData;
    itColData = m_spColSetList->insert(m_spColSetList->begin(), columnSetData);

    SnapinToColSetIDMap::iterator itSnapins;
    itSnapins = m_spSnapinsMap->find(refSnapinCLSID);

    if (itSnapins != m_spSnapinsMap->end())
    {
        // Snapin is already in the map.
        // Look if the col-id is already inserted.
        ColSetIDToViewTableMap::iterator       itColSetIDMap;

        ColSetIDToViewTableMap& colSetIDMap = itSnapins->second;

        // Get the data for the colSetID.
        itColSetIDMap = colSetIDMap.find(colSetID);

        if (colSetIDMap.end() == itColSetIDMap)
        {
            // The column-id not found.
            // So insert new one.

            // Construct the view-id to column-data map
            ViewToColSetDataMap viewIDMap;
            viewIDMap.insert( ViewToColSetDataVal(nViewID, itColData) );

            colSetIDMap.insert(ColSetIDToViewTableVal(colSetID, viewIDMap) );
        }
        else
        {
            // The data for Col-ID exists.
            // find if the given view exists in the map.

            ViewToColSetDataMap::iterator itViewIDMap;
            ViewToColSetDataMap& viewIDMap = itColSetIDMap->second;

            itViewIDMap = viewIDMap.find(nViewID);
            if (viewIDMap.end() != itViewIDMap)
            {
                // The map from ViewID to column list exists.
                // So delete the old data and insert new data
                // at the top of the queue.
                m_spColSetList->erase(itViewIDMap->second);
                itViewIDMap->second = itColData;
            }
            else
            {
                // This view is not found.
                // So insert new one.

                viewIDMap.insert( ViewToColSetDataVal(nViewID, itColData) );
            }

        }

    }
    else
    {
        // Insert the snapin into the map.

        // Construct the ViewID to column-data map.
        ViewToColSetDataMap viewIDMap;
        viewIDMap.insert( ViewToColSetDataVal(nViewID, itColData) );

        // Insert the above into the col-id map.
        ColSetIDToViewTableMap colIDMap;
        colIDMap.insert( ColSetIDToViewTableVal(colSetID, viewIDMap) );

        // Insert into the snapins map.
        m_spSnapinsMap->insert( SnapinToColSetIDVal(refSnapinCLSID, colIDMap) );
    }

    // Set dirty after modifying the column-data.
    m_bDirty = TRUE;

    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     DeleteColumnData
//
//  Synopsis:   Delete the persisted column information for the given
//              snapin, col-id and view id.
//
//  Arguments:
//              [refSnapinCLSID] - Snapin Guid.
//              [SColumnSetID]       - Column Set Identifier.
//              [nViewID]        - View ID.
//
//  Returns:    None.
//
//  History:    02-13-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
VOID CColumnPersistInfo::DeleteColumnData( const CLSID& refSnapinCLSID,
                                           const SColumnSetID& colID,
                                           INT nViewID)
{
    // Make sure we are initialized.
    if (!m_bInitialized && !Init())
    {
        ASSERT(FALSE);
        return;
    }

    // Construct CColumnSetID.
    CColumnSetID colSetID(colID);

    // Use the snapin clsid to get the ColSetIDToViewTableMap.
    SnapinToColSetIDMap::iterator        itSnapins;
    itSnapins = m_spSnapinsMap->find(refSnapinCLSID);
    if (itSnapins == m_spSnapinsMap->end())
        return;

    // The ColSetIDToViewTableMap is a simple map.
    ColSetIDToViewTableMap::iterator       itColSetIDMap;
    ColSetIDToViewTableMap& colSetIDMap = itSnapins->second;

    // Get the data for colSetID.
    itColSetIDMap = colSetIDMap.find(colSetID);
    if (colSetIDMap.end() == itColSetIDMap)
        return;

    ViewToColSetDataMap& viewData = itColSetIDMap->second;
    ViewToColSetDataMap::iterator itViews;

    // See if our view is present.
    itViews = viewData.find(nViewID);
    if (viewData.end() == itViews)
        return;

    ItColSetDataList itColSetData = itViews->second;
    itColSetData->m_bInvalid = TRUE;

    // Delete the invalid items.
    DeleteMarkedItems();

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     DeleteColumnDataOfSnapin
//
//  Synopsis:   Delete the column data of given snapin.
//
//  Arguments:  [refSnapinCLSID] - Snapin Guid.
//
//  Returns:    TRUE - Data removed successfully.
//
//  History:    02-11-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
BOOL CColumnPersistInfo::DeleteColumnDataOfSnapin( const CLSID& refSnapinCLSID)
{
    // Make sure we are init
    if (!m_bInitialized)
    {
        return FALSE;
    }

    SnapinToColSetIDMap::iterator itSnapinsMap;
    itSnapinsMap = m_spSnapinsMap->find(refSnapinCLSID);

    // Find the given snapin.
    // Iterate thro all the col-ids of this snapin and
    // all the views of those col-id and set the data
    // to be invalid.
    if (m_spSnapinsMap->end() != itSnapinsMap)
    {
        ColSetIDToViewTableMap& colSets = itSnapinsMap->second;

        // Iterate thro' all colset ids of this snapin.
        ColSetIDToViewTableMap::iterator itColumnSetIDMap;

        for (itColumnSetIDMap  = colSets.begin();
             itColumnSetIDMap != colSets.end();
             ++itColumnSetIDMap)
        {
            // Get the view map

            ViewToColSetDataMap& viewIDMap = itColumnSetIDMap->second;
            ViewToColSetDataMap::iterator itViewIDMap;

            // Iterate thro' all views and set the data invalid.
            for (itViewIDMap  = viewIDMap.begin();
                 itViewIDMap != viewIDMap.end();
                 ++itViewIDMap)
            {
                ItColSetDataList itColSetData = itViewIDMap->second;
                itColSetData->m_bInvalid = TRUE;
            }
        }
    }

    // Delete the invalid items.
    DeleteMarkedItems();

    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     DeleteColumnDataOfView
//
//  Synopsis:   Delete the column data of given view.
//
//  Arguments:  [nViewID] - View ID.
//
//  Returns:    TRUE - Data removed successfully.
//
//  History:    02-11-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
BOOL CColumnPersistInfo::DeleteColumnDataOfView( int nViewID)
{
    // Make sure we are init
    if (!m_bInitialized)
    {
        return FALSE;
    }

    // Iterate thro all snapins, col-ids and find the matching
    // view and set data to be invalid.
    SnapinToColSetIDMap::iterator itSnapinsMap;

    // Iterate thro all snapins.
    for (itSnapinsMap = m_spSnapinsMap->begin();
         m_spSnapinsMap->end() != itSnapinsMap;
         ++itSnapinsMap)
    {
        ColSetIDToViewTableMap& colSets = itSnapinsMap->second;
        ColSetIDToViewTableMap::iterator itColumnSetIDMap;

        // Iterate thro' all colset ids of this snapin.
        for (itColumnSetIDMap  = colSets.begin();
             itColumnSetIDMap != colSets.end();
             ++itColumnSetIDMap)
        {
            // Get the view map
            ViewToColSetDataMap& viewIDMap = itColumnSetIDMap->second;
            ViewToColSetDataMap::iterator itViewIDMap;

            // Find the matching views and mark them to be deleted.
            for (itViewIDMap  = viewIDMap.begin();
                 itViewIDMap != viewIDMap.end();
                 ++itViewIDMap)
            {
                if (nViewID == itViewIDMap->first)
                {
                    ItColSetDataList itColSetData = itViewIDMap->second;
                    itColSetData->m_bInvalid = TRUE;
                }
            }

        }
    }

    // Delete the invalid items.
    DeleteMarkedItems();

    return TRUE;
}



//+-------------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   Create the Map and the list for CColumnSetData.
//
//  Returns:    TRUE - for success.
//
//  History:    10-16-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
BOOL CColumnPersistInfo::Init()
{
	// Create the data structures to store column data.
	m_spSnapinsMap = auto_ptr<SnapinToColSetIDMap>(new SnapinToColSetIDMap);

	m_spColSetList = auto_ptr<ColSetDataList> (new ColSetDataList);

	// Now the objects are created, so now set initialized to true.
	m_bInitialized = TRUE;

	// Now read the registry to see if m_dwMaxItems is specified.
	// Check if the settings key exists.
	CRegKeyEx rSettingsKey;
	if (rSettingsKey.ScOpen (HKEY_LOCAL_MACHINE, SETTINGS_KEY, KEY_READ).IsError())
		return m_bInitialized;

	// Read the values for MaxColDataPersisted.
	if (rSettingsKey.IsValuePresent(g_szMaxColumnDataPersisted))
	{
		DWORD  dwType = REG_DWORD;
		DWORD  dwSize = sizeof(DWORD);

		SC sc = rSettingsKey.ScQueryValue (g_szMaxColumnDataPersisted, &dwType,
										   &m_dwMaxItems, &dwSize);

		if (sc)
			sc.TraceAndClear();
	}

    return m_bInitialized;
}

//+-------------------------------------------------------------------
//
//  Member:     GarbageCollectItems
//
//  Synopsis:   Free least used column data.
//
//  Arguments:  None.
//
//  History:    02-11-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
VOID CColumnPersistInfo::GarbageCollectItems()
{
    INT nItemsToBeRemoved = COLUMNS_MAXLIMIT * m_dwMaxItems;

    // Go thro' the list and set the nItemsToBeRemoved that was least recently
    // accessed to be invalid.
    INT nIndex = 0;
    ItColSetDataList itColList;

    // Skip first m_dwMaxItems.
    for (itColList  = m_spColSetList->begin();
         ( (itColList != m_spColSetList->end()) && (nIndex <= m_dwMaxItems) );
         ++itColList, nIndex++)
    {
        nIndex++;
    }

    // Mark rest of the items to be garbage.
    while (itColList != m_spColSetList->end())
    {
        itColList->m_bInvalid = TRUE;
        ++itColList;
    }

    // Delete the invalid items.
    DeleteMarkedItems();

    return;
}


//+-------------------------------------------------------------------
//
//  Member:     DeleteMarkedItems
//
//  Synopsis:   Delete invalidated items. This involves iterating thro
//              the maps to find the invalid items. Then deleting the
//              items. If the map becomes empty then delete the map.
//
//  History:    02-11-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
VOID CColumnPersistInfo::DeleteMarkedItems()
{
    SnapinToColSetIDMap::iterator itSnapinsMap, itSnapinsMapNew;

    // Now iterate thro the map and remove those elements.
    itSnapinsMap  = m_spSnapinsMap->begin();

    while (itSnapinsMap != m_spSnapinsMap->end())
    {
        ColSetIDToViewTableMap& colSets = itSnapinsMap->second;
        ColSetIDToViewTableMap::iterator itColumnSetIDMap;

        // Iterate thro this snapins col-ids.
        itColumnSetIDMap  = colSets.begin();

        while (itColumnSetIDMap != colSets.end())
        {
            // Get the view map
            ViewToColSetDataMap& viewIDMap = itColumnSetIDMap->second;
            ViewToColSetDataMap::iterator itViewIDMap;

            // Iterate thro all the views.
            itViewIDMap = viewIDMap.begin();

            while (itViewIDMap != viewIDMap.end())
            {
                ItColSetDataList itColSetData = itViewIDMap->second;

                if (itColSetData->m_bInvalid)
                {
                    // Delete the item ref from the map.
                    // Erase returns iterator to next item.
                    itViewIDMap = viewIDMap.erase(itViewIDMap);

                    // Delete the item from the list.
                    m_spColSetList->erase(itColSetData);
                }
                else
                    // Item is valid item.
                    ++itViewIDMap;
            }

            // If the view has zero items we need to remove this
            // view map. (ColID to ViewMap).
            if (0 == viewIDMap.size())
            {
                // Delete the col-id map.
                // Erase returns iterator to next item.
                itColumnSetIDMap = colSets.erase(itColumnSetIDMap);
            }
            else
                ++itColumnSetIDMap;
        }

        // If there are no col-id's remove the
        // Snapin to this col-id map.
        if (0 == colSets.size())
        {
            // Delete this snapin map.
            // Erase returns iterator to next item.
            itSnapinsMap = m_spSnapinsMap->erase(itSnapinsMap);
        }
        else
            ++itSnapinsMap;
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   Load the persisted column information.
//
//  Arguments:  [pStream]- ISteam from which column widths to be loaded.
//
//  Returns:    S_OK - Loaded successfully.
//
//  History:    10-16-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
STDMETHODIMP CColumnPersistInfo::Load (IStream* pStream)
{
    HRESULT hr = E_FAIL;

    if (!m_bInitialized && !Init())
    {
        ASSERT(FALSE);
        return hr;
    }

    // read the column width information.
    try
    {
        do
        {
            // Read the version. If it did not match return
            INT   nVersion                      = 0;
            *pStream >> nVersion;
            if (COLPersistenceVersion != nVersion)
                return S_FALSE;

            // Read the # of Snapins
            DWORD dwSnapins = 0;
            *pStream >> dwSnapins;

            m_spColSetList->clear();
            m_spSnapinsMap->clear();

            // For each snapin...
            for (int nSnapIdx = 0; nSnapIdx < dwSnapins; nSnapIdx++)
            {
                // Read snapin CLSID.
                CLSID clsidSnapin;
                *pStream >> clsidSnapin;

                // Read the number of col-ids for this snapin.
                DWORD dwColIDs = 0;
                *pStream >> dwColIDs;

                ColSetIDToViewTableMap colSetsMap;

                // For each col-id...
                for (int nColIDIdx = 0; nColIDIdx < dwColIDs; nColIDIdx++)
                {
                    // Read the col-id
                    CColumnSetID colSetID;
                    *pStream >> colSetID;

                    // Read the number of views.
                    DWORD dwNumViews = 0;
                    *pStream >> dwNumViews;

                    ViewToColSetDataMap ViewIDMap;

                    // For each view...
                    for (int nViewIdx = 0; nViewIdx < dwNumViews; nViewIdx++)
                    {
                        // Read view id.
                        DWORD dwViewID;
                        *pStream >> dwViewID;

                        // Read the CColumnSetData.
                        CColumnSetData   ColData;
                        ColData.Read(*pStream);

                        // Insert the data into the global linked list.
                        ItColSetDataList itColSetData;
                        itColSetData = m_spColSetList->insert(m_spColSetList->begin(), ColData);

                        // Insert the pointer to the data in to view map.
                        ViewIDMap.insert(ViewToColSetDataVal(dwViewID, itColSetData));
                    }

                    // Insert the view map into the col-id map.
                    colSetsMap.insert(ColSetIDToViewTableVal(colSetID, ViewIDMap));
                }

                // Insert the col-id map into the snapin map.
                m_spSnapinsMap->insert(SnapinToColSetIDVal(clsidSnapin, colSetsMap));
            }

            // Now sort the list.
            m_spColSetList->sort();

        } while (FALSE);
    }
    catch (_com_error& err)
    {
        hr = err.Error();
    }
    catch (...)
    {
        ASSERT (0 && "Unexpected exception");
        throw;
    }

    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   Persist the column information.
//
//  Arguments:  [pStream]- IStream in which column widths are to be saved.
//
//  Returns:    S_OK - Saved successfully.
//
//  History:    10-16-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
STDMETHODIMP CColumnPersistInfo::Save (IStream* pStream, BOOL bClearDirty)
{
    // absolete method.
    // this method is left here since we use IPersistStream to export
    // persistence to CONUI side and need to implement it.
    // But this interface will never be called to save data
    // [we will use CPersistor-based XML saving instead]
    // so the method will always fail.
    ASSERT(FALSE && "Should never come here");
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------
//
//  Member:     Persist
//
//  Synopsis:   Persists the column information.
//
//  Arguments:  [persistor]- CPersistor in/from which column widths are persisted.
//
//  Returns:    void.
//
//  History:    10-08-1999   AudriusZ   Created
//
//--------------------------------------------------------------------
void CColumnPersistInfo::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CColumnPersistInfo::Persist"));

    if (!m_bInitialized && !Init())
        sc.Throw(E_FAIL);

    sc = ScCheckPointers(m_spColSetList.get(), m_spSnapinsMap.get(), E_UNEXPECTED);
    if (sc)
        sc.Throw();

    if (persistor.IsStoring())
    {
        // Give ranking to each column data.
        ItColSetDataList itColList;
        DWORD dwRank = 0;
        for (itColList = m_spColSetList->begin();
             itColList != m_spColSetList->end();
             ++itColList)
        {
            itColList->m_dwRank = dwRank++;
        }
    }
    else // if (persistor.IsLoading())
    {
        m_spColSetList->clear();
        m_spSnapinsMap->clear();
    }

    SnapinToColSetIDMapPersistor childPersisot(*m_spSnapinsMap, *m_spColSetList);
    childPersisot.Persist(persistor);

    if (persistor.IsStoring())
        m_bDirty = FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     OnInitDialog
//
//  Synopsis:   Initialize the Columns dialog.
//
//  Arguments:
//
//  History:    11-16-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
LRESULT CColumnsDlg::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_btnAdd      = ::GetDlgItem(m_hWnd, IDC_ADD_COLUMNS);
    m_btnRemove   = ::GetDlgItem(m_hWnd, IDC_REMOVE_COLUMNS);
    m_btnRestoreDefaultColumns    = ::GetDlgItem(m_hWnd, IDC_RESTORE_DEFAULT_COLUMNS);
    m_btnMoveUp   = ::GetDlgItem(m_hWnd, IDC_MOVEUP_COLUMN);
    m_btnMoveDown = ::GetDlgItem(m_hWnd, IDC_MOVEDOWN_COLUMN);

    m_HiddenColList.Attach(::GetDlgItem(m_hWnd, IDC_HIDDEN_COLUMNS));
    m_DisplayedColList.Attach(::GetDlgItem(m_hWnd, IDC_DISPLAYED_COLUMNS));

    m_bUsingDefaultColumnSettings = (*m_pColumnInfoList == m_DefaultColumnInfoList);

    InitializeLists();
    EnableUIObjects();

    return 0;
}


//+-------------------------------------------------------------------
//
//  Member:     OnOK
//
//  Synopsis:   Get the hidden and visible columns.
//
//  Arguments:
//
//  History:    11-16-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
LRESULT CColumnsDlg::OnOK (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (! m_bDirty) // column settings are not modified
    {
        EndDialog (IDCANCEL);

        return 1;
    }

    if (m_bUsingDefaultColumnSettings)
    {
        EndDialog(IDC_RESTORE_DEFAULT_COLUMNS);
        return 1;
    }

    ASSERT(NULL != m_pColumnInfoList);
    if (NULL == m_pColumnInfoList)
        return 0;

    WTL::CString strColumnName;
    CColumnInfoList::iterator   it;
    CColumnInfo                 colinfo;

    // Get the strings from Hidden_List_Box.
    // These cols are to be hidden. So put them first in the list.
    int cItems =    m_HiddenColList.GetCount();
    for (int i = 0; i < cItems; i++)
    {
        // Get the text from list box
        int nRet = m_HiddenColList.GetText(i, strColumnName);
        if (LB_ERR == nRet)
        {
            ASSERT(FALSE);
            break;
        }

        // Use the string to get the actual index of the column.
        int nIndex = GetColIndex(strColumnName);
        if (0 > nIndex )
        {
            ASSERT(FALSE);
            break;
        }

        // With the index get the column and insert it at beginning.
        it = find_if(m_pColumnInfoList->begin(), m_pColumnInfoList->end(),
                     bind2nd(ColPosCompare(), nIndex));

        if (it == m_pColumnInfoList->end())
        {
            ASSERT(FALSE);
            break;
        }

        // Set the *it flag to be hidden. Insert it at beginning.
        colinfo = *it;
        colinfo.SetColHidden();

        // Move the item to the head of the list
        m_pColumnInfoList->erase(it);
        m_pColumnInfoList->push_front(colinfo);
    }

    // Then get the strings from DisplayedColumns_List_Box.
    cItems = m_DisplayedColList.GetCount();
    for (i = 0; i < cItems; i++)
    {
        // Get the text from list box
        int nRet = m_DisplayedColList.GetText(i, strColumnName);
        if (LB_ERR == nRet)
        {
            ASSERT(FALSE);
            break;
        }

        // Use the column name to get the column index.
        int nIndex = GetColIndex(strColumnName);

        if (0 > nIndex )
        {
            ASSERT(FALSE);
            break;
        }

        // Get the CColumnInfo and insert at end.
        it = find_if(m_pColumnInfoList->begin(), m_pColumnInfoList->end(),
                     bind2nd(ColPosCompare(), nIndex));

        if (it == m_pColumnInfoList->end())
            break;

        colinfo = *it;

        if (colinfo.IsColHidden())
        {
            // If hidden column is made visible
            // reset the hidden flag and set the width
            // to auto_width.
            colinfo.SetColHidden(false);
            if (colinfo.GetColWidth() <= 0)
                colinfo.SetColWidth(AUTO_WIDTH);
        }

        // Move it to the end of the list.
        m_pColumnInfoList->erase(it);
        m_pColumnInfoList->push_back(colinfo);
    }

    EndDialog (IDOK);
    return 1;
}

LRESULT CColumnsDlg::OnCancel (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndDialog (IDCANCEL);
    return 0;
}


LRESULT CColumnsDlg::OnMoveUp (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    MoveItem(TRUE);

    return 0;
}

LRESULT CColumnsDlg::OnMoveDown (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    MoveItem(FALSE);

    return 0;
}

//+-------------------------------------------------------------------
//
//  Member:     OnAdd
//
//  Synopsis:   Adds a column to displayed columns list by removing
//              the currently selected column from hidden column list.
//
//  Arguments:
//
//--------------------------------------------------------------------
LRESULT CColumnsDlg::OnAdd (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // First remove from hidden column list.
    int nCurSel = m_HiddenColList.GetCurSel();

    WTL::CString strColumnName;
    int nRet = m_HiddenColList.GetText(nCurSel, strColumnName);
    if (LB_ERR == nRet)
    {
        ASSERT(FALSE);
        return 0;
    }

    m_HiddenColList.DeleteString(nCurSel);

    // now add it to Displayed column list.
    m_DisplayedColList.AddString(strColumnName);
    SetDirty();

    if (nCurSel > m_HiddenColList.GetCount()-1)
        nCurSel = m_HiddenColList.GetCount()-1;

    m_HiddenColList.SetCurSel(nCurSel);
    m_DisplayedColList.SelectString(0, strColumnName);

    SetListBoxHScrollSize();
    EnableUIObjects();
    return 0;
}

//+-------------------------------------------------------------------
//
//  Member:     OnRemove
//
//  Synopsis:   Removes the currently selected column from displayed
//              columns list by removing and adds it to hidden column list.
//
//  Arguments:
//
//--------------------------------------------------------------------
LRESULT CColumnsDlg::OnRemove (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // Get the currently selected item in Displayed Columns list.
    int nCurSel = m_DisplayedColList.GetCurSel();

    WTL::CString strColumnName;
    int nRet = m_DisplayedColList.GetText(nCurSel, strColumnName);
    if (LB_ERR == nRet)
    {
        ASSERT(FALSE);
        return 0;
    }

    // If column zero do not hide it.
    if (0 == GetColIndex(strColumnName))
        return 0;

    m_DisplayedColList.DeleteString(nCurSel);

    // Add it to hidden column list.
    m_HiddenColList.AddString(strColumnName);
    SetDirty();

    if (nCurSel > m_DisplayedColList.GetCount()-1)
        nCurSel = m_DisplayedColList.GetCount()-1;

    m_DisplayedColList.SetCurSel(nCurSel);
    m_HiddenColList.SelectString(0, strColumnName);

    EnableUIObjects();

    SetListBoxHScrollSize();

    return 0;
}

LRESULT CColumnsDlg::OnRestoreDefaultColumns (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DECLARE_SC(sc, TEXT("CColumnsDlg::OnRestoreDefaultColumns"));

    // Get the default data and populate the columns dialog.
    *m_pColumnInfoList = m_DefaultColumnInfoList;

    SetUsingDefaultColumnSettings();

    InitializeLists();
    EnableUIObjects();

	// Button is disabled so put the focus on the dialog.
    SetFocus();

    return 0;
}


LRESULT CColumnsDlg::OnSelChange (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EnableUIObjects();

    return 0;
}

//+-------------------------------------------------------------------
//
//  Member:     MoveItem
//
//  Synopsis:   Moves an item in the displayed columns list up or down.
//              The up down order is same as column visible order from
//              left to right.
//
//  Arguments:  [BOOL] - up or down.
//
//--------------------------------------------------------------------
void CColumnsDlg::MoveItem (BOOL bMoveUp)
{
    int nCurSel = m_DisplayedColList.GetCurSel();

    WTL::CString strColumnName;
    int nRet = m_DisplayedColList.GetText(nCurSel, strColumnName);
    if (LB_ERR == nRet)
    {
        ASSERT(FALSE);
        return;
    }

    m_DisplayedColList.DeleteString(nCurSel);
    if (bMoveUp)
        m_DisplayedColList.InsertString(nCurSel-1, strColumnName);
    else
        m_DisplayedColList.InsertString(nCurSel+1, strColumnName);

    m_DisplayedColList.SelectString(0, strColumnName);

    SetDirty();

    EnableUIObjects();
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     EnableControl
//
//  Synopsis:   Enable or Disable a window. If this window has to be
//              disabled and it has focus, shift the focus to next
//              enabled item in the tab-sequence.
//
//  Arguments:  hwnd - window to be enabled or disabled.
//              bEnable - enable or disable.
//
//--------------------------------------------------------------------
bool CColumnsDlg::EnableControl(HWND hwnd, bool bEnable)
{
    // If disabling and this window has focus then 
    // put focus on next enabled window.
    if ( (!bEnable) && (hwnd == ::GetFocus()) )
    {
        HWND hwndWindowToFocus = GetNextDlgTabItem(hwnd);
        if (hwndWindowToFocus)
            ::SetFocus(hwndWindowToFocus);
    }

    // Now enable or disable the control.
    return ::EnableWindow(hwnd, bEnable);
}

//+-------------------------------------------------------------------
//
//  Member:     EnableUIObjects
//
//  Synopsis:   Enable/Disable the UI objects in the dialog.
//
//  Arguments:
//
//--------------------------------------------------------------------
void CColumnsDlg::EnableUIObjects()
{
    int  curselAvailable    = m_HiddenColList.GetCurSel();
    int  curselShow         = m_DisplayedColList.GetCurSel();
    int  cItems             = m_HiddenColList.GetCount();
    BOOL bEnableAdd         = ((curselAvailable != LB_ERR) && (curselAvailable || cItems)) ? TRUE: FALSE;
    BOOL bEnableRemove      = ((curselShow != LB_ERR)) ? TRUE: FALSE;
    BOOL bEnableMoveUp      = ((curselShow != LB_ERR) && curselShow) ? TRUE: FALSE;
    cItems                  = m_DisplayedColList.GetCount();
    BOOL bEnableMoveDown    = cItems && (curselShow != LB_ERR) && (cItems!=curselShow+1);

    BOOL bRet = FALSE;

    HWND hHwnFocussed = ::GetFocus();

    bRet = EnableControl(m_btnAdd, bEnableAdd);
    bRet = EnableControl(m_btnRemove, bEnableRemove);
    bRet = EnableControl(m_btnMoveUp, bEnableMoveUp);
    bRet = EnableControl(m_btnMoveDown, bEnableMoveDown);

    // Enable restore defaults only if columns are already customized before bringing the dialog
    bRet = EnableControl(m_btnRestoreDefaultColumns, (!m_bUsingDefaultColumnSettings));

    // Disable Remove/Move Up/Move Down buttons for Col zero.
    int nCurSel = m_DisplayedColList.GetCurSel();

    WTL::CString strColumnName;
    int nRet = m_DisplayedColList.GetText(nCurSel, strColumnName);
    if (LB_ERR == nRet)
    {
        ASSERT(FALSE);
        return;
    }

    if (0 == GetColIndex(strColumnName)) // Column 0
        EnableControl(m_btnRemove, FALSE);
}

int CColumnsDlg::GetColIndex(LPCTSTR lpszColName)
{
    TStringVector::iterator itStrVec1;

    USES_CONVERSION;

    itStrVec1 = find(m_pStringVector->begin(), m_pStringVector->end(), lpszColName);

    if (m_pStringVector->end() != itStrVec1)
        return (itStrVec1 - m_pStringVector->begin());
    else
        // Unknown column
        return -1;
}

//+-------------------------------------------------------------------
//
//  Member:     SetListBoxHorizontalScrollbar
//
//  Synopsis:   For the given list box enumerate the strings added and find
//              the largest string. Calculate scrollbar size for this string
//              and set it.
//
//  Arguments:  [listBox] - Given list box.
//
//--------------------------------------------------------------------
void CColumnsDlg::SetListBoxHorizontalScrollbar(WTL::CListBox& listBox)
{
    int          dx=0;
    WTL::CDC     dc(listBox.GetWindowDC());
    if (dc.IsNull())
        return;

    // Find the longest string in the list box.
    for (int i=0;i < listBox.GetCount();i++)
    {
	    WTL::CString str;
        int nRet = listBox.GetText( i, str );
        if (nRet == LB_ERR)
            return;

	    WTL::CSize   sz;
        if (! dc.GetTextExtent(str, str.GetLength(), &sz))
            return;

        if (sz.cx > dx)
            dx = sz.cx;
    }

    // Set the horizontal extent so every character of all strings
    // can be scrolled to.
    listBox.SetHorizontalExtent(dx);

    return;
}

/* CColumnsDlg::InitializeLists
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *      void
 */
void CColumnsDlg::InitializeLists()
{
    CColumnInfoList::iterator it;
    int j = 0;

    if (!m_pColumnInfoList)
    {
        ASSERT(FALSE);
        return;
    }

    m_HiddenColList.ResetContent();
    m_DisplayedColList.ResetContent();

    USES_CONVERSION;
    for (it = m_pColumnInfoList->begin(); it != m_pColumnInfoList->end(); ++it)
    {
        if (it->IsColHidden())
        {
            m_HiddenColList.AddString(m_pStringVector->at(it->GetColIndex()).data());
        }
        else
        {
            m_DisplayedColList.InsertString(j++, m_pStringVector->at(it->GetColIndex()).data());
        }
    }

    m_DisplayedColList.SetCurSel(m_DisplayedColList.GetCount()-1);
    m_HiddenColList.SetCurSel(m_HiddenColList.GetCount()-1);

    SetListBoxHScrollSize();
}

//+-------------------------------------------------------------------
//
//  Member:     CColumnSetID::Persist
//
//  Synopsis:   Persists object data
//
//  Arguments:
//
//  History:    10-10-1999   AudriusZ   Created
//
//--------------------------------------------------------------------
void CColumnSetID::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CColumnSetID::Persist"));

    CXMLAutoBinary binary;
    if (persistor.IsStoring() && m_vID.size()) // fill only if have data
    {
        sc = binary.ScAlloc(m_vID.size());
        if (sc)
            sc.Throw();

        CXMLBinaryLock sLock(binary); // will unlock in destructor

        LPBYTE pData = NULL;
        sc = sLock.ScLock(&pData);
        if (sc)
            sc.Throw();

        sc = ScCheckPointers(pData, E_UNEXPECTED);
        if (sc)
            sc.Throw();

        std::copy(m_vID.begin(), m_vID.end(), pData);
    }
    persistor.PersistAttribute(XML_ATTR_COLUMN_SET_ID_PATH, binary);
    if (persistor.IsLoading())
    {
        m_vID.clear();

        if (binary.GetSize())
        {
            CXMLBinaryLock sLock(binary); // will unlock in destructor

            LPBYTE pData = NULL;
            sc = sLock.ScLock(&pData);
            if (sc)
                sc.Throw();

            sc = ScCheckPointers(pData, E_UNEXPECTED);
            if (sc)
                sc.Throw();

            m_vID.insert(m_vID.end(), pData, pData + binary.GetSize());
        }
    }

   persistor.PersistAttribute(XML_ATTR_COLUMN_SET_ID_FLAGS, m_dwFlags);
}


/***************************************************************************\
 *
 * METHOD:  ViewToColSetDataMapPersistor::Persist
 *
 * PURPOSE: called by the base class to create and persist the new element
 *
 * PARAMETERS:
 *    CPersistor& persistor - [in] persistor from which to persist new element
 *
 * RETURNS:
 *    void
 *
 * see "Data structures used to persist column information" comment
 * int file colwidth.h for more information
\***************************************************************************/
void ViewToColSetDataMapPersistor::Persist(CPersistor &persistor)
{
    if (persistor.IsStoring())
    {
        // iterate and save all elements as linear list
        ViewToColSetDataMap::iterator it;
        for (it = m_map.begin(); it != m_map.end(); ++it)
        {
            // we will sneak under child's element to persist the KEY value as an attribute
            // of the child element. To do that we use tag got from _GetXMLType() of the child
            CPersistor persistorChild(persistor, it->second->GetXMLType());

            int view_id = it->first; // just to cast constness out (we do not have const Persist)
            persistorChild.PersistAttribute(XML_ATTR_COLUMN_SET_ID_VIEW, view_id);
            // note: we are asking the child to persist on the same level.
            // thats to save on depth
            it->second->Persist(persistorChild);
        }
    }
    else
    {
        // use base class to read. it will call OnNewElement for each found
        m_map.clear();
        XMLListCollectionBase::Persist(persistor);
    }
}

/***************************************************************************\
 *
 * METHOD:  ViewToColSetDataMapPersistor::OnNewElement
 *
 * PURPOSE: called by the base class to create and persist the new element
 *
 * PARAMETERS:
 *    CPersistor& persistor - [in] persistor from which to persist new element
 *
 * RETURNS:
 *    void
 *
 * see "Data structures used to persist column information" comment
 * int file colwidth.h for more information
\***************************************************************************/
void ViewToColSetDataMapPersistor::OnNewElement(CPersistor& persistor)
{
    // we will sneak under child's element to persist the KEY value as an attribute
    // of the child element. To do that we use tag got from GetXMLType() of the child
    CColumnSetData setData;
    CPersistor persistorChild(persistor, setData.GetXMLType());

    // read the key value from the child element
    int view_id = 0;
    persistorChild.PersistAttribute(XML_ATTR_COLUMN_SET_ID_VIEW, view_id);

    // insert value to the list
    ColSetDataList::iterator it = m_list.insert(m_list.end(), setData);
    // ad list iterator to the map
    m_map[view_id] = it;

    // persist contents of the list item
    it->Persist(persistorChild);
}

/***************************************************************************\
 *
 * METHOD:  ColSetIDToViewTableMapPersistor::Persist
 *
 * PURPOSE: called as a request for the object to persist it's data
 *
 * PARAMETERS:
 *    CPersistor &persistor [in] persistor to persist to/from
 *
 * RETURNS:
 *    void
 *
 * see "Data structures used to persist column information" comment
 * int file colwidth.h for more information
\***************************************************************************/
void ColSetIDToViewTableMapPersistor::Persist(CPersistor &persistor)
{
    if (persistor.IsStoring())
    {
        // iterate and save all elements as linear list
        ColSetIDToViewTableMap::iterator it;
        for (it = m_map.begin(); it != m_map.end(); ++it)
        {
            // we will sneak under child's element to persist the KEY value as an attribute
            // of the child element. To do that we use tag got from _GetXMLType() of the child
            CPersistor persistorChild(persistor, ViewToColSetDataMapPersistor::_GetXMLType());
            CColumnSetID& rID = *const_cast<CColumnSetID *>(&it->first);
            rID.Persist(persistorChild);

            // note: we are asking the child to persist on the same level.
            // thats to save on depth
            ViewToColSetDataMapPersistor mapPersistor(it->second, m_list);
            mapPersistor.Persist(persistorChild);
        }
    }
    else
    {
        // use base class to read. it will call OnNewElement for each found
        m_map.clear();
        XMLListCollectionBase::Persist(persistor);
    }
}

/***************************************************************************\
 *
 * METHOD:  ColSetIDToViewTableMapPersistor::OnNewElement
 *
 * PURPOSE: called by the base class to create and persist the new element
 *
 * PARAMETERS:
 *    CPersistor& persistor - [in] persistor from which to persist new element
 *
 * RETURNS:
 *    void
 *
 * see "Data structures used to persist column information" comment
 * int file colwidth.h for more information
\***************************************************************************/
void ColSetIDToViewTableMapPersistor::OnNewElement(CPersistor& persistor)
{
    // we will sneak under child's element to persist the KEY value as an attribute
    // of the child element. To do that we use tag got from _GetXMLType() of the child
    CPersistor persistorChild(persistor, ViewToColSetDataMapPersistor::_GetXMLType());

    // read the key value from the child element
    // note that we are forcing CColumnSetID to share the same element,
    // therefore we are not using persistor.Persist()
    CColumnSetID ID;
    ID.Persist(persistorChild);

    // insert the new element into the map
    ViewToColSetDataMap &rMap = m_map[ID];

    // create the wrapper on inserted map value
    // (pass a list to wrapper. we actually have it [list] for this only reason)
    ViewToColSetDataMapPersistor mapPersistor(m_map[ID], m_list);

    // ask wrapper to read the rest
    mapPersistor.Persist(persistorChild);
}

/***************************************************************************\
 *
 * METHOD:  SnapinToColSetIDMapPersistor::Persist
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CPersistor &persistor
 *
 * RETURNS:
 *    void
 *
 * see "Data structures used to persist column information" comment
 * int file colwidth.h for more information
\***************************************************************************/
void SnapinToColSetIDMapPersistor::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("SnapinToColSetIDMapPersistor::Persist"));

    if (persistor.IsStoring())
    {
        // prior-to-save cleanup
        sc = ScPurgeUnusedColumnData();
        if (sc)
            sc.Throw();

        // iterate and save all elements as linear list
        SnapinToColSetIDMap::iterator it;
        for (it = m_map.begin(); it != m_map.end(); ++it)
        {
            // we will sneak under child's element to persist the KEY value as an attribute
            // of the child element. To do that we use tag got from _GetXMLType() of the child
            CPersistor persistorChild(persistor, ColSetIDToViewTableMapPersistor::_GetXMLType());

            // write the key value.
             // just to cast constness out (we do not have const Persist)
            GUID& guid = *const_cast<GUID *>(&it->first);
            persistorChild.PersistAttribute(XML_ATTR_COLUMN_INFO_SNAPIN, guid);

            // create a wrapper on the value (which is also a map)
            // (pass a list to wrapper. though it's not used for storing)
            ColSetIDToViewTableMapPersistor mapPersistor(it->second, m_list);

            // persist the wrapper
            mapPersistor.Persist(persistorChild);
        }
    }
    else
    {
        // use base class to read. it will call OnNewElement for each found
        m_map.clear();
        XMLListCollectionBase::Persist(persistor);
    }
}

/***************************************************************************\
 *
 * METHOD:  SnapinToColSetIDMapPersistor::OnNewElement
 *
 * PURPOSE: called by the base class to create and persist the new element
 *
 * PARAMETERS:
 *    CPersistor& persistor - [in] persistor from which to persist new element
 *
 * RETURNS:
 *    void
 *
 * see "Data structures used to persist column information" comment
 * int file colwidth.h for more information
\***************************************************************************/
void SnapinToColSetIDMapPersistor::OnNewElement(CPersistor& persistor)
{
    // we will sneak under child's element to persist the KEY value as an attribute
    // of the child element. To do that we use tag got from _GetXMLType() of the child
    CPersistor persistorChild(persistor, ColSetIDToViewTableMapPersistor::_GetXMLType());

    GUID guid;
    // read the key value
    persistorChild.PersistAttribute(XML_ATTR_COLUMN_INFO_SNAPIN, guid);

    // insert the new element into the map
    ColSetIDToViewTableMap &rMap = m_map[guid];

    // create the wrapper on inserted map value
    // (pass a list to wrapper. we actually have it [list] for this only reason)
    ColSetIDToViewTableMapPersistor mapPersistor(rMap, m_list);

    // ask wrapper to read the rest
    mapPersistor.Persist(persistorChild);
}

/***************************************************************************\
 *
 * METHOD:  SnapinToColSetIDMapPersistor::ScPurgeUnusedColumnData
 *
 * PURPOSE: prior-to-save cleanup. removes unused snapin entries
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC SnapinToColSetIDMapPersistor::ScPurgeUnusedColumnData()
{
    DECLARE_SC(sc, TEXT("SnapinToColSetIDMapPersistor::ScPurgeUnusedColumnData"));

    // get the scopetree pointer
    CScopeTree *pScopeTree = CScopeTree::GetScopeTree();

    // check it
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc;

    // iterate and remove unused entries
    SnapinToColSetIDMap::iterator it = m_map.begin();
    while (it != m_map.end())
    {
        // ask the scope tree if snapin is in use
        BOOL bInUse = FALSE;
        sc = pScopeTree->IsSnapinInUse(it->first, &bInUse);
        if (sc)
            return sc;

        // act depending on usage
        if (bInUse)
        {
            ++it;   // skip also the stuff currently in use
        }
        else
        {
            // to the trash can

            ColSetIDToViewTableMap& colSets = it->second;

            // Iterate thro' all colset ids of this snapin.
            ColSetIDToViewTableMap::iterator itColumnSetIDMap = colSets.begin();

            while(itColumnSetIDMap != colSets.end())
            {
                // Get the view map

                ViewToColSetDataMap& viewIDMap = itColumnSetIDMap->second;
                ViewToColSetDataMap::iterator itViewIDMap = viewIDMap.begin();

                // Iterate thro' all views and remove entries
                while (itViewIDMap  != viewIDMap.end())
                {
                    m_list.erase(/*(ItColSetDataList)*/itViewIDMap->second);
                    itViewIDMap = viewIDMap.erase(itViewIDMap);
                }

                itColumnSetIDMap = colSets.erase(itColumnSetIDMap);
            }

            it = m_map.erase(it);
        }

    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\compcat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       compcat.h
//
//--------------------------------------------------------------------------

// compcat.h : interfaces for the CComponentCategory class
//
/////////////////////////////////////////////////////////////////////////////
#ifndef __COMPCAT_H__
#define __COMPCAT_H__


class CComponentCategory
{
// Constructors / destructors
public:
    CComponentCategory();
    ~CComponentCategory();

//attribute
public:
    typedef struct tagComponentInfo
    {
        CLSID           m_clsid;                // Component CLSID
        UINT            m_uiBitmap;             // Bitmap ID in ImageList
        CStr            m_strName;              // Component Readable Name
        bool            m_bSelected;            // Filter selection flag
    } COMPONENTINFO;

    CArray <CATEGORYINFO*, CATEGORYINFO*>       m_arpCategoryInfo;      // Array of categories
    CArray <COMPONENTINFO*, COMPONENTINFO*>     m_arpComponentInfo;     // Array of componets
    
    WTL::CImageList     m_iml;                  // Image list of components


//Operations
public:
    void CommonStruct(void);
    BOOL ValidateInstall(void);
    void EnumComponentCategories(void);
    void EnumComponents();
    void FilterComponents(CATEGORYINFO* pCatInfo);

    HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription);
    HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid);
    HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid);

};

#endif //__COMPCAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\comcat.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0101 */
/* at Fri May 24 09:43:08 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __comcat_h__
#define __comcat_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumGUID_FWD_DEFINED__
#define __IEnumGUID_FWD_DEFINED__
typedef interface IEnumGUID IEnumGUID;
#endif 	/* __IEnumGUID_FWD_DEFINED__ */


#ifndef __IEnumCATEGORYINFO_FWD_DEFINED__
#define __IEnumCATEGORYINFO_FWD_DEFINED__
typedef interface IEnumCATEGORYINFO IEnumCATEGORYINFO;
#endif 	/* __IEnumCATEGORYINFO_FWD_DEFINED__ */


#ifndef __ICatRegister_FWD_DEFINED__
#define __ICatRegister_FWD_DEFINED__
typedef interface ICatRegister ICatRegister;
#endif 	/* __ICatRegister_FWD_DEFINED__ */


#ifndef __ICatInformation_FWD_DEFINED__
#define __ICatInformation_FWD_DEFINED__
typedef interface ICatInformation ICatInformation;
#endif 	/* __ICatInformation_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: comcat.h
//
//--------------------------------------------------------------------------
			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */


////////////////////////////////////////////////////////////////////////////
//  Classes (link with uuid3.lib)

#pragma comment(lib,"uuid.lib")

EXTERN_C const CLSID CLSID_StdComponentCategoriesMgr;

////////////////////////////////////////////////////////////////////////////
//  Types
			/* size is 16 */
typedef GUID CATID;

			/* size is 4 */
typedef REFGUID REFCATID;

#define IID_IEnumCLSID              IID_IEnumGUID
#define IEnumCLSID                  IEnumGUID
#define LPENUMCLSID                 LPENUMGUID
#define CATID_NULL                   GUID_NULL
#define IsEqualCATID(rcatid1, rcatid2)       IsEqualGUID(rcatid1, rcatid2)
#define IID_IEnumCATID       IID_IEnumGUID
#define IEnumCATID           IEnumGUID

////////////////////////////////////////////////////////////////////////////
//  Category IDs (link to uuid3.lib)
EXTERN_C const CATID CATID_Insertable;
EXTERN_C const CATID CATID_Control;
EXTERN_C const CATID CATID_Programmable;
EXTERN_C const CATID CATID_IsShortcut;
EXTERN_C const CATID CATID_NeverShowExt;
EXTERN_C const CATID CATID_DocObject;
EXTERN_C const CATID CATID_Printable;
EXTERN_C const CATID CATID_RequiresDataPathHost;
EXTERN_C const CATID CATID_PersistsToMoniker;
EXTERN_C const CATID CATID_PersistsToStorage;
EXTERN_C const CATID CATID_PersistsToStreamInit;
EXTERN_C const CATID CATID_PersistsToStream;
EXTERN_C const CATID CATID_PersistsToMemory;
EXTERN_C const CATID CATID_PersistsToFile;
EXTERN_C const CATID CATID_PersistsToPropertyBag;
EXTERN_C const CATID CATID_InternetAware;

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPENUMGUID_DEFINED
#define _LPENUMGUID_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IEnumGUID_INTERFACE_DEFINED__
#define __IEnumGUID_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumGUID
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumGUID __RPC_FAR *LPENUMGUID;


EXTERN_C const IID IID_IEnumGUID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumGUID : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumGUIDVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumGUID __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumGUID __RPC_FAR * This,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumGUIDVtbl;

    interface IEnumGUID
    {
        CONST_VTBL struct IEnumGUIDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumGUID_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumGUID_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumGUID_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumGUID_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumGUID_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumGUID_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumGUID_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IEnumGUID_Next_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumGUID_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumGUID_Skip_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumGUID_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumGUID_Reset_Proxy( 
    IEnumGUID __RPC_FAR * This);


void __RPC_STUB IEnumGUID_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumGUID_Clone_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumGUID_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumGUID_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0006
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPENUMCATEGORYINFO_DEFINED
#define _LPENUMCATEGORYINFO_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_s_ifspec;

#ifndef __IEnumCATEGORYINFO_INTERFACE_DEFINED__
#define __IEnumCATEGORYINFO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumCATEGORYINFO
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumCATEGORYINFO __RPC_FAR *LPENUNCATEGORYINFO;

			/* size is 276 */
typedef struct  tagCATEGORYINFO
    {
    CATID catid;
    LCID lcid;
    OLECHAR szDescription[ 128 ];
    }	CATEGORYINFO;

			/* size is 4 */
typedef struct tagCATEGORYINFO __RPC_FAR *LPCATEGORYINFO;


EXTERN_C const IID IID_IEnumCATEGORYINFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumCATEGORYINFO : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCATEGORYINFOVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumCATEGORYINFOVtbl;

    interface IEnumCATEGORYINFO
    {
        CONST_VTBL struct IEnumCATEGORYINFOVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCATEGORYINFO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCATEGORYINFO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCATEGORYINFO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCATEGORYINFO_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumCATEGORYINFO_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCATEGORYINFO_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCATEGORYINFO_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IEnumCATEGORYINFO_Next_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCATEGORYINFO_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumCATEGORYINFO_Skip_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCATEGORYINFO_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumCATEGORYINFO_Reset_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This);


void __RPC_STUB IEnumCATEGORYINFO_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumCATEGORYINFO_Clone_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumCATEGORYINFO_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCATEGORYINFO_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0007
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCATREGISTER_DEFINED
#define _LPCATREGISTER_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0007_v0_0_s_ifspec;

#ifndef __ICatRegister_INTERFACE_DEFINED__
#define __ICatRegister_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatRegister
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ICatRegister __RPC_FAR *LPCATREGISTER;


EXTERN_C const IID IID_ICatRegister;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICatRegister : public IUnknown
    {
    public:
        virtual HRESULT __stdcall RegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]) = 0;
        
        virtual HRESULT __stdcall UnRegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT __stdcall RegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT __stdcall UnRegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT __stdcall RegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT __stdcall UnRegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatRegisterVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ICatRegister __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ICatRegister __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *RegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *UnRegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *RegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *UnRegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *RegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *UnRegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
    } ICatRegisterVtbl;

    interface ICatRegister
    {
        CONST_VTBL struct ICatRegisterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatRegister_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatRegister_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatRegister_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatRegister_RegisterCategories(This,cCategories,rgCategoryInfo)	\
    (This)->lpVtbl -> RegisterCategories(This,cCategories,rgCategoryInfo)

#define ICatRegister_UnRegisterCategories(This,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterCategories(This,cCategories,rgcatid)

#define ICatRegister_RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ICatRegister_RegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);


void __RPC_STUB ICatRegister_RegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_UnRegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_RegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_UnRegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_RegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_UnRegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatRegister_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0008
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCATINFORMATION_DEFINED
#define _LPCATINFORMATION_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0008_v0_0_s_ifspec;

#ifndef __ICatInformation_INTERFACE_DEFINED__
#define __ICatInformation_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatInformation
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ICatInformation __RPC_FAR *LPCATINFORMATION;


EXTERN_C const IID IID_ICatInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICatInformation : public IUnknown
    {
    public:
        virtual HRESULT __stdcall EnumCategories( 
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo) = 0;
        
        virtual HRESULT __stdcall GetCategoryDesc( 
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc) = 0;
        
        virtual HRESULT __stdcall EnumClassesOfCategories( 
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid) = 0;
        
        virtual HRESULT __stdcall IsClassOfCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]) = 0;
        
        virtual HRESULT __stdcall EnumImplCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
        virtual HRESULT __stdcall EnumReqCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatInformationVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ICatInformation __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ICatInformation __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *EnumCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);
        
        HRESULT ( __stdcall __RPC_FAR *GetCategoryDesc )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc);
        
        HRESULT ( __stdcall __RPC_FAR *EnumClassesOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);
        
        HRESULT ( __stdcall __RPC_FAR *IsClassOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *EnumImplCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
        HRESULT ( __stdcall __RPC_FAR *EnumReqCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
    } ICatInformationVtbl;

    interface ICatInformation
    {
        CONST_VTBL struct ICatInformationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatInformation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatInformation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatInformation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatInformation_EnumCategories(This,lcid,ppenumCategoryInfo)	\
    (This)->lpVtbl -> EnumCategories(This,lcid,ppenumCategoryInfo)

#define ICatInformation_GetCategoryDesc(This,rcatid,lcid,pszDesc)	\
    (This)->lpVtbl -> GetCategoryDesc(This,rcatid,lcid,pszDesc)

#define ICatInformation_EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)	\
    (This)->lpVtbl -> EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)

#define ICatInformation_IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)	\
    (This)->lpVtbl -> IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)

#define ICatInformation_EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)

#define ICatInformation_EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ICatInformation_EnumCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ LCID lcid,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);


void __RPC_STUB ICatInformation_EnumCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_GetCategoryDesc_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCATID rcatid,
    /* [in] */ LCID lcid,
    /* [out] */ LPWSTR __RPC_FAR *pszDesc);


void __RPC_STUB ICatInformation_GetCategoryDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_EnumClassesOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);


void __RPC_STUB ICatInformation_EnumClassesOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_IsClassOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]);


void __RPC_STUB ICatInformation_IsClassOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_EnumImplCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumImplCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_EnumReqCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumReqCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatInformation_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0009
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL__intf_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0009_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\compcat.cpp ===
// CompCat.cpp : implementation of the CComponentCategory class
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      CompCat.cpp
//
//  Contents:  Enumerates the component categories
//
//  History:   01-Aug-96 WayneSc    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"         //precompiled header

#include <comcat.h>         // COM Component Categoories Manager


#include "compcat.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentCategory);

CComponentCategory::CComponentCategory()
{
    BOOL const created = m_iml.Create( IDB_IMAGELIST, 16 /*cx*/, 4 /*cGrow*/, RGB(0,255,0) /*RGBLTGREEN*/ );
    ASSERT(created);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentCategory);
}

CComponentCategory::~CComponentCategory()
{
    // delete all memory allocated for categories
    for (int i=0; i <= m_arpCategoryInfo.GetUpperBound(); i++)
        delete m_arpCategoryInfo.GetAt(i);

    m_arpCategoryInfo.RemoveAll();

    // delete all memory allocated for components
    for (i=0; i <= m_arpComponentInfo.GetUpperBound(); i++)
        delete m_arpComponentInfo.GetAt(i);

    m_arpComponentInfo.RemoveAll();

    m_iml.Destroy();

    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentCategory);
}


void CComponentCategory::EnumComponentCategories(void)
{
    ICatInformation* pci = NULL;
    HRESULT hr;
    
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_INPROC, IID_ICatInformation, (void**)&pci);
    if (SUCCEEDED(hr))
    {
        IEnumCATEGORYINFO* penum = NULL;
        if (SUCCEEDED(hr = pci->EnumCategories(GetUserDefaultLCID(), &penum)))
        {
            CATEGORYINFO* pCatInfo = new CATEGORYINFO;
            while (penum->Next(1, pCatInfo, NULL) == S_OK)
            {
                // skip unnamed categories 
                if ( pCatInfo->szDescription[0] && !IsEqualCATID(pCatInfo->catid, CATID_Control))
                {
                    m_arpCategoryInfo.Add(pCatInfo);
                    pCatInfo = new CATEGORYINFO;
                }
            }
            delete pCatInfo;
            
            penum->Release();
        }
        pci->Release();
    }
}


void CComponentCategory::EnumComponents()
{   
    ICatInformation* pci;
    HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, MMC_CLSCTX_INPROC, 
                                    IID_ICatInformation, (void**)&pci);
    if (SUCCEEDED(hr))
    {
        IEnumCLSID* penumClass;
        hr = pci->EnumClassesOfCategories(1, const_cast<GUID*>(&CATID_Control), 0, NULL, &penumClass);
        if (SUCCEEDED(hr)) 
        {
            CLSID   clsid;
            while (penumClass->Next(1, &clsid, NULL) == S_OK)
            {

                TCHAR   szCLSID [40];
#ifdef _UNICODE
                StringFromGUID2(clsid, szCLSID, countof(szCLSID));
#else
                WCHAR wszCLSID[40];
                StringFromGUID2(clsid, wszCLSID, countof(wszCLSID));
                WideCharToMultiByte(CP_ACP, 0, wszCLSID, -1, szCLSID, sizeof(szCLSID), NULL, NULL);
#endif // _UNICODE
                
                COMPONENTINFO* pComponentInfo = new COMPONENTINFO;
 
                TCHAR szName[MAX_PATH];
                szName[0] = _T('\0');

                long cb = sizeof(szName); // this is a weird API - it takes a TSTR but asks for the length in cb, not cch
            
                // Get control class name
                RegQueryValue(HKEY_CLASSES_ROOT, CStr("CLSID\\") + szCLSID, szName, &cb); 
                if (szName[0] != _T('\0'))
                    pComponentInfo->m_strName = szName;
                else
                    pComponentInfo->m_strName = szCLSID;

                // set the remainder attributes
                pComponentInfo->m_clsid = clsid;
                pComponentInfo->m_uiBitmap=0; // (WayneSc) need to open up exe
                pComponentInfo->m_bSelected = TRUE;

                // Add component to array
                m_arpComponentInfo.Add(pComponentInfo);
            } 
            penumClass->Release();
        }
        pci->Release();
    }
}

void CComponentCategory::FilterComponents(CATEGORYINFO* pCatInfo)
{
    ICatInformation* pci;
    HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, MMC_CLSCTX_INPROC, 
                                    IID_ICatInformation, (void**)&pci);
    if (SUCCEEDED(hr))
    {
        for (int i=0; i <= m_arpComponentInfo.GetUpperBound(); i++)
        {
            COMPONENTINFO* pCompInfo = m_arpComponentInfo.GetAt(i);

            // if NULL categories, select all conponents
            if (pCatInfo == NULL)
            {
                pCompInfo->m_bSelected = TRUE;
            }
            else
            {
                // Query if component implements the category
                pCompInfo->m_bSelected = 
                    (pci->IsClassOfCategories(pCompInfo->m_clsid, 1, &pCatInfo->catid, 0, NULL) == S_OK);
            } 
        }
        pci->Release();
    }
}


// Helper function to create a component category and associated description
HRESULT CComponentCategory::CreateComponentCategory(CATID catid, WCHAR* catDescription)
{
    DECLARE_SC(sc, TEXT("CComponentCategory::CreateComponentCategory"));

    CComPtr<ICatRegister> pcr;

    sc = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
            NULL, MMC_CLSCTX_INPROC, IID_ICatRegister, (void**)&pcr);

    if (sc)
        return sc.ToHr();

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

    sc = StringCchCopyW(catinfo.szDescription, countof(catinfo.szDescription), catDescription);
    if(sc)
        return sc.ToHr();

    sc = pcr->RegisterCategories(1, &catinfo);
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}

// Helper function to register a CLSID as belonging to a component category
HRESULT CComponentCategory::RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
    {
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
            NULL, MMC_CLSCTX_INPROC, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
    return hr;
    }

// Helper function to unregister a CLSID as belonging to a component category
HRESULT CComponentCategory::UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
    {
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
            NULL, MMC_CLSCTX_INPROC, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\copypast.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       copypast.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "objfmts.h"
#include "copypast.h"
#include "multisel.h"
#include "dbg.h"
#include "rsltitem.h"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/***************************************************************************\
|
| NOTE: DataObject Cleanup works by these rules (see CNode::CDataObjectCleanup):
|
|  1. Data object created for cut , copy or dragdrop registers every node added to it
|  2. Nodes are registered in the static multimap, mapping node to the data object it belongs to.
|  3. Node destructor checks the map and triggers cleanup for all affected data objects.
|  4. Data Object cleanup is: 	a) unregistering its nodes,
|  				b) release contained data objects
|  				b) entering invalid state (allowing only removal of cut objects to succeed)
|  				c) revoking itself from clipboard if it is on the clipboard.
|  It will not do any of following:	a) release references to IComponents as long as is alive
|  				b) prevent MMCN_CUTORMOVE to be send by invoking RemoveCutItems()
|
\***************************************************************************/

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject~CMMCClipBoardDataObject
 *
 * PURPOSE: Destructor. Informs CNode's that they are no longer on clipboard
 *
\***************************************************************************/
CMMCClipBoardDataObject::~CMMCClipBoardDataObject()
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::~CMMCClipBoardDataObject"));

    // inform all nodes put to clipboard about being removed from there
    // but do not ask to force clenup on itself - it is not needed (we are in desrtuctor)
    // and it is harmfull to cleanup ole in such a case (see bug #164789)
    sc = CNode::CDataObjectCleanup::ScUnadviseDataObject( this , false/*bForceDataObjectCleanup*/);
    if (sc)
        sc.TraceAndClear();
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetSourceProcessId
 *
 * PURPOSE: returns process id of the source data object
 *
 * PARAMETERS:
 *    DWORD *pdwProcID - [out] id of source process
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::GetSourceProcessId( DWORD *pdwProcID )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::GetSourceProcessID"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // parameter check
    sc = ScCheckPointers(pdwProcID);
    if (sc)
        return sc.ToHr();

    // return the id
    *pdwProcID = ::GetCurrentProcessId();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetAction
 *
 * PURPOSE: returns ction which created the data object
 *
 * PARAMETERS:
 *    DATA_SOURCE_ACTION *peAction [out] - action
 *
 * RETURNS:
 *    HRESULT    - result code.
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::GetAction( DATA_SOURCE_ACTION *peAction )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::IsCreatedForCopy"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // parameter check
    sc = ScCheckPointers(peAction);
    if (sc)
        return sc.ToHr();

    // return the action
    *peAction = m_eOperation;

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetCount
 *
 * PURPOSE: Retuns the count of contined snapin data objects
 *
 * PARAMETERS:
 *    DWORD *pdwCount   [out] - count of objects
 *
 * RETURNS:
 *    HRESULT    - result code. S_OK, or error code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::GetCount( DWORD *pdwCount )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::GetCount"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // parameter check
    sc = ScCheckPointers(pdwCount);
    if (sc)
        return sc.ToHr();

    *pdwCount = m_SelectionObjects.size();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetDataObject
 *
 * PURPOSE: Returns one of contained snapin data objects
 *
 * PARAMETERS:
 *    DWORD dwIndex           [in] - index of reqested object
 *    IDataObject **ppObject  [out] - requested object
 *    DWORD *pdwFlags         [out] - object flags
 *
 * RETURNS:
 *    HRESULT    - result code. S_OK, or error code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::GetDataObject( DWORD dwIdx, IDataObject **ppObject, DWORD *pdwFlags )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::GetDataObject"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // check out param
    sc = ScCheckPointers(ppObject, pdwFlags);
    if (sc)
        return sc.ToHr();

    // init out param
    *ppObject = NULL;
    *pdwFlags = 0;

    // more parameter check
    if ( dwIdx >= m_SelectionObjects.size() )
        return (sc = E_INVALIDARG).ToHr();

    // return the object
    IDataObjectPtr spObject = m_SelectionObjects[dwIdx].spDataObject;
    *ppObject = spObject.Detach();
    *pdwFlags = m_SelectionObjects[dwIdx].dwSnapinOptions;

    return sc.ToHr();
}

///////////////////////////////////////////////////////////////////////////////

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::ScGetSingleSnapinObject
 *
 * PURPOSE: Returns interface to data object created by the source snapin
 *          NOTE: returns S_FALSE (and NULL ptr) when snapin count is not
 *          equal to one
 *
 * PARAMETERS:
 *    IDataObject **ppDataObject [out] - interface to data object
 *
 * RETURNS:
 *    HRESULT    - result code. S_OK, or error code
 *
\***************************************************************************/
SC CMMCClipBoardDataObject::ScGetSingleSnapinObject( IDataObject **ppDataObject )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::GetContainedSnapinObject"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return sc = E_UNEXPECTED;

    // parameter check
    sc = ScCheckPointers( ppDataObject );
    if (sc)
        return sc;

    // init out parameter
    *ppDataObject = NULL;

    // we can only resolve to the snapin if we have only one of them
    if ( m_SelectionObjects.size() != 1 )
        return sc = S_FALSE;

    // ask for snapins DO
    IDataObjectPtr spDataObject = m_SelectionObjects[0].spDataObject;

    // return
    *ppDataObject = spDataObject.Detach();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetDataHere
 *
 * PURPOSE: Implements IDataObject::GetDataHere. Forwards to snapin or fails
 *
 * PARAMETERS:
 *    LPFORMATETC lpFormatetc
 *    LPSTGMEDIUM lpMedium
 *
 * RETURNS:
 *    HRESULT    - result code. S_OK, or error code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::GetDataHere"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // parameter check
    sc = ScCheckPointers(lpFormatetc, lpMedium);
    if (sc)
        return sc.ToHr();

    // try to get the snapin
    IDataObjectPtr spDataObject;
    sc = ScGetSingleSnapinObject( &spDataObject );
    if (sc)
        return sc.ToHr();

    // we do not support any clipboard format at all ourselves
    if (sc == S_FALSE)
        return (sc = DATA_E_FORMATETC).ToHr();

    // recheck
    sc = ScCheckPointers( spDataObject, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    // forward to the snapin
    sc = spDataObject->GetDataHere(lpFormatetc, lpMedium);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetData
 *
 * PURPOSE: Implements IDataObject::GetData. Forwards to snapin or fails
 *
 * PARAMETERS:
 *    LPFORMATETC lpFormatetcIn
 *    LPSTGMEDIUM lpMedium
 *
 * RETURNS:
 *    HRESULT    - result code. S_OK, or error code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::GetData"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // parameter check
    sc = ScCheckPointers(lpFormatetcIn, lpMedium);
    if (sc)
        return sc.ToHr();

    // try to get the snapin
    IDataObjectPtr spDataObject;
    sc = ScGetSingleSnapinObject( &spDataObject );
    if (sc)
        return sc.ToHr();

    // we do not support any clipboard format at all ourselves
    if (sc == S_FALSE)
        return (sc = DATA_E_FORMATETC).ToHr();

    // recheck
    sc = ScCheckPointers( spDataObject, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    // forward to the snapin
    sc = spDataObject->GetData(lpFormatetcIn, lpMedium);
    if (sc)
    {
        HRESULT hr = sc.ToHr();
        sc.Clear(); // ignore the error
        return hr;
    }

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::EnumFormatEtc
 *
 * PURPOSE: Implements IDataObject::EnumFormatEtc. Forwards to snapin or fails
 *
 * PARAMETERS:
 *    DWORD dwDirection
 *    LPENUMFORMATETC* ppEnumFormatEtc
 *
 * RETURNS:
 *    HRESULT    - result code. S_OK, or error code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::EnumFormatEtc"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // parameter check
    sc = ScCheckPointers(ppEnumFormatEtc);
    if (sc)
        return sc.ToHr();

    // init out parameter
    *ppEnumFormatEtc = NULL;

    IEnumFORMATETCPtr spEnum;
    std::vector<FORMATETC> vecFormats;

    // add own entry
    if (dwDirection == DATADIR_GET)
    {
        FORMATETC fmt ={GetWrapperCF(), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        vecFormats.push_back( fmt );
    }

    // try to get the snapin
    IDataObjectPtr spDataObject;
    sc = ScGetSingleSnapinObject( &spDataObject );
    if (sc)
        return sc.ToHr();

    // add snapins formats (when we have one-and-only snapin)
    IEnumFORMATETCPtr spEnumSnapin;
    if (sc == S_OK)
    {
        // recheck
        sc = ScCheckPointers( spDataObject, E_UNEXPECTED );
        if (sc)
            return sc.ToHr();

        // forward to the snapin
        sc = spDataObject->EnumFormatEtc(dwDirection, &spEnumSnapin);
        if ( !sc.IsError() )
        {
            // recheck the pointer
            sc = ScCheckPointers( spEnumSnapin );
            if (sc)
                return sc.ToHr();

            // reset the enumeration
            sc = spEnumSnapin->Reset();
            if (sc)
                return sc.ToHr();

            FORMATETC frm;
            ZeroMemory( &frm, sizeof(frm) );

            while ( (sc = spEnumSnapin->Next( 1, &frm, NULL )) == S_OK )
            {
                vecFormats.push_back( frm );
            }
            // trap the error
            if (sc)
                return sc.ToHr();


        }
        else
        {
            sc.Clear(); // ignore the error - some snapins does not implement it
        }
    }

    if ( vecFormats.size() == 0 ) // have nothing to return ?
        return (sc = E_FAIL).ToHr();

    // create the enumerator
    sc = ::GetObjFormats( vecFormats.size(), vecFormats.begin(), (void **)ppEnumFormatEtc );
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::QueryGetData
 *
 * PURPOSE: Implements IDataObject::QueryGetData. Forwards to snapin or fails
 *
 * PARAMETERS:
 *    LPFORMATETC lpFormatetc
 *
 * RETURNS:
 *    HRESULT    - result code. S_OK, or error code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::QueryGetData(LPFORMATETC lpFormatetc)
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::QueryGetData"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // parameter check
    sc = ScCheckPointers(lpFormatetc);
    if (sc)
        return sc.ToHr();

    // try to get the snapin
    IDataObjectPtr spDataObject;
    sc = ScGetSingleSnapinObject( &spDataObject );
    if (sc)
        return sc.ToHr();

    // we do not support any clipboard format at all ourselves
    if (sc == S_FALSE)
        return DV_E_FORMATETC; // not assigning to sc - not an error

    // recheck
    sc = ScCheckPointers( spDataObject, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    // forward to the snapin
    sc = spDataObject->QueryGetData(lpFormatetc);
    if (sc)
    {
        HRESULT hr = sc.ToHr();
        sc.Clear(); // ignore the error
        return hr;
    }

    return sc.ToHr();
}


/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::RemoveCutItems
 *
 * PURPOSE: Called to remove copied objects from the source snapin
 *
 * PARAMETERS:
 *    DWORD dwIndex                 [in] snapin index
 *    IDataObject *pCutDataObject   [in] items to be removed
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::RemoveCutItems( DWORD dwIndex, IDataObject *pCutDataObject )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::RemoveCutItems"));

    // this is the only method allowed to be called on invalid object

    // check param
    sc = ScCheckPointers(pCutDataObject);
    if (sc)
        return sc.ToHr();

    // more parameter check
    if ( dwIndex >= m_SelectionObjects.size() )
        return (sc = E_INVALIDARG).ToHr();


    // get to the snapin
    IComponent *pComponent = m_SelectionObjects[dwIndex].spComponent;
    sc = ScCheckPointers( pComponent, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    sc = pComponent->Notify( NULL, MMCN_CUTORMOVE,
                             reinterpret_cast<LONG_PTR>(pCutDataObject), 0 );
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

///////////////////////////////////////////////////////////////////////////////

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::ScCreateInstance
 *
 * PURPOSE: Helper method (static) to create instance of CMMCClipBoardDataObject
 *
 * PARAMETERS:
 *    DATA_SOURCE_ACTION operation          [in] why the object is created
 *    CMTNode *pTiedObj                     [in] object to trigger revoking
 *    CMMCClipBoardDataObject **ppRawObject [out] raw pointer
 *    IMMCClipboardDataObject **ppInterface [out] pointer to interface
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCClipBoardDataObject::ScCreateInstance(DATA_SOURCE_ACTION operation,
                                             CMMCClipBoardDataObject **ppRawObject,
                                             IMMCClipboardDataObject **ppInterface)
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::ScCreateInstance"));

    // parameter check;
    sc = ScCheckPointers( ppRawObject, ppInterface );
    if (sc)
        return sc;

    // out param initialization
    *ppInterface = NULL;
    *ppRawObject = NULL;

    typedef CComObject<CMMCClipBoardDataObject> CreatedObj;
    CreatedObj *pCreatedObj;

    sc = CreatedObj::CreateInstance( &pCreatedObj );
    if (sc)
        return sc;

    // add first reference if non null;
    IMMCClipboardDataObjectPtr spMMCDataObject = pCreatedObj;

    // recheck
    sc = ScCheckPointers( spMMCDataObject, E_UNEXPECTED );
    if (sc)
    {
        delete pCreatedObj;
        return sc;
    }

    // init the object
    static_cast<CMMCClipBoardDataObject *>(pCreatedObj)->m_eOperation = operation;

    // return 'em
    *ppInterface = spMMCDataObject.Detach();
    *ppRawObject = pCreatedObj;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::ScAddSnapinDataObject
 *
 * PURPOSE: Part of creating DO for the operation
 *          Adds snapins data to be carried inside
 *
 * PARAMETERS:
 *    IComponent *pComponent   [in] - source snapin, which data id added
 *    IDataObject *pObject     [in] - data object supplied by snapin
 *    bool bCopyEnabled        [in] - if snapin allows to copy the data
 *    bool bCutEnabled         [in] - if snapin allows to move the data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCClipBoardDataObject::ScAddSnapinDataObject( const CNodePtrArray& nodes,
                                                   IComponent *pComponent,
                                                   IDataObject *pObject,
                                                   bool bCopyEnabled, bool bCutEnabled )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::ScAddSnapinDataObject"));

    // parameter check
    sc = ScCheckPointers( pComponent, pObject );
    if (sc)
        return sc;

    // create the object;
    ObjectEntry object;
    object.dwSnapinOptions = (bCopyEnabled ? COPY_ALLOWED : 0) |
                             (bCutEnabled ? MOVE_ALLOWED : 0);
    object.spComponent = pComponent;
    object.spDataObject = pObject;

    // register the nodes to invalidate this data object on destruction
    for ( CNodePtrArray::const_iterator it = nodes.begin(); it != nodes.end(); ++it )
    {
        CNode *pNode = *it;
        sc = ScCheckPointers( pNode, E_UNEXPECTED );
        if (sc)
            return sc;

        // register node to revoke this object from destructor
        sc = CNode::CDataObjectCleanup::ScRegisterNode( pNode, this );
        if (sc)
            return sc;
    }

    // add to the array
    m_SelectionObjects.push_back(object);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetNodeCopyAndCutVerbs
 *
 * PURPOSE: Calculates if copy and cut verb are enabled for node
 *
 * PARAMETERS:
 *    CNode* pNode              [in] node to examine
 *    IDataObject *pDataObject  [in] snapin's data object
 *    bool bScopePane           [in] Scope or result (item for which the verb states needed).
 *    LPARAM lvData             [in] If result then the LVDATA.
 *    bool *pCopyEnabled        [out] true == Copy verb enabled
 *    bool *bCutEnabled         [out] true == Cut verb enabled
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCClipBoardDataObject::ScGetNodeCopyAndCutVerbs( CNode* pNode, IDataObject *pDataObject,
                                                      bool bScopePane, LPARAM lvData,
                                                      bool *pbCopyEnabled, bool *pbCutEnabled )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::ScGetNodeCopyAndCutVerbs"));

    // paramter check
    sc = ScCheckPointers(pNode, pDataObject, pbCopyEnabled, pbCutEnabled);
    if (sc)
        return sc;

    // init out parameters
    *pbCopyEnabled = *pbCutEnabled = false;

    // Create temp verb with given context.
    CComObject<CTemporaryVerbSet> stdVerbTemp;

    sc = stdVerbTemp.ScInitialize(pDataObject, pNode, bScopePane, lvData);

    BOOL bFlag = FALSE;
    stdVerbTemp.GetVerbState(MMC_VERB_COPY, ENABLED, &bFlag);
    *pbCopyEnabled = bFlag;
    stdVerbTemp.GetVerbState(MMC_VERB_CUT, ENABLED, &bFlag);
    *pbCutEnabled = bFlag;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::ScCreate
 *
 * PURPOSE: helper. Creates and initializes CMMCClipBoardDataObject
 *
 * PARAMETERS:
 *    DATA_SOURCE_ACTION operation       [in] - for which operation (d&d, cut, copy)
 *    CNode* pNode                       [in] - Node to tie to
 *    bool bScopePane                    [in] - if it is scope pane operation
 *    bool bMultiSelect                  [in] - if it is multiselection
 *    LPARAM lvData                      [in] - lvdata for result item
 *    IMMCClipboardDataObject **ppMMCDO  [out] - created data object
 *    bool& bContainsItems               [out] - If snapin does not support cut/copy then
 *                                               dataobjets will not be added and this is
 *                                               not an error
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCClipBoardDataObject::ScCreate( DATA_SOURCE_ACTION operation,
                                      CNode* pNode, bool bScopePane,
                                      bool bMultiSelect, LPARAM lvData,
                                      IMMCClipboardDataObject **ppMMCDataObject,
                                      bool& bContainsItems )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::Create"));

    bContainsItems = false;

    // parameter check
    sc = ScCheckPointers( ppMMCDataObject, pNode );
    if (sc)
        return sc;

    // init out param
    *ppMMCDataObject = NULL;

    // get MT node, view data;
    CMTNode* pMTNode = pNode->GetMTNode();
    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers( pMTNode, pViewData, E_UNEXPECTED );
    if (sc)
        return sc;

    // create data object to be used for data transfer
    CMMCClipBoardDataObject    *pResultObject = NULL;
    IMMCClipboardDataObjectPtr spResultInterface;
    sc = ScCreateInstance(operation, &pResultObject, &spResultInterface);
    if (sc)
        return sc;

    // recheck pointers
    sc = ScCheckPointers( pResultObject, spResultInterface, E_UNEXPECTED );
    if (sc)
        return sc;

    // valid from the start
    pResultObject->m_bObjectValid = true;

    // add data to the object...

    if (!bMultiSelect) // single selection
    {
        // get snapins data object
        IDataObjectPtr spDataObject;
        CComponent*    pCComponent;
        bool           bScopeItem = bScopePane;
		CNode*		   pOwnerNode = NULL;
        sc = pNode->ScGetDataObject(bScopePane, lvData, bScopeItem, &spDataObject, &pCComponent, &pOwnerNode);
        if (sc)
            return sc;

        // recheck data object
        if ( IS_SPECIAL_DATAOBJECT ( spDataObject.GetInterfacePtr() ) )
        {
            spDataObject.Detach();
            return sc = E_UNEXPECTED;
        }

        sc = ScCheckPointers(pCComponent, pOwnerNode, E_UNEXPECTED);
        if (sc)
            return sc;

        IComponent *pComponent = pCComponent->GetIComponent();
        sc = ScCheckPointers(pComponent, E_UNEXPECTED);
        if (sc)
            return sc;

        // add snapin's data object to transfer object
        sc = pResultObject->ScAddDataObjectForItem( pOwnerNode, bScopePane, lvData,
                                                    pComponent, spDataObject,
                                                    bContainsItems );
        if (sc)
            return sc;

        if (! bContainsItems)
            return sc;
    }
    else // result pane : multi selection
    {
        // get pointer to multiselection
        CMultiSelection *pMultiSel = pViewData->GetMultiSelection();
        sc = ScCheckPointers( pMultiSel, E_UNEXPECTED );
        if (sc)
            return sc;

        sc = pMultiSel->ScGetSnapinDataObjects(pResultObject);
        if (sc)
            return sc;
    }

    // if no items were added, something is wrong
    DWORD dwCount = 0;
    sc = pResultObject->GetCount( &dwCount );
    if (sc)
        return sc;

    if ( dwCount == 0 )
        return sc = E_UNEXPECTED;

    bContainsItems = true;

    // return interface
    *ppMMCDataObject = spResultInterface.Detach();

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::ScAddDataObjectForItem
 *
 * PURPOSE: Adds data object for one item
 *
 * PARAMETERS:
 *    CNode* pNode              [in] - node to add (or one owning the item)
 *    bool bScopePane           [in] - if operation is on scope pane
 *    LPARAM lvData             [in] - if result pane the LVDATA
 *    IComponent *pComponent    [in] - snapins interface
 *    IDataObject *pDataObject  [in] - data object to add
 *    bool& bContainsItems     [out] - Are there any dataobjects added?
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCClipBoardDataObject::ScAddDataObjectForItem( CNode* pNode, bool bScopePane,
                                                    LPARAM lvData, IComponent *pComponent,
                                                    IDataObject *pDataObject ,
                                                    bool& bContainsItems)
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::ScAddDataObjectForScopeNode"));

    // Init out param.
    bContainsItems = false;

    // paramter check
    sc = ScCheckPointers( pNode, pComponent, pDataObject );
    if (sc)
        return sc;

    // get the verbs
    bool bCopyEnabled = false;
    bool bCutEnabled = false;
    sc = ScGetNodeCopyAndCutVerbs( pNode, pDataObject, bScopePane, lvData, &bCopyEnabled, &bCutEnabled);
    if (sc)
        return sc;

    // see it the data matches our criteria
    // (needs to allow something at least)
    if ( ( (m_eOperation == ACTION_COPY) && (bCopyEnabled == false) )
      || ( (m_eOperation == ACTION_CUT) && (bCutEnabled == false) )
      || ( (bCutEnabled == false)  && (bCopyEnabled == false) ) )
        return sc = S_FALSE;

    // add to the list
    sc = ScAddSnapinDataObject( CNodePtrArray(1, pNode), pComponent, pDataObject, bCopyEnabled, bCutEnabled );
    if (sc)
        return sc;

    bContainsItems = true;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetWrapperCF
 *
 * PURPOSE: Helper. registers and returns own clipboard format
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CLIPFORMAT
 *
\***************************************************************************/
CLIPFORMAT CMMCClipBoardDataObject::GetWrapperCF()
{
    static CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
        s_cf = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_MMC_INTERNAL"));

    return s_cf;
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::ScEnsureNotInClipboard
 *
 * PURPOSE: called to remove data from clipbord when comonent is destoyed
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCClipBoardDataObject::ScInvalidate( void )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::ScEnsureNotInClipboard"));

    // not valid anymore
    m_bObjectValid = false;

    // release data objects
    for ( int i = 0; i< m_SelectionObjects.size(); i++)
        m_SelectionObjects[i].spDataObject = NULL;

    // check the clipboard
    sc = ::OleIsCurrentClipboard( this );
    if (sc)
        return sc;

    // it is on clipboard - remove
    if (sc == S_OK)
        OleSetClipboard(NULL);

    return sc;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\colwidth.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       colwidth.h
//
//  Contents:   Classes related to column persistence.
//
//  Classes:    CColumnInfo, CColumnPersistInfo
//              CColumnsDlg.
//
//  History:    14-Oct-98 AnandhaG     Created
//
//--------------------------------------------------------------------

#ifndef COLWIDTH_H
#define COLWIDTH_H
#pragma once

#pragma warning(disable: 4503) // Disable long name limit warnings

#include "columninfo.h"

using namespace std;

class  CColumnPersistInfo;
class  CColumnsDlg;

// Column Persistence Versioning
// Version 1 has
//    "Col index (seen by snapin)" "Width" "Format" in order.
static const INT COLPersistenceVersion = 2;

// We allow the list to grow COLUMNS_MAXLIMIT times more,
// then we do garbage collection.
#define  COLUMNS_MAXLIMIT           0.4


//+-------------------------------------------------------------------
//
//  Class:      CColumnSortInfo
//
//  Purpose:    Columns sort information.
//              The column that is sorted and direction.
//
//  History:    10-27-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
class CColumnSortInfo : public CSerialObject, public CXMLObject
{
public:
    friend class  CColumnPersistInfo;
    friend class  CNode;
    friend class  CColumnsDlg;
    friend struct ColPosCompare;
    friend class  CColumnData;

public:
    CColumnSortInfo () : m_nCol(-1), m_dwSortOptions(0),
                         m_lpUserParam(NULL)
        {}

    CColumnSortInfo (INT nCol, DWORD dwSortOptions)
                : m_nCol(nCol), m_dwSortOptions(dwSortOptions),
                  m_lpUserParam(NULL)
    {
    }

    CColumnSortInfo(const CColumnSortInfo& colInfo)
    {
        m_nCol = colInfo.m_nCol;
        m_dwSortOptions = colInfo.m_dwSortOptions;
        m_lpUserParam = colInfo.m_lpUserParam;
    }

    CColumnSortInfo& operator=(const CColumnSortInfo& colInfo)
    {
        if (this != &colInfo)
        {
            m_nCol = colInfo.m_nCol;
            m_dwSortOptions = colInfo.m_dwSortOptions;
            m_lpUserParam = colInfo.m_lpUserParam;
        }

        return (*this);
    }

    bool operator ==(const CColumnSortInfo &colinfo) const
    {
        return ( (m_nCol      == colinfo.m_nCol)      &&
                 (m_dwSortOptions == colinfo.m_dwSortOptions) &&
                 (m_lpUserParam == colinfo.m_lpUserParam) );
    }

    INT  getColumn() const         { return m_nCol;}
    DWORD getSortOptions() const   { return m_dwSortOptions;}
    ULONG_PTR getUserParam() const { return m_lpUserParam;}

protected:
    INT   m_nCol;                // The index supplied when snapin inserted the column.
                                 // This is not the index viewed by the user.
    DWORD     m_dwSortOptions;   // Sort flags like Ascending/Descending, Sort icon...
    ULONG_PTR m_lpUserParam;     // Snapin supplied user param.

protected:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 2;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/);

protected:
    DEFINE_XML_TYPE(XML_TAG_COLUMN_SORT_INFO);
    virtual void Persist(CPersistor &persistor);
};

//+-------------------------------------------------------------------
//
//  Class:      CColumnSortList
//
//  Purpose:    linked list with CColumnInfo's.
//
//  History:    02-11-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CColumnSortList : public list<CColumnSortInfo>, public CSerialObject
{
public:
    friend class  CColumnSetData;

public:
    CColumnSortList ()
    {
    }

    ~CColumnSortList()
    {
    }

protected:

    void PersistSortList(CPersistor& persistor);

    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/);
};

//+-------------------------------------------------------------------
//
//  Class:      CColumnSetData
//
//  Purpose:    Data for a ColumnSetID. That is the data pertaining to
//              set of columns associated with a node. This data includes
//              column width, order, hidden/visible status. It also
//              includes the column on which we have sorted and the
//              order.
//
//  History:    01-13-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
class CColumnSetData : public CSerialObject, public CXMLObject
{
public:
    friend class  CColumnPersistInfo;
    friend class  CColumnsDlg;

public:
    CColumnSetData ()
    {
        m_colInfoList.clear();
        m_colSortList.clear();

        m_dwRank = -1;
        m_bInvalid = FALSE;
    }

    ~CColumnSetData()
    {
        m_colInfoList.clear();
        m_colSortList.clear();

        m_dwRank = -1;
        m_bInvalid = FALSE;
    }

    CColumnSetData(const CColumnSetData& colSetInfo)
    {
        m_colInfoList  = colSetInfo.m_colInfoList;
        m_colSortList  = colSetInfo.m_colSortList;

        m_dwRank       = colSetInfo.m_dwRank;
        m_bInvalid     = FALSE;
    }

    CColumnSetData& operator=(const CColumnSetData& colSetInfo)
    {
        if (this != &colSetInfo)
        {
            m_colInfoList = colSetInfo.m_colInfoList;
            m_colSortList = colSetInfo.m_colSortList;

            m_dwRank      = colSetInfo.m_dwRank;
            m_bInvalid    = colSetInfo.m_bInvalid;
        }

        return (*this);
    }

    bool operator ==(const CColumnSetData &colinfo) const
    {
        return (false);
    }

    bool operator< (const CColumnSetData& colSetInfo)
    {
        return (m_dwRank < colSetInfo.m_dwRank);
    }

    CColumnInfoList*  get_ColumnInfoList()
    {
        return &m_colInfoList;
    }

    void set_ColumnInfoList(const CColumnInfoList& colInfoList)
    {
        m_colInfoList = colInfoList;
    }

    CColumnSortList*  get_ColumnSortList()
    {
        return &m_colSortList;
    }

    void set_ColumnSortList(CColumnSortList& colSortList)
    {
        m_colSortList = colSortList;
    }

protected:
    // Needed for book keeping.
    DWORD                m_dwRank;            // Usage rank.
    BOOL                 m_bInvalid;          // For garbage collection.

protected:
    // Persisted data.
    CColumnInfoList      m_colInfoList;
    CColumnSortList      m_colSortList;

protected:
    // CSerialObject methods
    // Version 2 had view settings removed. This data should be skipped while reading
    // version 1 files.
    virtual UINT    GetVersion()     {return 2;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/);

protected:
    DEFINE_XML_TYPE(XML_TAG_COLUMN_SET_DATA);
    virtual void Persist(CPersistor &persistor);
};

typedef const BYTE *        LPCBYTE;
typedef std::vector<BYTE>   ByteVector;


//+-------------------------------------------------------------------
//
//  Class:      CColumnSetID
//
//  Purpose:    Identifier for a Column-Set. A a column-set is a set of
//              columns inserted by a snapin. When the user selects a
//              different node in that snapin same or different column-set
///             may be shown by the snapin.     MMC asks snapin to provide an
//              ID (either SColumnSetID or NodeTypeGuid) to uniquely identify
//              each column-set so that it can persist the column data.
//              This enables MMC to use this GUID to load and use the column
//              data across different instances,locales and systems.
//
//  History:    02-08-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
class CColumnSetID : public CXMLObject
{
public:
    friend class  CColumnPersistInfo;

    friend IStream& operator>> (IStream& stm, CColumnSetID& colID);
    friend IStream& operator<< (IStream& stm, const CColumnSetID& colID);

private:
    void CommonConstruct (const SColumnSetID& refColID)
    {
        m_vID.clear();
        m_dwFlags = refColID.dwFlags;
        m_vID.insert (m_vID.begin(), refColID.id, refColID.id + refColID.cBytes);
    }

    void CommonConstruct (const CLSID& clsidNodeType)
    {
        m_dwFlags = 0;
        BYTE* pbByte = (BYTE*)&clsidNodeType;

        if (pbByte != NULL)
        {
            m_vID.clear();
            m_vID.insert (m_vID.begin(), pbByte, pbByte + sizeof(CLSID));
        }
    }

public:
    CColumnSetID() : m_dwFlags(0)
    {
    }

    ~CColumnSetID() {}

    CColumnSetID(LPCBYTE& pbInit)
    {
        // pbInit now points to a SColumnSetID; initialize from it
        const SColumnSetID*  pColID = reinterpret_cast<const SColumnSetID*>(pbInit);
        CommonConstruct (*pColID);

        // bump the input pointer to the next element
        pbInit += sizeof (pColID->cBytes) + pColID->cBytes;
    }

    CColumnSetID(const SColumnSetID& refColID)
    {
        CommonConstruct (refColID);
    }


    CColumnSetID(const CLSID& clsidNodeType)
    {
        CommonConstruct (clsidNodeType);
    }

    CColumnSetID(const CColumnSetID& colID)
    {
        m_dwFlags = colID.m_dwFlags;
        m_vID = colID.m_vID;
    }

    CColumnSetID& operator=(const CColumnSetID& colID)
    {
        if (this != &colID)
        {
            m_dwFlags = colID.m_dwFlags;
            m_vID = colID.m_vID;
        }

        return (*this);
    }

    bool operator ==(const CColumnSetID& colID) const
    {
        return (m_vID == colID.m_vID);
    }

    bool operator <(const CColumnSetID& colID) const
    {
        return (m_vID < colID.m_vID);
    }

    DWORD GetFlags() const   { return m_dwFlags; }
    int  empty ()   const    { return (m_vID.empty()); }

    DEFINE_XML_TYPE(NULL); // not to be persisted as alone element
    virtual void    Persist(CPersistor &persistor);

protected:
    DWORD       m_dwFlags;
    ByteVector  m_vID;
};


//+-------------------------------------------------------------------
//
//  Member:     operator>>
//
//  Synopsis:   Writes CColumnSetID data to stream.
//
//  Arguments:  [stm]   - The input stream.
//              [colID] - CColumnSetID structure.
//
//                          The format is :
//                              DWORD  flags
//                              ByteVector
//
//--------------------------------------------------------------------
inline IStream& operator>> (IStream& stm, CColumnSetID& colID)
{
    return (stm >> colID.m_dwFlags >> colID.m_vID);
}


//+-------------------------------------------------------------------
//
//  Member:     operator<<
//
//  Synopsis:   Reads CColumnSortInfo data from the stream.
//
//  Arguments:  [stm]   - The stream to write to.
//              [colID] - CColumnSetID structure.
//
//                          The format is :
//                              DWORD  flags
//                              ByteVector
//
//--------------------------------------------------------------------
inline IStream& operator<< (IStream& stm, const CColumnSetID& colID)
{
    return (stm << colID.m_dwFlags << colID.m_vID);
}

//+-------------------------------------------------------------------
//
//  Data structures used to persist column information:
//
// Column information is persisted as follows:
// Internally, the following data structure is used. Column information
// is recorded per snapin, per column ID, per view.
//        map               map             map
// CLSID ------> column ID ------> view ID -----> iterator to a list
// containing data.
//
// The data itself is stored in an object of type CColumnSetData.
// This has subobjects to store column width, column sorting, and view
// options.
//
// The list contains CColumnSetData to all the views, all snapins
// and all col-ids.
//
// Persistence: The information is serialized as follows:
//
// 1) Stream version
// 2) Number of snapins
// 3) For each snapin:
//    i)  snapin CLSID
//    ii) number of column IDs
//        For each column ID:
//        i)  column ID
//        ii) Number of views
//            For each view:
//            i)  View ID
//            ii) Column data (CColumnSetData).
//--------------------------------------------------------------------

//*********************************************************************
//
// Note:
//     The alpha compiler is unable to resolve long names and calls
//     wrong version of stl::map::erase (bug# 295465).
//     So we derive dummy classes like I1, V1, C1, S1 to shorten
//     those names.
//
//     To repro the problem define _ALPHA_BUG_IN_MMC and compile mmc
//
// Classes: I1, V1, C1, S1
//
//     For version 2.0 the change was undone. But the names are not
//     long anymore, since classes are derived from maps (not typedef'ed)
//
//*********************************************************************
//*********************************************************************

// A list of all ColumnSet datas.
typedef list<CColumnSetData >                       ColSetDataList;

    typedef ColSetDataList::iterator                    ItColSetDataList;

    // A one to one map from ViewID to iterator to CColumnSetData.
    class ViewToColSetDataMap : public map<int /*nViewID*/, ItColSetDataList>
    {
    };
    typedef ViewToColSetDataMap::value_type             ViewToColSetDataVal;

    // A one to one map from CColumnSetID to ViewToColSetDataMap.
    class ColSetIDToViewTableMap : public map<CColumnSetID, ViewToColSetDataMap>
    {
    };
    typedef ColSetIDToViewTableMap::value_type          ColSetIDToViewTableVal;

    // A one to one map from Snapin GUID to ColSetIDToToViewTableMap (snapins widthsets)
    class SnapinToColSetIDMap : public map<CLSID, ColSetIDToViewTableMap>
    {
    };
    typedef SnapinToColSetIDMap::value_type             SnapinToColSetIDVal;

//+-------------------------------------------------------------------
//
//  Some helper data structures that wont be persisted.
//
//--------------------------------------------------------------------
// A vector of strings to store column names
typedef vector<tstring>                     TStringVector;


//+-------------------------------------------------------------------
//
//  Class:      CColumnPersistInfo
//
//  Purpose:    This class has column persistence information for all
//              views (therefore one per instance of mmc).
//              Knows to load/save the info from streams.
//
//  History:    10-27-1998   AnandhaG   Created
//
//  Data structures used to persist column information:
//      A map from the ViewID to the CColumnSetData class.
//      A multimap from ColumnSet-ID to above map.
//      A map that maps snapin GUID to above map.
//
//--------------------------------------------------------------------
class CColumnPersistInfo : public IPersistStream, public CComObjectRoot, public CXMLObject
{
private:
    BOOL                            m_bInitialized;
    auto_ptr<ColSetDataList>        m_spColSetList;
    auto_ptr<SnapinToColSetIDMap>   m_spSnapinsMap;

    // This is the max number of items specified by user???
    // We go 40% more so that we dont do garbage collection often.
    DWORD                           m_dwMaxItems;

    BOOL                            m_bDirty;

private:
    BOOL ClearAllEntries();

public:
    /*
     * ATL COM map
     */
    BEGIN_COM_MAP (CColumnPersistInfo)
        COM_INTERFACE_ENTRY (IPersistStream)
    END_COM_MAP ()

public:
    CColumnPersistInfo();
    ~CColumnPersistInfo();

    BOOL Init();

    BOOL RetrieveColumnData( const CLSID& refSnapinCLSID, const SColumnSetID& colID,
                             INT nViewID, CColumnSetData& columnSetData);
    BOOL SaveColumnData( const CLSID& refSnapinCLSID, const SColumnSetID& colID,
                         INT nViewID, CColumnSetData& columnSetData);
    VOID DeleteColumnData( const CLSID& refSnapinCLSID, const SColumnSetID& colID,
                           INT nViewID);

    BOOL DeleteColumnDataOfSnapin( const CLSID& refSnapinCLSID);
    BOOL DeleteColumnDataOfView( int nViewID);

    VOID GarbageCollectItems();
    VOID DeleteMarkedItems();

    // IPersistStream methods
    STDMETHOD(IsDirty)(void)
    {
        if (m_bDirty)
            return S_OK;

        return S_FALSE;
    }

    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize)
    {
        return E_NOTIMPL;
    }

    STDMETHOD(GetClassID)(LPCLSID lpClsid)
    {
        lpClsid = NULL;
        return E_NOTIMPL;
    }

    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);

    DEFINE_XML_TYPE(XML_TAG_COLUMN_PERIST_INFO);
    virtual void    Persist(CPersistor &persistor);
};


//+-------------------------------------------------------------------
//
//  Class:      CColumnDlg
//
//  Purpose:    The column modification dialog.
//
//  History:    11-15-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
class CColumnsDlg : public CDialogImpl<CColumnsDlg>
{
    typedef CColumnsDlg                ThisClass;
    typedef CDialogImpl<CColumnsDlg>   BaseClass;

// Constructor/Destrcutor
public:

    CColumnsDlg(CColumnInfoList *pColumnInfoList, TStringVector* pStringVector, CColumnInfoList& defaultColumnInfoList)
            : m_pColumnInfoList(pColumnInfoList), m_pStringVector(pStringVector), m_bDirty(false),
              m_DefaultColumnInfoList(defaultColumnInfoList), m_bUsingDefaultColumnSettings(false)
    {}


    ~CColumnsDlg()
     {}


//MSGMAP
public:
    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER    (WM_INITDIALOG,  OnInitDialog)
        CONTEXT_HELP_HANDLER()
        COMMAND_ID_HANDLER (IDOK,                   OnOK)
        COMMAND_ID_HANDLER (IDCANCEL,               OnCancel)
        COMMAND_ID_HANDLER (IDC_MOVEUP_COLUMN,      OnMoveUp)
        COMMAND_ID_HANDLER (IDC_MOVEDOWN_COLUMN ,   OnMoveDown)
        COMMAND_ID_HANDLER (IDC_ADD_COLUMNS,        OnAdd)
        COMMAND_ID_HANDLER (IDC_REMOVE_COLUMNS,     OnRemove)
        COMMAND_ID_HANDLER (IDC_RESTORE_DEFAULT_COLUMNS, OnRestoreDefaultColumns)
        COMMAND_HANDLER    (IDC_HIDDEN_COLUMNS, LBN_SELCHANGE, OnSelChange);
        COMMAND_HANDLER    (IDC_DISPLAYED_COLUMNS, LBN_SELCHANGE, OnSelChange);
        COMMAND_HANDLER    (IDC_HIDDEN_COLUMNS, LBN_DBLCLK, OnAdd);
        COMMAND_HANDLER    (IDC_DISPLAYED_COLUMNS, LBN_DBLCLK, OnRemove);
    END_MSG_MAP()

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_COLUMNS);

public:
    // Operators
    enum { IDD = IDD_COLUMNS };

// Generated message map functions
protected:
    LRESULT OnInitDialog    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK            (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel        (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnMoveUp        (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnMoveDown      (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnAdd           (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemove        (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRestoreDefaultColumns (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnSelChange     (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnHelp          (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    void    MoveItem        (BOOL bMoveUp);
    void    InitializeLists ();
    void    EnableUIObjects ();
    int     GetColIndex(LPCTSTR lpszColName);
    void    SetListBoxHorizontalScrollbar(WTL::CListBox& listBox);
    void    SetDirty() { m_bDirty = true; m_bUsingDefaultColumnSettings = false;}
    void    SetUsingDefaultColumnSettings() { m_bDirty = true; m_bUsingDefaultColumnSettings = true;}
    bool    EnableControl(HWND hwnd, bool bEnable);

    void    SetListBoxHScrollSize()
    {
        SetListBoxHorizontalScrollbar(m_DisplayedColList);
        SetListBoxHorizontalScrollbar(m_HiddenColList);

    }

private:

    WTL::CListBox           m_HiddenColList;
    WTL::CListBox           m_DisplayedColList;
    WTL::CButton            m_btnAdd;
    WTL::CButton            m_btnRemove;
    WTL::CButton            m_btnRestoreDefaultColumns;
    WTL::CButton            m_btnMoveUp;
    WTL::CButton            m_btnMoveDown;

    CColumnInfoList*        m_pColumnInfoList;
    TStringVector*          m_pStringVector;
    CColumnInfoList&        m_DefaultColumnInfoList;
    bool                    m_bDirty;
    bool                    m_bUsingDefaultColumnSettings;
};

#endif /* COLWIDTH_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\containr.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       Containr.h
//
//  Contents:   declarations of map and pair container classes
//
//  Classes:
//
//  Functions:
//
//  History:    10/8/98   VivekJ   Created
//
//____________________________________________________________________________




//#define MAPDBG
#pragma warning(disable : 4786)
template<typename _T1, typename _T2> class Pair
{
public:
    typedef _T1 First;
    typedef _T2 Second;
    Pair() {}
    Pair(const First& f, const Second& s) : m_First(f), m_Second(s) {}
    Pair(const Pair& p) : m_First(p.m_First), m_Second(p.m_Second) {}
    ~Pair() {}
    Pair& operator=(const Pair& p) { if (this != &p) {m_First = p.m_First; m_Second = p.m_Second; } return *this; }
    //bool operator==(const Pair& p) const { return m_First == p.m_First && m_Second == p.m_Second; }
    //bool operator!=(const Pair& p) const { return !operator==(p); }
    const First& GetFirst() const { return m_First; }
    void SetFirst(const First& f) { m_First = f; };
    const Second& GetSecond() const { return m_Second; }
    void SetSecond(const Second& s) { m_Second = s; };
    First* GetFirstPtr() { return reinterpret_cast<First*>(reinterpret_cast<char*>(this) + offsetof(Pair, m_First)); }
    Second* GetSecondPtr() { return reinterpret_cast<Second*>(reinterpret_cast<char*>(this) + offsetof(Pair, m_Second)); }
    const First* GetFirstPtr() const { return reinterpret_cast<const First*>(reinterpret_cast<const char*>(this) + offsetof(Pair, m_First)); }
    const Second* GetSecondPtr() const { return reinterpret_cast<const Second*>(reinterpret_cast<const char*>(this) + offsetof(Pair, m_Second)); }
private:
    First m_First;
    Second m_Second;
}; // class Pair

template<typename _T, typename _Key> class Map
// This is a temporary class which should be replaced by something that can
// hold smart pointers
{
public:
    typedef _T T;
    typedef _Key Key;

    typedef Pair<T, Key> Element;
    typedef Element* iterator;
    typedef const Element* const_iterator;

    explicit Map(size_t initialSize = 0)
        : m_nSize(0), m_nUsed(0), m_pMap(NULL), m_pNext(NULL)
        #ifdef MAPDBG
        , m_nFinds(0), m_nCompares(0)
        #endif //MAPDBG
    {
        const bool bAllocated = Allocate(initialSize);
        ASSERT(m_nSize == initialSize);
        ASSERT(bAllocated);
    }

    Map(const Map& m)
        : m_nSize(0), m_nUsed(0), m_pMap(NULL), m_pNext(NULL)
        #ifdef MAPDBG
        , m_nFinds(0), m_nCompares(0)
        #endif //MAPDBG
    {
        ASSERT(&m != NULL);
        if (m.m_nUsed == 0)
            return;
        const bool bAllocated = Allocate(m.m_nUsed);
        ASSERT(bAllocated);
        if (!bAllocated)
            return;
        ASSERT(m_nSize == m.m_nUsed);
        ASSERT(m_pMap != NULL);
        m_pNext = UninitializedCopy(m_pMap, m.m_pMap, m_nSize);
        m_nUsed = m_nSize;
    }

    ~Map()
    {
        Destroy();
    }

    Map& operator=(const Map& m)
    {
        ASSERT(&m != NULL);
        if (&m == this)
            return *this;

        Destroy();

        if (m.m_nUsed == 0)
            return *this;

        const bool bAllocated = Allocate(m.m_nUsed);
        ASSERT(bAllocated);
        if (!bAllocated)
            return *this;
        ASSERT(m_nSize == m.m_nUsed);
        ASSERT(m_pMap != NULL);
        m_pNext = UninitializedCopy(m_pMap, m.m_pMap, m_nSize);
        m_nUsed = m_nSize;
        return *this;
    }
    
    const_iterator GetBegin() const
    {
        return m_pMap;
    }

    size_t GetSize() const
    {
        return m_nUsed;
    }

    Element* GetPair(size_t n) const
    {
        if (n >= m_nUsed)
            return NULL;
        else
            return m_pMap + n;
    }

    const_iterator GetEnd() const
    {
        return m_pMap + m_nUsed;
    }

    bool Allocate(size_t nSize)
    {
        ASSERT(m_nSize == 0 || nSize > m_nSize);
        if (nSize <= m_nSize)
            return true;

        Element* pNewMap = reinterpret_cast<Element*>(new char[nSize * sizeof(Element)]);
        ASSERT(pNewMap != NULL);
        if (pNewMap == NULL)
            return false;

        const size_t nUsed = m_nUsed;
        Element* const pCopied = UninitializedCopy(pNewMap, m_pMap, nUsed);
        ASSERT(pCopied != NULL);
        if (pCopied == NULL)
            return false;

        Destroy();
        m_pMap = m_pNext = pNewMap;
        m_nSize = nSize;
        m_nUsed = nUsed;
        return true;
    }

    bool Insert(const T& t, const Key& key)
    {
        ASSERT(&t != NULL);
        ASSERT(&key != NULL);
        Element* const pUnique = FindElement(key, false);
        if (pUnique != NULL)
            return false;
        ASSERT(m_nUsed <= m_nSize);
        if (m_nUsed >= m_nSize)
        {
            const unsigned long nNewSize = m_nSize == 0 ? 1 : m_nSize + (m_nSize + 1) / 2;
            const bool bMoreAllocated = Allocate(nNewSize);
            ASSERT(bMoreAllocated);
            if (!bMoreAllocated)
                return false;
        }
        Element e(t, key);
        Element* const dest = m_pMap + m_nUsed++;
        m_pNext = UninitializedCopy(dest, &e, 1);
        ASSERT(m_pNext != NULL);
        return true;
    }

    bool Remove(const Key& key)
    {
        ASSERT(&key != NULL);
        Element* const e = FindElement(key);
        if (e == NULL)
            return false;
        Element* endOfUsed = m_pMap + m_nUsed--;
        ASSERT(e < endOfUsed);
        ASSERT(e >= m_pMap);
        const size_t numberToCopy = endOfUsed - (e + 1);
        Copy(const_cast<Element*>(e), e+1, numberToCopy);
        (endOfUsed - 1)->~Pair<T, Key>();
        if (m_pNext >= endOfUsed)
            m_pNext = m_pMap;
        return true;
    }
    
    T& operator[](const Key& key) const
    {
        ASSERT(&key != NULL);
        T* const t = Find(key);
        ASSERT(t != NULL);
        return *t;
    }

    T* Find(const Key& key) const
    {
        ASSERT(&key != NULL);
        Element* const e = FindElement(key);
        return e != NULL ? e->GetFirstPtr() : NULL;
    }

    size_t Size() const
    {
        return m_nUsed;
    }

    size_t MaxSize() const
    {
        return m_nSize;
    }

    bool Empty() const
    {
        return m_nUsed > 0;
    }

    void Clear()
    {
        Destroy();
    }

private:
    Element* m_pMap;
    size_t m_nSize;
    size_t m_nUsed;
    mutable Element* m_pNext;
    #ifdef MAPDBG
    mutable unsigned long m_nFinds;
    mutable unsigned long m_nCompares;
    #endif //MAPDBG

    void Destroy()
    {
        if (m_pMap == NULL)
            return;
        Element* const end = m_pMap + m_nUsed;
        Element* i = m_pMap;
        while (i != end)
            (i++)->~Pair<T, Key>();
        delete [] reinterpret_cast<char*>(m_pMap);
        m_pNext = m_pMap = NULL;
        m_nSize = 0;
        m_nUsed = 0;
    }

    Element* FindElement(const Key& key, bool bIncludeInStats = true) const
    {
        ASSERT(&key != NULL);
        #ifdef MAPDBG
        if (bIncludeInStats)
            ++m_nFinds;
        #endif //MAPDBG
        Element* const pNext = m_pNext;
        Element* const end = m_pMap + m_nUsed;
        ASSERT(pNext <= end);
        while (m_pNext != end)
        {
            if (m_pNext->GetSecond() == key)
            {
                #ifdef MAPDBG
                if (bIncludeInStats)
                    TotalStats(m_pNext - pNext);
                #endif //MAPDBG
                return m_pNext++;
            }
            ++m_pNext;
        }
        m_pNext = m_pMap;
        ASSERT(m_pNext != NULL || pNext == NULL);
        ASSERT(m_pNext <= pNext);
        while (m_pNext != pNext)
        {
            if (m_pNext->GetSecond() == key)
            {
                #ifdef MAPDBG
                if (bIncludeInStats)
                    TotalStats((m_pNext - m_pMap) + (end - pNext));
                #endif //MAPDBG
                return m_pNext++;
            }
            ++m_pNext;
        }
        #ifdef MAPDBG
        if (bIncludeInStats)
            TotalStats(m_nUsed);
        #endif //MAPDBG
        return NULL;
    }

    #ifdef MAPDBG
    void TotalStats(unsigned long nComparesPerformed) const
    {
        m_nCompares += nComparesPerformed;
        double average = double(m_nCompares) / double(m_nFinds);
        double const successRatio = nComparesPerformed == 0 ? 100.0 :
            (1.0 - (double(nComparesPerformed) / double(m_nUsed))) * 100.0;
        const size_t nOffset = m_pNext - m_pMap;
        TRACE("Map::find(%u), #%u, offset: %u, comps: %u, ave: %u, %%%u\n",
            (unsigned)(this), m_nFinds, nOffset, nComparesPerformed, (unsigned long)(average),
            (unsigned long)(successRatio));
    }
    #endif // MAPDBG

    static Element* UninitializedCopy(Element* dest, Element* src, size_t nCount)
    {
        if (nCount == 0)
            return dest;

        ASSERT(src != NULL || nCount == 0);
        ASSERT(dest != NULL);
        ASSERT(nCount > 0);
        if (nCount <= 0 || dest == NULL || src == NULL)
            return NULL;

        Element* const originalDest = dest;
        Element* const end = dest + nCount;
        while (dest != end)
            new(dest++) Element(*src++);
        return originalDest;
    }

    static void Copy(Element* dest, const Element* src, size_t nCount)
    {
        ASSERT(dest != NULL);
        ASSERT(src != NULL);
        ASSERT(static_cast<SSIZE_T>(nCount) >= 0);
        ASSERT(dest < src);
        if (nCount <= 0 || dest == NULL || src == NULL || dest >= src)
            return;

        Element* const end = dest + nCount;
        while (dest != end)
            *dest++ = *src++;
    }

}; // class Map
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\copypast.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       copypast.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7/21/1997   RaviR   Created
//____________________________________________________________________________
//

#ifndef COPYPAST_H__
#define COPYPAST_H__

/***************************************************************************\
 *
 * CLASS:  CMMCClipBoardDataObject
 *
 * PURPOSE: Implements IMMCClipboardDataObject - interface to data object
 *          added by MMC to the clipboard, or used in DragDrop operation.
 *          Also implements several methods for creating and initializing
 *          the object.
 *
 * USAGE:   Used in Cut, Copy, Paste and DragDrop operations.
 *          Static members are used to create the object, then it is passed to OLE
 *          Accessed via interface from the target ( same process or the external one)
 *
\***************************************************************************/
class CMMCClipBoardDataObject :
public IMMCClipboardDataObject,
public CComObjectRoot
{
public:

    typedef std::vector<CNode *> CNodePtrArray;


    // destructor
    ~CMMCClipBoardDataObject();

BEGIN_COM_MAP(CMMCClipBoardDataObject)
    COM_INTERFACE_ENTRY(IMMCClipboardDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

    // IMMCClipboardDataObject methods
    STDMETHOD(GetSourceProcessId)( DWORD *pdwProcID );
    STDMETHOD(GetAction)         ( DATA_SOURCE_ACTION *peAction );
    STDMETHOD(GetCount)          ( DWORD *pdwCount );
    STDMETHOD(GetDataObject)     ( DWORD dwIndex, IDataObject **ppObject, DWORD *pdwFlags );
    STDMETHOD(RemoveCutItems)    ( DWORD dwIndex, IDataObject *pCutDataObject );

    // IDataObject methods
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc);

    // Not Implemented IDataObject methods
    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut) { return E_NOTIMPL; };
    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease) { return E_NOTIMPL; };
    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,LPADVISESINK pAdvSink, LPDWORD pdwConnection) { return E_NOTIMPL; };
    STDMETHOD(DUnadvise)(DWORD dwConnection) { return E_NOTIMPL; };
    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise) { return E_NOTIMPL; }

public:

    // method to add data objects
    SC ScAddSnapinDataObject( const CNodePtrArray& nodes, IComponent *pComponent, IDataObject *pDataObject,
                              bool bCopyEnabled, bool bCutEnabled );

    static SC ScCreate( DATA_SOURCE_ACTION operation,
                        CNode* pNode, bool bScope,
                        bool bMultiSelect, LPARAM lvData,
                        IMMCClipboardDataObject **ppMMCDataObject ,
                        bool& bContainsItems);

    // to remove going away snapins
    SC ScInvalidate( void );

private: // implementation helpers

    // returns DO of snapin if the object contains only one snapin
    SC ScGetSingleSnapinObject( IDataObject **ppDataObject );

    // method to create the instance
    static SC ScCreateInstance(DATA_SOURCE_ACTION operation,
                               CMMCClipBoardDataObject **ppRawObject,
                               IMMCClipboardDataObject **ppInterface);

    // helper to get node's verb state
    static SC ScGetNodeCopyAndCutVerbs( CNode* pNode, IDataObject *pDataObject,
                                      bool bScopePane, LPARAM lvData,
                                      bool *pbCopyEnabled, bool *pbCutEnabled );

    // method to add data objects for one item
    SC ScAddDataObjectForItem( CNode* pNode, bool bScopePane, LPARAM lvData,
                               IComponent *pComponent, IDataObject *pDataObject,
                               bool& bDataObjectAdded );

    CLIPFORMAT GetWrapperCF();

private: // data
    DATA_SOURCE_ACTION  m_eOperation;

    struct ObjectEntry
    {
        IDataObjectPtr  spDataObject;    // data
        IComponentPtr   spComponent;     // for Notification
        DWORD           dwSnapinOptions; // copy/cut allowed
    };

    std::vector<ObjectEntry> m_SelectionObjects;
    bool                     m_bObjectValid; // valid to access any icluded data objects
};


#endif // COPYPAST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\ctrlbar.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctrlbar.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//____________________________________________________________________________
//


#include "stdafx.h"
#include "menubtn.h"
#include "viewdata.h"
#include "amcmsgid.h"
#include "regutil.h"

#include "commctrl.h"
#include "multisel.h"
#include "rsltitem.h"
#include "conview.h"
#include "util.h"
#include "nodemgrdebug.h"

#ifdef _DEBUG
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Snapin name needed for debug information.
inline void Debug_SetControlbarSnapinName(const CLSID& clsidSnapin, CControlbar* pControlbar)
{
#ifdef DBG
    tstring tszSnapinName;
    bool bRet = GetSnapinNameFromCLSID(clsidSnapin, tszSnapinName);
    if (bRet)
        pControlbar->SetSnapinName(tszSnapinName.data());
#endif
}


//////////////////////////////////////////////////////////////////////////////
// IControlbar implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CControlbar);

CControlbar::CControlbar()
: m_pCache(NULL)
{
    TRACE(_T("CControlbar::CControlbar()\n"));
    DEBUG_INCREMENT_INSTANCE_COUNTER(CControlbar);
    m_pMenuButton=NULL;
    m_ToolbarsList.clear();

#ifdef DBG
    dbg_cRef = 0;
#endif
}

CControlbar::~CControlbar()
{
    DECLARE_SC(sc, _T("CControlbar::~CControlbar"));
    DEBUG_DECREMENT_INSTANCE_COUNTER(CControlbar);

    // Remove the toolbars & menubuttons references.
    sc = ScCleanup();
    // sc dtor will trace error if there is one.

    // release reference prior to m_ToolbarsList destruction
    // The destructor of CToolbar will try to remove itself from the list!
    m_spExtendControlbar = NULL;
}

//+-------------------------------------------------------------------
//
//  Member:     Create
//
//  Synopsis:   Create a toolbar or menubutton object
//
//  Arguments:
//              [nType]              - Type of object to be created (Toolbar or Menubutton).
//              [pExtendControlbar]  -  IExtendControlbar associated with this IControlbar.
//              [ppUnknown]          - IUnknown* of the object created.
//
//  Returns:    HR
//
//--------------------------------------------------------------------
STDMETHODIMP CControlbar::Create(MMC_CONTROL_TYPE nType,
                                 LPEXTENDCONTROLBAR pExtendControlbar,
                                 LPUNKNOWN* ppUnknown)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IControlbar::Create"));

    if (ppUnknown == NULL || pExtendControlbar == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Arguments"), sc);
        return sc.ToHr();
    }

    *ppUnknown = NULL;

    switch (nType)
    {
    case TOOLBAR:
        sc = ScCreateToolbar(pExtendControlbar, ppUnknown);
        break;

    case MENUBUTTON:
        sc = ScCreateMenuButton(pExtendControlbar, ppUnknown);
        break;
    default:
        sc = E_NOTIMPL;
        break;
    }
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


HRESULT CControlbar::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    ASSERT(m_spExtendControlbar != NULL);
    if (m_spExtendControlbar == NULL)
        return E_FAIL;

    HRESULT hr;

	// Deactivate if theming (fusion or V6 common-control) context before calling snapins.
	ULONG_PTR ulpCookie;
	if (! MmcDownlevelActivateActCtx(NULL, &ulpCookie)) 
		return E_FAIL;

    __try
    {
        hr = m_spExtendControlbar->ControlbarNotify(event, arg, param);
		MmcDownlevelDeactivateActCtx(0, ulpCookie);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_FAIL;
        TraceSnapinException(m_clsidSnapin, TEXT("IExtendControlbar::ControlbarNotify"), event);
		MmcDownlevelDeactivateActCtx(0, ulpCookie);
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     Attach
//
//  Synopsis:   Attach given toolbar or menubutton object
//
//  Arguments:
//              [nType]      -  Toolbar or Menubutton.
//              [lpUnknown]  -  IUnknown* of the object to be attached.
//
//  Returns:    HR
//
//--------------------------------------------------------------------
STDMETHODIMP CControlbar::Attach(MMC_CONTROL_TYPE nType, LPUNKNOWN lpUnknown)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IControlbar::Attach"));

    if (lpUnknown == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Arguments"), sc);
        return sc.ToHr();
    }

    switch (nType)
    {
    case TOOLBAR:
        sc = ScAttachToolbar(lpUnknown);
        break;
    case MENUBUTTON:
        sc = ScAttachMenuButtons(lpUnknown);
        break;
    case COMBOBOXBAR:
        sc = E_NOTIMPL;
        break;
    }
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Detach given toolbar or menubutton object
//
//  Arguments:  [lpUnknown]  -  IUnknown* of the object to be detached
//
//  Returns:    HR
//
//--------------------------------------------------------------------
STDMETHODIMP CControlbar::Detach(LPUNKNOWN lpUnknown)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IControlbar::Detach"));

    if (lpUnknown == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Arguments"), sc);
        return sc.ToHr();
    }

    // Is it a toolbar
    IToolbarPtr spToolbar = lpUnknown;
    if (spToolbar != NULL)
    {
        sc = ScDetachToolbar(spToolbar);
        return sc.ToHr();
    }

    // Is it a menu button
    IMenuButtonPtr spMenuButton = lpUnknown;
    if (spMenuButton != NULL)
    {
        sc = ScDetachMenuButton(spMenuButton);
        return sc.ToHr();
    }


    // The passed lpUnknown is neither toolbar nor menubutton.
    // The Snapin has passed invalid object.
    sc = E_INVALIDARG;
    TraceSnapinError(_T("lpUnknown passed is neither toolbar nor menubutton"), sc);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     ScDetachToolbar
//
//  Synopsis:   Detach given toolbar object
//
//  Arguments:  [lpToolbar]  -  IToolbar* of the object to be detached
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScDetachToolbar(LPTOOLBAR lpToolbar)
{
    DECLARE_SC(sc, _T("CControlbar::SCDetachToolbar"));

    if (NULL == lpToolbar)
        return (sc = E_UNEXPECTED);

    // Get the CToolbar object.
    CToolbar* pToolbar = dynamic_cast<CToolbar*>(lpToolbar);
    if (NULL == pToolbar)
        return (sc = E_UNEXPECTED);

    // Get the CMMCToolbarIntf interface.
    CMMCToolbarIntf* pToolbarIntf = pToolbar->GetMMCToolbarIntf();
    if (NULL == pToolbarIntf)
        return (sc = E_UNEXPECTED);

    // Detach the toolbar from UI.
    sc = pToolbarIntf->ScDetach(pToolbar);
    if (sc)
        return sc;

    // Remove the CControlbar reference.
    pToolbar->SetControlbar(NULL);

    // Remove the reference to the toolbar.
    m_ToolbarsList.remove(pToolbar);

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScDetachMenuButton
//
//  Synopsis:   Detach given toolbar or menubutton object
//
//  Arguments:  [lpUnknown]  -  IUnknown* of the object to be detached
//
//  Returns:    HR
//
//--------------------------------------------------------------------
SC CControlbar::ScDetachMenuButton(LPMENUBUTTON lpMenuButton)
{
    DECLARE_SC(sc, _T("CControlbar::ScDetachMenuButton"));

    if (NULL == lpMenuButton)
        return (sc = E_UNEXPECTED);

    CMenuButton* pMenuButton = dynamic_cast<CMenuButton*>(lpMenuButton);
    if (NULL == pMenuButton)
        return (sc = E_UNEXPECTED);

    sc = pMenuButton->ScDetach();
    if (sc)
        return sc;

    // If this is same as the cached menubutton object
    // then remove the (cached) ref.
    if (m_pMenuButton == pMenuButton)
        m_pMenuButton = NULL;
    else
    {
        // The IControlbar implementation is supposed to
        // have only one CMenuButton obj. How come it is
        // not same as one we have cached.
        sc = E_UNEXPECTED;
    }

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScCreateToolbar
//
//  Synopsis:   Create a toolbar for the given snapin (IExtendControlbar).
//
//  Arguments:  [pExtendControlbar]  -  IExtendControlbar of the snapin.
//              [ppUnknown]          -  IUnknown* (IToolbar) of created toolbar.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScCreateToolbar(LPEXTENDCONTROLBAR pExtendControlbar,
                                LPUNKNOWN* ppUnknown)
{
    DECLARE_SC(sc, _T("CControlbar::ScCreateToolbar"));

    if ( (NULL == pExtendControlbar) ||
         (NULL == ppUnknown) )
        return (sc = E_INVALIDARG);

    ASSERT(m_spExtendControlbar == NULL ||
           m_spExtendControlbar == pExtendControlbar);

    // Create the new CToolbar object.
    CComObject<CToolbar>* pToolbar = NULL;
    sc = CComObject<CToolbar>::CreateInstance(&pToolbar);
    if (sc)
        return sc;

    if (NULL == pToolbar)
        return (sc = E_FAIL);

    sc = pToolbar->QueryInterface(IID_IToolbar,
                                  reinterpret_cast<void**>(ppUnknown));
    if (sc)
        return sc;

    CMMCToolbarIntf* pToolbarIntf = NULL;

    // Get the toolbars mgr.
    CAMCViewToolbarsMgr* pAMCViewToolbarsMgr = GetAMCViewToolbarsMgr();
    if (NULL == pAMCViewToolbarsMgr)
    {
        sc = E_UNEXPECTED;
        goto ToolbarUICreateError;
    }

    // Ask it to create the toolbar UI.
    sc = pAMCViewToolbarsMgr->ScCreateToolBar(&pToolbarIntf);
    if (sc)
        goto ToolbarUICreateError;

    // Let the IToolbar imp be aware of toolbar UI interface.
    pToolbar->SetMMCToolbarIntf(pToolbarIntf);

Cleanup:
    return(sc);

ToolbarUICreateError:
    // Destroy the CToolbar object created.
    if (*ppUnknown)
        (*ppUnknown)->Release();

    *ppUnknown = NULL;
    goto Cleanup;
}


//+-------------------------------------------------------------------
//
//  Member:     ScCreateMenuButton
//
//  Synopsis:   Create a menu button object.
//
//  Arguments:  [pExtendControlbar]  - IExtendControlbar of the snapin
//                                     that is creating MenuButton object.
//              [ppUnknown]          - IUnknown if MenuButton object.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScCreateMenuButton(LPEXTENDCONTROLBAR pExtendControlbar,
                                   LPUNKNOWN* ppUnknown)
{
    DECLARE_SC(sc, _T("CControlbar::ScCreateMenuButton"));

    if ( (NULL == pExtendControlbar) ||
         (NULL == ppUnknown) )
        return (sc = E_INVALIDARG);

    ASSERT(m_spExtendControlbar == NULL ||
           m_spExtendControlbar == pExtendControlbar);

    // Create the new IMenuButton object
    CComObject<CMenuButton>* pMenuButton;
    sc = CComObject<CMenuButton>::CreateInstance(&pMenuButton);
    if (sc)
        return sc;

    if (NULL == pMenuButton)
        return (sc = E_FAIL);

    sc = pMenuButton->QueryInterface(IID_IMenuButton,
                                     reinterpret_cast<void**>(ppUnknown));

    if (sc)
        return sc;

    pMenuButton->SetControlbar(this);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScNotifySnapinOfToolBtnClick
//
//  Synopsis:   Notify the snapin about a tool button is click.
//
//  Arguments:  [hNode]             - Node that owns result pane.
//              [bScopePane]        - Scope or Result.
//              [lResultItemCookie] - If Result pane is selected the item param.
//              [nID]               - Command ID of the tool button clicked.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScNotifySnapinOfToolBtnClick(HNODE hNode, bool bScopePane,
                                             LPARAM lResultItemCookie,
                                             UINT nID)
{
    DECLARE_SC(sc, _T("CControlbar::ScNotifySnapinOfToolBtnClick"));

    LPDATAOBJECT pDataObject = NULL;
    CNode* pNode = CNode::FromHandle(hNode);
    if (NULL == pNode)
        return (sc = E_UNEXPECTED);

    bool bScopeItem = bScopePane;
    // Get the data object of the currently selected item.
    sc = pNode->ScGetDataObject(bScopePane, lResultItemCookie, bScopeItem, &pDataObject);
    if (sc)
        return sc;

    ASSERT(m_spExtendControlbar != NULL);

    // Notify the snapin
    sc = ControlbarNotify(MMCN_BTN_CLICK, reinterpret_cast<LPARAM>(pDataObject),
                          static_cast<LPARAM>(nID));

    // Release the dataobject if it is not special dataobject.
    RELEASE_DATAOBJECT(pDataObject);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScNotifySnapinOfMenuBtnClick
//
//  Synopsis:   Notify the snapin about a menu button is click.
//
//  Arguments:  [hNode]             - Node that owns result pane.
//              [bScopePane]        - Scope or Result.
//              [lResultItemCookie] - If Result pane is selected the item param.
//              [lpmenuButtonData]  - MENUBUTTONDATA
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScNotifySnapinOfMenuBtnClick(HNODE hNode, bool bScopePane,
                                             LPARAM lResultItemCookie,
                                             LPMENUBUTTONDATA lpmenuButtonData)
{
    DECLARE_SC(sc, _T("CControlbar::ScNotifySnapinOfMenuBtnClick"));

    LPDATAOBJECT pDataObject = NULL;
    CNode* pNode = CNode::FromHandle(hNode);
    if (NULL == pNode)
        return (sc = E_UNEXPECTED);

    bool bScopeItem = bScopePane;
    // Get the data object of the currently selected item.
    sc = pNode->ScGetDataObject(bScopePane, lResultItemCookie, bScopeItem, &pDataObject);
    if (sc)
        return sc;

    ASSERT(m_spExtendControlbar != NULL);

    // Notify the snapin
    sc = ControlbarNotify(MMCN_MENU_BTNCLICK, reinterpret_cast<LPARAM>(pDataObject),
                          reinterpret_cast<LPARAM>(lpmenuButtonData));

    // Release the dataobject if it is not special dataobject.
    RELEASE_DATAOBJECT(pDataObject);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScAttachToolbar
//
//  Synopsis:   Attach given toolbar object
//
//  Arguments:  [lpUnknown]  -  IUnknown* of the object to be attached
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScAttachToolbar(LPUNKNOWN lpUnknown)
{
    DECLARE_SC(sc, _T("CControlbar::ScAttachToolbar"));

    ASSERT(NULL != lpUnknown);

    IToolbarPtr spToolbar = lpUnknown;
    if (NULL == spToolbar)
        return (sc = E_UNEXPECTED);

    // Get the toolbar object (IToolbar implementation).
    CToolbar* pToolbarC = dynamic_cast<CToolbar*>(spToolbar.GetInterfacePtr());
    if (NULL == pToolbarC)
        return (sc = E_UNEXPECTED);

    // Get the toolbar UI interface.
    CMMCToolbarIntf* pToolbarIntf = pToolbarC->GetMMCToolbarIntf();
    if (NULL == pToolbarIntf)
        return (sc = E_UNEXPECTED);

    // Attach the toolbar.
    sc = pToolbarIntf->ScAttach(pToolbarC);
    if (sc)
        return sc;

    // Make the CToolbar aware of this IControlbar.
    pToolbarC->SetControlbar(this);

    // Add this CToolbar to our list of toolbars.
    ToolbarsList::iterator itToolbar = std::find(m_ToolbarsList.begin(), m_ToolbarsList.end(), pToolbarC);
    if (m_ToolbarsList.end() == itToolbar)
    {
        m_ToolbarsList.push_back(pToolbarC);
    }

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScAttachMenuButtons
//
//  Synopsis:   Attach a menu button object.
//
//  Arguments:  [lpUnknown]  - IUnknown if MenuButton object.
//
//  Returns:    HRESULT
//
//  Note:  Only one CMenuButton object per Controlbar/snapin.
//         Snapins can create many menu buttons using a
//         single CMenuButton object.
//--------------------------------------------------------------------
SC CControlbar::ScAttachMenuButtons(LPUNKNOWN lpUnknown)
{
    DECLARE_SC(sc, _T("CControlbar::ScAttachMenuButtons"));

    ASSERT(NULL != lpUnknown);

    CMenuButton* pMenuButton = dynamic_cast<CMenuButton*>(lpUnknown);
    if (pMenuButton == NULL)
        return (sc = E_INVALIDARG);

    if (m_pMenuButton == pMenuButton)
    {
        // Already attached.
        sc = S_FALSE;
        TraceNodeMgrLegacy(_T("The menubutton is already attached"), sc);
        return sc;
    }
    else if (m_pMenuButton != NULL)
    {
        // There is already a CMenuButton object attached by this
        // Controlbar (Snapin). Detach that before attaching this
        // CMenuButton Object (See the note above).
        sc = m_pMenuButton->ScDetach();
        if (sc)
            return sc;
    }

    // Cache the ref to CMenuButton object.
    // Used when selection moves away from the snapin.
    // MMC has to remove the menubutton put by this snapin.
    m_pMenuButton = pMenuButton;

    if (pMenuButton->GetControlbar() != this)
        pMenuButton->SetControlbar(this);

    sc = pMenuButton->ScAttach();
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScCleanup
//
//  Synopsis:   Remove all the toolbars and menu buttons owned
//              by this controlbar.
//
//  Arguments:  None
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScCleanup()
{
    DECLARE_SC(sc, _T("CControlbar::ScCleanup"));

    ASSERT(m_spExtendControlbar != NULL);
    if (m_spExtendControlbar != NULL)
        m_spExtendControlbar->SetControlbar(NULL);

    sc = ScDetachToolbars();
    if (sc)
        return sc;

    // If there is a menu button, detach (remove it
    // from the UI).
    if (m_pMenuButton)
    {
        sc = m_pMenuButton->ScDetach();
        m_pMenuButton = NULL;
    }

    return sc;
}



//+-------------------------------------------------------------------
//
//  Member:     ScDetachToolbars
//
//  Synopsis:   Detach all the toolbars.
//
//  Arguments:  None.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScDetachToolbars()
{
    DECLARE_SC(sc, _T("CControlbar::ScDetachToolbars"));

    ToolbarsList::iterator itToolbar = m_ToolbarsList.begin();
    while (itToolbar != m_ToolbarsList.end())
    {
        CToolbar* pToolbar = (*itToolbar);
        if (NULL == pToolbar)
            return (sc = E_UNEXPECTED);

        CMMCToolbarIntf* pToolbarIntf = pToolbar->GetMMCToolbarIntf();
        if (NULL == pToolbarIntf)
            return (sc = E_UNEXPECTED);

        // Detach the toolbar UI.
        sc = pToolbarIntf->ScDetach(pToolbar);
        if (sc)
            return sc;

        // Detach the controlbar from toolbar.
        pToolbar->SetControlbar(NULL);

        // Remove the toolbar reference from the list.
        itToolbar = m_ToolbarsList.erase(itToolbar);
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScShowToolbars
//
//  Synopsis:   Show/Hide all the toolbars.
//
//  Arguments:  [bool] - Show or Hide.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScShowToolbars(bool bShow)
{
    DECLARE_SC(sc, _T("CControlbar::ScShowToolbars"));

    ToolbarsList::iterator itToolbar = m_ToolbarsList.begin();
    for (; itToolbar != m_ToolbarsList.end(); ++itToolbar)
    {
        CToolbar* pToolbar = (*itToolbar);
        if (NULL == pToolbar)
            return (sc = E_UNEXPECTED);

        CMMCToolbarIntf* pToolbarIntf = pToolbar->GetMMCToolbarIntf();
        if (NULL == pToolbarIntf)
            return (sc = E_UNEXPECTED);

        sc = pToolbarIntf->ScShow(pToolbar, bShow);
        if (sc)
            return sc;
    }

    return sc;
}


CViewData* CControlbar::GetViewData()
{
    ASSERT(m_pCache != NULL);
    return m_pCache->GetViewData();
}

///////////////////////////////////////////////////////////////////////////
//
// CSelData implementation
//

DEBUG_DECLARE_INSTANCE_COUNTER(CSelData);

//+-------------------------------------------------------------------
//
//  Member:     ScReset
//
//  Synopsis:   Init all the data members.
//
//  Arguments:  None
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CSelData::ScReset()
{
    DECLARE_SC(sc, _T("CSelData::ScReset"));

    if (m_pCtrlbarPrimary != NULL)
    {
        sc = ScDestroyPrimaryCtrlbar();
        if (sc)
            return sc;
    }

    sc = ScDestroyExtensionCtrlbars();
    if (sc)
        return sc;

    m_bScopeSel = false;
    m_bSelect = false;
    m_pNodeScope = NULL;
    m_pMS = NULL;
    m_pCtrlbarPrimary = NULL;
    m_lCookie = -1;
    m_pCompPrimary = NULL;
    m_spDataObject = NULL;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScShowToolbars
//
//  Synopsis:   Show/Hide primary & extension toolbars.
//
//  Arguments:  [bool] - Show/Hide.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CSelData::ScShowToolbars(bool bShow)
{
    DECLARE_SC(sc, _T("CSelData::ScShowToolbars"));

    if (m_pCtrlbarPrimary != NULL)
    {
        sc = m_pCtrlbarPrimary->ScShowToolbars(bShow);

        if (sc)
            return sc;
    }

    POSITION pos =  m_listExtCBs.GetHeadPosition();
    bool bReturn = true;
    while (pos != NULL)
    {
        CControlbar* pControlbar =  m_listExtCBs.GetNext(pos);
        if (pControlbar)
        {
            sc = pControlbar->ScShowToolbars(bShow);
            if (sc)
                return sc;
        }
    }

    return sc;
}

CControlbar* CSelData::GetControlbar(const CLSID& clsidSnapin)
{
    POSITION pos = m_listExtCBs.GetHeadPosition();
    while (pos)
    {
        CControlbar* pControlbar = m_listExtCBs.GetNext(pos);
        if (pControlbar && pControlbar->IsSameSnapin(clsidSnapin) == TRUE)
            return pControlbar;
    }

    return NULL;
}


//+-------------------------------------------------------------------
//
//  Member:     ScDestroyPrimaryCtrlbar
//
//  Synopsis:   Ask primary controlbar to release its toolbar/menubutton
//              ref and cleanup our reference to the controlbar.
//
//  Arguments:  None
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CSelData::ScDestroyPrimaryCtrlbar()
{
    DECLARE_SC(sc, _T("CSelData::ScDestroyPrimaryCtrlbar"));

    if (NULL == m_pCtrlbarPrimary)
        return (sc = E_UNEXPECTED);

    sc = m_pCtrlbarPrimary->ScCleanup();
    if (sc)
        return sc;

    /*
     * In CreateControlbar we had a ref on IControlbar
     * (detaching smart ptr). Let us now undo that ref.
     */
    m_pCtrlbarPrimary->Release();
    m_pCtrlbarPrimary = NULL;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScDestroyExtensionCtrlbars
//
//  Synopsis:   Ask extension controlbars to release their toolbar/menubutton
//              ref and cleanup our reference to the controlbars.
//
//  Arguments:  None
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CSelData::ScDestroyExtensionCtrlbars()
{
    DECLARE_SC(sc, _T("CSelData::ScDestroyExtensionCtrlbars"));

    POSITION pos =  m_listExtCBs.GetHeadPosition();
    while (pos != NULL)
    {
        CControlbar* pControlbar =  m_listExtCBs.GetNext(pos);
        if (pControlbar)
        {
            sc = pControlbar->ScCleanup();
            if (sc)
                return sc;

            /*
             * In CreateControlbar we had a ref on IControlbar
             * (detaching smart ptr). Let us now undo that ref.
             */
            pControlbar->Release();
        }
    }

    m_listExtCBs.RemoveAll();

    return sc;
}


///////////////////////////////////////////////////////////////////////////
//
// CControlbarsCache implementation
//

DEBUG_DECLARE_INSTANCE_COUNTER(CControlbarsCache);


void CControlbarsCache::SetViewData(CViewData* pViewData)
{
    ASSERT(pViewData != 0);
    m_pViewData = pViewData;
}

CViewData* CControlbarsCache::GetViewData()
{
    ASSERT(m_pViewData != NULL);
    return m_pViewData;
}


CControlbar* CControlbarsCache::CreateControlbar(IExtendControlbarPtr& spECB,
                                                 const CLSID& clsidSnapin)
{
    DECLARE_SC(sc, _T("CControlbarsCache::CreateControlbar"));

    CComObject<CControlbar>* pControlbar;
    sc = CComObject<CControlbar>::CreateInstance(&pControlbar);
    if (sc)
        return NULL;

    IControlbarPtr spControlbar = pControlbar;
    if (NULL == spControlbar)
    {
        ASSERT(NULL != pControlbar); // QI fails but object is created how?
        sc = E_UNEXPECTED;
        return NULL;
    }

    pControlbar->SetCache(this);
    pControlbar->SetExtendControlbar(spECB, clsidSnapin);

    sc = spECB->SetControlbar(spControlbar);
    if (sc)
        return NULL; // spControlbar smart ptr (object will be destroyed).

    // Snapin must return S_OK to be valid
    if (S_OK == sc.ToHr())
    {
        // Detach, thus hold a ref count on the Controlbar object
        // CSelData holds this reference & releases the ref in
        // ScDestroyPrimaryCtrlbar() or ScDestroyExtensionCtrlbars().
        spControlbar.Detach();

        // This is for debug info.
        Debug_SetControlbarSnapinName(clsidSnapin, pControlbar);

        return pControlbar;
    }

    return NULL;
}


HRESULT
CControlbarsCache::OnMultiSelect(
                                CNode* pNodeScope,
                                CMultiSelection* pMultiSelection,
                                IDataObject* pDOMultiSel,
                                BOOL bSelect)
{
    ASSERT(pNodeScope != NULL);
    ASSERT(pMultiSelection != NULL);
    ASSERT(pDOMultiSel != NULL);
    if (pNodeScope == NULL || pMultiSelection == NULL || pDOMultiSel == NULL)
        return E_FAIL;

    CSelData selData(false, (bool)bSelect);
    selData.m_pMS = pMultiSelection;

    if (selData == m_SelData)
        return S_FALSE;

    if (!bSelect)
        return _OnDeSelect(selData);

    selData.m_pCompPrimary = pMultiSelection->GetPrimarySnapinComponent();

    CList<GUID, GUID&> extnSnapins;
    HRESULT hr = pMultiSelection->GetExtensionSnapins(g_szToolbar, extnSnapins);
    CHECK_HRESULT(hr);

    selData.m_spDataObject.Attach(pDOMultiSel, TRUE);
    return _ProcessSelection(selData, extnSnapins);
}

HRESULT
CControlbarsCache::OnResultSelChange(
                                    CNode* pNode,
                                    MMC_COOKIE cookie,
                                    BOOL bSelected)
{
    DECLARE_SC(sc, TEXT("CControlbarsCache::OnResultSelChange"));

    sc = ScCheckPointers (pNode);
    if (sc)
        return (sc.ToHr());

    CSelData selData(false, (bool)bSelected);
    selData.m_lCookie = cookie;

    if (selData == m_SelData)
        return (sc = S_FALSE).ToHr();

    if (!bSelected)
    {
        sc = _OnDeSelect(selData);
        return sc.ToHr();
    }

    IDataObjectPtr spDataObject = NULL;
    CComponent* pCCResultItem = NULL;
    CList<CLSID, CLSID&> extnSnapins;

    BOOL bListPadItem = GetViewData()->HasListPad() && !IS_SPECIAL_LVDATA(cookie);

    if (GetViewData()->IsVirtualList())
    {
        pCCResultItem = pNode->GetPrimaryComponent();
        sc = ScCheckPointers(pCCResultItem, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        sc = pCCResultItem->QueryDataObject(cookie, CCT_RESULT, &spDataObject);
        if (sc)
            return sc.ToHr();
    }
    else if ( (GetViewData()->HasOCX()) || (GetViewData()->HasWebBrowser() && !bListPadItem) )
    {
        selData.m_pCompPrimary = pNode->GetPrimaryComponent();
        sc = _ProcessSelection(selData, extnSnapins);
        return sc.ToHr();
    }
    else
    {
        CResultItem* pri = CResultItem::FromHandle(cookie);
        sc = ScCheckPointers(pri, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (pri->IsScopeItem())
        {
            // Get the data object from IComponentData
            pNode = CNode::FromResultItem (pri);
            sc = ScCheckPointers(pNode, E_UNEXPECTED);
            if (sc)
                return sc.ToHr();

            if (pNode->IsInitialized() == FALSE)
            {
                sc = pNode->InitComponents();
                if (sc)
                    return sc.ToHr();
            }

            pCCResultItem = pNode->GetPrimaryComponent();
            sc = pNode->QueryDataObject(CCT_SCOPE, &spDataObject);
            if (sc)
                return sc.ToHr();
        }
        else // Must be a leaf item inserted by a snapin
        {
            pCCResultItem = pNode->GetComponent(pri->GetOwnerID());
            sc = ScCheckPointers(pCCResultItem, E_UNEXPECTED);
            if (sc)
                return sc.ToHr();

            sc = pCCResultItem->QueryDataObject(pri->GetSnapinData(), CCT_RESULT,
                                                &spDataObject);
            if (sc)
                return sc.ToHr();
        }
    }

    // Create extension snapin list
    if (spDataObject != NULL)
    {
        ASSERT(pCCResultItem != NULL);

        GUID guidObjType;
        sc = ::ExtractObjectTypeGUID(spDataObject, &guidObjType);
        if (sc)
            return sc.ToHr();

        CSnapIn* pSnapIn = pNode->GetPrimarySnapIn();

        CMTNode* pmtNode = pNode->GetMTNode();
        sc = ScCheckPointers(pmtNode, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CArray<GUID, GUID&> DynExtens;
        ExtractDynExtensions(spDataObject, DynExtens);

        CExtensionsIterator it;
        sc = it.ScInitialize(pSnapIn, guidObjType, g_szToolbar, DynExtens.GetData(), DynExtens.GetSize());
        if (!sc.IsError())
        {
            for (; !it.IsEnd(); it.Advance())
            {
                extnSnapins.AddHead(const_cast<GUID&>(it.GetCLSID()));
            }
        }

        selData.m_pCompPrimary = pCCResultItem;
        selData.m_spDataObject.Attach(spDataObject.Detach());
    }

    // Finally process selection
    sc = _ProcessSelection(selData, extnSnapins);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

HRESULT CControlbarsCache::OnScopeSelChange(CNode* pNode, BOOL bSelected)
{
    DECLARE_SC(sc, TEXT("CControlbarsCache::OnScopeSelChange"));

    CSelData selData(true, (bool)bSelected);
    selData.m_pNodeScope = pNode;
    if (selData == m_SelData)
        return S_FALSE;

    if (!bSelected)
        return _OnDeSelect(selData);

    HRESULT hr = S_OK;
    IDataObjectPtr spDataObject;
    CComponent* pCCPrimary = NULL;
    CList<CLSID, CLSID&> extnSnapins;

    hr = pNode->QueryDataObject(CCT_SCOPE, &spDataObject);
    if (FAILED(hr))
        return hr;

    pCCPrimary = pNode->GetPrimaryComponent();

    GUID guidObjType;
    hr = ::ExtractObjectTypeGUID(spDataObject, &guidObjType);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    CSnapIn* pSnapIn = pNode->GetPrimarySnapIn();

    CArray<GUID, GUID&> DynExtens;
    ExtractDynExtensions(spDataObject, DynExtens);

    CExtensionsIterator it;
    sc = it.ScInitialize(pSnapIn, guidObjType, g_szToolbar, DynExtens.GetData(), DynExtens.GetSize());
    if (!sc.IsError())
    {
        for (; it.IsEnd() == FALSE; it.Advance())
        {
            extnSnapins.AddHead(const_cast<GUID&>(it.GetCLSID()));
        }
    }

    // Finally process selection
    selData.m_pCompPrimary = pCCPrimary;
    selData.m_spDataObject.Attach(spDataObject.Detach());
    return _ProcessSelection(selData, extnSnapins);
}

HRESULT CControlbarsCache::_OnDeSelect(CSelData& selData)
{
    ASSERT(!selData.IsSelect());
    if (selData.m_bScopeSel != m_SelData.m_bScopeSel)
        return S_FALSE;

    if ( (m_SelData.m_pCtrlbarPrimary != NULL &&
          m_SelData.m_spDataObject == NULL) &&
         (!GetViewData()->HasOCX() ||
          !GetViewData()->HasWebBrowser()) &&
         m_SelData.IsScope())
    {
        return E_UNEXPECTED;
    }

    MMC_NOTIFY_TYPE eNotifyCode = MMCN_SELECT;
    LPARAM lDataObject;

    if (GetViewData()->IsVirtualList())
    {
        eNotifyCode = MMCN_DESELECT_ALL;

        // Must use NULL data object for MMCN_DESELECT_ALL.
        lDataObject = 0;
    }
    else if ((GetViewData()->HasOCX()) && (!m_SelData.IsScope()))
        lDataObject = reinterpret_cast<LPARAM>(DOBJ_CUSTOMOCX);
    else if ((GetViewData()->HasWebBrowser()) && (!m_SelData.IsScope()))
    {
        if (GetViewData()->HasListPad() && m_SelData.m_spDataObject != NULL)
        {
            lDataObject = reinterpret_cast<LPARAM>(
                                                  static_cast<IDataObject*>(m_SelData.m_spDataObject));
        }
        else
        {
            lDataObject = reinterpret_cast<LPARAM>(DOBJ_CUSTOMWEB);
        }
    }
    else
    {
        lDataObject = reinterpret_cast<LPARAM>(
                                              static_cast<IDataObject*>(m_SelData.m_spDataObject));
    }

    WORD wScope = static_cast<WORD>(m_SelData.IsScope());
    LPARAM arg = MAKELONG(wScope, FALSE);


    if (m_SelData.m_pCtrlbarPrimary != NULL)
    {
        m_SelData.m_pCtrlbarPrimary->ControlbarNotify(eNotifyCode, arg,
                                                      lDataObject);
    }

    POSITION pos = m_SelData.m_listExtCBs.GetHeadPosition();
    while (pos)
    {
        CControlbar* pCbar = m_SelData.m_listExtCBs.GetNext(pos);
        pCbar->ControlbarNotify(eNotifyCode, arg, lDataObject);
    }

    m_SelData.m_bSelect = false;
    m_SelData.m_spDataObject = NULL; // Release & set to NULL
    return S_OK;
}

HRESULT
CControlbarsCache::_ProcessSelection(
                                    CSelData& selData,
                                    CList<CLSID, CLSID&>& extnSnapins)
{
    LPARAM lDataObject = reinterpret_cast<LPARAM>(
                                                 static_cast<IDataObject*>(selData.m_spDataObject));

    if (NULL == lDataObject)
    {
        if ( (GetViewData()->HasOCX()) && (!selData.IsScope()) )
            lDataObject = reinterpret_cast<LPARAM>(DOBJ_CUSTOMOCX);
        else if ( (GetViewData()->HasWebBrowser()) && (!selData.IsScope()) )
            lDataObject = reinterpret_cast<LPARAM>(DOBJ_CUSTOMWEB);
    }

    WORD wScope = static_cast<WORD>(selData.IsScope());
    long arg = MAKELONG(wScope, TRUE);

    m_SelData.m_bScopeSel = selData.m_bScopeSel;
    m_SelData.m_bSelect = selData.m_bSelect;
    m_SelData.m_pNodeScope = selData.m_pNodeScope;
    m_SelData.m_lCookie = selData.m_lCookie;
    m_SelData.m_spDataObject.Attach(selData.m_spDataObject.Detach());

    // Handle primary controlbar first
    if (m_SelData.m_pCompPrimary != selData.m_pCompPrimary)
    {
        if (m_SelData.m_pCtrlbarPrimary != NULL)
        {
            // Ask controlbar to destroy its ref & destroy our ref
            // to controlbar.
            m_SelData.ScDestroyPrimaryCtrlbar();
        }

        m_SelData.m_pCompPrimary = selData.m_pCompPrimary;

        if (m_SelData.m_pCompPrimary != NULL &&
            m_SelData.m_pCtrlbarPrimary == NULL)
        {
            IExtendControlbarPtr spECBPrimary =
            m_SelData.m_pCompPrimary->GetIComponent();
            if (spECBPrimary != NULL)
            {
                m_SelData.m_pCtrlbarPrimary =
                CreateControlbar(spECBPrimary,
                                 m_SelData.m_pCompPrimary->GetCLSID());
            }
        }
    }

    if (m_SelData.m_pCtrlbarPrimary != NULL)
    {
        m_SelData.m_pCtrlbarPrimary->ControlbarNotify(MMCN_SELECT, arg,
                                                      lDataObject);
    }

    // Handle extension controlbars

    CControlbarsList newCBs;

    POSITION pos = extnSnapins.GetHeadPosition();

    while (pos)
    {
        CControlbar* pCbar = NULL;

        CLSID& clsid = extnSnapins.GetNext(pos);

        POSITION pos2 = m_SelData.m_listExtCBs.GetHeadPosition();
        POSITION pos2Prev = 0;
        while (pos2)
        {
            pos2Prev = pos2;
            pCbar = m_SelData.m_listExtCBs.GetNext(pos2);
            ASSERT(pCbar != NULL);
            if (pCbar->IsSameSnapin(clsid) == TRUE)
                break;
            pCbar = NULL;
        }

        if (pCbar != NULL)
        {
            ASSERT(pos2Prev != 0);
            m_SelData.m_listExtCBs.RemoveAt(pos2Prev);
        }
        else
        {
            IExtendControlbarPtr spECB;
            HRESULT hr = spECB.CreateInstance(clsid, NULL, MMC_CLSCTX_INPROC);
            CHECK_HRESULT(hr);
            if (SUCCEEDED(hr))
                pCbar = CreateControlbar(spECB, clsid);
        }

        if (pCbar != NULL)
            newCBs.AddHead(pCbar);
    }

    m_SelData.ScDestroyExtensionCtrlbars();

    pos = newCBs.GetHeadPosition();
    while (pos)
    {
        CControlbar* pCbar = newCBs.GetNext(pos);
        m_SelData.m_listExtCBs.AddHead(pCbar);
        pCbar->ControlbarNotify(MMCN_SELECT, arg, lDataObject);
    }
    newCBs.RemoveAll();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\declspec.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       declspec.h
//
//--------------------------------------------------------------------------

// Used to import or export data in nodemgr DLL without the hassle of
// creating a .DEF file with decorated names.


#ifdef _NODEMGRDLL
    #define NM_DECLSPEC __declspec(dllexport)
#else
    #define NM_DECLSPEC __declspec(dllimport)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------



#include "..\inc\StdDbg.h"

#ifdef DBG
    DECLARE_DEBUG(AMCNodeMgr)
    #define DBG_COMP    AMCNodeMgrInfoLevel
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\ctrlbar.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctrlbar.h
//
//  Contents:   IControlbar implementation, peer of IExtendControlbar
//
//  Classes:    CControlbar
//
//  History:
//____________________________________________________________________________
//

#ifndef _CTRLBAR_H_
#define _CTRLBAR_H_

class CControlbarsCache;
class CMenuButton;
class CNode;
class CComponentPtrArray;
class CToolbar;


//+-------------------------------------------------------------------
//
//  class:     CControlbar
//
//  Purpose:   The IControlbar implementation that (equivalent
//             to IExtendControlbar). This allows manipulation
//             of toolbars & menu buttons.
//             The snapin and CSelData hold reference to this object.
//
//  History:    10-12-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CControlbar : public IControlbar,
                    public CComObjectRoot
{
public:
    CControlbar();
    ~CControlbar();

    IMPLEMENTS_SNAPIN_NAME_FOR_DEBUG()

private:
    CControlbar(const CControlbar& controlBar);

public:
// ATL COM map
BEGIN_COM_MAP(CControlbar)
    COM_INTERFACE_ENTRY(IControlbar)
END_COM_MAP()


#ifdef DBG
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        bool b = 1;
        if (b)
            ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        bool b = 1;
        if (b)
            --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG


// IControlbar members
public:
    STDMETHOD(Create)(MMC_CONTROL_TYPE nType,
                      LPEXTENDCONTROLBAR pExtendControlbar,
                      LPUNKNOWN* ppUnknown);
    STDMETHOD(Attach)(MMC_CONTROL_TYPE nType, LPUNKNOWN  lpUnknown);
    STDMETHOD(Detach)(LPUNKNOWN lpUnknown);

public:
    HRESULT ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

    SC ScCleanup();
    SC ScShowToolbars(bool bShow);

    // Toolbar button & Menu button click handler.
    SC ScNotifySnapinOfMenuBtnClick(HNODE hNode, bool bScope, LPARAM lParam, LPMENUBUTTONDATA lpmenuButtonData);
    SC ScNotifySnapinOfToolBtnClick(HNODE hNode, bool bScope, LPARAM lParam, UINT nID);

    // The CToolbar object calls this when it is being destroyed.
    // It wants Controlbar to stop referencing it.
    void DeleteFromToolbarsList(CToolbar *pToolbar)
    {
        m_ToolbarsList.remove(pToolbar);
    }

public:
    // Accessors.
    IExtendControlbar* GetExtendControlbar()
    {
        return m_spExtendControlbar;
    }
    void SetExtendControlbar(IExtendControlbar* pExtendControlbar,
                             const CLSID& clsidSnapin)
    {
        ASSERT(pExtendControlbar != NULL);
        ASSERT(m_spExtendControlbar == NULL);
        m_spExtendControlbar = pExtendControlbar;
        m_clsidSnapin = clsidSnapin;
    }
    void SetExtendControlbar(IExtendControlbar* pExtendControlbar)
    {
        ASSERT(pExtendControlbar != NULL);
        ASSERT(m_spExtendControlbar == NULL);
        m_spExtendControlbar = pExtendControlbar;
    }
    BOOL IsSameSnapin(const CLSID& clsidSnapin)
    {
        return IsEqualCLSID(m_clsidSnapin, clsidSnapin);
    }
    void SetCache(CControlbarsCache* pCache)
    {
        ASSERT(pCache != NULL);
        m_pCache = pCache;
    }

    CMenuButtonsMgr* GetMenuButtonsMgr()
    {
        CViewData* pViewData = GetViewData();
        if (NULL != pViewData)
        {
            return pViewData->GetMenuButtonsMgr();
        }

        return NULL;
    }

    CAMCViewToolbarsMgr* GetAMCViewToolbarsMgr()
    {
        CViewData* pViewData = GetViewData();
        if (NULL != pViewData)
        {
            return pViewData->GetAMCViewToolbarsMgr();
        }

        return NULL;
    }

private:
    // private methods
    CViewData* GetViewData();

    SC ScCreateToolbar(LPEXTENDCONTROLBAR pExtendControlbar, LPUNKNOWN* ppUnknown);
    SC ScCreateMenuButton(LPEXTENDCONTROLBAR pExtendControlbar, LPUNKNOWN* ppUnknown);
    SC ScAttachToolbar(LPUNKNOWN lpUnknown);
    SC ScAttachMenuButtons(LPUNKNOWN lpUnknown);
    SC ScDetachToolbars();
    SC ScDetachToolbar(LPTOOLBAR lpToolbar);
    SC ScDetachMenuButton(LPMENUBUTTON lpMenuButton);


// Implementation
private:
    IExtendControlbarPtr    m_spExtendControlbar;
    CLSID                   m_clsidSnapin;
    CControlbarsCache*      m_pCache;

    // List of IToolbar implementations (CToolbar) created.
    typedef  std::list<CToolbar*>   ToolbarsList;

    // Toolbars specific data
    ToolbarsList            m_ToolbarsList;
    CMenuButton*            m_pMenuButton; // One per IControlbar.

}; // class CControlbar


typedef CTypedPtrList<MMC::CPtrList, CControlbar*> CControlbarsList;

class CSelData
{
public:

    CSelData(bool bScopeSel, bool bSelect)
        :
        m_bScopeSel(bScopeSel), m_bSelect(bSelect), m_pNodeScope(NULL),
        m_pMS(NULL), m_pCtrlbarPrimary(NULL), m_lCookie(-1),
        m_pCompPrimary(NULL)
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CSelData);
    }

    ~CSelData()
    {
        DECLARE_SC(sc, _T("CSelData::~CSelData"));
        sc = ScReset();
        DEBUG_DECREMENT_INSTANCE_COUNTER(CSelData);
    }

    SC ScReset();
    SC ScDestroyPrimaryCtrlbar();
    SC ScDestroyExtensionCtrlbars();
    SC ScShowToolbars(bool bShow);

    bool operator==(CSelData& rhs)
    {
        if (m_bScopeSel != rhs.m_bScopeSel ||
            m_bSelect != rhs.m_bSelect)
            return false;

        if (m_bScopeSel)
            return (m_pNodeScope == rhs.m_pNodeScope);
        else
            return (m_pMS == rhs.m_pMS && m_lCookie == rhs.m_lCookie);
    }

    CControlbar* GetControlbar(const CLSID& clsidSnapin);

    CControlbarsList& GetControlbarsList()
    {
        return m_listExtCBs;
    }

    bool IsScope()
    {
        return m_bScopeSel;
    }

    bool IsSelect()
    {
        return m_bSelect;
    }

// Implementation
    CComponent* m_pCompPrimary;
    CControlbar* m_pCtrlbarPrimary;
    CControlbarsList m_listExtCBs;
    IDataObjectPtr m_spDataObject;

    // data for scope sel
    CNode* m_pNodeScope;

    // data for result sel
    CMultiSelection* m_pMS;
    MMC_COOKIE m_lCookie;

    bool m_bScopeSel;
    bool m_bSelect;

}; // class CSelData


class CControlbarsCache : public IControlbarsCache,
                          public CComObjectRoot
{
public:
    CControlbarsCache() : m_pViewData(NULL), m_SelData(false, false)
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CControlbarsCache);
    }
    ~CControlbarsCache()
    {
        DEBUG_DECREMENT_INSTANCE_COUNTER(CControlbarsCache);
    }

public:
// ATL COM map
BEGIN_COM_MAP(CControlbarsCache)
    COM_INTERFACE_ENTRY(IControlbarsCache)
END_COM_MAP()

// IControlbarsCache methods
public:
    STDMETHOD(DetachControlbars)()
    {
        DECLARE_SC(sc, _T("CControlbarsCache::DetachControlbars"));
        sc = m_SelData.ScReset();
        if (sc)
            return sc.ToHr();

        return sc.ToHr();
    }

public:
    HRESULT OnResultSelChange(CNode* pNode, MMC_COOKIE cookie, BOOL bSelected);
    HRESULT OnScopeSelChange(CNode* pNode, BOOL bSelected);
    HRESULT OnMultiSelect(CNode* pNodeScope, CMultiSelection* pMultiSelection,
                          IDataObject* pDOMultiSel, BOOL bSelect);

    void SetViewData(CViewData* pViewData);
    CViewData* GetViewData();
    SC ScShowToolbars(bool bShow)
    {
        DECLARE_SC(sc, _T("CControlbarsCache::ScShowToolbars"));
        return (sc = m_SelData.ScShowToolbars(bShow));
    }

private:
    CSelData m_SelData;
    CViewData* m_pViewData;

// private methods
    HRESULT _OnDeSelect(CSelData& selData);
    CControlbar* CreateControlbar(IExtendControlbarPtr& spECB,
                                     const CLSID& clsidSnapin);

    HRESULT _ProcessSelection(CSelData& selData,
                              CList<CLSID, CLSID&>& extnSnapins);

}; // class CControlbarsCache

#endif // _CTRLBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\doccnfg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       doccnfg.h
//
//--------------------------------------------------------------------------

// DocCnfg.h: Definition of the CMMCDocConfig class
//
//////////////////////////////////////////////////////////////////////

#ifndef _DOCCNFG_H_
#define _DOCCNFG_H_


/////////////////////////////////////////////////////////////////////////////
// CMMCDocConfig

class CMMCDocConfig :
    public CComDualImpl<IDocConfig, &IID_IDocConfig, &LIBID_NODEMGRLib>,
    //public ISupportErrorInfo,
    public CComObjectRoot,
    public IDumpSnapins,
    public CComCoClass<CMMCDocConfig, &CLSID_MMCDocConfig>,
    public CConsoleFilePersistor
{

private:
    IStoragePtr             m_spStorage;
    tstring                 m_strFilePath;
    CAutoPtr<CSnapInsCache> m_spCache;
    CXMLDocument            m_XMLDocument;
    CXMLElement             m_XMLElemConsole;
    CXMLElement             m_XMLElemTree;

public:
    ~CMMCDocConfig();

BEGIN_COM_MAP(CMMCDocConfig)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IDocConfig)
    COM_INTERFACE_ENTRY(IDumpSnapins)
    //COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_AGGREGATABLE(CMMCDocConfig)

DECLARE_MMC_OBJECT_REGISTRATION (
	g_szMmcndmgrDll,					// implementing DLL
    CLSID_MMCDocConfig,             	// CLSID
    _T("DocConfig 1.0 Object"),         // class name
    _T("NODEMGR.MMCDocConfig.1"),       // ProgID
    _T("NODEMGR.MMCDocConfig"))         // version-independent ProgID

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IDocConfig
public:
    STDMETHOD(OpenFile)(BSTR bstrFilePath);
    STDMETHOD(SaveFile)(BSTR bstrFilePath);
    STDMETHOD(CloseFile)();
    STDMETHOD(EnableSnapInExtension)(BSTR bstrSnapInCLSID, BSTR bstrExtCLSID, VARIANT_BOOL bEnable);

// IDumpSnapins
    STDMETHOD(Dump)(LPCTSTR pszDumpFilePath);
	STDMETHOD(CheckSnapinAvailability)(CAvailableSnapinInfo& asi);

private:
    BOOL IsFileOpen() { return !m_strFilePath.empty(); }

    SC ScOpenFile(BSTR bstrFilePath);
    SC ScCloseFile();
    SC ScSaveFile(BSTR bstrFilePath);
    SC ScEnableSnapInExtension(BSTR bstrSnapInCLSID, BSTR bstrExtCLSID, VARIANT_BOOL bEnable);
    SC ScDump (LPCTSTR pszDumpFilePath);
    SC ScCheckSnapinAvailability (CAvailableSnapinInfo& asi);
};

#endif // _DOCCNFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\doccnfg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       doccnfg.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "doccnfg.h"
#include "comdbg.h"

/////////////////////////////////////////////////////////////////////////////
//
// external references
extern const wchar_t* AMCSnapInCacheStreamName;

/////////////////////////////////////////////////////////////////////////////
//
// Class CMMCDocConfig implementation

CMMCDocConfig::~CMMCDocConfig()
{
    if (IsFileOpen())
        CloseFile();
}


STDMETHODIMP CMMCDocConfig::InterfaceSupportsErrorInfo(REFIID riid)
{
    return (InlineIsEqualGUID(IID_IDocConfig, riid)) ? S_OK : S_FALSE;
}


STDMETHODIMP CMMCDocConfig::OpenFile(BSTR bstrFilePath)
{
    return ScOpenFile( bstrFilePath ).ToHr();
}


STDMETHODIMP CMMCDocConfig::CloseFile()
{
    return ScCloseFile().ToHr();
}


STDMETHODIMP CMMCDocConfig::SaveFile(BSTR bstrFilePath)
{
    return ScSaveFile(bstrFilePath).ToHr();
}


STDMETHODIMP CMMCDocConfig::EnableSnapInExtension(BSTR bstrSnapIn, BSTR bstrExt, VARIANT_BOOL bEnable)
{
    return ScEnableSnapInExtension(bstrSnapIn, bstrExt, bEnable).ToHr();
}


/*+-------------------------------------------------------------------------*
 * CMMCDocConfig::Dump
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMMCDocConfig::Dump (LPCTSTR pszDumpFilePath)
{
    return ScDump (pszDumpFilePath).ToHr();
}


/*+-------------------------------------------------------------------------*
 * CMMCDocConfig::CheckSnapinAvailability
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMMCDocConfig::CheckSnapinAvailability (CAvailableSnapinInfo& asi)
{
    return ScCheckSnapinAvailability(asi).ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCDocConfig::ScOpenFile
 *
 * PURPOSE: Opens the specified console file and reads snapin cache from it
 *
 * PARAMETERS:
 *    BSTR bstrFilePath [in] file name to read from
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDocConfig::ScOpenFile(BSTR bstrFilePath)
{
    DECLARE_SC(sc, TEXT("CMMCDocConfig::ScOpenFile"));

    // Close currently open file
    if (IsFileOpen())
    {
        sc = ScCloseFile();
        if (sc)
            sc.TraceAndClear(); // report the error and ignore
    }

    // parameter check
    if (bstrFilePath == NULL || SysStringLen(bstrFilePath) == 0)
        return sc = E_INVALIDARG;

    USES_CONVERSION;
    LPCTSTR lpstrFilePath = OLE2CT(bstrFilePath);

    // create object to load the snapins
    CAutoPtr<CSnapInsCache> spSnapInsCache( new CSnapInsCache );
    sc = ScCheckPointers( spSnapInsCache, E_OUTOFMEMORY );
    if (sc)
        return sc;

    // load the data (use bas class method)
    bool bXmlBased = false;
    CXMLDocument xmlDocument;
    IStoragePtr spStorage;
    sc = ScLoadConsole( lpstrFilePath, bXmlBased, xmlDocument, &spStorage );
    if (sc)
        return sc;

    // examine file type
    if ( !bXmlBased )
    {
        // structured storage - based console
        IStreamPtr spStream;
        sc = OpenDebugStream(spStorage, AMCSnapInCacheStreamName,
                         STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"SnapInCache", &spStream);
        if (sc)
            return sc;

        sc = spSnapInsCache->ScLoad(spStream);
        if (sc)
            return sc;

        m_spStorage = spStorage;
    }
    else
    {
        // xml - based console

        try // xml implementation throws sc's
        {
            // construct parent document
            CXMLElement elemDoc = xmlDocument;
            CPersistor persistorFile(xmlDocument, elemDoc);
            // init
            persistorFile.SetLoading(true);

            // navigate to snapin cache
            CPersistor persistorConsole ( persistorFile,    XML_TAG_MMC_CONSOLE_FILE );
            CPersistor persistorTree    ( persistorConsole, XML_TAG_SCOPE_TREE );

            // load
            persistorTree.Persist(*spSnapInsCache);

            // hold onto the persistor info
            m_XMLDocument = persistorConsole.GetDocument();
            m_XMLElemConsole = persistorConsole.GetCurrentElement();
            m_XMLElemTree = persistorTree.GetCurrentElement();
        }
        catch(SC& sc_thrown)
        {
            return (sc = sc_thrown);
        }
    }

    // keep on the pointer
    m_spCache.Attach( spSnapInsCache.Detach() );
    m_strFilePath = lpstrFilePath;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDocConfig::ScCloseFile
 *
 * PURPOSE: closes open file
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDocConfig::ScCloseFile()
{
    DECLARE_SC(sc, TEXT("CMMCDocConfig::ScCloseFile"));

    if (!IsFileOpen())
        return sc = E_UNEXPECTED;

    // release everything
    m_spStorage = NULL;
    m_strFilePath.erase();
    m_spCache.Delete();
    m_XMLDocument = CXMLDocument();
    m_XMLElemConsole = CXMLElement();
    m_XMLElemTree = CXMLElement();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  ScFindAndTruncateChild
 *
 * PURPOSE: helper; locates the element by tag and removes all element's contents
 *          Doing so instead of deleting and recreating the element preserves all
 *          the formating and tag order in xml document
 *
 * PARAMETERS:
 *    CPersistor& parent    [in] - parent persistor
 *    LPCTSTR strTag        [in] - child's tag
 *    CXMLElement& child    [out] - child's element
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC ScFindAndTruncateChild(CPersistor& parent, LPCTSTR strTag, CXMLElement& child)
{
    DECLARE_SC(sc, TEXT("ScTruncateChild"));

    try
    {
        // create persistor for the old cache tag
        parent.SetLoading(true); // we want 'loading-alike' navigation
        CPersistor persistorChild( parent, strTag );
        parent.SetLoading(false); // restore saving behavior

        // get the element
        CXMLElement elChild = persistorChild.GetCurrentElement();

        // get nodes under the element
        CXMLElementCollection colChildren;
        elChild.get_children( &colChildren );

        long count = 0;
        colChildren.get_count( &count );

        // iterate and delete all the nodes
        while (count > 0)
        {
            CXMLElement el;
            colChildren.item( 0, &el);

            elChild.removeChild(el);

            --count;
        }

        // return the element
        child = elChild;
    }
    catch(SC& sc_thrown)
    {
        return (sc = sc_thrown);
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDocConfig::ScSaveFile
 *
 * PURPOSE: Saves file to specified location
 *
 * PARAMETERS:
 *    BSTR bstrFilePath [in] file path to save to. NULL -> same as load
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDocConfig::ScSaveFile(BSTR bstrFilePath)
{
    DECLARE_SC(sc, TEXT("CMMCDocConfig::ScSaveFile"));

    if (!IsFileOpen() || m_spCache == NULL)
        return sc = E_UNEXPECTED;

    USES_CONVERSION;

    // if new path specified, save local copy as new default
    if ( bstrFilePath && SysStringLen(bstrFilePath) != 0)
        m_strFilePath = OLE2CT(bstrFilePath);

    // remove extensions marked for deletion
    m_spCache->Purge(TRUE);

    if ( m_spStorage != NULL ) // not the XML way?
    {
        // replace snapin cache stream with new cache contents
        IStreamPtr spStream;
        sc = CreateDebugStream(m_spStorage, AMCSnapInCacheStreamName,
                STGM_SHARE_EXCLUSIVE | STGM_CREATE | STGM_READWRITE, L"SnapInCache", &spStream);
        if (sc)
            return sc;

        // save the cache
        sc = m_spCache->ScSave(spStream, TRUE);
        if (sc)
            return sc;

        // Create storage for the requested file
        IStoragePtr spNewStorage;
        sc = CreateDebugDocfile( T2COLE( m_strFilePath.c_str() ),
            STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE | STGM_READWRITE,
            &spNewStorage);

        if (sc)
            return sc;

        // copy the working storage to the new file
        sc = m_spStorage->CopyTo(NULL, NULL, NULL, spNewStorage);
        if (sc)
            return sc;

        // lets hold on the new one
        m_spStorage = spNewStorage;
    }
    else
    {
        try // may throw
        {
            // save the data

            CPersistor persistorTree( m_XMLDocument, m_XMLElemTree );

            // this is more tricky than loading - we want to reuse the same tag

            CXMLElement elCache;
            sc = ScFindAndTruncateChild(persistorTree, m_spCache->GetXMLType(), elCache);
            if (sc)
                return sc;

            // create persistor for the new cache tag
            CPersistor persistorCache( persistorTree, elCache );

            // now persist under the new tag
            m_spCache->Persist(persistorCache);

            // update documents guid to invalidate user data

            GUID  guidConsoleId;
            sc = CoCreateGuid(&guidConsoleId);
            if (sc)
                return sc;

            // persistor for console
            CPersistor persistorConsole ( m_XMLDocument,  m_XMLElemConsole );
            persistorConsole.SetLoading(false);

            CXMLElement elGuid;
            sc = ScFindAndTruncateChild(persistorConsole, XML_TAG_CONSOLE_FILE_UID, elGuid);
            if (sc)
                return sc;

            // create persistor for the new guid tag
            CPersistor persistorGuid( persistorConsole, elGuid );

            // now persist under the new tag
            persistorGuid.PersistContents(guidConsoleId);

            //save to file
            sc = ScSaveConsole( m_strFilePath.c_str(), true/*bForAuthorMode*/, m_XMLDocument);
            if (sc)
                return sc;
        }
        catch(SC& sc_thrown)
        {
            return (sc = sc_thrown);
        }
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDocConfig::ScEnableSnapInExtension
 *
 * PURPOSE: Enables extension in snapin cache
 *
 * PARAMETERS:
 *    BSTR bstrSnapIn       [in] classid of the snapin
 *    BSTR bstrExt          [in] classid of extension
 *    VARIANT_BOOL bEnable  [in] enable/disable flag
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDocConfig::ScEnableSnapInExtension(BSTR bstrSnapIn, BSTR bstrExt, VARIANT_BOOL bEnable)
{
    DECLARE_SC(sc, TEXT("CMMCDocConfig::ScEnableSnapInExtension"));

    CLSID SnapInCLSID;
    CLSID ExtCLSID;
    CSnapInPtr spBaseSnapIn;
    CSnapInPtr spExtSnapIn;

    // convert input strings to CLSIDs
    sc = CLSIDFromString(bstrSnapIn, &SnapInCLSID);
    if (sc)
        return sc;

    sc = CLSIDFromString( bstrExt, &ExtCLSID);
    if (sc)
        return sc;

    // Locate base snap-in in cache
    sc = m_spCache->ScFindSnapIn(SnapInCLSID, &spBaseSnapIn);
    if (sc)
        return sc = E_INVALIDARG;

    // Check if extension is enabled
    CExtSI* pExt = spBaseSnapIn->GetExtensionSnapIn();
    while (pExt != NULL)
    {
        if (pExt->GetSnapIn()->GetSnapInCLSID() == ExtCLSID)
            break;

        pExt = pExt->Next();
    }

    // if extension is present and not marked for deletion
    if (pExt != NULL && !pExt->IsMarkedForDeletion())
    {
        // If should be disabled, just mark deleted
        if (!bEnable)
            pExt->MarkDeleted(TRUE);
    }
    else
    {
        // if should be enabled
        if (bEnable)
        {
            // if extension is present, just undelete
            if (pExt != NULL)
            {
                pExt->MarkDeleted(FALSE);
            }
            else
            {
                // Find or create cache entry for extension snapin
                sc = m_spCache->ScGetSnapIn(ExtCLSID, &spExtSnapIn);
                if (sc)
                    return sc;

                // Add as extension to base snapin
                spBaseSnapIn->AddExtension(spExtSnapIn);
            }
        }
    }

    return sc;
}



/***************************************************************************\
 *
 * METHOD:  CMMCDocConfig::ScDump
 *
 * PURPOSE: dumps contents of snapin cache
 *
 * PARAMETERS:
 *    LPCTSTR pszDumpFilePath [in] file to dump to
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDocConfig::ScDump (LPCTSTR pszDumpFilePath)
{
    DECLARE_SC(sc, TEXT("CMMCDocConfig::ScDump"));

	/*
	 * validate input
	 */
	sc = ScCheckPointers (pszDumpFilePath);
	if (sc)
		return sc;

    if (pszDumpFilePath[0] == 0)
        return sc = E_INVALIDARG;

	/*
	 * make sure a file is open
	 */
	if (!IsFileOpen())
		return ((sc = E_UNEXPECTED).ToHr());

	sc = ScCheckPointers (m_spCache, E_UNEXPECTED);
	if (sc)
		return (sc.ToHr());

    return (m_spCache->Dump (pszDumpFilePath));
}



/***************************************************************************\
 *
 * METHOD:  CMMCDocConfig::ScCheckSnapinAvailability
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    	BOOL  f32bit            [in]    // check 32-bit (vs. 64-bit) snap-ins?
 *    	UINT& cTotalSnapins     [out]   // total number of snap-ins referenced in the console file
 *    	UINT& cAvailableSnapins [out]   // number of snap-ins available in the requested memory model
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDocConfig::ScCheckSnapinAvailability (CAvailableSnapinInfo& asi)
{
    DECLARE_SC(sc, TEXT("CMMCDocConfig::ScCheckSnapinAvailability"));

	/*
	 * make sure a file is open
	 */
	if (!IsFileOpen())
		return ((sc = E_UNEXPECTED).ToHr());

	sc = ScCheckPointers (m_spCache, E_UNEXPECTED);
	if (sc)
		return sc;

	sc = m_spCache->ScCheckSnapinAvailability (asi);
	if (sc)
		return sc;

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\dummysi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dummysi.h
//
//--------------------------------------------------------------------------

#ifndef DUMMYSI_H
#define DUMMYSI_H
#pragma once

// Different reasons for which a dummy snapin is created.
enum EDummyCreateReason
{
    eNoReason = 0,
    eSnapPolicyFailed,
    eSnapCreateFailed,
};


SC ScCreateDummySnapin (IComponentData ** ppICD, EDummyCreateReason, const CLSID& clsid);
void ReportSnapinInitFailure(const CLSID& clsid);

extern const GUID IID_CDummySnapinCD;

#endif /* DUMMYSI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\dummysi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dummysi.cpp
//
//  Contents:  If a snapin creation fails a Dummy snapin is created,
//             this file contains the dummy snapin implementation.
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "dummysi.h"
#include "regutil.h"


const CLSID CLSID_Dummy    = {0x82c37898,0x7808,0x11d1,{0xa1,0x90,0x00,0x00,0xf8,0x75,0xb1,0x32}};
const GUID IID_CDummySnapinCD = {0xe683b257, 0x3ca9, 0x454a, {0xae, 0xb9, 0x7, 0x64, 0xdd, 0x31, 0xb1, 0xe8}};

//+-------------------------------------------------------------------
//
//  Class:      CDummySnapinCD
//
//  Purpose:    Dummy snapin's ComponentData.
//
//  Notes:      Dummy snapin should implement all 3 persist interfaces
//              or None. So let us implement none.
//
//--------------------------------------------------------------------

class CDummySnapinCD :
    public IComponentData,
    public CComObjectRoot

{
public:

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDummySnapinCD)

BEGIN_COM_MAP(CDummySnapinCD)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY_IID(IID_CDummySnapinCD, CDummySnapinCD)
END_COM_MAP()

    CDummySnapinCD() : m_eReason(eNoReason) {}
    ~CDummySnapinCD() {}

// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    void  SetDummyCreateReason(EDummyCreateReason eReason) { m_eReason = eReason; }
    EDummyCreateReason GetDummyCreateReason() const { return m_eReason;}

    const CLSID& GetFailedSnapinCLSID() { return m_clsid;}
    void SetFailedSnapinCLSID(const CLSID& clsid) { m_clsid = clsid; }

private:
    EDummyCreateReason m_eReason;       // Reason for dummy creation.
    CLSID              m_clsid;         // Class ID of the snapin that could not be created.
};

DEFINE_COM_SMARTPTR(CDummySnapinCD);   // CDummySnapinCDPtr

//+-------------------------------------------------------------------
//
//  Class:      CDataObject
//
//  Purpose:    Dummy snapin's IDataObject implementation.
//
//--------------------------------------------------------------------
class CDataObject:
    public IDataObject,
    public CComObjectRoot
{
public:

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)

BEGIN_COM_MAP(CDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

    CDataObject();
    ~CDataObject() {}

// IDataObject overrides
    STDMETHOD(GetDataHere) (FORMATETC *pformatetc, STGMEDIUM *pmedium);
// Not Implemented
private:
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };
    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };
    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

public:
    static UINT s_cfInternal;      // Our custom clipboard format
    static UINT s_cfDisplayName;   // Our test for a node
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
};

//+-------------------------------------------------------------------
//
//  Class:      CDummySnapinC
//
//  Purpose:    Dummy snapin's IComponent implementation.
//
//--------------------------------------------------------------------
class CDummySnapinC:
    public IComponent,
    public CComObjectRoot
{
private:
    LPCONSOLE       m_pConsole;
    CDummySnapinCD* m_pComponentData;

public:
    void SetComponentData(CDummySnapinCD* pCompData)
    {
        m_pComponentData = pCompData;
    }

public:

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDummySnapinC)

BEGIN_COM_MAP(CDummySnapinC)
    COM_INTERFACE_ENTRY(IComponent)
END_COM_MAP()

    CDummySnapinC() :m_pConsole(NULL), m_pComponentData(NULL) {}
    ~CDummySnapinC() {}

    //
    // IComponent interface members
    //
    STDMETHOD(Initialize) (LPCONSOLE lpConsole);
    STDMETHOD(Notify) (LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy) (MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType) (MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(QueryDataObject) (MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo) (RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects) (LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);
};

//+-------------------------------------------------------------------
//
//  Member:     ScCreateDummySnapin
//
//  Synopsis:   Create a dummy snapin.
//
//  Arguments:  [ppICD]   -  Ptr to dummy snapins IComponentData.
//              [eReason] -  Reason for creating dummy snapin.
//              [clsid]   -  Class ID of the snapin that could not be created.
//
//--------------------------------------------------------------------
SC ScCreateDummySnapin (IComponentData ** ppICD, EDummyCreateReason eReason, const CLSID& clsid)
{
    DECLARE_SC(sc, TEXT("ScCreateDummySnapin"));

    sc = ScCheckPointers(ppICD);
    if(sc)
        return sc;

    ASSERT(eNoReason != eReason);

    *ppICD = NULL;

    CComObject<CDummySnapinCD>* pDummySnapinCD;
    sc = CComObject<CDummySnapinCD>::CreateInstance (&pDummySnapinCD);
    if (sc)
        return sc;

    if (NULL == pDummySnapinCD)
        return (sc = E_UNEXPECTED);

    pDummySnapinCD->SetDummyCreateReason(eReason);
    pDummySnapinCD->SetFailedSnapinCLSID(clsid);

    IComponentDataPtr spComponentData = pDummySnapinCD;
    if(spComponentData == NULL)
    {
        delete pDummySnapinCD;
        return (sc = E_UNEXPECTED);
    }

    *ppICD = spComponentData;
    if(NULL == *ppICD)
    {
        delete pDummySnapinCD;
        return (sc = E_UNEXPECTED);
    }

    (*ppICD)->AddRef(); //addref for client

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ReportSnapinInitFailure
//
//  Synopsis:   Get the name of the snapin provided class id.
//
//  Arguments:  [strClsid] - Class id of the snapin.
//              [szName]   - Name of the snapin.
//
//--------------------------------------------------------------------
void ReportSnapinInitFailure(const CLSID& clsid)
{
    DECLARE_SC(sc, _T("ReportSnapinInitFailure"));

    // snapin name
    CStr strMessage;
    strMessage.LoadString(GetStringModule(), IDS_SNAPIN_FAILED_INIT_NAME);

    CCoTaskMemPtr<WCHAR> spszClsid;
    sc = StringFromCLSID(clsid, &spszClsid);
    if (sc)
        return;

    USES_CONVERSION;
    tstring strSnapName;
    bool bSuccess = GetSnapinNameFromCLSID(clsid, strSnapName);
    if (false == bSuccess)
    {
        TraceError(_T("GetSnapinName call in ReportSnapinInitFailure failed."), sc);

        // signal unknown name of snapin and continue
        if ( !strSnapName.LoadString( GetStringModule(), IDS_UnknownSnapinName ) )
            strSnapName = _T("<unknown>");
    }

    strMessage += strSnapName.data();

    // clsid
    CStr strClsid2;
    strClsid2.LoadString(GetStringModule(), IDS_SNAPIN_FAILED_INIT_CLSID);
    strClsid2 += OLE2T(spszClsid);

    // construct the error message
    CStr strError;
    strError.LoadString(GetStringModule(), IDS_SNAPIN_FAILED_INIT);

    strError += strMessage;
    strError += strClsid2;

    MMCErrorBox(strError, MB_OK|MB_TASKMODAL);

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinCD::Initialize
//
//  Synopsis:   Does nothing.
//
//  Arguments:  [pUnknown] - IConsole2 ptr.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinCD::Initialize (LPUNKNOWN pUnknown)
{ return S_OK; }

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinCD::CreateComponent
//
//  Synopsis:   Creates a CDummySnapinC object.
//
//  Arguments:  [ppComponent] - Ptr to created component.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinCD::CreateComponent (LPCOMPONENT* ppComponent)
{
    SC sc = E_FAIL;

    CComObject<CDummySnapinC>* pDummySnapinC;
    sc = CComObject<CDummySnapinC>::CreateInstance (&pDummySnapinC);
    if (sc)
        goto Error;

    if (NULL == pDummySnapinC)
        goto Error;

    pDummySnapinC->SetComponentData(this);
    sc = pDummySnapinC->QueryInterface(IID_IComponent, reinterpret_cast<void**>(ppComponent));

Cleanup:
    return HrFromSc(sc);

Error:
    TraceError(TEXT("CDummySnapinCD::CreateComponent"), sc);
     goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinCD::Notify
//
//  Synopsis:   Right now does not handle any events.
//
//  Arguments:  [lpDataObject] - Ptr to created component.
//              [event]        - Event type.
//              [arg, param)   - event specific data.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinCD::Notify (LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinCD::Destroy
//
//  Synopsis:   Right now does nothing to destroy.
//
//  Arguments:  None
//
//--------------------------------------------------------------------
HRESULT CDummySnapinCD::Destroy ()
{ return S_OK; }

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinCD::QuertDataObject
//
//  Synopsis:   Get IDataObject.
//
//  Arguments:  [cookie]       - Snapin specific data.
//              [type]         - data obj type, Scope/Result/Snapin mgr...
//              [ppDataObject] - IDataObject ptr.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinCD::QueryDataObject (MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    SC sc = E_FAIL;

    CComObject<CDataObject>* pDataObject;
    sc = CComObject<CDataObject>::CreateInstance (&pDataObject);
    if (sc)
        goto Error;

    if (NULL == pDataObject)
        goto Error;

    sc = pDataObject->QueryInterface(IID_IDataObject, reinterpret_cast<void**>(ppDataObject));

Cleanup:
    return HrFromSc(sc);

Error:
    TraceError(TEXT("CDummySnapinCD::QueryDataObject"), sc);
     goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinCD::GetDisplayInfo
//
//  Synopsis:   Display info call back.
//              (Right now there is nothing to display, no enumerated item).
//
//  Arguments:  [pScopeDataItem] - Snapin should fill this struct for Display info.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinCD::GetDisplayInfo (SCOPEDATAITEM* pScopeDataItem)
{ return S_OK; }

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinCD::CompareObjects
//
//  Synopsis:   Used for sort / find prop sheet...
//              (Right now do nothing as we have only one item).
//
//  Arguments:  [lpDataObjectA] - IDataObject of first item.
//              [lpDataObjectB] - IDataObject of second item.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinCD::CompareObjects (LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{ return S_OK; }

#define MY_CF_SNAPIN_INTERNAL L"DUMMY SNAPIN"

// global(s)
const GUID GUID_DummyNode = {
    0x82c37899,
    0x7808,
    0x11d1,
    {0xa1, 0x90, 0x00, 0x00, 0xf8, 0x75, 0xb1, 0x32}
};

// statics
UINT CDataObject::s_cfInternal = 0;
UINT CDataObject::s_cfDisplayName = 0;
UINT CDataObject::s_cfNodeType = 0;
UINT CDataObject::s_cfSnapinClsid = 0;

CDataObject::CDataObject()
{
    USES_CONVERSION;
    s_cfInternal    = RegisterClipboardFormat (W2T(MY_CF_SNAPIN_INTERNAL));
    s_cfDisplayName = RegisterClipboardFormat (W2T(CCF_DISPLAY_NAME));
    s_cfNodeType    = RegisterClipboardFormat (W2T(CCF_NODETYPE));
    s_cfSnapinClsid = RegisterClipboardFormat (W2T(CCF_SNAPIN_CLASSID));
}

//+-------------------------------------------------------------------
//
//  Member:     CDataObject::GetDataHere
//
//  Synopsis:   IDataObject::GetDataHere.
//
//  Arguments:  [pformatetc]
//              [pmedium]
//
//--------------------------------------------------------------------
HRESULT CDataObject::GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    SC sc = DV_E_FORMATETC;

    IStream * pstm = NULL;
    sc = CreateStreamOnHGlobal (pmedium->hGlobal, FALSE, &pstm);
    if (pstm) {

       const CLIPFORMAT cf = pformatetc->cfFormat;

       if (cf == s_cfDisplayName) {
          LPTSTR pszName = _T("Display Manager (Version 2)");
          sc = pstm->Write (pszName, sizeof(TCHAR)*(1+_tcslen (pszName)), NULL);
       } else
       if (cf == s_cfInternal) {
          CDataObject * pThis = this;
          sc = pstm->Write (pThis, sizeof(CDataObject *), NULL);
       } else
       if (cf == s_cfNodeType) {
          const GUID * pguid;
          pguid = &GUID_DummyNode;
          sc = pstm->Write ((PVOID)pguid, sizeof(GUID), NULL);
       } else
       if (cf == s_cfSnapinClsid) {
          sc = pstm->Write (&CLSID_Dummy, sizeof(CLSID_Dummy), NULL);
       } else {
          sc = DV_E_FORMATETC;
          // don't ASSERT
          // _ASSERT(hresult == S_OK);
       }
       pstm->Release();
    }

    return HrFromSc(sc);
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinC::Initialize
//
//  Synopsis:   Just store given ICOnsole2.
//
//  Arguments:  [lpConsole] - IConsole2 ptr.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinC::Initialize (LPCONSOLE lpConsole)
{
    m_pConsole = lpConsole;
    if (m_pConsole)
        m_pConsole->AddRef();

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinC::Notify
//
//  Synopsis:   Right now handle only MMCN_SHOW to display
//              IMessageView with failure message.
//
//  Arguments:  [lpDataObject] - Ptr to created component.
//              [event]        - Event type.
//              [arg, param)   - event specific data.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinC::Notify (LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    DECLARE_SC(sc, _T("CDummySnapinC::Notify"));
    sc = S_FALSE; // Default ret val.

    switch(event)
    {
    case MMCN_SHOW: // Display error message during MMCN_SHOW, TRUE.
        {
            if (FALSE == arg)
                break;

            // First get the IUnknown of Result Pane.
            LPUNKNOWN lpUnkn = NULL;
            sc = m_pConsole->QueryResultView(&lpUnkn);

            if (sc)
                return sc.ToHr();

            // Now get the message view.
            IMessageViewPtr spMessageView;
            sc = lpUnkn->QueryInterface(IID_IMessageView, reinterpret_cast<void**>(&spMessageView));
            lpUnkn->Release();

            if (sc)
                return sc.ToHr();

            // Got the message view, not set the title and text.
            CStr strTempForLoading; // Temp object for loading string from resources.

            sc = spMessageView->Clear();
            if (sc)
                return sc.ToHr();

            strTempForLoading.LoadString(GetStringModule(), IDS_SNAPIN_CREATE_FAILED);

            USES_CONVERSION;
            sc = spMessageView->SetTitleText( T2OLE((LPTSTR)(LPCTSTR)strTempForLoading));
            if (sc)
                return sc.ToHr();

            sc = spMessageView->SetIcon(Icon_Error);
            if (sc)
                return sc.ToHr();

            //////////////////////////////////
            // The body text is as follows  //
            //      Reason.                 //
            //      Snapin Name.            //
            //      Snapin Class ID.        //
            //////////////////////////////////

            tstring szBodyText;       // Body text for message view.

            if (m_pComponentData->GetDummyCreateReason() == eSnapPolicyFailed)
                strTempForLoading.LoadString(GetStringModule(), IDS_SNAPIN_POLICYFAILURE);
            else
                strTempForLoading.LoadString(GetStringModule(), IDS_SNAPIN_FAILED);

            // Reason for failure.
            szBodyText = strTempForLoading + _T('\n');

            // Snapin name.
            CStr strSnapName;
            strTempForLoading.LoadString(GetStringModule(), IDS_SNAPIN_FAILED_INIT_NAME);
            szBodyText += strTempForLoading;

            CCoTaskMemPtr<WCHAR> spszClsid;
            sc = StringFromCLSID(m_pComponentData->GetFailedSnapinCLSID(), &spszClsid);
            if (sc)
                return sc.ToHr();

            // Get the snapin name.
            tstring szSnapinName;
            bool bSucc = GetSnapinNameFromCLSID(m_pComponentData->GetFailedSnapinCLSID(), szSnapinName);
            if (false == bSucc)
            {
                sc = E_FAIL;
                TraceError(_T("GetSnapinName call in CDummySnapinC::Notify failed."), sc);
                return sc.ToHr();
            }

            szBodyText += szSnapinName;
            szBodyText += _T("\n");

            // Now add the snapin class id.
            strTempForLoading.LoadString(GetStringModule(), IDS_SNAPIN_FAILED_INIT_CLSID);
            szBodyText += strTempForLoading;
            szBodyText += OLE2T(spszClsid);

            sc = spMessageView->SetBodyText( T2COLE(szBodyText.data()));
        }
        break;

    default:
        break;
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinC::Destroy
//
//  Synopsis:   Release the cached IConsole2 ptr.
//
//  Arguments:  None
//
//--------------------------------------------------------------------
HRESULT CDummySnapinC::Destroy (MMC_COOKIE cookie)
{
    if (m_pConsole)
        m_pConsole->Release();

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinC::GetResultViewType
//
//  Synopsis:   Specify the message view as result view type.
//
//  Arguments:  [cookie]       - Snapin supplied param.
//              [ppViewType]   - View Name (OCX - GUID, WEB - URL name).
//              [pViewOptions] - View options
//
//--------------------------------------------------------------------
HRESULT CDummySnapinC::GetResultViewType (MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions)
{
    SC sc;

    TCHAR szBuffer[MAX_PATH * 2];
    int cchBuffer = MAX_PATH * 2;

    // We want to display the error message using the message view.
    LPOLESTR lpClsid = NULL;
    sc = StringFromCLSID(CLSID_MessageView, &lpClsid);

    USES_CONVERSION;
    if (!sc.IsError())
    {
        // Use the message view to display error message.
        sc = StringCchCopy(szBuffer, cchBuffer, OLE2T(lpClsid));
        if(sc)
            goto Error;

        ::CoTaskMemFree(lpClsid);
    }
    else
    {
        // Conversion failed, display default error page.
        sc = StringCchCopy (szBuffer, cchBuffer, _T("res://"));
        if(sc)
            goto Error;

        ::GetModuleFileName (NULL, szBuffer + _tcslen(szBuffer), cchBuffer - _tcslen(szBuffer));
        sc = StringCchCat (szBuffer, cchBuffer, _T("/error.htm"));
        if(sc)
            goto Error;
    }

    int cchViewType = 1+_tcslen(szBuffer);
    *ppViewType = (OLECHAR *)::CoTaskMemAlloc (sizeof(OLECHAR)*cchViewType);
    if (!*ppViewType)
    {
        sc = E_OUTOFMEMORY;
        goto Error;
    }

    sc = StringCchCopyW (*ppViewType, cchViewType, T2OLE(szBuffer));
    if(sc)
        goto Error;


Cleanup:
    return HrFromSc(sc);
Error:
    TraceError(TEXT("CDummySnapinC::GetResultViewType"), sc);
    goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinC::QuertDataObject
//
//  Synopsis:   Get IDataObject.
//
//  Arguments:  [cookie]       - Snapin specific data.
//              [type]         - data obj type, Scope/Result/Snapin mgr...
//              [ppDataObject] - IDataObject ptr.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinC::QueryDataObject (MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    SC sc = E_FAIL;

    CComObject<CDataObject>* pDataObject;
    sc = CComObject<CDataObject>::CreateInstance (&pDataObject);
    if (sc)
        goto Error;

    if (NULL == pDataObject)
        goto Error;

    sc = pDataObject->QueryInterface(IID_IDataObject, reinterpret_cast<void**>(ppDataObject));

Cleanup:
    return HrFromSc(sc);
Error:
    TraceError(TEXT("CDummySnapinC::QueryDataObject"), sc);
    goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinC::GetDisplayInfo
//
//  Synopsis:   Display info call back.
//              (Right now there is nothing to display, no result items).
//
//  Arguments:  [pResultDataItem] - Snapin should fill this struct for Display info.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinC::GetDisplayInfo (RESULTDATAITEM*  pResultDataItem)
{ return S_OK; }

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinC::CompareObjects
//
//  Synopsis:   Used for sort / find prop sheet...
//              (Right now do nothing as we dont have any result items).
//
//  Arguments:  [lpDataObjectA] - IDataObject of first item.
//              [lpDataObjectB] - IDataObject of second item.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinC::CompareObjects (LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{ return S_OK; }

#include "scopndcb.h"

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::IsDummySnapin
//
//  Synopsis:    Given the node see if it is dummy snapin.
//
//  Arguments:   [hNode]        - [in] Node selection context.
//               [bDummySnapin] - [out] Is this dummy snapin?
//
//  Returns:     SC
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::IsDummySnapin (/*[in]*/HNODE hNode, /*[out]*/bool& bDummySnapin)
{
    DECLARE_SC(sc, _T("CNodeCallback::IsDummySnapin"));
    sc = ScCheckPointers( (void*) hNode);
    if (sc)
        return sc.ToHr();

    bDummySnapin = false;

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CMTNode *pMTNode = pNode->GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CComponentData *pComponentData = pMTNode->GetPrimaryComponentData();
    sc = ScCheckPointers(pComponentData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    IComponentData* pIComponentData = pComponentData->GetIComponentData();
    sc = ScCheckPointers(pIComponentData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CDummySnapinCDPtr spDummyCD = pIComponentData;
    if (spDummyCD)
        bDummySnapin = true;

    return (sc.ToHr());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\guids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       guids.h
//
//--------------------------------------------------------------------------

// GUIDS.H

#ifndef __GUIDS_H__
#define __GUIDS_H__



//{40FC6ED4-2438-11CF-A3DB-080036F12502} - Standard windows ocx control
static const CATID CATID_OCXControl = 
    { 0x40fc6ed4, 0x2438, 0xa3db, { 0xa3, 0xdb, 0x08, 0x0, 0x36, 0xf1, 0x25, 0x02 } };

#define CONSOLECONTROLS_COMPCAT_NAME _T("Managment Console Controls")

// {B0DAE1CC-F531-11cf-AACE-00AA00BDD61E} - AMC Control category (Component Category)
static const CATID CATID_ConsoleControl = 
    { 0xb0dae1cc, 0xf531, 0x11cf, { 0xaa, 0xce, 0x0, 0xaa, 0x0, 0xbd, 0xd6, 0x1e } };

#define MONITORINGCONTROLS_COMPCAT_NAME _T("Monitoring Controls")

// {B1E09020-0105-11d0-AADA-00AA00BDD61E}
static const CATID CATID_ConsoleMonitorControl = 
{ 0xb1e09020, 0x105, 0x11d0, { 0xaa, 0xda, 0x0, 0xaa, 0x0, 0xbd, 0xd6, 0x1e } };


#endif //__GUIDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\fldrsnap.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:       fldrsnap.cpp
 *
 *  Contents:   Implementation file for built-in snapins that implement
 *              the Folder, ActiveX Control, and Web Link nodes.
 *                  These replace earlier code that had special "built-in"
 *              nodetypes.
 *
 *  History:    23-Jul-98 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "tstring.h"
#include "fldrsnap.h"
#include "imageid.h"
#include <comcat.h>             // COM Component Categoories Manager
#include "compcat.h"
#include "guids.h"
#include "regutil.h"

#include "newnode.h"

// These must now be the same - CMTNode::ScConvertLegacyNode depends on it.
#define SZ_OCXSTREAM  (L"ocx_streamorstorage")
#define SZ_OCXSTORAGE (L"ocx_streamorstorage")


/*+-------------------------------------------------------------------------*
 *
 * ScLoadAndAllocateString
 *
 * PURPOSE: Loads the string specified by the string ID and returns a string
 *          whose storage has been allocated by CoTaskMemAlloc.
 *
 * PARAMETERS:
 *    UINT       ids :
 *    LPOLESTR * lpstrOut :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
ScLoadAndAllocateString(UINT ids, LPOLESTR *lpstrOut)
{
    DECLARE_SC(sc, TEXT("ScLoadAndAllocateString"));

    sc = ScCheckPointers(lpstrOut);
    if(sc)
        return sc;

    USES_CONVERSION;
    CStr str;

    str.LoadString(GetStringModule(), ids);

    int cchStrOut = str.GetLength() +1;
    *lpstrOut = (LPOLESTR) CoTaskMemAlloc( cchStrOut *sizeof(OLECHAR) );
    if(*lpstrOut)
    {
        sc = StringCchCopyW(*lpstrOut, cchStrOut, T2CW(str));
        if(sc)
            return sc;
    }
    else
        sc = E_OUTOFMEMORY;

    return sc;
}


//############################################################################
//############################################################################
//
//  Implementation of class CSnapinDescriptor
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CSnapinDescriptor::CSnapinDescriptor
 *
 * PURPOSE: Constructor
 *
 *+-------------------------------------------------------------------------*/
CSnapinDescriptor::CSnapinDescriptor()
: m_idsName(0), m_idsDescription(0), m_idiSnapinImage(0), m_idbSmallImage(0), m_idbSmallImageOpen(0),
  m_idbLargeImage(0), m_clsidSnapin(GUID_NULL), m_szClsidSnapin(TEXT("")),
  m_guidNodetype(GUID_NULL), m_szGuidNodetype(TEXT("")), m_szClassName(TEXT("")),
  m_szProgID(TEXT("")), m_szVersionIndependentProgID(TEXT("")), m_viewOptions(0)
{
}

CSnapinDescriptor::CSnapinDescriptor(UINT idsName, UINT idsDescription, UINT idiSnapinImage,
                                     UINT idbSmallImage,UINT idbSmallImageOpen, UINT idbLargeImage,
                                       const CLSID &clsidSnapin, LPCTSTR szClsidSnapin,
                                       const GUID &guidNodetype, LPCTSTR szGuidNodetype,
                                       LPCTSTR szClassName, LPCTSTR szProgID,
                                       LPCTSTR szVersionIndependentProgID,
                                       long viewOptions)

: m_idsName(idsName), m_idsDescription(idsDescription), m_idiSnapinImage(idiSnapinImage),
  m_idbSmallImage(idbSmallImage), m_idbSmallImageOpen(idbSmallImageOpen),
  m_idbLargeImage(idbLargeImage), m_clsidSnapin(clsidSnapin), m_szClsidSnapin(szClsidSnapin),
  m_guidNodetype(guidNodetype), m_szGuidNodetype(szGuidNodetype), m_szClassName(szClassName),
  m_szProgID(szProgID), m_szVersionIndependentProgID(szVersionIndependentProgID),
  m_viewOptions(viewOptions)
{
}


/*+-------------------------------------------------------------------------*
 * ScFormatIndirectSnapInName
 *
 * Returns the name of the snap-in in the indirect form supported by
 * SHLoadRegUIString:
 *
 *		@<dllname>,-<strId>
 *--------------------------------------------------------------------------*/

SC ScFormatIndirectSnapInName (
	HINSTANCE	hInst,					/* I:module containing the resource	*/
	int			idNameString,			/* I:ID of name's string resource	*/
	CStr&		strName)				/* O:formatted indirect name string	*/
{
	DECLARE_SC (sc, _T("ScFormatIndirectSnapInName"));

	/*
	 * allocate a buffer for GetModuleFileName
	 */
	const int cchBuffer = MAX_PATH;
	WTL::CString strStringModule;
	LPTSTR szBuffer = strStringModule.GetBuffer (cchBuffer);

	/*
	 * if we couldn't allocate a buffer, return an error
	 */
	if (szBuffer == NULL)
		return (sc = E_OUTOFMEMORY);

	/*
	 * get the name of the module that provides strings
	 */
	const DWORD cbCopied = GetModuleFileName (hInst, szBuffer, cchBuffer);
	strStringModule.ReleaseBuffer();

	/*
	 * if GetModuleFileName failed, return its failure code
	 */
	if (cbCopied == 0)
	{
		sc.FromLastError();

		/*
		 * just in case GetModuleFileName didn't set the last error, make
		 * sure the SC contains some kind of failure code
		 */
		if (!sc.IsError())
			sc = E_FAIL;

		return (sc);
	}

	/*
	 * if a path is present, SHLoadRegUIString won't search for the DLL
	 * based on the current UI language; remove the path portion of the
	 * module name so it will
	 */
	int nLastPathSep = strStringModule.ReverseFind (_T('\\'));
	if (nLastPathSep != -1)
		strStringModule = strStringModule.Mid (nLastPathSep + 1);

	/*
	 * format the name the way SHLoadRegUIString expects it
	 */
	strStringModule.MakeLower();
	strName.Format (_T("@%s,-%d"), (LPCTSTR) strStringModule, idNameString);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinDescriptor::GetRegisteredIndirectName
 *
 * Returns the name of the snap-in in the indirect form supported by
 * SHLoadRegUIString:
 *
 *		@<dllname>,-<strId>
 *--------------------------------------------------------------------------*/

void
CSnapinDescriptor::GetRegisteredIndirectName(CStr &strIndirectName)
{
	DECLARE_SC (sc, _T("CSnapinDescriptor::GetRegisteredIndirectName"));

	sc = ScFormatIndirectSnapInName (GetStringModule(), m_idsName, strIndirectName);
	if (sc)
		sc.TraceAndClear();
}


/*+-------------------------------------------------------------------------*
 * CSnapinDescriptor::GetRegisteredDefaultName
 *
 * Returns the name of the snap-in in the indirect form supported by
 * SHLoadRegUIString:
 *
 *		@<dllname>,-<strId>
 *--------------------------------------------------------------------------*/

void
CSnapinDescriptor::GetRegisteredDefaultName(CStr &str)
{
	str.LoadString (GetStringModule(), m_idsName);
}


/*+-------------------------------------------------------------------------*
 * CSnapinDescriptor::GetName
 *
 * Returns the human-readable name of the snap-in.
 *--------------------------------------------------------------------------*/

void
CSnapinDescriptor::GetName(CStr &str)
{
	DECLARE_SC (sc, _T("CSnapinDescriptor::GetName"));

	/*
	 * get the name from the registry
	 */
	sc = ScGetSnapinNameFromRegistry (m_szClsidSnapin, str);
	if (sc)
		sc.TraceAndClear();
}



long
CSnapinDescriptor::GetViewOptions()
{
    return m_viewOptions;
}

//############################################################################
//############################################################################
//
//  Implementation of class CSnapinComponentDataImpl
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::CSnapinComponentDataImpl
 *
 * PURPOSE: Constructor
 *
 *+-------------------------------------------------------------------------*/
CSnapinComponentDataImpl::CSnapinComponentDataImpl()
: m_bDirty(false)
{
}


void
CSnapinComponentDataImpl::SetName(LPCTSTR sz)
{
    m_strName = sz;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::SetView
 *
 * PURPOSE: Sets the view.
 *
 * PARAMETERS:
 *    LPCTSTR  sz :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CSnapinComponentDataImpl::SetView(LPCTSTR sz)
{
    m_strView = sz;
}


STDMETHODIMP
CSnapinComponentDataImpl::Initialize(LPUNKNOWN pUnknown)
{
    m_spConsole2          = pUnknown;
    m_spConsoleNameSpace2 = pUnknown;

    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::Notify
 *
 * PURPOSE:  Notification handler for the IComponentData implementation.
 *
 * PARAMETERS:
 *    LPDATAOBJECT     lpDataObject : As per MMC docs.
 *    MMC_NOTIFY_TYPE  event :
 *    LPARAM           arg :
 *    LPARAM           param :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event,
               LPARAM arg, LPARAM param)
{
    USES_CONVERSION;

    switch(event)
    {

    case MMCN_RENAME: // the root node is being renamed
        m_strName = OLE2T((LPOLESTR)param);
        SetDirty();
        return S_OK;

    case MMCN_PRELOAD:
        return OnPreload((HSCOPEITEM) arg);
    }

    return S_FALSE;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::OnPreload
 *
 * PURPOSE: sets the icon of the root node (which is the only node.)
 *
 * PARAMETERS:
 *    HSCOPEITEM  scopeItem :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CSnapinComponentDataImpl::OnPreload(HSCOPEITEM scopeItem)
{
    SCOPEDATAITEM item;
    ZeroMemory (&item, sizeof(SCOPEDATAITEM));
    item.mask           = SDI_CHILDREN;
    item.ID             = scopeItem;
    item.cChildren      = 0; // make sure no "+" sign is displayed.

    m_spConsoleNameSpace2->SetItem (&item);

    return S_OK;
}


/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::Destroy
 *
 * PURPOSE: Gives up all references to MMC.
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::Destroy()
{
    m_spConsole2          = NULL;
    m_spConsoleNameSpace2 = NULL;
    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::QueryDataObject
 *
 * PURPOSE: Returns a data object for the specified node.
 *
 * PARAMETERS:
 *    MMC_COOKIE         cookie : NULL for the root node.
 *    DATA_OBJECT_TYPES  type :
 *    LPDATAOBJECT*      ppDataObject :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                          LPDATAOBJECT* ppDataObject)
{
    ASSERT(cookie == NULL);
    if(cookie != NULL)
        return E_UNEXPECTED;

    CComObject<CSnapinDataObject> * pDataObject;
    CComObject<CSnapinDataObject>::CreateInstance(&pDataObject);
    if(pDataObject == NULL)
        return E_UNEXPECTED;

    pDataObject->Initialize(this, type);

    return pDataObject->QueryInterface(IID_IDataObject, (void**)ppDataObject);
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::GetDisplayInfo
 *
 * PURPOSE: Gets the display info for the root (the only) node.
 *
 * PARAMETERS:
 *    SCOPEDATAITEM* pScopeDataItem : [IN/OUT]: The structure to fill in
 *                  based on the mask value.
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::GetDisplayInfo( SCOPEDATAITEM* pScopeDataItem)
{
    SCOPEDATAITEM &sdi = *pScopeDataItem;
    DWORD mask = sdi.mask;

    if(mask & SDI_STR)
    {
        sdi.displayname = (LPOLESTR) GetName();
    }
    if(mask & SDI_IMAGE)
    {
        sdi.nImage     = m_iImage;
    }
    if(mask & SDI_OPENIMAGE)
    {
        sdi.nImage = m_iOpenImage;
    }
    if(mask & SDI_STATE)
    {
    }
    if(mask & SDI_CHILDREN)
    {
        sdi.cChildren =0;
    }

    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::CompareObjects
 *
 * PURPOSE: Determines whether two data objects correspond to the same
 *          underlying object.
 *
 * PARAMETERS:
 *    LPDATAOBJECT  lpDataObjectA :
 *    LPDATAOBJECT  lpDataObjectB :
 *
 * RETURNS:
 *    STDMETHODIMP : S_OK if they correspond to the same object, else S_FALSE.
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    return (lpDataObjectA == lpDataObjectB) ? S_OK : S_FALSE;
}


// IPersistStream
/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::GetClassID
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CLSID * pClassID :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::GetClassID(CLSID *pClassID)
{
    return E_NOTIMPL;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::IsDirty
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    voi d :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::IsDirty(void)
{
    TraceDirtyFlag(TEXT("CSnapinComponentDataImpl (MMC Built-in snapin)"), m_bDirty);

    return m_bDirty ? S_OK : S_FALSE;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::Load
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPSTREAM  pStm :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::Load(LPSTREAM pStm)
{
    return CSerialObject::Read(*pStm);
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::Save
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPSTREAM  pStm :
 *    BOOL      fClearDirty :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::Save(LPSTREAM pStm , BOOL fClearDirty)
{
    HRESULT hr = CSerialObjectRW::Write(*pStm);
    if (SUCCEEDED(hr) && fClearDirty)
        SetDirty(FALSE);

    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::GetSizeMax
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    ULARGE_INTEGER* pcbSize :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::GetSizeMax(ULARGE_INTEGER* pcbSize  )
{
    return E_NOTIMPL;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::GetWatermarks
 *
 * PURPOSE: Sets the header for the wizard
 *
 * PARAMETERS:
 *    LPDATAOBJECT  lpIDataObject :
 *    HBITMAP *     lphWatermark :
 *    HBITMAP *     lphHeader :
 *    HPALETTE *    lphPalette :
 *    BOOL*         bStretch :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::GetWatermarks(LPDATAOBJECT lpIDataObject, HBITMAP * lphWatermark, HBITMAP * lphHeader, HPALETTE * lphPalette,  BOOL* bStretch)
{
    DECLARE_SC(sc, TEXT("COCXSnapinData::ScGetWatermarks"));

    // validate inputs
    sc = ScCheckPointers(lpIDataObject, lphWatermark, lphHeader, lphPalette);
    if(sc)
        return sc.ToHr();

    // initialize outputs
    *lphWatermark = GetWatermark() ? ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(GetWatermark()))
                                      : NULL;
    // if there is a header, use it.
    *lphHeader    = GetHeaderBitmap() ? ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(GetHeaderBitmap()))
                                      : NULL;
    *lphPalette   = NULL;

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::QueryPagesFor
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPDATAOBJECT  lpDataObject :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    CSnapinDataObject *pDataObject = dynamic_cast<CSnapinDataObject *>(lpDataObject);
    if(pDataObject == NULL)
        return E_UNEXPECTED;


    if(pDataObject->GetType() != CCT_SNAPIN_MANAGER)
        return S_FALSE;

    return S_OK; // properties exist only in the snap-in manager.
}


/*+-------------------------------------------------------------------------*
 * CSnapinComponentDataImpl::GetHelpTopic
 *
 * Default implementation of ISnapinHelp::GetHelpTopic for built-in snap-
 * ins (folder, OCX, web page).
 *
 * We need to implement ISnapinHelp in the built-ins to avoid getting
 * "Help for <snap-in>" on the Help menu (bug 453700).  They don't really
 * have help info, so we simply return S_FALSE so the help engine doesn't
 * complain.
 *--------------------------------------------------------------------------*/

STDMETHODIMP CSnapinComponentDataImpl::GetHelpTopic (
    LPOLESTR*   /*ppszCompiledHelpTopic*/)
{
    return (S_FALSE);       // no help topic
}



// CSerialObject methods
/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::ReadSerialObject
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    IStream & stm :
 *    UINT      nVersion :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CSnapinComponentDataImpl::ReadSerialObject (IStream &stm, UINT nVersion)
{
    if(nVersion==1)
    {
        stm >> m_strName;
        stm >> m_strView;
        return S_OK;
    }
    else
        return S_FALSE; //unknown version, skip.
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::WriteSerialObject
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    IStream & stm :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CSnapinComponentDataImpl::WriteSerialObject(IStream &stm)
{
    stm << m_strName;
    stm << m_strView;
    return S_OK;
}


//############################################################################
//############################################################################
//
//  Implementation of class CSnapinComponentImpl
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::Init
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    IComponentData * pComponentData :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CSnapinComponentImpl::Init(IComponentData *pComponentData)
{
    m_spComponentData = pComponentData;
}


// IComponent
/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::Initialize
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPCONSOLE  lpConsole :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentImpl::Initialize(LPCONSOLE lpConsole)
{
    m_spConsole2 = lpConsole;
    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::Notify
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPDATAOBJECT     lpDataObject :
 *    MMC_NOTIFY_TYPE  event :
 *    LPARAM           arg :
 *    LPARAM           param :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event,
                             LPARAM arg, LPARAM param)
{
    switch(event)
    {
    case MMCN_SELECT:
        {
            BOOL bScope  = (BOOL) LOWORD(arg);
            BOOL bSelect = (BOOL) HIWORD(arg);

            SC sc = ScOnSelect(bScope, bSelect);
            if(sc)
                return sc.ToHr();
        }
        return S_OK;
        break;


    default:
        break;

    }
    return S_FALSE;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::ScOnSelect
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    BOOL  bScope :
 *    BOOL  bSelect :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CSnapinComponentImpl::ScOnSelect(BOOL bScope, BOOL bSelect)
{
    DECLARE_SC(sc, TEXT("CSnapinComponentImpl::ScOnSelect"));

    IConsoleVerbPtr spConsoleVerb;
    sc = m_spConsole2->QueryConsoleVerb(&spConsoleVerb);
    if(sc)
        return sc;

    sc = spConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, (bSelect && bScope));
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::Destroy
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    MMC_COOKIE  cookie :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentImpl::Destroy(MMC_COOKIE cookie)
{
    m_spConsole2 = NULL;
    m_spComponentData = NULL;
    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::QueryDataObject
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    MMC_COOKIE         cookie :
 *    DATA_OBJECT_TYPES  type :
 *    LPDATAOBJECT*      ppDataObject :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                      LPDATAOBJECT* ppDataObject)
{
    return E_NOTIMPL;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::GetComponentData
 *
 * PURPOSE:
 *
 * RETURNS:
 *    CSnapinComponentDataImpl *
 *
 *+-------------------------------------------------------------------------*/
CSnapinComponentDataImpl *
CSnapinComponentImpl::GetComponentData()
{
    CSnapinComponentDataImpl *pCD = dynamic_cast<CSnapinComponentDataImpl *>(m_spComponentData.GetInterfacePtr());

    ASSERT(pCD != NULL);
    return pCD;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::GetResultViewType
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    MMC_COOKIE  cookie :
 *    LPOLESTR*   ppViewType :
 *    long*       pViewOptions : Set to MMC_VIEW_OPTIONS_NOLISTVIEWS  for the HTML and OCX snapins,
 *                               0 for the folder snapin.
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentImpl::GetResultViewType(MMC_COOKIE cookie, LPOLESTR* ppViewType,
                                        long* pViewOptions)
{
    DECLARE_SC(sc, TEXT("CSnapinComponentImpl::GetResultViewType"));
    // check parameters
    if(!ppViewType || !pViewOptions)
        return E_UNEXPECTED;

    if(!GetComponentData())
        return E_UNEXPECTED;

    USES_CONVERSION;
    int cchViewType = _tcslen(GetComponentData()->GetView())+1;
    *ppViewType = (LPOLESTR)CoTaskMemAlloc( cchViewType * sizeof(OLECHAR) );
    *pViewOptions = GetComponentData()->GetDescriptor().GetViewOptions();
    sc = StringCchCopyW(*ppViewType, cchViewType, T2OLE((LPTSTR)GetComponentData()->GetView()));
    if(sc)
        return sc.ToHr();
    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::GetDisplayInfo
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    RESULTDATAITEM* pResultDataItem :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentImpl::GetDisplayInfo( RESULTDATAITEM*  pResultDataItem)
{
    RESULTDATAITEM &rdi = *pResultDataItem;
    DWORD mask = rdi.mask;

    if(mask & RDI_STR)
    {
        rdi.str = (LPOLESTR) GetComponentData()->GetName();
    }
    if(mask & RDI_IMAGE)
    {
        rdi.nImage  = GetComponentData()->m_iImage;
    }

    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::CompareObjects
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPDATAOBJECT  lpDataObjectA :
 *    LPDATAOBJECT  lpDataObjectB :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    return E_NOTIMPL;
}

//############################################################################
//############################################################################
//
//  Implementation of class CSnapinDataObject
//
//############################################################################
//############################################################################
// Clipboard formats that are required by the console
UINT CSnapinDataObject::s_cfNodeType;
UINT CSnapinDataObject::s_cfNodeTypeString;
UINT CSnapinDataObject::s_cfDisplayName;
UINT CSnapinDataObject::s_cfCoClass;
UINT CSnapinDataObject::s_cfSnapinPreloads;

/*+-------------------------------------------------------------------------*
 *
 * CSnapinDataObject::RegisterClipboardFormats
 *
 * PURPOSE:
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CSnapinDataObject::RegisterClipboardFormats()
{
    static bool bRegistered = false;
    if(!bRegistered)
    {
        USES_CONVERSION;

        CSnapinDataObject::s_cfNodeType       = RegisterClipboardFormat(OLE2T(CCF_NODETYPE));
        CSnapinDataObject::s_cfNodeTypeString = RegisterClipboardFormat(OLE2T(CCF_SZNODETYPE));
        CSnapinDataObject::s_cfDisplayName    = RegisterClipboardFormat(OLE2T(CCF_DISPLAY_NAME));
        CSnapinDataObject::s_cfCoClass        = RegisterClipboardFormat(OLE2T(CCF_SNAPIN_CLASSID));
        CSnapinDataObject::s_cfSnapinPreloads = RegisterClipboardFormat(OLE2T(CCF_SNAPIN_PRELOADS));

        bRegistered = true;
    }
}

CSnapinDataObject::CSnapinDataObject() : m_bInitialized(false)
{
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinDataObject::GetDataHere
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    FORMATETC * pformatetc :
 *    STGMEDIUM * pmedium :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinDataObject::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    DECLARE_SC(sc, TEXT("CSnapinDataObject::GetDataHere"));

    // validate inputs
    sc = ScCheckPointers(pformatetc, pmedium);
    if(sc)
        return sc.ToHr();

    USES_CONVERSION;
    RegisterClipboardFormats();

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = pformatetc->cfFormat;

    // ensure the medium is an HGLOBAL
    if(pformatetc->tymed != TYMED_HGLOBAL)
        return (sc = DV_E_TYMED).ToHr();

    IStreamPtr spStream;
    HGLOBAL hGlobal = pmedium->hGlobal;

    pmedium->pUnkForRelease = NULL;      // by OLE spec

    sc = CreateStreamOnHGlobal( hGlobal, FALSE, &spStream );
    if(sc)
        return sc.ToHr();

    CSnapinComponentDataImpl *pComponentDataImpl =
        dynamic_cast<CSnapinComponentDataImpl *>(m_spComponentData.GetInterfacePtr());
    ASSERT(pComponentDataImpl != NULL);

    if (cf == s_cfNodeType)
    {
        spStream<<pComponentDataImpl->GetDescriptor().m_guidNodetype;
    }
    else if (cf == s_cfCoClass)
    {
        spStream<<pComponentDataImpl->GetDescriptor().m_clsidSnapin;
    }
    else if(cf == s_cfNodeTypeString)
    {
        WriteString(spStream, T2OLE((LPTSTR)pComponentDataImpl->GetDescriptor().m_szGuidNodetype));
    }
    else if (cf == s_cfDisplayName)
    {
        WriteString(spStream, T2OLE((LPTSTR)pComponentDataImpl->GetName()));
    }
    else if (cf == s_cfSnapinPreloads)
    {
        BOOL bPreload = true;
        spStream->Write ((void *)&bPreload, sizeof(BOOL), NULL);
    }
    else
    {
        return (sc = DV_E_CLIPFORMAT).ToHr(); // invalid format.
    }

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinDataObject::WriteString
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    IStream *  pStream :
 *    LPCOLESTR  sz :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CSnapinDataObject::WriteString(IStream *pStream, LPCOLESTR sz)
{
    DECLARE_SC(sc, TEXT("CSnapinDataObject::WriteString"));

    sc = ScCheckPointers(pStream, sz);
    if(sc)
        return sc.ToHr();

    UINT cbToWrite = wcslen(sz)*sizeof(WCHAR);
    ULONG cbActuallyWritten=0;

    sc = pStream->Write (sz, cbToWrite, &cbActuallyWritten);
    if(sc)
        return sc.ToHr();

    ASSERT(cbToWrite==cbActuallyWritten);
    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinDataObject::Initialize
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    IComponentData *   pComponentData :
 *    DATA_OBJECT_TYPES  type :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CSnapinDataObject::Initialize(IComponentData *pComponentData, DATA_OBJECT_TYPES type)
{
    ASSERT(pComponentData != NULL);
    m_spComponentData = pComponentData;
    m_type            = type;
    m_bInitialized    = true;
}

//############################################################################
//############################################################################
//
//  Implementation of class CFolderSnapinData
//
//############################################################################
//############################################################################
STDMETHODIMP
CFolderSnapinData::CreateComponent(LPCOMPONENT* ppComponent)
{
    typedef CComObject<CFolderSnapinComponent> CComponent;
    CComponent *    pComponent = NULL;
    CComObject<CFolderSnapinComponent>::CreateInstance(&pComponent);
    ASSERT(pComponent != NULL);
    if(pComponent == NULL)
    {
        //TraceError(TEXT("CFolderSnapinData::CreateComponent"));
        return E_UNEXPECTED;
    }

    pComponent->Init(this);

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent); // does the Addref.
}


CFolderSnapinData::CFolderSnapinData()
{
    m_iImage     = eStockImage_Folder;
    m_iOpenImage = eStockImage_OpenFolder;
}


const CLSID       CLSID_FolderSnapin         = {0xC96401CC, 0x0E17,0x11D3, {0x88,0x5B,0x00,0xC0,0x4F,0x72,0xC7,0x17}};
static const GUID GUID_FolderSnapinNodetype  = {0xc96401ce, 0xe17, 0x11d3, { 0x88, 0x5b, 0x0, 0xc0, 0x4f, 0x72, 0xc7, 0x17 } };
static LPCTSTR szClsid_FolderSnapin          = TEXT("{C96401CC-0E17-11D3-885B-00C04F72C717}");
static LPCTSTR szGuidFolderSnapinNodetype    = TEXT("{C96401CE-0E17-11D3-885B-00C04F72C717}");


CSnapinDescriptor &
CFolderSnapinData::GetSnapinDescriptor()
{
    static CSnapinDescriptor snapinDescription(IDS_FOLDER,
                   IDS_FOLDERSNAPIN_DESC, IDI_FOLDER, IDB_FOLDER_16, IDB_FOLDEROPEN_16, IDB_FOLDER_32,
                   CLSID_FolderSnapin, szClsid_FolderSnapin, GUID_FolderSnapinNodetype,
                   szGuidFolderSnapinNodetype, TEXT("Folder"), TEXT("Snapins.FolderSnapin"),
                   TEXT("Snapins.FolderSnapin.1"), 0 /*viewOptions*/ );
    return snapinDescription;
}

// IExtendPropertySheet2
STDMETHODIMP
CFolderSnapinData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpIDataObject)
{
    return S_FALSE;
}

//############################################################################
//############################################################################
//
//  Implementation of class CHTMLSnapinData
//
//############################################################################
//############################################################################
STDMETHODIMP
CHTMLSnapinData::CreateComponent(LPCOMPONENT* ppComponent)
{
    typedef CComObject<CHTMLSnapinComponent> CComponent;
    CComponent *    pComponent = NULL;
    CComObject<CHTMLSnapinComponent>::CreateInstance(&pComponent);
    ASSERT(pComponent != NULL);
    if(pComponent == NULL)
    {
        //TraceError(TEXT("CHTMLSnapinData::CreateComponent"));
        return E_UNEXPECTED;
    }

    pComponent->Init(this);

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent); // does the Addref.
}


CHTMLSnapinData::CHTMLSnapinData()
{
    m_pHtmlPage1 = NULL;
    m_pHtmlPage2 = NULL;
    m_iImage     = eStockImage_HTML;
    m_iOpenImage = eStockImage_HTML;
}

CHTMLSnapinData::~CHTMLSnapinData()
{
}

STDMETHODIMP
CHTMLSnapinData::Destroy()
{
    if(m_pHtmlPage1 != NULL)
    {
        delete m_pHtmlPage1;
        m_pHtmlPage1 = NULL;
    }
    if(m_pHtmlPage2 != NULL)
    {
        delete m_pHtmlPage2;
        m_pHtmlPage2 = NULL;
    }

    return BC::Destroy();
}



const CLSID       CLSID_HTMLSnapin         = {0xC96401D1, 0x0E17,0x11D3, {0x88,0x5B,0x00,0xC0,0x4F,0x72,0xC7,0x17}};
static const GUID GUID_HTMLSnapinNodetype  = {0xc96401d2, 0xe17, 0x11d3, { 0x88, 0x5b, 0x0, 0xc0, 0x4f, 0x72, 0xc7, 0x17 } };
static LPCTSTR szClsid_HTMLSnapin          = TEXT("{C96401D1-0E17-11D3-885B-00C04F72C717}");
static LPCTSTR szGuidHTMLSnapinNodetype    = TEXT("{C96401D2-0E17-11D3-885B-00C04F72C717}");


CSnapinDescriptor &
CHTMLSnapinData::GetSnapinDescriptor()
{
    static CSnapinDescriptor snapinDescription(IDS_HTML,
                   IDS_HTMLSNAPIN_DESC, IDI_HTML, IDB_HTML_16, IDB_HTML_16, IDB_HTML_32,
                   CLSID_HTMLSnapin, szClsid_HTMLSnapin, GUID_HTMLSnapinNodetype,
                   szGuidHTMLSnapinNodetype, TEXT("HTML"), TEXT("Snapins.HTMLSnapin"),
                   TEXT("Snapins.HTMLSnapin.1"), MMC_VIEW_OPTIONS_NOLISTVIEWS  /*viewOptions*/ );
    return snapinDescription;
}

// IExtendPropertySheet2

/*+-------------------------------------------------------------------------*
 *
 * CHTMLSnapinData::CreatePropertyPages
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPPROPERTYSHEETCALLBACK  lpProvider :
 *    LONG_PTR                 handle :
 *    LPDATAOBJECT             lpIDataObject :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CHTMLSnapinData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpIDataObject)
{
    HPROPSHEETPAGE hPage;

    ASSERT(lpProvider != NULL);
    if(lpProvider == NULL)
    {
        //TraceError(TEXT("CHTMLSnapinData::CreatePropertyPages"));
        return E_UNEXPECTED;
    }

    ASSERT(m_pHtmlPage1 == NULL);
    ASSERT(m_pHtmlPage2 == NULL);

    // create property pages
    m_pHtmlPage1 = new CHTMLPage1;
    m_pHtmlPage2 = new CHTMLPage2;

    // pass in pointer to data structure
    m_pHtmlPage1->Initialize(this);
    m_pHtmlPage2->Initialize(this);

    // Add Pages to property sheet
    hPage=CreatePropertySheetPage(&m_pHtmlPage1->m_psp);
    lpProvider->AddPage(hPage);

    hPage=CreatePropertySheetPage(&m_pHtmlPage2->m_psp);
    lpProvider->AddPage(hPage);

    return S_OK;
}


//############################################################################
//############################################################################
//
//  Implementation of class CHTMLSnapinComponent
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CHTMLSnapinComponent::ScOnSelect
 *
 * PURPOSE: Handles the MMCN_SELECT notification. Enables the Refresh verb,
 *          which uses the default MMC handler to refresh the page.
 *
 * PARAMETERS:
 *    BOOL  bScope :
 *    BOOL  bSelect :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CHTMLSnapinComponent::ScOnSelect(BOOL bScope, BOOL bSelect)
{
    DECLARE_SC(sc, TEXT("CHTMLSnapinComponent::ScOnSelect"));

    // call the base class method
    sc = BC::ScOnSelect(bScope, bSelect);
    if(sc)
        return sc;

    IConsoleVerbPtr spConsoleVerb;

    sc = ScCheckPointers(m_spConsole2, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = m_spConsole2->QueryConsoleVerb(&spConsoleVerb);
    if(sc)
        return sc;

    sc = ScCheckPointers(spConsoleVerb, E_UNEXPECTED);
    if(sc)
        return sc;

    // enable the Refresh verb - the default MMC handler is adequate to refresh the page.
    sc = spConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, (bSelect && bScope));
    if(sc)
        return sc;

    //NOTE: (vivekj): I'm intentionally not setting the HIDDEN state to false here, because
    // we have an explicit test in our verb code for MMC1.0 snapins that wrote code like this,
    // and this provides a useful compatibility test.

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CHTMLSnapinComponent::GetResultViewType
 *
 * PURPOSE: Performs parameter substitution on the URL for the environment variables
 *          %windir% and %systemroot% (only) and returns the expanded URL.
 *
 * NOTE:    We don't expand ALL variables using ExpandEnvironmentString. Doing so could
 *          break compatibility with URL's that have %var% but DON'T want to be
 *          expanded.
 *
 * PARAMETERS:
 *    MMC_COOKIE  cookie :
 *    LPOLESTR*   ppViewType :
 *    long*       pViewOptions :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CHTMLSnapinComponent::GetResultViewType(MMC_COOKIE cookie, LPOLESTR* ppViewType, long* pViewOptions)
{
    DECLARE_SC(sc, TEXT("CHTMLSnapinComponent::GetResultViewType"));

    // check parameters
    if(!ppViewType || !pViewOptions)
        return (sc = E_UNEXPECTED).ToHr();

    if(!GetComponentData())
        return (sc = E_UNEXPECTED).ToHr();

    // add support for expanding the environment variables %WINDIR% and %SYSTEMROOT% to maintain compatibility with MMC1.2
    CStr strTarget = GetComponentData()->GetView();
    CStr strRet    = strTarget; // the return value
    CStr strTemp   = strTarget; // both initialized to the same value.

    strTemp.MakeLower(); // NOTE: this lowercase conversion is used only for comparison. The original case is preserved in the output.

    // Find out if %windir% or %systemroot% is in the target string
    int nWndDir = strTemp.Find(MMC_WINDIR_VARIABLE_PERC);
    int nSysDir = strTemp.Find(MMC_SYSTEMROOT_VARIABLE_PERC);

    if (nWndDir != -1 || nSysDir != -1)
    {
        const UINT cchBuffer = 4096;

        // Get start pos and length of replacement string
        int nStpos = (nWndDir != -1) ? nWndDir : nSysDir;
        int nLen = (nWndDir != -1) ? _tcslen(MMC_WINDIR_VARIABLE_PERC) : _tcslen(MMC_SYSTEMROOT_VARIABLE_PERC);

        // Setup temp variable to hold BUFFERLEN chars
        CStr strRoot;
        LPTSTR szBuffer = strRoot.GetBuffer(cchBuffer);

        if (szBuffer != NULL)
        {
            int iReturn = -1;

            if (nWndDir != -1)
               iReturn = GetWindowsDirectory(szBuffer, cchBuffer);
            else
               iReturn = GetEnvironmentVariable(MMC_SYSTEMROOT_VARIABLE, szBuffer, cchBuffer);

            // release string buffer
            strRoot.ReleaseBuffer();

            // Build up new target string based on environemnt variable.
            if (iReturn != 0)
            {
                strRet =  strTarget.Left(nStpos);
                strRet += strRoot;
                strRet += strTarget.Mid(nStpos + nLen, strTarget.GetLength() - (nStpos + nLen));
            }
        }
    }

    USES_CONVERSION;
    int cchViewType = _tcslen(strRet)+1;
    *ppViewType = (LPOLESTR)CoTaskMemAlloc( cchViewType * sizeof(OLECHAR) );
    *pViewOptions = GetComponentData()->GetDescriptor().GetViewOptions();

    sc = ScCheckPointers(*ppViewType, *pViewOptions);
    if(sc)
        return sc.ToHr();

    sc = StringCchCopyW(*ppViewType, cchViewType, T2COLE(strRet));
    if(sc)
        return sc.ToHr();


    return sc.ToHr();
}

//############################################################################
//############################################################################
//
//  Implementation of class COCXSnapinData
//
//############################################################################
//############################################################################
STDMETHODIMP
COCXSnapinData::CreateComponent(LPCOMPONENT* ppComponent)
{
    typedef CComObject<COCXSnapinComponent> CComponent;
    CComponent *    pComponent = NULL;
    CComObject<COCXSnapinComponent>::CreateInstance(&pComponent);
    ASSERT(pComponent != NULL);
    if(pComponent == NULL)
    {
        //TraceError(TEXT("COCXSnapinData::CreateComponent"));
        return E_UNEXPECTED;
    }

    pComponent->Init(this);

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent); // does the Addref.
}


COCXSnapinData::COCXSnapinData()
{
    m_pActiveXPage0 = NULL;
    m_pActiveXPage1 = NULL;
    m_pActiveXPage2 = NULL;
    m_iImage     = eStockImage_OCX;
    m_iOpenImage = eStockImage_OCX;
}

COCXSnapinData::~COCXSnapinData()
{
}

STDMETHODIMP
COCXSnapinData::Destroy()
{
    if(m_pActiveXPage0 != NULL)
    {
        delete m_pActiveXPage0;
        m_pActiveXPage0 = NULL;
    }
    if(m_pActiveXPage1 != NULL)
    {
        delete m_pActiveXPage1;
        m_pActiveXPage1 = NULL;
    }
    if(m_pActiveXPage2 != NULL)
    {
        delete m_pActiveXPage2;
        m_pActiveXPage2 = NULL;
    }

    return BC::Destroy();
}

const CLSID       CLSID_OCXSnapin         = {0xC96401CF, 0x0E17,0x11D3, {0x88,0x5B,0x00,0xC0,0x4F,0x72,0xC7,0x17}};
static const GUID GUID_OCXSnapinNodetype  = {0xc96401d0, 0xe17, 0x11d3, { 0x88, 0x5b, 0x0, 0xc0, 0x4f, 0x72, 0xc7, 0x17 } };
static LPCTSTR szClsid_OCXSnapin          = TEXT("{C96401CF-0E17-11D3-885B-00C04F72C717}");
static LPCTSTR szGuidOCXSnapinNodetype    = TEXT("{C96401D0-0E17-11D3-885B-00C04F72C717}");


CSnapinDescriptor &
COCXSnapinData::GetSnapinDescriptor()
{
    static CSnapinDescriptor snapinDescription(IDS_ACTIVEXCONTROL,
                   IDS_OCXSNAPIN_DESC, IDI_OCX, IDB_OCX_16, IDB_OCX_16, IDB_OCX_32,
                   CLSID_OCXSnapin, szClsid_OCXSnapin, GUID_OCXSnapinNodetype,
                   szGuidOCXSnapinNodetype, TEXT("OCX"), TEXT("Snapins.OCXSnapin"),
                   TEXT("Snapins.OCXSnapin.1"), MMC_VIEW_OPTIONS_NOLISTVIEWS  /*viewOptions*/ );
    return snapinDescription;
}

// IExtendPropertySheet2
STDMETHODIMP
COCXSnapinData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpIDataObject)
{
    HPROPSHEETPAGE hPage;

    ASSERT(lpProvider != NULL);
    if(lpProvider == NULL)
    {
        //TraceError(TEXT("CHTMLSnapinData::CreatePropertyPages"));
        return E_UNEXPECTED;
    }

    ASSERT(m_pActiveXPage0 == NULL);
    ASSERT(m_pActiveXPage1 == NULL);
    ASSERT(m_pActiveXPage2 == NULL);

    // create property pages
    m_pActiveXPage0 = new CActiveXPage0;
    m_pActiveXPage1 = new CActiveXPage1;
    m_pActiveXPage2 = new CActiveXPage2;

    // pass in pointer to data structure
    m_pActiveXPage0->Initialize(this);
    m_pActiveXPage1->Initialize(this);
    m_pActiveXPage2->Initialize(this);

    // Add Pages to property sheet
    hPage=CreatePropertySheetPage(&m_pActiveXPage0->m_psp);
    lpProvider->AddPage(hPage);

    hPage=CreatePropertySheetPage(&m_pActiveXPage1->m_psp);
    lpProvider->AddPage(hPage);

    hPage=CreatePropertySheetPage(&m_pActiveXPage2->m_psp);
    lpProvider->AddPage(hPage);

    return S_OK;
}

//############################################################################
//############################################################################
//
//  Implementation of class COCXSnapinComponent
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * COCXSnapinComponent::Notify
 *
 * PURPOSE: Implements the CComponent::Notify method
 *
 * PARAMETERS:
 *    LPDATAOBJECT     lpDataObject :
 *    MMC_NOTIFY_TYPE  event :
 *    LPARAM           arg :
 *    LPARAM           param :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
COCXSnapinComponent::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    switch(event)
    {
    // Handle just the OCX initialization notify
    case MMCN_INITOCX:
        return OnInitOCX(lpDataObject, arg, param);
        break;

    default:
        // Pass other notifications on to base class
        return CSnapinComponentImpl::Notify(lpDataObject, event, arg, param);
        break;
    }

    return hr;
}


/*+-------------------------------------------------------------------------*
 *
 * COCXSnapinComponent::OnInitOCX
 *
 * PURPOSE: Handles the MMCN_INITOCX message.
 *
 * PARAMETERS:
 *    LPDATAOBJECT  lpDataObject :
 *    LPARAM        arg :
 *    LPARAM        param :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
COCXSnapinComponent::OnInitOCX(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    ASSERT(param != NULL);
    IUnknown* pUnknown = reinterpret_cast<IUnknown*>(param);

    ASSERT(m_bLoaded || m_bInitialized);

    // Load or initialze the OCX
    if (m_bLoaded || m_bInitialized)
    {
        IPersistStreamInitPtr spIPStmInit;

        // Query for stream support
        m_spIPStm = pUnknown;

        // if none, try streamInit
        if (m_spIPStm == NULL)
        {
            spIPStmInit = pUnknown;

            // if streamInit found, cast to normal stream pointer
            // so common methods can be called from single pointer
            if (spIPStmInit != NULL)
                m_spIPStm = (IPersistStream*)spIPStmInit.GetInterfacePtr();
        }

        // if either type of stream persistance supported
        if (m_spIPStm != NULL)
        {
            // if load method was called, then ask OCX to load from inner stream
            // Note that inner stream will not exist if OCX was never created
            if (m_bLoaded)
            {
                IStreamPtr spStm;
                HRESULT hr2 = m_spStg->OpenStream(SZ_OCXSTREAM, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, NULL, &spStm);

                if (SUCCEEDED(hr2))
                    hr = m_spIPStm->Load(spStm);
                else
                    m_bLoaded = FALSE;
            }

            // if no load was done and OCX requires an InitNew, give it one now
            if (!m_bLoaded && spIPStmInit != NULL)
                hr = spIPStmInit->InitNew();
        }
        else
        {
            // Query for storage support
            m_spIPStg = pUnknown;

            // if storage supported, ask OCX to load from inner storage
            // Note that inner storage will not exist if OCX was never created
            if (m_spIPStg != NULL)
            {
                if (m_bLoaded)
                {
                    ASSERT(m_spStgInner == NULL);
                    HRESULT hr2 = m_spStg->OpenStorage(SZ_OCXSTORAGE, NULL, STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                                        NULL, NULL, &m_spStgInner);
                    if (SUCCEEDED(hr2))
                        hr = m_spIPStg->Load(m_spStgInner);
                    else
                        m_bLoaded = FALSE;
                }

                // if no load done, create an inner storage and init from it
                if (!m_bLoaded)
                {
                    ASSERT(m_spStgInner == NULL);
                    hr = m_spStg->CreateStorage(SZ_OCXSTORAGE, STGM_READWRITE|STGM_SHARE_EXCLUSIVE, NULL,
                                                        NULL, &m_spStgInner);
                    if (SUCCEEDED(hr))
                        hr = m_spIPStg->InitNew(m_spStgInner);
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP COCXSnapinComponent::InitNew(IStorage* pStg)
{
    if (pStg == NULL)
        return E_POINTER;

    if (m_bInitialized)
        return CO_E_ALREADYINITIALIZED;

    // Hold onto storage
    m_spStg = pStg;
    m_bInitialized = TRUE;

    return S_OK;
}


HRESULT COCXSnapinComponent::Load(IStorage* pStg)
{
    if (pStg == NULL)
        return E_POINTER;

    if (m_bInitialized)
        return CO_E_ALREADYINITIALIZED;

    // Hold onto storage
    m_spStg = pStg;
    m_bLoaded = TRUE;
    m_bInitialized = TRUE;

    return S_OK;
}


HRESULT COCXSnapinComponent::IsDirty()
{
    HRESULT hr = S_FALSE;

    if (m_spIPStm != NULL)
    {
        hr = m_spIPStm->IsDirty();
    }
    else if (m_spIPStg != NULL)
    {
        hr = m_spIPStg->IsDirty();
    }

    return hr;
}


HRESULT COCXSnapinComponent::Save(IStorage* pStg, BOOL fSameAsLoad)
{
    DECLARE_SC(sc, TEXT("COCXSnapinComponent::Save"));

    // parameter check
    sc = ScCheckPointers( pStg );
    if (sc)
        return sc.ToHr();

    // to be able to save we need to be initialized
    sc = ScCheckPointers( m_spStg, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    // if need to use the new storage - make a copy 
    if (!fSameAsLoad)
    {
        sc = m_spStg->CopyTo(0, NULL, NULL, pStg);
        if (sc)
            return sc.ToHr();

        // release cached storage (in case we have it) - it must change
        m_spStgInner = NULL;

        // hold onto the new storage
        m_spStg = pStg;

        // assignment uses QI - recheck!
        sc = ScCheckPointers( m_spStg, E_UNEXPECTED );
        if (sc)
            return sc.ToHr();
    }

    // if storage support, ask OCX to save to inner storage
    if (m_spIPStg)
    {
        bool bSameStorageForSnapin = true;
        // if saving to different storage, create new inner storage on it and pass to OCX
        if ( m_spStgInner == NULL )
        {
            sc = pStg->CreateStorage(SZ_OCXSTORAGE, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, NULL, NULL, &m_spStgInner);
            if (sc)
                return sc.ToHr();

            bSameStorageForSnapin = false;
        }

        // recheck the pointer 
        sc = ScCheckPointers( m_spStgInner, E_UNEXPECTED );
        if (sc)
            return sc.ToHr();

        // save to the storage
        sc = m_spIPStg->Save( m_spStgInner, (fSameAsLoad && bSameStorageForSnapin) );
        if (sc)
            return sc.ToHr();
    }
    // else if stream support, create/open stream and save to it
    else if (m_spIPStm)
    {
        // if stream support, create internal stream and pass to OCX
        IStreamPtr spStm;
        sc = m_spStg->CreateStream(SZ_OCXSTREAM, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, NULL, NULL, &spStm);
        if (sc)
            return sc.ToHr();

        sc = m_spIPStm->Save(spStm, TRUE);
        if (sc)
            return sc.ToHr();
    }
    else
    {
        // we are here if the OCX was never created (i.e., this component never owned the result pane)
        // if node was loaded and has to save to a new file, just copy the current storage to the new one
    }

    return sc.ToHr();
}


HRESULT COCXSnapinComponent::HandsOffStorage()
{
    // Release storage if holding ref
    // if ocx is holding storage, forward call to it
    if (m_spIPStg != NULL && m_spStgInner != NULL)
        m_spIPStg->HandsOffStorage();

    // Free our own refs
    m_spStgInner = NULL;
    m_spStg = NULL;

    return S_OK;
}


HRESULT COCXSnapinComponent::SaveCompleted(IStorage* pStgNew)
{
    HRESULT hr = S_OK;

    if (m_spIPStg != NULL)
    {
        // if new storage provided
        if (pStgNew != NULL && pStgNew != m_spStg)
        {
            // Create new inner storage and give to OCX
            IStoragePtr spStgInner;
            hr = pStgNew->CreateStorage(SZ_OCXSTORAGE, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, NULL, NULL, &spStgInner);
            if (SUCCEEDED(hr))
                hr = m_spIPStg->SaveCompleted(spStgInner);

            // Free current inner storage and hold onto new one
            m_spStgInner = spStgInner;
        }
        else
        {
            m_spIPStg->SaveCompleted(NULL);
        }
    }

    if (pStgNew != NULL)
        m_spStg = pStgNew;

    return hr;
}


HRESULT COCXSnapinComponent::GetClassID(CLSID *pClassID)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\fldrsnap.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:       fldrsnap.h
 *
 *  Contents:   Header file for built-in snapins that implement
 *              the Folder, ActiveX Control, and Web Link nodes.
 *                  These replace earlier code that had special "built-in"
 *              nodetypes.
 *
 *  History:    23-Jul-98 vivekj     Created
 *
 *--------------------------------------------------------------------------*/
#ifndef __FOLDERSNAPIN_H_
#define __FOLDERSNAPIN_H_

extern const CLSID CLSID_FolderSnapin;
extern const CLSID CLSID_OCXSnapin;
extern const CLSID CLSID_HTMLSnapin;

extern LPCTSTR szClsid_FolderSnapin;
extern LPCTSTR szClsid_HTMLSnapin;
extern LPCTSTR szClsid_OCXSnapin;


// forward decls
class CHTMLPage1;
class CHTMLPage2;

class CActiveXPage0;
class CActiveXPage1;
class CActiveXPage2;

HRESULT WINAPI IPersistStreamFunc(void* pv, REFIID riid, LPVOID* ppv, DWORD dw);

SC ScFormatIndirectSnapInName (
	HINSTANCE	hInst,					/* I:module containing the resource	*/
	int			idNameString,			/* I:ID of name's string resource	*/
	CStr&		strName);				/* O:formatted indirect name string	*/


/*+-------------------------------------------------------------------------*
 * Class:      CSnapinDescriptor
 *
 * PURPOSE:    A class that contains information to be filled in by
 *             derived snap-ins.
 *
 *+-------------------------------------------------------------------------*/
class CSnapinDescriptor
{
private:
    UINT    m_idsName;
    UINT    m_idsDescription;
    UINT    m_idbSmallImage;
    UINT    m_idbSmallImageOpen;
    UINT    m_idbLargeImage;
    long    m_viewOptions;              // for GetResultViewType
    UINT    m_idiSnapinImage;           // the icon used by ISnapinAbout

public:
    const   CLSID & m_clsidSnapin;      // the snapin class ID
    const   LPCTSTR m_szClsidSnapin;
    const   GUID &  m_guidNodetype;     // root node type
    const   LPCTSTR m_szGuidNodetype;

    const   LPCTSTR m_szClassName;
    const   LPCTSTR m_szProgID;
    const   LPCTSTR m_szVersionIndependentProgID;


public:
    CSnapinDescriptor();
    CSnapinDescriptor(UINT idsName, UINT idsDescription, UINT idiSnapinImage, UINT idbSmallImage, 
                      UINT idbSmallImageOpen, UINT idbLargeImage,
               const CLSID &clsidSnapin, LPCTSTR szClsidSnapin,
               const GUID &guidNodetype, LPCTSTR szGuidNodetype,
               LPCTSTR szClassName, LPCTSTR szProgID, LPCTSTR szVersionIndependentProgID,
               long viewOptions);

    void    GetName(CStr &str);
    void    GetRegisteredDefaultName(CStr &str);
    void    GetRegisteredIndirectName(CStr &str);
    UINT    GetDescription()        {return m_idsDescription;}
    UINT    GetSmallImage()         {return m_idbSmallImage;}
    UINT    GetSmallImageOpen()     {return m_idbSmallImageOpen;}
    UINT    GetLargeImage()         {return m_idbLargeImage;}
    long    GetViewOptions();
    UINT    GetSnapinImage()        {return m_idiSnapinImage;}
};

/*+-------------------------------------------------------------------------*
 * class CSnapinComponentDataImpl
 *
 *
 * PURPOSE: Implements IComponentData for the built-in snapins.
 *
 *+-------------------------------------------------------------------------*/
class CSnapinComponentDataImpl :
    public IComponentData,
    public CComObjectRoot,
    public ISnapinAbout,
    public ISnapinHelp,
    public IPersistStream,
    public IExtendPropertySheet2,
    public CSerialObjectRW
{
    friend class CSnapinComponentImpl;
public:

    CSnapinComponentDataImpl();
    virtual  CSnapinDescriptor&  GetDescriptor() = 0;

    // IComponentData
    STDMETHODIMP Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event,
                   LPARAM arg, LPARAM param);
    STDMETHODIMP Destroy();
    STDMETHODIMP QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                            LPDATAOBJECT* ppDataObject);
    STDMETHODIMP GetDisplayInfo( SCOPEDATAITEM* pScopeDataItem);
    STDMETHODIMP CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    // IPersistStream
    STDMETHODIMP GetClassID(CLSID *pClassID);
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(LPSTREAM pStm);
    STDMETHODIMP Save(LPSTREAM pStm , BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize  );

    // ISnapinHelp
    STDMETHODIMP GetHelpTopic (LPOLESTR* ppszCompiledHelpFile);

    // IExtendPropertySheet2
    STDMETHODIMP CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpIDataObject) = 0;
    STDMETHODIMP GetWatermarks(LPDATAOBJECT lpIDataObject, HBITMAP * lphWatermark, HBITMAP * lphHeader, HPALETTE * lphPalette,  BOOL* bStretch);
    STDMETHODIMP QueryPagesFor(LPDATAOBJECT lpDataObject);

    // override
    virtual      UINT GetHeaderBitmap() {return 0;}
    virtual      UINT GetWatermark() {return 0;}

    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion);
    virtual HRESULT WriteSerialObject(IStream &stm);

protected:
    HRESULT         OnPreload(HSCOPEITEM scopeItem);


private: // attributes - not persisted
    IConsole2Ptr                m_spConsole2;
    IConsoleNameSpace2Ptr       m_spConsoleNameSpace2;
    bool                        m_bDirty;
protected:
    UINT                        m_iImage;
    UINT                        m_iOpenImage;

    void SetDirty(BOOL bState = TRUE) { m_bDirty = bState; }

private: // attributes - persisted
    CStringTableString  m_strName;  // the name of the root node, which is the only node created by the snapin
    CStringTableString  m_strView;  // the view displayed by the node.

public:
    void         SetName(LPCTSTR sz);
    LPCTSTR      GetName() {return m_strName.data();}
    void         SetView(LPCTSTR sz);
    LPCTSTR      GetView() {return m_strView.data();}
};

/*+-------------------------------------------------------------------------*
 * class CSnapinComponentImpl
 *
 *
 * PURPOSE: Implements IComponent for the built-in snapins.
 *
 *+-------------------------------------------------------------------------*/
class CSnapinComponentImpl : public CComObjectRoot, public IComponent
{
public:
BEGIN_COM_MAP(CSnapinComponentImpl)
    COM_INTERFACE_ENTRY(IComponent)
END_COM_MAP()

    void  Init(IComponentData *pComponentData);

    // IComponent
    STDMETHODIMP Initialize(LPCONSOLE lpConsole);
    STDMETHODIMP Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event,
                   LPARAM arg, LPARAM param);
    STDMETHODIMP Destroy(MMC_COOKIE cookie);
    STDMETHODIMP QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                            LPDATAOBJECT* ppDataObject);
    STDMETHODIMP GetResultViewType(MMC_COOKIE cookie, LPOLESTR* ppViewType,
                              long* pViewOptions);
    STDMETHODIMP GetDisplayInfo( RESULTDATAITEM*  pResultDataItem);
    STDMETHODIMP CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

protected:
    CSnapinComponentDataImpl *  GetComponentData();

protected:
    virtual SC                  ScOnSelect(BOOL bScope, BOOL bSelect);

protected: // attributes - not persisted
    IConsole2Ptr                m_spConsole2;
    IComponentDataPtr           m_spComponentData;
};

/*+-------------------------------------------------------------------------*
 * class CSnapinDataObject
 *
 *
 * PURPOSE: Implements IDataObject for the built-in snapins.
 *
 *+-------------------------------------------------------------------------*/
class CSnapinDataObject : public CComObjectRoot, public IDataObject
{
public:
BEGIN_COM_MAP(CSnapinDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

    CSnapinDataObject();

    // IDataObject
    STDMETHODIMP GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
private:
    STDMETHODIMP GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium){ return E_NOTIMPL; };
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc){ return E_NOTIMPL; };
    STDMETHODIMP QueryGetData(LPFORMATETC lpFormatetc) { return E_NOTIMPL; };
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut){ return E_NOTIMPL; };
    STDMETHODIMP SetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease){ return E_NOTIMPL; };
    STDMETHODIMP DAdvise(LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection){ return E_NOTIMPL; };
    STDMETHODIMP DUnadvise(DWORD dwConnection){ return E_NOTIMPL; };
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA* ppEnumAdvise){ return E_NOTIMPL; };

    HRESULT      WriteString(IStream *pStream, LPCOLESTR sz);

public:
    void              Initialize(IComponentData *pComponentData, DATA_OBJECT_TYPES type);
    DATA_OBJECT_TYPES GetType() const {return m_type;}

private:
    bool              m_bInitialized;
    IComponentDataPtr m_spComponentData;    // back pointer to the parent.
    DATA_OBJECT_TYPES m_type;

// Clipboard formats that are required by the console
    static void       RegisterClipboardFormats();
    static UINT       s_cfNodeType;
    static UINT       s_cfNodeTypeString;
    static UINT       s_cfDisplayName;
    static UINT       s_cfCoClass;
    static UINT       s_cfSnapinPreloads;


};


SC ScLoadAndAllocateString(UINT ids, LPOLESTR *lpstrOut);

/*+-------------------------------------------------------------------------*
 * class CSnapinWrapper
 *
 *
 * PURPOSE: A template class, used to instantiate the snapin.
 *
 *+-------------------------------------------------------------------------*/
template <class CSnapin, const CLSID *pCLSID_Snapin>
class CSnapinWrapper : public CSnapin, public CComCoClass<CSnapin, pCLSID_Snapin>
{
    typedef CSnapinWrapper<CSnapin, pCLSID_Snapin> ThisClass;

BEGIN_COM_MAP(ThisClass)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(ISnapinAbout)
    COM_INTERFACE_ENTRY(ISnapinHelp)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IExtendPropertySheet2)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(ThisClass)

    // registry
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
    {
        USES_CONVERSION;

        CStr strName;
        GetSnapinDescriptor().GetRegisteredDefaultName (strName);

        CStr strIndirectName;
        GetSnapinDescriptor().GetRegisteredIndirectName (strIndirectName);

        _ATL_REGMAP_ENTRY rgEntries[] =
        {
            { L"VSnapinClsid",              T2COLE(          GetSnapinDescriptor().m_szClsidSnapin)},
            { L"VNodetype",                 T2COLE(          GetSnapinDescriptor().m_szGuidNodetype)},
            { L"VSnapinName",               T2COLE((LPCTSTR) strName)},
            { L"VSnapinNameIndirect",       T2COLE((LPCTSTR) strIndirectName)},
            { L"VClassName",                T2COLE(          GetSnapinDescriptor().m_szClassName)},
            { L"VProgID",                   T2COLE(          GetSnapinDescriptor().m_szProgID)},
            { L"VVersionIndependentProgID", T2COLE(          GetSnapinDescriptor().m_szVersionIndependentProgID)},
            { L"VFileName",                 T2COLE(          g_szMmcndmgrDll)},
            {NULL, NULL}
        };

        return _Module.UpdateRegistryFromResource(IDR_FOLDERSNAPIN, bRegister, rgEntries);
    }

    

    STDMETHODIMP GetSnapinDescription(LPOLESTR* lpDescription)
    {
        DECLARE_SC(sc, TEXT("CSnapinWrapper::GetSnapinDescription"));
        
        sc = ScLoadAndAllocateString(GetSnapinDescriptor().GetDescription(), lpDescription);
        return sc.ToHr();
    }

    STDMETHODIMP GetProvider(LPOLESTR* lpDescription)
    {
        DECLARE_SC(sc, TEXT("CSnapinWrapper::GetProvider"));
        
        sc = ScLoadAndAllocateString(IDS_BUILTIN_SNAPIN_PROVIDER, lpDescription);
        return sc.ToHr();
    }

    STDMETHODIMP GetSnapinVersion(LPOLESTR* lpDescription)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP GetSnapinImage(HICON* hAppIcon)
    {
        DECLARE_SC (sc, TEXT("CSnapinWrapper::GetSnapinImage"));

        sc = ScCheckPointers(hAppIcon);
        if(sc)
            return sc.ToHr();
    
        if(!m_hIconSnapinImage)
            LoadIcon( _Module.GetModuleInstance(), MAKEINTRESOURCE(GetDescriptor().GetSnapinImage()));

        *hAppIcon = m_hIconSnapinImage;
    
        return sc.ToHr();
    }

    STDMETHODIMP GetStaticFolderImage(HBITMAP* hSmallImage, HBITMAP* hSmallImageOpen,
                                               HBITMAP* hLargeImage, COLORREF* cMask)
    {
        DECLARE_SC (sc, TEXT("CSnapinWrapper::GetStaticFolderImage"));

        sc = ScCheckPointers(hSmallImage, hSmallImageOpen, hLargeImage, cMask);
        if(sc)
            return sc.ToHr();

        if(!m_bmpSmallImage)
            m_bmpSmallImage.LoadBitmap(MAKEINTRESOURCE(GetDescriptor().GetSmallImage()));

        if(!m_bmpSmallImageOpen)
            m_bmpSmallImageOpen.LoadBitmap(MAKEINTRESOURCE(GetDescriptor().GetSmallImageOpen()));

        if(!m_bmpLargeImage)
            m_bmpLargeImage.LoadBitmap(MAKEINTRESOURCE(GetDescriptor().GetLargeImage()));

        *hSmallImage     = m_bmpSmallImage;
        *hSmallImageOpen = m_bmpSmallImageOpen;
        *hLargeImage     = m_bmpLargeImage;
        *cMask           = RGB(255, 0, 255);

        return sc.ToHr();
    }


    virtual  CSnapinDescriptor&  GetDescriptor()
    {
        return GetSnapinDescriptor();
    }

    CSnapinWrapper() : m_hIconSnapinImage(NULL)
    {
        CStr strName;
        GetDescriptor().GetName(strName);
        SetName(strName);
    }

private:

    HICON        m_hIconSnapinImage;
    WTL::CBitmap m_bmpSmallImage;       // these are smart handles.
    WTL::CBitmap m_bmpSmallImageOpen;
    WTL::CBitmap m_bmpLargeImage;
};

//____________________________________________________________________________
//
//  Class:      CFolderSnapinData
//
//  PURPOSE:
//____________________________________________________________________________
//
class CFolderSnapinData : public CSnapinComponentDataImpl
{
    typedef CSnapinComponentDataImpl BC;
public:

    CFolderSnapinData();

    // IComponentData
    STDMETHODIMP CreateComponent(LPCOMPONENT* ppComponent);

    // IExtendPropertySheet2
    STDMETHODIMP CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpIDataObject);

    void SetDirty(BOOL bState = TRUE) { BC::SetDirty(bState); }

    static CSnapinDescriptor&  GetSnapinDescriptor();
};

typedef CSnapinWrapper<CFolderSnapinData, &CLSID_FolderSnapin> CFolderSnapin;

//____________________________________________________________________________
//
//  Class:      CFolderSnapinComponent
//
//  PURPOSE:
//____________________________________________________________________________
//
class CFolderSnapinComponent : public CSnapinComponentImpl
{
};

//____________________________________________________________________________
//
//  Class:      CHTMLSnapinData
//
//  PURPOSE:
//____________________________________________________________________________
//
class CHTMLSnapinData : public CSnapinComponentDataImpl
{
    typedef CSnapinComponentDataImpl BC;
public:

    CHTMLSnapinData();
    ~CHTMLSnapinData();

    // IComponentData
    STDMETHODIMP CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP Destroy();

    // IExtendPropertySheet2
    STDMETHODIMP CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpIDataObject);

    virtual      UINT GetWatermark() {return IDB_SETUPWIZARD1;}


    static CSnapinDescriptor&  GetSnapinDescriptor();

private:
    CHTMLPage1 *m_pHtmlPage1;
    CHTMLPage2 *m_pHtmlPage2;
};

typedef CSnapinWrapper<CHTMLSnapinData, &CLSID_HTMLSnapin> CHTMLSnapin;

//____________________________________________________________________________
//
//  Class:      CHTMLSnapinComponent
//
//  PURPOSE:
//____________________________________________________________________________
//
class CHTMLSnapinComponent : public CSnapinComponentImpl
{
    typedef CSnapinComponentImpl BC;
public:
    virtual SC   ScOnSelect(BOOL bScope, BOOL bSelect);

    STDMETHODIMP GetResultViewType(MMC_COOKIE cookie, LPOLESTR* ppViewType,
                              long* pViewOptions);

};

//____________________________________________________________________________
//
//  Class:      COCXSnapinData
//
//  PURPOSE:
//____________________________________________________________________________
//
class COCXSnapinData : public CSnapinComponentDataImpl
{
    typedef CSnapinComponentDataImpl BC;
public:

    COCXSnapinData();
    ~COCXSnapinData();

    // IComponentData
    STDMETHODIMP CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP Destroy();

    // IExtendPropertySheet2
    STDMETHODIMP CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpIDataObject);

    virtual      UINT GetHeaderBitmap() {return IDB_OCX_WIZARD_HEADER;}
    virtual      UINT GetWatermark()    {return IDB_SETUPWIZARD;}


    static CSnapinDescriptor&  GetSnapinDescriptor();

private:
    CActiveXPage0* m_pActiveXPage0;
    CActiveXPage1* m_pActiveXPage1;
    CActiveXPage2* m_pActiveXPage2;

};

typedef CSnapinWrapper<COCXSnapinData, &CLSID_OCXSnapin> COCXSnapin;

//____________________________________________________________________________
//
//  Class:      COCXSnapinComponent
//
//  PURPOSE:
//____________________________________________________________________________
//
class COCXSnapinComponent : public CSnapinComponentImpl, IPersistStorage
{
public:
    COCXSnapinComponent() : m_bLoaded(FALSE), m_bInitialized(FALSE) {}

    BEGIN_COM_MAP(COCXSnapinComponent)
        COM_INTERFACE_ENTRY(IPersistStorage)
        COM_INTERFACE_ENTRY_CHAIN(CSnapinComponentImpl)
    END_COM_MAP()

    // IPersistStorage
    STDMETHODIMP HandsOffStorage();
    STDMETHODIMP InitNew(IStorage* pStg);
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStorage* pStg);
    STDMETHODIMP Save(IStorage* pStg, BOOL fSameAsLoad);
    STDMETHODIMP SaveCompleted(IStorage* pStgNew);
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IComponenent override
    STDMETHODIMP Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event,
                        LPARAM arg, LPARAM param);

protected:
    STDMETHODIMP OnInitOCX(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);

private:
    IStoragePtr         m_spStg;        // Storage provided by MMC
    IStoragePtr         m_spStgInner;   // Nested storage given to OCX

    IPersistStreamPtr   m_spIPStm;      // Persist interfaces from OCX
    IPersistStoragePtr  m_spIPStg;      // only one will be used

    BOOL                m_bLoaded;      // MMC called Load
    BOOL                m_bInitialized; // MMC called InitNew
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\helparr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       HelpArr.h
//
//  Resource file: \\kernel\razzle2\src\admin\activec\nodemgr\nodemgr.rc
//
//  Help file: mmc.hlp
//
//  Help Source file: mmcnd_cs.rtf
//
//  Help IDs file:	mmcndmgr.h
//
//  Authored:	John Mikesell (a-jmike) 06/08/99
//--------------------------------------------------------------------------

#ifndef _HELPARR_H_
#define _HELPARR_H_

#ifndef IDH_DISABLEHELP
#define IDH_DISABLEHELP	((DWORD)-1)
#endif

#define IDH_ACTIVEX_PROPPAGE1_DISPLAYTX	1001
#define IDH_COLUMNS_COLUMNS_ADD_BTN	1002
#define IDH_COLUMNS_COLUMNS_DISPLAYED_LIST	1003
#define IDH_COLUMNS_COLUMNS_HIDDEN_LIST	1004
#define IDH_COLUMNS_COLUMNS_MOVEDOWN_BTN	1005
#define IDH_COLUMNS_COLUMNS_MOVEUP_BTN	1006
#define IDH_COLUMNS_COLUMNS_REMOVE_BTN	1007
#define IDH_COLUMNS_COLUMNS_RESET_BTN	1008
#define IDH_CUSTOMIZE_VIEW_CUST_CONSOLE_TREE	1009
#define IDH_CUSTOMIZE_VIEW_CUST_DESC_BAR	1010
#define IDH_CUSTOMIZE_VIEW_CUST_SNAPIN_BUTTONS	1011
#define IDH_CUSTOMIZE_VIEW_CUST_SNAPIN_MENUS	1012
#define IDH_CUSTOMIZE_VIEW_CUST_STATUS_BAR	1013
#define IDH_CUSTOMIZE_VIEW_CUST_STD_BUTTONS	1014
#define IDH_CUSTOMIZE_VIEW_CUST_STD_MENUS	1015
#define IDH_CUSTOMIZE_VIEW_CUST_TASKPAD_TABS	1016
#define IDH_HTML_PROPPAGE1_CHANGEICONBT	1019
#define IDH_HTML_PROPPAGE1_DISPLAYTX	1020
#define IDH_HTML_PROPPAGE1_FINDTARGETBT	1021
#define IDH_HTML_PROPPAGE1_TARGETTX	1022
#define IDH_MONITOR_PROPPAGE1_CTRLPROPERTIES	1023
#define IDH_NOPROPS_PROPPAGE_NOPROPS	1024
#define IDH_ORDER_DIALOG_LIST	1025
#define IDH_ORDER_DIALOG_MOVE_DOWN	1026
#define IDH_ORDER_DIALOG_MOVE_UP	1027
#define IDH_RETARGET_TASKPAD_RetargetRootTree	1028
#define IDH_SHORTCUT_PROPPAGE1_CHANGEICONBT	1029
#define IDH_SHORTCUT_PROPPAGE1_FINDTARGETBT	1030
#define IDH_SHORTCUT_PROPPAGE1_RUNTX	1031
#define IDH_SHORTCUT_PROPPAGE1_STARTINTX	1032
#define IDH_SHORTCUT_PROPPAGE1_TARGETTX	1033
#define IDH_SNAPIN_ABOUT_COMPANY_NAME	1034
#define IDH_SNAPIN_ABOUT_DESCRIPTION	1035
#define IDH_SNAPIN_ABOUT_SNAPIN_NAME	1036
#define IDH_SNAPIN_ABOUT_VERSION	1037
#define IDH_SNAPIN_DESCR	1038
#define IDH_SNAPIN_EXTENSION_PROPP_EXTENSION_LIST	1039
#define IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_ABOUT	1040
#define IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_COMBOEX	1041
#define IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_DESCR	1042
#define IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_ENABLEALL	1043
#define IDH_SNAPIN_MANAGER_ADD_SNAPIN_LV	1044
#define IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_ABOUT	1045
#define IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_ADDED_LIST	1046
#define IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_COMBOEX	1047
#define IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_DESCR	1048
#define IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_MANAGER_ADD	1049
#define IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_MANAGER_DELETE	1050
#define IDH_SNAPIN_STANDALONE_PROPP_TOOLBAR	1051
#define IDH_TASK_PROPS_CMDLINE_PAGE_BrowseForArguments	1052
#define IDH_TASK_PROPS_CMDLINE_PAGE_BrowseForCommand	1053
#define IDH_TASK_PROPS_CMDLINE_PAGE_BrowseForWorkingDir	1054
#define IDH_TASK_PROPS_CMDLINE_PAGE_Command	1055
#define IDH_TASK_PROPS_CMDLINE_PAGE_CommandArgs	1056
#define IDH_TASK_PROPS_CMDLINE_PAGE_CommandWindowStateCombo	1057
#define IDH_TASK_PROPS_CMDLINE_PAGE_CommandWorkingDir	1058
#define IDH_TASK_PROPS_NAME_PAGE_TaskDescription	1059
#define IDH_TASK_PROPS_NAME_PAGE_TaskName	1060
#define IDH_TASK_PROPS_SYMBOL_PAGE_DESCRIPTION	1061
#define IDH_TASK_PROPS_SYMBOL_PAGE_DESCRIPTION2	1062
#define IDH_TASK_PROPS_SYMBOL_PAGE_GLYPH_LIST	1063
#define IDH_TASKPAD_ADVANCED_DontUseForSimilarNodes	1064
#define IDH_TASKPAD_ADVANCED_SetDefaultForNodetype	1065
#define IDH_TASKPAD_ADVANCED_UseForSimilarNodes	1066
#define IDH_TASKPAD_GENERAL_Options	1067
#define IDH_TASKPAD_GENERAL_STYLE_DESCRIPTION	1068
#define IDH_TASKPAD_GENERAL_Style_HorizontalList	1069
#define IDH_TASKPAD_GENERAL_Style_SizeCombo	1070
#define IDH_TASKPAD_GENERAL_Style_TasksOnly	1071
#define IDH_TASKPAD_GENERAL_Style_TextDesc	1072
#define IDH_TASKPAD_GENERAL_Style_TooltipDesc	1073
#define IDH_TASKPAD_GENERAL_Style_VerticalList	1074
#define IDH_TASKPAD_GENERAL_TASKPAD_DESCRIPTION	1075
#define IDH_TASKPAD_GENERAL_TASKPAD_TITLE	1076
#define IDH_TASKPAD_GENERAL_TaskpadPreview	1077
#define IDH_TASKS_LIST_TASKS	1078
#define IDH_TASKS_MODIFY	1079
#define IDH_TASKS_MOVE_DOWN	1080
#define IDH_TASKS_MOVE_UP	1081
#define IDH_TASKS_NEW_TASK_BT	1082
#define IDH_TASKS_REMOVE_TASK	1083
#define IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_DOWNLOAD 1084
#define IDH_SNAPIN_MANAGER_ADD_SNAPIN_DESCR        1085
#define IDH_Style_HideNormalTab 4162

const DWORD g_aHelpIDs_IDD_SNAPIN_ABOUT[]=	
{	
IDC_APPICON,	IDH_DISABLEHELP,
IDC_COMPANY_NAME,	IDH_SNAPIN_ABOUT_COMPANY_NAME,
IDC_DESCRIPTION,	IDH_SNAPIN_ABOUT_DESCRIPTION,
IDC_LINE,	IDH_DISABLEHELP,
IDC_SNAPIN_NAME,	IDH_SNAPIN_ABOUT_SNAPIN_NAME,
IDC_VERSION,	IDH_SNAPIN_ABOUT_VERSION,
    0, 0	
};	
	
	
const DWORD g_aHelpIDs_IDD_ACTIVEX_PROPPAGE1[]=	
{	
IDC_DISPLAYTX,	IDH_ACTIVEX_PROPPAGE1_DISPLAYTX,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_SHORTCUT_PROPPAGE1[]=	
{	
IDC_TARGETTX,	IDH_SHORTCUT_PROPPAGE1_TARGETTX,
IDC_FINDTARGETBT,	IDH_SHORTCUT_PROPPAGE1_FINDTARGETBT,
IDC_CHANGEICONBT,	IDH_SHORTCUT_PROPPAGE1_CHANGEICONBT,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_HTML_PROPPAGE1[]=	
{	
IDC_DISPLAYTX,	IDH_HTML_PROPPAGE1_DISPLAYTX,
IDC_TARGETTX,	IDH_HTML_PROPPAGE1_TARGETTX,
IDC_FINDTARGETBT,	IDH_HTML_PROPPAGE1_FINDTARGETBT,
IDC_CHANGEICONBT,	IDH_HTML_PROPPAGE1_CHANGEICONBT,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_MONITOR_PROPPAGE1[]=	
{	
IDC_CTRLPROPERTIES,	IDH_MONITOR_PROPPAGE1_CTRLPROPERTIES,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_NOPROPS_PROPPAGE[]=	
{	
IDC_NOPROPS,	IDH_NOPROPS_PROPPAGE_NOPROPS,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_SNAPIN_MANAGER_ADD[]=	
{	
IDC_SNAPIN_LV,	IDH_SNAPIN_MANAGER_ADD_SNAPIN_LV,
IDC_SNAPIN_DESCR,	IDH_SNAPIN_MANAGER_ADD_SNAPIN_DESCR,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_SNAPIN_STANDALONE_PROPP[]=	
{	
IDC_SNAPIN_DESCR,	IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_DESCR,
IDC_SNAPIN_MANAGER_ADD,	IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_MANAGER_ADD,
IDC_SNAPIN_MANAGER_DELETE,	IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_MANAGER_DELETE,
IDC_SNAPIN_ADDED_LIST,	IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_ADDED_LIST,
IDC_SNAPIN_ABOUT,	IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_ABOUT,
IDC_SNAPIN_COMBOEX,	IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_COMBOEX,
IDC_TOOLBAR,	IDH_SNAPIN_STANDALONE_PROPP_TOOLBAR,
IDC_VTHELPER,	IDH_DISABLEHELP,
    0, 0	
};	
	
	
const DWORD g_aHelpIDs_IDD_SNAPIN_EXTENSION_PROPP[]=	
{	
IDC_SNAPIN_LABEL,	IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_COMBOEX,
IDC_SNAPIN_DESCR,	IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_DESCR,
IDC_SNAPIN_ABOUT,	IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_ABOUT,
IDC_SNAPIN_COMBOEX,	IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_COMBOEX,
IDC_SNAPIN_DOWNLOAD,	IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_DOWNLOAD,
IDC_EXTENSION_LIST,	IDH_SNAPIN_EXTENSION_PROPP_EXTENSION_LIST,
IDC_VTHELPER,	        IDH_DISABLEHELP,
IDC_EXTENSION_LABEL,	IDH_SNAPIN_EXTENSION_PROPP_EXTENSION_LIST,
IDC_SNAPIN_ENABLEALL,	IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_ENABLEALL,
    0, 0	
};	
	

// HELP: Gave proper IDs instead of numbers from nodemgr.rc
const DWORD g_aHelpIDs_IDD_COLUMNS[]=	
{	
IDC_HIDDEN_COLUMNS,	IDH_COLUMNS_COLUMNS_HIDDEN_LIST,
IDC_ADD_COLUMNS,	IDH_COLUMNS_COLUMNS_ADD_BTN,
IDC_REMOVE_COLUMNS,	IDH_COLUMNS_COLUMNS_REMOVE_BTN,
IDC_RESTORE_DEFAULT_COLUMNS,	IDH_COLUMNS_COLUMNS_RESET_BTN,
IDC_DISPLAYED_COLUMNS,	IDH_COLUMNS_COLUMNS_DISPLAYED_LIST,
IDC_MOVEUP_COLUMN,	IDH_COLUMNS_COLUMNS_MOVEUP_BTN,
IDC_MOVEDOWN_COLUMN,    IDH_COLUMNS_COLUMNS_MOVEDOWN_BTN,
65535,	                IDH_DISABLEHELP,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_CUSTOMIZE_VIEW[]=	
{	
IDC_CUST_VIEW_CAPTION,             -1,                // prevent help from showing for static text
IDC_CUST_CONSOLE_TREE,	IDH_CUSTOMIZE_VIEW_CUST_CONSOLE_TREE,
IDC_CUST_STD_MENUS,	IDH_CUSTOMIZE_VIEW_CUST_STD_MENUS,
IDC_CUST_STD_BUTTONS,	IDH_CUSTOMIZE_VIEW_CUST_STD_BUTTONS,
IDC_CUST_STATUS_BAR,	IDH_CUSTOMIZE_VIEW_CUST_STATUS_BAR,
IDC_CUST_DESC_BAR,	IDH_CUSTOMIZE_VIEW_CUST_DESC_BAR,
IDC_CUST_TASKPAD_TABS,	IDH_CUSTOMIZE_VIEW_CUST_TASKPAD_TABS,
IDC_CUST_SNAPIN_MENUS,	IDH_CUSTOMIZE_VIEW_CUST_SNAPIN_MENUS,
IDC_CUST_SNAPIN_BUTTONS,IDH_CUSTOMIZE_VIEW_CUST_SNAPIN_BUTTONS,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_ORDER_DIALOG[]=	
{	
IDC_MOVE_UP,	IDH_ORDER_DIALOG_MOVE_UP,
IDC_MOVE_DOWN,	IDH_ORDER_DIALOG_MOVE_DOWN,
    0, 0	
};	
	
		
const DWORD g_aHelpIDs_IDD_TASK_PROPS_CMDLINE_PAGE[]=	
{	
IDC_CommandLabel,	IDH_TASK_PROPS_CMDLINE_PAGE_Command,
IDC_Command,	IDH_TASK_PROPS_CMDLINE_PAGE_Command,
IDC_CommandArgsLabel,	IDH_TASK_PROPS_CMDLINE_PAGE_CommandArgs,
IDC_CommandArgs,	IDH_TASK_PROPS_CMDLINE_PAGE_CommandArgs,
IDC_CommandWorkingDirLabel,	IDH_TASK_PROPS_CMDLINE_PAGE_CommandWorkingDir,
IDC_CommandWorkingDir,	IDH_TASK_PROPS_CMDLINE_PAGE_CommandWorkingDir,
IDC_CommandWindowStateComboLabel,	IDH_TASK_PROPS_CMDLINE_PAGE_CommandWindowStateCombo,
IDC_CommandWindowStateCombo,	IDH_TASK_PROPS_CMDLINE_PAGE_CommandWindowStateCombo,
IDC_BrowseForCommand,	IDH_TASK_PROPS_CMDLINE_PAGE_BrowseForCommand,
IDC_BrowseForArguments,	IDH_TASK_PROPS_CMDLINE_PAGE_BrowseForArguments,
IDC_BrowseForWorkingDir,	IDH_TASK_PROPS_CMDLINE_PAGE_BrowseForWorkingDir,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_TASK_PROPS_NAME_PAGE[]=	
{	
IDC_TaskNameLabel,	IDH_TASK_PROPS_NAME_PAGE_TaskName,
IDC_TaskName,	IDH_TASK_PROPS_NAME_PAGE_TaskName,
IDC_TaskDescription,	IDH_TASK_PROPS_NAME_PAGE_TaskDescription,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_TASK_PROPS_SYMBOL_PAGE[]=	
{	
IDC_DESCRIPTION,	IDH_TASK_PROPS_SYMBOL_PAGE_DESCRIPTION,
IDC_DESCRIPTION2,	IDH_TASK_PROPS_SYMBOL_PAGE_DESCRIPTION2,
IDC_GLYPH_LIST,	IDH_TASK_PROPS_SYMBOL_PAGE_GLYPH_LIST,
    0, 0	
};	
	
	
const DWORD g_aHelpIDs_IDD_TASKPAD_ADVANCED[]=	
{	
IDC_DontUseForSimilarNodes,	IDH_TASKPAD_ADVANCED_DontUseForSimilarNodes,
IDC_UseForSimilarNodes,	IDH_TASKPAD_ADVANCED_UseForSimilarNodes,
IDC_SetDefaultForNodetype,	IDH_TASKPAD_ADVANCED_SetDefaultForNodetype,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_TASKPAD_GENERAL[]=	
{	
IDC_TASKPAD_TITLE,	IDH_TASKPAD_GENERAL_TASKPAD_TITLE,
IDC_TASKPAD_DESCRIPTION,	IDH_TASKPAD_GENERAL_TASKPAD_DESCRIPTION,
IDC_Style_VerticalList,	IDH_TASKPAD_GENERAL_Style_VerticalList,
IDC_Style_HorizontalList,	IDH_TASKPAD_GENERAL_Style_HorizontalList,
IDC_Style_TasksOnly,	IDH_TASKPAD_GENERAL_Style_TasksOnly,
IDC_Style_TextDesc,	IDH_TASKPAD_GENERAL_Style_TextDesc,
IDC_Style_TooltipDesc,	IDH_TASKPAD_GENERAL_Style_TooltipDesc,
IDC_Style_SizeCombo,	IDH_TASKPAD_GENERAL_Style_SizeCombo,
IDC_Options,	IDH_TASKPAD_GENERAL_Options,
IDC_STYLE_DESCRIPTION,	IDH_TASKPAD_GENERAL_STYLE_DESCRIPTION,
IDC_TaskpadPreview,	IDH_TASKPAD_GENERAL_TaskpadPreview,
IDC_Style_HideNormalTab, IDH_Style_HideNormalTab,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_TASKS[]=	
{	
IDC_LIST_TASKS,	IDH_TASKS_LIST_TASKS,
IDC_NEW_TASK_BT,	IDH_TASKS_NEW_TASK_BT,
IDC_REMOVE_TASK,	IDH_TASKS_REMOVE_TASK,
IDC_MODIFY,	IDH_TASKS_MODIFY,
IDC_MOVE_UP,	IDH_TASKS_MOVE_UP,
IDC_MOVE_DOWN,	IDH_TASKS_MOVE_DOWN,
    0, 0	
};	

// Handle context sensitive dialog help for the nodemgr subsystem
void HelpWmHelp(LPHELPINFO pHelpInfo, const DWORD* pHelpIDs);
void HelpContextMenuHelp(HWND hWnd, ULONG_PTR p);

#define CONTEXT_HELP_HANDLER()                                                  \
        MESSAGE_HANDLER   (WM_HELP,         OnWmHelp)                           \
        MESSAGE_HANDLER(WM_CONTEXTMENU,     OnWmContextMenu)                    \


#define IMPLEMENT_CONTEXT_HELP(g_helpIds)                                         \
                                                                                  \
LRESULT OnWmHelp( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )       \
{                                                                                 \
    HelpWmHelp(reinterpret_cast<LPHELPINFO>(lParam), g_helpIds);                  \
    return true;                                                                  \
}                                                                                 \
                                                                                  \
LRESULT OnWmContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled ) \
{                                                                                 \
    HelpContextMenuHelp((HWND)wParam,                                             \
               (ULONG_PTR)(LPVOID) g_helpIds);                                    \
    return TRUE;                                                                  \
}



#endif // _HELPAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\helpdoc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       helpdoc.cpp
//
//--------------------------------------------------------------------------


/*
 * There are two ways by which help collection is recognized dirty. First is if a snapin
 * is added/removed or extension is enabled/disabled, but this is only for this instance
 * of console file.
 * Second is if the modification time of console file is different from modification time
 * of collection. This is because an author may have added/removed a snapin without bringing
 * up help and saves console file. So the modification time on console file is later than
 * collection. Next time he/she opens console file and brings help, the help collection is
 * regenerated.
 */

// mmchelp.cpp : implmentation of the HelpTopics class
//
#include "stdafx.h"
#include "strings.h"
#include "helpdoc.h"
#include "nodemgr.h"
#include "regutil.h"
#include "scopndcb.h"


#ifdef DBG
CTraceTag	tagHelpCollection (_T("Help"), _T(".COL construction"));
#endif


SC   ScGetBaseFileName(LPCWSTR pszFilePath, LPWSTR pszBaseName, int cchBaseName);
BOOL MatchFileTimes(FILETIME& ftime1, FILETIME& ftime2);

HRESULT CHelpDoc::Initialize(HELPDOCINFO* pDocInfo)
{
    ASSERT(pDocInfo != NULL);
    m_pDocInfo = pDocInfo;

    return BuildFilePath();
}


HRESULT CHelpDoc::BuildFilePath()
{
    DECLARE_SC(sc, TEXT("CHelpDoc::BuildFilePath"));
    USES_CONVERSION;

    do // false loop
    {
        // Get temp directory
        DWORD dwRet = GetTempPath(countof(m_szFilePath), m_szFilePath);
        if (dwRet == 0 || dwRet > MAX_PATH)
            break;

        // Make sure that the temp path exists and it is a dir
        dwRet = GetFileAttributes(m_szFilePath);
        if ( (0xFFFFFFFF == dwRet) || !(FILE_ATTRIBUTE_DIRECTORY & dwRet) )
            break;

        // Get base name of console file (if no name use "default")
        WCHAR szBaseName[MAX_PATH];
        int cchBaseName = MAX_PATH;

        if (m_pDocInfo->m_pszFileName && m_pDocInfo->m_pszFileName[0])
        {
			TCHAR szShortFileName[MAX_PATH] = {0};
			if ( 0 == GetShortPathName( OLE2CT( m_pDocInfo->m_pszFileName ), szShortFileName, countof(szShortFileName)) )
            {
				sc = StringCchCopyW(szBaseName, cchBaseName, L"default"); // Does not need to be localized
                if(sc)
                    return sc.ToHr();
            }
			else
				sc = ScGetBaseFileName( T2CW(szShortFileName), szBaseName, countof(szBaseName));
                if(sc)
                    return sc.ToHr();
        }
        else
        {
            sc = StringCchCopyW(szBaseName, cchBaseName, L"default"); // Does not need to be localized
            if(sc)
                return sc.ToHr();
        }

        TCHAR* pszBaseName = OLE2T(szBaseName);

        // construct help file path
        sc = StringCchCat(m_szFilePath, countof(m_szFilePath), pszBaseName);
        if(sc)
            return sc.ToHr();

        sc = StringCchCat(m_szFilePath, countof(m_szFilePath), _T(".col"));
        if(sc)
            return sc.ToHr();

        return S_OK;

    } while (0);

    // clear path on failure
    m_szFilePath[0] = 0;

    return E_FAIL;
}


bool entry_title_comp(EntryPair* pE1, EntryPair* pE2)
{
    return pE1->second < pE2->second;
}

//------------------------------------------------------------------------------
// Enumerate the snapins in the snap-in cache. Call AddSnapInToList for each one.
// Open the snap-ins registry key for AddSnapInToList to use. When all the
// snap-ins have been added, sort the resulting entries by snap-in name.
//------------------------------------------------------------------------------
HRESULT CHelpDoc::CreateSnapInList()
{
    DECLARE_SC(sc, TEXT("CHelpDoc::CreateSnapInList"));

    CSnapInsCache* pSnapInsCache = theApp.GetSnapInsCache();
    ASSERT(pSnapInsCache != NULL);

    m_entryMap.clear();
    m_entryList.clear();

    // open MMC\Snapins key
    sc = ScFromWin32 ( m_keySnapIns.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY, KEY_READ) );
    if (sc)
        return sc.ToHr();

    // mark all snapins which have external references
    sc = pSnapInsCache->ScMarkExternallyReferencedSnapins();
    if (sc)
        return sc.ToHr();

    // Add each snap-in and its static extensions to the list
    CSnapInsCache::iterator c_it;
    for (c_it = pSnapInsCache->begin(); c_it != pSnapInsCache->end(); ++c_it)
    {
        const CSnapIn *pSnapin = c_it->second;
        if (!pSnapin)
            return (sc = E_UNEXPECTED).ToHr();

        bool bIsExternallyReferenced = false;
        sc = pSnapin->ScTempState_IsExternallyReferenced( bIsExternallyReferenced );
        if (sc)
            return sc.ToHr();

        // skip if snapin is not externally referenced
        if ( !bIsExternallyReferenced )
            continue;

        AddSnapInToList(pSnapin->GetSnapInCLSID());

        // we do not need to add extensions, since they are in cache anyway
        // and must be marked as externally referenced, (so will be added by the code above)
        // but it is worth to assert that

#ifdef DBG

        {
            CExtSI* pExt = pSnapin->GetExtensionSnapIn();
            while (pExt != NULL)
            {
                CSnapIn *pSnapin = pExt->GetSnapIn();
                sc = ScCheckPointers( pSnapin, E_UNEXPECTED );
                if (sc)
                {
                    sc.TraceAndClear();
                    break;
                }

                bool bExtensionExternallyReferenced = false;
                sc = pSnapin->ScTempState_IsExternallyReferenced( bExtensionExternallyReferenced );
                if (sc)
                {
                    sc.TraceAndClear();
                    break;
                }

                // assert it is in the cache and is marked properly
                CSnapInPtr spSnapin;
                ASSERT( SC(S_OK) == pSnapInsCache->ScFindSnapIn( pExt->GetCLSID(), &spSnapin ) );
                ASSERT( bExtensionExternallyReferenced );

                pExt = pExt->Next();
            }
        }

#endif // DBG

    }

    m_keySnapIns.Close();

    // our snap-in set is now up to date
    pSnapInsCache->SetHelpCollectionDirty(false);

    // copy items from map to list container so they can be sorted
    EntryMap::iterator it;
    for (it = m_entryMap.begin(); it != m_entryMap.end(); it++ )
    {
        m_entryList.push_back(&(*it));
    }

    sort(m_entryList.begin(), m_entryList.end(), entry_title_comp);

    return sc.ToHr();
}


//-----------------------------------------------------------------
// Add an entry to the snap-in list for the specified snap-in CLSID.
// Then recursively add any dynamic-only extensions that are registered
// to extend this snap-in. This list is indexed by snap-in CLSID to
// speed up checking for duplicate snap-ins.
//-----------------------------------------------------------------
void CHelpDoc::AddSnapInToList(const CLSID& rclsid)
{
    DECLARE_SC(sc, TEXT("CHelpDoc::AddSnapInToList"));

    // check if already included
    if (m_entryMap.find(rclsid) != m_entryMap.end())
        return;

    // open the snap-in key
    OLECHAR szCLSID[40];
    int iRet = StringFromGUID2(rclsid, szCLSID, countof(szCLSID));
    ASSERT(iRet != 0);

    USES_CONVERSION;

    CRegKeyEx keyItem;
    LONG lStat = keyItem.Open(m_keySnapIns, OLE2T(szCLSID), KEY_READ);
    if (lStat != ERROR_SUCCESS)
        return;

    // get the snap-in name
	WTL::CString strName;
    sc = ScGetSnapinNameFromRegistry (keyItem, strName);
#ifdef DBG
    if (sc)
    {
        USES_CONVERSION;
        sc.SetSnapinName(W2T (szCLSID)); // only guid is valid ...
        TraceSnapinError(_T("Failure reading \"NameString\" value from registry"), sc);
        sc.Clear();
    }
#endif // DBG

    // Add to snap-in list
    if (lStat == ERROR_SUCCESS)
    {
        wstring s(T2COLE(strName));
        m_entryMap[rclsid] = s;
    }

    // Get list of registered extensions
    CExtensionsCache  ExtCache;
    HRESULT hr = MMCGetExtensionsForSnapIn(rclsid, ExtCache);
    ASSERT(SUCCEEDED(hr));
    if (hr != S_OK)
        return;

    // Pass each dynamic extension to AddSnapInToList
    //  Note that the EXT_TYPE_DYNAMIC flag will be set for any extension
    //  that is dynamic-only for at least one nodetype. It may also be a
    //  static extension for another node type, so we don't check that the
    //  EXT_TYPE_STATIC flag is not set.
    CExtensionsCacheIterator ExtIter(ExtCache);
    for (; ExtIter.IsEnd() == FALSE; ExtIter.Advance())
    {
        if (ExtIter.GetValue() & CExtSI::EXT_TYPE_DYNAMIC)
        {
            CLSID clsid = ExtIter.GetKey();
            AddSnapInToList(clsid);
        }
    }
}


//----------------------------------------------------------------------
// Add a single file to a help collection. The file is added as a title
// and if bAddFolder is specified a folder is also added.
//----------------------------------------------------------------------
HRESULT CHelpDoc::AddFileToCollection(
            LPCWSTR pszTitle,
            LPCWSTR pszFilePath,
            BOOL    bAddFolder )
{
	DECLARE_SC (sc, _T("CHelpDoc::AddFileToCollection"));

	/*
	 * redirect the help file to the user's UI language, if necessary
	 */
	WTL::CString strFilePath = pszFilePath;
	LANGID langid = ENGLANGID;
	sc = ScRedirectHelpFile (strFilePath, langid);
	if (sc)
		return (sc.ToHr());

	Trace (tagHelpCollection, _T("AddFileToCollection: %s - %s (langid=0x%04x)"), pszTitle, (LPCTSTR) strFilePath, langid);

	USES_CONVERSION;
	pszFilePath = T2CW (strFilePath);

    DWORD dwError = 0;
    m_spCollection->AddTitle (pszTitle, pszFilePath, pszFilePath, L"", L"",
							  langid, FALSE, NULL, &dwError, TRUE, L"");
    if (dwError != 0)
		return ((sc = E_FAIL).ToHr());

    if (bAddFolder)
    {
        // Folder ID parameter has the form "=title"
        WCHAR szTitleEq[MAX_PATH+1];
        szTitleEq[0] = L'=';
        sc = StringCchCopyW(szTitleEq+1, countof(szTitleEq) -1, pszTitle);
        if(sc)
            return sc.ToHr();

        m_spCollection->AddFolder(szTitleEq, 1, &dwError, langid);
		if (dwError != 0)
			return ((sc = E_FAIL).ToHr());
    }

	return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CHelpDoc::ScRedirectHelpFile
 *
 * This method is for MUI support.  On MUI systems, where the user's UI
 * language is not US English, we will attempt to redirect the help file to
 *
 *		<dir>\mui\<langid>\<helpfile>
 *
 * <dir>		Takes one of two values:  If the helpfile passed in is fully
 * 				qualified, <dir> is the supplied directory.  If the helpfile
 * 				passed in is unqualified, then <dir> is %SystemRoot%\Help.
 * <langid>		The langid of the user's UI language, formatted as %04x
 * <helpfile>	The name of the original .chm file.
 *
 * This function returns:
 *
 * S_OK			if the helpfile was successfully redirected
 * S_FALSE		if the helpfile wasn't redirected
 *--------------------------------------------------------------------------*/

SC CHelpDoc::ScRedirectHelpFile (
	WTL::CString&	strHelpFile,	/* I/O:help file (maybe redirected)		*/
	LANGID&			langid)			/* O:language ID of output help file	*/
{
	DECLARE_SC (sc, _T("CHelpDoc::ScRedirectHelpFile"));

    typedef LANGID (WINAPI* GetUILangFunc)(void);
	static GetUILangFunc	GetUserDefaultUILanguage_   = NULL;
	static GetUILangFunc	GetSystemDefaultUILanguage_ = NULL;
	static bool				fAttemptedGetProcAddress    = false;

	/*
	 * validate input
	 */
	if (strHelpFile.IsEmpty())
		return (sc = E_FAIL);

	/*
	 * assume no redirection is required
	 */
	sc     = S_FALSE;
	langid = ENGLANGID;
	Trace (tagHelpCollection, _T("Checking for redirection of %s"), (LPCTSTR) strHelpFile);

	/*
	 * GetUser/SystemDefaultUILanguage are unsupported on systems < Win2K,
	 * so load them dynamically
	 */
    if (!fAttemptedGetProcAddress)
    {
        fAttemptedGetProcAddress = true;

        HMODULE hMod = GetModuleHandle (_T("kernel32.dll"));

        if (hMod)
		{
            GetUserDefaultUILanguage_   = (GetUILangFunc) GetProcAddress (hMod, "GetUserDefaultUILanguage");
            GetSystemDefaultUILanguage_ = (GetUILangFunc) GetProcAddress (hMod, "GetSystemDefaultUILanguage");
		}
    }

	/*
	 * if we couldn't load the MUI APIs, don't redirect
	 */
	if ((GetUserDefaultUILanguage_ == NULL) || (GetSystemDefaultUILanguage_ == NULL))
	{
		Trace (tagHelpCollection, _T("Couldn't load GetUser/SystemDefaultUILanguage, not redirecting"));
		return (sc);
	}

	/*
	 * find out what languages the system and user are using
	 */
	const LANGID langidUser   = GetUserDefaultUILanguage_();
	const LANGID langidSystem = GetSystemDefaultUILanguage_();

	/*
	 * we only redirect if we're running on MUI and MUI is always hosted on
	 * the US English release, so if the system UI language isn't US English,
	 * don't redirect
	 */
	if (langidSystem != ENGLANGID)
	{
		langid = langidSystem;
		Trace (tagHelpCollection, _T("System UI language is not US English (0x%04x), not redirecting"), langidSystem);
		return (sc);
	}

	/*
	 * if the user's language is US English, don't redirect
	 */
	if (langidUser == ENGLANGID)
	{
		Trace (tagHelpCollection, _T("User's UI language is US English, not redirecting"));
		return (sc);
	}

	/*
	 * the user's language is different from the default, see if we can
	 * find a help file that matches the user's UI langugae
	 */
	ASSERT (langidUser != langidSystem);
	WTL::CString strName;
	WTL::CString strPathPrefix;

	/*
	 * look for a path seperator to see if this is a fully qualified filename
	 */
	int iLastSep = strHelpFile.ReverseFind (_T('\\'));

	/*
	 * if it's fully qualified, construct a MUI directory name, e.g.
	 *
	 * 		<path>\mui\<langid>\<filename>
	 */
	if (iLastSep != -1)
	{
		strName       = strHelpFile.Mid  (iLastSep+1);
		strPathPrefix = strHelpFile.Left (iLastSep);
	}

	/*
	 * otherwise, it's not fully qualified, default to %SystemRoot%\Help, e.g.
	 *
	 * 		%SystemRoot%\Help\mui\<langid>\<filename>
	 */
	else
	{
		strName = strHelpFile;
        UINT cchBuffer = MAX_PATH;
        LPTSTR szBuffer = strPathPrefix.GetBuffer(cchBuffer);

        if(!szBuffer)
            return (sc = E_FAIL);

		ExpandEnvironmentStrings (_T("%SystemRoot%\\Help"), szBuffer, cchBuffer);
		strPathPrefix.ReleaseBuffer();
	}

	WTL::CString strRedirectedHelpFile;
	strRedirectedHelpFile.Format (_T("%s\\mui\\%04x\\%s"),
								  (LPCTSTR) strPathPrefix,
								  langidUser,
								  (LPCTSTR) strName);

	/*
	 * see if the redirected help file exists
	 */
	DWORD dwAttr = GetFileAttributes (strRedirectedHelpFile);

	if ((dwAttr == 0xFFFFFFFF) ||
		(dwAttr & (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_OFFLINE)))
	{
#ifdef DBG
		Trace (tagHelpCollection, _T("Attempting redirection to %s, %s"),
			   (LPCTSTR) strRedirectedHelpFile,
			   (dwAttr == 0xFFFFFFFF)              ? _T("not found")		  :
			   (dwAttr & FILE_ATTRIBUTE_DIRECTORY) ? _T("found as directory") :
													 _T("file offline"));
#endif
		return (sc);
	}

	/*
	 * if we get here, we've found a help file that matches the user's UI
	 * language; return it and the UI language ID
	 */
	Trace (tagHelpCollection, _T("Help redirected to %s"), (LPCTSTR) strRedirectedHelpFile);
	strHelpFile = strRedirectedHelpFile;
	langid      = langidUser;

	/*
	 * we redirected, return S_OK
	 */
	return (sc = S_OK);
}


//-------------------------------------------------------------------------------
// Delete the current help file collection. First delete it as a collection, then
// delete the file itself. It is possible that the file doesn't exist when this
// is called, so it's not a failure if it can't be deleted.
//-------------------------------------------------------------------------------
void
CHelpDoc::DeleteHelpFile()
{
    // Delete existing help file
    HANDLE hFile = ::CreateFile(m_szFilePath, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        ::CloseHandle(hFile);

        IHHCollectionWrapperPtr spOldCollection;
        spOldCollection.CreateInstance(CLSID_HHCollectionWrapper);

        USES_CONVERSION;

        WCHAR* pszFilePath = T2OLE(m_szFilePath);
        DWORD dwError = spOldCollection->Open(pszFilePath);
        if (dwError == 0)
            spOldCollection->RemoveCollection(FALSE);

        ::DeleteFile(m_szFilePath);
    }
}


//----------------------------------------------------------------------------
// Create a new help doc file for the current MMC console. This function
// enumerates all of the snap-in's used in the console and all their possible
// extension snap-ins. It queries each snap-in for a single help topic file and
// any linked help files. These files are added to a collection file which
// is then saved with the same base file name, creation time, and modification
// time as the console file.
//-----------------------------------------------------------------------------
HRESULT CHelpDoc::CreateHelpFile()
{
    DECLARE_SC(sc, TEXT("CHelpDoc::CreateHelpFile"));
    USES_CONVERSION;

    HelpCollectionEntrySet HelpFiles;
    DWORD dwError;

    ASSERT(m_spCollection == NULL);
    m_spCollection.CreateInstance(CLSID_HHCollectionWrapper);
    ASSERT(m_spCollection != NULL);

    if (m_spCollection == NULL)
        return E_FAIL;

    HRESULT hr = CreateSnapInList();
    if (hr != S_OK)
        return hr;

    IMallocPtr spIMalloc;
    hr = CoGetMalloc(MEMCTX_TASK, &spIMalloc);
    ASSERT(hr == S_OK);
    if (hr != S_OK)
        return hr;

    // Delete existing file before rebuilding it, or help files will
    // be appended to the existing files
    DeleteHelpFile();

    // open new collection file
    WCHAR* pszFilePath = T2OLE(m_szFilePath);
    dwError = m_spCollection->Open(pszFilePath);
    ASSERT(dwError == 0);
    if (dwError != 0)
        return E_FAIL;

    // Have collection automatically find linked files
    m_spCollection->SetFindMergedCHMS(TRUE);

    AddFileToCollection(L"mmc", T2CW(SC::GetHelpFile()), TRUE);

    /*
     * Build a set of unique help files provided by the snap-ins
     */
    EntryPtrList::iterator it;
    for (it = m_entryList.begin(); it != m_entryList.end(); ++it)
    {
        TRACE(_T("Help snap-in: %s\n"), (*it)->second.c_str());

        USES_CONVERSION;
        HRESULT hr;

        OLECHAR szHelpFilePath[MAX_PATH];
        const CLSID& clsid = (*it)->first;

        // Create an instance of the snap-in to query
        IUnknownPtr spIUnknown;
        hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC, IID_IUnknown, (void**)&spIUnknown);
        if (FAILED(hr))
            continue;

        // use either ISnapinHelp or ISnapinHelp2 to get the main topic file
        ISnapinHelpPtr spIHelp = spIUnknown;
        ISnapinHelp2Ptr spIHelp2 = spIUnknown;

        if (spIHelp == NULL && spIHelp2 == NULL)
            continue;

        LPWSTR pszHelpFile = NULL;

        hr = (spIHelp2 != NULL) ? spIHelp2->GetHelpTopic(&pszHelpFile) :
                                  spIHelp->GetHelpTopic(&pszHelpFile);

        if (hr == S_OK)
        {
            /*
             * Put this help file in the collection entry set.  The
             * set will prevent duplicating help file names.
             */
            HelpFiles.insert (CHelpCollectionEntry (pszHelpFile, clsid));
            spIMalloc->Free(pszHelpFile);

            // if IsnapinHelp2, query for additional help files
            pszHelpFile = NULL;
            if (spIHelp2 == NULL ||
                spIHelp2->GetLinkedTopics(&pszHelpFile) != S_OK ||
                pszHelpFile == NULL)
                continue;

            // There may be multiple names separated by ';'s
            // Add each as a separate title.
            // Note: there is no call to AddFolder because linked files
            // do not appear in the TOC.
            WCHAR *pchStart = wcstok(pszHelpFile, L";");
            while (pchStart != NULL)
            {
                // Must use base file name as title ID
                WCHAR szTitleID[MAX_PATH];

                sc = ScGetBaseFileName(pchStart, szTitleID, countof(szTitleID));
                if(!sc.IsError())
                {
                    AddFileToCollection(szTitleID, pchStart, FALSE);
                }

                // position to start of next string
                pchStart = wcstok(NULL, L";");
            }

            spIMalloc->Free(pszHelpFile);
        }
    }

    /*
     * Put all of the help files provided by the snap-ins in the help collection.
     */
    HelpCollectionEntrySet::iterator itHelpFile;
    for (itHelpFile = HelpFiles.begin(); itHelpFile != HelpFiles.end(); ++itHelpFile)
    {
        const CHelpCollectionEntry& file = *itHelpFile;

        AddFileToCollection(file.m_strCLSID.c_str(), file.m_strHelpFile.c_str(), TRUE);
    }

    dwError = m_spCollection->Save();
    ASSERT(dwError == 0);

    dwError = m_spCollection->Close();
    ASSERT(dwError == 0);

    // Force creation/modify times to match the console file
    HANDLE hFile = ::CreateFile(m_szFilePath, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL, NULL);
    ASSERT(hFile != INVALID_HANDLE_VALUE);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        BOOL bStat = ::SetFileTime(hFile, &m_pDocInfo->m_ftimeCreate, NULL, &m_pDocInfo->m_ftimeModify);
        ASSERT(bStat);

        ::CloseHandle(hFile);

        ASSERT(IsHelpFileValid());
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// Determine if the current help doc file is valid. A help file is valid if it
// has the base file name, creation time, and modification time as the MMC
// console doc file.
//-----------------------------------------------------------------------------
BOOL CHelpDoc::IsHelpFileValid()
{
    // Try to open the help file
    HANDLE hFile = ::CreateFile(m_szFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    // Check file creation and modification times
    FILETIME ftimeCreate;
    FILETIME ftimeModify;

    BOOL bStat = ::GetFileTime(hFile, &ftimeCreate, NULL, &ftimeModify);
    ASSERT(bStat);

    ::CloseHandle(hFile);

    return MatchFileTimes(ftimeCreate,m_pDocInfo->m_ftimeCreate) &&
           MatchFileTimes(ftimeModify,m_pDocInfo->m_ftimeModify);
}


//--------------------------------------------------------------------------
// If the current help doc file is valid then update its creation and
// modification times to match the new doc info.
//--------------------------------------------------------------------------
HRESULT CHelpDoc::UpdateHelpFile(HELPDOCINFO* pNewDocInfo)
{
    if (IsHelpFileValid())
    {
        HANDLE hFile = ::CreateFile(m_szFilePath, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile == INVALID_HANDLE_VALUE)
            return E_FAIL;

        BOOL bStat = ::SetFileTime(hFile, &pNewDocInfo->m_ftimeCreate, NULL, &pNewDocInfo->m_ftimeModify);
        ASSERT(bStat);

        ::CloseHandle(hFile);
    }

    return S_OK;
}


//------------------------------------------------------------------------
// Delete the current help doc file
//------------------------------------------------------------------------
HRESULT CNodeCallback::OnDeleteHelpDoc(HELPDOCINFO* pCurDocInfo)
{
    CHelpDoc HelpDoc;

    HRESULT hr = HelpDoc.Initialize(pCurDocInfo);
    if (FAILED(hr))
        return hr;

    HelpDoc.DeleteHelpFile();

    return S_OK;
}


CHelpCollectionEntry::CHelpCollectionEntry(LPOLESTR pwzHelpFile, const CLSID& clsid)
{
    if (!IsPartOfString (m_strHelpFile, pwzHelpFile))
        m_strHelpFile.erase();  // see KB Q172398

    m_strHelpFile = pwzHelpFile;

    WCHAR szCLSID[40];
    StringFromGUID2 (clsid, szCLSID, countof(szCLSID));

    m_strCLSID.erase(); // see KB Q172398
    m_strCLSID = szCLSID;
}


// ----------------------------------------------------------------------
// CNodeCallack method implementation
// ----------------------------------------------------------------------

//------------------------------------------------------------------------
// Get the pathname of the help doc for an MMC console doc. If the current
// help doc is valid and there are no snap-in changes, return the current
// doc. Otherwise, create a new help doc and return it.
//------------------------------------------------------------------------
HRESULT CNodeCallback::OnGetHelpDoc(HELPDOCINFO* pHelpInfo, LPOLESTR* ppszHelpFile)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnGetHelpDoc"));
    CHelpDoc HelpDoc;

    sc = HelpDoc.Initialize(pHelpInfo);
    if (sc)
        return sc.ToHr();

    CSnapInsCache* pSnapInsCache = theApp.GetSnapInsCache();
    sc = ScCheckPointers(pSnapInsCache);
    if(sc)
        return sc.ToHr();

    // Rebuild file if snap-in set changed or current file is not up to date
    if (pSnapInsCache->IsHelpCollectionDirty() || !HelpDoc.IsHelpFileValid())
    {
        sc = HelpDoc.CreateHelpFile();
        if(sc)
            return sc.ToHr();
    }

    // if ok, allocate and return file path string (OLESTR)
    LPCTSTR szHelpDoc = HelpDoc.GetFilePath();
    sc = ScCheckPointers(szHelpDoc);
    if(sc)
        return sc.ToHr();

    int cchHelpFile = lstrlen(szHelpDoc) + 1;
    *ppszHelpFile = reinterpret_cast<LPOLESTR> (CoTaskMemAlloc(cchHelpFile * sizeof(wchar_t)));
    sc = ScCheckPointers(*ppszHelpFile, E_OUTOFMEMORY);
    if (sc)
        return sc.ToHr();

    USES_CONVERSION;
    sc = StringCchCopyW(*ppszHelpFile, cchHelpFile, T2COLE(HelpDoc.GetFilePath()));
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::DoesStandardSnapinHelpExist
//
//  Synopsis:    Given the selection context, see if Standard MMC style help
//               exists (snapin implements ISnapinHelp[2] interface.
//               If not we wantto put "Help On <Snapin> which is MMC1.0 legacy
//               help mechanism.
//
//  Arguments:   [hNode]               - [in] the node selection context.
//               [bStandardHelpExists] - [out] Does standard help exists or not?
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT
CNodeCallback::DoesStandardSnapinHelpExist(HNODE hNode, bool& bStandardHelpExists)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnHasHelpDoc"));
    sc = ScCheckPointers( (void*) hNode);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    bStandardHelpExists = false;

    // QI ComponentData for ISnapinHelp
    CMTNode* pMTNode = pNode->GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    CComponentData* pCD = pMTNode->GetPrimaryComponentData();
    sc = ScCheckPointers(pCD, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    IComponentData *pIComponentData = pCD->GetIComponentData();
    sc = ScCheckPointers(pIComponentData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    ISnapinHelp* pIHelp = NULL;
    sc = pIComponentData->QueryInterface(IID_ISnapinHelp, (void**)&pIHelp);

    // if no ISnapinHelp, try ISnapinHelp2
    if (sc)
    {
        sc = pIComponentData->QueryInterface(IID_ISnapinHelp2, (void**)&pIHelp);
        if (sc)
        {
            // no ISnapinHelp2 either
            sc.Clear(); // not an error.
            return sc.ToHr();
        }
    }

    // make sure we got a valid pointer
    sc = ScCheckPointers(pIHelp, E_UNEXPECTED);
    if(sc)
    {
        sc.Clear();
        return sc.ToHr();
    }

    bStandardHelpExists = true;

    pIHelp->Release();

    return (sc).ToHr();
}

//-----------------------------------------------------------------------
// Update the current help doc file to match the new MMC console doc
//-----------------------------------------------------------------------
HRESULT CNodeCallback::OnUpdateHelpDoc(HELPDOCINFO* pCurDocInfo, HELPDOCINFO* pNewDocInfo)
{
    CHelpDoc HelpDoc;

    HRESULT hr = HelpDoc.Initialize(pCurDocInfo);
    if (FAILED(hr))
        return hr;

    return HelpDoc.UpdateHelpFile(pNewDocInfo);
}


SC ScGetBaseFileName(LPCWSTR pszFilePath, LPWSTR pszBaseName, int cBaseName)
{
    DECLARE_SC(sc, TEXT("GetBaseFileName"));

    sc = ScCheckPointers(pszFilePath, pszBaseName);
    if(sc)
        return sc;

    // Find last '\'
    LPCWSTR pszTemp = wcsrchr(pszFilePath, L'\\');

    // if no '\' found, find drive letter terminator':'
    if (pszTemp == NULL)
        pszTemp = wcsrchr(pszFilePath, L':');

    // if neither found, there is no path
    // else skip over last char of path
    if (pszTemp == NULL)
        pszTemp = pszFilePath;
    else
        pszTemp++;

    // find last '.' (assume that extension follows)
    WCHAR *pchExtn = wcsrchr(pszTemp, L'.');

    // How many chars excluding extension ?
    int cCnt = pchExtn ? (pchExtn - pszTemp) : wcslen(pszTemp);
    ASSERT(cBaseName > cCnt);
    if (cBaseName <= cCnt)
        return (sc = E_FAIL);

    // Copy to output buffer
    memcpy(pszBaseName, pszTemp, cCnt * sizeof(WCHAR));
    pszBaseName[cCnt] = L'\0';

    return sc;
}


//
// Compare two file times. Two file times are a match if they
// differ by no more than 2 seconds. This difference is allowed
// because a FAT file system stores times with a 2 sec resolution.
//
inline BOOL MatchFileTimes(FILETIME& ftime1, FILETIME& ftime2)
{
    // file system time resolution (2 sec) in 100's of nanosecs
    const static LONGLONG FileTimeResolution = 20000000;

    LONGLONG& ll1 = *(LONGLONG*)&ftime1;
    LONGLONG& ll2 = *(LONGLONG*)&ftime2;

    return (abs(ll1 - ll2) <= FileTimeResolution);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\helpdoc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       helpdoc.h
//
//--------------------------------------------------------------------------

#ifndef _HELPDOC_H
#define _HELPDOC_H

#pragma warning(disable:4786)

#include "tstring.h"
#include "hcolwrap.h"
#include "collect.h"

using namespace std;

DEFINE_COM_SMARTPTR(IHHCollectionWrapper);  // IHHCollectionWrapperPtr

class CHelpCollectionEntry
{
public:
    wstring m_strHelpFile;
    wstring m_strCLSID;

    CHelpCollectionEntry() {}
    CHelpCollectionEntry(LPOLESTR pwzHelpFile, const CLSID& clsid);

    bool operator==(const CHelpCollectionEntry& other) const
        { return (m_strHelpFile == other.m_strHelpFile); }

    bool operator< (const CHelpCollectionEntry& other) const
        { return (m_strHelpFile <  other.m_strHelpFile); }
};

typedef map<CLSID, wstring>             EntryMap;
typedef pair<const CLSID, wstring>      EntryPair;
typedef vector<EntryPair*>              EntryPtrList;
typedef set<CHelpCollectionEntry>       HelpCollectionEntrySet;


class CHelpDoc
{

public:
    CHelpDoc() {};

    HRESULT Initialize(HELPDOCINFO* pDocInfo);

    BOOL    IsHelpFileValid();
    HRESULT CreateHelpFile();
    void    DeleteHelpFile();
    HRESULT UpdateHelpFile(HELPDOCINFO* pNewDocInfo);
    LPCTSTR GetFilePath() { return m_szFilePath; }

	static SC CHelpDoc::ScRedirectHelpFile (
		WTL::CString&	strHelpFile,	/* I/O:help file (maybe redirected)		*/
		LANGID&			langid);		/* O:language ID of output help file	*/

private:
    IHHCollectionWrapperPtr m_spCollection;
    HELPDOCINFO*    m_pDocInfo;
    EntryMap        m_entryMap;
    EntryPtrList    m_entryList;
    MMC_ATL::CRegKey    m_keySnapIns;
    TCHAR           m_szFilePath[MAX_PATH];

private:
    HRESULT BuildFilePath();
    HRESULT CreateSnapInList();
    HRESULT AddFileToCollection(
            LPCWSTR pszTitle,
            LPCWSTR pszFilePath,
            BOOL    bAddFolder );
    void    AddSnapInToList(const CLSID& rclsid);

};


#endif //_HELPDOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\iconcontrol.cpp ===
// IconCtrl.cpp : Implementation of CIconControl

#include "stdafx.h"
#include "ndmgr.h"
#include "IconControl.h"
#include "findview.h"
#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// CIconControl

const CLSID CLSID_IconControl = {0xB0395DA5, 0x06A15, 0x4E44, {0x9F, 0x36, 0x9A, 0x9D, 0xC7, 0xA2, 0xF3, 0x41}};


//+-------------------------------------------------------------------
//
//  Member:      CIconControl::ScConnectToAMCViewForImageInfo
//
//  Synopsis:    Find the CAMCView that hosts this control and ask
//               for the icon information.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CIconControl::ScConnectToAMCViewForImageInfo ()
{
    DECLARE_SC(sc, _T("CIconControl::ScGetAMCView"));

    HWND hWnd = FindMMCView((*dynamic_cast<CComControlBase*>(this)));
    if (!hWnd)
        return (sc = E_FAIL);

	// check if we need the notch on the right side
	m_fLayoutRTL = (::GetWindowLong(hWnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);

    m_fAskedForImageInfo = true;
    sc = SendMessage(hWnd, MMC_MSG_GET_ICON_INFO, (WPARAM)&m_hIcon, 0);

    if (!m_hIcon)
        return (sc = E_FAIL);

    m_fImageInfoValid = true;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CIconControl::OnDraw
//
//  Synopsis:    Called by the host to draw.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CIconControl::OnDraw(ATL_DRAWINFO& di)
{
    DECLARE_SC(sc, _T("CIconControl::OnDraw"));
    RECT& rc = *(RECT*)di.prcBounds;

    // If never got the icon, ask CAMCView.
    if (!m_fAskedForImageInfo)
    {
        sc = ScConnectToAMCViewForImageInfo();
        if (sc)
            return sc.ToHr();
    }

    // Our attempt to get icon failed, so just return.
    if (!m_fImageInfoValid)
    {
        sc.TraceAndClear();
        return sc.ToHr();
    }

    // Draw the outline. Looks like: 
    //      xxxxxxxxxxxxxxxxxxxxxx
    //      x                    x
    //      x                    x
    //      x                   xx
    //      x                  x
    //      xxxxxxxxxxxxxxxxxxxx    <------- "Notch"

    // color the complete area
    COLORREF bgColor = GetSysColor(COLOR_ACTIVECAPTION);
    WTL::CBrush brush;
    brush.CreateSolidBrush(bgColor);                   // background brush

    WTL::CDC dc(di.hdcDraw); 

    // clear the DC
    dc.FillRect(&rc, brush);

    if(m_bDisplayNotch)  //Draw the notch if needed
    {
        WTL::CRgn rgn;
        int roundHeight = 10; // hack

        // clear out a quarter circle
        int left  = (m_fLayoutRTL==false ? rc.right : rc.left) - roundHeight;
        int right = (m_fLayoutRTL==false ? rc.right : rc.left) + roundHeight;
        int bottom= rc.bottom  + roundHeight;
        int top   = rc.bottom  - roundHeight;

        rgn.CreateRoundRectRgn(left, top, right, bottom, roundHeight*2, roundHeight*2);

        {
            COLORREF bgColor = GetSysColor(COLOR_WINDOW);
            WTL::CBrush brush;
            brush.CreateSolidBrush(bgColor);                   // background brush

            dc.FillRgn(rgn, brush);
        }
    }

    dc.Detach(); // release the DC before exiting!!

	const int LEFT_MARGIN = 10;
	const int TOP_MARGIN = 5;
	POINT ptIconPos = { (m_fLayoutRTL==false ? rc.left + LEFT_MARGIN : rc.right - LEFT_MARGIN -1 ), rc.top + TOP_MARGIN };

	// if we are on rtl mode - need to make dc behave that way as well 
	// For a time we draw an icon ( to appear in place and be flipped correctly )
	// (IE does not have RTL dc by default)
	DWORD dwLayout=0L;
	if ( m_fLayoutRTL && !( (dwLayout=GetLayout(di.hdcDraw)) & LAYOUT_RTL) ) 
	{
		LPtoDP( di.hdcDraw, &ptIconPos, 1/*nPoint*/);
		SetLayout(di.hdcDraw, dwLayout|LAYOUT_RTL);
		DPtoLP( di.hdcDraw, &ptIconPos, 1/*nPoint*/);
	}

	if (! DrawIconEx(di.hdcDraw, ptIconPos.x, ptIconPos.y, m_hIcon, 0, 0, 0, NULL, DI_NORMAL))
    {
        sc.FromLastError();
        sc.TraceAndClear();
        return sc.ToHr();
    }

	// Restore the DC to its previous layout state.
	if ( m_fLayoutRTL && !( dwLayout & LAYOUT_RTL ) ) 
	{
		SetLayout(di.hdcDraw, dwLayout);
	}

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\iconcontrol.h ===
// IconControl.h : Declaration of the CIconControl

#ifndef __ICONCONTROL_H_
#define __ICONCONTROL_H_

extern const CLSID CLSID_IconControl;

/////////////////////////////////////////////////////////////////////////////
// CIconControl
class ATL_NO_VTABLE CIconControl :
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComControl<CIconControl>,
        public IPersistStreamInitImpl<CIconControl>,
        public IOleControlImpl<CIconControl>,
        public IOleObjectImpl<CIconControl>,
        public IOleInPlaceActiveObjectImpl<CIconControl>,
        public IViewObjectExImpl<CIconControl>,
        public IOleInPlaceObjectWindowlessImpl<CIconControl>,
        public IPersistStorageImpl<CIconControl>,
        public ISpecifyPropertyPagesImpl<CIconControl>,
        public IQuickActivateImpl<CIconControl>,
        public IDataObjectImpl<CIconControl>,
        public IPersistPropertyBagImpl<CIconControl>,
        public IObjectSafetyImpl<CIconControl, INTERFACESAFE_FOR_UNTRUSTED_DATA>,
        public CComCoClass<CIconControl, &CLSID_IconControl>
{
public:
        CIconControl() : m_fImageInfoValid(false), m_fAskedForImageInfo(false), m_hIcon(NULL), 
						 m_bDisplayNotch(true), m_fLayoutRTL(false)
        {
        }

        virtual ~CIconControl()
        {
            if (m_hIcon)
                DestroyIcon(m_hIcon);
        }

        DECLARE_MMC_CONTROL_REGISTRATION(
            g_szMmcndmgrDll,                                        // implementing DLL
            CLSID_IconControl,
            _T("MMC IconControl class"),
            _T("MMC.IconControl.1"),
            _T("MMC.IconControl"),
            LIBID_NODEMGRLib,
            _T("1"),
            _T("1.0"))

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CIconControl)
        COM_INTERFACE_ENTRY(IViewObjectEx)
        COM_INTERFACE_ENTRY(IViewObject2)
        COM_INTERFACE_ENTRY(IViewObject)
        COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY(IOleInPlaceObject)
        COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY(IOleControl)
        COM_INTERFACE_ENTRY(IOleObject)
        COM_INTERFACE_ENTRY(IPersistPropertyBag)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
        COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY(IQuickActivate)
        COM_INTERFACE_ENTRY(IPersistStorage)
        COM_INTERFACE_ENTRY(IDataObject)
        COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

BEGIN_PROP_MAP(CIconControl)
        PROP_DATA_ENTRY("Notch",           m_bDisplayNotch,          VT_UI4) // the "Notch" is the quarter circle at the bottom-right of the panel
        // PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
        // PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
        // Example entries
        // PROP_ENTRY("Property Description", dispid, clsid)
        // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CIconControl)
        CHAIN_MSG_MAP(CComControl<CIconControl>)
        DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
   DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

public:
   HRESULT OnDraw(ATL_DRAWINFO& di);

// Helpers
private:
    SC ScConnectToAMCViewForImageInfo();

private:
    HICON           m_hIcon;
    bool            m_fImageInfoValid : 1;
    bool            m_fAskedForImageInfo : 1;
    UINT            m_bDisplayNotch; // the "Notch" is the quarter circle at the bottom-right of the panel
	bool            m_fLayoutRTL;
};
#endif //__ICONCONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\menubtn.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       menubtn.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5/17/1997   WayneSc   Created
//____________________________________________________________________________
//

#include "stdafx.h"
#include "menubtn.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////////////
// IMenuButton implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CMenuButton);

CMenuButton::CMenuButton()
{
    m_pControlbar = NULL;
    m_pMenuButtonsMgr = NULL;

    DEBUG_INCREMENT_INSTANCE_COUNTER(CMenuButton);
}

CMenuButton::~CMenuButton()
{
    m_pControlbar = NULL;
    m_pMenuButtonsMgr = NULL;

    DEBUG_DECREMENT_INSTANCE_COUNTER(CMenuButton);
}

void CMenuButton::SetControlbar(CControlbar* pControlbar)
{
    m_pControlbar = pControlbar;
}

CControlbar* CMenuButton::GetControlbar()
{
    return m_pControlbar;
}

CMenuButtonsMgr* CMenuButton::GetMenuButtonsMgr(void)
{
    if ((NULL == m_pMenuButtonsMgr) && (NULL != m_pControlbar) )
    {
        m_pMenuButtonsMgr = m_pControlbar->GetMenuButtonsMgr();
    }

    return m_pMenuButtonsMgr;
}


//+-------------------------------------------------------------------
//
//  Member:     AddButton
//
//  Synopsis:   Add a menu button, called by snapin.
//
//  Arguments:  [idCommand]     - Command ID for the menu button.
//              [lpButtonText]  - The text for menu button.
//              [lpTooltipText] - Status / Tool tip text.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CMenuButton::AddButton(int idCommand, LPOLESTR lpButtonText, LPOLESTR lpTooltipText)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IMenuButton::AddButton"));

    if (lpButtonText == NULL || lpTooltipText == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Args"), sc);
        return sc.ToHr();
    }

    CMenuButtonsMgr* pMenuButtonsMgr = GetMenuButtonsMgr();
    if (NULL == pMenuButtonsMgr)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    sc = pMenuButtonsMgr->ScAddMenuButton(this, idCommand, lpButtonText, lpTooltipText);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     SetButton
//
//  Synopsis:   Modify a menu button name or status text, called by snapin.
//
//  Arguments:  [idCommand]     - Command ID for the menu button.
//              [lpButtonText]  - The text for menu button.
//              [lpTooltipText] - Status / Tool tip text.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CMenuButton::SetButton(int idCommand, LPOLESTR lpButtonText, LPOLESTR lpTooltipText)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IMenuButton::SetButton"));

    if (lpButtonText == NULL || lpTooltipText == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Args"), sc);
        return sc.ToHr();
    }

    CMenuButtonsMgr* pMenuButtonsMgr = GetMenuButtonsMgr();
    if (NULL == pMenuButtonsMgr)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    sc = pMenuButtonsMgr->ScModifyMenuButton(this, idCommand, lpButtonText, lpTooltipText);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     SetButtonState
//
//  Synopsis:   Modify a menu button state, called by snapin.
//
//  Arguments:  [idCommand] - Command ID for the menu button.
//              [nState]    - The state to be modified.
//              [bState]    - Set or Reset the state.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CMenuButton::SetButtonState(int idCommand, MMC_BUTTON_STATE nState, BOOL bState)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IMenuButton::SetButtonState"));

    if (nState == CHECKED || nState == INDETERMINATE)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Button States"), sc);
        return sc.ToHr();
    }

    if (m_pControlbar == NULL)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    // ENABLED, HIDDEN, BUTTONPRESSED
    CMenuButtonsMgr* pMenuButtonsMgr = GetMenuButtonsMgr();
    if (NULL == pMenuButtonsMgr)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    sc = pMenuButtonsMgr->ScModifyMenuButtonState(this, idCommand, nState, bState);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     ScAttach
//
//  Synopsis:   Attach this MenuButton object to the UI.
//
//  Arguments:  None
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButton::ScAttach(void)
{
    DECLARE_SC(sc, _T("CMenuButton::ScAttach"));

    CMenuButtonsMgr* pMenuButtonsMgr = GetMenuButtonsMgr();
    if (NULL == pMenuButtonsMgr)
        return (sc = E_UNEXPECTED);

    sc = pMenuButtonsMgr->ScAttachMenuButton(this);
    if (sc)
        return sc.ToHr();

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScDetach
//
//  Synopsis:   Detach this MenuButton object from the UI.
//
//  Arguments:  None
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButton::ScDetach(void)
{
    DECLARE_SC(sc, _T("CMenuButton::ScDetach"));

    CMenuButtonsMgr* pMenuButtonsMgr = GetMenuButtonsMgr();
    if (NULL == pMenuButtonsMgr)
        return (sc = E_UNEXPECTED);

    sc = pMenuButtonsMgr->ScDetachMenuButton(this);
    if (sc)
        return sc;

    SetControlbar(NULL);

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScNotifyMenuBtnClick
//
//  Synopsis:   Notify the Controbar (snapin) that menu button is clicked.
//
//  Arguments:  [hNode]          - The node that owns the result pane.
//              [bScope]         - Scope or Result.
//              [lParam]         - If result (pane) lParam of result item.
//              [menuButtonData] - MENUBUTTONDATA
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButton:: ScNotifyMenuBtnClick(HNODE hNode, bool bScope,
                                      LPARAM lParam,
                                      MENUBUTTONDATA& menuButtonData)

{
    DECLARE_SC(sc, _T("CMenuButton::ScNotifyMenuBtnClick"));

    if (NULL == m_pControlbar)
        return (sc = E_UNEXPECTED);

    sc = m_pControlbar->ScNotifySnapinOfMenuBtnClick(hNode, bScope, lParam, &menuButtonData);
    if (sc)
        return sc.ToHr();

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\menuitem.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       menuitem.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// MenuItem.cpp : CMenuItem class implementation.

#include "stdafx.h"

#include "MenuItem.h"
#include "..\inc\stddbg.h" // ASSERT_OBJECTPTR
#include "util.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DEBUG_DECLARE_INSTANCE_COUNTER(CMenuItem);

//############################################################################
//############################################################################
//
//  Traces
//
//############################################################################
//############################################################################
#ifdef DBG
CTraceTag tagMenuItem(TEXT("Menu Items"), TEXT("Menu Item Path"));
#endif

//############################################################################
//############################################################################
//
//  Implementation of class CMMCMenuItem
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CMMCMenuItem
 *
 *
 * PURPOSE: Encapsulates a single CMenuItem, and exposes the MenuItem interface.
 *
 *+-------------------------------------------------------------------------*/
class CMMCMenuItem:
    public CMMCIDispatchImpl<MenuItem>,
    public CTiedComObject<CMenuItem>
{
    typedef CMMCMenuItem        ThisClass;
    typedef CMenuItem           CMyTiedObject;

public:

    BEGIN_MMC_COM_MAP(ThisClass)
    END_MMC_COM_MAP()

    // give a public access to IsTied();
    bool IsTied() { return CTiedComObject<CMenuItem>::IsTied(); }

    // MenuItem interface methods
public:
    MMC_METHOD0(Execute);
    MMC_METHOD1(get_DisplayName,             PBSTR /*pbstrName*/);
    MMC_METHOD1(get_LanguageIndependentName, PBSTR /*LanguageIndependentName*/);
    MMC_METHOD1(get_Path,                    PBSTR /*pbstrPath*/);
    MMC_METHOD1(get_LanguageIndependentPath, PBSTR /*LanguageIndependentPath*/);
    MMC_METHOD1(get_Enabled,                 PBOOL /*pBool*/);
};


//############################################################################
//############################################################################
//
//  Implementation of class CMenuItem
//
//############################################################################
//############################################################################

CMenuItem::CMenuItem(   LPCTSTR                 lpszName,
                        LPCTSTR                 lpszStatusBarText,
                        LPCTSTR                 lpszLanguageIndependentName,
                        LPCTSTR                 lpszPath,
                        LPCTSTR                 lpszLanguageIndependentPath,
                        long                    nCommandID,
                        long                    nMenuItemID,
                        long                    nFlags,
                        MENU_OWNER_ID           ownerID,
                        IExtendContextMenu *    pExtendContextMenu,
                        IDataObject *           pDataObject,
                        DWORD                   fSpecialFlags,
                        bool                    bPassCommandBackToSnapin /*= false*/) :

    m_strName(lpszName),
    m_strStatusBarText(lpszStatusBarText),
    m_strPath(lpszPath),
    m_strLanguageIndependentName(lpszLanguageIndependentName),
    m_strLanguageIndependentPath(lpszLanguageIndependentPath),
    m_nCommandID(nCommandID),
    m_nMenuItemID(nMenuItemID),
    m_nFlags(nFlags),
    m_OwnerID(ownerID),
    m_fSpecialFlags(fSpecialFlags),
    m_PopupMenuHandle(NULL),
    m_SubMenu(),            // default c-tor
    m_spExtendContextMenu(pExtendContextMenu),
    m_pDataObject(pDataObject), //AddRef'ed in the c-tor body
    m_bEnabled(true),
    m_spMenuItem(),         // default c-tor   
    m_bPassCommandBackToSnapin(bPassCommandBackToSnapin)
{
    // Caller must check range on ID and State

    // NULL is a special dataobject
    if (! IS_SPECIAL_DATAOBJECT(m_pDataObject))
        m_pDataObject->AddRef();

    DEBUG_INCREMENT_INSTANCE_COUNTER(CMenuItem);
}

CMenuItem::~CMenuItem()
{
    POSITION pos = m_SubMenu.GetHeadPosition();
    while(pos)
    {
        CMenuItem* pItem = m_SubMenu.GetNext(pos);
        ASSERT( pItem != NULL );
        delete pItem;
    }
    m_SubMenu.RemoveAll();

    m_spExtendContextMenu = NULL;

    if (! IS_SPECIAL_DATAOBJECT(m_pDataObject))
        m_pDataObject->Release();

    m_spMenuItem = NULL;

    DEBUG_DECREMENT_INSTANCE_COUNTER(CMenuItem);
}


void CMenuItem::AssertValid()
{
    ASSERT(this != NULL);
    if (m_nCommandID == -1 ||
        m_nMenuItemID == OWNERID_INVALID ||
        m_nFlags == -1
        )
    {
        ASSERT( FALSE );
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CMenuItem::ScGetMenuItem
 *
 * PURPOSE: Creates an returns a tied MenuItem COM object.
 *
 * PARAMETERS:
 *    PPMENUITEM  ppMenuItem :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMenuItem::ScGetMenuItem(PPMENUITEM ppMenuItem)
{
    DECLARE_SC(sc, TEXT("CMenuItem::ScGetMenuItem"));

    sc = ScCheckPointers(ppMenuItem);
    if(sc)
        return sc;

    // initialize out parameter
    *ppMenuItem = NULL;

    // create a CMMCMenuItem if needed.
    sc = CTiedComObjectCreator<CMMCMenuItem>::ScCreateAndConnect(*this, m_spMenuItem);
    if(sc)
        return sc;

    if(m_spMenuItem == NULL)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // addref the pointer for the client.
    m_spMenuItem->AddRef();
    *ppMenuItem = m_spMenuItem;

    return sc;
}


//+-------------------------------------------------------------------
//
//  class:      CManageActCtx
//
//  Purpose:    To deactivate UI theme context (if set) and restore
//              the context automatically.
//
//  Usage:      1. Call Activate to set the activation context to V5
//              common controls. This is needed before calling into snapins
//              so that snapin created windows are not themed accidentally.
//
//              The snapin can theme its windows by calling appropriate
//              fusion apis while calling create-window.
//
//              2. Call Deactivate to restore the activation context.
//              This is needed after calling into snapins, so that
//              if we called from themed context then it is restored.
//
// Explanation:
//              When MMC calls into the snapin if the last winproc which
//              received a window message is themed and will result in a
//              call to snapin then we will call the snapin in themed
//              context. If snapin creates & displays any UI then it will
//              be themed. This function is to de-activate the theming
//              before calling the snapin.
//
//
//--------------------------------------------------------------------
class CManageActCtx
{
public:
	CManageActCtx() : m_ulpCookie(0) { }
	~CManageActCtx() 
	{ 
		if (m_ulpCookie != 0) 
			MmcDownlevelDeactivateActCtx(0, m_ulpCookie); 
	}

	BOOL Activate(HANDLE hActCtx) 
	{
		if (m_ulpCookie != 0) 
		{
			ULONG_PTR ulpTemp = m_ulpCookie;
			m_ulpCookie = 0;
			MmcDownlevelDeactivateActCtx(0, ulpTemp);
		}

		return MmcDownlevelActivateActCtx(hActCtx, &m_ulpCookie);
	}

	VOID Deactivate() 
	{
		ULONG_PTR ulpTemp = m_ulpCookie;

		if (ulpTemp != 0) 
		{
			m_ulpCookie = 0;
			MmcDownlevelDeactivateActCtx(0, ulpTemp);
		}
	}

private:
	ULONG_PTR m_ulpCookie;
};


/*+-------------------------------------------------------------------------*
 *
 * CMenuItem::ScExecute
 *
 * PURPOSE: Executes the menu item.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMenuItem::ScExecute()
{
    DECLARE_SC(sc, TEXT("CMenuItem::ScExecute"));

    Trace(tagMenuItem, TEXT("\"%s\""), m_strPath);

    // check whether the item is disabled.
    BOOL bEnabled = FALSE;
    sc = Scget_Enabled(&bEnabled);
    if (sc)
        return sc;

    if (!bEnabled)
        return sc = E_FAIL;

    // if the command is to be passed to snapin  - nothing can be done here
    if ( m_bPassCommandBackToSnapin )
        return sc;

    sc = ScCheckPointers(m_spExtendContextMenu.GetInterfacePtr(), E_UNEXPECTED);
    if(sc)
        return sc;

    MenuItemPtr spMenuItem;
    sc = ScGetMenuItem( &spMenuItem );
    if (sc)
        return sc;

	// Deactivate if theming (fusion or V6 common-control) context before calling snapins.
	CManageActCtx mac;
	if (! mac.Activate(NULL) )
		return (sc = E_FAIL);

	sc = m_spExtendContextMenu->Command(GetCommandID(), m_pDataObject);

	mac.Deactivate();

    if (sc)
        return sc;

    // get the pointer for com event emitting
    CConsoleEventDispatcher *pConsoleEventDispatcher = NULL;
    sc = CConsoleEventDispatcherProvider::ScGetConsoleEventDispatcher( pConsoleEventDispatcher );
    if(sc)
    {
        sc.TraceAndClear(); // event does not affect item execution itself
        return sc;
    }

    // fire event about successful execution (do not rely on 'this' to be valid)
    if (pConsoleEventDispatcher != NULL)
    {
        // check if com object still points to a valid object
        CMMCMenuItem *pMMCMenuItem = dynamic_cast<CMMCMenuItem *>( spMenuItem.GetInterfacePtr() );

        // check the pointer
        sc = ScCheckPointers( pMMCMenuItem, E_UNEXPECTED );
        if (sc)
        {
            spMenuItem = NULL;  // invalid anyway - do not pass to the script
            sc.TraceAndClear(); // does not affect the result
        }
        else if ( !pMMCMenuItem->IsTied() ) // validate menu item
        {
            spMenuItem = NULL;  // gone away - change to NULL instead of passing invalid object
        }

        // fire it!
        sc = pConsoleEventDispatcher->ScOnContextMenuExecuted( spMenuItem );
        if (sc)
            sc.TraceAndClear(); // does not affect the result
    }
    else
    {
        // needs to be set prior to using
        (sc = E_UNEXPECTED).TraceAndClear();
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMenuItem::Scget_DisplayName
 *
 * PURPOSE: Returns the display name of the menu item, which includes acclerators.
 *          Eg '&Properties  ALT+ENTER'
 *
 * PARAMETERS:
 *    PBSTR  pbstrName :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMenuItem::Scget_DisplayName(PBSTR pbstrName)
{
    DECLARE_SC(sc, TEXT("CMenuItem::Scget_DisplayName"));

    sc = ScCheckPointers(pbstrName);
    if(sc)
        return sc;

    CComBSTR bstrName = GetMenuItemName();

    // give the
    *pbstrName = bstrName.Detach();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CMenuItem::Scget_LanguageIndependentName
 *
 * PURPOSE: Returns the language-independent name of the menu item. If there is no 
 *          language independent name, returns the display name without accelerators.
 *
 * PARAMETERS: 
 *    PBSTR  LanguageIndependentName :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMenuItem::Scget_LanguageIndependentName(PBSTR LanguageIndependentName)
{
    DECLARE_SC(sc, TEXT("CMenuItem::Scget_LanguageIndependentName"));

    sc = ScCheckPointers(LanguageIndependentName);
    if(sc)
        return sc;

    // initialize the out parameter
    *LanguageIndependentName = NULL;

    CComBSTR bstrLanguageIndependentName = GetLanguageIndependentName();

    // set the output param
    *LanguageIndependentName = bstrLanguageIndependentName.Detach();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMenuItem::Scget_Path
 *
 * PURPOSE: Returns the path of the menu item starting from the root. Does not include
 *          accelerators. Eg View->Large
 *
 * PARAMETERS:
 *    PBSTR  pbstrPath :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMenuItem::Scget_Path(PBSTR pbstrPath)
{
    DECLARE_SC(sc, TEXT("CMenuItem::Scget_Path"));

    sc = ScCheckPointers(pbstrPath);
    if(sc)
        return sc.ToHr();

    CComBSTR bstrPath = (LPCTSTR)m_strPath;

    // give the
    *pbstrPath = bstrPath.Detach();

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CMenuItem::Scget_LanguageIndependentPath
 *
 * PURPOSE: Returns the language independent path of the menu item starting from the root. 
 *          Eg _VIEW->_LARGE
 *
 * PARAMETERS: 
 *    PBSTR   LanguageIndependentPath :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC  
CMenuItem::Scget_LanguageIndependentPath(PBSTR  LanguageIndependentPath)
{
    DECLARE_SC(sc, TEXT("CMenuItem::Scget_LanguageIndependentPath"));

    sc = ScCheckPointers(LanguageIndependentPath);
    if(sc)
        return sc;

    // initialize the out parameter
    *LanguageIndependentPath = NULL;

    CComBSTR bstrLanguageIndependentPath = (LPCTSTR)GetLanguageIndependentPath();

    // set the output param
    *LanguageIndependentPath = bstrLanguageIndependentPath.Detach();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CMenuItem::Scget_Enabled
 *
 * PURPOSE: Returns whether the menu item is enabled.
 *
 * PARAMETERS:
 *    PBOOL  pBool :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
SC
CMenuItem::Scget_Enabled(PBOOL pBool)
{
    DECLARE_SC(sc, TEXT("CMenuItem::Scget_Enabled"));

    sc = ScCheckPointers(pBool);
    if(sc)
        return sc.ToHr();

    // the item is enabled only if it was never disabled via the Disable object model
    // method and it is not grayed out or disabled via the MF_ flags.
    *pBool = m_bEnabled &&
             ((m_nFlags & MF_DISABLED) == 0) &&
             ((m_nFlags & MF_GRAYED) == 0);

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMenuItem::ScFindMenuItemByPath
 *
 * PURPOSE: finds the menu item by matching the path
 *
 * PARAMETERS:
 *    LPCTSTR lpstrPath [in] manu item path
 *
 * RETURNS:
 *    CMenuItem*    - found item (NULL == not found)
 *
\***************************************************************************/
CMenuItem*
CMenuItem::FindItemByPath( LPCTSTR lpstrPath )
{
    // first check if this item does not meet requirements
    if ( 0 == m_strLanguageIndependentPath.Compare(lpstrPath)
      || 0 == m_strPath.Compare(lpstrPath) )
        return this;

    // recurse into subitems
    POSITION pos = GetMenuItemSubmenu().GetHeadPosition();
    while(pos)
    {
        CMenuItem* pItem = GetMenuItemSubmenu().GetNext(pos);
        if (!pItem)
        {
            ASSERT(FALSE);
            return NULL;
        }

        CMenuItem* pItemFound = pItem->FindItemByPath( lpstrPath );
        if (pItemFound)
            return pItemFound;
    }

    // not found 
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\menubtn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       menubtn.h
//
//--------------------------------------------------------------------------

#ifndef _MENUBTN_H_
#define _MENUBTN_H_

#include "toolbars.h"       // for CMenuButtonNotify

#ifdef DBG
#include "ctrlbar.h"  // Needed for GetSnapinName()
#endif


//forward prototypes
class CControlbar;
class CMenuButton;
class CMenuButtonsMgr;

//+-------------------------------------------------------------------
//
//  class:     CMenuButton
//
//  Purpose:   The IMenuButton implementation this is owned
//             by the CControlbar and talks to the CMenuButtonsMgr
//             to create/manipulate the menus.
//             The CMenuButtonNotify interface receives the menubutton
//             click notification.
//
//  History:    10-12-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CMenuButton : public IMenuButton,
                    public CMenuButtonNotify,
                    public CComObjectRoot
{
public:
    CMenuButton();
    ~CMenuButton();

public:
// ATL COM map
BEGIN_COM_MAP(CMenuButton)
    COM_INTERFACE_ENTRY(IMenuButton)
END_COM_MAP()


// CMenuButton methods
public:
    STDMETHOD(AddButton)(int idCommand, LPOLESTR lpButtonText, LPOLESTR lpTooltipText);
    STDMETHOD(SetButton)(int idCommand, LPOLESTR lpButtonText, LPOLESTR lpTooltipText);
    STDMETHOD(SetButtonState)(int idCommand, MMC_BUTTON_STATE nState, BOOL bState);

public:
    // Helpers
    void SetControlbar(CControlbar* pControlbar);
    CControlbar* GetControlbar(void);
    CMenuButtonsMgr* GetMenuButtonsMgr(void);

    SC ScAttach(void);
    SC ScDetach(void);

public:
    // CMenuButtonsMgr methods.
    virtual SC ScNotifyMenuBtnClick(HNODE hNode, bool bScope, LPARAM lParam,
                                    MENUBUTTONDATA& menuButtonData);

#ifdef DBG     // Debug information.
public:
    LPCTSTR GetSnapinName ()
    {
        if (m_pControlbar)
            return m_pControlbar->GetSnapinName();

        return _T("Unknown");
    }
#endif

// Attributes
private:
    CControlbar*            m_pControlbar;     // pointer to IControlbar (1 IControlbar to 1 IMenuButton)
    CMenuButtonsMgr*        m_pMenuButtonsMgr; // The Menu buttons mgr that manages the UI.
}; // class CMenuButton


#endif  // _MENUBTN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\mmcatl.h ===
//############################################################################
//############################################################################
//
// this should be provided by ATL, but it's not
//
//############################################################################
//############################################################################
#ifndef REFLECTED_NOTIFY_CODE_HANDLER
#define REFLECTED_NOTIFY_CODE_HANDLER(cd, func) \
    if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
    { \
        bHandled = TRUE; \
        lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
        if(bHandled) \
            return TRUE; \
    }
#endif

#define GET_PARENT_OBJECT(className, member) \
        className* pThis = \
            ((className*)((BYTE*)this - offsetof(className, member)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\menuitem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       menuitem.h
//
//--------------------------------------------------------------------------

// MenuItem.h : Declaration of the CMenuItem class.

/////////////////////////////////////////////////////////////////////////////
// MenuItem.h : See MenuItem.cpp for implementation.

#ifndef _MENUITEM_H
#define _MENUITEM_H

#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
#include "ndmgr.h"
#include "cmenuinfo.h"

// menu owner IDs
#define OWNERID_NATIVE          0
#define OWNERID_PRIMARY_MIN     1
#define OWNERID_PRIMARY_MAX     0x7FFFFFFF
#define OWNERID_THIRD_PARTY_MIN 0x80000000
#define OWNERID_THIRD_PARTY_MAX 0xFFFFFFFE
#define OWNERID_INVALID         0xFFFFFFFF
inline BOOL IsSystemOwnerID( MENU_OWNER_ID ownerid )
    { return (OWNERID_NATIVE == ownerid); }
inline BOOL IsPrimaryOwnerID( MENU_OWNER_ID ownerid )
    { return (OWNERID_PRIMARY_MIN <= ownerid && OWNERID_PRIMARY_MAX >= ownerid ); }
inline BOOL IsThirdPartyOwnerID( MENU_OWNER_ID ownerid )
    { return (OWNERID_THIRD_PARTY_MIN <= ownerid && OWNERID_THIRD_PARTY_MAX >= ownerid ); }

inline BOOL IsSpecialInsertionPointID( long lInsertionPointID )
    { return (lInsertionPointID & CCM_INSERTIONPOINTID_MASK_SPECIAL); }
inline BOOL IsSharedInsertionPointID( long lInsertionPointID )
    { return (lInsertionPointID & CCM_INSERTIONPOINTID_MASK_SHARED); }
inline BOOL IsCreatePrimaryInsertionPointID( long lInsertionPointID )
    { return (lInsertionPointID & CCM_INSERTIONPOINTID_MASK_CREATE_PRIMARY); }
inline BOOL IsAddPrimaryInsertionPointID( long lInsertionPointID )
    { return (lInsertionPointID & CCM_INSERTIONPOINTID_MASK_ADD_PRIMARY); }
inline BOOL IsAdd3rdPartyInsertionPointID( long lInsertionPointID )
    { return (lInsertionPointID & CCM_INSERTIONPOINTID_MASK_ADD_3RDPARTY); }
inline BOOL IsReservedInsertionPointID( long lInsertionPointID )
    { return (lInsertionPointID & CCM_INSERTIONPOINTID_MASK_RESERVED); }

inline BOOL IsReservedCommandID( long lCommandID )
    { return (lCommandID & CCM_COMMANDID_MASK_RESERVED); }


#define MENUITEM_BASE_ID 1000

/*+-------------------------------------------------------------------------*
 * class CMenuItem
 *
 *
 * PURPOSE: Encapsulates all information, including how to execute,
 *          for a menu item.
 *
 *+-------------------------------------------------------------------------*/
class CMenuItem :
    public CTiedObject
{
    DECLARE_NOT_COPIABLE(CMenuItem)
    DECLARE_NOT_ASSIGNABLE(CMenuItem)
public:
    CMenuItem(  LPCTSTR                 lpszName,
                LPCTSTR                 lpszStatusBarText,
                LPCTSTR                 lpszLanguageIndependentName,
                LPCTSTR                 lpszPath,
                LPCTSTR                 lpszLanguageIndependentPath,
                long                    nCommandID,
                long                    nMenuItemID,
                long                    nFlags,
                MENU_OWNER_ID           ownerID,
                IExtendContextMenu *    pExtendContextMenu,
                IDataObject *           pDataObject,
                DWORD                   fSpecialFlags,
                bool                    bPassCommandBackToSnapin = false );
    virtual ~CMenuItem();

// Interfaces
public:
// use MFC's standard object validity technique
    virtual void AssertValid();

public:
    void    GetMenuItemName(LPTSTR pBuffer, int* pLen);
    LPCTSTR GetMenuItemName() const             { return m_strName; }
    LPCTSTR GetMenuItemStatusBarText() const    { return m_strStatusBarText; }
    LPCTSTR GetLanguageIndependentName() const  { return m_strLanguageIndependentName;}
    LPCTSTR GetPath()  const                    { return m_strPath;}
    LPCTSTR GetLanguageIndependentPath() const  { return m_strLanguageIndependentPath;}
    long    GetCommandID() const                { return m_nCommandID; }
    long    GetMenuItemID() const               { return m_nMenuItemID; }
    long    GetMenuItemFlags() const            { return m_nFlags; }
    void    SetMenuItemFlags( long nFlags )     { m_nFlags = nFlags; }
    MENU_OWNER_ID GetMenuItemOwner() const      { return m_OwnerID; }
    MenuItemList& GetMenuItemSubmenu()          { return m_SubMenu; }
    DWORD   GetSpecialFlags() const             { return m_fSpecialFlags;}
    HMENU   GetPopupMenuHandle()                { return m_PopupMenuHandle; }
    void    SetPopupMenuHandle( HMENU hmenu )   { m_PopupMenuHandle = hmenu; }
    BOOL    IsPopupMenu()                       { return (MF_POPUP & m_nFlags); }
    BOOL    IsSpecialItemDefault()              { return (m_fSpecialFlags & CCM_SPECIAL_DEFAULT_ITEM); }
    BOOL    IsSpecialSeparator()                { return (m_fSpecialFlags & CCM_SPECIAL_SEPARATOR); }
    BOOL    IsSpecialSubmenu()                  { return (m_fSpecialFlags & CCM_SPECIAL_SUBMENU); }
    BOOL    IsSpecialInsertionPoint()           { return (m_fSpecialFlags & CCM_SPECIAL_INSERTION_POINT); }
    BOOL    HasChildList()                      { return ((m_nFlags & MF_POPUP) || IsSpecialInsertionPoint()); }

    CMenuItem* FindItemByPath( LPCTSTR lpstrPath );

    // creates and returns a ContextMenu interface.
    SC      ScGetMenuItem(PPMENUITEM ppMenuItem);

    // MenuItem methods.
    virtual SC  ScExecute();     // executes the menu item.
    virtual SC  Scget_DisplayName(PBSTR pbstrName);
    virtual SC  Scget_LanguageIndependentName(PBSTR LanguageIndependentName);
    virtual SC  Scget_Path(PBSTR  pbstrPath);
    virtual SC  Scget_LanguageIndependentPath(PBSTR  LanguageIndependentPath);
    virtual SC  Scget_Enabled(PBOOL pBool);

    bool NeedsToPassCommandBackToSnapin() { return m_bPassCommandBackToSnapin; }
private:
    CStr                    m_strName;
    CStr                    m_strStatusBarText;
    CStr                    m_strPath;
    CStr                    m_strLanguageIndependentName;
    CStr                    m_strLanguageIndependentPath;
    long                    m_nCommandID;
    long                    m_nMenuItemID;
    long                    m_nFlags;
    MENU_OWNER_ID           m_OwnerID;
    long                    m_fSpecialFlags;
    HMENU                   m_PopupMenuHandle;
    MenuItemList            m_SubMenu;
    IExtendContextMenuPtr   m_spExtendContextMenu;  // the callback called when the item is executed.
    IDataObject*            m_pDataObject;

    BOOL                    m_bEnabled;

    MenuItemPtr             m_spMenuItem;
    bool                    m_bPassCommandBackToSnapin;
};


/*+-------------------------------------------------------------------------*
 *
 * CRootMenuItem
 *
 * PURPOSE: The root menu item.
 *
 * RETURNS:
 *    class
 *
 *+-------------------------------------------------------------------------*/
class
CRootMenuItem : public CMenuItem
{
public:
    CRootMenuItem() : CMenuItem(NULL/*lpszName*/, NULL/*lpszStatusBarText*/, NULL/*lpszLanguageIndependentName*/, 
                                NULL/*lpszPath*/, NULL/*lpszLanguageIndependentPath*/, 0/*nCommandID*/,
                                0/*nMenuItemID*/,MF_POPUP/*nFlags*/,0/*ownerID*/, NULL/*pExtendContextMenu*/, 
                                NULL/*pDataObject*/, 0/*fSpecialFlags*/) 
    {
    }

    virtual SC ScExecute() const {SC sc; return sc;} // does nothing.

};

/////////////////////////////////////////////////////////////////////////////
// SnapinStruct

class SnapinStruct
{
    // cannot assign - will unbalance m_pIDataObject refs
    DECLARE_NOT_COPIABLE(SnapinStruct)
    DECLARE_NOT_ASSIGNABLE(SnapinStruct)
public: 
    IExtendContextMenuPtr pIExtendContextMenu;
    MENU_OWNER_ID       m_OwnerID;
    IDataObject*        m_pIDataObject;

    SnapinStruct(   IExtendContextMenu* pintf,
                    IDataObject* pIDataObject,
                    MENU_OWNER_ID ownerID)
    :   pIExtendContextMenu( pintf ),
        m_OwnerID( ownerID )
    {
        ASSERT( NULL != pintf && NULL != pIDataObject );
        m_pIDataObject = pIDataObject;

        if (! IS_SPECIAL_DATAOBJECT(m_pIDataObject))
            m_pIDataObject->AddRef();
    }

    ~SnapinStruct()
    {
        if (! IS_SPECIAL_DATAOBJECT(m_pIDataObject))
            m_pIDataObject->Release();
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\mfccllct.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mfccllct.h
//
//--------------------------------------------------------------------------

#ifndef __MFCCLLCT_H
#define __MFCCLLCT_H


namespace MMC       // Temporary for the MFC->ATL conversion
{


class CPtrList 
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        void* data;
    };
public:

// Construction
    CPtrList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    void*& GetHead();
    void* GetHead() const;
    void*& GetTail();
    void* GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list!
    void* RemoveHead();
    void* RemoveTail();

    // add before head or after tail
    POSITION AddHead(void* newElement);
    POSITION AddTail(void* newElement);

    // add another list of elements before head or after tail
    void AddHead(CPtrList* pNewList);
    void AddTail(CPtrList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    POSITION GetHeadPosition() const;
    POSITION GetTailPosition() const;
    void*& GetNext(POSITION& rPosition); // return *Position++
    void* GetNext(POSITION& rPosition) const; // return *Position++
    void*& GetPrev(POSITION& rPosition); // return *Position--
    void* GetPrev(POSITION& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    void*& GetAt(POSITION position);
    void* GetAt(POSITION position) const;
    void SetAt(POSITION pos, void* newElement);
    void RemoveAt(POSITION position);

    // inserting before or after a given position
    POSITION InsertBefore(POSITION position, void* newElement);
    POSITION InsertAfter(POSITION position, void* newElement);

    // helper functions (note: O(n) speed)
    POSITION Find(void* searchValue, POSITION startAfter = NULL) const;
                        // defaults to starting at the HEAD
                        // return NULL if not found
    POSITION FindIndex(int nIndex) const;
                        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CPtrList();
#ifdef _DBG
    void AssertValid() const;
#endif
    // local typedefs for class templates
    typedef void* BASE_TYPE;
    typedef void* BASE_ARG_TYPE;
};

inline int CPtrList::GetCount() const
    { return m_nCount; }
inline BOOL CPtrList::IsEmpty() const
    { return m_nCount == 0; }
inline void*& CPtrList::GetHead()
    { ASSERT(m_pNodeHead != NULL);
        return m_pNodeHead->data; }
inline void* CPtrList::GetHead() const
    { ASSERT(m_pNodeHead != NULL);
        return m_pNodeHead->data; }
inline void*& CPtrList::GetTail()
    { ASSERT(m_pNodeTail != NULL);
        return m_pNodeTail->data; }
inline void* CPtrList::GetTail() const
    { ASSERT(m_pNodeTail != NULL);
        return m_pNodeTail->data; }
inline POSITION CPtrList::GetHeadPosition() const
    { return (POSITION) m_pNodeHead; }
inline POSITION CPtrList::GetTailPosition() const
    { return (POSITION) m_pNodeTail; }
inline void*& CPtrList::GetNext(POSITION& rPosition) // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
inline void* CPtrList::GetNext(POSITION& rPosition) const // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
inline void*& CPtrList::GetPrev(POSITION& rPosition) // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
inline void* CPtrList::GetPrev(POSITION& rPosition) const // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
inline void*& CPtrList::GetAt(POSITION position)
    { CNode* pNode = (CNode*) position;
        ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
        return pNode->data; }
inline void* CPtrList::GetAt(POSITION position) const
    { CNode* pNode = (CNode*) position;
        ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
        return pNode->data; }
inline void CPtrList::SetAt(POSITION pos, void* newElement)
    { CNode* pNode = (CNode*) pos;
        ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
        pNode->data = newElement; }


}       // MMC namespace

      
#endif  // __MFCCLLCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\mmcmt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcmt.h
//
//--------------------------------------------------------------------------

#ifndef __MMCMT_H_
#define __MMCMT_H_

/*
	mmcmt.h
	
	Simple thread synchronization classes
*/


/////////////////////////////////////////////////////////////////////////////
// CSyncObject

class CSyncObject
{
	friend class CMutex;

	public:
		CSyncObject();
		virtual ~CSyncObject();
	
		operator HANDLE() const { return m_hObject; }
	
		virtual BOOL Lock(DWORD dwTimeout = INFINITE);
		virtual BOOL Unlock() = 0;
		virtual BOOL Unlock(LONG /* lCount */, LPLONG /* lpPrevCount=NULL */) { return TRUE; }

	protected:
		HANDLE  m_hObject;
};


/////////////////////////////////////////////////////////////////////////////
// CMutex

class CMutex : public CSyncObject
{
	public:
		CMutex(BOOL bInitiallyOwn = FALSE);

		BOOL Unlock();
};


/////////////////////////////////////////////////////////////////////////////
// CCriticalSection

class CCriticalSection : public CSyncObject
{
	public:
		CCriticalSection();
		virtual ~CCriticalSection();
	
		operator CRITICAL_SECTION*() { return &m_sect; }
	
		BOOL Lock();
		BOOL Unlock();

	protected:
		CRITICAL_SECTION m_sect;
};


inline CCriticalSection::CCriticalSection() :
	CSyncObject()
{
	::InitializeCriticalSection( &m_sect );
}

inline CCriticalSection::~CCriticalSection()
{
	::DeleteCriticalSection( &m_sect );
}

inline BOOL CCriticalSection::Lock()
{
	::EnterCriticalSection( &m_sect ); 
	return TRUE;
}

inline BOOL CCriticalSection::Unlock()
{
	::LeaveCriticalSection( &m_sect ); 
	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CSingleLock

class CSingleLock
{
	public:
		CSingleLock(CSyncObject* pObject, BOOL bInitialLock = FALSE);
		~CSingleLock() { Unlock(); }

		BOOL Lock(DWORD dwTimeOut = INFINITE);
		BOOL Unlock();
		BOOL IsLocked() { return m_bAcquired; }
	
	protected:
		CSyncObject* m_pObject;
		HANDLE  m_hObject;
		BOOL    m_bAcquired;
};


#endif	// __MMCMT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\mmcmt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcmt.cpp
//
//--------------------------------------------------------------------------

/*
	mmcmt.cpp
	
	Implementation of thread synchronization classes
*/

#include "stdafx.h"


/////////////////////////////////////////////////////////////////////////////
// CSyncObject

CSyncObject::CSyncObject() :
	m_hObject( NULL )
{
}


CSyncObject::~CSyncObject()
{
	if( m_hObject != NULL )
	{
		::CloseHandle( m_hObject );
		m_hObject = NULL;
	}
}


BOOL CSyncObject::Lock( DWORD dwTimeout )
{
	// this is a band-aid fix. Whis locking architecture is not working at all.
	// Raid #374770 ( Windows Bugs ntraid9 4/23/2001 )
	// fixes need to be made to:
	// a) remove m_hObject member from this class
	// b) remove CMutex - not used anywhere
	// c) make Lock a pure virtual method and require everyone to override it.
	// d) remove this locking from context menu - it is not needed there

	if( m_hObject && ::WaitForSingleObject( m_hObject, dwTimeout) == WAIT_OBJECT_0 )
		return TRUE;
	else
		return FALSE;
}



/////////////////////////////////////////////////////////////////////////////
// CMutex

CMutex::CMutex( BOOL bInitiallyOwn ) :
	CSyncObject()
{
	m_hObject = ::CreateMutex( NULL, bInitiallyOwn, NULL );
	ASSERT( m_hObject );
}



BOOL CMutex::Unlock()
{
	return ::ReleaseMutex( m_hObject );
}



/////////////////////////////////////////////////////////////////////////////
// CSingleLock

CSingleLock::CSingleLock( CSyncObject* pObject, BOOL bInitialLock )
{
	ASSERT( pObject != NULL );

	m_pObject = pObject;
	m_hObject = *pObject;
	m_bAcquired = FALSE;

	if (bInitialLock)
		Lock();
}


BOOL CSingleLock::Lock( DWORD dwTimeOut )
{
	ASSERT( m_pObject != NULL || m_hObject != NULL );
	ASSERT( !m_bAcquired );

	m_bAcquired = m_pObject->Lock( dwTimeOut );
	return m_bAcquired;
}


BOOL CSingleLock::Unlock()
{
	ASSERT( m_pObject != NULL );
	if (m_bAcquired)
		m_bAcquired = !m_pObject->Unlock();

	// successfully unlocking means it isn't acquired
	return !m_bAcquired;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\mmcres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nodemgr.rc
//
#define IDD_SNAPIN_ABOUT                107
#define IDD_TASKS                       108
#define IDB_SETUPWIZARD                 137
#define IDB_CHECKBOX                    138
#define IDD_ACTIVEX_WIZPAGE1            143
#define IDD_ACTIVEX_WIZPAGE2            144
#define IDD_HTML_WIZPAGE1               145
#define IDD_HTML_WIZPAGE2               146
#define IDD_ACTIVEX_WIZPAGE0            149
#define IDD_NOPROPS_PROPPAGE            156
#define IDB_SNP_MANAGER                 158
#define IDD_SNAPIN_MANAGER_ADD          159
#define IDB_IMAGELIST                   200
#define IDB_SETUPWIZARD1                201
#define IDC_CTRLPROPERTIES              204
#define IDC_CATEGORY_COMBOEX            212
#define IDB_TPPreview_HorzLrg           216
#define IDB_TPPreview_HorzMed           217
#define IDB_TPPreview_HorzSml           218
#define IDB_TPPreview_HorzLrgD          219
#define IDB_TPPreview_HorzMedD          220
#define IDB_TPPreview_HorzSmlD          221
#define IDB_TPPreview_Tasks             222
#define IDB_TPPreview_TasksD            223
#define IDB_TPPreview_VertLrg           224
#define IDB_TPPreview_VertMed           225
#define IDB_TPPreview_VertSml           226
#define IDB_TPPreview_VertLrgD          227
#define IDB_TPPreview_VertMedD          228
#define IDB_TPPreview_VertSmlD          229
#define IDB_TASKPAD_WIZARD_HEADER       230
#define IDR_FOLDERSNAPIN                232
#define IDB_OCX_WIZARD_HEADER           234
#define IDC_CONTROLXLS                  1000
#define IDC_TASKPAD_TITLE               1001
#define IDC_Options                     1012
#define IDC_NEW_TASK_BT                 1014
#define IDC_REMOVE_TASK                 1015
#define IDC_MODIFY                      1017
#define IDC_START_TASK_WIZARD           1018
#define IDC_MOVE_UP                     1020
#define IDC_MOVE_DOWN                   1021
#define IDC_DISPLAYTX                   1022
#define IDC_TARGETTX                    1023
#define IDC_BROWSEBT                    1024
#define IDC_INFOBT                      1025
#define IDC_ALLOP                       1026
#define IDC_CHECK1                      1032
#define IDC_MONITOROP                   1033
#define IDC_FixedLevelCount             1034
#define IDC_CustomContextFormat         1041
#define IDC_FINDTARGETBT                1047
#define IDC_CHANGEICONBT                1048
#define IDC_SNAPIN_LV                   1049
#define IDC_TOOLBAR                     1053
#define IDD_SNAPIN_STANDALONE_PROPP     1055
#define IDD_SNAPIN_EXTENSION_PROPP      1056
#define IDD_TASKPAD_GENERAL             1057
#define IDD_TASKPAD_ADVANCED            1059
#define IDD_COLUMNS                     1070
#define IDD_TASK_WIZARD_WELCOME         1072
#define IDB_TASKPAD_WIZARD_WELCOME      1073
#define IDD_TASK_WIZARD_NAME_PAGE       1074
#define IDD_TASK_WIZARD_SYMBOL_PAGE     1075
#define IDD_TASK_WIZARD_CMDLINE_PAGE    1076
#define IDD_TASK_WIZARD_MENU_PAGE       1077
#define IDD_TASK_PROPS_CMDLINE_PAGE     1080
#define IDD_TASK_PROPS_NAME_PAGE        1081
#define IDD_TASK_PROPS_SYMBOL_PAGE      1082
#define IDD_TASKPAD_WIZARD_WELCOME      1083
#define IDD_TASKPAD_WIZARD_STYLE_PAGE   1084
#define IDD_TASKPAD_WIZARD_NAME_PAGE    1085
#define IDD_CUSTOMIZE_VIEW              1086
#define IDD_TASKPAD_WIZARD_TITLE_PAGE   1087
#define IDB_FOLDER_32                   1087
#define IDB_FOLDER_16                   1088
#define IDD_TASK_WIZARD_TYPE_PAGE       1089
#define IDD_TASK_WIZARD_FINISH          1090
#define IDB_FOLDEROPEN_16               1090
#define IDB_OCX_16                      1091
#define IDB_HTML_16                     1092
#define IDB_OCX_32                      1093
#define IDB_HTML_32                     1094
#define IDD_TASKPAD_WIZARD_FINISH       1097
#define IDI_FOLDER                      1097
#define IDD_TASKPAD_WIZARD_NODETYPE_PAGE 1098
#define IDI_HTML                        1098
#define IDD_TASK_WIZARD_FAVORITE_PAGE   1099
#define IDI_OCX                         1099
#define IDC_APPICON                     4000
#define IDC_COMPANY_NAME                4002
#define IDC_DESCRIPTION                 4003
#define IDC_VERSION                     4004
#define IDC_DESCRIPTION2                4004
#define IDC_LINE                        4005
#define IDC_SNAPIN_NAME                 4006
#define IDC_SNAPIN_DESCR                4007
#define IDC_SNAPIN_MANAGER_ADD          4008
#define IDC_SNAPIN_MANAGER_DELETE       4009
#define IDC_SNAPIN_DESCR_LABEL          4010
#define IDC_SNAPIN_ADDED_LIST           4011
#define IDC_SNAPIN_ABOUT                4014
#define IDC_SNAPIN_COMBOEX              4018
#define IDC_EXTENSION_LIST              4020
#define IDC_VTHELPER                    4021
#define IDC_SNAPIN_LABEL                4022
#define IDC_EXTENSION_LABEL             4023
#define IDC_NOPROPS                     4024
#define IDC_SNAPIN_ENABLEALL            4025
#define IDC_SNAPIN_DOWNLOAD             4026
#define IDC_STYLE_DESCRIPTION           4033
#define IDC_LIST_TASKS                  4036
#define IDC_FixedLevelCountSpin         4044
#define IDC_UseFixedFormat              4046
#define IDC_UseCustomContextFormat      4047
#define IDC_NoCaption                   4048
#define IDC_BrowseForCommand            4050
#define IDC_BrowseForWorkingDir         4051
#define IDC_Command                     4052
#define IDC_CommandArgs                 4053
#define IDC_CommandArgsLabel            4054
#define IDC_CommandLabel                4055
#define IDC_CommandWindowStateCombo     4058
#define IDC_CommandWindowStateComboLabel 4059
#define IDC_CommandWorkingDir           4060
#define IDC_CommandWorkingDirLabel      4061
#define IDC_CommandList                 4067
#define IDC_CommandListLabel            4068
#define IDC_ScopeTree                   4069
#define IDC_TaskName                    4071
#define IDC_TaskNameLabel               4072
#define IDC_BrowseForArguments          4080
#define IDC_HIDDEN_COLUMNS              4084
#define IDC_ADD_COLUMNS                 4085
#define IDC_REMOVE_COLUMNS              4086
#define IDC_RESTORE_DEFAULT_COLUMNS     4087
#define IDC_DISPLAYED_COLUMNS           4088
#define IDC_MOVEUP_COLUMN               4089
#define IDC_MOVEDOWN_COLUMN             4090
#define IDC_TASKPAD_DESCRIPTION         4091
#define IDC_TaskpadPreview              4092
#define IDC_WELCOME                     4099
#define IDC_COMPLETING                  4100
#define IDC_ResultList                  4110
#define IDC_GLYPH_LIST                  4113
#define IDC_MENU_TASK                   4115
#define IDC_CMDLINE_TASK                4116
#define IDB_RESTART_TASK_WIZARD         4124
#define IDC_CustomTitleSample           4125
#define IDC_UseForSimilarNodes          4128
#define IDC_SetDefaultForNodetype       4129
#define IDC_TaskDescription             4130
#define IDC_CUST_SNAPIN_MENUS           4138
#define IDC_CUST_STD_BUTTONS            4139
#define IDC_CUST_SNAPIN_BUTTONS         4140
#define IDC_CUST_STATUS_BAR             4141
#define IDC_CUST_DESC_BAR               4142
#define IDC_CUST_CONSOLE_TREE           4143
#define IDC_CUST_STD_MENUS              4144
#define IDC_CUST_TASKPAD_TABS           4145
#define IDC_DontUseForSimilarNodes      4146
#define IDC_Style_VerticalList          4147
#define IDC_Style_HorizontalList        4148
#define IDC_Style_TasksOnly             4149
#define IDC_Style_TooltipDesc           4150
#define IDC_Style_TextDesc              4151
#define IDC_Style_SizeCombo             4152
#define IDC_TASK_SOURCE_COMBO           4153
#define IDC_RESULT_TASK_DESCR           4154
#define IDC_NAVIGATION_TASK             4155
#define IDC_FAVORITE_STATIC             4157
#define IDC_CONSOLE_TREE_CAPTION        4159
#define IDC_SNAPIN_INFO                 4160
#define IDC_SNAPIN_DESC                 4161
#define IDC_Style_HideNormalTab         4162
#define IDB_SELECT_TASK_ICON            4163
#define IDC_CustomIcon                  4165
#define IDC_CustomIconRadio             4166
#define IDC_MMCIconsRadio               4167
#define IDC_DESCRIPTION2Label           4168
#define IDC_DESCRIPTIONLabel            4169
#define IDC_CustomIconWell              4170
#define IDC_CUST_VIEW_CAPTION           4171

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1100
#define _APS_NEXT_COMMAND_VALUE         13578
#define _APS_NEXT_CONTROL_VALUE         4171
#define _APS_NEXT_SYMED_VALUE           5001
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\moreutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       moreutil.cpp
//
//--------------------------------------------------------------------------

/*
    moreutil.cpp
    
    Utility functions for the nodemgr without MFC
*/


#include "stdafx.h"
#include "macros.h"


BOOL _IsValidAddress( const void* lp, UINT nBytes, BOOL bReadWrite )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\moreutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       moreutil.h
//
//--------------------------------------------------------------------------

#ifndef __MMCUTIL_H__
#define __MMCUTIL_H__

/*
	mmcutil.h
	
	Some extra macros and definitions to aid the anti-MFC effort
*/


#if 1
#define MMC_TRY
#define MMC_CATCH
#else
#define MMC_TRY																			\
	try {

#define MMC_CATCH									 	                                 \
    }                                                	                                 \
    catch ( std::bad_alloc )                         	                                 \
    {                                                	                                 \
        ASSERT( FALSE );                             	                                 \
        return E_OUTOFMEMORY;                        	                                 \
    }                                                	                                 \
    catch ( std::exception )                         	                                 \
    {                                                	                                 \
        ASSERT( FALSE );                             	                                 \
        return E_UNEXPECTED;                         	                                 \
	}
#endif


BOOL _IsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite = TRUE);
  
#endif	// __MMCUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\mmcprotocol.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       mmcprotocol.h
//
//  Purpose: Creates a temporary pluggable internet protocol, mmc://
//
//  History: 14-April-2000 Vivekj added
//--------------------------------------------------------------------------

#include<stdafx.h>

#include<mmcprotocol.h>
#include "tasks.h"
#include "typeinfo.h" // for COleCacheCleanupObserver

// {3C5F432A-EF40-4669-9974-9671D4FC2E12}
static const CLSID CLSID_MMCProtocol = { 0x3c5f432a, 0xef40, 0x4669, { 0x99, 0x74, 0x96, 0x71, 0xd4, 0xfc, 0x2e, 0x12 } };
static const WCHAR szMMC[] =  _W(MMC_PROTOCOL_SCHEMA_NAME);
static const WCHAR szMMCC[] = _W(MMC_PROTOCOL_SCHEMA_NAME) _W(":");
static const WCHAR szPageBreak[] = _W(MMC_PAGEBREAK_RELATIVE_URL);

static const WCHAR szMMCRES[] = L"%mmcres%";
static const WCHAR chUNICODE = 0xfeff;

#ifdef DBG
CTraceTag tagProtocol(_T("MMC iNet Protocol"), _T("MMCProtocol"));
#endif //DBG

/***************************************************************************\
 *
 * FUNCTION:  HasSchema
 *
 * PURPOSE: helper: determines if URL contains schema (like "something:" or "http:" )
 *
 * PARAMETERS:
 *    LPCWSTR strURL
 *
 * RETURNS:
 *    bool ; true == does contain schema
 *
\***************************************************************************/
inline bool HasSchema(LPCWSTR strURL)
{
    if (strURL == NULL)
        return false;

    // skip spaces and schema name
    while ( iswspace(*strURL) || iswalnum(*strURL) )
        strURL++;

    // valid schema ends with ':'
    return *strURL == L':';
}

/***************************************************************************\
 *
 * FUNCTION:  HasMMCSchema
 *
 * PURPOSE: helper: determines if URL contains mmc schema ( begins with "mmc:" )
 *
 * PARAMETERS:
 *    LPCWSTR strURL
 *
 * RETURNS:
 *    bool ; true == does contain mmc schema
 *
\***************************************************************************/
inline bool HasMMCSchema(LPCWSTR strURL)
{
    if (strURL == NULL)
        return false;

    // skip spaces
    while ( iswspace(*strURL) )
        strURL++;

    return (0 == _wcsnicmp( strURL, szMMCC, wcslen(szMMCC) ) );
}

/***************************************************************************\
 *
 * CLASS:  CMMCProtocolRegistrar
 *
 * PURPOSE: register/ unregisters mmc protocol.
 *          Also class provides cleanup functionality. Because it registers as
 *          COleCacheCleanupObserver, it will receive the event when MMC
 *          is about to uninitialize OLE, and will revoke registered mmc protocol
 *
\***************************************************************************/
class CMMCProtocolRegistrar : public COleCacheCleanupObserver
{
    bool               m_bRegistered;
    IClassFactoryPtr   m_spClassFactory;
public:
    // c-tor.
    CMMCProtocolRegistrar() : m_bRegistered(false) {}

    // registration / unregistration
    SC ScRegister();
    SC ScUnregister();

    // event sensor - unregisters mmc protocol
    virtual SC ScOnReleaseCachedOleObjects()
    {
        DECLARE_SC(sc, TEXT("ScOnReleaseCachedOleObjects"));

        return sc = ScUnregister();
    }
};

/***************************************************************************\
 *
 * METHOD:  CMMCProtocolRegistrar::ScRegister
 *
 * PURPOSE: registers the protocol if required
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCProtocolRegistrar::ScRegister()
{
    DECLARE_SC(sc, TEXT("CMMCProtocolRegistrar::ScRegister"));

    // one time registration only
    if(m_bRegistered)
        return sc;

    // get internet session
    IInternetSessionPtr spInternetSession;
    sc = CoInternetGetSession(0, &spInternetSession, 0);
    if(sc)
        return sc;

    // doublecheck
    sc = ScCheckPointers(spInternetSession, E_FAIL);
    if(sc)
        return sc;

    // ask CComModule for the class factory
    sc = _Module.GetClassObject(CLSID_MMCProtocol, IID_IClassFactory, (void **)&m_spClassFactory);
    if(sc)
        return sc;

    // register the namespace
    sc = spInternetSession->RegisterNameSpace(m_spClassFactory, CLSID_MMCProtocol, szMMC, 0, NULL, 0);
    if(sc)
        return sc;

    // start observing cleanup requests - to unregister in time
    COleCacheCleanupManager::AddOleObserver(this);

    m_bRegistered = true; // did it.
    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocolRegistrar::ScUnregister
 *
 * PURPOSE: unregisters the protocol if one was registered
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCProtocolRegistrar::ScUnregister()
{
    DECLARE_SC(sc, TEXT("CMMCProtocolRegistrar::ScUnregister"));

    if (!m_bRegistered)
        return sc;

    // unregister
    IInternetSessionPtr spInternetSession;
    sc = CoInternetGetSession(0, &spInternetSession, 0);
    if(sc)
    {
        sc.Clear(); // no session - no headache
    }
    else // need to unregister
    {
        // recheck
        sc = ScCheckPointers(spInternetSession, E_UNEXPECTED);
        if(sc)
            return sc;

        // unregister the namespace
        sc = spInternetSession->UnregisterNameSpace(m_spClassFactory, szMMC);
        if(sc)
            return sc;
    }

    m_spClassFactory.Release();
    m_bRegistered = false;

    return sc;
}



/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::ScRegisterProtocol
 *
 * PURPOSE: Registers mmc protocol. IE will resove "mmc:..." ULRs to it
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC
CMMCProtocol::ScRegisterProtocol()
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::ScRegisterProtocol"));

    // registrar (unregisters on cleanup event) - needs to be static
    static CMMCProtocolRegistrar registrar;

    // let the registrar do the job
    return sc = registrar.ScRegister();
}

//*****************************************************************************
// IInternetProtocolRoot interface
//*****************************************************************************

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::Start
 *
 * PURPOSE: Starts data download thru this protocol
 *
 * PARAMETERS:
 *    LPCWSTR szUrl
 *    IInternetProtocolSink *pOIProtSink
 *    IInternetBindInfo *pOIBindInfo
 *    DWORD grfPI
 *    HANDLE_PTR dwReserved
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP
CMMCProtocol::Start(LPCWSTR szUrl, IInternetProtocolSink *pOIProtSink, IInternetBindInfo *pOIBindInfo, DWORD grfPI, HANDLE_PTR dwReserved)
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::Start"));

    // check inputs
    sc = ScCheckPointers(szUrl, pOIProtSink, pOIBindInfo);
    if(sc)
        return sc.ToHr();

    // reset position for reading
    m_uiReadOffs = 0;

    bool bPageBreakRequest = false;

    // see if it was a pagebreak requested
    sc = ScParsePageBreakURL( szUrl, bPageBreakRequest );
    if(sc)
        return sc.ToHr();

    if ( bPageBreakRequest )
    {
        // just report success (S_OK/S_FALSE) in case we were just parsing
        if ( grfPI & PI_PARSE_URL )
            return sc.ToHr();

        // construct a pagebreak
        m_strData  = L"<HTML/>";

        sc = pOIProtSink->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, L"text/html");
        if (sc)
            sc.TraceAndClear(); // ignore and continue
    }
    else
    {
        //if  not a pagebreak - then taskpad
        GUID guidTaskpad = GUID_NULL;
        sc = ScParseTaskpadURL( szUrl, guidTaskpad );
        if(sc)
            return sc.ToHr();

        // report the S_FALSE instead of error in case we were just parsing
        if ( grfPI & PI_PARSE_URL )
            return ( sc.IsError() ? (sc = S_FALSE) : sc ).ToHr();

        if (sc)
            return sc.ToHr();

        // load the contents
        sc = ScGetTaskpadXML( guidTaskpad, m_strData );
        if (sc)
            return sc.ToHr();

        sc = pOIProtSink->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, L"text/html");
        if (sc)
            sc.TraceAndClear(); // ignore and continue
    }

    const DWORD grfBSCF = BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
    const DWORD dwDataSize = m_strData.length() * sizeof (WCHAR);
    sc = pOIProtSink->ReportData(grfBSCF, dwDataSize , dwDataSize);
    if (sc)
        sc.TraceAndClear(); // ignore and continue

    sc = pOIProtSink->ReportResult(0, 0, 0);
    if (sc)
        sc.TraceAndClear(); // ignore and continue

    return sc.ToHr();
}

STDMETHODIMP CMMCProtocol::Continue(PROTOCOLDATA *pProtocolData)    { return E_NOTIMPL; }
STDMETHODIMP CMMCProtocol::Abort(HRESULT hrReason, DWORD dwOptions) { return S_OK; }
STDMETHODIMP CMMCProtocol::Terminate(DWORD dwOptions)               { return S_OK; }
STDMETHODIMP CMMCProtocol::LockRequest(DWORD dwOptions)             { return S_OK; }
STDMETHODIMP CMMCProtocol::UnlockRequest()                          { return S_OK; }
STDMETHODIMP CMMCProtocol::Suspend()                                { return E_NOTIMPL; }
STDMETHODIMP CMMCProtocol::Resume()                                 { return E_NOTIMPL; }

STDMETHODIMP CMMCProtocol::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    return E_NOTIMPL;
}



//*****************************************************************************
// IInternetProtocol interface
//*****************************************************************************

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::Read
 *
 * PURPOSE: Reads data from the protocol
 *
 * PARAMETERS:
 *    void *pv
 *    ULONG cb
 *    ULONG *pcbRead
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCProtocol::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::Read"));

    // parameter check;
    sc = ScCheckPointers(pv, pcbRead);
    if(sc)
        return sc.ToHr();

    // init out parameter;
    *pcbRead = 0;

    size_t size = ( m_strData.length() ) * sizeof(WCHAR);

    if ( size <= m_uiReadOffs )
        return (sc = S_FALSE).ToHr(); // no more data

    // calculate the size we'll return
    *pcbRead = size - m_uiReadOffs;
    if (size - m_uiReadOffs > cb)
        *pcbRead = cb;

    if (*pcbRead)
        memcpy( pv, reinterpret_cast<const BYTE*>( m_strData.begin() ) + m_uiReadOffs, *pcbRead );

    m_uiReadOffs += *pcbRead;

    if ( size <= m_uiReadOffs )
        return (sc = S_FALSE).ToHr(); // no more data

    return sc.ToHr();
}

//*****************************************************************************
// IInternetProtocolInfo interface
//*****************************************************************************

STDMETHODIMP
CMMCProtocol::ParseUrl(  LPCWSTR pwzUrl, PARSEACTION ParseAction, DWORD dwParseFlags, LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved)
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::ParseUrl"));

    if (ParseAction == PARSE_SECURITY_URL)
    {
        // get system directory (like "c:\winnt\system32\")
        std::wstring windir;
        AppendMMCPath(windir);
        windir += L'\\';

        // we are as secure as windir is - report the url (like "c:\winnt\system32\")
        *pcchResult = windir.length() + 1;

        // check if we have enough place for the result and terminating zero
        if ( cchResult <= windir.length() )
            return S_FALSE; // not enough

        sc = StringCchCopyW(pwzResult,cchResult, windir.c_str());
        if(sc)
            return sc.ToHr();

        return (sc = S_OK).ToHr();
    }

    return INET_E_DEFAULT_ACTION;
}


/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::CombineUrl
 *
 * PURPOSE: combines base + relative url to resulting url
 *          we do local variable substitution here
 *
 * PARAMETERS:
 *    LPCWSTR pwzBaseUrl
 *    LPCWSTR pwzRelativeUrl
 *    DWORD dwCombineFlags
 *    LPWSTR pwzResult
 *    DWORD cchResult
 *    DWORD *pcchResult
 *    DWORD dwReserved
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCProtocol::CombineUrl(LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags, LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved)
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::CombineUrl"));

#ifdef DBG
    USES_CONVERSION;
    Trace(tagProtocol, _T("CombineUrl: [%s] + [%s]"), W2CT(pwzBaseUrl), W2CT(pwzRelativeUrl));
#endif //DBG

    std::wstring temp1;
    if (HasMMCSchema(pwzBaseUrl))
    {
        // our stuff

        temp1 = pwzRelativeUrl;
        ExpandMMCVars(temp1);

        if ( ! HasSchema( temp1.c_str() ) )
        {
            // combine everything into relative URL
            temp1.insert( 0, pwzBaseUrl );
        }

        // form 'new' relative address
        pwzRelativeUrl = temp1.c_str();

        // say we are refered from http - let it do the dirty job ;)
        pwzBaseUrl = L"http://";
    }

    // since we stripped out ourselfs from pwzBaseUrl - it will not recurse back,
    // but will do original html stuff
    sc = CoInternetCombineUrl( pwzBaseUrl, pwzRelativeUrl, dwCombineFlags, pwzResult, cchResult, pcchResult, dwReserved );
    if (sc)
        return sc.ToHr();

    Trace(tagProtocol, _T("CombineUrl: == [%s]"), W2CT(pwzResult));

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::CompareUrl
 *
 * PURPOSE: compares URLs if they are the same
 *
 * PARAMETERS:
 *    LPCWSTR pwzUrl1
 *    LPCWSTR pwzUrl2
 *    DWORD dwCompareFlags
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCProtocol::CompareUrl(LPCWSTR pwzUrl1, LPCWSTR pwzUrl2,DWORD dwCompareFlags)
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::CompareUrl"));

    return INET_E_DEFAULT_ACTION;
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::QueryInfo
 *
 * PURPOSE: Queries info about URL
 *
 * PARAMETERS:
 *    LPCWSTR pwzUrl
 *    QUERYOPTION QueryOption
 *    DWORD dwQueryFlags
 *    LPVOID pBuffer
 *    DWORD cbBuffer
 *    DWORD *pcbBuf
 *    DWORD dwReserved
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCProtocol::QueryInfo( LPCWSTR pwzUrl, QUERYOPTION QueryOption,DWORD dwQueryFlags, LPVOID pBuffer, DWORD cbBuffer, DWORD *pcbBuf, DWORD dwReserved)
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::QueryInfo"));

    if (QueryOption == QUERY_USES_NETWORK)
    {
        if (cbBuffer >= 4)
        {
            *(LPDWORD)pBuffer = FALSE; // does not use the network
            *pcbBuf = 4;
            return S_OK;
        }
    }
    else if (QueryOption == QUERY_IS_SAFE)
    {
        if (cbBuffer >= 4)
        {
            *(LPDWORD)pBuffer = TRUE; // only serves trusted content
            *pcbBuf = 4;
            return S_OK;
        }
    }


    return INET_E_DEFAULT_ACTION;
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::ScParseTaskpadURL
 *
 * PURPOSE: Extracts taskpad guid from URL given to the protocol
 *
 * PARAMETERS:
 *    LPCWSTR strURL [in] - URL
 *    GUID& guid     [out] - extracted guid
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCProtocol::ScParseTaskpadURL( LPCWSTR strURL, GUID& guid )
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::ScParseTaskpadURL"));

    guid = GUID_NULL;

    sc = ScCheckPointers(strURL);
    if (sc)
        return sc;

    // taskpad url should be in form "mmc:{guid}"

    // check for "mmc:"
    if ( 0 != _wcsnicmp( strURL, szMMCC, wcslen(szMMCC) ) )
        return sc = E_FAIL;

    // skip "mmc:"
    strURL += wcslen(szMMCC);

    // get the url
    sc = CLSIDFromString( const_cast<LPWSTR>(strURL), &guid );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::ScParsePageBreakURL
 *
 * PURPOSE: Checks if URL given to the protocol is a request for a pagebreak
 *
 * PARAMETERS:
 *    LPCWSTR strURL    [in] - URL
 *    bool& bPageBreak  [out] - true it it is a request for pagebreak
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCProtocol::ScParsePageBreakURL( LPCWSTR strURL, bool& bPageBreak )
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::ScParsePageBreakURL"));

    bPageBreak = false;

    sc = ScCheckPointers(strURL);
    if (sc)
        return sc;

    // pagebreak url should be in form "mmc:pagebreak.<number>"

    // check for "mmc:"
    if ( 0 != _wcsnicmp( strURL, szMMCC, wcslen(szMMCC) ) )
        return sc; // not an error - return value updated

    // skip "mmc:"
    strURL += wcslen(szMMCC);

    // get the url
    bPageBreak = ( 0 == wcsncmp( strURL, szPageBreak, wcslen(szPageBreak) ) );

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::ScGetTaskpadXML
 *
 * PURPOSE: given the guid uploads taskpad XML string to the string
 *
 * PARAMETERS:
 *    const GUID& guid              [in] - taskpad guid
 *    std::wstring& strResultData   [out] - taskpad xml string
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCProtocol::ScGetTaskpadXML( const GUID& guid, std::wstring& strResultData )
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::ScGetTaskpadXML"));

    strResultData.erase();

    CScopeTree* pScopeTree = CScopeTree::GetScopeTree();

    sc = ScCheckPointers(pScopeTree, E_FAIL);
    if(sc)
        return sc.ToHr();

    CConsoleTaskpadList * pConsoleTaskpadList = pScopeTree->GetConsoleTaskpadList();
    sc = ScCheckPointers(pConsoleTaskpadList, E_FAIL);
    if(sc)
        return sc.ToHr();

    for(CConsoleTaskpadList::iterator iter = pConsoleTaskpadList->begin(); iter!= pConsoleTaskpadList->end(); ++iter)
    {
        CConsoleTaskpad &consoleTaskpad = *iter;

        // check if this is the one we are looking for
        if ( !IsEqualGUID( guid, consoleTaskpad.GetID() ) )
            continue;

        // convert the taskpad to a string
        CStr strTaskpadHTML;
        sc = consoleTaskpad.ScGetHTML(strTaskpadHTML); // create a string version of the taskpad
        if(sc)
            return sc.ToHr();

        // form the result string
        USES_CONVERSION;
        strResultData = chUNICODE;
        strResultData += T2CW(strTaskpadHTML);

        return sc;
    }

    // not found
    return sc = E_FAIL;
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::AppendMMCPath
 *
 * PURPOSE: helper. Appends the mmcndmgr.dll dir (no file name) to the string
 *          It may append something like: "c:\winnt\system32"
 *
 * PARAMETERS:
 *    std::wstring& str [in/out] - string to edit
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CMMCProtocol::AppendMMCPath(std::wstring& str)
{
    TCHAR szModule[_MAX_PATH+10] = { 0 };
    DWORD cchSize = countof(szModule);
    DWORD dwRet = GetModuleFileName(_Module.GetModuleInstance(), szModule, cchSize);
    if(0==dwRet)
        return;

    // NTRAID#NTBUG9-613782-2002/05/02-ronmart-prefast  warning 53: Call to 'GetModuleFileNameW' may not zero-terminate string
    szModule[cchSize - 1] = 0;

    USES_CONVERSION;
    LPCWSTR strModule = T2CW(szModule);

    LPCWSTR dirEnd = wcsrchr( strModule, L'\\' );
    if (dirEnd != NULL)
        str.append(strModule, dirEnd);
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::ExpandMMCVars
 *
 * PURPOSE: helper. expands any %mmcres% contained in the string
 *          It expands it to something like "res://c:\winnt\system32\mmcndmgr.dll"
 *
 * PARAMETERS:
 *    std::wstring& str [in/out] - string to edit
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CMMCProtocol::ExpandMMCVars(std::wstring& str)
{
    TCHAR szModule[_MAX_PATH+10] = { 0 };
    DWORD cchSize = countof(szModule);
    DWORD dwRet = GetModuleFileName(_Module.GetModuleInstance(), szModule, cchSize);
    if(0==dwRet)
        return;

    // NTRAID#NTBUG9-613782-2002/05/02-ronmart-prefast  warning 53: Call to 'GetModuleFileNameW' may not zero-terminate string
    szModule[cchSize - 1] = 0;

    USES_CONVERSION;
    LPCWSTR strModule = T2CW(szModule);

    std::wstring mmcres = L"res://";
    mmcres += strModule;

    // second - replace the instances

    int pos;
    while (std::wstring::npos != (pos = str.find(szMMCRES) ) )
    {
        // make one substitution
        str.replace( pos, wcslen(szMMCRES), mmcres) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\msgview.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      msgview.cpp
 *
 *  Contents:  Implementation file for CMessageView
 *
 *  History:   28-Apr-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "msgview.h"
#include "util.h"

using std::_MAX;
using std::_MIN;


/*+-------------------------------------------------------------------------*
 * CMessageView::CMessageView
 *
 *
 *--------------------------------------------------------------------------*/

CMessageView::CMessageView ()
    :   m_hIcon      (NULL),
        m_yScroll    (0),
        m_yScrollMax (0),
        m_yScrollMin (0),
        m_cyPage     (0),
        m_cyLine     (0),
        m_sizeWindow (0, 0),
        m_sizeIcon   (0, 0),
        m_sizeMargin (0, 0),
		m_nAccumulatedScrollDelta (0)
{
    /*
     * can't be windowless
     */
    m_bWindowOnly = true;

	/*
	 * get the system metrics we'll use
	 */
	UpdateSystemMetrics();

    DEBUG_INCREMENT_INSTANCE_COUNTER(CMessageView);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::~CMessageView
 *
 *
 *--------------------------------------------------------------------------*/

CMessageView::~CMessageView ()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CMessageView);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnCreate
 *
 * WM_CREATE handler for CMessageView.
 *--------------------------------------------------------------------------*/

LRESULT CMessageView::OnCreate (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CreateFonts();
	RecalcLayout ();

	return (0);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnDestroy
 *
 * WM_DESTROY handler for CMessageView.
 *--------------------------------------------------------------------------*/

LRESULT CMessageView::OnDestroy (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DeleteFonts();
    return (0);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnSize
 *
 * WM_SIZE handler for CMessageView.
 *--------------------------------------------------------------------------*/

LRESULT CMessageView::OnSize (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    /*
     * The transient appearance/disappearance of WS_VSCROLL makes the client
     * rect volatile and can mess up our calculations.  We'll use the more
     * stable window rect instead.
     */
    WTL::CRect rectWindow;
    GetWindowRect (rectWindow);

    if (GetExStyle() & WS_EX_CLIENTEDGE)
        rectWindow.DeflateRect (GetSystemMetrics (SM_CXEDGE),
                                GetSystemMetrics (SM_CYEDGE));

    WTL::CSize sizeWindow (rectWindow.Width(), rectWindow.Height());

    /*
     * if the overall size has changed, we have some work to do
     */
    if (m_sizeWindow != sizeWindow)
    {
        /*
         * load m_sizeWindow right away so scrollbar future calculations
         * will have the right values in the member variable
         */
        std::swap (m_sizeWindow, sizeWindow);

        /*
         * if the width has changed, we'll might need to recalculate
         * all of the text heights
         */
        if (m_sizeWindow.cx != sizeWindow.cx)
            RecalcLayout ();

        /*
         * if the height changed, there's scrollbar work
         */
        if (m_sizeWindow.cy != sizeWindow.cy)
        {
            int dy = m_sizeWindow.cy - sizeWindow.cy;

            /*
             * if the window's grown, we might need to scroll to keep the
             * bottom of our content glued to the bottom of the window
             */
            if ((dy > 0) && (m_yScroll > 0) &&
                        ((m_yScroll + m_sizeWindow.cy) > GetOverallHeight()))
                ScrollToPosition (m_yScroll - dy);

            /*
             * otherwise, just update the scrollbar
             */
            else
                UpdateScrollSizes();
        }
    }

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnSettingChange
 *
 * WM_SETTINGCHANGE handler for CMessageView.
 *--------------------------------------------------------------------------*/

LRESULT CMessageView::OnSettingChange (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (wParam == SPI_SETNONCLIENTMETRICS)
    {
        DeleteFonts ();
        CreateFonts ();
	}

	UpdateSystemMetrics();
    RecalcLayout ();

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::UpdateSystemMetrics
 *
 * Updates the system metrics used by the message view control.
 *--------------------------------------------------------------------------*/

void CMessageView::UpdateSystemMetrics ()
{
	m_sizeMargin.cx = GetSystemMetrics (SM_CXVSCROLL);
	m_sizeMargin.cy = GetSystemMetrics (SM_CYVSCROLL);
	m_sizeIcon.cx   = GetSystemMetrics (SM_CXICON);
	m_sizeIcon.cy   = GetSystemMetrics (SM_CYICON);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnKeyDown
 *
 * WM_KEYDOWN handler for CMessageView.
 *--------------------------------------------------------------------------*/

LRESULT CMessageView::OnKeyDown (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    return (0);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnVScroll
 *
 * WM_VSCROLL handler for CMessageView.
 *--------------------------------------------------------------------------*/

LRESULT CMessageView::OnVScroll (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	VertScroll (LOWORD (wParam), HIWORD (wParam), 1);
	return (0);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnMouseWheel
 *
 * WM_MOUSEWHEEL handler for CMessageView.
 *--------------------------------------------------------------------------*/

LRESULT CMessageView::OnMouseWheel (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	m_nAccumulatedScrollDelta += GET_WHEEL_DELTA_WPARAM (wParam);

	/*
	 * scroll one line up or down for each WHEEL_DELTA unit in our
	 * accumulated delta
	 */
	const int nScrollCmd    = (m_nAccumulatedScrollDelta < 0) ? SB_LINEDOWN : SB_LINEUP;
	const int nScrollRepeat = abs(m_nAccumulatedScrollDelta) / WHEEL_DELTA;
	VertScroll (nScrollCmd, 0, nScrollRepeat);

	m_nAccumulatedScrollDelta %= WHEEL_DELTA;

	return (0);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::VertScroll
 *
 * Vertical scroll handler for CMessageView.
 *--------------------------------------------------------------------------*/

void CMessageView::VertScroll (
	int	nScrollCmd,				/* I:how to scroll (e.g. SB_LINEUP)			*/
	int	nScrollPos,				/* I:absolute position (SB_THUMBTRACK only)	*/
	int	nRepeat)				/* I:repeat count							*/
{
    int yScroll = m_yScroll;

    switch (nScrollCmd)
    {
        case SB_LINEUP:
            yScroll -= nRepeat * m_cyLine;
            break;

        case SB_LINEDOWN:
            yScroll += nRepeat * m_cyLine;
            break;

        case SB_PAGEUP:
            yScroll -= nRepeat * m_cyPage;
            break;

        case SB_PAGEDOWN:
            yScroll += nRepeat * m_cyPage;
            break;

        case SB_TOP:
            yScroll = m_yScrollMin;
            break;

        case SB_BOTTOM:
            yScroll = m_yScrollMax;
            break;

        case SB_THUMBTRACK:
            yScroll = nScrollPos;
            break;
    }

    ScrollToPosition (yScroll);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnDraw
 *
 * Draw handler for CMessageView.
 *--------------------------------------------------------------------------*/

HRESULT CMessageView::OnDraw(ATL_DRAWINFO& di)
{
	/*
	 * use CDCHandle instead of CDC so the dtor won't delete the DC
	 * (we didn't create it, so we can't delete it)
	 */
    WTL::CDCHandle dc = di.hdcDraw;

    /*
     * handle scrolling
     */
    dc.SetViewportOrg (0, -m_yScroll);

    /*
     * set up colors
     */
    COLORREF clrText = dc.SetTextColor (GetSysColor (COLOR_WINDOWTEXT));
    COLORREF clrBack = dc.SetBkColor   (GetSysColor (COLOR_WINDOW));

    /*
     * get the clipping region for the DC
     */
    WTL::CRect rectT;
    WTL::CRect rectClip;
    dc.GetClipBox (rectClip);

    /*
     * if there is a title and it intersects the clipping region, draw it
     */
    if ((m_TextElement[Title].str.length() > 0) &&
                rectT.IntersectRect (rectClip, m_TextElement[Title].rect))
        DrawTextElement (dc, m_TextElement[Title]);

    /*
     * if there is a body and it intersects the clipping region, draw it
     */
    if ((m_TextElement[Body].str.length() > 0) &&
                rectT.IntersectRect (rectClip, m_TextElement[Body].rect))
        DrawTextElement (dc, m_TextElement[Body]);

    /*
     * if there is an icon and it intersects the clipping region, draw it
     */
    if ((m_hIcon != NULL) && rectT.IntersectRect (rectClip, m_rectIcon))
        dc.DrawIcon (m_rectIcon.TopLeft(), m_hIcon);

    /*
     * restore the DC
     */
    dc.SetTextColor (clrText);
    dc.SetBkColor   (clrBack);

#define SHOW_MARGINS 0
#if (defined(DBG) && SHOW_MARGINS)
    {
        HBRUSH hbr = GetSysColorBrush (COLOR_GRAYTEXT);
        WTL::CRect rectAll;
		WTL::CRect rectTemp;

		rectTemp.UnionRect  (m_TextElement[Body].rect, m_TextElement[Title].rect);
        rectAll.UnionRect   (rectTemp, m_rectIcon);
		rectAll.InflateRect (m_sizeMargin);

        dc.FrameRect (m_TextElement[Title].rect, hbr);
        dc.FrameRect (m_TextElement[Body].rect,  hbr);
        dc.FrameRect (m_rectIcon,                hbr);
        dc.FrameRect (rectAll,                   hbr);
    }
#endif

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::SetTitleText
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMessageView::SetTitleText (LPCOLESTR pszTitleText)
{
    return (SetTextElement (m_TextElement[Title], pszTitleText));
}


/*+-------------------------------------------------------------------------*
 * CMessageView::SetBodyText
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMessageView::SetBodyText (LPCOLESTR pszBodyText)
{
    return (SetTextElement (m_TextElement[Body], pszBodyText));
}


/*+-------------------------------------------------------------------------*
 * CMessageView::SetTextElement
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT CMessageView::SetTextElement (TextElement& te, LPCOLESTR pszNewText)
{
    USES_CONVERSION;
    tstring strNewText;

    if (pszNewText != NULL)
        strNewText = W2CT(pszNewText);

    if (te.str != strNewText)
    {
        te.str = strNewText;
        RecalcLayout();
        Invalidate();
    }

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::SetIcon
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMessageView::SetIcon (IconIdentifier id)
{
    bool fHadIconBefore = (m_hIcon != NULL);

    if (id == Icon_None)
        m_hIcon = NULL;

    else if ((id >= Icon_First) && (id <= Icon_Last))
        m_hIcon = LoadIcon (NULL, MAKEINTRESOURCE (id));

    else
        return (E_INVALIDARG);

    /*
     * if we had an icon before, but we don't have one now (or vice versa)
     * we need to recalculate the layout and redraw everything
     */
    if (fHadIconBefore != (m_hIcon != NULL))
    {
        RecalcLayout();
        Invalidate();
    }

    /*
     * otherwise, just redraw draw the icon
     */
    else
        InvalidateRect (m_rectIcon);

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::Clear
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMessageView::Clear ()
{
    m_TextElement[Title].str.erase();
    m_TextElement[Body].str.erase();
    m_hIcon = NULL;

    RecalcLayout();
    Invalidate();

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::RecalcLayout
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::RecalcLayout()
{
    RecalcIconLayout();
    RecalcTitleLayout();
    RecalcBodyLayout();
    UpdateScrollSizes();
}


/*+-------------------------------------------------------------------------*
 * CMessageView::RecalcIconLayout
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::RecalcIconLayout()
{
    m_rectIcon = WTL::CRect (WTL::CPoint (m_sizeMargin.cx, m_sizeMargin.cy),
                             (m_hIcon != NULL) ? m_sizeIcon : WTL::CSize(0,0));
}


/*+-------------------------------------------------------------------------*
 * CMessageView::RecalcTitleLayout
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::RecalcTitleLayout()
{
    WTL::CRect& rect = m_TextElement[Title].rect;

    /*
     * prime the title rectangle for calculating the text height
	 * (leave room for a vertical scrollbar on the right so its appearance
	 * and disappearance don't affect the layout of the text)
     */
    rect.SetRect (
        m_rectIcon.right,
        m_rectIcon.top,
        _MAX (0, (int) (m_sizeWindow.cx - m_sizeMargin.cx - GetSystemMetrics(SM_CXVSCROLL))),
        0);

    /*
     * if there is an icon, leave a gutter between the icon and title
     */
    if ((m_hIcon != NULL) && (rect.right > 0))
    {
        rect.left += m_cyLine;
        rect.right = _MAX (rect.left, rect.right);
    }

    /*
     * compute the height of the title
     */
        if (m_TextElement[Title].str.length() > 0)
            rect.bottom = rect.top + CalcTextElementHeight (m_TextElement[Title], rect.Width());

    /*
     * if the title is shorter than the icon, center it vertically
     */
    if (rect.Height() < m_rectIcon.Height())
        rect.OffsetRect (0, (m_rectIcon.Height() - rect.Height()) / 2);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::RecalcBodyLayout
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::RecalcBodyLayout()
{
    WTL::CRect& rect = m_TextElement[Body].rect;

    /*
     * prime the body rectangle for calculating the text height
     */

    /* Compute the envelope of the Icon and Title rectangles, and then 
     * shift it down until it no longer overlaps the former two.
     * Bug# 666434: Cannot use UnionRect for computing the envelope because 
     * it ignores empty rectangles. The Icon and Title recatangles can be 
     * empty if SetTitleText or SetIcon haven't been called, or called with
     * empty strings/images
     */
    rect.left  = _MIN (m_rectIcon.left, m_TextElement[Title].rect.left);
    rect.right = _MAX (m_rectIcon.right, m_TextElement[Title].rect.right);
    rect.top   = _MAX (m_rectIcon.bottom, m_TextElement[Title].rect.bottom);
    

    /*
     * compute the height of the body; it starts empty, but adds the
     * height of the body text if we have any
     */
    rect.bottom = rect.top;
    if (m_TextElement[Body].str.length() > 0)
        rect.bottom += CalcTextElementHeight (m_TextElement[Body], rect.Width());

    /*
     * if there's an icon or title, we need to leave
     * a line's worth of space before the body
     */
    if (!rect.IsRectEmpty())
        rect.OffsetRect (0, m_cyLine);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::CalcTextElementHeight
 *
 *
 *--------------------------------------------------------------------------*/

int CMessageView::CalcTextElementHeight (const TextElement& te, int cx)
{
    TextElement teWork = te;
    teWork.rect.SetRect (0, 0, cx, 0);

    DrawTextElement (WTL::CWindowDC(m_hWnd), teWork, DT_CALCRECT);
    teWork.font.Detach();

    return (teWork.rect.Height());
}


/*+-------------------------------------------------------------------------*
 * CMessageView::DrawTextElement
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::DrawTextElement (HDC hdc, TextElement& te, DWORD dwFlags)
{
	/*
	 * use CDCHandle instead of CDC so the dtor won't delete the DC
	 * (we didn't create it, so we can't delete it)
	 */
    WTL::CDCHandle dc = hdc;

    HFONT hFont = dc.SelectFont (te.font);

    dc.DrawText (te.str.data(), te.str.length(), te.rect,
                 DT_LEFT | DT_TOP | DT_WORDBREAK | DT_NOPREFIX | dwFlags);
    dc.SelectFont (hFont);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::CreateFonts
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::CreateFonts ()
{
	/*
     * create a font that's a little larger than the
     * one used for icon titles to use for the body text
	 */
    NONCLIENTMETRICS ncm;
    ncm.cbSize = sizeof (ncm);
    SystemParametersInfo (SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, false);

    m_TextElement[Body].font.CreateFontIndirect (&ncm.lfMessageFont);

    /*
     * create a bold version for the title
     */
    ncm.lfMessageFont.lfWeight = FW_BOLD;
    m_TextElement[Title].font.CreateFontIndirect (&ncm.lfMessageFont);

    /*
     * get the height of a line of text
     */
    SIZE siz;
    TCHAR ch = _T('0');
    WTL::CWindowDC dc(m_hWnd);
    HFONT hFontOld = dc.SelectFont (m_TextElement[Title].font);
    dc.GetTextExtent (&ch, 1, &siz);
    dc.SelectFont (hFontOld);
    m_cyLine = siz.cy;
}


/*+-------------------------------------------------------------------------*
 * CMessageView::DeleteFonts
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::DeleteFonts ()
{
    m_TextElement[Title].font.DeleteObject();
    m_TextElement[Body].font.DeleteObject();
}


/*+-------------------------------------------------------------------------*
 * CMessageView::UpdateScrollSizes
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::UpdateScrollSizes ()
{
    WTL::CRect rect;
    GetClientRect (rect);

    int cyTotal  = GetOverallHeight();
    m_yScrollMax = _MAX (0, cyTotal - rect.Height());

    /*
     * The height of a page is a whole number of lines.  If the window
     * can display N lines at a time, a page will be N-1 lines so there's
     * some continuity after a page up or down.
     */
    if (m_cyLine > 0)
        m_cyPage = rect.Height();// _MAX (0, ((rect.Height() / m_cyLine) - 1) * m_cyLine);
    else
        m_cyPage  = 0;


    /*
     * update the scrollbar
     */
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask  = SIF_PAGE | SIF_RANGE | SIF_POS;
    si.nMax   = cyTotal;
    si.nMin   = m_yScrollMin;
    si.nPage  = m_cyPage;
    si.nPos   = m_yScroll;

    SetScrollInfo (SB_VERT, &si);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::ScrollToPosition
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::ScrollToPosition (int yScroll)
{
    yScroll = _MIN (m_yScrollMax, _MAX (m_yScrollMin, yScroll));

    if (m_yScroll != yScroll)
    {
        int dy = m_yScroll - yScroll;
        m_yScroll = yScroll;

        ScrollWindow (0, dy);
        UpdateScrollSizes();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\mmcprotocol.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       mmcprotocol.h
//
//  Purpose: Creates a temporary pluggable internet protocol, mmc:
//
//  History: 14-April-2000 Vivekj added
//--------------------------------------------------------------------------

extern const CLSID CLSID_MMCProtocol;

class CMMCProtocol : 
    public IInternetProtocol,
    public IInternetProtocolInfo,
    public CComObjectRoot,
    public CComCoClass<CMMCProtocol, &CLSID_MMCProtocol>
{
    typedef CMMCProtocol ThisClass;

public:
    BEGIN_COM_MAP(ThisClass)
        COM_INTERFACE_ENTRY(IInternetProtocol)
        COM_INTERFACE_ENTRY(IInternetProtocolRoot)
	    COM_INTERFACE_ENTRY(IInternetProtocolInfo)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass)

    DECLARE_MMC_OBJECT_REGISTRATION (
		g_szMmcndmgrDll,						// implementing DLL
        CLSID_MMCProtocol     ,				    // CLSID
        _T("MMC Plugable Internet Protocol"),   // class name
        _T("NODEMGR.MMCProtocol.1"),		    // ProgID
        _T("NODEMGR.MMCProtocol"))		        // version-independent ProgID


    static SC ScRegisterProtocol();
    static SC ScParseTaskpadURL( LPCWSTR strURL, GUID& guid );
    static SC ScParsePageBreakURL( LPCWSTR strURL, bool& bPageBreak );
    static SC ScGetTaskpadXML( const GUID& guid, std::wstring& strResultData );
    static void ExpandMMCVars(std::wstring& str);
    static void AppendMMCPath(std::wstring& str);

    // IInternetProtocolRoot interface

    STDMETHODIMP Start(LPCWSTR szUrl, IInternetProtocolSink *pOIProtSink, IInternetBindInfo *pOIBindInfo, DWORD grfPI, HANDLE_PTR dwReserved);
    STDMETHODIMP Continue(PROTOCOLDATA *pProtocolData);
    STDMETHODIMP Abort(HRESULT hrReason, DWORD dwOptions);
    STDMETHODIMP Terminate(DWORD dwOptions);
    STDMETHODIMP Suspend();
    STDMETHODIMP Resume();

    // IInternetProtocol interface

    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP LockRequest(DWORD dwOptions);    
    STDMETHODIMP UnlockRequest();

    // IInternetProtocolInfo interface
    STDMETHODIMP ParseUrl(  LPCWSTR pwzUrl, PARSEACTION ParseAction, DWORD dwParseFlags, LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved);
    STDMETHODIMP CombineUrl(LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl,DWORD dwCombineFlags, LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved);
    STDMETHODIMP CompareUrl(LPCWSTR pwzUrl1, LPCWSTR pwzUrl2,DWORD dwCompareFlags);
    STDMETHODIMP QueryInfo( LPCWSTR pwzUrl, QUERYOPTION OueryOption,DWORD dwQueryFlags, LPVOID pBuffer, DWORD cbBuffer, DWORD *pcbBuf, DWORD dwReserved);

private:
    std::wstring             m_strData;      // contents of the specified URL             
    size_t                   m_uiReadOffs;   // present read location
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\msgview.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      msgview.h
 *
 *  Contents:  Interface file for CMessageView
 *
 *  History:   28-Apr-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef __MESSAGEVIEW_H_
#define __MESSAGEVIEW_H_

#include "tstring.h"


/////////////////////////////////////////////////////////////////////////////
// CMessageView
class ATL_NO_VTABLE CMessageView :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMessageView, &CLSID_MessageView>,
    public CComControl<CMessageView>,
	public IMessageView,
    public IPersistStreamInitImpl<CMessageView>,
    public IOleControlImpl<CMessageView>,
    public IOleObjectImpl<CMessageView>,
    public IOleInPlaceActiveObjectImpl<CMessageView>,
    public IViewObjectExImpl<CMessageView>,
    public IOleInPlaceObjectWindowlessImpl<CMessageView>
{
public:
    CMessageView();
   ~CMessageView();

DECLARE_NOT_AGGREGATABLE(CMessageView)

DECLARE_MMC_OBJECT_REGISTRATION (
	g_szMmcndmgrDll,					// implementing DLL
    CLSID_MessageView,              	// CLSID
    _T("MessageView Class"),            // class name
    _T("MessageView.MessageView.1"),    // ProgID
    _T("MessageView.MessageView"))      // version-independent ProgID

BEGIN_COM_MAP(CMessageView)
    COM_INTERFACE_ENTRY(IMessageView)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CMessageView)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
//  PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CMessageView)
    MESSAGE_HANDLER (WM_CREATE,         OnCreate)
    MESSAGE_HANDLER (WM_DESTROY,        OnDestroy)
    MESSAGE_HANDLER (WM_SIZE,           OnSize)
    MESSAGE_HANDLER (WM_SETTINGCHANGE,  OnSettingChange)
    MESSAGE_HANDLER (WM_KEYDOWN,        OnKeyDown)
    MESSAGE_HANDLER (WM_VSCROLL,        OnVScroll)
    MESSAGE_HANDLER (WM_MOUSEWHEEL,     OnMouseWheel)
	CHAIN_MSG_MAP (CComControl<CMessageView>)
END_MSG_MAP()

#define MESSAGE_HANDLER_FUNC(func)  LRESULT (func)(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

    MESSAGE_HANDLER_FUNC (OnCreate);
    MESSAGE_HANDLER_FUNC (OnDestroy);
    MESSAGE_HANDLER_FUNC (OnSize);
    MESSAGE_HANDLER_FUNC (OnSettingChange);
    MESSAGE_HANDLER_FUNC (OnKeyDown);
    MESSAGE_HANDLER_FUNC (OnVScroll);
    MESSAGE_HANDLER_FUNC (OnMouseWheel);

    DECLARE_WND_CLASS_EX(NULL, CS_HREDRAW, COLOR_WINDOW);

// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

// IMessageView
    STDMETHOD(SetTitleText)(LPCOLESTR pszTitleText);
    STDMETHOD(SetBodyText)(LPCOLESTR pszBodyText);
    STDMETHOD(SetIcon)(IconIdentifier id);
    STDMETHOD(Clear)();


public:
    HRESULT OnDraw(ATL_DRAWINFO& di);

private:
    void RecalcLayout();
    void RecalcIconLayout();
    void RecalcTitleLayout();
    void RecalcBodyLayout();
	void UpdateSystemMetrics();

    struct TextElement;
    void DrawTextElement (HDC hdc, TextElement& te, DWORD dwFlags = 0);
    int CalcTextElementHeight (const TextElement& te, int cx);
    HRESULT SetTextElement (TextElement& te, LPCOLESTR pszNewText);

    void CreateFonts ();
    void DeleteFonts ();

	void VertScroll (int nScrollCmd, int nScrollPos, int nRepeat);
    void ScrollToPosition (int yScroll);
    void UpdateScrollSizes ();

    int GetOverallHeight() const
        { return (m_TextElement[Body].rect.bottom + m_sizeMargin.cy); }


private:
    enum { Title, Body, ElementCount };

    struct TextElement
    {
        TextElement() : rect (0,0,0,0) {}

        tstring		str;
        WTL::CFont	font;
        WTL::CRect	rect;
    };

    TextElement m_TextElement[ElementCount];

    HICON       m_hIcon;
    WTL::CRect  m_rectIcon;

    // for scrolling
    int         m_yScroll;
    int         m_yScrollMax;
    int         m_yScrollMin;
    int         m_cyPage;
    int         m_cyLine;
	int			m_nAccumulatedScrollDelta;		// for WM_MOUSEWHEEL processing

    WTL::CSize  m_sizeWindow;
    WTL::CSize	m_sizeIcon;
    WTL::CSize	m_sizeMargin;
};

#endif //__MESSAGEVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\msimodul.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       msimodul.h
//
//--------------------------------------------------------------------------

// msimodl.h : header file for class CMsiModule
//

#ifndef __MSIMODL_H__
#define __MSIMODL_H__ 

#include <msi.h>
#include <msiquery.h>

class CMsiModule
{
    typedef UINT (*EnumQualCompFncPtr)(LPTSTR, DWORD, LPTSTR, DWORD*, LPTSTR, DWORD*);
    typedef UINT (*ProvideQualCompFncPtr)(LPCTSTR, LPCTSTR, DWORD, LPTSTR, DWORD*);
    typedef UINT (*LocateCompFncPtr)(LPCTSTR, LPTSTR, DWORD*);

public:
    CMsiModule(void) : hMsiDll(NULL), pfnEnumQualComp(NULL), pfnProvideQualComp(NULL) 
    {
        hMsiDll = LoadLibrary(TEXT("msi.dll"));

        if (hMsiDll != NULL)
        {

	#ifdef _UNICODE
            pfnEnumQualComp = reinterpret_cast<EnumQualCompFncPtr>
                                (GetProcAddress(hMsiDll, "MsiEnumComponentQualifiersW"));
            ASSERT(pfnEnumQualComp != NULL);

            pfnProvideQualComp = reinterpret_cast<ProvideQualCompFncPtr>
                                    (GetProcAddress(hMsiDll, "MsiProvideQualifiedComponentW"));
            ASSERT(pfnProvideQualComp != NULL);

            pfnLocateComp = reinterpret_cast<LocateCompFncPtr>
                                    (GetProcAddress(hMsiDll, "MsiLocateComponentW"));
            ASSERT(pfnLocateComp != NULL); 
	#else
            pfnEnumQualComp = reinterpret_cast<EnumQualCompFncPtr>
                                (GetProcAddress(hMsiDll, "MsiEnumComponentQualifiersA"));
            ASSERT(pfnEnumQualComp != NULL);

            pfnProvideQualComp = reinterpret_cast<ProvideQualCompFncPtr>
                                    (GetProcAddress(hMsiDll, "MsiProvideQualifiedComponentA"));
            ASSERT(pfnProvideQualComp != NULL);

            pfnLocateComp = reinterpret_cast<LocateCompFncPtr>
                                    (GetProcAddress(hMsiDll, "MsiLocateComponentA"));
            ASSERT(pfnLocateComp != NULL); 

	#endif // _UNICODE

       }
    }
    
    ~CMsiModule(void) { if (hMsiDll != NULL) FreeLibrary(hMsiDll); }

    BOOL IsPresent(void) { return (hMsiDll != NULL); }

    UINT EnumComponentQualifiers( LPTSTR szComponent, DWORD iIndex, 
                                     LPTSTR lpQualifierBuf, DWORD *pcchQualifierBuf,  
                                     LPTSTR lpApplicationDataBuf, DWORD *pcchApplicationDataBuf)
    {
        if (pfnEnumQualComp == NULL)
            return ERROR_CALL_NOT_IMPLEMENTED;

        return pfnEnumQualComp(szComponent, iIndex, lpQualifierBuf, pcchQualifierBuf,
                                 lpApplicationDataBuf, pcchApplicationDataBuf);
    }

    UINT ProvideQualifiedComponent( LPCTSTR szComponent, LPCTSTR szQualifier, DWORD dwInstallMode, 
                                       LPTSTR lpPathBuf, DWORD *pcchPathBuf)
    {
        if (pfnProvideQualComp == NULL)
            return ERROR_CALL_NOT_IMPLEMENTED;

        return pfnProvideQualComp(szComponent, szQualifier, dwInstallMode, lpPathBuf, pcchPathBuf);
    }

    UINT LocateComponent( LPCTSTR szComponent, LPTSTR lpPathBuf, DWORD *pcchPathBuf)
    {
        if (pfnLocateComp == NULL)
            return ERROR_CALL_NOT_IMPLEMENTED;

        return pfnLocateComp(szComponent, lpPathBuf, pcchPathBuf);
    }
                                     
private:      
    HMODULE hMsiDll;
    EnumQualCompFncPtr pfnEnumQualComp;
    ProvideQualCompFncPtr pfnProvideQualComp;
    LocateCompFncPtr pfnLocateComp;

};


CMsiModule& MsiModule()
{
    static CMsiModule MsiModuleInstance;

    return MsiModuleInstance;
}


#endif // __MSIMODL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\mtnode.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       MTNode.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9/17/1996   RaviR   Created
//____________________________________________________________________________
//


#include "stdafx.h"
#include "nodemgr.h"
#include "comdbg.h"
#include "regutil.h"
#include "bitmap.h"
#include "dummysi.h"
#include "tasks.h"
#include "policy.h"
#include "bookmark.h"
#include "nodepath.h"
#include "siprop.h"
#include "util.h"
#include "addsnpin.h"
#include "about.h"
#include "nodemgrdebug.h"

extern const CLSID CLSID_FolderSnapin;
extern const CLSID CLSID_OCXSnapin;
extern const CLSID CLSID_HTMLSnapin;


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// {118B559C-6D8C-11d0-B503-00C04FD9080A}
const GUID IID_PersistData =
{ 0x118b559c, 0x6d8c, 0x11d0, { 0xb5, 0x3, 0x0, 0xc0, 0x4f, 0xd9, 0x8, 0xa } };

//############################################################################
//############################################################################
//
//  Implementation of class CStorage
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 * class CStorage
 *
 *
 * PURPOSE: Wrapper for IStorage. Provides several utility functions.
 *
 *+-------------------------------------------------------------------------*/
class CStorage
{
    IStoragePtr m_spStorage;

public:
    CStorage() {}

    CStorage(IStorage *pStorage)
    {
        m_spStorage = pStorage;
    }

    CStorage & operator = (const CStorage &rhs)
    {
        m_spStorage = rhs.m_spStorage;
        return *this;
    }

    void Attach(IStorage *pStorage)
    {
        m_spStorage = pStorage;
    }

    IStorage *Get()
    {
        return m_spStorage;
    }

    // create this storage below the specified storage
    SC  ScCreate(CStorage &storageParent, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName)
    {
        SC sc;
        sc = CreateDebugStorage(storageParent.Get(), name, grfMode, instanceName, &m_spStorage);
        return sc;
    }

    SC  ScMoveElementTo(const wchar_t *name, CStorage &storageDest, const wchar_t *newName, DWORD grfFlags)
    {
        SC sc;
        if(!Get() || ! storageDest.Get())
            goto PointerError;

        sc = m_spStorage->MoveElementTo(name, storageDest.Get(), newName, grfFlags);
        // error STG_E_FILENOTFOUND must be treated differently, since it is expected
        // to occur and means the end of move operation (loop) in ScConvertLegacyNode.
        // Do not trace in this case.
        if(sc == SC(STG_E_FILENOTFOUND))
            goto Cleanup;
        if(sc)
            goto Error;

        Cleanup:
            return sc;
        PointerError:
            sc = E_POINTER;
        Error:
            TraceError(TEXT("CStorage::ScMoveElementTo"), sc);
            goto Cleanup;
    }

};

//############################################################################
//############################################################################
//
//  Implementation of class CStream
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CStream
 *
 *
 * PURPOSE: Wrapper for IStream. Provides several utility functions.
 *
 *+-------------------------------------------------------------------------*/
class CStream
{
    IStreamPtr m_spStream;
    typedef IStream *PSTREAM;

public:
    CStream() {}

    CStream(IStream *pStream)
    {
        m_spStream = pStream;
    }

    CStream & operator = (const CStream &rhs)
    {
        m_spStream = rhs.m_spStream;
        return *this;
    }

    void Attach(IStream *pStream)
    {
        m_spStream = pStream;
    }

    IStream *Get()
    {
        return m_spStream;
    }

    operator IStream&()
    {
        return *m_spStream;
    }

    // create this stream below the specified storage
    SC ScCreate(CStorage& storageParent, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName)
    {
        SC sc;
        sc = CreateDebugStream(storageParent.Get(), name, grfMode, instanceName, &m_spStream);
        return sc;
    }


    /*+-------------------------------------------------------------------------*
     *
     * ScRead
     *
     * PURPOSE: Reads the specified object from the stream.
     *
     * PARAMETERS:
     *    void *  pv :      The location of the object.
     *    size_t  size :    The size of the object.
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    SC  ScRead(void *pv, size_t size, bool bIgnoreErrors = false)
    {
        DECLARE_SC(sc, TEXT("CStream::ScRead"));

        // parameter check
        sc = ScCheckPointers(pv);
        if (sc)
            return sc;

        // internal pointer check
        sc = ScCheckPointers(m_spStream, E_POINTER);
        if (sc)
            return sc;

        // read the data
        ULONG bytesRead = 0;
        sc = m_spStream->Read(pv, size, &bytesRead);

        // if we need to ignore errors, just return.
        if(bIgnoreErrors)
            return sc.Clear(), sc;

        if (sc)
            return sc;

        // since this function does not return the number of bytes read,
        // failure to read as may as requested should be treated as error
        if (sc == SC(S_FALSE) || bytesRead != size)
            return sc = E_FAIL;

        return sc;
    }

    /*+-------------------------------------------------------------------------*
     *
     * ScWrite
     *
     * PURPOSE: Writes the specified object to the stream
     *
     * PARAMETERS:
     *    const   void :
     *    size_t  size :
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    SC  ScWrite(const void *pv, size_t size)
    {
        DECLARE_SC(sc, TEXT("CStream::ScWrite"));

        // parameter check
        sc = ScCheckPointers(pv);
        if (sc)
            return sc;

        // internal pointer check
        sc = ScCheckPointers(m_spStream, E_POINTER);
        if (sc)
            return sc;

        // write the data

        ULONG   bytesWritten = 0;
        sc = m_spStream->Write(pv, size, &bytesWritten);
        if (sc)
            return sc;

        // since this function does not return the number of bytes written,
        // failure to write as may as requested should be treated as error
        if (bytesWritten != size)
            return sc = E_FAIL;

        return sc;
    }
};



/////////////////////////////////////////////////////////////////////////////
// Forward declaration of helper functions defined below

SC  ScLoadBitmap (CStream &stream, HBITMAP* pBitmap);
void PersistBitmap (CPersistor &persistor, LPCTSTR name, HBITMAP& hBitmap);

static inline SC ScWriteEmptyNode(CStream &stream)
{
    SC          sc;
    int         nt = 0;

    sc = stream.ScWrite(&nt, sizeof(nt));
    if(sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(TEXT("ScWriteEmptyNode"), sc);
    goto Cleanup;
}

static inline CLIPFORMAT GetPreLoadFormat (void)
{
    static CLIPFORMAT s_cfPreLoads = 0;
    if (s_cfPreLoads == 0) {
        USES_CONVERSION;
        s_cfPreLoads = (CLIPFORMAT) RegisterClipboardFormat (W2T(CCF_SNAPIN_PRELOADS));
    }
    return s_cfPreLoads;
}

//############################################################################
//############################################################################
//
//  Implementation of class CMTNode
//
//############################################################################
//############################################################################
DEBUG_DECLARE_INSTANCE_COUNTER(CMTNode);

// Static member
MTNODEID CMTNode::m_NextID = ROOTNODEID;


CMTNode::CMTNode()
: m_ID(GetNextID()), m_pNext(NULL), m_pChild(NULL), m_pParent(NULL),
  m_bIsDirty(true), m_cRef(1), m_usFlags(0), m_bLoaded(false),
  m_bookmark(NULL), m_pPrev(NULL), m_pLastChild(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CMTNode);
    Reset();
    m_nImage = eStockImage_Folder;
    m_nOpenImage = eStockImage_OpenFolder;
    m_nState = 0;
}


void CMTNode::Reset()
{
	m_idOwner               = TVOWNED_MAGICWORD;
	m_lUserParam            = 0;
	m_pPrimaryComponentData = NULL;
	m_bInit                 = false;
	m_bExtensionsExpanded   = false;
	m_usExpandFlags         = 0;

    ResetExpandedAtLeastOnce();
}


CMTNode::~CMTNode()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CMTNode);
    DECLARE_SC(sc, TEXT("CMTNode::~CMTNode"));

    if (IsPropertyPageDisplayed() == TRUE)
        MMCIsMTNodeValid(this, TRUE);

    ASSERT(m_pNext == NULL);
    ASSERT(m_pPrev == NULL);
    ASSERT(m_pParent == NULL);
    ASSERT(m_cRef == 0);

    CScopeTree *pScopeTree = CScopeTree::GetScopeTree();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (!sc)
    {
        sc = pScopeTree->ScUnadviseMTNode(this);
    }

    if (m_pChild != NULL)
    {
        // Don't recurse the siblings of the child.
        CMTNode* pMTNodeCurr = m_pChild;
        while (pMTNodeCurr)
        {
            m_pChild = pMTNodeCurr->Next();
            pMTNodeCurr->AttachNext(NULL);
            pMTNodeCurr->AttachParent(NULL);
            pMTNodeCurr->AttachPrev(NULL);
            pMTNodeCurr->Release();
            pMTNodeCurr = m_pChild;
        }

        m_pChild = NULL;
    }

    // DON'T CHANGE THE ORDER OF THESE NULL ASSIGNMENTS!!!!!!!!!
    m_spTreeStream = NULL;
    m_spViewStorage = NULL;
    m_spCDStorage = NULL;
    m_spNodeStorage = NULL;
    m_spPersistData = NULL;

    if (m_pParent != NULL)
    {
        ASSERT(false); /* The following appears to be dead code */

        if (m_pParent->m_pChild == this)
        {
            m_pParent->m_pChild = NULL;
            if (GetStaticParent() == this)
                m_pParent->SetDirty();
        }
    }
}

// Was MMCN_REMOVE_CHILDREN sent to the snapin owning this node or its parent
bool CMTNode::AreChildrenBeingRemoved ()
{
    if (_IsFlagSet(FLAG_REMOVING_CHILDREN))
        return true;

    if (Parent())
        return Parent()->AreChildrenBeingRemoved ();

    return false;
}

CMTNode* CMTNode::FromScopeItem (HSCOPEITEM item)
{
    CMTNode* pMTNode = reinterpret_cast<CMTNode*>(item);
    
    pMTNode = dynamic_cast<CMTNode*>(pMTNode);

    return (pMTNode);
}

/*+-------------------------------------------------------------------------*
 * class CMMCSnapIn
 *
 *
 * PURPOSE: The COM 0bject that exposes the SnapIn interface.
 *
 *+-------------------------------------------------------------------------*/
class CMMCSnapIn :
    public CMMCIDispatchImpl<SnapIn>, // the View interface
    public CTiedComObject<CMTSnapInNode>
{
    typedef CMTSnapInNode CMyTiedObject;
    typedef std::auto_ptr<CSnapinAbout> SnapinAboutPtr;

public:
    BEGIN_MMC_COM_MAP(CMMCSnapIn)
    END_MMC_COM_MAP()

public:
    MMC_METHOD1(get_Name,       PBSTR      /*pbstrName*/);
    STDMETHOD(get_Vendor)( PBSTR pbstrVendor );
    STDMETHOD(get_Version)( PBSTR pbstrVersion );
    MMC_METHOD1(get_Extensions, PPEXTENSIONS  /*ppExtensions*/);
    MMC_METHOD1(get_SnapinCLSID,PBSTR      /*pbstrSnapinCLSID*/);
    MMC_METHOD1(get_Properties, PPPROPERTIES /*ppProperties*/);
    MMC_METHOD1(EnableAllExtensions, BOOL    /*bEnable*/);

    // not an interface method,
    // just a convenient way to reach for tied object's method
    MMC_METHOD1(GetSnapinClsid, CLSID& /*clsid*/);

    CMTSnapInNode *GetMTSnapInNode();

private:
    ::SC ScGetSnapinAbout(CSnapinAbout*& pAbout);

private:
    SnapinAboutPtr m_spSnapinAbout;
};


/*+-------------------------------------------------------------------------*
 * class CExtension
 *
 *
 * PURPOSE: The COM 0bject that exposes the SnapIn interface.
 *
 *          This extension is not tied to any object. An extension snapin instance
 *          can be uniquely identified by combination of its class-id & its primary
 *          snapin's class-id. So this object just stores this data.
 *          See addsnpin.h for more comments.
 *
 *+-------------------------------------------------------------------------*/
class CExtension :
    public CMMCIDispatchImpl<Extension>
{
    typedef std::auto_ptr<CSnapinAbout> SnapinAboutPtr;

public:
    BEGIN_MMC_COM_MAP(CExtension)
    END_MMC_COM_MAP()

public:
    STDMETHODIMP get_Name( PBSTR  pbstrName);
    STDMETHODIMP get_Vendor( PBSTR  pbstrVendor);
    STDMETHODIMP get_Version( PBSTR  pbstrVersion);
    STDMETHODIMP get_Extensions( PPEXTENSIONS ppExtensions);
    STDMETHODIMP get_SnapinCLSID( PBSTR  pbstrSnapinCLSID);
    STDMETHODIMP EnableAllExtensions(BOOL bEnable);
    STDMETHODIMP Enable(BOOL bEnable = TRUE);

    CExtension() : m_clsidAbout(GUID_NULL) {}

    void Init(const CLSID& clsidExtendingSnapin, const CLSID& clsidThisExtension, const CLSID& clsidAbout)
    {
        m_clsidExtendingSnapin = clsidExtendingSnapin;
        m_clsidThisExtension   = clsidThisExtension;
        m_clsidAbout           = clsidAbout;
    }

    LPCOLESTR GetVersion()
    {
        CSnapinAbout *pSnapinAbout = GetSnapinAbout();
        if (! pSnapinAbout)
            return NULL;

        return pSnapinAbout->GetVersion();
    }

    LPCOLESTR GetVendor()
    {
        CSnapinAbout *pSnapinAbout = GetSnapinAbout();
        if (! pSnapinAbout)
            return NULL;

        return pSnapinAbout->GetCompanyName();
    }

private:
    CSnapinAbout* GetSnapinAbout()
    {
        // If about object is already created just return it.
        if (m_spExtensionAbout.get())
            return m_spExtensionAbout.get();

        if (m_clsidAbout == GUID_NULL)
            return NULL;

        // Else create & initialize the about object.
        m_spExtensionAbout = SnapinAboutPtr (new CSnapinAbout);
        if (! m_spExtensionAbout.get())
            return NULL;

        if (m_spExtensionAbout->GetSnapinInformation(m_clsidAbout))
            return m_spExtensionAbout.get();

        return NULL;
    }

private:
    CLSID         m_clsidThisExtension;
    CLSID         m_clsidExtendingSnapin;

    CLSID         m_clsidAbout;

    SnapinAboutPtr m_spExtensionAbout;
};


//############################################################################
//############################################################################
//
//  Implementation of class CExtensions
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CExtensions
 *
 *
 * PURPOSE: Implements the Extensions automation interface.
 *
 * The Scget_Extensions uses this class as a template parameter to the typedef
 * below. The typedef is an array of Extension objects, that needs atleast below
 * empty class declared. Scget_Extensions adds the extensions to the array.
 *
 *    typedef CComObject< CMMCArrayEnum<Extensions, Extension> > CMMCExtensions;
 *
 *+-------------------------------------------------------------------------*/
class CExtensions :
    public CMMCIDispatchImpl<Extensions>,
    public CTiedObject                     // enumerators are tied to it
{
protected:
    typedef void CMyTiedObject;
};


// Helper functions used by both CMMCSnapIn as well as CExtension.
SC Scget_Extensions(const CLSID& clsidPrimarySnapin, PPEXTENSIONS  ppExtensions);
SC ScEnableAllExtensions (const CLSID& clsidPrimarySnapin, BOOL bEnable);


//+-------------------------------------------------------------------
//
//  Member:      Scget_Extensions
//
//  Synopsis:    Helper function, given class-id of primary creates &
//               returns the extensions collection for this snapin.
//
//  Arguments:   [clsidPrimarySnapin] -
//               [ppExtensions]       - out param, extensions collection.
//
//  Returns:     SC
//
//  Note:        Collection does not include dynamic extensions.
//
//--------------------------------------------------------------------
SC Scget_Extensions(const CLSID& clsidPrimarySnapin, PPEXTENSIONS  ppExtensions)
{
    DECLARE_SC(sc, TEXT("Scget_Extensions"));
    sc = ScCheckPointers(ppExtensions);
    if (sc)
        return sc;

    *ppExtensions = NULL;

    // Create the extensions collection (which also implements the enumerator).
    typedef CComObject< CMMCArrayEnum<Extensions, Extension> > CMMCExtensions;
    CMMCExtensions *pMMCExtensions = NULL;
    sc = CMMCExtensions::CreateInstance(&pMMCExtensions);
    if (sc)
        return sc;

    sc = ScCheckPointers(pMMCExtensions, E_UNEXPECTED);
    if (sc)
        return sc;

    typedef CComPtr<Extension> CMMCExtensionPtr;
    typedef std::vector<CMMCExtensionPtr> ExtensionSnapins;
    ExtensionSnapins extensions;

    // Now get the extensions for this collection from this snapin.
    CExtensionsCache extnsCache;
    sc = MMCGetExtensionsForSnapIn(clsidPrimarySnapin, extnsCache);
    if (sc)
        return sc;

    // Create Extension object for each non-dynamic extension.
    CExtensionsCacheIterator it(extnsCache);

    for (; it.IsEnd() == FALSE; it.Advance())
    {
        // Collection does not include dynamic extensions.
        if (CExtSI::EXT_TYPE_DYNAMIC & it.GetValue())
            continue;

        typedef CComObject<CExtension> CMMCExtensionSnap;
        CMMCExtensionSnap *pExtension = NULL;

        sc = CMMCExtensionSnap::CreateInstance(&pExtension);
        if (sc)
            return sc;

        sc = ScCheckPointers(pExtension, E_UNEXPECTED);
        if (sc)
            return sc;

        CLSID clsidAbout;
        sc = ScGetAboutFromSnapinCLSID(it.GetKey(), clsidAbout);
        if (sc)
            sc.TraceAndClear();

        // Make the Extension aware of its primary snapin & about object.
        pExtension->Init(clsidPrimarySnapin, it.GetKey(), clsidAbout);

        extensions.push_back(pExtension);
    }

    // Fill this data into the extensions collection.
    pMMCExtensions->Init(extensions.begin(), extensions.end());

    sc = pMMCExtensions->QueryInterface(ppExtensions);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      ScEnableAllExtensions
//
//  Synopsis:    Helper function, given class-id of primary enables
//               all extensions or un-checks the enable all so that
//               individual extension can be disabled.
//
//  Arguments:   [clsidPrimarySnapin] -
//               [bEnable]            - enable or disable.
//
//  Returns:     SC
//
//  Note:        Collection does not include dynamic extensions.
//
//--------------------------------------------------------------------
SC ScEnableAllExtensions (const CLSID& clsidPrimarySnapin, BOOL bEnable)
{
    DECLARE_SC(sc, _T("ScEnableAllExtensions"));

    // Create snapin manager.
    CScopeTree *pScopeTree = CScopeTree::GetScopeTree();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CSnapinManager snapinMgr(pScopeTree->GetRoot());

    // Ask the snapinMgr to enable/disable its extensions.
    sc = snapinMgr.ScEnableAllExtensions(clsidPrimarySnapin, bEnable);
    if (sc)
        return sc.ToHr();

    // Update the scope tree with changes made by snapin manager.
    sc = pScopeTree->ScAddOrRemoveSnapIns(snapinMgr.GetDeletedNodesList(),
                                          snapinMgr.GetNewNodes());
    if (sc)
        return sc.ToHr();

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CExtension::get_Name
//
//  Synopsis:    Return the name of this extension.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
STDMETHODIMP CExtension::get_Name (PBSTR  pbstrName)
{
    DECLARE_SC(sc, _T("CExtension::get_Name"));
    sc = ScCheckPointers(pbstrName);
    if (sc)
        return sc.ToHr();

    *pbstrName = NULL;

    tstring tszSnapinName;
    bool bRet = GetSnapinNameFromCLSID(m_clsidThisExtension, tszSnapinName);
    if (!bRet)
        return (sc = E_FAIL).ToHr();

    USES_CONVERSION;
    *pbstrName = SysAllocString(T2COLE(tszSnapinName.data()));
    if ( (! *pbstrName) && (tszSnapinName.length() > 0) )
        return (sc = E_OUTOFMEMORY).ToHr();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CExtension::get_Vendor
//
//  Synopsis:    Get the vendor information for this extension if it exists.
//
//  Arguments:   [pbstrVendor] - out param, ptr to vendor info.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CExtension::get_Vendor (PBSTR  pbstrVendor)
{
    DECLARE_SC(sc, _T("CExtension::get_Vendor"));
    sc = ScCheckPointers(pbstrVendor);
    if (sc)
        return sc.ToHr();

    LPCOLESTR lpszVendor = GetVendor();

    *pbstrVendor = SysAllocString(lpszVendor);
    if ((lpszVendor) && (! *pbstrVendor))
        return (sc = E_OUTOFMEMORY).ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CExtension::get_Version
//
//  Synopsis:    Get the version info for this extension if it exists.
//
//  Arguments:   [pbstrVersion] - out param, ptr to version info.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CExtension::get_Version (PBSTR  pbstrVersion)
{
    DECLARE_SC(sc, _T("CExtension::get_Version"));
    sc = ScCheckPointers(pbstrVersion);
    if (sc)
        return sc.ToHr();

    LPCOLESTR lpszVersion = GetVersion();

    *pbstrVersion = SysAllocString(lpszVersion);
    if ((lpszVersion) && (! *pbstrVersion))
        return (sc = E_OUTOFMEMORY).ToHr();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CExtension::get_SnapinCLSID
//
//  Synopsis:    Get the extension snapin class-id.
//
//  Arguments:   [pbstrSnapinCLSID] - out param, snapin class-id.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CExtension::get_SnapinCLSID (PBSTR  pbstrSnapinCLSID)
{
    DECLARE_SC(sc, _T("CExtension::get_SnapinCLSID"));
    sc = ScCheckPointers(pbstrSnapinCLSID);
    if (sc)
        return sc.ToHr();

    CCoTaskMemPtr<OLECHAR> szSnapinClsid;

    sc = StringFromCLSID(m_clsidThisExtension, &szSnapinClsid);
    if (sc)
        return sc.ToHr();

    *pbstrSnapinCLSID = SysAllocString(szSnapinClsid);
    if (! *pbstrSnapinCLSID)
        sc = E_OUTOFMEMORY;

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CExtension::ScEnable
//
//  Synopsis:    Enable or disable this extension
//
//  Arguments:   [bEnable] - enable or disable.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
STDMETHODIMP CExtension::Enable (BOOL bEnable /*= TRUE*/)
{
    DECLARE_SC(sc, _T("CExtension::ScEnable"));

    /*
     * 1. Create snapin manager.
     * 2. Ask snapin mgr to disable this snapin.
     */

    // Create snapin manager.
    CScopeTree *pScopeTree = CScopeTree::GetScopeTree();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CSnapinManager snapinMgr(pScopeTree->GetRoot());

    // Ask the snapinMgr to disable this extension.
    sc = snapinMgr.ScEnableExtension(m_clsidExtendingSnapin, m_clsidThisExtension, bEnable);
    if (sc)
        return sc.ToHr();

    // Update the scope tree with changes made by snapin manager.
    sc = pScopeTree->ScAddOrRemoveSnapIns(snapinMgr.GetDeletedNodesList(),
                                          snapinMgr.GetNewNodes());
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CExtension::Scget_Extensions
//
//  Synopsis:    Get the extensions collection for this snapin.
//
//  Arguments:   [ppExtensions] - out ptr to extensions collection.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
HRESULT CExtension::get_Extensions( PPEXTENSIONS  ppExtensions)
{
    DECLARE_SC(sc, _T("CExtension::get_Extensions"));
    sc = ScCheckPointers(ppExtensions);
    if (sc)
        return sc.ToHr();

    *ppExtensions = NULL;

    sc = ::Scget_Extensions(m_clsidThisExtension, ppExtensions);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CExtension::EnableAllExtensions
//
//  Synopsis:    Enable/Disable all the extensions of this snapin.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CExtension::EnableAllExtensions(BOOL bEnable)
{
    DECLARE_SC(sc, TEXT("CExtension::EnableAllExtensions"));

    sc = ::ScEnableAllExtensions(m_clsidThisExtension, bEnable);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CMTSnapInNode::ScGetCMTSnapinNode
//
//  Synopsis:    Static function, given PSNAPIN (SnapIn interface)
//               return the CMTSnapInNode of that snapin.
//
//  Arguments:   [pSnapIn] - Snapin interface.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMTSnapInNode::ScGetCMTSnapinNode(PSNAPIN pSnapIn, CMTSnapInNode **ppMTSnapInNode)
{
    DECLARE_SC(sc, _T("CMTSnapInNode::GetCMTSnapinNode"));
    sc = ScCheckPointers(pSnapIn, ppMTSnapInNode);
    if (sc)
        return sc;

    *ppMTSnapInNode = NULL;

    CMMCSnapIn *pMMCSnapIn = dynamic_cast<CMMCSnapIn*>(pSnapIn);
    if (!pMMCSnapIn)
        return (sc = E_UNEXPECTED);

    *ppMTSnapInNode = pMMCSnapIn->GetMTSnapInNode();

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CMTSnapInNode::Scget_Name
//
//  Synopsis:    Return the name of this snapin.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMTSnapInNode::Scget_Name (PBSTR pbstrName)
{
    DECLARE_SC(sc, _T("CMTSnapInNode::Scget_Name"));
    sc = ScCheckPointers(pbstrName);
    if (sc)
        return sc;

    *pbstrName = NULL;

    CSnapIn *pSnapin =  GetPrimarySnapIn();
    sc = ScCheckPointers(pSnapin, E_UNEXPECTED);
    if (sc)
        return sc;

    WTL::CString strSnapInName;
    sc = pSnapin->ScGetSnapInName(strSnapInName);
    if (sc)
        return sc;

    USES_CONVERSION;
    *pbstrName = strSnapInName.AllocSysString();
    if ( (! *pbstrName) && (strSnapInName.GetLength() > 0) )
        return (sc = E_OUTOFMEMORY);

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CMTSnapInNode::Scget_Extensions
//
//  Synopsis:    Get the extensions collection for this snapin.
//
//  Arguments:   [ppExtensions] - out ptr to extensions collection.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMTSnapInNode::Scget_Extensions( PPEXTENSIONS  ppExtensions)
{
    DECLARE_SC(sc, _T("CMTSnapInNode::Scget_Extensions"));
    sc = ScCheckPointers(ppExtensions);
    if (sc)
        return sc;

    *ppExtensions = NULL;

    CSnapIn *pSnapin =  GetPrimarySnapIn();
    sc = ScCheckPointers(pSnapin, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = ::Scget_Extensions(pSnapin->GetSnapInCLSID(), ppExtensions);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CMTSnapInNode::ScGetSnapinClsid
//
//  Synopsis:    Gets the CLSID of snapin
//
//  Arguments:   CLSID& clsid [out] - class id of snapin.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMTSnapInNode::ScGetSnapinClsid(CLSID& clsid)
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScGetAboutClsid"));

    // init out param
    clsid = GUID_NULL;

    CSnapIn *pSnapin =  GetPrimarySnapIn();
    sc = ScCheckPointers(pSnapin, E_UNEXPECTED);
    if (sc)
        return sc;

    clsid = pSnapin->GetSnapInCLSID();

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CMTSnapInNode::Scget_SnapinCLSID
//
//  Synopsis:    Get the CLSID for this snapin.
//
//  Arguments:   [pbstrSnapinCLSID] - out ptr to CLSID.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMTSnapInNode::Scget_SnapinCLSID(     PBSTR      pbstrSnapinCLSID)
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::Scget_SnapinCLSID"));
    sc = ScCheckPointers(pbstrSnapinCLSID);
    if (sc)
        return sc;

    CSnapIn *pSnapin =  GetPrimarySnapIn();
    sc = ScCheckPointers(pSnapin, E_UNEXPECTED);
    if (sc)
        return sc;

    CCoTaskMemPtr<OLECHAR> szSnapinClsid;

    sc = StringFromCLSID(pSnapin->GetSnapInCLSID(), &szSnapinClsid);
    if (sc)
        return sc.ToHr();

    *pbstrSnapinCLSID = SysAllocString(szSnapinClsid);
    if (! *pbstrSnapinCLSID)
        sc = E_OUTOFMEMORY;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CMTSnapInNode::ScEnableAllExtensions
//
//  Synopsis:    Enable or not enable all extensions of this snapin.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMTSnapInNode::ScEnableAllExtensions (BOOL bEnable)
{
    DECLARE_SC(sc, _T("CMTSnapInNode::ScEnableAllExtensions"));

    CSnapIn *pSnapin =  GetPrimarySnapIn();
    sc = ScCheckPointers(pSnapin, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = ::ScEnableAllExtensions(pSnapin->GetSnapInCLSID(), bEnable);
    if (sc)
        return sc;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::Scget_Properties
 *
 * Returns a pointer to the snap-in's Properties object
 *--------------------------------------------------------------------------*/

SC CMTSnapInNode::Scget_Properties( PPPROPERTIES ppProperties)
{
    DECLARE_SC (sc, _T("CMTSnapInNode::Scget_Properties"));

    /*
     * validate parameters
     */
    sc = ScCheckPointers (ppProperties);
    if (sc)
        return (sc);

    *ppProperties = m_spProps;

    /*
     * If the snap-in doesn't support ISnapinProperties, don't return
     * a Properties interface.  This is not an error, but rather a valid
     * unsuccessful return, so we return E_NOINTERFACE directly instead
     * of assigning to sc first.
     */
    if (m_spProps == NULL)
        return (E_NOINTERFACE);

    /*
     * put a ref on for the client
     */
    (*ppProperties)->AddRef();

    return (sc);
}



/*+-------------------------------------------------------------------------*
 *
 * CMTSnapInNode::ScGetSnapIn
 *
 * PURPOSE: Returns a pointer to the SnapIn object.
 *
 * PARAMETERS:
 *    PPSNAPIN  ppSnapIn :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMTSnapInNode::ScGetSnapIn(PPSNAPIN ppSnapIn)
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScGetSnapIn"));

    sc = ScCheckPointers(ppSnapIn);
    if(sc)
        return sc;

    // initialize out parameter
    *ppSnapIn = NULL;

    // create a CMMCView if needed.
    sc = CTiedComObjectCreator<CMMCSnapIn>::ScCreateAndConnect(*this, m_spSnapIn);
    if(sc)
        return sc;

    if(m_spSnapIn == NULL)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // addref the pointer for the client.
    m_spSnapIn->AddRef();
    *ppSnapIn = m_spSnapIn;

    return sc;
}


HRESULT CMTNode::OpenStorageForNode()
{
    if (m_spNodeStorage != NULL)
        return S_OK;

    ASSERT(m_spPersistData != NULL);
    if (m_spPersistData == NULL)
        return E_POINTER;

    // Get the storage for all of the nodes
    IStorage* const pAllNodes = m_spPersistData->GetNodeStorage();
    ASSERT(pAllNodes != NULL);
    if (pAllNodes == NULL)
        return E_POINTER;

    // Create the outer storage for this node
    WCHAR name[MAX_PATH];
    HRESULT hr = OpenDebugStorage(pAllNodes, GetStorageName(name),
        STGM_READWRITE | STGM_SHARE_EXCLUSIVE, L"\\node\\#", &m_spNodeStorage);
    return hr == S_OK ? S_OK : E_FAIL;
}

HRESULT CMTNode::OpenStorageForView()
{
    if (m_spViewStorage != NULL)
        return S_OK;

    // Get the storage for all of the nodes
    IStorage* const pNodeStorage = GetNodeStorage();
    ASSERT(pNodeStorage != NULL);
    if (pNodeStorage == NULL)
        return E_FAIL;

    // Create the outer storage for this node
    WCHAR name[MAX_PATH];
    HRESULT hr = OpenDebugStorage(pNodeStorage, L"view",
                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE, L"\\node\\#\\view",
                                                     &m_spViewStorage);
    return hr == S_OK ? S_OK : E_FAIL;
}

HRESULT CMTNode::OpenStorageForCD()
{
    if (m_spCDStorage != NULL)
        return S_OK;

    // Get the storage for all of the nodes
    IStorage* const pNodeStorage = GetNodeStorage();
    ASSERT(pNodeStorage != NULL);
    if (pNodeStorage == NULL)
        return E_FAIL;

    // Create the outer storage for this node
    WCHAR name[MAX_PATH];
    HRESULT hr = OpenDebugStorage(pNodeStorage, L"data",
                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE, L"\\node\\#\\data",
                                                     &m_spCDStorage);
    return hr == S_OK ? S_OK : E_FAIL;
}

HRESULT CMTNode::OpenTreeStream()
{
    if (m_spTreeStream != NULL)
    {
        const LARGE_INTEGER loc = {0,0};
        ULARGE_INTEGER newLoc;
        HRESULT hr = m_spTreeStream->Seek(loc, STREAM_SEEK_SET, &newLoc);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return E_FAIL;

        return S_OK;
    }

    HRESULT hr = OpenStorageForNode();
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;

    hr = OpenStorageForView();
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;

    hr = OpenStorageForCD();
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;

    IStorage* const pTreeNodes = GetNodeStorage();
    ASSERT(pTreeNodes != NULL);
    if (pTreeNodes == NULL)
        return E_POINTER;

    hr = OpenDebugStream(pTreeNodes, L"tree",
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE, L"\\node\\#\\tree", &m_spTreeStream);
    ASSERT(SUCCEEDED(hr) && m_spTreeStream != NULL);
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}

/*+-------------------------------------------------------------------------*
 *
 * CMTSnapInNode::NextStaticNode
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:   NULL if not found, else the next CMTSnapInNode.
 *    inline
 *
 * NOTE: This performance is poor! Improve by indexing all CMTSnapInNodes
 *       separately.
 *+-------------------------------------------------------------------------*/
CMTNode*
CMTNode::NextStaticNode()
{
    CMTNode *pNext = this;

    while (pNext)
    {
        if (pNext->IsStaticNode())
            return pNext;
        pNext = pNext->Next();
    }
    return NULL;
}




HRESULT CMTNode::IsDirty()
{
    if (GetDirty())
    {
        TraceDirtyFlag(TEXT("CMTNode"), true);
        return S_OK;
    }

    HRESULT hr;
    CMTNode* const pChild = m_pChild->NextStaticNode();
    if (pChild)
    {
        hr = pChild->IsDirty();
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;
        if (hr != S_FALSE)
        {
            TraceDirtyFlag(TEXT("CMTNode"), true);
            return hr;
        }
    }

    CMTNode* const pNext = m_pNext->NextStaticNode();
    if (pNext)
    {
        hr = pNext->IsDirty();
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;
        if (hr != S_FALSE)
        {
            TraceDirtyFlag(TEXT("CMTNode"), true);
            return hr;
        }
    }

    TraceDirtyFlag(TEXT("CMTNode"), false);
    return S_FALSE;
}


/*+-------------------------------------------------------------------------*
 *
 * CMTNode::InitNew
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    PersistData* d :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMTNode::InitNew(PersistData* d)
{
    SC      sc;
    CStream treeStream;

    if ( (m_spPersistData != NULL) || (d==NULL) || !IsStaticNode())
        goto FailedError;

    m_spPersistData = d;
    if (m_spPersistData == NULL)
        goto ArgumentError;

    sc = InitNew();
    if(sc)
        goto Error;

    // Get the stream for persistence of the tree

    treeStream.Attach( m_spPersistData->GetTreeStream());

    // recurse thru children
    {
        CMTNode* const pChild = m_pChild->NextStaticNode();
        if (pChild)
        {
            sc = pChild->InitNew(d);
            if(sc)
                goto Error;
        }
        else
        {
            sc = ScWriteEmptyNode(treeStream);
            if(sc)
                goto Error;
        }
    }

    // chain to next node.
    {
        CMTNode* const pNext = m_pNext->NextStaticNode();
        if (pNext)
        {
            sc = pNext->InitNew(d);
            if(sc)
                goto Error;
        }
        else
        {
            sc = ScWriteEmptyNode(treeStream);
            if(sc)
                goto Error;
        }
    }

Cleanup:
    return HrFromSc(sc);
FailedError:
    sc = E_FAIL;
    goto Error;
ArgumentError:
    sc = E_INVALIDARG;
Error:
    TraceError(TEXT("CMTNode::InitNew"), sc);
    goto Cleanup;

}

/*+-------------------------------------------------------------------------*
 *
 * CMTNode::Persist
 *
 * PURPOSE: Persists the CMTNode to the specified persistor.
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CMTNode::Persist(CPersistor& persistor)
{
    MTNODEID id = GetID();       // persist the node id
    persistor.PersistAttribute(XML_ATTR_MT_NODE_ID, id);
    SetID(id);

    // Save the children
    CPersistor persistorSubNode(persistor, XML_TAG_SCOPE_TREE_NODES);
    if (persistor.IsStoring())
    {
        CMTNode* pChild = m_pChild->NextStaticNode();
        while (pChild)
        {
            persistorSubNode.Persist(*pChild);
            // get next node
            pChild = pChild->Next();
            // advance if it is not a static node
            pChild = (pChild ? pChild->NextStaticNode() : NULL);
        }
        ClearDirty();
    }
    else
    {
        XMLListCollectionBase::Persist(persistorSubNode);
    }

    UINT nImage = m_nImage;
    if (nImage > eStockImage_Max)       // if SnapIn changed icon dynamically, then
        nImage = eStockImage_Folder;    // this value will be bogus next time:
                                            // replace w/ 0 (closed folder)
    persistor.PersistAttribute(XML_ATTR_MT_NODE_IMAGE, nImage);
    persistor.PersistString(XML_ATTR_MT_NODE_NAME,  m_strName);
}

/*+-------------------------------------------------------------------------*
 *
 * CMTNode::OnNewElement
 *
 * PURPOSE: called for each new child node found in XML doc
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CMTNode::OnNewElement(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CMTNode::OnNewElement"));

    // load the child
    CMTNode* pChild;
    // attach to the list
    PersistNewNode(persistor, &pChild);
    if (pChild)
    {
        // Insert after m_pLastChild (at the last position). 
        // If m_pLastChild is NULL, insert as the first and only child.
        sc = ScInsertChild(pChild, m_pLastChild); 
    }
}

//+-------------------------------------------------------------------
//
//  Member:    CMTNode::ScLoad
//
//  Synopsis: Loads the MTNode from the specified stream.
//            COMPATIBILITY issues: MMC1.0 through MMC1.2 used special built-in
//            node types to represent Folder, Web Link, and ActiveX control 
//            nodes. MMC2.0 and higher use snap-ins instead. The only special 
//            node is Console Root, which is still saved and loaded as a Folder
//            node with ID = 1.
//
//  Arguments: d [IN]: Data Stream to load the node from.
//             ppNode [OUT]: Non-Null pointer to the pointer to the loaded 
//             node.
//
//  Returns:   SC
//
//--------------------------------------------------------------------

SC CMTNode::ScLoad(PersistData* d, CMTNode** ppNode)
{
    // Call helper method with NULL parent (for Root node) and 
    // NULL prev (Insert at first position).

    return ScLoad(d, ppNode, NULL, NULL);
}

//+-------------------------------------------------------------------
//
//  Member:    CMTNode::ScLoad
//
//  Synopsis: Helper for ScLoad(PersistData*, CMTNode**). Uses Recusrion
//
//  Arguments: d [IN]: Data Stream to load the node from
//             ppNode [OUT]: Non-Null pointer to the pointer to the loaded 
//             node.
//             pParent [IN]: Pointer to the node under which the node is to be 
//             loaded. 
//             pPrev [IN]: Pointer to the node after which the node is to be 
//             loaded. 
//
//
//  Returns:   SC
//
//--------------------------------------------------------------------
SC CMTNode::ScLoad(PersistData* d, CMTNode** ppNode, CMTNode* pParent, CMTNode *pPrev)
{
    DECLARE_SC(sc, TEXT("CMTNode::ScLoad"));
    CMTSnapInNode* pmtSnapInNode = NULL;
    CStream        treeStream;

    // check parameters
    sc = ScCheckPointers(d, ppNode);
    if(sc)
        return sc;

    *ppNode = NULL;

    // Read the type of node from the stream.
    treeStream.Attach(d->GetTreeStream());

    int nt;
    sc = treeStream.ScRead(&nt, sizeof(nt));
    if(sc)
        return sc;

    if (!nt)
        return sc;

    if (!(nt == NODE_CODE_SNAPIN || nt == NODE_CODE_FOLDER ||
          nt == NODE_CODE_HTML   || nt == NODE_CODE_OCX))
        return (sc = E_FAIL); // invalid node type.

    // Read the storage key
    MTNODEID id;
    sc = treeStream.ScRead(&id, sizeof(id));
    if(sc)
        return sc;

    // Create a node of the appropriate type. Everything, including Console Root
    // uses CMTSnapInNode.
    if( nt == NODE_CODE_FOLDER || nt == NODE_CODE_SNAPIN || nt == NODE_CODE_HTML || nt == NODE_CODE_OCX )
    {
        pmtSnapInNode = new CMTSnapInNode (NULL);

        ASSERT(pmtSnapInNode != NULL);
        if (pmtSnapInNode == NULL)
            return E_POINTER;

        *ppNode = pmtSnapInNode;
    }
    else
        return (sc = E_UNEXPECTED); // should never happen

    (*ppNode)->m_bLoaded = true;

    ASSERT((*ppNode)->m_spPersistData == NULL);
    ASSERT(d != NULL);
    (*ppNode)->m_spPersistData = d;
    ASSERT((*ppNode)->m_spPersistData != NULL);
    if ((*ppNode)->m_spPersistData == NULL)
        return E_INVALIDARG;


    (*ppNode)->SetID(id);
    if (id >= m_NextID)
        m_NextID = id+1;

    // Open the stream for the nodes data
    sc = (*ppNode)->OpenTreeStream();
    if (sc)
    {
        (*ppNode)->Release();
        *ppNode = NULL;
        return sc;
    }

    // Load the node
    // If old style node, then convert to snap-in type node

    switch (nt)
    {
    case NODE_CODE_SNAPIN:
        sc = (*ppNode)->ScLoad();
        break;

    // All folder nodes, INCLUDING old-style console root nodes, are upgraded to snap-ins.
    case NODE_CODE_FOLDER:
            if(pmtSnapInNode == NULL)
                return (sc = E_UNEXPECTED);

            sc = pmtSnapInNode->ScConvertLegacyNode(CLSID_FolderSnapin);
            break;
    case NODE_CODE_HTML:
        sc = pmtSnapInNode->ScConvertLegacyNode(CLSID_HTMLSnapin);
        break;

    case NODE_CODE_OCX:
        sc = pmtSnapInNode->ScConvertLegacyNode(CLSID_OCXSnapin);
        break;

    default:
        ASSERT(0 && "Invalid node type");
        sc = E_FAIL;
    }

    if (sc)
    {
        (*ppNode)->Release();
        *ppNode = NULL;
        return sc;
    }

    // Set the parent pointer before loading the children or the siblings
    if(pParent) // Do not insert if pParent is NULL (as for the root node)
    {
        // Insert after pPrev. If pPrev is NULL, insert as the first child.
        sc = pParent->ScInsertChild(*ppNode, pPrev);
        if (sc)
        {
            (*ppNode)->Release();
            *ppNode = NULL;
            return sc;
        }
    }

    // load the children
    CMTNode* pChild;
    sc = ScLoad(d, &pChild, *ppNode, NULL); // NULL ==> Insert at First Position
    if (sc)
    {
        (*ppNode)->Release();
        *ppNode = NULL;
        return sc;
    }

    // Load siblings
    CMTNode* pNext;
    CMTNode * pTemp = NULL; 
    // IMPORTANT - why are we passing pTemp instead of & (*ppNode->Next()) ? This is because
    // the latter automatically gets set owing to the fourth parameter. This caused a bug when the second
    // parameter also caused the Next() pointer to get set - in effect, the node was being set as its own
    // sibling.
    sc = ScLoad(d, &pTemp, pParent, *ppNode);
    if (sc)
    {
        (*ppNode)->Release();
        *ppNode = NULL;
        return sc;
    }
	
    (*ppNode)->SetDirty(false);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMTNode::PersistNewNode
 *
 * PURPOSE: Loads the MTNode from the persistor.
 *
 *+-------------------------------------------------------------------------*/
void CMTNode::PersistNewNode(CPersistor &persistor, CMTNode** ppNode)
{
    DECLARE_SC(sc, TEXT("CMTNode::PersistNewNode"));

    CMTSnapInNode* pmtSnapInNode = NULL;

    const int CONSOLE_ROOT_ID = 1;
    // check parameters
    sc = ScCheckPointers(ppNode);
    if (sc)
        sc.Throw();

    *ppNode = NULL;

    // Create a node of the snapin type. Everything uses CMTSnapInNode.

    pmtSnapInNode = new CMTSnapInNode(NULL);
    sc = ScCheckPointers(pmtSnapInNode,E_OUTOFMEMORY);
    if (sc)
        sc.Throw();

    *ppNode = pmtSnapInNode;

    (*ppNode)->m_bLoaded = true;

    ASSERT((*ppNode)->m_spPersistData == NULL);

    try
    {
        persistor.Persist(**ppNode);
    }
    catch(...)
    {
        // ensure cleanup here
        (*ppNode)->Release();
        *ppNode = NULL;
        throw;
    }
    // update index for new nodes
    MTNODEID id = (*ppNode)->GetID();
    if (id >= m_NextID)
        m_NextID = id+1;

    (*ppNode)->SetDirty(false);
}

HRESULT CMTNode::DestroyElements()
{
    if (!IsStaticNode())
        return S_OK;

    HRESULT hr;

    if (m_pChild != NULL)
    {
        hr = m_pChild->DestroyElements();
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;
    }

    return DoDestroyElements();
}

HRESULT CMTNode::DoDestroyElements()
{
    if (m_spPersistData == NULL)
        return S_OK;

    IStorage* const pNodeStorage = m_spPersistData->GetNodeStorage();
    ASSERT(pNodeStorage != NULL);
    if (pNodeStorage == NULL)
        return S_OK;

    WCHAR name[MAX_PATH];
    HRESULT hr = pNodeStorage->DestroyElement(GetStorageName(name));

    SetDirty();
    CMTNode* const psParent = m_pParent != NULL ? m_pParent->GetStaticParent() : NULL;
    if (psParent != NULL)
        psParent->SetDirty();

    return S_OK;
}

void CMTNode::SetParent(CMTNode* pParent)
{
    m_pParent = pParent;
    if (m_pNext)
        m_pNext->SetParent(pParent);
}


HRESULT CMTNode::CloseView(int idView)
{
    if (!IsStaticNode())
        return S_OK;

    HRESULT hr;
    CMTNode* const pChild = m_pChild->NextStaticNode();
    if (pChild)
    {
        hr = pChild->CloseView(idView);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return E_FAIL;
    }

    CMTNode* const pNext = m_pNext->NextStaticNode();
    if (pNext)
    {
        hr = pNext->CloseView(idView);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return E_FAIL;
    }

    return S_OK;
}


HRESULT CMTNode::DeleteView(int idView)
{
    if (!IsStaticNode())
        return S_OK;

    HRESULT hr;
    CMTNode* const pChild = m_pChild->NextStaticNode();
    if (pChild)
    {
        hr = pChild->DeleteView(idView);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return E_FAIL;
    }

    CMTNode* const pNext = m_pNext->NextStaticNode();
    if (pNext)
    {
        hr = pNext->DeleteView(idView);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return E_FAIL;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     GetBookmark
//
//  Synopsis:   Get bookmark for this MTNode.
//
//  Arguments:  None.
//
//  Returns:    auto pointer to CBookmark.
//
//  History:    04-23-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
CBookmark* CMTNode::GetBookmark()
{
    DECLARE_SC(sc, TEXT("CMTNode::GetBookmark"));

    // If the bookmark is not created, create one.
    if (NULL == m_bookmark.get())
    {
        m_bookmark = std::auto_ptr<CBookmarkEx>(new CBookmarkEx);
        if (NULL == m_bookmark.get())
            return NULL;

        m_bookmark->Reset();

        SC sc = m_bookmark->ScInitialize(this, GetStaticParent(), false /*bFastRetrievalOnly*/);
        if(sc)
            sc.TraceAndClear(); // change
    }

    return m_bookmark.get();
}

void
CMTNode::SetCachedDisplayName(LPCTSTR pszName)
{
    if (m_strName.str() != pszName)
    {
        m_strName = pszName;
        SetDirty();

        if (Parent())
            Parent()->OnChildrenChanged();
    }
}

UINT
CMTNode::GetState(void)
{
   UINT nState = 0;
   if (WasExpandedAtLeastOnce())
   {
       nState |= MMC_SCOPE_ITEM_STATE_EXPANDEDONCE;
   }

   return nState;
}


/*+-------------------------------------------------------------------------*
 *
 * CMTNode::ScLoad
 *
 * PURPOSE: Loads the node from the tree stream
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMTNode::ScLoad()
{
    ASSERT (IsStaticNode());
    SC      sc;
    CStream stream;

    stream.Attach(GetTreeStream());

    HRESULT hr;

    IStringTablePrivate* pStringTable = CScopeTree::GetStringTable();
    ASSERT (pStringTable != NULL);


    /*
     * read the "versioned stream" marker
     */
    StreamVersionIndicator nVersionMarker;
    sc = stream.ScRead(&nVersionMarker, sizeof(nVersionMarker));
    if(sc)
        goto Error;

    /*
     * Determine the stream version number.  If this is a versioned
     * stream, the version is the next DWORD in the stream, otherwise
     * it must be it's a version 1 stream
     */
    StreamVersionIndicator nVersion;

    if (nVersionMarker == VersionedStreamMarker)
    {
        sc = stream.ScRead(&nVersion, sizeof(nVersion));
        if(sc)
            goto Error;
    }
    else
        nVersion = Stream_V0100;


    switch (nVersion)
    {
        /*
         * MMC 1.0 stream
         */
        case Stream_V0100:
        {
            /*
             * Version 1 streams didn't have a version marker; they began with
             * the image index as the first DWORD.  The first DWORD has
             * already been read (version marker), so we can recycle that
             * value for the image index.
             */
            m_nImage = nVersionMarker;

            /*
             * Continue reading with the display name (length then characters)
             */
            unsigned int stringLength = 0;
            sc = stream.ScRead(&stringLength, sizeof(stringLength));
            if(sc)
                goto Error;

            if (stringLength)
            {
                wchar_t* str = reinterpret_cast<wchar_t*>(alloca((stringLength+1)*2));
                ASSERT(str != NULL);
                if (str == NULL)
                    return E_POINTER;
                sc = stream.ScRead(str, stringLength*2);
                if(sc)
                    goto Error;

                str[stringLength] = 0;

                USES_CONVERSION;
                m_strName = W2T (str);
            }

            break;
        }

        /*
         * MMC 1.1 stream
         */
        case Stream_V0110:
        {
            /*
             * read the image index
             */
            sc = stream.ScRead(&m_nImage, sizeof(m_nImage));
            if(sc)
                goto Error;

            /*
             * read the name (stream insertion operators will throw
             * _com_error's, so we need an exception block here)
             */
            try
            {
                IStream *pStream = stream.Get();
                if(!pStream)
                    goto PointerError;

                *pStream >> m_strName;
            }
            catch (_com_error& err)
            {
                hr = err.Error();
                ASSERT (false && "Caught _com_error");
                return (hr);
            }
            break;
        }

        default:
#ifdef DBG
            TCHAR szTraceMsg[80];
            StringCchPrintf (szTraceMsg, countof(szTraceMsg), _T("Unexpected stream version 0x08x\n"), nVersion);
            TRACE (szTraceMsg);
            ASSERT (FALSE);
#endif
            return (E_FAIL);
            break;
    }

Cleanup:
    return sc;
PointerError:
    sc = E_POINTER;
Error:
    TraceError(TEXT("CMTNode::Load"), sc);
    goto Cleanup;
}

HRESULT CMTNode::Init(void)
{
    DECLARE_SC(sc, TEXT("CMTNode::Init"));

    if (m_bInit == TRUE)
        return S_FALSE;

    ASSERT(WasExpandedAtLeastOnce() == FALSE);

    if (!m_pPrimaryComponentData)
        return E_FAIL;


    CMTSnapInNode* pMTSnapIn = GetStaticParent();
    HMTNODE hMTNode = CMTNode::ToHandle(pMTSnapIn);

    if (!m_pPrimaryComponentData->IsInitialized())
    {

        sc = m_pPrimaryComponentData->Init(hMTNode);
        if(sc)
            return sc.ToHr();

        sc = pMTSnapIn->ScInitIComponentData(m_pPrimaryComponentData);
        if (sc)
            return sc.ToHr();
    }

    // Init the extensions
    m_bInit = TRUE;

    BOOL fProblem = FALSE;

    // Get node's node-type
    GUID guidNodeType;
    sc = GetNodeType(&guidNodeType);
    if (sc)
        return sc.ToHr();


    CExtensionsIterator it;
    // TODO: try to use the easier form of it.ScInitialize()
    sc = it.ScInitialize(m_pPrimaryComponentData->GetSnapIn(), guidNodeType, g_szNameSpace,
                            m_arrayDynExtCLSID.GetData(), m_arrayDynExtCLSID.GetSize());
    if(sc)
        return sc.ToHr();
    else
    {
        CComponentData* pCCD = NULL;

        for (; it.IsEnd() == FALSE; it.Advance())
        {
            pCCD = pMTSnapIn->GetComponentData(it.GetCLSID());
            if (pCCD == NULL)
            {
                CSnapInPtr spSnapIn;

                // If a dynamic extension, we have to get the snap-in ourselves
                // otherwise the iterator has it
                if (it.IsDynamic())
                {
                    CSnapInsCache* const pCache = theApp.GetSnapInsCache();
                    ASSERT(pCache != NULL);

                    SC sc = pCache->ScGetSnapIn(it.GetCLSID(), &spSnapIn);
                    ASSERT(!sc.IsError());

                    // On failure, continue with other extensions
                    if (sc)
                        continue;
                }
                else
                {
                    spSnapIn = it.GetSnapIn();
                }

                ASSERT(spSnapIn != NULL);

                pCCD = new CComponentData(spSnapIn);
                pMTSnapIn->AddComponentDataToArray(pCCD);
            }

            ASSERT(pCCD != NULL);

            if (pCCD != NULL && pCCD->IsInitialized() == FALSE)
            {
                sc = pCCD->Init(hMTNode);

                if ( !sc.IsError() )
                    sc = pMTSnapIn->ScInitIComponentData(pCCD);

                if ( sc )
                {
                    sc.TraceAndClear();
                    fProblem = TRUE;
                }
            }
        }

        pMTSnapIn->CompressComponentDataArray();

    }

    if (fProblem == TRUE)
    {
        Dbg(DEB_TRACE, _T("Failed to load some extensions"));
    }

    return S_OK;
}

HRESULT CMTNode::Expand(void)
{
    DECLARE_SC(sc, TEXT("CMTNode::Expand"));

    CComponentData* pCCD = m_pPrimaryComponentData;
    if (WasExpandedAtLeastOnce() == FALSE)
        Init();

    SetExpandedAtLeastOnce();

    ASSERT(pCCD != NULL);
    if (pCCD == NULL)
        return E_FAIL;

    // Get the data object for the cookie from the owner snap-in
    IDataObjectPtr spDataObject;
    HRESULT hr = pCCD->QueryDataObject(GetUserParam(), CCT_SCOPE, &spDataObject);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;

//  hr = pCCD->Notify (spDataObject, MMCN_EXPAND, TRUE,
//                     reinterpret_cast<LPARAM>(this));
    hr = Expand (pCCD, spDataObject, TRUE);

    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;

    // Mark the folder for the master tree item as expanded
    CMTSnapInNode* pSIMTNode = GetStaticParent();

    //
    // Deal with extension snap-ins
    //

    m_bExtensionsExpanded = TRUE;

    // Get node's node-type
    GUID guidNodeType;
    hr = GetNodeType(&guidNodeType);
    if (FAILED(hr))
        return hr;

    CExtensionsIterator it;

    // TODO: try to use the easier form of it.ScInitialize()
    sc = it.ScInitialize(GetPrimarySnapIn(), guidNodeType, g_szNameSpace,
                    m_arrayDynExtCLSID.GetData(), m_arrayDynExtCLSID.GetSize());
    if (sc)
        return S_FALSE;     // The snapin is not loaded on the m/c.

    if (it.IsEnd())  // No extensions.
        return S_OK;

    BOOL fProblem = FALSE;

    for (; it.IsEnd() == FALSE; it.Advance())
    {
        CComponentData* pCCD = pSIMTNode->GetComponentData(it.GetCLSID());
        if (pCCD == NULL)
            continue;

//      hr = pCCD->Notify (spDataObject, MMCN_EXPAND, TRUE,
//                         reinterpret_cast<LPARAM>(this));
        hr = Expand (pCCD, spDataObject, TRUE);
        CHECK_HRESULT(hr);

        // continue even if an error occurs with extension snapins
        if (FAILED(hr))
            fProblem = TRUE;
    }

    return (fProblem == TRUE) ? S_FALSE : S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:    CMTNode::ScInsertChild     
//
//  Synopsis:  Inserts a child node after the designated node.
//
//  Arguments: pmtn: Non-Null pointer to the node to be inserted.
//             pmtnInsertAfter: Pointer to the node to insert after. 
//             If NULL, pmtn is inserted as the first child.
//
//  Returns:   SC 
//
//--------------------------------------------------------------------

SC CMTNode::ScInsertChild(CMTNode* pmtn, CMTNode* pmtnInsertAfter)
{

    DECLARE_SC(sc, TEXT("CMTNode::ScInsertChild"));

    sc = ScCheckPointers(pmtn);
    if (sc)
        return sc;

    pmtn->AttachNext(NULL);
    pmtn->AttachPrev(NULL);

    if(pmtnInsertAfter)
    {
        if (pmtnInsertAfter->Parent() != this)
            return (sc = E_INVALIDARG);
       
        CMTNode* pmtnNext = pmtnInsertAfter->Next();
        if(pmtnNext)
        {
            pmtnNext->AttachPrev(pmtn);
            pmtn->AttachNext(pmtnNext);
        }
        else
        {
            if (LastChild() != pmtnInsertAfter)
                return (sc = E_UNEXPECTED);

            AttachLastChild(pmtn);
        }

        pmtnInsertAfter->AttachNext(pmtn);
        pmtn->AttachPrev(pmtnInsertAfter);
    }
    else
    {
        CMTNode* pmtnNext = Child();
        if(pmtnNext)
        {
            pmtnNext->AttachPrev(pmtn);
            pmtn->AttachNext(pmtnNext);
        }
        else
        {
            AttachLastChild(pmtn);
        }
        AttachChild(pmtn);
    }

    pmtn->AttachParent(this);

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:    CMTNode::ScDeleteChild     
//
//  Synopsis:  Deletes a child node.
//
//  Arguments: pmtn: Non-Null pointer to the node to be deleted. 
//
//  Returns:   SC  
//
//--------------------------------------------------------------------

SC CMTNode::ScDeleteChild(CMTNode *pmtn)
{
    
    DECLARE_SC(sc, TEXT("CMTNode::ScDeleteChild"));

    sc = ScCheckPointers(pmtn);
    if (sc)
        return sc;

    if (pmtn->Parent() != this)
        return (sc = E_INVALIDARG);

    CMTNode* pmtnNext = pmtn->Next();
    CMTNode* pmtnPrev = pmtn->Prev();

    if (pmtnPrev) 
    {
        pmtnPrev->AttachNext(pmtnNext);
    }
    else
    {   
        /* pmtn is the first child */
        if(pmtn != Child())
            return (sc = E_UNEXPECTED);

        AttachChild(pmtnNext);
    }

    if(pmtnNext)
    {
        pmtnNext->AttachPrev(pmtnPrev);
    }
    else 
    {
        /* pmtn is the last child */
        AttachLastChild(pmtnPrev);
    }

    pmtn->AttachNext(NULL);
    pmtn->AttachPrev(NULL);
    pmtn->AttachParent(NULL);

    pmtn->Release();

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:    CMTNode::ScDeleteTrailingChildren
//
//  Synopsis:  Deletes the designated child node and all subsequent ones.
//
//  Arguments: pmtn: Non-Null pointer to the first node to be deleted. 
//
//  Returns:   SC 
//
//--------------------------------------------------------------------
SC CMTNode::ScDeleteTrailingChildren(CMTNode* pmtn)
{    
    DECLARE_SC(sc, TEXT("CMTNode::ScDeleteTrailingChildren"));

    sc = ScCheckPointers(pmtn);
    if (sc)
        return sc;

    if (pmtn->Parent() != this)
        return (sc = E_INVALIDARG);

    if (Child() == pmtn) /* First child */
        AttachChild(NULL); 
 
    AttachLastChild(pmtn->Prev()); 

    CMTNode* pmtnTmp = NULL;
    while(pmtn)
    {
        pmtnTmp = pmtn;
        pmtn = pmtnTmp->Next();
 
        pmtnTmp->AttachNext(NULL);
        pmtnTmp->AttachPrev(NULL);
        pmtnTmp->AttachParent(NULL);
        pmtnTmp->Release();
    }

    return sc;
}

CNode* CMTNode::GetNode(CViewData* pViewData, BOOL fRootNode)
{
    CMTSnapInNode* pMTSnapInNode = GetStaticParent();
    if (pMTSnapInNode == NULL)
        return (NULL);

    if (fRootNode)
    {
        /*
         * create a static parent node for this non-static
         * root node (it will be deleted in the CNode dtor)
         */
        CNode* pNodeTemp = pMTSnapInNode->GetNode(pViewData, FALSE);
        if (pNodeTemp == NULL)
            return NULL;
    }

    CNode* pNode = new CNode(this, pViewData, fRootNode);

    if (pNode != NULL)
    {
        CComponent* pCC = pMTSnapInNode->GetComponent(pViewData->GetViewID(),
                                    GetPrimaryComponentID(), GetPrimarySnapIn());
        if (pCC==NULL)
        {
            delete pNode;
            return NULL;
        }
        else
            pNode->SetPrimaryComponent(pCC);
    }

    return pNode;
}

HRESULT CMTNode::AddExtension(LPCLSID lpclsid)
{
    DECLARE_SC(sc, TEXT("CMTNode::AddExtension"));
    sc = ScCheckPointers(lpclsid);
    if (sc)
        return sc.ToHr();

    CMTSnapInNode* pMTSnapIn = GetStaticParent();
    CSnapInsCache* const pCache = theApp.GetSnapInsCache();

    sc = ScCheckPointers(pMTSnapIn, pCache, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    do // not a loop
    {
        // Get node's node-type
        GUID guidNodeType;
        sc = GetNodeType(&guidNodeType);
        if (sc)
            return sc.ToHr();

        // Must be a namespace extension
        if (!ExtendsNodeNameSpace(guidNodeType, lpclsid))
            return (sc = E_INVALIDARG).ToHr();

        // Check if extension is already enabled
        CExtensionsIterator it;
        // TODO: try to use the easier form of it.ScInitialize()
        sc = it.ScInitialize(GetPrimarySnapIn(), guidNodeType, g_szNameSpace,
                             m_arrayDynExtCLSID.GetData(), m_arrayDynExtCLSID.GetSize());
        for (; it.IsEnd() == FALSE; it.Advance())
        {
            if (IsEqualCLSID(*lpclsid, it.GetCLSID()))
                return (sc = S_FALSE).ToHr();
        }

        // Add extension to dynamic list
        m_arrayDynExtCLSID.Add(*lpclsid);

        // No errors returned if node is not initialized in MMC1.2.
        if (!m_bInit)
            break;

        HMTNODE hMTNode = CMTNode::ToHandle(pMTSnapIn);

        CSnapInPtr spSI;

        CComponentData* pCCD = pMTSnapIn->GetComponentData(*lpclsid);
        if (pCCD == NULL)
        {
            sc = pCache->ScGetSnapIn(*lpclsid, &spSI);
            if (sc)
                return sc.ToHr();

            pCCD = new CComponentData(spSI);
            sc = ScCheckPointers(pCCD, E_OUTOFMEMORY);
            if (sc)
                return sc.ToHr();

            pMTSnapIn->AddComponentDataToArray(pCCD);
        }

        sc = ScCheckPointers(pCCD, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (pCCD->IsInitialized() == FALSE)
        {
            sc = pCCD->Init(hMTNode);

            if (sc)
            {
                // Init failed.
                pMTSnapIn->CompressComponentDataArray();
                return sc.ToHr();
            }
            else
            {
                // Above Init is successful.
                sc = pMTSnapIn->ScInitIComponentData(pCCD);
                sc.TraceAndClear(); // to maintain compatibility
            }
        }

        // Create and initialize a CComponent for all initialized nodes
        CNodeList& nodes = pMTSnapIn->GetNodeList();
        POSITION pos = nodes.GetHeadPosition();
        CNode* pNode = NULL;

        while (pos)
        {
            pNode = nodes.GetNext(pos);
            CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(pNode);
			sc = ScCheckPointers(pSINode, E_UNEXPECTED);
			if (sc)
            {
                sc.TraceAndClear();
                continue;
            }

            // Create component if hasn't been done yet
            CComponent* pCC = pSINode->GetComponent(pCCD->GetComponentID());
            if (pCC == NULL)
            {
                // Create and initialize one
                pCC = new CComponent(pCCD->GetSnapIn());

                sc = ScCheckPointers(pCC, E_OUTOFMEMORY);
                if (sc)
                    return sc.ToHr();

                pCC->SetComponentID(pCCD->GetComponentID());
                pSINode->AddComponentToArray(pCC);

                sc = pCC->Init(pCCD->GetIComponentData(), hMTNode, CNode::ToHandle(pNode),
                                 pCCD->GetComponentID(), pNode->GetViewID());

                sc.Trace_(); // Just trace for MMC1.2 compatibility.
            }
        }

        // if extensions are already expanded, expand the new one now
        if (AreExtensionsExpanded())
        {
            // Get the data object for the cookie from the owner snap-in
            IDataObjectPtr spDataObject;
            sc = GetPrimaryComponentData()->QueryDataObject(GetUserParam(), CCT_SCOPE, &spDataObject);
            if (sc)
                return sc.ToHr();

//              hr = pCCD->Notify (spDataObject, MMCN_EXPAND, TRUE,
//                                 reinterpret_cast<LPARAM>(this));
            sc = Expand (pCCD, spDataObject, TRUE);
            if (sc)
                sc.Trace_(); // Just trace for MMC1.2 compatibility.
        }
    }
    while(0);

    return sc.ToHr();
}


HRESULT CMTNode::IsExpandable()
{
    DECLARE_SC(sc, TEXT("CMTNode::IsExpandable"));

    // if already expanded, we know if there are children
    if (WasExpandedAtLeastOnce())
        return (Child() != NULL) ? S_OK : S_FALSE;

    // Even if not expanded there might be static children
    if (Child() != NULL)
        return S_OK;

    // if primary snap-in can add children, return TRUE
    // Note: When primary declares no children, it is also declaring
    // there will be no dynamic namespace extensions
    if (!(m_usExpandFlags & FLAG_NO_CHILDREN_FROM_PRIMARY))
        return S_OK;

    // Check enabled static extensions if haven't already
    if (!(m_usExpandFlags & FLAG_NAMESPACE_EXTNS_CHECKED))
    {
        m_usExpandFlags |= FLAG_NAMESPACE_EXTNS_CHECKED;

        do
        {
            // Do quick check for no extensions first
            if (GetPrimarySnapIn()->GetExtensionSnapIn() == NULL)
            {
                m_usExpandFlags |= FLAG_NO_NAMESPACE_EXTNS;
                break;
            }

            // Use iterator to find statically enabled namespace extens
            GUID guidNodeType;
            HRESULT hr = GetNodeType(&guidNodeType);
            ASSERT(SUCCEEDED(hr));
            if (FAILED(hr))
                break;

            CExtensionsIterator it;
            // TODO: try to use the easier form of it.ScInitialize()
            sc = it.ScInitialize(GetPrimarySnapIn(), guidNodeType, g_szNameSpace, NULL, 0);

            // if no extensions found, set the flag
            if (sc.IsError() || it.IsEnd())
                m_usExpandFlags |= FLAG_NO_NAMESPACE_EXTNS;
        }
        while (FALSE);
    }

    // if no namespace extensions, there will be no children
    if (m_usExpandFlags & FLAG_NO_NAMESPACE_EXTNS)
        return S_FALSE;

    return S_OK;
}


HRESULT CMTNode::Expand (
    CComponentData* pComponentData,
    IDataObject*    pDataObject,
    BOOL            bExpanding)
{
    HRESULT hr          = E_FAIL;
    bool    fSendExpand = true;

    if (CScopeTree::_IsSynchronousExpansionRequired())
    {
        MMC_EXPANDSYNC_STRUCT   ess;
        ess.bHandled   = FALSE;
        ess.bExpanding = bExpanding;
        ess.hItem      = reinterpret_cast<HSCOPEITEM>(this);

        hr = pComponentData->Notify (pDataObject, MMCN_EXPANDSYNC, 0,
                                     reinterpret_cast<LPARAM>(&ess));

        fSendExpand = !ess.bHandled;
    }

    if (fSendExpand)
    {
        hr = pComponentData->Notify (pDataObject, MMCN_EXPAND, bExpanding,
                                     reinterpret_cast<LPARAM>(this));
    }

    return (hr);
}

SC CMTNode::ScQueryDispatch(DATA_OBJECT_TYPES type,
                                      PPDISPATCH ppScopeNodeObject)
{
    DECLARE_SC(sc, _T("CMTNode::QueryDispatch"));
    sc = ScCheckPointers(ppScopeNodeObject);
    if (sc)
        return sc;

    *ppScopeNodeObject = NULL;

    CMTSnapInNode* pMTSINode = GetStaticParent();
    sc = ScCheckPointers(pMTSINode, E_UNEXPECTED);
    if (sc)
        return sc;

    CComponentData* pCCD = pMTSINode->GetComponentData(GetPrimarySnapInCLSID());
    sc = ScCheckPointers(pCCD, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = pCCD->ScQueryDispatch(GetUserParam(), type, ppScopeNodeObject);

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CMTNode::SetDisplayName
 *
 *
 *--------------------------------------------------------------------------*/

void CMTNode::SetDisplayName (LPCTSTR pszName)
{
    // This function should never be called as it does nothing. Display names
    DECLARE_SC(sc, TEXT("CMTNode::SetDisplayName"));

    if (pszName != (LPCTSTR) MMC_TEXTCALLBACK)
    {
        sc = E_INVALIDARG;
        TraceError(TEXT("The string should be MMC_TEXTCALLBACK"), sc);
        sc.Clear();
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CMTNode::GetDisplayName
 *
 * PURPOSE: Returns the display name of the node.
 *
 * RETURNS:
 *    LPCTSTR
 *
 *+-------------------------------------------------------------------------*/
tstring
CMTNode::GetDisplayName()
{
    CComponentData* pCCD = GetPrimaryComponentData();
    if (pCCD)
    {
        SCOPEDATAITEM ScopeDataItem;
        ZeroMemory(&ScopeDataItem, sizeof(ScopeDataItem));
        ScopeDataItem.mask   = SDI_STR;
        ScopeDataItem.lParam = GetUserParam();

        HRESULT hr = pCCD->GetDisplayInfo(&ScopeDataItem);
        CHECK_HRESULT(hr);

        /*
         * if we succeeded, cache the name returned to us for
         * persistence
         */
        if (SUCCEEDED(hr))
        {
            USES_CONVERSION;
            if (ScopeDataItem.displayname)
                SetCachedDisplayName(OLE2T(ScopeDataItem.displayname));
            else
                SetCachedDisplayName(_T(""));
        }
    }

    return GetCachedDisplayName();
}

/***************************************************************************\
 *
 * METHOD:  CMTNode::ScGetPropertyFromINodeProperties
 *
 * PURPOSE: gets SnapIn property thru INodeProperties interface
 *
 * PARAMETERS:
 *    LPDATAOBJECT pDataObject  [in] - data object
 *    BSTR bstrPropertyName     [in] - property name
 *    PBSTR  pbstrPropertyValue [out] - property value
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTNode::ScGetPropertyFromINodeProperties(LPDATAOBJECT pDataObject, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue)
{
    DECLARE_SC(sc, TEXT("CMTNode::ScGetPropertyFromINodeProperties"));

    SC sc_no_trace; // for 'valid' error - not to be traced

    // parameter check
    sc = ScCheckPointers(pDataObject, bstrPropertyName, pbstrPropertyValue);
    if(sc)
        return sc;

    // get the CComponentData
    CComponentData *pComponentData = GetPrimaryComponentData();
    sc = ScCheckPointers(pComponentData, E_UNEXPECTED);
    if(sc)
        return sc;

    // QI for INodeProperties from IComponentData
    INodePropertiesPtr spNodeProperties = pComponentData->GetIComponentData();

    // at this point we should have a valid interface if it is supported
    sc_no_trace = ScCheckPointers(spNodeProperties, E_NOINTERFACE);
    if(sc_no_trace)
        return sc_no_trace;

    // get the property
    sc_no_trace = spNodeProperties->GetProperty(pDataObject,  bstrPropertyName, pbstrPropertyValue);

    return sc_no_trace;
}

//############################################################################
//############################################################################
//
//  Implementation of class CComponentData
//
//############################################################################
//############################################################################


//____________________________________________________________________________
//
//  Class:      CComponentData Inlines
//____________________________________________________________________________
//

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentData);

CComponentData::CComponentData(CSnapIn * pSnapIn)
    : m_spSnapIn(pSnapIn), m_ComponentID(-1), m_bIComponentDataInitialized(false)

{
    TRACE_CONSTRUCTOR(CComponentData);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentData);

    ASSERT(m_spSnapIn != NULL);
}

CComponentData::~CComponentData()
{
    TRACE_DESTRUCTOR(CComponentData);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentData);

    if (m_spIComponentData != NULL)
        m_spIComponentData->Destroy();
}

HRESULT CComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    ASSERT(m_spIComponentData != NULL);
    if (m_spIComponentData == NULL)
        return E_FAIL;

    HRESULT hr = S_OK;
    __try
    {
        hr = m_spIComponentData->Notify(lpDataObject, event, arg, param);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_FAIL;
        if (m_spSnapIn)
            TraceSnapinException(m_spSnapIn->GetSnapInCLSID(), TEXT("IComponentData::Notify"), event);
    }

    return hr;
}


SC CComponentData::ScQueryDispatch(MMC_COOKIE cookie,
                                   DATA_OBJECT_TYPES type,
                                   PPDISPATCH ppScopeNodeObject)
{
    DECLARE_SC(sc, _T("CComponentData::ScQueryDispatch"));
    sc = ScCheckPointers(m_spIComponentData, E_UNEXPECTED);
    if (sc)
        return sc;

    IComponentData2Ptr spCompData2 = m_spIComponentData;
    sc = ScCheckPointers(spCompData2.GetInterfacePtr(), E_NOINTERFACE);
    if (sc)
        return sc;

    ASSERT(type != CCT_RESULT); // Cant Ask Disp for resultpane objects.
    sc = spCompData2->QueryDispatch(cookie, type, ppScopeNodeObject);

    return sc;
}



/*+-------------------------------------------------------------------------*
 *
 * CreateSnapIn
 *
 * PURPOSE: Create a name space snapin (standalone or extension).
 *
 * PARAMETERS:
 *    clsid                 - class id of the snapin to be created.
 *    ppICD                 - IComponentData ptr of created snapin.
 *    fCreateDummyOnFailure - Create dummy snapin if Create snapin fails.
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT CreateSnapIn (const CLSID& clsid, IComponentData** ppICD,
                    bool fCreateDummyOnFailure /* =true */)
{
    DECLARE_SC(sc, TEXT("CreateSnapIn"));

    EDummyCreateReason eReason = eSnapCreateFailed;
    IComponentDataPtr  spICD;

    sc = ScCheckPointers(ppICD);
    if(sc)
        return sc.ToHr();

    // initialize the out parameter
    *ppICD = NULL;

    CPolicy policy;
    sc = policy.ScInit();
    if (sc)
    {
        eReason = eSnapPolicyFailed;
    }
    else if (policy.IsPermittedSnapIn(clsid))
    {
        /*
         * Bug 258270: creating the snap-in might result in MSI running to
         * install it.  The MSI status window is modeless, but may spawn a
         * modal dialog.  If we don't manually disable MMC's main window,
         * the user might start clicking around in the scope tree while that
         * modal dialog is up, leading to reentrancy and all of the resulting
         * calamity that one would expect.
         */
        bool fReenableMMC = false;
        CScopeTree* pScopeTree = CScopeTree::GetScopeTree();
        HWND hwndMain = (pScopeTree) ? pScopeTree->GetMainWindow() : NULL;

        if (IsWindow (hwndMain))
        {
            fReenableMMC = IsWindowEnabled (hwndMain);

            if (fReenableMMC)
                EnableWindow (hwndMain, false);
        }

        //create the snapin
        sc = spICD.CreateInstance(clsid, NULL,MMC_CLSCTX_INPROC);
        if(!sc.IsError() && (spICD==NULL))
           sc = E_NOINTERFACE;

        /*
         * re-enable the main window if we disabled it
         */
        if (fReenableMMC)
            EnableWindow (hwndMain, true);

        if (sc)
        {
            ReportSnapinInitFailure(clsid);

            // Create a dummy snapin with snapin
            // creation failed message.
            eReason = eSnapCreateFailed;
        }
        else // creation succeeded. return
        {
            *ppICD = spICD.Detach();
            return sc.ToHr();
        }
    }
    else
    {
        // Display a message that policies does not
        // allow this snapin to be created.
        DisplayPolicyErrorMessage(clsid, FALSE);

        // Create a dummy snapin with policy
        // restriction message.
        sc = E_FAIL;
        eReason = eSnapPolicyFailed;
    }

    // If we've reached here, an error occurred

    // create dummy snap-in that only displays error message
    if (fCreateDummyOnFailure)
    {
        sc = ScCreateDummySnapin (&spICD, eReason, clsid);
        if(sc)
            return sc.ToHr();

        sc = ScCheckPointers(spICD, E_UNEXPECTED);
        if(sc)
            return sc.ToHr();

        *ppICD = spICD.Detach();
    }

    return sc.ToHr();
}


CExtSI* AddExtension(CSnapIn* pSnapIn, CLSID& rclsid, CSnapInsCache* pCache)
{
    ASSERT(pSnapIn != NULL);

    // See if extension is already present
    CExtSI* pExt = pSnapIn->FindExtension(rclsid);

    // if not, create one
    if (pExt == NULL)
    {
        // Create cache entry for extension snapin
        if (pCache == NULL)
            pCache = theApp.GetSnapInsCache();

        ASSERT(pCache != NULL);

        CSnapInPtr spExtSnapIn;
        SC sc = pCache->ScGetSnapIn(rclsid, &spExtSnapIn);
        ASSERT(!sc.IsError() && spExtSnapIn != NULL);

        // Attach extension to snap-in
        if (!sc.IsError())
            pExt = pSnapIn->AddExtension(spExtSnapIn);
    }
    else
    {
        // Clear deletion flag
        pExt->MarkDeleted(FALSE);
    }

    return pExt;
}


HRESULT LoadRequiredExtensions (
    CSnapIn*        pSnapIn,
    IComponentData* pICD,
    CSnapInsCache*  pCache /*=NULL*/)
{
    SC sc;

    ASSERT(pSnapIn != NULL);

    // if already loaded, just return
    if (pSnapIn->RequiredExtensionsLoaded())
        goto Cleanup;

    do
    {
        // Set extensions loaded, so we don't try again
        pSnapIn->SetRequiredExtensionsLoaded();

        // if snapin was enabling all extensions
        // clear the flags before asking again
        if (pSnapIn->DoesSnapInEnableAll())
        {
            pSnapIn->SetSnapInEnablesAll(FALSE);
            pSnapIn->SetAllExtensionsEnabled(FALSE);
        }

        // Mark all required extensions for deletion
        CExtSI* pExt = pSnapIn->GetExtensionSnapIn();
        while (pExt != NULL)
        {
            if (pExt->IsRequired())
                pExt->MarkDeleted(TRUE);

            pExt = pExt->Next();
        }

        // Check for interface
        IRequiredExtensionsPtr spReqExtn = pICD;

        // if snap-in wants all extensions enabled
        if (spReqExtn != NULL && spReqExtn->EnableAllExtensions() == S_OK)
        {
            // Set the "enable all" flags
            pSnapIn->SetSnapInEnablesAll(TRUE);
            pSnapIn->SetAllExtensionsEnabled(TRUE);
        }

        // if either user or snap-in wants all extensions
        if (pSnapIn->AreAllExtensionsEnabled())
        {
            // Get list of all extensions
            CExtensionsCache  ExtCache;
            sc = MMCGetExtensionsForSnapIn(pSnapIn->GetSnapInCLSID(), ExtCache);
            if (sc)
                goto Cleanup;

            // Add each extension to snap-in's extension list
            CExtensionsCacheIterator ExtIter(ExtCache);
            for (; ExtIter.IsEnd() == FALSE; ExtIter.Advance())
            {
                // Only add extensions that can be statically enabled
                if ((ExtIter.GetValue() & CExtSI::EXT_TYPE_STATIC) == 0)
                    continue;

                GUID clsid = ExtIter.GetKey();
                CExtSI* pExt = AddExtension(pSnapIn, clsid, pCache);

                // Mark required if enabled by the snap-in
                if (pExt != NULL && pSnapIn->DoesSnapInEnableAll())
                    pExt->SetRequired();
            }
        }

        CPolicy policy;
        sc = policy.ScInit();
        if (sc)
            goto Error;

        // if snap-in supports the interface and didn't enable all
        // ask for specific required extensions
        // Note: this is done even if the user has enabled all because
        //       we need to know which ones the snap-in requires
        if (spReqExtn != NULL && !pSnapIn->DoesSnapInEnableAll())
        {
            CLSID clsid;
            sc = spReqExtn->GetFirstExtension(&clsid);

            // Do while snap-in provides extension CLSIDs
            while (HrFromSc(sc) == S_OK)
            {
                // See if the extension is restricted by policy.
                // If so display a message.
                if (! policy.IsPermittedSnapIn(clsid))
                    DisplayPolicyErrorMessage(clsid, TRUE);

                // Add as required extension
                CExtSI* pExt = AddExtension(pSnapIn, clsid, pCache);
                if (pExt != NULL)
                    pExt->SetRequired();

                sc = spReqExtn->GetNextExtension(&clsid);
            }
        }

        // Delete extensions that are no longer required
        // Note: Because required extensions are updated when snap-in is first loaded
        //       we don't have to worry about adding/deleting any nodes now.
        pSnapIn->PurgeExtensions();

    } while (FALSE);

Cleanup:
    return HrFromSc(sc);

Error:
    TraceError(TEXT("LoadRequiredExtensions"), sc);
    goto Cleanup;
}


HRESULT CComponentData::Init(HMTNODE hMTNode)
{
    ASSERT(hMTNode != 0);

    if (IsInitialized() == TRUE)
        return S_OK;

    ASSERT(m_spSnapIn != NULL);
    HRESULT hr = S_OK;

    do
    {
        if (m_spIComponentData == NULL)
        {
            if (m_spSnapIn == NULL)
            {
                hr = E_POINTER;
                break;
            }

            IUnknownPtr spUnknown;
            hr = CreateSnapIn(m_spSnapIn->GetSnapInCLSID(), &m_spIComponentData);
            ASSERT(SUCCEEDED(hr));
            ASSERT(m_spIComponentData != NULL);

            if (FAILED(hr))
                break;
            if(m_spIComponentData == NULL)
            {
                hr = E_FAIL;
                break;
            }
        }

        hr = m_spIFramePrivate.CreateInstance(CLSID_NodeInit,
#if _MSC_VER >= 1100
                        NULL,
#endif
                        MMC_CLSCTX_INPROC);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        Debug_SetNodeInitSnapinName(m_spSnapIn, m_spIFramePrivate.GetInterfacePtr());

        // Init frame.
        ASSERT(m_ComponentID != -1);
        ASSERT(m_spIFramePrivate != NULL);
        ASSERT(m_spSnapIn != NULL);

        if ((m_spIFramePrivate == NULL) || (m_spSnapIn == NULL))
        {
            hr = E_UNEXPECTED;
            CHECK_HRESULT(hr);
            break;
        }

        m_spIFramePrivate->SetComponentID(m_ComponentID);
        m_spIFramePrivate->CreateScopeImageList(m_spSnapIn->GetSnapInCLSID());
        m_spIFramePrivate->SetNode(hMTNode, NULL);

        // Load extensions requested by snap-in and proceed regardless of outcome
        LoadRequiredExtensions(m_spSnapIn, m_spIComponentData);

        hr = m_spIComponentData->Initialize(m_spIFramePrivate);
        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

    } while (0);

    if (FAILED(hr))
    {
        m_spIComponentData = NULL;
        m_spIFramePrivate = NULL;
    }

    return hr;
}



//############################################################################
//############################################################################
//
//  Implementation of class CMTSnapInNode
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(CMTSnapInNode);

CMTSnapInNode::CMTSnapInNode(Properties* pProps)
      : m_spProps            (pProps),
        m_fCallbackForDisplayName(false)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CMTSnapInNode);

    // Open and Closed images
    SetImage(eStockImage_Folder);
    SetOpenImage(eStockImage_OpenFolder);

	m_ePreloadState    = ePreload_Unknown;
    m_bHasBitmaps      = FALSE;
    m_resultImage      = CMTNode::GetImage();


    /*
     * attach this node to it's properties collection
     */
    if (m_spProps != NULL)
    {
        CSnapinProperties* pSIProps = CSnapinProperties::FromInterface (m_spProps);

        if (pSIProps != NULL)
            pSIProps->ScSetSnapInNode (this);
    }
}

CMTSnapInNode::~CMTSnapInNode() throw()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CMTSnapInNode);

    for (int i=0; i < m_ComponentDataArray.size(); i++)
        delete m_ComponentDataArray[i];

    // DON'T CHANGE THIS ORDER!!!!!
    m_ComponentStorage.Clear();

    /*
     * detach this node from it's properties collection
     */
    if (m_spProps != NULL)
    {
        CSnapinProperties* pSIProps = CSnapinProperties::FromInterface (m_spProps);

        if (pSIProps != NULL)
            pSIProps->ScSetSnapInNode (NULL);
    }

	/*
	 * clean up the image lists (they aren't self-cleaning!)
	 */
	m_imlSmall.Destroy();
	m_imlLarge.Destroy();
}

HRESULT CMTSnapInNode::Init(void)
{
    DECLARE_SC (sc, _T("CMTSnapInNode::Init"));

    if (IsInitialized() == TRUE)
        return S_FALSE;

    HRESULT hr = CMTNode::Init();
    if (FAILED(hr))
        return hr;

    /*
     * initialize the snap-in with its properties interface
     */
    sc = ScInitProperties ();
    if (sc)
        return (sc.ToHr());

    if (IsPreloadRequired())
    {
        CComponentData* pCCD = GetPrimaryComponentData();
        ASSERT(pCCD != NULL);

        IDataObjectPtr spDataObject;
        hr = pCCD->QueryDataObject(GetUserParam(), CCT_SCOPE, &spDataObject);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        HSCOPEITEM hsi = reinterpret_cast<HSCOPEITEM>(this);

        pCCD->Notify(spDataObject, MMCN_PRELOAD, hsi, 0);
    }

    return S_OK;
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::ScInitProperties
 *
 * Initializes the snap-in with its properties interface, if it supports
 * ISnapinProperties.
 *--------------------------------------------------------------------------*/

SC CMTSnapInNode::ScInitProperties ()
{
    DECLARE_SC (sc, _T("CMTSnapInNode::ScInitProperties"));

    /*
     * get the snap-in's IComponentData
     */
    CComponentData* pCCD = GetPrimaryComponentData();
    if (pCCD == NULL)
        return (sc = E_UNEXPECTED);

    IComponentDataPtr spComponentData = pCCD->GetIComponentData();
    if (spComponentData == NULL)
        return (sc = E_UNEXPECTED);

    /*
     * If the snap-in supports ISnapinProperties, give it its Properties
     * interface.
     */
    ISnapinPropertiesPtr spISP = spComponentData;

    if (spISP != NULL)
    {
        /*
         * If we didn't persist properties for this snap-in we won't have
         * a CSnapinProperties object yet; create one now.
         */
        CSnapinProperties* pSIProps = NULL;
        sc = ScCreateSnapinProperties (&pSIProps);
        if (sc)
            return (sc);

        if (pSIProps == NULL)
            return (sc = E_UNEXPECTED);

        /*
         * Initialize the snap-in with the initial properties.
         */
        sc = pSIProps->ScInitialize (spISP, pSIProps, this);
        if (sc)
            return (sc);
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::ScCreateSnapinProperties
 *
 * Creates the CSnapinProperties object for this node.  It is safe to call
 * this method multiple times; subsequent invocations will short out.
 *--------------------------------------------------------------------------*/

SC CMTSnapInNode::ScCreateSnapinProperties (
    CSnapinProperties** ppSIProps)      /* O:pointer to the CSnapinProperties object (optional) */
{
    DECLARE_SC (sc, _T("CMTSnapInNode::ScCreateSnapinProperties"));

    /*
     * create a CSnapinProperties if we don't already have one
     */
    if (m_spProps == NULL)
    {
        /*
         * create the properties object
         */
        CComObject<CSnapinProperties>* pSIProps;
        sc = CComObject<CSnapinProperties>::CreateInstance (&pSIProps);
        if (sc)
            return (sc);

        if (pSIProps == NULL)
            return (sc = E_UNEXPECTED);

        /*
         * keep a reference to the object
         */
        m_spProps = pSIProps;
    }

    /*
     * return a pointer to the implementing object, if desired
     */
    if (ppSIProps != NULL)
        *ppSIProps = CSnapinProperties::FromInterface (m_spProps);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CMTSnapInNode::SetDisplayName
 *
 * PURPOSE: Sets the display name of the node.
 *
 * PARAMETERS:
 *    LPCTSTR  pszName :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CMTSnapInNode::SetDisplayName(LPCTSTR pszName)
{
    bool fDisplayCallback = (pszName == (LPCTSTR)MMC_TEXTCALLBACK);

    /*
     * if our callback setting has changed, we're dirty
     */
    if (m_fCallbackForDisplayName != fDisplayCallback)
    {
        m_fCallbackForDisplayName = fDisplayCallback;
        SetDirty();
    }

    /*
     * if we're not now callback, cache the name (if we're callback,
     * the name will be cached the next time GetDisplayName is called)
     */
    if (!m_fCallbackForDisplayName)
        SetCachedDisplayName(pszName);
}

/*+-------------------------------------------------------------------------*
 *
 * CMTSnapInNode::GetDisplayName
 *
 * PURPOSE: Returns the display name of the node.
 *
 * RETURNS:
 *    LPCTSTR
 *
 *+-------------------------------------------------------------------------*/
tstring
CMTSnapInNode::GetDisplayName()
{
    if (m_fCallbackForDisplayName)
        return (CMTNode::GetDisplayName());

    return GetCachedDisplayName();
}

HRESULT CMTSnapInNode::IsExpandable()
{
    // if haven't intiailized the snap-in we have to assume that
    // there could be children
    if (!IsInitialized())
        return S_OK;

    return CMTNode::IsExpandable();
}


void CMTSnapInNode::CompressComponentDataArray()
{
    int nSize = m_ComponentDataArray.size();
    int nSkipped = 0;

    for (int i=0; i<nSize; ++i)
    {
        ASSERT(m_ComponentDataArray[i] != NULL);

        if (m_ComponentDataArray[i]->IsInitialized() == FALSE)
        {
            // if component failed to intialize, delete it
            // and skip over it
            delete m_ComponentDataArray[i];
            ++nSkipped;
        }
        else
        {
            // if components have been skiped, move the good component to the
            // first vacant slot and adjust the component's ID
            if (nSkipped)
            {
                m_ComponentDataArray[i-nSkipped] = m_ComponentDataArray[i];
                m_ComponentDataArray[i-nSkipped]->ResetComponentID(i-nSkipped);
            }
        }
     }

     // reduce array size by number skipped
     if (nSkipped)
        m_ComponentDataArray.resize(nSize - nSkipped);
}

void CMTSnapInNode::AddNode(CNode * pNode)
{
    #ifdef DBG
    {
        POSITION pos = m_NodeList.Find(pNode);
        ASSERT(pos == NULL);
    }
    #endif

    if (!FindNode(pNode->GetViewID()))
        m_NodeList.AddHead(pNode);
}

void CMTSnapInNode::RemoveNode(CNode * pNode)
{
    POSITION pos = m_NodeList.Find(pNode);

    if (pos != NULL)
        m_NodeList.RemoveAt(pos);
}

CSnapInNode* CMTSnapInNode::FindNode(int nViewID)
{
    POSITION pos = m_NodeList.GetHeadPosition();
    while (pos)
    {
        CSnapInNode* pSINode =
            dynamic_cast<CSnapInNode*>(m_NodeList.GetNext(pos));
        ASSERT(pSINode != NULL);

        if (pSINode->GetViewID() == nViewID)
        {
            return pSINode;
        }
    }

    return NULL;
}

UINT CMTSnapInNode::GetResultImage(CNode* pNode, IImageListPrivate* pResultImageList)
{
    if (pResultImageList == NULL)
        return GetImage();
    if ((m_bHasBitmaps == FALSE) && (m_resultImage != MMC_IMAGECALLBACK))
        return GetImage();

    int ret = 0;
    IFramePrivate* pFramePrivate = dynamic_cast<IFramePrivate*>(pResultImageList);
    COMPONENTID id = 0;
    pFramePrivate->GetComponentID (&id);
    COMPONENTID tempID = (COMPONENTID)-GetID(); // use Ravi's negative of ID scheme
    pFramePrivate->SetComponentID (tempID);

    if (m_bHasBitmaps)
	{
		const int nResultImageIndex = 0;

		/*
		 * if we haven't added this node's images to the result image list,
		 * add it now
		 */
		if (FAILED (pResultImageList->MapRsltImage (tempID, nResultImageIndex, &ret)))
		{
			/*
			 * Extract icons from the imagelist dynamically for device independence.
			 * (There ought to be a way to copy images from one imagelist to
			 * another, but there's not.  ImageList_Copy looks like it should
			 * work, but it only supports copying images within the same image
			 * list.)
			 */
			HRESULT hr;
			CSmartIcon icon;

			/*
			 * Set our icon from the small imagelist.  ImageListSetIcon
			 * will also set the large icon by stretching the small, but
			 * we'll fix that below.
			 */
			icon.Attach (m_imlSmall.GetIcon (0));
			hr = pResultImageList->ImageListSetIcon (
							reinterpret_cast<PLONG_PTR>((HICON)icon),
							nResultImageIndex);

			if (hr == S_OK)
			{
				/*
				 * Replace the large icon that ImageListSetIcon generated
				 * by stretching the small icon above, with the large icon
				 * that was created with the correct dimensions.
				 */
				icon.Attach (m_imlLarge.GetIcon (0));
				hr = pResultImageList->ImageListSetIcon (
								reinterpret_cast<PLONG_PTR>((HICON)icon),
								ILSI_LARGE_ICON (nResultImageIndex));
			}

			if (hr == S_OK)
				pResultImageList->MapRsltImage (tempID, nResultImageIndex, &ret);
		}
    }
	else if (m_resultImage == MMC_IMAGECALLBACK)
	{
        // ask snapin
        // first call IComponent::Notify w/ MMCN_ADD_IMAGES;
        CComponent* pComponent = pNode->GetPrimaryComponent ();
        if (pComponent) {
            IDataObjectPtr spDataObject;
            HRESULT hr = pComponent->QueryDataObject (GetUserParam(), CCT_RESULT, &spDataObject);
            if (spDataObject) {
                hr = pComponent->Notify (spDataObject, MMCN_ADD_IMAGES,
                                        (LPARAM)pResultImageList, (LPARAM)this);
                if (hr == S_OK) {
                    RESULTDATAITEM rdi;
                    ZeroMemory (&rdi, sizeof(rdi));
                    rdi.mask   = SDI_IMAGE;
                    rdi.lParam = GetUserParam();
                    rdi.nImage = 0;
                    hr = pComponent->GetDisplayInfo (&rdi);

                    // map user's number to our number
                    pResultImageList->MapRsltImage (tempID, rdi.nImage, &ret);
                }
            }
        }
    }
    pFramePrivate->SetComponentID (id);         // change back
    return (UINT)ret;
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::ScHandleCustomImages
 *
 * Retrieves images from a snap-in's About object and delegates to the
 * overload of this function to assemble the images into their appropriate
 * internal state.
 *--------------------------------------------------------------------------*/

SC CMTSnapInNode::ScHandleCustomImages (const CLSID& clsidSnapin)
{
	DECLARE_SC (sc, _T("CMTSnapInNode::ScHandleCustomImages"));

	m_bHasBitmaps = false;

	/*
	 * open the SnapIns key
	 */
    MMC_ATL::CRegKey keySnapins;
    sc.FromWin32 (keySnapins.Open (HKEY_LOCAL_MACHINE, SNAPINS_KEY, KEY_READ));
	if (sc)
		return (sc);

	OLECHAR szSnapinCLSID[40];
	if (StringFromGUID2 (clsidSnapin, szSnapinCLSID, countof(szSnapinCLSID)) == 0)
		return (sc = E_UNEXPECTED);

	/*
	 * open the key for the requested snap-in
	 */
    USES_CONVERSION;
	MMC_ATL::CRegKey keySnapin;
	sc.FromWin32 (keySnapin.Open (keySnapins, OLE2T(szSnapinCLSID), KEY_READ));
	if (sc)
		return (sc);

    // from snapin clsid, get "about" clsid, if any.
    TCHAR szAboutCLSID[40] = {0};
	DWORD dwCnt = sizeof(szAboutCLSID);
	sc.FromWin32 (keySnapin.QueryValue (szAboutCLSID, _T("About"), &dwCnt));
	if (sc)
		return (sc);

	if (szAboutCLSID[0] == 0)
		return (sc = E_FAIL);

    // create an instance of the About object
    ISnapinAboutPtr spISA;
    sc = spISA.CreateInstance (T2OLE (szAboutCLSID), NULL, MMC_CLSCTX_INPROC);
	if (sc)
		return (sc);

	sc = ScCheckPointers (spISA, E_UNEXPECTED);
	if (sc)
		return (sc);

    // get the images
    // Documentation explicitly states these images are NOT owned by
    // MMC, despite the are out parameters. So we cannot release them,
    // even though most snapins will leak them anyway.
    // see bugs #139613 & #140637
    HBITMAP hbmpSmallImage = NULL;
    HBITMAP hbmpSmallImageOpen = NULL;
    HBITMAP hbmpLargeImage = NULL;
	COLORREF crMask;
    sc = spISA->GetStaticFolderImage (&hbmpSmallImage,
									  &hbmpSmallImageOpen,
									  &hbmpLargeImage,
									  &crMask);
	if (sc)
		return (sc);

	/*
	 * if the snap-in didn't give us a complete set of bitmaps,
	 * use default images but don't fail
	 */
    if (hbmpSmallImage == NULL || hbmpSmallImageOpen == NULL || hbmpLargeImage == NULL)
        return (sc);

	sc = ScHandleCustomImages (hbmpSmallImage, hbmpSmallImageOpen, hbmpLargeImage, crMask);
	if (sc)
		return (sc);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::ScHandleCustomImages
 *
 * Takes custom images for this snap-in and adds them to an imagelist for
 * device-independence.
 *--------------------------------------------------------------------------*/

SC CMTSnapInNode::ScHandleCustomImages (
	HBITMAP		hbmSmall,			// I:small image
	HBITMAP		hbmSmallOpen,		// I:small open image
	HBITMAP		hbmLarge,			// I:large image
	COLORREF	crMask)				// I:mask color, common between all bitmaps
{
	DECLARE_SC (sc, _T("CMTSnapInNode::ScHandleCustomImages"));

	/*
	 * validate input
	 */
	sc = ScCheckPointers (hbmSmall, hbmSmallOpen, hbmLarge);
	if (sc)
		return (sc);

	/*
	 * we need to make copies of the input bitmaps because the calls to
	 * ImageList_AddMasked (below) messes up the background color
	 */
    WTL::CBitmap bmpSmallCopy = CopyBitmap (hbmSmall);
	if (bmpSmallCopy.IsNull())
		return (sc.FromLastError());

    WTL::CBitmap bmpSmallOpenCopy = CopyBitmap (hbmSmallOpen);
	if (bmpSmallOpenCopy.IsNull())
		return (sc.FromLastError());

    WTL::CBitmap bmpLargeCopy = CopyBitmap (hbmLarge);
	if (bmpLargeCopy.IsNull())
		return (sc.FromLastError());

	/*
	 * preserve the images in imagelists for device independence
	 */
	ASSERT (m_imlSmall.IsNull());
	if (!m_imlSmall.Create (16, 16, ILC_COLOR8 | ILC_MASK, 2, 1)	||
		(m_imlSmall.Add (bmpSmallCopy,     crMask) == -1)			||
		(m_imlSmall.Add (bmpSmallOpenCopy, crMask) == -1))
	{
		return (sc.FromLastError());
	}

	ASSERT (m_imlLarge.IsNull());
	if (!m_imlLarge.Create (32, 32, ILC_COLOR8 | ILC_MASK, 1, 1)	||
		(m_imlLarge.Add (bmpLargeCopy,     crMask) == -1))
	{
		return (sc.FromLastError());
	}

    m_bHasBitmaps = TRUE;

	sc = ScAddImagesToImageList ();
	if (sc)
		return (sc);

	return (sc);
}


void CMTSnapInNode::SetPrimarySnapIn(CSnapIn * pSI)
{
	DECLARE_SC (sc, _T("CMTSnapInNode::SetPrimarySnapIn"));

    ASSERT(m_ComponentDataArray.size() == 0);
    CComponentData* pCCD = new CComponentData(pSI);
    int nID = AddComponentDataToArray(pCCD);
    ASSERT(nID == 0);
    SetPrimaryComponentData(pCCD);

    if (m_bHasBitmaps == FALSE) {
        sc = ScHandleCustomImages (pSI->GetSnapInCLSID());
		if (sc)
			sc.TraceAndClear();

		if (m_bHasBitmaps)
			SetDirty();
    }
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScInitIComponent
 *
 * PURPOSE: Either loads component (if has a stream/storage)
 *          or initializes with a fresh stream/storage
 *
 * PARAMETERS:
 *    CComponent* pCComponent   [in] component to initialize
 *    int viewID                [in] view id of the component
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScInitIComponent(CComponent* pCComponent, int viewID)
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScInitIComponent"));

    // parameter chack
    sc = ScCheckPointers( pCComponent );
    if (sc)
        return sc;

    IComponent* pComponent = pCComponent->GetIComponent();
    sc = ScCheckPointers( pComponent, E_UNEXPECTED );
    if (sc)
        return sc;

    CLSID clsid = pCComponent->GetCLSID();

    // initialize the snapin object
    sc = ScInitComponentOrComponentData(pComponent, &m_ComponentPersistor, viewID, clsid );
    if (sc)
        return sc;

    pCComponent->SetIComponentInitialized();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScInitIComponentData
 *
 * PURPOSE: Either loads component data (if has a stream/storage)
 *          or initializes with a fresh stream/storage
 *
 * PARAMETERS:
 *    CComponentData* pCComponentData
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScInitIComponentData(CComponentData* pCComponentData)
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScInitIComponentData"));

    // parameter check
    sc = ScCheckPointers( pCComponentData );
    if (sc)
        return sc;

    // Get the IComponentData to later obtain IPersist* from
    IComponentData* const pIComponentData = pCComponentData->GetIComponentData();
    sc = ScCheckPointers( pIComponentData, E_UNEXPECTED );
    if (sc)
        return sc;

    const CLSID& clsid = pCComponentData->GetCLSID();

    // initialize the snapin object
    sc = ScInitComponentOrComponentData(pIComponentData, &m_CDPersistor, CDPersistor::VIEW_ID_DOCUMENT, clsid );
    if (sc)
        return sc;

    pCComponentData->SetIComponentDataInitialized();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScInitComponentOrComponentData
 *
 * PURPOSE: Either loads snapin object (component or component data)
 *          or initializes with a fresh stream/storage
 *
 * PARAMETERS:
 *    IUnknown *pSnapin         [in] - snapin to initialize
 *    CMTSnapinNodeStreamsAndStorages *pStreamsAndStorages
 *                              [in] - collection of streams/storages
 *    int idView                [in] - view id of component
 *    const CLSID& clsid        [in] class is of the snapin
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScInitComponentOrComponentData(IUnknown *pSnapin, CMTSnapinNodeStreamsAndStorages *pStreamsAndStorages, int idView, const CLSID& clsid )
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScInitComponentOrComponentData"));

    // parameter check
    sc = ScCheckPointers( pSnapin, pStreamsAndStorages );
    if (sc)
        return sc;

    IPersistStreamPtr       spIPersistStream;
    IPersistStreamInitPtr   spIPersistStreamInit;
    IPersistStoragePtr      spIPersistStorage;

    // determine the interface supported and load/init

    if ( (spIPersistStream = pSnapin) != NULL) // QI first for an IPersistStream
    {
        if ( pStreamsAndStorages->HasStream( idView, clsid ) )
        {
            // load
            IStreamPtr spStream;
            sc = pStreamsAndStorages->ScGetIStream( idView, clsid, &spStream);
            if (sc)
                return sc;

            sc = spIPersistStream->Load( spStream );
            if(sc)
                return sc;
        }
        // for this interface there in no initialization if we have nothing to load from
    }
    else if ( (spIPersistStreamInit = pSnapin) != NULL) // QI for an IPersistStreamInit
    {
        if ( pStreamsAndStorages->HasStream( idView, clsid ) )
        {
            // load
            IStreamPtr spStream;
            sc = pStreamsAndStorages->ScGetIStream( idView, clsid, &spStream);
            if (sc)
                return sc;

            sc = spIPersistStreamInit->Load( spStream );
            if(sc)
                return sc;
        }
        else
        {
            // init new
            sc = spIPersistStreamInit->InitNew();
            if (sc)
                return sc;
        }
    }
    else if ( (spIPersistStorage = pSnapin) != NULL) // QI for an IPersistStorage
    {
        bool bHasStorage = pStreamsAndStorages->HasStorage( idView, clsid );

        IStoragePtr spStorage;
        sc = pStreamsAndStorages->ScGetIStorage( idView, clsid, &spStorage);
        if (sc)
            return sc;

        if ( bHasStorage )
        {
            sc = spIPersistStorage->Load( spStorage );
            if (sc)
                return sc;
        }
        else
        {
            sc = spIPersistStorage->InitNew( spStorage );
            if (sc)
                return sc;
        }
    }

    return sc;
}


/**************************************************************************
// CMTSnapinNode::CloseView
//
// This method does any clean-up that is required before deleting
// a view. For now all we do is close any OCXs assocoiated with the view.
// This is done so the OCX can close before the view is hidden.
***************************************************************************/
HRESULT CMTSnapInNode::CloseView(int idView)
{
    // Locate associated node in specified view
    CNodeList& nodes = GetNodeList();
    ASSERT(&nodes != NULL);
    if (&nodes == NULL)
        return E_FAIL;

    POSITION pos = nodes.GetHeadPosition();
    while (pos)
    {
        CNode* pNode = nodes.GetNext(pos);
        ASSERT(pNode != NULL);
        if (pNode == NULL)
            continue;

        // if match found, tell node to close its controls
        if (pNode->GetViewID() == idView)
        {
            CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(pNode);
            ASSERT(pSINode != NULL);

            pSINode->CloseControls();
            break;
        }
    }

    HRESULT hr = CMTNode::CloseView(idView);
    ASSERT(hr == S_OK);
    return hr == S_OK ? S_OK : E_FAIL;
}


HRESULT CMTSnapInNode::DeleteView(int idView)
{
    HRESULT hr;

    m_ComponentPersistor.RemoveView(idView);

    hr = CMTNode::DeleteView(idView);
    ASSERT(hr == S_OK);
    return hr == S_OK ? S_OK : E_FAIL;
}

SC CMTSnapInNode::ScLoad()
{
    SC      sc;
    CStream stream;
    CLSID   clsid;

    sc = CMTNode::ScLoad();
    if(sc)
        goto Error;

    stream.Attach(GetTreeStream());

    sc = stream.ScRead(&clsid, sizeof(clsid));
    if(sc)
        goto Error;

    // read bitmaps, if any

    // we are ignoring error here, because we had gaps in the save code
    // in the past and now we have console files to deal with
    // see bug 96402 "Private:  AV in FrontPage Server Extensions & HP ManageX"
	ASSERT (sizeof(m_bHasBitmaps) == sizeof(BOOL));
    sc = stream.ScRead(&m_bHasBitmaps, sizeof(BOOL), true /*bIgnoreErrors*/);
    if(sc)
        goto Error;

    if (m_bHasBitmaps == TRUE)
    {

		WTL::CBitmap bmpSmall;
        sc = ScLoadBitmap (stream, &bmpSmall.m_hBitmap);
        if(sc)
            goto Error;

		WTL::CBitmap bmpSmallOpen;
        sc = ScLoadBitmap (stream, &bmpSmallOpen.m_hBitmap);
        if(sc)
            goto Error;

		WTL::CBitmap bmpLarge;
        sc = ScLoadBitmap (stream, &bmpLarge.m_hBitmap);
        if(sc)
            goto Error;

		COLORREF crMask;
        sc = stream.ScRead(&crMask, sizeof(COLORREF));
        if(sc)
            goto Error;

		sc = ScHandleCustomImages (bmpSmall, bmpSmallOpen, bmpLarge, crMask);
		if (sc)
			goto Error;
    }

    {
        CSnapInsCache* const pCache = theApp.GetSnapInsCache();
        ASSERT(pCache != NULL);
        if (pCache == NULL)
            return E_FAIL;

        CSnapInPtr spSI;
        sc = pCache->ScGetSnapIn(clsid, &spSI);
        if (sc)
            goto Error;
        sc = ScCheckPointers(spSI, E_UNEXPECTED);
        if (sc)
            goto Error;

        SetPrimarySnapIn(spSI);
        pCache->SetDirty(FALSE);
    }

    // see if we have to do the preload thing
	{
		BOOL bPreload = FALSE;
		sc = stream.ScRead(&bPreload, sizeof(BOOL), true /*bIgnoreErrors*/); // the preload bit is optional, do no error out.
		if(sc)
			goto Error;

		SetPreloadRequired (bPreload);
	}

    // read all the streams and storages for this node
    sc = ScReadStreamsAndStoragesFromConsole();
	if(sc)
		goto Error;

Cleanup:
    return sc == S_OK ? S_OK : E_FAIL;
Error:
    TraceError(TEXT("CMTSnapInNode::Load"), sc);
    goto Cleanup;

}

HRESULT CMTSnapInNode::IsDirty()
{
	DECLARE_SC (sc, _T("CMTSnapInNode::IsDirty"));

    HRESULT hr = CMTNode::IsDirty();
    ASSERT(SUCCEEDED(hr));
    if (hr != S_FALSE)
    {
        TraceDirtyFlag(TEXT("CMTSnapinNode"), true);
        return hr;
    }

    hr = AreIComponentDatasDirty();
    ASSERT(hr == S_OK || hr == S_FALSE);
    if (hr == S_OK)
    {
        TraceDirtyFlag(TEXT("CMTSnapinNode"), true);
        return S_OK;
    }
    if (hr != S_FALSE)
    {
        TraceDirtyFlag(TEXT("CMTSnapinNode"), true);
        return E_FAIL;
    }

    hr = AreIComponentsDirty();
    ASSERT(hr == S_OK || hr == S_FALSE);
    if (hr == S_OK)
    {
        TraceDirtyFlag(TEXT("CMTSnapinNode"), true);
        return S_OK;
    }
    if (hr != S_FALSE)
    {
        TraceDirtyFlag(TEXT("CMTSnapinNode"), true);
        return E_FAIL;
    }

	/*
	 * See if "preload" bit changed.  If an error occurred while querying
	 * the snap-in, we'll assume that the preload bit hasn't changed.
	 */
	PreloadState ePreloadState = m_ePreloadState;
	SC scNoTrace = ScQueryPreloadRequired (ePreloadState);

    if (scNoTrace.IsError() || (ePreloadState == m_ePreloadState))
    {
        TraceDirtyFlag(TEXT("CMTSnapinNode"), false);
        return S_FALSE;
    }

    TraceDirtyFlag(TEXT("CMTSnapinNode"), true);
    return S_OK;
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::AreIComponentDatasDirty
 *
 * Returns S_OK if any of the IComponentDatas attached to this snap-in node
 * (i.e. those of this snap-in and its extensions) is dirty, S_FALSE otherwise.
 *--------------------------------------------------------------------------*/

HRESULT CMTSnapInNode::AreIComponentDatasDirty()
{
    CComponentData* const pCCD = GetPrimaryComponentData();

#if 1
    /*
     * we used to check the primary component data explicitly, but that
     * (if it exists) is always the first element in the IComponentData
     * array.  The loop below will handle it in a more generic manner.
     */
    ASSERT ((pCCD == NULL) || (pCCD == m_ComponentDataArray[0]));
#else
    IComponentData* const pICCD = pCCD != NULL ?
                                           pCCD->GetIComponentData() : NULL;

    if ((pICCD != NULL) && (IsIUnknownDirty (pICCD) == S_OK))
        return (S_OK);
#endif

    /*
     * check all of the IComponentDatas attached to this snap-in node
     * to see if any one is dirty
     */
    UINT cComponentDatas = m_ComponentDataArray.size();

    for (UINT i = 0; i < cComponentDatas; i++)
    {
        IComponentData* pICCD = (m_ComponentDataArray[i] != NULL)
                                    ? m_ComponentDataArray[i]->GetIComponentData()
                                    : NULL;

        if ((pICCD != NULL) && (IsIUnknownDirty (pICCD) == S_OK))
            return (S_OK);
    }

    return (S_FALSE);
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::AreIComponentsDirty
 *
 * Returns S_OK if any of the IComponents attached to this snap-in node
 * (in any view) is dirty, S_FALSE otherwise.
 *--------------------------------------------------------------------------*/

HRESULT CMTSnapInNode::AreIComponentsDirty()
{
    CNodeList& nodes = GetNodeList();
    ASSERT(&nodes != NULL);
    if (&nodes == NULL)
        return E_FAIL;

    POSITION pos = nodes.GetHeadPosition();

    while (pos)
    {
        CNode* pNode = nodes.GetNext(pos);
        ASSERT(pNode != NULL);
        if (pNode == NULL)
            return E_FAIL;

        CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(pNode);
        ASSERT(pSINode != NULL);
        if (pSINode == NULL)
            return E_FAIL;

        const CComponentArray& components = pSINode->GetComponentArray();
        const int end = components.size();
        for (int i = 0; i < end; i++)
        {
            CComponent* pCC = components[i];
            if ((NULL == pCC) || (pCC->IsInitialized() == FALSE) )
                continue;

            IComponent* pComponent = pCC->GetIComponent();
            if (NULL == pComponent)
                continue;

            HRESULT hr = IsIUnknownDirty(pComponent);
            ASSERT(hr == S_OK || hr == S_FALSE);
            if (hr == S_OK)
                return S_OK;
            if (hr != S_FALSE)
                return E_FAIL;
        }
    }

    return S_FALSE;
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::IsIUnknownDirty
 *
 * Checks an IUnknown* for any of the three persistence interfaces
 * (IPersistStream, IPersistStreamInit, and IPersistStorage, in that order)
 * and if any of them is supported, returns the result of that interface's
 * IsDirty method.
 *--------------------------------------------------------------------------*/

HRESULT CMTSnapInNode::IsIUnknownDirty(IUnknown* pUnk)
{
    ASSERT(pUnk != NULL);
    if (pUnk == NULL)
        return E_POINTER;

    // 1. Check for IPersistStream
    IPersistStreamPtr spIPS = pUnk;
    if (spIPS != NULL)
        return spIPS->IsDirty();

    // 2. Check for IPersistStreamInit
    IPersistStreamInitPtr spIPSI = pUnk;
    if (spIPSI != NULL)
        return spIPSI->IsDirty();

    // 3. Check for IPersistStorage
    IPersistStoragePtr spIPStg = pUnk;
    if (spIPStg != NULL)
        return spIPStg->IsDirty();

    return S_FALSE;
}

// local functions
inline long LongScanBytes (long bits)
{
    bits += 31;
    bits /= 8;
    bits &= ~3;
    return bits;
}

SC ScLoadBitmap (CStream &stream, HBITMAP* pBitmap)
{
    DECLARE_SC(sc, TEXT("ScLoadBitmap"));

    // parameter check
    sc = ScCheckPointers(pBitmap);
    if (sc)
        return sc;

	/*
	 * The bitmap we're going to CreateDIBitmap into should be empty.
	 * If it's not, it may indicate a bitmap leak.  If you've investigated
	 * an instance where this assert fails and determined that *pBitmap
	 * isn't being leaked (be very sure!), set *pBitmap to NULL before
	 * calling ScLoadBitmap.  DO NOT remove this assert because you
	 * think it's hyperactive.
	 */
	ASSERT (*pBitmap == NULL);

    // initialization
    *pBitmap = NULL;

    DWORD dwSize;
    sc = stream.ScRead(&dwSize, sizeof(DWORD));
    if(sc)
        return sc;

    CAutoArrayPtr<BYTE> spDib(new BYTE[dwSize]);
    sc = ScCheckPointers(spDib, E_OUTOFMEMORY);
    if (sc)
        return sc;

    // have a typed pointer for member access
    typedef const BITMAPINFOHEADER * const LPCBITMAPINFOHEADER;
    LPCBITMAPINFOHEADER pDib = reinterpret_cast<LPCBITMAPINFOHEADER>(&spDib[0]);

    sc = stream.ScRead(spDib, dwSize);
    if(sc)
        return sc;

    BYTE * bits = (BYTE*) (pDib+1);
    int depth = pDib->biBitCount*pDib->biPlanes;
    if (depth <= 8)
        bits += (1<<depth)*sizeof(RGBQUAD);

    // get a screen dc
    WTL::CClientDC dc(NULL);
    if (dc == NULL)
        return sc.FromLastError(), sc;

    HBITMAP hbitmap = CreateDIBitmap (dc, pDib, CBM_INIT, bits, (BITMAPINFO*)pDib, DIB_RGB_COLORS);
    if (hbitmap == NULL)
        return sc.FromLastError(), sc;

    // return the bitmap
    *pBitmap = hbitmap;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * PersistBitmap
 *
 * PURPOSE:  Saves Bitmap to / loads from XML doc.
 *
 * PARAMETERS:
 *    CPersistor &persistor :
 *    LPCTSTR   name : name attribute of instance in XML
 *    HBITMAP   hBitmap :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void PersistBitmap(CPersistor &persistor, LPCTSTR name, HBITMAP& hBitmap)
{
    DECLARE_SC(sc, TEXT("PersistBitmap"));

    // combined from ScSaveBitmap & ScLoadBitmap

    // get a screen dc
    WTL::CClientDC dc(NULL);
    if (dc == NULL)
        sc.FromLastError(), sc.Throw();

    CXMLAutoBinary binBlock;


    if (persistor.IsStoring())
    {
        // check pointers
        sc = ScCheckPointers(hBitmap);
        if (sc)
            sc.Throw();

        // create memory dc
        WTL::CDC memdc;
        memdc.CreateCompatibleDC(dc);
        if (memdc == NULL)
            sc.FromLastError(), sc.Throw();

        // get bitmap info
        BITMAP bm;
        if (0 == GetObject (hBitmap, sizeof(BITMAP), (LPSTR)&bm))
            sc.FromLastError(), sc.Throw();

        // TODO:  lousy palette stuff

        int depth;
        switch(bm.bmPlanes*bm.bmBitsPixel)
        {
        case 1:
            depth = 1;
            break;
        case 2:
        case 3:
        case 4:
            depth = 4;
            break;
        case 5:
        case 6:
        case 7:
        case 8:
            depth = 8;
            break;
        default:
            depth = 24;
            break;
        }

        DWORD dwSize = sizeof(BITMAPINFOHEADER) + bm.bmHeight*LongScanBytes(depth*bm.bmWidth);
        DWORD colors = 0;
        if(depth  <= 8)
        {
            colors  = 1<<depth;
            dwSize += colors*sizeof(RGBQUAD);
        }

        sc = binBlock.ScAlloc(dwSize);
        if (sc)
            sc.Throw();

        CXMLBinaryLock sLock(binBlock); // will unlock in destructor

        BITMAPINFOHEADER* dib = NULL;
        sc = sLock.ScLock(&dib);
        if (sc)
            sc.Throw();

        sc = ScCheckPointers(dib, E_UNEXPECTED);
        if (sc)
            sc.Throw();

        BYTE * bits = colors*sizeof(RGBQUAD) + (BYTE *)&dib[1];

        dib->biSize          = sizeof(BITMAPINFOHEADER);
        dib->biWidth         = bm.bmWidth;
        dib->biHeight        = bm.bmHeight;
        dib->biPlanes        = 1;
        dib->biBitCount      = (WORD)depth;
        dib->biCompression   = 0;
        dib->biSizeImage     = dwSize; // includes palette and bih ??
        dib->biXPelsPerMeter = 0;
        dib->biYPelsPerMeter = 0;
        dib->biClrUsed       = colors;
        dib->biClrImportant  = colors;

        HBITMAP hold = memdc.SelectBitmap (hBitmap);
        if (hold == NULL)
            sc.FromLastError(), sc.Throw();

        int lines = GetDIBits (memdc, hBitmap, 0, bm.bmHeight, (LPVOID)bits, (BITMAPINFO*)dib, DIB_RGB_COLORS);
        // see if we were successful
        if (!lines)
            sc.FromLastError();
        else if(lines != bm.bmHeight)
            sc = E_UNEXPECTED; // should not happen

        // clean up gdi resources.
        memdc.SelectBitmap(hold);

        if(sc)
            sc.Throw();
    }

    persistor.Persist(binBlock, name);

    if (persistor.IsLoading())
    {
		/*
		 * The bitmap we're going to CreateDIBitmap into should be empty.
		 * If it's not, it may indicate a bitmap leak.  If you've investigated
		 * an instance where this assert fails and determined that hBitmap
		 * isn't being leaked (be very sure!), set hBitmap to NULL before
		 * calling PersistBitmap.  DO NOT remove this assert because you
		 * think it's hyperactive.
		 */
		ASSERT (hBitmap == NULL);
        hBitmap = NULL;

        CXMLBinaryLock sLock(binBlock); // will unlock in destructor

        BITMAPINFOHEADER* dib = NULL;
        sc = sLock.ScLock(&dib);
        if (sc)
            sc.Throw();

        sc = ScCheckPointers(dib, E_UNEXPECTED);
        if (sc)
            sc.Throw();

        BYTE * bits = (BYTE *)&dib[1];
        int depth = dib->biBitCount*dib->biPlanes;
        if (depth <= 8)
            bits += (1<<depth)*sizeof(RGBQUAD);

        HBITMAP hbitmap = CreateDIBitmap (dc,
                                          dib, CBM_INIT,
                                          bits,
                                          (BITMAPINFO*)dib,
                                          DIB_RGB_COLORS);

        if (hbitmap == NULL)
            sc.FromLastError(), sc.Throw();

        hBitmap = hbitmap;
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CMTSnapInNode::Persist
 *
 * PURPOSE:  Persist snapin node
 *
 * PARAMETERS:
 *    CPersistor &persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CMTSnapInNode::Persist(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::Persist"));

    // save the base class.
    CMTNode::Persist(persistor);

    CLSID clsid;
    ZeroMemory(&clsid,sizeof(clsid));

    if (persistor.IsLoading())
    {
        // check if bitmaps are here
        m_bHasBitmaps = persistor.HasElement(XML_TAG_NODE_BITMAPS, NULL);

        /*
         * load persisted properties, if present
         */
        if (persistor.HasElement (CSnapinProperties::_GetXMLType(), NULL))
        {
            /*
             * create a properties object, since we don't have one yet
             */
            ASSERT (m_spProps == NULL);
            CSnapinProperties* pSIProps = NULL;
            sc = ScCreateSnapinProperties (&pSIProps);
            if (sc)
                sc.Throw();

            if (pSIProps == NULL)
                (sc = E_UNEXPECTED).Throw();

            /*
             * load the properties
             */
            persistor.Persist (*pSIProps);
        }
    }
    else
    {
        clsid = GetPrimarySnapInCLSID();

        /*
         * persist properties, if present
         */
        if (m_spProps != NULL)
        {
            CSnapinProperties* pSIProps = CSnapinProperties::FromInterface(m_spProps);

            if (pSIProps != NULL)
                persistor.Persist (*pSIProps);
        }
    }

    persistor.PersistAttribute(XML_ATTR_MT_NODE_SNAPIN_CLSID, clsid);

    if (m_bHasBitmaps)
    {
        CPersistor persistorBitmaps(persistor, XML_TAG_NODE_BITMAPS);

		/*
		 * Early versions of XML persistence saved device-dependent
		 * bitmaps.  If there's a BinaryData element named "SmallOpen",
		 * this is a console saved by early XML persistence -- read it
		 * in a special manner.
		 */
		if (persistor.IsLoading() &&
			persistorBitmaps.HasElement (XML_TAG_VALUE_BIN_DATA,
										 XML_NAME_NODE_BITMAP_SMALL_OPEN))
		{
			WTL::CBitmap bmpSmall, bmpSmallOpen, bmpLarge;
			std::wstring strMask;

			PersistBitmap(persistorBitmaps, XML_NAME_NODE_BITMAP_SMALL,      bmpSmall.m_hBitmap);
			PersistBitmap(persistorBitmaps, XML_NAME_NODE_BITMAP_SMALL_OPEN, bmpSmallOpen.m_hBitmap);
			PersistBitmap(persistorBitmaps, XML_NAME_NODE_BITMAP_LARGE,      bmpLarge.m_hBitmap);
			persistorBitmaps.PersistAttribute(XML_ATTR_NODE_BITMAPS_MASK, strMask);

			COLORREF crMask = wcstoul(strMask.c_str(), NULL, 16);
			sc = ScHandleCustomImages (bmpSmall, bmpSmallOpen, bmpLarge, crMask);
			if (sc)
				sc.Throw();
		}

		/*
		 * We either writing or reading a modern XML file that has persisted
		 * the images in device-independent imagelist.  Read/write them that way.
		 */
		else
		{
			persistorBitmaps.Persist (m_imlSmall, XML_NAME_NODE_BITMAP_SMALL);
			persistorBitmaps.Persist (m_imlLarge, XML_NAME_NODE_BITMAP_LARGE);

			if (persistor.IsLoading())
			{
				sc = ScAddImagesToImageList();
				if (sc)
					sc.Throw();
			}
		}
    }

    // setup snapins CD
	if (persistor.IsLoading())
	{
        CSnapInsCache* const pCache = theApp.GetSnapInsCache();
        if (pCache == NULL)
            sc.Throw(E_FAIL);

        CSnapInPtr spSI;
        sc = pCache->ScGetSnapIn(clsid, &spSI);
        if (sc)
            sc.Throw();
        if (spSI != NULL)
            SetPrimarySnapIn(spSI);
        else
            sc.Throw(E_UNEXPECTED);
        pCache->SetDirty(FALSE);
    }

    // when storing, ask snapins to save their data first
    if ( persistor.IsStoring() )
    {
        sc = ScSaveIComponentDatas();
        if (sc)
            sc.Throw();

        sc = ScSaveIComponents();
        if (sc)
            sc.Throw();
    }

    persistor.Persist(m_CDPersistor);
    persistor.Persist(m_ComponentPersistor);

	/*
	 * Save/load the preload bit.  Do this last to avoid busting old .msc files.
	 */
	BOOL bPreload = false;
    if (persistor.IsStoring() && IsInitialized())
		bPreload = IsPreloadRequired ();

    persistor.PersistAttribute(XML_ATTR_MT_NODE_PRELOAD, CXMLBoolean(bPreload));

    if (persistor.IsLoading())
		SetPreloadRequired (bPreload);
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::ScAddImagesToImageList
 *
 * Adds the small and small(open) bitmaps for the snap-in to the scope
 * tree's imagelist.
 *--------------------------------------------------------------------------*/

SC CMTSnapInNode::ScAddImagesToImageList()
{
	DECLARE_SC (sc, _T("CMTSnapInNode::ScAddImagesToImageList"));

	/*
	 * get the scope tree's imagelist
	 */
	CScopeTree* pScopeTree = CScopeTree::GetScopeTree();
	sc = ScCheckPointers (pScopeTree, E_UNEXPECTED);
	if (sc)
		return (sc);

	WTL::CImageList imlScopeTree = pScopeTree->GetImageList();
	if (imlScopeTree.IsNull())
		return (sc = E_UNEXPECTED);

	/*
	 * add images to scope tree's imagelist, first closed...
	 */
	CSmartIcon icon;
	icon.Attach (m_imlSmall.GetIcon (0));
	if (icon == NULL)
		return (sc.FromLastError());

    SetImage (imlScopeTree.AddIcon (icon));

	/*
	 * ...then open
	 */
	icon.Attach (m_imlSmall.GetIcon (1));
	if (icon == NULL)
		return (sc.FromLastError());

    SetOpenImage (imlScopeTree.AddIcon (icon));

	return (sc);
}


CComponent* CMTSnapInNode::GetComponent(UINT nViewID, COMPONENTID nID,
                                        CSnapIn* pSnapIn)
{
    CNodeList& nodes = GetNodeList();
    POSITION pos = nodes.GetHeadPosition();
    CNode* pNode = NULL;

    while (pos)
    {
        pNode = nodes.GetNext(pos);
        if (pNode != NULL && pNode->GetViewID() == (int)nViewID)
            break;
    }

    if(pNode == NULL)
        return NULL;

    ASSERT(pNode != NULL);
    ASSERT(pNode->GetViewID() == (int)nViewID);

    if (pNode->GetViewID() != (int)nViewID)
        return NULL;

    CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(pNode);
    CComponent* pCC = pSINode->GetComponent(nID);

    if (pCC == NULL)
        pCC = pSINode->CreateComponent(pSnapIn, nID);

    return pCC;
}

CNode* CMTSnapInNode::GetNode(CViewData* pViewData, BOOL fRootNode)
{
    /*
     * check for another CSnapInNode that already exists in this view
     */
    CSnapInNode* pExistingNode = FindNode (pViewData->GetViewID());
    CSnapInNode* pNewNode;

    /*
     * if this is the first CSnapInNode for this view, create a unique one
     */
    if (fRootNode || (pExistingNode == NULL))
        pNewNode = new CSnapInNode (this, pViewData, fRootNode);

    /*
     * otherwise, copy the node that's here
     */
    else
        pNewNode = new CSnapInNode (*pExistingNode);

    return (pNewNode);
}


/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::Reset
 *
 * PURPOSE: Resets the node in order to reload extensions. basically it forces
 *          save-load-init sequence to refresh the snapin node
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CMTSnapInNode::Reset()
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::Reset"));

    CSnapIn * pSnapIn = GetPrimarySnapIn();
    ASSERT(pSnapIn != NULL);

    // we will perform resetting of components and component datas
    // by storing / loading them "the XML way"
    // following that there is nothing what makes this node different
    // from one loaded from XML, so we will change it's type

    sc = ScSaveIComponentDatas();
    if (sc)
        sc.TraceAndClear(); // continue even on error

    sc = ScSaveIComponents();
    if (sc)
        sc.TraceAndClear(); // continue even on error

    // need to reset component XML streams/storage
    sc = m_CDPersistor.ScReset();
    if (sc)
        sc.TraceAndClear(); // continue even on error

    sc = m_ComponentPersistor.ScReset();
    if (sc)
        sc.TraceAndClear(); // continue even on error

    // First Reset all the nodes
    POSITION pos = m_NodeList.GetHeadPosition();
    while (pos)
    {
        CSnapInNode* pSINode =
            dynamic_cast<CSnapInNode*>(m_NodeList.GetNext(pos));
        ASSERT(pSINode != NULL);

        pSINode->Reset();
    }

    for (int i=0; i < m_ComponentDataArray.size(); i++)
        delete m_ComponentDataArray[i];

    m_ComponentDataArray.clear();

    CMTNode::Reset();

    ResetExpandedAtLeastOnce();

    SetPrimarySnapIn(pSnapIn);

    pos = m_NodeList.GetHeadPosition();
    while (pos)
    {
        CSnapInNode* pSINode =
            dynamic_cast<CSnapInNode*>(m_NodeList.GetNext(pos));
        ASSERT(pSINode != NULL);

        CComponent* pCC = new CComponent(pSnapIn);
        pCC->SetComponentID(GetPrimaryComponentID());
        pSINode->AddComponentToArray(pCC);

        pSINode->SetPrimaryComponent(pCC);
    }

    Init();

    pos = m_NodeList.GetHeadPosition();
    while (pos)
    {
        CSnapInNode* pSINode =
            dynamic_cast<CSnapInNode*>(m_NodeList.GetNext(pos));
        ASSERT(pSINode != NULL);
        pSINode->InitComponents();
    }
}



/*+-------------------------------------------------------------------------*
 * class CLegacyNodeConverter
 *
 *
 * PURPOSE: Used to emulate the legacy node snapins' Save routines.
 *
 *+-------------------------------------------------------------------------*/
class CLegacyNodeConverter : public CSerialObjectRW
{

public:
    CLegacyNodeConverter(LPCTSTR szName, LPCTSTR szView)
    : m_strName(szName), m_strView(szView)
    {
    }

    ~CLegacyNodeConverter()
    {
        // must call detach or the strings will be removed from the string table.
        m_strName.Detach();
        m_strView.Detach();
    }



public:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion) {ASSERT(0 && "Should not come here."); return E_UNEXPECTED;}
    virtual HRESULT WriteSerialObject(IStream &stm);

private: // attributes - persisted
    CStringTableString  m_strName;  // the name of the root node, which is the only node created by the snapin
    CStringTableString  m_strView;  // the view displayed by the node.
};


/*+-------------------------------------------------------------------------*
 *
 * CLegacyNodeConverter::WriteSerialObject
 *
 * PURPOSE: Writes out the name and view strings using the format expected
 *          by the built in snapins.
 *
 * PARAMETERS:
 *    IStream & stm :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CLegacyNodeConverter::WriteSerialObject(IStream &stm)
{
    stm << m_strName;
    stm << m_strView;

    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CMTSnapInNode::ScConvertLegacyNode
 *
 * PURPOSE: Reads in an legacy node and converts it to a built-in snapin node.
 *          1) The original tree stream is read and the target URL or OCX is read.
 *          2) The new Data stream with the munged CLSID name is created
 *             and the data required by the snapin is placed there. Because
 *             the bitmap etc is already loaded, and because the original
 *             stream is thrown away, we don't need to emulate the "tree"
 *             stream. Also, because this snapin has no view specific information,
 *             the views storage is not used.
 *
 * PARAMETERS: clsid: The CLSID of the built in snapin.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMTSnapInNode::ScConvertLegacyNode(const CLSID &clsid)
{
    USES_CONVERSION;
    SC              sc;
    std::wstring    strView;
    CStream         stream;
    CStream         nodeStream = NULL;
    int             iStorageOrStream=0;
    IStreamPtr      spCDStream;

    bool bIsHTMLNode = (&clsid == &CLSID_HTMLSnapin);
    bool bIsOCXNode  = (&clsid == &CLSID_OCXSnapin);

    // 1. load the base class
    sc = CMTNode::ScLoad();
    if(sc)
        goto Error;

    // get the tree stream.
    stream.Attach(GetTreeStream());

    // 2. read the URL or OCX string as needed.
    if(bIsHTMLNode)
    {
        WCHAR* szView = NULL;

        // get the string length of the label, and read the string.
        unsigned int stringLength;
        sc = stream.ScRead(&stringLength, sizeof(stringLength));
        if(sc)
            goto Error;

        szView = reinterpret_cast<wchar_t*>(alloca((stringLength+1)*sizeof(WCHAR))); // allocates on stack, don't free.
        if (szView == NULL)
            goto PointerError;

        sc = stream.ScRead(szView, stringLength*2);
        if(sc)
            goto Error;

        szView[stringLength] = TEXT('\0'); // null terminate the string.

        strView = szView;
    }
    else if(bIsOCXNode)
    {
        CLSID clsidOCX;

        // Read OCX clsid
        sc = stream.ScRead(&clsidOCX, sizeof(clsidOCX));
        if(sc)
            goto Error;

        {
            WCHAR   szCLSID[40];
            if (0 == StringFromGUID2 (clsidOCX, szCLSID, countof(szCLSID)))
            {
                sc = E_UNEXPECTED;
                goto Error;
            }

            strView = szCLSID;
        }
    }

    // at this point, strView contains either the URL or OCX CLSID.



    // 3. Write node name
    sc = m_CDPersistor.ScGetIStream( clsid, &spCDStream );
    if (sc)
        goto Error;

    nodeStream.Attach( spCDStream );
    if(NULL == nodeStream.Get())
        goto PointerError;

    // 4. Write out the Data stream.
    {
		tstring strName = GetDisplayName();
        CLegacyNodeConverter converter(strName.data(), OLE2CT(strView.data()));

        // call the converter to write out the stream.
        sc = converter.Write(nodeStream);
        if(sc)
            goto Error;
    }

    // at this point, the "data" stream  should be correctly written out.

    // 5. For OCX nodes, convert the view streams and storages
    /*      OLD                                             NEW
            2 (node storage)                                2 (node storage)
                data                                            data
                tree                                            tree
                view                                            view
                    1  <--- streams and storages   ---------        1
                    2  <--- written by OCX, 1 per view --   \           1jvmv2n4y1k471h9ujk86lite7 (OCX snap-in)
                                                         \   -------->      ocx_stream (or ocx_storage)
                                                          \
                                                           ------>  2   1jvmv2n4y1k471h9ujk86lite7 (OCX snap-in)
                                                                            ocx_stream (or ocx_storage)


    */
    if(bIsOCXNode)
    {
        for(iStorageOrStream = 1 /*NOT zero*/; ; iStorageOrStream++)
        {
            // create the name of the storage
            CStr strStorageOrStream;
            strStorageOrStream.Format(TEXT("%d"), iStorageOrStream);

            // at this point strStorageOrStream should contain a number like "1"
            CStorage storageView(GetViewStorage());

            // rename the storage or stream labelled "1" to "temp" under the same parent.
            sc = storageView.ScMoveElementTo(T2COLE(strStorageOrStream), storageView, L"temp", STGMOVE_MOVE);
            if(sc == SC(STG_E_FILENOTFOUND))    // loop end condition - no more streams or storages
            {
                sc.Clear();
                break;
            }

            if(sc)
                goto Error;

            // now we create the storage with the same name, eg "1"
            {
                WCHAR name[MAX_PATH];
                sc = ScGetComponentStorageName(name, countof(name), clsid); // the name of the snapin component
                if(sc)
                    goto Error;

                CStorage storageNewView, storageSnapIn;
                sc = storageNewView.ScCreate(storageView, T2COLE(strStorageOrStream),
                                          STGM_WRITE|STGM_SHARE_EXCLUSIVE|STGM_CREATE,
                                          L"\\node\\#\\view\\#\\storage" /*CHANGE*/);
                if(sc)
                    goto Error;

                // create the snapin's storage underneath the view's storage
                sc = storageSnapIn.ScCreate(storageNewView, name,
                                            STGM_WRITE|STGM_SHARE_EXCLUSIVE|STGM_CREATE,
                                            L"\\node\\#\\view\\#\\storage\\#\\snapinStorage");
                if(sc)
                    goto Error;

                // move the "temp" stream or storage to the storage called L"ocx_streamorstorage"
                // (which is what the OCX snapin expects.)

                sc = storageView.ScMoveElementTo(L"temp", storageSnapIn, L"ocx_streamorstorage", STGMOVE_MOVE);
                if(sc)
                    goto Error;
            }

        }
    }


    // 6. now do the same thing that CMTSnapInNode::ScLoad would do.
    {
        CSnapInsCache* const pCache = theApp.GetSnapInsCache();
        ASSERT(pCache != NULL);
        if (pCache == NULL)
            goto FailedError;

        CSnapInPtr spSI;
        sc = pCache->ScGetSnapIn(clsid, &spSI);
        ASSERT(!sc.IsError() && spSI != NULL);

        if (!sc.IsError() && spSI != NULL)
            SetPrimarySnapIn(spSI);

        pCache->SetDirty(FALSE);

        if(sc)
            goto Error;
    }

    // always set the preload bit.
    SetPreloadRequired (true);

    // Some actions (loading bitmaps for example) performed here invalidate the node
    // and set the dirty flag. Since coverting legacy node may be done any time again
    // the converted node should not be assumed as changed.
    ClearDirty();

    // read all the streams and storages for this node
    sc = ScReadStreamsAndStoragesFromConsole();
	if(sc)
		goto Error;

Cleanup:
    return sc;

FailedError:
    sc = E_FAIL;
    goto Error;
PointerError:
    sc = E_POINTER;
Error:
    TraceError(TEXT("CMTSnapInNode::ScConvertLegacyNode"), sc);
    goto Cleanup;
}

HRESULT copyStream(IStream* dest, IStream* src)
{
    ASSERT(dest != NULL);
    ASSERT(src != NULL);
    if (dest == NULL || src == NULL)
        return E_POINTER;

    const LARGE_INTEGER loc = {0,0};
    ULARGE_INTEGER newLoc;
    HRESULT hr = src->Seek(loc, STREAM_SEEK_SET, &newLoc);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;

    hr = dest->Seek(loc, STREAM_SEEK_SET, &newLoc);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;

    const ULARGE_INTEGER size = {0,0};
    hr = dest->SetSize(size);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    STATSTG statstg;
    hr = src->Stat(&statstg, STATFLAG_NONAME);
    ASSERT(hr == S_OK);
    if (hr != S_OK)
        return E_FAIL;

    ULARGE_INTEGER cr;
    ULARGE_INTEGER cw;
    hr = src->CopyTo(dest, statstg.cbSize, &cr, &cw);
#if 0 // for debugging...
    for (long i = 0; true; i++)
    {
        BYTE b;
        long bytesRead;
        hr = src->Read(&b, sizeof(b), &bytesRead);
        if (hr != S_OK)
            return S_OK;
        long bytesWritten;
        hr = dest->Write(&b, bytesRead, &bytesWritten);
        ASSERT(hr == S_OK);
        ASSERT(bytesWritten == bytesRead);
        if (hr != S_OK || bytesWritten != bytesRead)
            return E_FAIL;
    }
#endif
    return S_OK;
}

//############################################################################
//############################################################################
//
//  Helper functions
//
//############################################################################
//############################################################################

void    DisplayPolicyErrorMessage(const CLSID& clsid, bool bExtension)
{
    CStr strMessage;

    if (bExtension)
        strMessage.LoadString(GetStringModule(), IDS_EXTENSION_NOTALLOWED);
    else
        strMessage.LoadString(GetStringModule(), IDS_SNAPIN_NOTALLOWED);

    // Get the snapin name for the error message.
    CSnapInsCache* pSnapInsCache = theApp.GetSnapInsCache();
    ASSERT(pSnapInsCache != NULL);
    CSnapInPtr spSnapIn;

    SC sc = pSnapInsCache->ScFindSnapIn(clsid, &spSnapIn);
    if (!sc.IsError() && (NULL != spSnapIn))
    {
		WTL::CString strName;
		sc = spSnapIn->ScGetSnapInName (strName);

		if (!sc.IsError())
		{
			strMessage += _T("\n");
			strMessage += strName;
			strMessage += _T(".");
		}
    }

    ::MessageBox(NULL, strMessage, _T("MMC"), MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
}

/***************************************************************************\
 *
 * METHOD:  CMMCSnapIn::get_Vendor
 *
 * PURPOSE: returns vendor info for snapin. Implements OM property SnapIn.Vendor
 *
 * PARAMETERS:
 *    PBSTR pbstrVendor [out] - vendor info
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCSnapIn::get_Vendor( PBSTR pbstrVendor )
{
    DECLARE_SC(sc, TEXT("CMMCSnapIn::get_Vendor"));

    sc = ScCheckPointers(pbstrVendor);
    if (sc)
        return sc.ToHr();

    // init out parameter
    *pbstrVendor = NULL;

    // get the snapin about
    CSnapinAbout *pSnapinAbout = NULL;
    sc = ScGetSnapinAbout(pSnapinAbout);
    if (sc)
        return sc.ToHr();

    // recheck the pointer
    sc = ScCheckPointers(pSnapinAbout, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    *pbstrVendor = ::SysAllocString( pSnapinAbout->GetCompanyName() );

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCSnapIn::get_Version
 *
 * PURPOSE: returns version info for snapin. Implements OM property SnapIn.Version
 *
 * PARAMETERS:
 *    PBSTR pbstrVersion [out] - version info
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCSnapIn::get_Version( PBSTR pbstrVersion )
{
    DECLARE_SC(sc, TEXT("CMMCSnapIn::get_Version"));

    sc = ScCheckPointers(pbstrVersion);
    if (sc)
        return sc.ToHr();

    // init out parameter
    *pbstrVersion = NULL;

    // get the snapin about
    CSnapinAbout *pSnapinAbout = NULL;
    sc = ScGetSnapinAbout(pSnapinAbout);
    if (sc)
        return sc.ToHr();

    // recheck the pointer
    sc = ScCheckPointers(pSnapinAbout, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    *pbstrVersion = ::SysAllocString( pSnapinAbout->GetVersion() );

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCSnapIn::GetMTSnapInNode
 *
 * PURPOSE: helper. returns mtnode for the snapin
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CMTSnapInNode *    - node
 *
\***************************************************************************/
CMTSnapInNode * CMMCSnapIn::GetMTSnapInNode()
{
    CMTSnapInNode *pMTSnapInNode = NULL;
    SC sc = ScGetTiedObject(pMTSnapInNode);
    if (sc)
        return NULL;

    return pMTSnapInNode;
}

/***************************************************************************\
 *
 * METHOD:  CMMCSnapIn::ScGetSnapinAbout
 *
 * PURPOSE: helper. returns snapins about object
 *
 * PARAMETERS:
 *    CSnapinAbout*& pAbout [out] - snapins about object
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCSnapIn::ScGetSnapinAbout(CSnapinAbout*& pAbout)
{
    DECLARE_SC(sc, TEXT("CMMCSnapIn::ScGetSnapinAbout"));

    // init out param
    pAbout = NULL;

    // If the snapin object is already created just return it.
    if (NULL != (pAbout = m_spSnapinAbout.get()))
        return sc;

    // get snapins clsid
    CLSID clsidSnapin = GUID_NULL;
    sc = GetSnapinClsid(clsidSnapin);
    if (sc)
        return sc;

    CLSID clsidAbout; // get the about class-id.
    sc = ScGetAboutFromSnapinCLSID(clsidSnapin, clsidAbout);
    if (sc)
        return sc;

    if (clsidSnapin == GUID_NULL)
        return sc = E_FAIL;

    // Create about object
    m_spSnapinAbout = SnapinAboutPtr (new CSnapinAbout);
    if (! m_spSnapinAbout.get())
        return sc = E_OUTOFMEMORY;

    // and initialize it.
    if (!m_spSnapinAbout->GetSnapinInformation(clsidAbout))
        return sc = E_FAIL;

    pAbout = m_spSnapinAbout.get();

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::IsPreloadRequired
 *
 * Returns true if the snap-in wants MMCN_PRELOAD notifications, false
 * otherwise.
 *--------------------------------------------------------------------------*/

BOOL CMTSnapInNode::IsPreloadRequired () const
{
	DECLARE_SC (sc, _T("CMTSnapInNode::IsPreloadRequired"));

	/*
	 * if we don't know whether the snap-in wants MMCN_PRELOAD (because
	 * we haven't asked it yet), ask now
	 */
	if (m_ePreloadState == ePreload_Unknown)
	{
		/*
		 * assume preload isn't required
		 */
		m_ePreloadState = ePreload_False;

		sc = ScQueryPreloadRequired (m_ePreloadState);
		if (sc)
			sc.TraceAndClear();
	}

	return (m_ePreloadState == ePreload_True);
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::ScQueryPreloadRequired
 *
 * Asks the snap-in whether it requires preload notification by asking its
 * data object for the CCF_SNAPIN_PRELOADS format.
 *
 * Returns in ePreload:
 *
 * 		ePreload_True	snap-in requires MMCN_PRELOAD
 * 		ePreload_False	snap-in doesn't require MMCN_PRELOAD
 *
 * If anything fails during the process of asking the snap-in for
 * CCF_SNAPIN_PRELOADS, the value of ePreload is unchanged.
 *--------------------------------------------------------------------------*/

SC CMTSnapInNode::ScQueryPreloadRequired (
	PreloadState&	ePreload) const		/* O:preload state for snap-in		*/
{
	DECLARE_SC (sc, _T("CMTSnapInNode::ScQueryPreloadRequired"));

	/*
	 * make sure we have a primary ComponentData
	 */
    CComponentData* pCCD = GetPrimaryComponentData();
	sc = ScCheckPointers (pCCD, E_UNEXPECTED);
	if (sc)
		return (sc);

	/*
	 * get the data object for this node
	 */
	IDataObjectPtr spDataObject;
	sc = pCCD->QueryDataObject(GetUserParam(), CCT_SCOPE, &spDataObject);
	if (sc)
		return (sc);

	sc = ScCheckPointers (spDataObject, E_UNEXPECTED);
	if (sc)
		return (sc);

	/*
	 * CCF_SNAPIN_PRELOADS is an optional clipboard format, so it's not
	 * an error if ExtractData fails.
	 */
	BOOL bPreload = (ePreload == ePreload_True) ? TRUE : FALSE;
	if (SUCCEEDED (ExtractData (spDataObject, GetPreLoadFormat(),
								(BYTE*)&bPreload, sizeof(BOOL))))
	{
		ePreload = (bPreload) ? ePreload_True : ePreload_False;
	}

	return (sc);
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScReadStreamsAndStoragesFromConsole
 *
 * PURPOSE: Enumerates old (structured storage based) console.
 *          Enumerates the streams and storages under the snapin node.
 *          For each stream/storage found adds a copy to m_CDPpersistor
 *          or m_ComponentPersistor, indexed by a hash value (name in storage).
 *          These entries will be recognized and stored by a CLSID when
 *          CLSID is known ( when request by CLSID is made )
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScReadStreamsAndStoragesFromConsole()
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScReadStreamsAndStoragesFromConsole"));

    IStorage* pNodeCDStorage = GetStorageForCD();
    sc = ScCheckPointers( pNodeCDStorage, E_POINTER );
    if (sc)
        return sc;

    IEnumSTATSTGPtr spEnum;
    sc = pNodeCDStorage->EnumElements( 0, NULL, 0, &spEnum );
    if (sc)
        return sc;

    // recheck pointer
    sc = ScCheckPointers( spEnum, E_POINTER );
    if (sc)
        return sc;

    // reset enumeration
    sc = spEnum->Reset();
    if (sc)
        return sc;

    // enumerate the items ( each entry is for separate component data )
    while (1)
    {
        STATSTG statstg;
        ZeroMemory( &statstg, sizeof(statstg) );

        ULONG cbFetched = 0;
        sc = spEnum->Next( 1, &statstg, &cbFetched );
        if (sc)
            return sc;

        if ( sc != S_OK ) // - done
        {
            sc.Clear();
            break;
        }

        // attach to the out param
        CCoTaskMemPtr<WCHAR> spName( statstg.pwcsName );

        // make a copy of streams and storages
        if ( statstg.type == STGTY_STREAM )
        {
            IStreamPtr spStream;
            sc = OpenDebugStream(pNodeCDStorage, spName, STGM_READ | STGM_SHARE_EXCLUSIVE,
                                 L"\\node\\#\\data\\clsid", &spStream);
            if (sc)
                return sc;

            sc = m_CDPersistor.ScInitIStream( spName, spStream );
            if (sc)
                return sc;
        }
        else if ( statstg.type == STGTY_STORAGE )
        {
            IStoragePtr spStorage;
            sc = OpenDebugStorage(pNodeCDStorage, spName, STGM_READ | STGM_SHARE_EXCLUSIVE,
                                  L"\\node\\#\\data\\clsid", &spStorage);
            if (sc)
                return sc;

            sc = m_CDPersistor.ScInitIStorage( spName, spStorage );
            if (sc)
                return sc;
        }
    }

    // view streams/storages
    IStorage *pNodeComponentStorage = GetViewStorage();
    sc = ScCheckPointers( pNodeComponentStorage, E_POINTER );
    if (sc)
        return sc;

    spEnum = NULL;
    sc = pNodeComponentStorage->EnumElements( 0, NULL, 0, &spEnum );
    if (sc)
        return sc;

    // recheck pointer
    sc = ScCheckPointers( spEnum, E_POINTER );
    if (sc)
        return sc;

    // reset enumeration
    sc = spEnum->Reset();
    if (sc)
        return sc;

    // enumerate the items ( each entry is for separate view )
    while (1)
    {
        STATSTG statstg;
        ZeroMemory( &statstg, sizeof(statstg) );

        ULONG cbFetched = 0;
        sc = spEnum->Next( 1, &statstg, &cbFetched );
        if (sc)
            return sc;

        if ( sc != S_OK ) //  done
        {
            sc.Clear();
            break;
        }

        // attach to the out param
        CCoTaskMemPtr<WCHAR> spName( statstg.pwcsName );

        // read the view storage
        if ( statstg.type == STGTY_STORAGE )
        {
            int idView = CMTNode::GetViewIdFromStorageName(spName);

            IStoragePtr spViewStorage;
            sc = OpenDebugStorage(pNodeComponentStorage, spName, STGM_READ | STGM_SHARE_EXCLUSIVE,
                                  L"\\node\\#\\view\\#", &spViewStorage);
            if (sc)
                return sc;

            // enumerate what's inside a view storage

            IEnumSTATSTGPtr spViewEnum;
            sc = spViewStorage->EnumElements( 0, NULL, 0, &spViewEnum );
            if (sc)
                return sc;

            // recheck pointer
            sc = ScCheckPointers( spViewEnum, E_POINTER );
            if (sc)
                return sc;

            // reset enumeration
            sc = spViewEnum->Reset();
            if (sc)
                return sc;

            // enumerate the items ( each entry is for separate component in a view )
            while (1)
            {
                STATSTG statstg;
                ZeroMemory( &statstg, sizeof(statstg) );

                ULONG cbFetched = 0;
                sc = spViewEnum->Next( 1, &statstg, &cbFetched );
                if (sc)
                    return sc;

                if ( sc != S_OK ) // - done
                {
                    sc.Clear();
                    break;
                }

                // attach to the out param
                CCoTaskMemPtr<WCHAR> spName( statstg.pwcsName );

                // make a copy of streams and storages
                if ( statstg.type == STGTY_STREAM )
                {
                    IStreamPtr spStream;
                    sc = OpenDebugStream(spViewStorage, spName, STGM_READ | STGM_SHARE_EXCLUSIVE,
                                         L"\\node\\#\\view\\#\\clsid", &spStream);
                    if (sc)
                        return sc;

                    sc = m_ComponentPersistor.ScInitIStream( idView, spName, spStream );
                    if (sc)
                        return sc;
                }
                else if ( statstg.type == STGTY_STORAGE )
                {
                    IStoragePtr spStorage;
                    sc = OpenDebugStorage(spViewStorage, spName, STGM_READ | STGM_SHARE_EXCLUSIVE,
                                          L"\\node\\#\\view\\#\\clsid", &spStorage);
                    if (sc)
                        return sc;

                    sc = m_ComponentPersistor.ScInitIStorage( idView, spName, spStorage );
                    if (sc)
                        return sc;
                }
            }
        }
    }

    // by now we should have loaded everything from the console file
    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScSaveIComponentDatas
 *
 * PURPOSE: Saves IComponentDatass for all snapins under this static scope node
 *
 * PARAMETERS:
 *
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScSaveIComponentDatas( )
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScSaveIComponentDatas"));

    // if node is not initialized ( not expanded ) - nothing to save
    // old data will be persisted.
    if ( !IsInitialized() )
        return sc;

    // go for every component data we have
    for( int i = 0; i< GetNumberOfComponentDatas(); i++ )
    {
        CComponentData* pCD = GetComponentData(i);
        sc = ScCheckPointers(pCD, E_UNEXPECTED);
        if (sc)
            return sc;

        sc = ScSaveIComponentData( pCD );
        if (sc)
            return sc;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScSaveIComponentData
 *
 * PURPOSE: Determines snapin's IComponentData persistence capabilities (QI for IPersistXXXX)
 *          And asks it to save giving maintained stream/storage as a media.
 *
 * PARAMETERS:
 *    CComponentData* pCD   [in]  component data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScSaveIComponentData( CComponentData* pCD )
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScSaveIComponentData"));

    sc = ScCheckPointers(pCD);
    if (sc)
        return sc;

    // check if the component is initialized
    if ( !pCD->IsIComponentDataInitialized() )
    {
        // compatibility with mmc1.2 - give another chance.
        sc = ScInitIComponentData(pCD);
        if (sc)
            return sc;
    }

    // Check first for an IComponentData
    IComponentData* const pICCD = pCD->GetIComponentData();
    sc = ScCheckPointers( pICCD, E_UNEXPECTED );
    if (sc)
        return sc;

    // Get the snapin name for the error message.
	CSnapInPtr spSnapin = pCD->GetSnapIn();

    // now ask the snapin to save the data
    sc = ScAskSnapinToSaveData( pICCD, &m_CDPersistor, CDPersistor::VIEW_ID_DOCUMENT, pCD->GetCLSID(), spSnapin );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScSaveIComponents
 *
 * PURPOSE: Saves IComponents for all snapins under this static scope node
 *
 * PARAMETERS:
 *
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScSaveIComponents( )
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScSaveIComponents"));

    // if node is not initialized ( not expanded ) - nothing to save
    // old data will be persisted.
    if ( !IsInitialized() )
        return sc;

    // go for every CNode in every view
    CNodeList& nodes = GetNodeList();
    POSITION pos = nodes.GetHeadPosition();

    while (pos)
    {
        CNode* pNode = nodes.GetNext( pos );
        sc = ScCheckPointers( pNode, E_UNEXPECTED );
        if (sc)
            return sc;

        CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(pNode);
        sc = ScCheckPointers(pSINode, E_UNEXPECTED);
        if (sc)
            return sc;

        const int viewID = pNode->GetViewID();
        const CComponentArray& components = pSINode->GetComponentArray();
        const int size = components.size();

        for (int i = 0; i < size; i++)
        {
            CComponent* pCC = components[i];
            if ( pCC != NULL )
            {
                sc = ScSaveIComponent( pCC, viewID);
                if (sc)
                    return sc;
            }
        }
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScSaveIComponent
 *
 * PURPOSE: Determines snapin's IComponent persistence capabilities (QI for IPersistXXXX)
 *          And asks it to save giving maintained stream/storage as a media.
 *
 * PARAMETERS:
 *    CComponent* pCComponent [in] component
 *    int viewID              [in] view id for which the component is created
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScSaveIComponent( CComponent* pCComponent, int viewID )
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScSaveIComponent"));

    // parameter check
    sc = ScCheckPointers( pCComponent );
    if (sc)
        return sc;

    const CLSID& clsid = pCComponent->GetCLSID();

    // check if the component is initialized (compatibility with mmc 1.2)
    // give another chance to load
    if ( !pCComponent->IsIComponentInitialized() )
    {
        sc = ScInitIComponent(pCComponent, viewID);
        if (sc)
            return sc;
    }

    // get IComponent
    IComponent* pComponent = pCComponent->GetIComponent();
    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get the snapin to get name for the error message.
	CSnapInPtr spSnapin = pCComponent->GetSnapIn();

    // now ask the snapin to save the data
    sc = ScAskSnapinToSaveData( pComponent, &m_ComponentPersistor, viewID, clsid, spSnapin );
    if (sc)
        return sc;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScAskSnapinToSaveData
 *
 * PURPOSE: Determines snapin persistence capabilities (QI for IPersistXXXX)
 *          And asks it to save giving maintained stream/storage as a media.
 *          This method is called to save both Components and ComponentDatas
 *
 * PARAMETERS:
 *    IUnknown *pSnapin         [in] snapin which data needs to be saved
 *    CMTSnapinNodeStreamsAndStorages *pStreamsAndStorages
 *                              [in] collection of streams/storage where to save
 *    int idView                [in] view id - key for saved data
 *    const CLSID& clsid        [in] class id - key for saved data
 *    CSnapIn *pCSnapin         [in] pointer to CSnapin, used for display name on error
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScAskSnapinToSaveData( IUnknown *pSnapin,
                                        CMTSnapinNodeStreamsAndStorages *pStreamsAndStorages,
                                        int idView , const CLSID& clsid, CSnapIn *pCSnapin )
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScAskSnapinToSaveData"));

    sc = ScCheckPointers( pSnapin, pStreamsAndStorages );
    if (sc)
        return sc;

    IPersistStreamPtr spIPS;
    IPersistStoragePtr spIPStg;
    IPersistStreamInitPtr spIPSI;

    // QI for IPersistStream
    if ( (spIPS = pSnapin) != NULL)
    {
        // get the object for persistence
        CXML_IStream *pXMLStream = NULL;
        sc = pStreamsAndStorages->ScGetXmlStream( idView, clsid, pXMLStream );
        if (sc)
            return sc;

        // recheck the pointer
        sc = ScCheckPointers( pXMLStream, E_UNEXPECTED );
        if (sc)
            return sc;

        // save data to stream
        sc = pXMLStream->ScRequestSave( spIPS.GetInterfacePtr() );
        if (sc)
            goto DisplaySnapinError;
    }
    else if ( (spIPSI = pSnapin) != NULL) // QI for IPersistStreamInit
    {
        // get the object for persistence
        CXML_IStream *pXMLStream = NULL;
        sc = pStreamsAndStorages->ScGetXmlStream( idView, clsid, pXMLStream );
        if (sc)
            return sc;

        // recheck the pointer
        sc = ScCheckPointers( pXMLStream, E_UNEXPECTED );
        if (sc)
            return sc;

        // save data to stream
        sc = pXMLStream->ScRequestSave( spIPSI.GetInterfacePtr() );
        if (sc)
            goto DisplaySnapinError;
    }
    else if ( (spIPStg = pSnapin) != NULL) // QI for IPersistStorage
    {
        // get the object for persistence
        CXML_IStorage *pXMLStorage = NULL;
        sc = pStreamsAndStorages->ScGetXmlStorage( idView, clsid, pXMLStorage );
        if (sc)
            return sc;

        // recheck the pointer
        sc = ScCheckPointers( pXMLStorage, E_UNEXPECTED );
        if (sc)
            return sc;

        // save data to storage
        sc = pXMLStorage->ScRequestSave( spIPStg.GetInterfacePtr() );
        if (sc)
            goto DisplaySnapinError;
    }

   return sc;

// display snapin failure
DisplaySnapinError:

    // need to inform the world...

    CStr strMessage;
    strMessage.LoadString(GetStringModule(), IDS_SNAPIN_SAVE_FAILED);

	if (pCSnapin != NULL)
	{
		WTL::CString strName;
		if (!pCSnapin->ScGetSnapInName(strName).IsError())
		{
			strMessage += _T("\n");
			strMessage += strName;
			strMessage += _T(".");
		}
	}

    ::MessageBox(NULL, strMessage, _T("Error"), MB_OK | MB_ICONEXCLAMATION);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\mtnode.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       MTNode.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9/13/1996   RaviR   Created
//
//____________________________________________________________________________

#ifndef _MTNODE_H_
#define _MTNODE_H_
#pragma once

#include "refcount.h"       // CRefCountedPtr
#include "xmlimage.h"		// CXMLImageList

#define MMC_SYSTEMROOT_VARIABLE _T("systemroot")
#define MMC_SYSTEMROOT_VARIABLE_PERC _T("%systemroot%")
#define MMC_WINDIR_VARIABLE_PERC _T("%windir%")


///////////////////////////////////////////////////////////////////////////////
// Classes referd to here declared in other local files.

class CSnapIn;          // from SnapIn.h
class CSnapInsCache;    // from SnapIn.h
class CComponent;       // from Node.h
class CNode;            // from Node.h
    class CSnapInNode;      // from Node.h

class CDoc;
class CSPImageCache;    // from ScopImag.h
class CExtensionsCache;
class CPersistor;

class CBookmark;        // from bookmark.h
class CSnapinProperties;    // from siprop.h

///////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

class CComponentData;

class CMTNode;
    class CMTSnapInNode;

///////////////////////////////////////////////////////////////////////////////
// typedefs

typedef CMTNode * PMTNODE;
typedef CTypedPtrList<MMC::CPtrList, CNode*> CNodeList;
typedef CList<HMTNODE, HMTNODE> CHMTNODEList;
typedef CComponentData* PCCOMPONENTDATA;
typedef std::vector<PCCOMPONENTDATA> CComponentDataArray;
typedef CArray<GUID, GUID&> CGuidArray;

HRESULT CreateSnapIn (const CLSID& clsid, IComponentData** ppICD,
                      bool fCreateDummyOnFailure = true);
HRESULT LoadRequiredExtensions(CSnapIn* pSnapIn, IComponentData* pICD, CSnapInsCache* pCache = NULL);
HRESULT AddRequiredExtension(CSnapIn* pSnapIn, CLSID& rcslid);
void    DisplayPolicyErrorMessage(const CLSID& clsid, bool bExtension);


#include "snapinpersistence.h"

//____________________________________________________________________________
//
//  Class:      CComponentData
//____________________________________________________________________________
//

class CComponentData
{
	DECLARE_NOT_COPIABLE   (CComponentData)
	DECLARE_NOT_ASSIGNABLE (CComponentData)

public:
// Constructor & Destructor
    CComponentData(CSnapIn * pSnapIn);
   ~CComponentData();

// Attributes
    void SetComponentID(COMPONENTID nID)
    {
        ASSERT(nID >= 0);
        ASSERT(nID < 1000);
        m_ComponentID = nID;
    }
    void SetIComponentData(IComponentData* pICD) { m_spIComponentData = pICD; }
    BOOL IsInitialized()
    {
        return (m_spIFramePrivate != NULL);
    }
    CSnapIn* GetSnapIn(void) const { return m_spSnapIn; }
    const CLSID& GetCLSID() const { return m_spSnapIn->GetSnapInCLSID(); }
    IComponentData* GetIComponentData(void) const { return m_spIComponentData; }
    IFramePrivate* GetIFramePrivate(void) const { return m_spIFramePrivate; }
    IImageListPrivate* GetIImageListPrivate(void);
    COMPONENTID GetComponentID(void) const { return m_ComponentID; }

    LPUNKNOWN GetUnknownToLoad(void) const { return m_spIComponentData; }

    // IComponentData interface methods
    HRESULT Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    HRESULT QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    HRESULT GetNodeType(MMC_COOKIE cookie, GUID* pGuid);
    HRESULT GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem);

    // IComponentData2 helpers
    SC ScQueryDispatch(MMC_COOKIE, DATA_OBJECT_TYPES type, PPDISPATCH ppScopeNodeObject);

// Operations
    // Initialization
    HRESULT Init(HMTNODE hMTNode);

    void ResetComponentID(COMPONENTID id)
    {
        m_spIFramePrivate->SetComponentID(m_ComponentID = id);
    }

    // loaded from stream/storage; initailized with the new one; or does not need initialization
    bool IsIComponentDataInitialized() 
    { 
        return m_bIComponentDataInitialized; 
    }

    // loaded from stream/storage; initailized with the new one; or does not need initialization
    void SetIComponentDataInitialized()
    { 
        m_bIComponentDataInitialized = true; 
    }

private:
// Implementation
    CSnapInPtr              m_spSnapIn;
    IComponentDataPtr       m_spIComponentData;
    IFramePrivatePtr        m_spIFramePrivate;
    COMPONENTID             m_ComponentID;
    bool                    m_bIComponentDataInitialized;

}; // class CComponentData


/*+-------------------------------------------------------------------------*
 * class CMTNode
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
class CMTNode : public XMLListCollectionBase
{
	DECLARE_NOT_COPIABLE   (CMTNode)
	DECLARE_NOT_ASSIGNABLE (CMTNode)

protected:
    // codes corresponding to legacy node types.
    enum eNodeCodes
    {
        NODE_CODE_SNAPIN     = 1,
        NODE_CODE_FOLDER     = 2,   //  codes 2,3,4 are no longer correspond to
        NODE_CODE_HTML       = 3,   //  MTNode derived classes, but are retained
        NODE_CODE_OCX        = 4,   //  for converting old .msc files
        NODE_CODE_ENUMERATED = 10
    };

public:
    static CMTNode*     FromScopeItem (HSCOPEITEM item);
    static HSCOPEITEM   ToScopeItem   (const CMTNode* pMTNode)  { return (reinterpret_cast<HSCOPEITEM>(pMTNode)); }
    static CMTNode*     FromHandle    (HMTNODE        hMTNode)  { return (reinterpret_cast<CMTNode*>(hMTNode)); }
    static HMTNODE      ToHandle      (const CMTNode* pMTNode)  { return (reinterpret_cast<HMTNODE>(const_cast<CMTNode*>(pMTNode))); }

// Constructor
    CMTNode();

    virtual HRESULT     Init(void);

// Attributes
    virtual BOOL        IsStaticNode() const            {return FALSE;}
    BOOL                IsDynamicNode() const           {return !IsStaticNode();}
    virtual HRESULT     IsExpandable();

    HRESULT             QueryDataObject(DATA_OBJECT_TYPES type, LPDATAOBJECT* ppdtobj);

    // Images
    UINT                GetImage(void)                  { return m_nImage; }
    UINT                GetOpenImage(void)              { return m_nOpenImage; }
    UINT                GetState(void);
    void                SetImage(UINT nImage)           { m_nImage = nImage; }
    void                SetOpenImage(UINT nImage)       { m_nOpenImage = nImage; }

    void                SetState(UINT nState)           { m_nState = nState; }

    void                SetOwnerID(long id)             { m_idOwner = id; }
    long                GetOwnerID(void) const          { return m_idOwner; }
    void                SetPrimaryComponentData(CComponentData* pDI)    { m_pPrimaryComponentData = pDI; }
    CComponentData*     GetPrimaryComponentData() const                 { return m_pPrimaryComponentData; }

    virtual tstring     GetDisplayName();
    virtual void        SetDisplayName(LPCTSTR pszName);

protected:
    tstring             GetCachedDisplayName() const    {return m_strName.str();}
    void                SetCachedDisplayName(LPCTSTR pszName);

public:
    BOOL                IsInitialized()                 { return m_bInit; }
    int                 GetDynExtCLSID ( LPCLSID *ppCLSID );
    void                SetNoPrimaryChildren(BOOL bState = TRUE);
    HRESULT             OnRename(long fRename, LPOLESTR pszNewName);
    SC                  ScQueryDispatch(DATA_OBJECT_TYPES type, PPDISPATCH ppScopeNodeObject);
    HRESULT             AddExtension(LPCLSID lpclsid);

    CSnapIn*            GetPrimarySnapIn(void) const    { return m_pPrimaryComponentData->GetSnapIn(); }
    COMPONENTID         GetPrimaryComponentID();

    CMTSnapInNode*      GetStaticParent(void);
    const CLSID&        GetPrimarySnapInCLSID(void);
    LPARAM              GetUserParam(void) const        { return m_lUserParam; }
    void                SetUserParam(LPARAM lParam)     { m_lUserParam = lParam; }
    HRESULT             GetNodeType(GUID* pGuid);
    SC                  ScGetPropertyFromINodeProperties(LPDATAOBJECT pDataObject, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue);

// Operations
    virtual CNode *     GetNode(CViewData* pViewData,
                           BOOL fRootNode = FALSE);     // Method to create a node  for this Master Node.
    HRESULT             Expand(void);
    HRESULT             Expand (CComponentData*, IDataObject*, BOOL);
    virtual bool        AllowNewWindowFromHere() const  { return (true); }


    // Reference counting methods.
    USHORT AddRef();
    USHORT Release();

    // Tree traversal methods.
    PMTNODE             Next() const                    {return m_pNext;}
    PMTNODE             Prev() const                    {return m_pPrev;}
    PMTNODE             Child() const                   {return m_pChild;}
    PMTNODE             LastChild() const               {return m_pLastChild;}
    PMTNODE             Parent() const                  {return m_pParent;}
    CMTNode *           NextStaticNode();

    //+------------------------------------------------------------------
    // Tree Manipulation methods 
    //
    // ScInsertChild: Inserts pmtn as a child after pmtnInsertAfter 
    // (first child if pmtnInsertAfter is NULL)
    //
    // ScDeleteChild: Deletes child pmtn
    //
    // ScDeleteTrailingChildren: Deletes pmtnFirst and following children
    //---------------------------------------------------------------------
    SC                 ScInsertChild(CMTNode* pmtn, CMTNode* pmtnInsertAfter);
    SC                 ScDeleteChild(CMTNode* pmtn);
    SC                 ScDeleteTrailingChildren(CMTNode* pmtnFirst);

    // Iterators that expand
    PMTNODE             GetNext() const                 {return Next();}
    PMTNODE             GetChild();

    void                CreatePathList(CHMTNODEList& path);
                        // Returns true if the stucture of tree needs to be saved,
                        // or if any of the nodes need to be saved.
                        // Derived classes which want to do more complex IsDirty() testing
                        // may over-ride this function.
    virtual HRESULT     IsDirty();

    HRESULT             InitNew(PersistData*);          // Saves the stream information for later use and sets the dirty flag.
    static SC           ScLoad(PersistData*, CMTNode** ppRootNode); // Creates a new tree structure from the provided storage and returns it in ppRootNode. 

    void                ResetExpandedAtLeastOnce()              {_SetFlag(FLAG_EXPANDED_AT_LEAST_ONCE, FALSE);}
    void                SetExpandedAtLeastOnce()                {_SetFlag(FLAG_EXPANDED_AT_LEAST_ONCE, TRUE);}
    BOOL                WasExpandedAtLeastOnce()                {return _IsFlagSet(FLAG_EXPANDED_AT_LEAST_ONCE);}
    void                SetPropertyPageIsDisplayed(BOOL bSet)   {_SetFlag(FLAG_PROPERTY_PAGE_IS_DISPLAYED, bSet);}
    BOOL                IsPropertyPageDisplayed()               {return _IsFlagSet(FLAG_PROPERTY_PAGE_IS_DISPLAYED);}

    // Flag to monitor if MMCN_REMOVE_CHILDREN was sent to the snapin owning the node
    void                SetRemovingChildren(bool b)             {_SetFlag(FLAG_REMOVING_CHILDREN, b);}
    bool                AreChildrenBeingRemoved();

    // Unique ID helper functions. (Each node will be assigned an unique id
    // within the .msc file.)
    static MTNODEID     GetNextID() throw()             {return m_NextID++;}
    static void         ResetID() throw()               {m_NextID = ROOTNODEID;}
    CMTNode*            Find(MTNODEID id);
    MTNODEID            GetID() const throw()           {return m_ID;}
    void                SetID(MTNODEID key)             {m_ID = key;}

    HRESULT             DestroyElements();              // recursive function
    HRESULT             DoDestroyElements();            // non-recursvie part
                                                        // Deletes any persistence data stored in the current file

    void                SetDirty(bool bIsDirty = true)  {m_bIsDirty = bIsDirty;}
    void                ClearDirty()                    {m_bIsDirty = false;}
    virtual void        NotifyAddedToTree()             {}
    virtual HRESULT     CloseView(int viewID);
    virtual HRESULT     DeleteView(int viewID);
    virtual bool        DoDelete(HWND hwnd)             { return true; }
    virtual void        OnChildrenChanged()             {}

    CMTNode*            GetLastChild();

    virtual CSnapInNode*    FindNode(int nViewID)           { return NULL; }

    // Unique ID for the node instance.
    CBookmark*          GetBookmark();

    virtual void        Reset();

protected:
    virtual ~CMTNode();


    virtual HRESULT     InitNew()                       {return S_OK;}  // Provides the derived nodes the opportunity to initialize the persistent resources.
    virtual SC          ScLoad();
public:
    virtual void        Persist(CPersistor& persistor);     // persists the node
    virtual void        OnNewElement(CPersistor& persistor);
    static void         PersistNewNode(CPersistor &persistor, CMTNode** ppNode);
    DEFINE_XML_TYPE(XML_TAG_MT_NODE);

    static wchar_t*     GetViewStorageName(wchar_t* name, int idView);
    static SC           ScGetComponentStreamName(wchar_t* szName, int cchName, const CLSID& clsid);
    static SC           ScGetComponentStorageName(wchar_t* szName, int cchName, const CLSID& clsid);
    static int          GetViewIdFromStorageName(const wchar_t* name);

protected:
    // Allows the tree to re-attach to a persistence source.
    IStream*            GetTreeStream()                 {return m_spTreeStream;}
    BOOL                GetDirty()                      {return m_bIsDirty;}
    wchar_t*            GetStorageName(wchar_t* name)   {return _ltow(GetID(), name, 36);}

    IStorage*           GetNodeStorage()        {return m_spNodeStorage;}
    IStorage*           GetViewStorage()        {return m_spViewStorage;}
    IStorage*           GetStorageForCD()       {return m_spCDStorage;}
    PersistData*        GetPersistData()        {return m_spPersistData;}
    bool                Loaded()                {return m_bLoaded;}

    bool                AreExtensionsExpanded(void) const { return m_bExtensionsExpanded; }


private: // Helper methods

    // Tree manipulation helpers 
    void                AttachNext(PMTNODE pmn)         {m_pNext = pmn;}
    void                AttachPrev(PMTNODE pmn)         {m_pPrev = pmn;}
    void                AttachChild(PMTNODE pmn)        {m_pChild = pmn;}
    void                AttachLastChild(PMTNODE pmn)    {m_pLastChild = pmn;}
    void                AttachParent(PMTNODE pmn)       {m_pParent = pmn;}

    // Helper for ScLoad(PersistData*, CMTNode**) 
    static SC           ScLoad(PersistData*, CMTNode** ppRootNode, 
                            CMTNode* pParent, CMTNode* pPrev); 

// Implementation
private:
    PMTNODE             m_pNext;
    PMTNODE             m_pPrev;
    PMTNODE             m_pChild; // First Child
    PMTNODE             m_pLastChild;
    PMTNODE             m_pParent;

    std::auto_ptr<CBookmarkEx> m_bookmark;        // For node instance persistance

    PersistDataPtr      m_spPersistData;
    IStoragePtr         m_spNodeStorage;
    IStoragePtr         m_spViewStorage;
    IStoragePtr         m_spCDStorage;
    IStreamPtr          m_spTreeStream;
    bool                m_bIsDirty;

    USHORT              m_cRef;
    USHORT              m_usFlags;  // m_bExpandedAtLeastOnce;
    enum ENUM_FLAGS
    {
        FLAG_EXPANDED_AT_LEAST_ONCE = 0x0001,
        FLAG_PROPERTY_PAGE_IS_DISPLAYED = 0x0002,
        FLAG_REMOVING_CHILDREN = 0x0004,
    };

    void                _SetFlag(ENUM_FLAGS flag, BOOL bSet);
    BOOL                _IsFlagSet(ENUM_FLAGS flag){return ((m_usFlags & flag) == flag);}

    MTNODEID            m_ID;                       // Unique id for this node within the .msc file.
    bool                m_bLoaded;                  // when true, load should be called instead of init new
    static MTNODEID     m_NextID;                   // The last unique identifier given out.

    HRESULT             OpenStorageForNode();       // Opens the storage for this specific instance of a node.
    HRESULT             OpenStorageForView();       // Opens the view storage for this specific instance of a node.
    HRESULT             OpenStorageForCD();         // Opens the view storage for this specific instance of a node.
private:
    HRESULT             OpenTreeStream();           // Opens the stream to be used to contain this nodes data.

    void                SetParent(CMTNode* pParent);// Sets the parent for this and all next nodes.


protected:
    UINT                m_nImage;
    UINT                m_nOpenImage;
    UINT                m_nState;
    CStringTableString  m_strName;  // Display name

protected:
    enum StreamVersionIndicator
    {
        Stream_V0100 = 1,       // MMC 1.0
        Stream_V0110 = 2,       // MMC 1.1

        Stream_CurrentVersion = Stream_V0110,
        VersionedStreamMarker = 0xFFFFFFFF,
    };

private:
    long                m_idOwner;  // One of the SnapIns.
    LPARAM              m_lUserParam;
    CComponentData*     m_pPrimaryComponentData;
    BOOL                m_bInit;
    bool                m_bExtensionsExpanded;
    CGuidArray          m_arrayDynExtCLSID;
    unsigned short      m_usExpandFlags;
    enum ENUM_EXPAND_FLAGS
    {
        FLAG_NO_CHILDREN_FROM_PRIMARY = 0x0001,
        FLAG_NO_NAMESPACE_EXTNS       = 0x0002,
        FLAG_NAMESPACE_EXTNS_CHECKED  = 0x0004
    };

}; // class CMTNode


/*+-------------------------------------------------------------------------*
 * class ViewRootStorage
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
class ViewRootStorage
{
public:
    ViewRootStorage() {}
    ~ViewRootStorage()
    {
        Clear();
    }
    void Initialize(IStorage* pRootStorage)
    {
        ASSERT(m_spRootStorage == NULL);
        ASSERT(pRootStorage != NULL);
        m_spRootStorage = pRootStorage;
    }
    IStorage* GetRootStorage()
    {
        return m_spRootStorage;
    }
    bool Insert(IStorage* pViewStorage, int idView)
    {
        ASSERT(pViewStorage != NULL);
        if ( NULL == m_Views.Find(idView))
        {
            return m_Views.Insert(IStoragePtr(pViewStorage), idView);
        }
        return true;
    }
    bool Remove(int idView)
    {
        const bool bRemoved = m_Views.Remove(idView);
        return bRemoved;
    }
    IStorage* FindViewStorage(int idView) const
    {
        CAdapt<IStoragePtr> *pspStorage = m_Views.Find(idView);
        return (pspStorage ? pspStorage->m_T : NULL);
    }
    void Clear()
    {
        m_Views.Clear();
        m_spRootStorage = NULL;
    }
private:
    // CAdapt is used to hide operator&() - which will be invoked by map 
    // implementation to get address of the element.
    // Smart pointer's operator&() releases reference plus returns wrong type for a map.
    Map<CAdapt<IStoragePtr>, int> m_Views;
    IStoragePtr m_spRootStorage;
}; // class ViewRootStorage


/*+-------------------------------------------------------------------------*
 * class CMTSnapInNode
 *
 *
 * PURPOSE: The root node of a primary snap-in. Added to the console and
 *          the scope tree by MMC. Only a snap-in that is added from the
 *          Add/Remove snapin page of the Snapin manager has a static node;
 *          extensions of any type do not.
 *
 *+-------------------------------------------------------------------------*/

class CMTSnapInNode : public CMTNode, public CTiedObject
{
	DECLARE_NOT_COPIABLE   (CMTSnapInNode)
	DECLARE_NOT_ASSIGNABLE (CMTSnapInNode)

public:
// Constructor & Destructor
    CMTSnapInNode(Properties* pProps);
   ~CMTSnapInNode();


    // SnapIn object model methods
public:
    SC ScGetSnapIn(PPSNAPIN ppSnapIn);

    SC Scget_Name(       PBSTR      pbstrName);
    SC Scget_Extensions( PPEXTENSIONS  ppExtensions);
    SC Scget_SnapinCLSID(PBSTR      pbstrSnapinCLSID);
    SC Scget_Properties( PPPROPERTIES ppProperties);
    SC ScEnableAllExtensions (BOOL bEnable);

    // helper for CMMCSnapIn
    SC ScGetSnapinClsid(CLSID& clsid);

    static SC ScGetCMTSnapinNode(PSNAPIN pSnapIn, CMTSnapInNode **ppMTSnapInNode);


public:
// Attributes
    virtual BOOL IsStaticNode() const { return TRUE; }
    UINT GetResultImage(CNode* pNode, IImageListPrivate* pImageList);
    void SetResultImage(UINT index) { m_resultImage = index; }
    void SetPrimarySnapIn(CSnapIn * pSI);
    CNodeList& GetNodeList(void) { return m_NodeList; }
    virtual HRESULT IsExpandable();

// Operations
    // Initialize


    virtual HRESULT Init(void);

    // Create a node  for this master node.
    virtual CNode * GetNode(CViewData* pViewData, BOOL fRootNode = FALSE);

    virtual tstring GetDisplayName();
    virtual void    SetDisplayName(LPCTSTR pszName);


    void AddNode(CNode * pNode);
    void RemoveNode(CNode * pNode);
    virtual CSnapInNode* FindNode(int nViewID);

    int GetNumberOfComponentDatas() { return m_ComponentDataArray.size(); }
    COMPONENTID AddComponentDataToArray(CComponentData* pCCD);
    CComponentData* GetComponentData(const CLSID& clsid);
    CComponentData* GetComponentData(COMPONENTID nID);
    CComponent* GetComponent(UINT nViewID, COMPONENTID nID, CSnapIn* pSnapIn);

    virtual HRESULT CloseView(int viewID);
    virtual HRESULT DeleteView(int viewID);

    // Loads from existing stream/storage or initializes with the new one
    SC   ScInitIComponentData( CComponentData* pCD );
    SC   ScInitIComponent(CComponent* pComponent, int viewID);

    virtual void Reset();
    void CompressComponentDataArray();
    BOOL IsPreloadRequired () const;
    void SetPreloadRequired (bool bPreload) { m_ePreloadState = (bPreload) ? ePreload_True : ePreload_False;}

    SC   ScConvertLegacyNode(const CLSID &clsid);

// Implementation
protected:
//    virtual HRESULT InitNew();
    virtual HRESULT IsDirty();
    virtual SC      ScLoad();
    virtual void    Persist(CPersistor& persistor);

private:
    SC ScInitProperties();
    SC ScCreateSnapinProperties(CSnapinProperties** ppSIProps);
	SC ScAddImagesToImageList();

    SC ScReadStreamsAndStoragesFromConsole();
    // Loads from existing sream/storage of initializes with the new one.
    SC ScInitComponentOrComponentData( IUnknown *pSnapin, CMTSnapinNodeStreamsAndStorages *pStreamsAndStorages,
                                       int idView , const CLSID& clsid );
private:
    enum PersistType
    {
        PT_None,
        PT_IStream,
        PT_IStreamInit,
        PT_IStorage
    };

	enum PreloadState
	{
		ePreload_Unknown = -1,		// don't know if MMCN_PRELOAD is required yet
		ePreload_False   =  0,		// MMCN_PRELOAD not required
		ePreload_True    =  1,		// MMCN_PRELOAD required
	};

	SC ScQueryPreloadRequired (PreloadState& ePreload) const;

    SC ScHandleCustomImages (const CLSID& clsidSnapin);
    SC ScHandleCustomImages (HBITMAP hbmSmall, HBITMAP hbmSmallOpen, HBITMAP hbmLarge, COLORREF crMask);

    HRESULT AreIComponentDatasDirty();
    HRESULT AreIComponentsDirty();
    HRESULT IsIUnknownDirty(IUnknown* pUnk);

    SC ScSaveIComponentDatas();
    SC ScSaveIComponentData( CComponentData* pCD );
    SC ScSaveIComponents();
    SC ScSaveIComponent( CComponent* pCComponent, int viewID );
    SC ScAskSnapinToSaveData( IUnknown *pSnapin, CMTSnapinNodeStreamsAndStorages *pStreamsAndStorages, 
                              int idView , const CLSID& clsid, CSnapIn *pCSnapin );

private:
    PropertiesPtr       m_spProps;
    SnapInPtr           m_spSnapIn;

    CComponentDataArray m_ComponentDataArray;
    CNodeList           m_NodeList;
    ViewRootStorage     m_ComponentStorage;

	CXMLImageList		m_imlSmall;			// small, open images
	CXMLImageList		m_imlLarge;			// large image

    UINT                m_resultImage;
    CDPersistor         m_CDPersistor;
    CComponentPersistor m_ComponentPersistor;

	mutable PreloadState m_ePreloadState;
    BOOL                m_bHasBitmaps;
    bool                m_fCallbackForDisplayName;  // snap-in gave us MMC_TEXTCALLBACK for node name?

}; // class CMTSnapInNode


#include "mtnode.inl"

#endif // _MTNODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\mtnode.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      mtnode.inl
 *
 *  Contents:
 *
 *  History:   8-Mar-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

//_____________________________________________________________________________
//
//  Inlines for class:  CMTNode
//_____________________________________________________________________________
//

inline USHORT CMTNode::AddRef()
{
    return (++m_cRef);
}

inline USHORT CMTNode::Release()
{
    // Note: The return value from this is important
    // as a return value of zero is interpreted as
    // object destroyed.

    ASSERT(m_cRef > 0);
    --m_cRef;
    if (m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

inline PMTNODE CMTNode::GetChild()
{
    if (!WasExpandedAtLeastOnce())
        Expand();

    return Child();
}

inline CMTSnapInNode* CMTNode::GetStaticParent(void)
{
    CMTNode* p = this;

    while (!p->IsStaticNode())
        p = p->Parent();

    ASSERT(p != NULL);
    CMTSnapInNode* pMTSnapInNode = dynamic_cast<CMTSnapInNode*>(p);
    ASSERT (pMTSnapInNode != NULL);

    return pMTSnapInNode;
}


inline void CMTNode::CreatePathList(CHMTNODEList& path)
{
    CMTNode* pMTNode = this;

    for (; pMTNode != NULL; pMTNode = pMTNode->Parent())
        path.AddHead(ToHandle(pMTNode));
}


inline CMTNode* CMTNode::Find(MTNODEID id)
{
	CMTNode* pStartNode = this; // this is to avoid traversing the tree above the initial node passed
	CMTNode* pNode = this;

	while ( pNode->GetID() != id )
	{
		if ( NULL != pNode->Child() )
		{
			// dive down to the lowest child
			pNode = pNode->Child();
		}
		else 
		{
			// get to the next sub-branch 
			// ( but first - climb up till you get to the junction )
			while ( NULL == pNode->Next() )
			{
				pNode = pNode->Parent();
				// if there are no more nodes - we are done ( search failed )
				// ... or if we looked thru all children and siblings [ this
				// mostly for compatibility - CMTNode::Find is never used else than
				// from topmost node].
				if ( (NULL == pNode) || (pNode == pStartNode->Parent()) )
					return NULL;
			}
			pNode = pNode->Next();
		}
	}

	return pNode;
}

inline CMTNode* CMTNode::GetLastChild()
{
    CMTNode* pMTNode = Child();
    if (pMTNode == NULL)
        return NULL;

    while (pMTNode->Next() != NULL)
    {
        pMTNode = pMTNode->Next();
    }

    return pMTNode;
}

inline wchar_t* CMTNode::GetViewStorageName(wchar_t* name, int idView)
{
    ASSERT(name != NULL);
    _ltow(idView, name, 36);
    return name;
}

/***************************************************************************\
 *
 * METHOD:  CMTNode::GetViewIdFromStorageName
 *
 * PURPOSE: function reconstructs view id from the component storage name
 *          in structured storage based console. This is opposit to what
 *          GetViewStorageName [above] does.
 *
 * PARAMETERS:
 *    const wchar_t* name [in] name of storage element
 *
 * RETURNS:
 *    int    - view id
 *
\***************************************************************************/
inline int CMTNode::GetViewIdFromStorageName(const wchar_t* name)
{
    ASSERT(name != NULL);
    if (name == NULL)
        return 0;
    
    wchar_t *stop = NULL;
    return wcstol( name, &stop, 36/*base*/ );
}

inline SC CMTNode::ScGetComponentStreamName(wchar_t* szName, int cchName, const CLSID& clsid)
{
    DECLARE_SC(sc, TEXT("CMTNode::ScGetComponentStreamName"));
    sc = ScCheckPointers(szName, &clsid);
    if(sc)
        return sc;

    // the return value is ALWAYS less than 40 characters (even if we use base 10). Expect the buffer to 
    // be conservatively at least that long.
    if(cchName < 40)
        return (sc = E_INVALIDARG).ToHr();

    wchar_t* pName = szName;
    const long* pl = reinterpret_cast<const long*>(&clsid);
    for (int i = 0; i < 4; i++)
    {
        _ltow(*pl++, pName, 36);
        pName += wcslen(pName);
    }

    return sc;
}

inline SC CMTNode::ScGetComponentStorageName(wchar_t* szName, int cchName, const CLSID& clsid)
{
    return ScGetComponentStreamName(szName, cchName, clsid);
}


inline void CMTNode::_SetFlag(ENUM_FLAGS flag, BOOL bSet)
{
    ASSERT((flag & (flag-1)) == 0);
    if (bSet == TRUE)
        m_usFlags |= flag;
    else
        m_usFlags &= ~flag;
}

inline const CLSID& CMTNode::GetPrimarySnapInCLSID(void)
{
    if (m_pPrimaryComponentData == NULL)
        return (GUID_NULL);

    CSnapIn* const pSnapIn = m_pPrimaryComponentData->GetSnapIn();
    if (pSnapIn == NULL)
        return (GUID_NULL);

    return pSnapIn->GetSnapInCLSID();
}

inline HRESULT CMTNode::GetNodeType(GUID* pGuid)
{
    HRESULT hr = m_pPrimaryComponentData->GetNodeType(GetUserParam(), pGuid);
    CHECK_HRESULT(hr);
    return hr;
}

inline HRESULT CMTNode::OnRename(long fRename, LPOLESTR pszNewName)
{
    IDataObjectPtr spDataObject;
    HRESULT hr = QueryDataObject(CCT_SCOPE, &spDataObject);
    if (FAILED(hr))
        return hr;

    hr = m_pPrimaryComponentData->Notify(spDataObject,
                  MMCN_RENAME, fRename, reinterpret_cast<LPARAM>(pszNewName));
    CHECK_HRESULT(hr);
    return hr;
}

inline HRESULT CMTNode::QueryDataObject(DATA_OBJECT_TYPES type,
                                                LPDATAOBJECT* ppdtobj)
{
    if (ppdtobj == NULL)
        return (E_INVALIDARG);

    *ppdtobj = NULL; // init

    CMTSnapInNode* pMTSINode = GetStaticParent();
    CComponentData* pCCD = pMTSINode->GetComponentData(GetPrimarySnapInCLSID());
    if (pCCD == NULL)
        return E_FAIL;

    HRESULT hr = pCCD->QueryDataObject(GetUserParam(),
                                       type, ppdtobj);
    CHECK_HRESULT(hr);
    return hr;
}

inline COMPONENTID CMTNode::GetPrimaryComponentID()
{
    return m_pPrimaryComponentData->GetComponentID();
}

inline int CMTNode::GetDynExtCLSID ( LPCLSID *ppCLSID )
{
    ASSERT(ppCLSID != NULL);
    *ppCLSID = m_arrayDynExtCLSID.GetData();
    return m_arrayDynExtCLSID.GetSize();
}

inline void CMTNode::SetNoPrimaryChildren(BOOL bState)
{
    if (bState)
        m_usExpandFlags |= FLAG_NO_CHILDREN_FROM_PRIMARY;
    else
        m_usExpandFlags &= ~FLAG_NO_CHILDREN_FROM_PRIMARY;
}



//____________________________________________________________________________
//
//  Class:      CComponentData Inlines
//____________________________________________________________________________
//

inline HRESULT CComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
	DECLARE_SC (sc, _T("CComponentData::QueryDataObject"));
	sc = ScCheckPointers (m_spIComponentData, E_FAIL);
	if (sc)
		return (sc.ToHr());

    ASSERT(type != CCT_RESULT);
    return ((sc = m_spIComponentData->QueryDataObject(cookie, type, ppDataObject)).ToHr());
}

inline HRESULT CComponentData::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
	DECLARE_SC (sc, _T("CComponentData::GetDisplayInfo"));
	sc = ScCheckPointers (m_spIComponentData, E_FAIL);
	if (sc)
		return (sc.ToHr());

    return ((sc = m_spIComponentData->GetDisplayInfo(pScopeDataItem)).ToHr());
}

inline HRESULT CComponentData::GetNodeType(MMC_COOKIE cookie, GUID* pGuid)
{
    IDataObjectPtr spdtobj;
    HRESULT hr = QueryDataObject(cookie, CCT_SCOPE, &spdtobj);
    if (SUCCEEDED(hr))
        hr = ExtractObjectTypeGUID(spdtobj, pGuid);

    return hr;
}


//____________________________________________________________________________
//
//  Class:      CMTSnapInNode Inlines
//____________________________________________________________________________
//

inline CComponentData* CMTSnapInNode::GetComponentData(const CLSID& clsid)
{
    for (int i=0; i < m_ComponentDataArray.size(); i++)
    {
        if (m_ComponentDataArray[i] != NULL &&
            IsEqualCLSID(clsid, m_ComponentDataArray[i]->GetCLSID()) == TRUE)
            return m_ComponentDataArray[i];
    }
    return NULL;
}

inline CComponentData* CMTSnapInNode::GetComponentData(COMPONENTID nID)
{
    if (nID < m_ComponentDataArray.size())
        return m_ComponentDataArray[nID];

    return NULL;
}

inline COMPONENTID CMTSnapInNode::AddComponentDataToArray(CComponentData* pCCD)
{
    m_ComponentDataArray.push_back(pCCD);
    int nID = m_ComponentDataArray.size() -1;
    pCCD->SetComponentID(nID);
    return nID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\multisel.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       multisel.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6/12/1997   RaviR   Created
//____________________________________________________________________________
//


#ifndef _MULTISEL_H_
#define _MULTISEL_H_

class CSnapIn;
class CNode;
class CSnapInNode;
class CMTSnapInNode;
class CMultiSelection;
class CComponent;
class CComponentPtrArray;
class CScopeTree;
class CMMCClipBoardDataObject;

// local classes
class CSnapinSelData;
class CSnapinSelDataList;
class CMultiSelectDataObject;


class CSnapinSelData
{
public:
    CSnapinSelData()
    :   m_nNumOfItems(0),
        m_lCookie(111),   // 0)
        m_bScopeItem(FALSE),
        m_ID(-1),
        m_pComponent(NULL),
        m_pSnapIn(NULL)
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapinSelData);
    }

    ~CSnapinSelData()
    {
        DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinSelData);
    }

    UINT GetNumOfItems() const
    {
        return m_nNumOfItems;
    }

    MMC_COOKIE GetCookie() const
    {
        return m_lCookie;
    }

    BOOL IsScopeItem() const
    {
        return m_bScopeItem;
    }

    void IncrementNumOfItems()
    {
        ++m_nNumOfItems;
    }

    void SetNumOfItems(UINT count)
    {
        m_nNumOfItems = count;
    }

    void SetCookie(MMC_COOKIE lCookie)
    {
        m_lCookie = lCookie;
    }

    void SetIsScopeItem(BOOL bScopeItem)
    {
        m_bScopeItem = bScopeItem;
    }

    void AddObjectType(GUID& guid)
    {
        m_objectTypeGuidList.AddHead(guid);
    }

    CList<GUID, GUID&>& GetObjectTypeGuidList()
    {
        return m_objectTypeGuidList;
    }

    void SetSnapIn(CSnapIn* pSnapIn)
    {
        m_pSnapIn = pSnapIn;
    }

    CSnapIn* GetSnapIn()
    {
        return m_pSnapIn;
    }

    COMPONENTID GetID()
    {
        return m_ID;
    }

    void SetID(COMPONENTID id)
    {
        m_ID = id;
    }

    void SetDataObject(IDataObject* pDO)
    {
        m_spDataObject = pDO;
    }

    IDataObject* GetDataObject()
    {
        ASSERT(m_spDataObject != NULL);
        return m_spDataObject;
    }

    void SetComponent(CComponent* pComponent)
    {
        ASSERT(m_pComponent == NULL);
        m_pComponent = pComponent;
    }

    CComponent* GetComponent()
    {
        ASSERT(m_pComponent != NULL);
        return m_pComponent;
    }

    void SetConsoleVerb(IConsoleVerb* pConsoleVerb)
    {
        m_spConsoleVerb = pConsoleVerb;
    }

    IConsoleVerb* GetConsoleVerb()
    {
        return m_spConsoleVerb;
    }


    // methods to access array of scope nodes included in multiselection
    // this data is particularly valuable, when data is put on clipboard
    // to be detect if contined data is affected by CNode being deleted
    typedef std::vector<CNode *> CNodePtrArray;

    void AddScopeNodes(const CNodePtrArray& nodes)  { m_vecScopeNodes.insert( m_vecScopeNodes.end(), nodes.begin(), nodes.end() ); }
    const CNodePtrArray& GetScopeNodes()            { return m_vecScopeNodes; }

private:
    UINT                m_nNumOfItems;
    BOOL                m_bScopeItem;
    MMC_COOKIE          m_lCookie;
    COMPONENTID         m_ID;
    CSnapIn*            m_pSnapIn;
    CComponent*         m_pComponent;
    IConsoleVerbPtr     m_spConsoleVerb;
    IDataObjectPtr      m_spDataObject;
    CList<GUID, GUID&>  m_objectTypeGuidList;

    CNodePtrArray        m_vecScopeNodes;

}; // class CSnapinSelData


class CSnapinSelDataList : public CList<CSnapinSelData*, CSnapinSelData*>
{
public:
    CSnapinSelDataList()
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapinSelDataList);
    }

    ~CSnapinSelDataList()
    {
        POSITION pos = GetHeadPosition();
        while (pos)
        {
            delete GetNext(pos);
        }

        DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinSelDataList);
    }

    void Add(CSnapinSelData& snapinSelData, BOOL bStaticNode);
};

class CMultiSelection
{
public:
    CMultiSelection(CNode* pNode);

    void AddRef()
    {
        ++m_cRef;
    }
    void Release()
    {
        ASSERT(m_cRef > 0);
        --m_cRef;
        if (m_cRef == 0)
        {
            ReleaseMultiSelDataObject();
            delete this;
        }
    }

    HRESULT Init();
    HRESULT GetMultiSelDataObject(IDataObject** ppDataObject);
    HRESULT GetExtensionSnapins(LPCTSTR pszExtensionTypeKey,
                                CList<GUID, GUID&>& snapinGuidList);
    bool IsSingleSnapinSelection()
    {
        if (m_rgStaticNodes.size() > 0 || m_snapinSelDataList.GetCount() > 1)
            return false;

        return true;
    }
    IDataObject* GetSingleSnapinSelDataObject()
    {
        if (!IsSingleSnapinSelection())
            return NULL;

        CSnapinSelData* pSnapinSelData = m_snapinSelDataList.GetHead();
        ASSERT(pSnapinSelData != NULL);
        return pSnapinSelData->GetDataObject();
    }
    CComponent* GetPrimarySnapinComponent()
    {
        if (!IsSingleSnapinSelection())
            return NULL;

        CSnapinSelData* pSnapinSelData = m_snapinSelDataList.GetHead();
        return pSnapinSelData->GetComponent();
    }
    BOOL IsAnExtensionSnapIn(const CLSID& rclsid);
    BOOL HasNodes()
    {
        return m_bHasNodes;
    }
    BOOL HasStaticData()
    {
        return (m_rgStaticNodes.size() > 0);
    }
    BOOL HasSnapinData()
    {
        return (m_snapinSelDataList.IsEmpty() == FALSE);
    }
    BOOL HasData()
    {
        if (HasSnapinData() == FALSE)
            return HasStaticData();
        return TRUE;
    }
    void SetScopeTree(CScopeTree* pCScopeTree)
    {
        m_pCScopeTree = pCScopeTree;
    }
    CScopeTree* GetScopeTree()
    {
        ASSERT(m_pCScopeTree != NULL);
        return m_pCScopeTree;
    }
    BOOL IsInUse()
    {
        return m_bInUse;
    }

    SC ScVerbInvoked(MMC_CONSOLE_VERB verb);
    bool RemoveStaticNode(CMTNode* pMTNode);
    void ReleaseMultiSelDataObject()
    {
        m_spDataObjectMultiSel = NULL;
        ASSERT(m_spDataObjectMultiSel == NULL);
    }

    SC ScIsVerbEnabledInclusively(MMC_CONSOLE_VERB mmcVerb, BOOL& bEnable);

    SC ScGetSnapinDataObjects(CMMCClipBoardDataObject *pResultObject);

private:
    DWORD               m_cRef;
    CNode*              m_pNode;
    CSnapInNode*        m_pSINode;
    CMTSnapInNode*      m_pMTSINode;
    CScopeTree*         m_pCScopeTree;

    CSnapinSelDataList  m_snapinSelDataList;
    CMTNodePtrArray     m_rgStaticNodes;
    IDataObjectPtr      m_spDataObjectMultiSel;

    BOOL                m_bHasNodes;
    BOOL                m_bInUse;

    CMTSnapInNode* _GetStaticMasterNode()
    {
        return m_pMTSINode;
    }

    CSnapInNode* _GetStaticNode()
    {
        return m_pSINode;
    }

    void _SetInUse(BOOL b)
    {
        m_bInUse = b;
    }

    SC _ScVerbInvoked(MMC_CONSOLE_VERB verb);
    bool _IsTargetCut();

#ifdef DBG
    BOOL m_bInit;
#endif

    HRESULT _ComputeSelectionDataList();
    CComponent* _GetComponent(CSnapinSelData* pSnapinSelData);
    HRESULT _GetObjectTypeForSingleSel(CSnapinSelData* pSnapinSelData);
    HRESULT _GetObjectTypesForMultipleSel(CSnapinSelData* pSnapinSelData);
    HRESULT _FindSnapinsThatExtendObjectTypes(CSnapinSelDataList& snapinSelDataList,
                                          CList<GUID, GUID&>& snapinGuidList);

    ~CMultiSelection();

}; // class CMultiSelection


class CMultiSelectDataObject : public IDataObject,
                               public CComObjectRoot
{
public:
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CMultiSelectDataObject)
BEGIN_COM_MAP(CMultiSelectDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()


#ifdef DBG
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        int tmp1 = dbg_cRef;
        int tmp2 = tmp1 * 4;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        int tmp1 = dbg_cRef;
        int tmp2 = tmp1 * 4;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG


// Construction/Destruction
    CMultiSelectDataObject() : m_ppDataObjects(NULL), m_count(0),
        m_ppMTNodes(NULL), m_nSize(0), m_pMS(NULL)
    {

#ifdef DBG
dbg_cRef = 0;
#endif
        DEBUG_INCREMENT_INSTANCE_COUNTER(CMultiSelectDataObject);
    }

    ~CMultiSelectDataObject();

    void SetDataObjects(LPDATAOBJECT* ppDataObjects, UINT count)
    {
        if (ppDataObjects != NULL)
        {
            ASSERT(m_ppDataObjects == NULL);
            ASSERT(m_count == 0);
            m_ppDataObjects = ppDataObjects;
            m_count = count;
        }
        else
        {
            ASSERT(count == 0);
            delete [] m_ppDataObjects;
            m_ppDataObjects = NULL;
            m_count = 0;
        }
    }

    void SetStaticNodes(CMTNodePtrArray &rgMTNodes, int nSize)
    {
        typedef CMTNode* _PMTNODE;
        ASSERT(m_ppMTNodes == NULL);
        ASSERT(m_nSize == 0);
        m_ppMTNodes = new _PMTNODE[nSize];
        if(m_ppMTNodes != NULL)
        {
            m_nSize = nSize;
            for(int i=0; i<nSize; i++)
                m_ppMTNodes[i] = rgMTNodes[i];
        }
    }

    void SetMultiSelection(CMultiSelection* pMS)
    {
        ASSERT(pMS != NULL);
        m_pMS = pMS;
        m_pMS->AddRef();
    }
    CMultiSelection* GetMultiSelection()
    {
        ASSERT(m_pMS != NULL);
        return m_pMS;
    }


// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc);

// Not Implemented
    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut) { return E_NOTIMPL; };
    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease) { return E_NOTIMPL; };
    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,LPADVISESINK pAdvSink, LPDWORD pdwConnection) { return E_NOTIMPL; };
    STDMETHOD(DUnadvise)(DWORD dwConnection) { return E_NOTIMPL; };
    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise) { return E_NOTIMPL; }

private:
    LPDATAOBJECT* m_ppDataObjects;
    UINT m_count;

    CMTNode** m_ppMTNodes;
    int m_nSize;

    CMultiSelection* m_pMS; // To be used only for Drag-Drop

}; // class CMultiSelectDataObject


bool IsMultiSelectDataObject(IDataObject* pdtobjCBSelData);

#endif // _MULTISEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\multisel.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       multisel.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "objfmts.h"
#include "multisel.h"
#include "nmutil.h"
#include "regutil.h"
#include "copypast.h"
#include "dbg.h"
#include "rsltitem.h"

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapinSelData);
DEBUG_DECLARE_INSTANCE_COUNTER(CSnapinSelDataList);

UINT GetRelation(CMTNode* pMTNodeSrc, CMTNode* pMTNodeDest);

CLIPFORMAT GetMultiSelectSnapinsCF()
{
    static CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_MULTI_SELECT_SNAPINS));
    }

    return s_cf;
}

CLIPFORMAT GetMultiSelectStaticDataCF()
{
    static CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_MULTI_SELECT_STATIC_DATA));
    }

    return s_cf;
}

CLIPFORMAT GetMultiSelObjectTypesCF()
{
    static CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_OBJECT_TYPES_IN_MULTI_SELECT));
    }

    return s_cf;
}

CLIPFORMAT GetMMCMultiSelDataObjectCF()
{
    static CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_MMC_MULTISELECT_DATAOBJECT));
    }

    return s_cf;
}

CLIPFORMAT GetMMCDynExtensionsCF()
{
    static CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_MMC_DYNAMIC_EXTENSIONS));
    }

    return s_cf;
}

HRESULT
DataObject_GetHGLOBALData(
    IDataObject* piDataObject,
    CLIPFORMAT cfClipFormat,
    HGLOBAL* phGlobal)
{
    ASSERT(piDataObject != NULL);
    ASSERT(phGlobal != NULL);
    if (piDataObject == NULL || phGlobal == NULL)
        return E_INVALIDARG;

    FORMATETC fmt = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgm = {TYMED_HGLOBAL, NULL, NULL};

    HRESULT hr = piDataObject->GetData(&fmt, &stgm);

    if (SUCCEEDED(hr) && (stgm.tymed == TYMED_HGLOBAL) && (stgm.hGlobal != NULL))
    {
        *phGlobal = stgm.hGlobal;
    }
    else
    {
        ReleaseStgMedium(&stgm);
        if (SUCCEEDED(hr))
            hr = (stgm.tymed != TYMED_HGLOBAL) ? DV_E_TYMED : E_UNEXPECTED;
    }

    return hr;
}

DEBUG_DECLARE_INSTANCE_COUNTER(CMultiSelectDataObject);

CMultiSelectDataObject::~CMultiSelectDataObject()
{
    if (m_pMS)
        m_pMS->Release();

    if (m_ppDataObjects != NULL)
    {
        delete [] m_ppDataObjects;
    }

    DEBUG_DECREMENT_INSTANCE_COUNTER(CMultiSelectDataObject);
}

STDMETHODIMP
CMultiSelectDataObject::GetData(
    FORMATETC*  pfmt,
    STGMEDIUM*  pmedium)
{
    if (m_ppDataObjects == NULL && m_ppMTNodes == NULL)
        return HRESULT_FROM_WIN32(ERROR_TIMEOUT);

    pmedium->hGlobal = NULL; // init

    if (pfmt->tymed & TYMED_HGLOBAL)
    {
        if (pfmt->cfFormat == GetMultiSelectSnapinsCF())
        {
            // UINT size = sizeof(DWORD) + m_count * sizeof(LPDATAOBJECT);
            // Windows bug 662181: On IA64 there are 4 bytes of padding after the DWORD. 
            // Changed to  the platform-independent expression below.
            UINT size = sizeof(SMMCDataObjects) + m_count * sizeof(LPDATAOBJECT) - sizeof(LPDATAOBJECT);
            pmedium->hGlobal = ::GlobalAlloc(GPTR, size);
            SMMCDataObjects* pData =
                reinterpret_cast<SMMCDataObjects*>(pmedium->hGlobal);
            if (pData == NULL)
                return E_OUTOFMEMORY;

            pData->count = m_count;
            for (UINT i=0; i<m_count; ++i)
            {
                pData->lpDataObject[i] = m_ppDataObjects[i];
            }
        }
        else if (pfmt->cfFormat == GetMultiSelectStaticDataCF())
        {
            ASSERT(m_nSize >= 0);
            typedef CMTNode* _PMTNODE;

            // m_ppDataObjects  m_count
            UINT cb = sizeof(DWORD) + sizeof(_PMTNODE) * m_nSize;
            pmedium->hGlobal = ::GlobalAlloc(GPTR, cb);

            BYTE* pb = reinterpret_cast<BYTE*>(pmedium->hGlobal);
            if (pb == NULL)
                return E_OUTOFMEMORY;

            *((DWORD*)pb) = m_nSize;

            if (m_nSize > 0)
            {
                pb += sizeof(DWORD);
                _PMTNODE* ppMTNodes = (_PMTNODE*)pb;
                CopyMemory(ppMTNodes, m_ppMTNodes, m_nSize * sizeof(_PMTNODE));
            }
        }
        else if (pfmt->cfFormat == GetMMCMultiSelDataObjectCF())
        {
            pmedium->hGlobal = ::GlobalAlloc(GPTR, sizeof(DWORD));
            if (pmedium->hGlobal == NULL)
                return E_OUTOFMEMORY;

            *((DWORD*)pmedium->hGlobal) = 1;
        }
        else
        {
            pmedium->tymed = TYMED_NULL;
            pmedium->hGlobal = NULL;
            pmedium->pUnkForRelease = NULL;

            return DATA_E_FORMATETC;
        }

        if (pmedium->hGlobal != NULL)
        {
            pmedium->tymed          = TYMED_HGLOBAL;
            pmedium->pUnkForRelease = NULL;

            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    return DV_E_TYMED;
}

STDMETHODIMP
CMultiSelectDataObject::GetDataHere(
    FORMATETC*  pfmt,
    STGMEDIUM*  pmedium)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CMultiSelectDataObject::EnumFormatEtc(
    DWORD dwDirection,
    IEnumFORMATETC **ppenumFormatEtc)
{
    if (m_ppDataObjects == NULL && m_ppMTNodes == NULL)
        return HRESULT_FROM_WIN32(ERROR_TIMEOUT);

    if (dwDirection == DATADIR_SET)
        return E_FAIL;

    FORMATETC fmte[] = {
        {GetMultiSelectSnapinsCF(), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {GetMMCMultiSelDataObjectCF(), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    };

    HRESULT hr = ::GetObjFormats(countof(fmte), fmte, (void**)ppenumFormatEtc);

    return hr;
}

STDMETHODIMP CMultiSelectDataObject::QueryGetData(LPFORMATETC pfmt)
{
    if (m_ppDataObjects == NULL && m_ppMTNodes == NULL)
        return HRESULT_FROM_WIN32(ERROR_TIMEOUT);

    //
    //  Check the aspects we support.
    //

    if (!(DVASPECT_CONTENT & pfmt->dwAspect))
        return DATA_E_FORMATETC;

    ASSERT(GetMultiSelectSnapinsCF() != 0);

    if (pfmt->cfFormat == GetMMCMultiSelDataObjectCF() ||
        pfmt->cfFormat == GetMultiSelectSnapinsCF())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


void CSnapinSelDataList::Add(CSnapinSelData& snapinSelData, BOOL bStaticNode)
{
    BOOL bCreateNew = TRUE;

    if (bStaticNode == FALSE &&
        snapinSelData.GetID() != TVOWNED_MAGICWORD)
    {
        POSITION pos = GetHeadPosition();

        while (pos)
        {
            CSnapinSelData* pSnapinSelData = GetNext(pos);
            if (pSnapinSelData->GetID() == snapinSelData.GetID())
            {
                pSnapinSelData->IncrementNumOfItems();
                pSnapinSelData->AddScopeNodes( snapinSelData.GetScopeNodes() );
                bCreateNew = FALSE;
                break;
            }
        }
    }

    if (bCreateNew == TRUE)
    {
        CSnapinSelData* pSnapinSelData = new CSnapinSelData;
        pSnapinSelData->SetNumOfItems(snapinSelData.GetNumOfItems());
        pSnapinSelData->AddScopeNodes(snapinSelData.GetScopeNodes());
        pSnapinSelData->SetIsScopeItem(snapinSelData.IsScopeItem());
        pSnapinSelData->SetCookie(snapinSelData.GetCookie());
        pSnapinSelData->SetID(snapinSelData.GetID());
        pSnapinSelData->SetSnapIn(snapinSelData.GetSnapIn());

        AddHead(pSnapinSelData);
    }
}


DEBUG_DECLARE_INSTANCE_COUNTER(CMultiSelection);

CMultiSelection::CMultiSelection(CNode* pNode)
    :   m_pNode(pNode), m_pMTSINode(NULL), m_bHasNodes(FALSE),
        m_pSINode(dynamic_cast<CSnapInNode*>(pNode)),
        m_bInUse(FALSE), m_cRef(1)
{
    ASSERT(pNode != NULL);

#ifdef DBG
    m_bInit = FALSE;
#endif

    DEBUG_INCREMENT_INSTANCE_COUNTER(CMultiSelection);
}

CMultiSelection::~CMultiSelection()
{
    ASSERT(m_bInUse == FALSE);

    if (m_spDataObjectMultiSel != NULL)
    {
        CMultiSelectDataObject* pObj =
            dynamic_cast<CMultiSelectDataObject*>(
                static_cast<IDataObject*>(m_spDataObjectMultiSel));
        ASSERT(pObj != NULL);
        if (pObj)
            pObj->SetDataObjects(NULL, 0);
    }

    DEBUG_DECREMENT_INSTANCE_COUNTER(CMultiSelection);
}

HRESULT CMultiSelection::Init()
{
#ifdef DBG
    m_bInit = TRUE;
#endif
    // compute m_pSINode, m_pMTSINode, m_pszExtensionTypeKey

    if (m_pNode != NULL)
    {
        if (m_pSINode == NULL)
            m_pSINode = m_pNode->GetStaticParent();

        ASSERT(m_pMTSINode == NULL);
        ASSERT(m_pNode->GetMTNode() != NULL);
        if (m_pNode->GetMTNode() == NULL)
            return E_UNEXPECTED;

        m_pMTSINode = m_pNode->GetMTNode()->GetStaticParent();
        ASSERT(m_pMTSINode != NULL);
        if (m_pMTSINode == NULL)
            return E_UNEXPECTED;
    }

    return S_OK;
}

bool CMultiSelection::RemoveStaticNode(CMTNode* pMTNode)
{
    int iMax = m_rgStaticNodes.size()-1;
    if (iMax < 0)
        return false;

    if (::GetRelation(pMTNode, m_rgStaticNodes[0]) == 2)
    {
        m_rgStaticNodes.clear();
        return m_snapinSelDataList.IsEmpty();
    }

    for (int i=iMax; i >= 0; --i)
    {
        if (m_rgStaticNodes[i] == pMTNode)
        {
            CMTNodePtrArray::iterator iter = m_rgStaticNodes.begin();
            std::advance(iter, iMax);
            m_rgStaticNodes[i] = m_rgStaticNodes[iMax];
            m_rgStaticNodes.erase(iter);
            break;
        }
    }

    return m_rgStaticNodes.size();
}


CComponent* CMultiSelection::_GetComponent(CSnapinSelData* pSnapinSelData)
{
    CComponent* pCC = NULL;

    if ((pSnapinSelData->GetNumOfItems() > 1) ||
        (pSnapinSelData->GetID() > 0) ||
        (pSnapinSelData->IsScopeItem() == FALSE))
    {
        CSnapInNode* pSINode = _GetStaticNode();
        if (pSINode == NULL)
            return NULL;

        pCC = pSINode->GetComponent(pSnapinSelData->GetID());
        ASSERT(pCC != NULL);
    }
    else
    {
        ASSERT(pSnapinSelData->IsScopeItem() == TRUE);

        CNode* pNode = CNode::FromHandle ((HNODE) pSnapinSelData->GetCookie());
        ASSERT(pNode != NULL);
        if (pNode != NULL)
            pCC = pNode->GetPrimaryComponent();
    }

    return pCC;
}

HRESULT CMultiSelection::_ComputeSelectionDataList()
{
#ifdef DBG
    ASSERT(m_bInit == TRUE);
#endif

    ASSERT(m_pNode != NULL);
    ASSERT(m_pNode->GetViewData() != NULL);

    HWND hwnd = m_pNode->GetViewData() ?
                    m_pNode->GetViewData()->GetListCtrl() : NULL;

    ASSERT(hwnd != NULL);
    if (hwnd == NULL)
        return E_UNEXPECTED;

    ASSERT(::IsWindow(hwnd));
    if (!(::IsWindow(hwnd)))
        return E_UNEXPECTED;

    if (m_pNode->GetViewData()->IsVirtualList() == TRUE)
    {
        CSnapinSelData snapinSelData;
        snapinSelData.SetID(m_pNode->GetPrimaryComponent()->GetComponentID());
        snapinSelData.SetNumOfItems(ListView_GetSelectedCount(hwnd));
        if (snapinSelData.GetNumOfItems() == 1)
            snapinSelData.SetCookie(ListView_GetNextItem(hwnd, -1, LVIS_SELECTED));

        m_snapinSelDataList.Add(snapinSelData, FALSE);
    }
    else
    {
        int iSel = ListView_GetNextItem(hwnd, -1, LVIS_SELECTED);
        if (iSel < 0)
            return S_FALSE;

        for (; iSel >= 0; iSel = ListView_GetNextItem(hwnd, iSel, LVIS_SELECTED))
        {
            LPARAM lParam = ListView_GetItemData(hwnd, iSel);
            CResultItem* pri = CResultItem::FromHandle(lParam);
            ASSERT(pri != NULL);
            if (pri == NULL)
                return E_FAIL;

            CSnapinSelData snapinSelData;
            snapinSelData.SetID(pri->GetOwnerID());
            snapinSelData.IncrementNumOfItems();
            snapinSelData.SetCookie(pri->GetSnapinData());

            BOOL bStaticNode = FALSE;
            if (pri->IsScopeItem())
            {
                CNode* pNodeContext = CNode::FromResultItem (pri);
                ASSERT(pNodeContext != NULL);
                if (pNodeContext->IsInitialized() == FALSE)
                {
                    HRESULT hr = pNodeContext->InitComponents();
                    ASSERT(SUCCEEDED(hr));
                    if (FAILED(hr))
                    {
                        m_rgStaticNodes.clear();
                        m_snapinSelDataList.RemoveAll();
                        return hr;
                    }
                }

                // its a scope node - store to scope node array for this data object
                snapinSelData.AddScopeNodes(CSnapinSelData::CNodePtrArray(1, pNodeContext));

                m_bHasNodes = TRUE;
                snapinSelData.SetID(::GetComponentID(NULL, pri));
                snapinSelData.SetIsScopeItem(TRUE);

                if (snapinSelData.GetID() == TVOWNED_MAGICWORD)
                {
                    ASSERT(pNodeContext->GetMTNode() != NULL);
                    m_rgStaticNodes.push_back(pNodeContext->GetMTNode());
                    continue;
                }

                if (snapinSelData.GetID() == 0)
                {
                    ASSERT(pri->IsScopeItem());
                    bStaticNode = pNodeContext->IsStaticNode();

                    if (bStaticNode)
                    {
                        ASSERT(pNodeContext->GetMTNode() != NULL);
                        m_rgStaticNodes.push_back(pNodeContext->GetMTNode());
                    }
                }
            }

            // Add to the list
            m_snapinSelDataList.Add(snapinSelData, bStaticNode);
        }
    }

    POSITION pos = m_snapinSelDataList.GetHeadPosition();
    HRESULT hr = S_OK;

    while (pos)
    {
        CSnapinSelData* pSnapinSelData = m_snapinSelDataList.GetNext(pos);

        if (pSnapinSelData->GetNumOfItems() == 1)
        {
            // Get object type for single snapin item sel
            hr = _GetObjectTypeForSingleSel(pSnapinSelData);
            if (FAILED(hr))
                return hr;
        }
        else if (pSnapinSelData->GetNumOfItems() > 1)
        {
            // Get object type(s) for multiple snapin items sel
            hr = _GetObjectTypesForMultipleSel(pSnapinSelData);
            if (FAILED(hr))
                return hr;
        }
    }

    return hr;
}


HRESULT
CMultiSelection::_GetObjectTypeForSingleSel(
    CSnapinSelData* pSnapinSelData)
{
    ASSERT(pSnapinSelData->GetNumOfItems() == 1);

    if (m_pNode->GetViewData()->IsVirtualList() == FALSE)
    {
        ASSERT(pSnapinSelData->GetCookie() != 0);

        if (pSnapinSelData->GetNumOfItems() != 1 ||
            pSnapinSelData->GetCookie() == 0)
            return E_INVALIDARG;
    }

    HRESULT         hr = S_OK;
    IDataObjectPtr  spDO;

    CComponent* pCC = _GetComponent(pSnapinSelData);
    if (pCC == NULL)
        return E_UNEXPECTED;

    if (pSnapinSelData->GetID() == TVOWNED_MAGICWORD)
    {
        ASSERT(pSnapinSelData->IsScopeItem() == TRUE);
    }
    else if (pSnapinSelData->IsScopeItem() == TRUE)
    {
        CNode* pNode = CNode::FromHandle ((HNODE) pSnapinSelData->GetCookie());
        ASSERT(pNode != NULL);
        if (pNode == NULL)
            return E_FAIL;

        CComponentData* pCCD = NULL;

        if (pNode->IsStaticNode())
        {
            CMTNode* pMTNode = pNode->GetMTNode();
            ASSERT(pMTNode != NULL);
            if (pMTNode == NULL)
                return E_FAIL;

            pCCD = pMTNode->GetPrimaryComponentData();
        }
        else
        {
            CMTSnapInNode* pMTSINode = _GetStaticMasterNode();
            ASSERT(pMTSINode != NULL);
            if (pMTSINode == NULL)
                return E_UNEXPECTED;

            pCCD = pMTSINode->GetComponentData(pSnapinSelData->GetID());
        }

        ASSERT(pCCD != NULL);
        if (pCCD == NULL)
            return E_UNEXPECTED;

        hr = pCCD->QueryDataObject(pNode->GetUserParam(), CCT_SCOPE, &spDO);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        pSnapinSelData->SetSnapIn(pCCD->GetSnapIn());
    }
    else
    {
        hr = pCC->QueryDataObject(pSnapinSelData->GetCookie(), CCT_RESULT, &spDO);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        pSnapinSelData->SetSnapIn(pCC->GetSnapIn());
    }

    do // not a loop
    {
        if (pCC == NULL)
            break;

        pSnapinSelData->SetComponent(pCC);

        IFramePrivate* pIFP = pCC->GetIFramePrivate();
        ASSERT(pIFP != NULL);
        if (pIFP == NULL)
            break;

        IConsoleVerbPtr spConsoleVerb;
        hr = pIFP->QueryConsoleVerb(&spConsoleVerb);

        if (SUCCEEDED(hr))
        {
            ASSERT(spConsoleVerb != NULL);
            pSnapinSelData->SetConsoleVerb(spConsoleVerb);

            CConsoleVerbImpl* pCVI = dynamic_cast<CConsoleVerbImpl*>(
                                static_cast<IConsoleVerb*>(spConsoleVerb));
            ASSERT(pCVI != NULL);
            if (pCVI)
                pCVI->SetDisabledAll();
        }

        Dbg(DEB_USER1, _T("MMCN_SELECT> MS-1 \n"));
        pCC->Notify(spDO, MMCN_SELECT, MAKELONG((WORD)FALSE, (WORD)TRUE), 0);

    } while (0);

    GUID guid;
    hr = ExtractObjectTypeGUID(spDO, &guid);
    ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
    {
        pSnapinSelData->SetDataObject(spDO);
        pSnapinSelData->AddObjectType(guid);
    }

    return hr;
}

HRESULT
CMultiSelection::_GetObjectTypesForMultipleSel(
    CSnapinSelData* pSnapinSelData)
{
    ASSERT(m_pSINode != NULL);
    ASSERT(m_pMTSINode != NULL);

    ASSERT(pSnapinSelData != NULL);
    if (pSnapinSelData == NULL)
        return E_POINTER;

    CComponent* pCC = _GetComponent(pSnapinSelData);
    if (pCC == NULL)
        return E_UNEXPECTED;

    pSnapinSelData->SetSnapIn(pCC->GetSnapIn());

    IDataObjectPtr  spDO;
    HRESULT hr = pCC->QueryDataObject(MMC_MULTI_SELECT_COOKIE,
                                      CCT_UNINITIALIZED, &spDO);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    do // not a loop
    {
        if (pCC == NULL)
            break;

        pSnapinSelData->SetComponent(pCC);

        IFramePrivate* pIFP = pCC->GetIFramePrivate();
        ASSERT(pIFP != NULL);
        if (pIFP == NULL)
            break;

        IConsoleVerbPtr spConsoleVerb;
        hr = pIFP->QueryConsoleVerb(&spConsoleVerb);

        if (SUCCEEDED(hr))
        {
            ASSERT(spConsoleVerb != NULL);
            pSnapinSelData->SetConsoleVerb(spConsoleVerb);

            CConsoleVerbImpl* pCVI = dynamic_cast<CConsoleVerbImpl*>(
                                static_cast<IConsoleVerb*>(spConsoleVerb));
            ASSERT(pCVI != NULL);
            if (pCVI)
                pCVI->SetDisabledAll();
        }

        Dbg(DEB_USER1, _T("MMCN_SELECT> MS-2 \n"));
        pCC->Notify(spDO, MMCN_SELECT, MAKELONG((WORD)FALSE, (WORD)TRUE), 0);

    } while (0);

    if (spDO == NULL)
        return E_UNEXPECTED;

    // Get the data
    HGLOBAL hGlobal = NULL;
    hr = DataObject_GetHGLOBALData(spDO, GetMultiSelObjectTypesCF(),
                                   &hGlobal);
    if (FAILED(hr))
        return hr;

    BYTE* pb = reinterpret_cast<BYTE*>(::GlobalLock(hGlobal));
    DWORD count = *((DWORD*)pb);
    pb += sizeof(DWORD);
    GUID* pGuid = reinterpret_cast<GUID*>(pb);

    for (DWORD index=0; index < count; ++index)
    {
        pSnapinSelData->AddObjectType(pGuid[index]);
    }

    ::GlobalUnlock(hGlobal);
    ::GlobalFree(hGlobal);

    pSnapinSelData->SetDataObject(spDO);

    return S_OK;
}

HRESULT
CMultiSelection::GetMultiSelDataObject(
    IDataObject** ppDataObject)
{
    if (m_spDataObjectMultiSel == NULL)
    {
        HRESULT hr = S_OK;

        if (HasData() == FALSE)
        {
            hr = _ComputeSelectionDataList();
            if (FAILED(hr))
                return hr;

            ASSERT(HasData() == TRUE);
            if (HasData() == FALSE)
                return E_FAIL;
        }

        // CreateDataObjectForMultiSelection
        CComObject<CMultiSelectDataObject>* pMSDObject;
        hr = CComObject<CMultiSelectDataObject>::CreateInstance(&pMSDObject);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        ASSERT(pMSDObject != NULL);
        if (pMSDObject == NULL)
            return E_FAIL;

        pMSDObject->SetMultiSelection(this);

        UINT count = m_snapinSelDataList.GetCount();
        if (count > 0)
        {
            LPDATAOBJECT* ppDOs = new LPDATAOBJECT[count];
            POSITION pos = m_snapinSelDataList.GetHeadPosition();

            for (int i=0; pos; ++i)
            {
                CSnapinSelData* pSnapinSelData = m_snapinSelDataList.GetNext(pos);
                ASSERT(pSnapinSelData != NULL);
                ASSERT(i < count);
                ppDOs[i] = pSnapinSelData->GetDataObject();
                ASSERT(ppDOs[i] != NULL);
            }

            pMSDObject->SetDataObjects(ppDOs, count);
        }
        int nSize = m_rgStaticNodes.size();
        if (nSize > 0)
        {
            pMSDObject->SetStaticNodes(m_rgStaticNodes, nSize);
        }

        m_spDataObjectMultiSel = pMSDObject;
    }

    *ppDataObject = m_spDataObjectMultiSel;
    m_spDataObjectMultiSel.AddRef();
    return S_OK;
}

HRESULT
CMultiSelection::GetExtensionSnapins(
    LPCTSTR pszExtensionTypeKey,
    CList<GUID, GUID&>& extnClsidList)
{
    DECLARE_SC(sc, TEXT("CMultiSelection::GetExtensionSnapins"));

    ASSERT(&extnClsidList != NULL);

    extnClsidList.RemoveAll(); //init

    HRESULT hr = S_OK;

    if (HasData() == FALSE)
    {
        hr = _ComputeSelectionDataList();
        if (FAILED(hr))
            return hr;

        if (hr == S_FALSE)
            return hr;

        ASSERT(HasData() == TRUE);
        if (HasData() == FALSE)
            return E_FAIL;
    }

    if (HasSnapinData() == FALSE)
        return S_FALSE;

    //
    // Add the extension snapin clsids for the first object type
    // to extnClsidList.
    //
    {
        CSnapinSelData* pSnapinSelData = m_snapinSelDataList.GetHead();

        CList<GUID, GUID&>& objTypeGuidsList = pSnapinSelData->GetObjectTypeGuidList();
        ASSERT(objTypeGuidsList.IsEmpty() == FALSE);
        if (objTypeGuidsList.IsEmpty() == TRUE)
            return E_FAIL;

        // Get dynamic extensions requested by the snap-in
        CArray<GUID, GUID&> DynExtens;
        ExtractDynExtensions(pSnapinSelData->GetDataObject(), DynExtens);

        POSITION pos = objTypeGuidsList.GetHeadPosition();
        BOOL bFirstTime = TRUE;

        while (pos)
        {
            GUID& objectTypeGuid = objTypeGuidsList.GetNext(pos);

            CExtensionsIterator it;
            sc = it.ScInitialize(pSnapinSelData->GetSnapIn(), objectTypeGuid, pszExtensionTypeKey, DynExtens.GetData(), DynExtens.GetSize());
            if (sc)
                return hr;

            if (bFirstTime == TRUE)
            {
                bFirstTime = FALSE;

                for (; it.IsEnd() == FALSE; it.Advance())
                {
                    extnClsidList.AddHead(const_cast<GUID&>(it.GetCLSID()));
                }
            }
            else
            {
                CArray<CLSID, CLSID&> rgClsid;
                for (; it.IsEnd() == FALSE; it.Advance())
                {
                    rgClsid.Add(const_cast<CLSID&>(it.GetCLSID()));
                }

                POSITION pos = extnClsidList.GetHeadPosition();
                POSITION posCurr = 0;
                while (pos)
                {
                    posCurr = pos;
                    CLSID& clsid = extnClsidList.GetNext(pos);
                    BOOL bPresent = FALSE;
                    for (int k=0; k <= rgClsid.GetUpperBound(); ++k)
                    {
                        if (::IsEqualCLSID(rgClsid[k], clsid) == TRUE)
                        {
                            bPresent = TRUE;
                            break;
                        }
                    }

                    if (bPresent == FALSE)
                    {
                        // Remove from list
                        ASSERT(posCurr != 0);
                        extnClsidList.RemoveAt(posCurr);
                    }
                } // end while
            } // end else

            // No point continuing if the extension clsid list is empty.
            if (extnClsidList.IsEmpty() == TRUE)
                break;
        }
    }


    if (extnClsidList.IsEmpty() == TRUE)
        return S_FALSE;

    // If only items from one snapin were selected return.
    if (m_snapinSelDataList.GetCount() == 1)
        return S_OK;


    // loop through the extension clsids
    POSITION pos = extnClsidList.GetHeadPosition();
    while (pos)
    {
        // Get the first extension clsid
        POSITION posCurr = pos;
        CLSID& clsidSnapin = extnClsidList.GetNext(pos);

        // See if this clsid extends selected items put up by other snapins.
        BOOL bExtends = FALSE;
        POSITION posSDL = m_snapinSelDataList.GetHeadPosition();
        m_snapinSelDataList.GetNext(posSDL); // skip the first one.

        while (posSDL)
        {
            CSnapinSelData* pSnapinSelData = m_snapinSelDataList.GetNext(posSDL);
            CList<GUID, GUID&>& objTypeGuidsList = pSnapinSelData->GetObjectTypeGuidList();

            // Get dynamic extensions requested by the snap-in
            CArray<GUID, GUID&> DynExtens;
            ExtractDynExtensions(pSnapinSelData->GetDataObject(), DynExtens);

            POSITION pos2 = objTypeGuidsList.GetHeadPosition();
            while (pos2)
            {
                bExtends = FALSE; // re-init

                GUID& guidObjectType = objTypeGuidsList.GetNext(pos2);

                CExtensionsIterator it;
                sc = it.ScInitialize(pSnapinSelData->GetSnapIn(), guidObjectType, pszExtensionTypeKey, DynExtens.GetData(), DynExtens.GetSize());
                if (sc)
                    break;

                for (; it.IsEnd() == FALSE; it.Advance())
                {
                    if (::IsEqualCLSID(clsidSnapin, it.GetCLSID()) == TRUE)
                    {
                        bExtends = TRUE;
                        break;
                    }
                }

                if (bExtends == FALSE)
                    break;
            }

            if (bExtends == FALSE)
                break;
        }

        ASSERT(posCurr != 0);
        if (bExtends == FALSE)
            extnClsidList.RemoveAt(posCurr);
    }

    return S_OK;
}

BOOL CMultiSelection::IsAnExtensionSnapIn(const CLSID& rclsid)
{
    POSITION pos = m_snapinSelDataList.GetHeadPosition();
    while (pos)
    {
        CSnapinSelData* pSSD = m_snapinSelDataList.GetNext(pos);
        ASSERT(pSSD != NULL);
        if (pSSD->GetSnapIn() != NULL &&
            ::IsEqualCLSID(rclsid, pSSD->GetSnapIn()->GetSnapInCLSID()))
        {
            return TRUE;
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:      CMultiSelection::ScVerbInvoked
//
//  Synopsis:    A verb was invoked, inform the snapin about invocation.
//
//  Arguments:   [verb] - that is invoked.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMultiSelection::ScVerbInvoked (MMC_CONSOLE_VERB verb)
{
    DECLARE_SC(sc, _T("CMultiSelection::ScVerbInvoked"));

    /*
     * If you make any modifications do not forget to Release
     * the ref as shown below.
     */
    AddRef();
    sc = _ScVerbInvoked(verb);
    Release();

    if (sc)
        return sc;
    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CMultiSelection::_ScVerbInvoked
//
//  Synopsis:    A verb was invoked, inform the snapin about invocation.
//
//  Arguments:   [verb] - that is invoked.
//
//  Returns:     SC
//
//  Note:        We handle only Delete & Print. If you want to handle
//               any other notifications, make sure the IComponent::Notify
//               gets right arg & param values (they are unused for Delete & Print).
//
//--------------------------------------------------------------------
SC CMultiSelection::_ScVerbInvoked (MMC_CONSOLE_VERB verb)
{
    DECLARE_SC(sc, _T("CMultiSelection::_ScVerbInvoked"));

    if (! HasSnapinData())
        return (sc = E_UNEXPECTED);

    MMC_NOTIFY_TYPE eNotifyCode;
    switch(verb)
    {
    case MMC_VERB_DELETE:
        eNotifyCode = MMCN_DELETE;
        break;

    case MMC_VERB_PRINT:
        eNotifyCode = MMCN_PRINT;
        break;

    default:
        /*
         * We handle only Delete & Print. If you want to handle
         * any other notifications, make sure the IComponent::Notify
         * gets right arg & param values (they are unused for Delete & Print).
         */
        sc = E_INVALIDARG;
        return sc;
    }

    POSITION pos = m_snapinSelDataList.GetHeadPosition();
    while (pos)
    {
        BOOL bFlag = FALSE;
        CSnapinSelData* pSSD = m_snapinSelDataList.GetNext(pos);
        sc = ScCheckPointers(pSSD, E_UNEXPECTED);
        if (sc)
            return sc;

        IConsoleVerb *pConsoleVerb = pSSD->GetConsoleVerb();
        sc = ScCheckPointers(pConsoleVerb, E_UNEXPECTED);
        if (sc)
            return sc;

        pConsoleVerb->GetVerbState(verb, ENABLED, &bFlag);

        // If snapin did not enable verb for this item then skip it.
        if (!bFlag)
            continue;

        CComponent *pComponent = pSSD->GetComponent();
        sc = ScCheckPointers(pComponent, E_UNEXPECTED);
        if (sc)
            return sc;

        sc = pComponent->Notify( pSSD->GetDataObject(),
                                 eNotifyCode, 0, 0);

        // Trace & Ignore snapin returned errors.
        if (sc)
            sc.TraceAndClear();
    }

    return (sc);
}

bool IsMultiSelectDataObject(IDataObject* pdtobjCBSelData)
{
    if (!pdtobjCBSelData)
        return FALSE;

    FORMATETC fmt;
    ZeroMemory(&fmt, sizeof(fmt));
    fmt.dwAspect = DVASPECT_CONTENT;
    fmt.cfFormat = GetMMCMultiSelDataObjectCF();

    return (pdtobjCBSelData->QueryGetData(&fmt) == S_OK);
}



HRESULT ExtractDynExtensions(IDataObject* pdataObj, CGuidArray& arGuid)
{
    ASSERT(pdataObj != NULL);

    static CLIPFORMAT cfDynExtensions = 0;
    if (cfDynExtensions == 0)
    {
        USES_CONVERSION;
        cfDynExtensions = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_MMC_DYNAMIC_EXTENSIONS));
        ASSERT(cfDynExtensions != 0);
    }

    // Get the data
    HGLOBAL hGlobal = NULL;
    HRESULT hr = DataObject_GetHGLOBALData(pdataObj, cfDynExtensions, &hGlobal);
    if (FAILED(hr))
        return hr;

    SMMCDynamicExtensions* pExtenData = reinterpret_cast<SMMCDynamicExtensions*>(::GlobalLock(hGlobal));
    ASSERT(pExtenData != NULL);

    for (DWORD index=0; index < pExtenData->count; ++index)
    {
        arGuid.Add(pExtenData->guid[index]);
    }

    ::GlobalUnlock(hGlobal);
    ::GlobalFree(hGlobal);

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:      CMultiSelection::ScIsVerbEnabledInclusively
//
//  Synopsis:    Is the given verb enabled under current multi-selection.
//               Should be used only if items from more than one snapin
//               is selected.
//               Inclusive means, bEnable will be true if any one snapin
//               enables given verb.
//
//
//  Arguments:   [mmcVerb]    - The verb to check.
//               [bEnable]    - Enabled or not, Return value.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMultiSelection::ScIsVerbEnabledInclusively(MMC_CONSOLE_VERB mmcVerb, BOOL& bEnable)
{
    DECLARE_SC(sc, _T("CMultiSelection::ScIsVerbEnabledInclusively"));
    bEnable = false;

    if (IsSingleSnapinSelection())
        return (sc = E_UNEXPECTED);

    POSITION pos = m_snapinSelDataList.GetHeadPosition();
    while (pos)
    {
        CSnapinSelData* pSSD = m_snapinSelDataList.GetNext(pos);
        sc = ScCheckPointers(pSSD, E_UNEXPECTED);
        if (sc)
            return sc;

        IConsoleVerb *pConsoleVerb = pSSD->GetConsoleVerb();
        sc = ScCheckPointers(pConsoleVerb, E_UNEXPECTED);
        if (sc)
            return sc;

        sc = pConsoleVerb->GetVerbState(mmcVerb, ENABLED, &bEnable);
        if (sc)
            return sc;

        if (bEnable)
            return sc;
    }

    return (sc);
}

/***************************************************************************\
 *
 * METHOD:  CMultiSelection::ScGetSnapinDataObjects
 *
 * PURPOSE: Adds all contained data objects to CMMCClipBoardDataObject
 *
 * PARAMETERS:
 *    CMMCClipBoardDataObject *pResultObject [in] - container to add data objects
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMultiSelection::ScGetSnapinDataObjects(CMMCClipBoardDataObject *pResultObject)
{
    DECLARE_SC(sc, TEXT("CMultiSelection::ScGetSnapinDataObjects"));

    // for each snapin...
    POSITION pos = m_snapinSelDataList.GetHeadPosition();
    while (pos)
    {
        CSnapinSelData* pSSD = m_snapinSelDataList.GetNext(pos);
        sc = ScCheckPointers(pSSD, E_UNEXPECTED);
        if (sc)
            return sc;

        // get snapin data
        CComponent *pComponent = pSSD->GetComponent();
        IConsoleVerb *pConsoleVerb = pSSD->GetConsoleVerb();
        sc = ScCheckPointers(pComponent, pConsoleVerb, E_UNEXPECTED);
        if (sc)
            return sc;

        // get verbs
        bool bCopyEnabled = false;
        bool bCutEnabled = false;

        BOOL bEnable = FALSE;
        sc = pConsoleVerb->GetVerbState(MMC_VERB_COPY, ENABLED, &bEnable);
        bCopyEnabled = bEnable;
        if (sc)
            return sc;

        sc = pConsoleVerb->GetVerbState(MMC_VERB_CUT, ENABLED, &bEnable);
        bCutEnabled = bEnable;
        if (sc)
            return sc;

        // construct the array of scope nodes in this data object
        CSnapinSelData::CNodePtrArray nodes;

        // if regular result items exist - add active scope node
        if ( pSSD->GetNumOfItems() != pSSD->GetScopeNodes().size() )
            nodes.push_back(m_pNode);

        // add scope items from result pane
        nodes.insert( nodes.end(), pSSD->GetScopeNodes().begin(), pSSD->GetScopeNodes().end() );

        // add to the MMC DO
        sc = pResultObject->ScAddSnapinDataObject( nodes,
                                                   pComponent->GetIComponent(),
                                                   pSSD->GetDataObject(),
                                                   bCopyEnabled, bCutEnabled );
        if (sc)
            return sc;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\newnode.cpp ===
// NewNode.cpp : implementation file
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      NewNode.cpp
//
//  Contents:  Wizards / Propertysheets for console owned nodes
//
//  History:   01-Aug-96 WayneSc    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include <comcat.h>         // COM Component Categoories Manager
#include "CompCat.h"        // Component Category help functions
#include "guids.h"          // AMC Category guids


#include "NewNode.h"
#include "amcmsgid.h"
#include "ndmgrp.h"

#include "fldrsnap.h"
                                            
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Listview compare function forward
int CALLBACK ListViewCompareFunc(LPARAM lParam1,LPARAM lParam2,LPARAM lParamSort);
void LoadFilterString(CStr &str, int iStrID);


/////////////////////////////////////////////////////////////////////////////
// CHTMLPage1 property page


CHTMLPage1::CHTMLPage1()
{
//    SetHelpIDs(g_aHelpIDs_IDD_HTML_WIZPAGE1);
}


CHTMLPage1::~CHTMLPage1()
{
}


LRESULT CHTMLPage1::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CWizardPage::OnInitWelcomePage(m_hWnd); // set up the correct title font
    
    HWND const hTarget = ::GetDlgItem( *this, IDC_TARGETTX );
    ASSERT( hTarget != NULL );
    m_strTarget.Attach( hTarget );
    m_strTarget.SetWindowText( _T( "" ) );
    m_strTarget.SetLimitText( 128 );

    _ValidatePage();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CHTMLPage1 message handlers

void CHTMLPage1::_ValidatePage(void)
{
    TRACE_METHOD(CHTMLPage1, _ValidatePage);

    DWORD dwFlags=0;

    // Check to see if we have a valid string
    TCHAR buff[ 256 ];
    int nChars = m_strTarget.GetWindowText( buff, countof(buff));

    if( nChars != 0 && _tcslen( buff ) > 0 )
        dwFlags|=PSWIZB_NEXT;


    HWND hWnd=::GetParent(m_hWnd);
    ::SendMessage(hWnd, PSM_SETWIZBUTTONS, 0, dwFlags);
}


BOOL CHTMLPage1::OnSetActive()
{
    TRACE_METHOD(CHTMLPage1, OnSetActive);
    
    CWizardPage::OnWelcomeSetActive(m_hWnd); 

    USES_CONVERSION;

    m_strTarget.SetWindowText(GetComponentDataImpl()->GetView());
    _ValidatePage();

    return TRUE;
}


BOOL CHTMLPage1::OnKillActive()
{
    // the line below has been commented because this wizard has only two pages and so we
    // want to enable the Finish button, not the Next button.
    // CWizardPage::OnWelcomeKillActive(m_hWnd); 
    
    TRACE_METHOD(CHTMLPage1, OnKillActive);
    USES_CONVERSION;

    TCHAR buff[ 256 ];
    int nChars = m_strTarget.GetWindowText( buff, countof(buff));
    if (nChars == 0)
        buff[0] = 0; // initialize to empty if failed

    // set the view and the name to be the same intially.
    GetComponentDataImpl()->SetView(buff);
    GetComponentDataImpl()->SetName(buff);

    LPTSTR psz = _tcsrchr(GetComponentDataImpl()->GetView(), TEXT('\\'));
    if (psz!=NULL)
    {
        psz++;
        GetComponentDataImpl()->SetName(psz); // use only the string after the last "\". Thus c:\mmc.xml gives mmc.xml as the display name.
    }

    return TRUE;
}




LRESULT CHTMLPage1::OnUpdateTargetTX( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    TRACE_METHOD(CHTMLPage1, OnUpdateTargetTX);

    _ValidatePage();

    return 0;
}


LRESULT CHTMLPage1::OnBrowseBT( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    TRACE_METHOD(CHTMLPage1, OnBrowseBT);

    TCHAR szFile[MAX_PATH] = { 0 };
    TCHAR szInitialPath[MAX_PATH];

    CStr strFilter;
    LoadFilterString(strFilter, IDS_HTML_FILES);

    CStr strTitle;
    strTitle.LoadString(GetStringModule(), IDS_BROWSE_WEBLINK);

    // Copy the current command target value to the file name
    m_strTarget.GetWindowText (szInitialPath, countof(szInitialPath));

    OPENFILENAME ofn;
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = strFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;   // use 1st filter in lpstrFilter
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrTitle = strTitle;
    ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = _T("htm");
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;
    ofn.lpstrInitialDir = szInitialPath;

    if (!GetOpenFileName(&ofn))
    {
        if (CommDlgExtendedError() != 0)
        {
            ASSERT(0 && "GetOpenFileName failed");
            Dbg(DEB_ERROR, _T("GetOpenFileName failed, 0x%08lx\n"),CommDlgExtendedError());
        }

        return 0;
    }

    // lpstrFile has the full path of the file to open

    TRACE(_T("Open: %ws\n"), ofn.lpstrFile);
    m_strTarget.SetWindowText( ofn.lpstrFile );

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CHTMLPage2 property page


CHTMLPage2::CHTMLPage2()
{
//    SetHelpIDs(g_aHelpIDs_IDD_HTML_WIZPAGE2);
}


CHTMLPage2::~CHTMLPage2()
{
}


LRESULT CHTMLPage2::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    USES_CONVERSION;
    HWND const hDisplay = ::GetDlgItem( *this, IDC_DISPLAYTX );
    ASSERT( hDisplay != NULL );
    m_strDisplay.Attach( hDisplay );
    m_strDisplay.SetWindowText( GetComponentDataImpl()->GetName());
    m_strDisplay.SetLimitText( 128 );

    _ValidatePage();
    return TRUE;
}



void CHTMLPage2::_ValidatePage(void)
{
    TRACE_METHOD(CHTMLPage2, _ValidatePage);

    DWORD dwFlags=PSWIZB_BACK|PSWIZB_DISABLEDFINISH;

    // Check to see if we have a valid string
    TCHAR buff[ 256 ];
    int nChars = m_strDisplay.GetWindowText( buff, countof(buff));

    if( nChars != 0 && _tcslen( buff ) > 0 )
        dwFlags|=PSWIZB_FINISH;


    HWND hWnd=::GetParent(m_hWnd);
    ::SendMessage(hWnd, PSM_SETWIZBUTTONS, 0, dwFlags);
}


BOOL CHTMLPage2::OnSetActive()
{
    TRACE_METHOD(CHTMLPage2, OnSetActive);
    USES_CONVERSION;

    m_strDisplay.SetWindowText( GetComponentDataImpl()->GetName());
    _ValidatePage();

    return TRUE;
}


BOOL CHTMLPage2::OnKillActive()
{
    TRACE_METHOD(CHTMLPage2, OnKillActive);

    TCHAR buff[ 256 ];
    m_strDisplay.GetWindowText( buff, countof(buff));
    GetComponentDataImpl()->SetName(buff);

    return TRUE;
}


BOOL CHTMLPage2::OnWizardFinish()
{
    TRACE_METHOD(CHTMLPage2, OnWizardFinish);

    OnKillActive();
    return TRUE;
}


LRESULT CHTMLPage2::OnUpdateDisplayTX( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    TRACE_METHOD(CHTMLPage2, OnUpdateDisplayTX);

    _ValidatePage();
    return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CActiveXPage0 property page


CActiveXPage0::CActiveXPage0()
{
//    SetHelpIDs(g_aHelpIDs_IDD_ACTIVEX_WIZPAGE0);
}


CActiveXPage0::~CActiveXPage0()
{
}


BOOL CActiveXPage0::OnSetActive()
{
    CWizardPage::OnWelcomeSetActive(m_hWnd); 
    
    return TRUE;
}


BOOL CActiveXPage0::OnKillActive()
{
    CWizardPage::OnWelcomeKillActive(m_hWnd); 
    return TRUE;
}

LRESULT CActiveXPage0::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{        
    CWizardPage::OnInitWelcomePage(m_hWnd); // set up the correct title font
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CActiveXPage1 property page


CActiveXPage1::CActiveXPage1()
{
    m_pListCtrl = NULL;
    m_pComponentCategory = NULL;
//    SetHelpIDs(g_aHelpIDs_IDD_ACTIVEX_WIZPAGE1);
}


CActiveXPage1::~CActiveXPage1()
{
}


void CActiveXPage1::_ValidatePage(void)
{
    DWORD dwFlags = PSWIZB_BACK;

    // Check to see if we have a valid string
    if (m_pListCtrl != NULL && m_pListCtrl->GetSelectedCount()>0)
        dwFlags|=PSWIZB_NEXT;

    HWND hWnd=::GetParent(m_hWnd);
    ::SendMessage(hWnd, PSM_SETWIZBUTTONS, 0, dwFlags);
}


BOOL CActiveXPage1::OnSetActive()
{
    _ValidatePage();
    return TRUE;
}


BOOL CActiveXPage1::OnKillActive()
{
    LV_ITEM lvi;
    ZeroMemory( &lvi,sizeof(LV_ITEM) );

    lvi.mask = LVIF_PARAM;
    lvi.iItem = m_pListCtrl->GetNextItem( -1, LVNI_SELECTED );

    if (lvi.iItem != -1)
    {
        if (m_pListCtrl->GetItem(&lvi))
        {
            CComponentCategory::COMPONENTINFO* pComponentInfo=(CComponentCategory::COMPONENTINFO*)lvi.lParam;

            USES_CONVERSION;
            GetComponentDataImpl()->SetName(((LPTSTR)(LPCTSTR)pComponentInfo->m_strName));
            LPOLESTR szClsid = NULL;
            StringFromCLSID(pComponentInfo->m_clsid, &szClsid);
            ASSERT(szClsid != NULL);
            if(szClsid != NULL)
            {
                GetComponentDataImpl()->SetView(OLE2T(szClsid));
                CoTaskMemFree(szClsid);
            }
        }
    }

    return TRUE;
}


LRESULT CActiveXPage1::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{        
    /*
     * this could take a while - throw up the hourglass
     */
    // Display hour glass during long initialization
    SetCursor (LoadCursor (NULL, IDC_WAIT));

    m_nConsoleView = -1;

    m_pListCtrl = new WTL::CListViewCtrl;
	if ( m_pListCtrl == NULL )
		return TRUE;

    m_pComboBox = new CComboBoxEx2;
	if ( m_pComboBox == NULL )
		return TRUE;

    m_pComponentCategory = new CComponentCategory;
	if ( m_pComponentCategory == NULL )
		return TRUE;


    // subclass the categories combo box
    m_pComboBox->Attach(::GetDlgItem(*this, IDC_CATEGORY_COMBOEX));

    // sub class the controls list
    m_pListCtrl->Attach(::GetDlgItem( *this, IDC_CONTROLXLS));

    // set the imagelist
    m_pListCtrl->SetImageList( m_pComponentCategory->m_iml, LVSIL_SMALL );

    // create single column in list view
    // Reduce column width by width of vertical scroll bar so that we
    // don't need a horizontal scroll bar
    RECT rc;
    m_pListCtrl->GetClientRect(&rc);

    LV_COLUMN lvc;
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 0;
    m_pListCtrl->InsertColumn(0, &lvc);

    // enumerate the categories and add them to the combo box 
    m_pComponentCategory->EnumComponentCategories();
    BuildCategoryList(m_pComponentCategory->m_arpCategoryInfo);

    // enumerate all the controls and add them to the list box
    m_pComponentCategory->EnumComponents();
    m_pComponentCategory->FilterComponents(NULL);
    BuildComponentList(m_pComponentCategory->m_arpComponentInfo);

     // remove the hourglass
    SetCursor (LoadCursor (NULL, IDC_ARROW));

    return TRUE;
}


LRESULT CActiveXPage1::OnDestroy( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    delete m_pComponentCategory;
    delete m_pListCtrl;
    delete m_pComboBox;
    return 0;
}


//
// Populate the category combo box from the category list
//
LRESULT CActiveXPage1::BuildCategoryList(CArray <CATEGORYINFO*, CATEGORYINFO*>& arpCategories)
{
    USES_CONVERSION;

    COMBOBOXEXITEM ComboItem;
        
    for (int i = 0; i <= arpCategories.GetUpperBound(); i++)
    {
        CATEGORYINFO* pCatInfo = arpCategories.GetAt(i);

        ComboItem.mask = CBEIF_LPARAM | CBEIF_TEXT;
        ComboItem.lParam = reinterpret_cast<LPARAM>(pCatInfo);
        ComboItem.pszText = OLE2T(pCatInfo->szDescription);

        // CComboBoxEx doesn't support CBS_SORT and has no add method, only insert.
        // So we need to find the insertion point ourselves. Because it's a short
        // list, just do a linear search.
        int iInsert;
        for (iInsert = 0; iInsert < i; iInsert++)
        {
            CATEGORYINFO* pCatEntry = reinterpret_cast<CATEGORYINFO*>(m_pComboBox->GetItemData(iInsert));
            if (_wcsicmp(pCatInfo->szDescription, pCatEntry->szDescription) < 0)
                break;
        }
        ComboItem.iItem = iInsert;

        int iItem = m_pComboBox->InsertItem(&ComboItem);
        ASSERT(iItem >= 0);
    }

    // Add special "All Categories" entry at the top and select it
    // Note that this item is recognized by a NULL category info ptr 
    CStr strAllCat;
    strAllCat.LoadString(GetStringModule(), IDS_ALL_CATEGORIES);

    ComboItem.mask = CBEIF_LPARAM | CBEIF_TEXT;
    ComboItem.lParam = NULL;
    ComboItem.pszText = const_cast<LPTSTR>((LPCTSTR)strAllCat);
    ComboItem.iItem = 0;

    int iItem = m_pComboBox->InsertItem(&ComboItem);
    ASSERT(iItem >= 0);

    m_pComboBox->SetCurSel(0);

    return S_OK;
}      


//
// Populate the component listview with the filtered items in the component list
//
LRESULT CActiveXPage1::BuildComponentList(
            CArray <CComponentCategory::COMPONENTINFO*, 
            CComponentCategory::COMPONENTINFO*>& arpComponents )
{
    // Get currently selected item data
    LPARAM lParamSel = 0;

    int iSelect = m_pListCtrl->GetNextItem(-1, LVNI_SELECTED);
    if (iSelect != -1)
        lParamSel = m_pListCtrl->GetItemData(iSelect);

    // clear and reload comp list
    m_pListCtrl->DeleteAllItems();

    for (int i=0; i <= arpComponents.GetUpperBound(); i++)
    {
        CComponentCategory::COMPONENTINFO* pCompInfo = arpComponents.GetAt(i);

        if (pCompInfo->m_bSelected)
        {
            LV_ITEM         lvi;

            lvi.mask        = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            lvi.iItem       = i;
            lvi.state       = 0;
            lvi.stateMask   = 0;
            lvi.iSubItem    = 0;
            lvi.pszText     = const_cast<LPTSTR>(static_cast<LPCTSTR>(pCompInfo->m_strName));
            lvi.iImage      = pCompInfo->m_uiBitmap;
            lvi.lParam      = (LPARAM)(LPVOID)pCompInfo;

            int iRet = m_pListCtrl->InsertItem(&lvi);
            ASSERT(iRet != -1);
        }
    }

    // if list isn't empty, select an item
    if (m_pListCtrl->GetItemCount() != 0)
    {
        // first item is the default
        iSelect = 0;

        // try finding previously selected item
        if (lParamSel != NULL)
        {
            LV_FINDINFO FindInfo;

            FindInfo.flags = LVFI_PARAM;
            FindInfo.lParam = lParamSel;

            iSelect = m_pListCtrl->FindItem(&FindInfo, -1 );
        }

        LV_ITEM lvi;

        lvi.mask = LVIF_STATE;
        lvi.iItem = iSelect;
        lvi.iSubItem = 0;
        lvi.state = LVIS_SELECTED | LVIS_FOCUSED;
        lvi.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

        m_pListCtrl->SetItem(&lvi);
        m_pListCtrl->EnsureVisible(iSelect, FALSE);
     }

    _ValidatePage();

    return S_OK;
}


//
// handle component selection change
//
LRESULT CActiveXPage1::OnComponentSelect( int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{
    _ValidatePage();

    return 0;
}


//
// Handle category selection change
//
LRESULT CActiveXPage1::OnCategorySelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iItem = m_pComboBox->GetCurSel();
    ASSERT(iItem >= 0);
    if (iItem < 0)
        return 0;

    // get the category info pointer (item's lparam)
    COMBOBOXEXITEM ComboItem;
    ComboItem.mask = CBEIF_LPARAM;
    ComboItem.iItem = iItem;

    BOOL bStat = m_pComboBox->GetItem(&ComboItem);
    ASSERT(bStat);

    CATEGORYINFO* pCatInfo = reinterpret_cast<CATEGORYINFO*>(ComboItem.lParam);

    // filter the component of this category
    m_pComponentCategory->FilterComponents(pCatInfo);

    // rebuild the component list
    BuildComponentList(m_pComponentCategory->m_arpComponentInfo);

    return 0;
}



/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CActiveXPage2 property page


CActiveXPage2::CActiveXPage2()
{
//    SetHelpIDs(g_aHelpIDs_IDD_ACTIVEX_WIZPAGE2);
}


CActiveXPage2::~CActiveXPage2()
{
}


LRESULT CActiveXPage2::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HWND const hDisplay = ::GetDlgItem( *this, IDC_DISPLAYTX );
    ASSERT( hDisplay != NULL );
    m_strDisplay.Attach( hDisplay );
    m_strDisplay.SetWindowText( _T( "" ) );
    m_strDisplay.SetLimitText( 128 );

    _ValidatePage();
    return 0;
}


void CActiveXPage2::_ValidatePage(void)
{
    DWORD dwFlags=PSWIZB_BACK|PSWIZB_DISABLEDFINISH;

    // Check to see if we have a valid string
    TCHAR buff[ 256 ];
    int nChars = m_strDisplay.GetWindowText( buff, countof(buff));

    if( nChars != 0 && _tcslen( buff ) > 0 )
        dwFlags|=PSWIZB_FINISH;


    HWND hWnd=::GetParent(m_hWnd);
    ::SendMessage(hWnd, PSM_SETWIZBUTTONS, 0, dwFlags);
}


BOOL CActiveXPage2::OnSetActive()
{
    USES_CONVERSION;
    m_strDisplay.SetWindowText(GetComponentDataImpl()->GetName());
    _ValidatePage();

    return TRUE;
}


BOOL CActiveXPage2::OnKillActive()
{
    TCHAR buff[ 256 ];
    m_strDisplay.GetWindowText( buff, countof(buff) );
    GetComponentDataImpl()->SetName(buff);

    return TRUE;
}


LRESULT CActiveXPage2::OnUpdateTargetTX( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    _ValidatePage();
    return 0;
}


BOOL CActiveXPage2::OnWizardFinish()
{
    OnKillActive();
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage

template<class T>
void CBasePropertyPage<T>::OnPropertySheetExit(HWND hWndOwner, int nFlag)
{
    m_spComponentData = NULL;
}

// Helper function to reformat filter resource string
// ( resource string uses '\' instead of null to separate strings
//   and doesn't terminate in double null. )

void LoadFilterString(CStr &strFilter, int iStrID)
{
    // Get resource string
    strFilter.LoadString(GetStringModule(), iStrID);

    // Append extra NULL to mark end of multi-string
    strFilter += _T('\0');

    // Change filter separators from '\' to nulls
    LPTSTR psz = const_cast<LPTSTR>((LPCTSTR)strFilter);
    while (*psz != _T('\0'))
    {
        if (*psz == _T('\\'))
            *psz = _T('\0');
        psz++;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\newnode.h ===
// NewNode.h : structures for console created nodes
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      NewNode.h
//
//  Contents:  Definitions for internal data types that can be created by the
//             user.
//
//  History:   12-Aug-96 WayneSc    Created
//
//--------------------------------------------------------------------------

#ifndef __NEWNODE_H__
#define __NEWNODE_H__

#include "dlgs.h"
#include "ccomboex.h"

#define NODE_NOCHANGE       0
#define NODE_NAME_CHANGE    1
#define NODE_TARGET_CHANGE  2

                             
class CSnapinComponentDataImpl;
                             
template<class T>
class CBasePropertyPage : public T
{
    typedef CBasePropertyPage<T>        ThisClass;
    typedef T                           BaseClass;

public:
    CBasePropertyPage() : m_pHelpIDs(NULL) {}
    void Initialize(IComponentData *pComponentData) 
    {
        // do not use a smart pointer - causes a circular reference
        // the lifetime is managed because the CBasePropertyObject is owned by the IComponentData
        m_pComponentData = pComponentData; 
    } 

public: 
    BEGIN_MSG_MAP(ThisClass)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP()

    void OnPropertySheetExit(HWND hWndOwner, int nFlag);

protected:
    void SetHelpIDs(const DWORD* pHelpIDs)
    {
        m_pHelpIDs = pHelpIDs;
    }

    const DWORD* GetHelpIDs(void) const
    {
        return m_pHelpIDs;
    }

private:
    const DWORD* m_pHelpIDs;

protected:
    CSnapinComponentDataImpl *GetComponentDataImpl()
    {
        CSnapinComponentDataImpl *pRet = dynamic_cast<CSnapinComponentDataImpl *>(m_pComponentData);
        ASSERT(pRet);
        return pRet;
    }

    IComponentData* m_pComponentData;
};

/////////////////////////////////////////////////////////////////////////////
// CHTMLPage1 dialog

class CHTMLPage1 : public CBasePropertyPage<CWizard97WelcomeFinishPage<CHTMLPage1> >
{
    typedef CHTMLPage1                              ThisClass;
    typedef CBasePropertyPage<CWizard97WelcomeFinishPage<CHTMLPage1> >  BaseClass;

    // Construction
    public:
        CHTMLPage1();
        ~CHTMLPage1();
       
    
    // Dialog Data
        enum { IDD = IDD_HTML_WIZPAGE1 };
        WTL::CEdit m_strTarget;
    
    
    // Overrides
    public:
        BOOL OnSetActive();
        BOOL OnKillActive();
    
    // Implementation
    protected:
        BEGIN_MSG_MAP(ThisClass)
            COMMAND_ID_HANDLER( IDC_BROWSEBT, OnBrowseBT )
            COMMAND_HANDLER( IDC_TARGETTX, EN_UPDATE, OnUpdateTargetTX )
            MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
            CHAIN_MSG_MAP(BaseClass)
        END_MSG_MAP()
    
        // Generated message map functions
        LRESULT OnBrowseBT( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
        LRESULT OnUpdateTargetTX( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
        LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    //Operators
    protected:
        void _ValidatePage(void);
    
};
/////////////////////////////////////////////////////////////////////////////
// CHTMLPage2 dialog

class CHTMLPage2 : public CBasePropertyPage<CWizard97WelcomeFinishPage<CHTMLPage2> >
{
    typedef CHTMLPage2                              ThisClass;
    typedef CBasePropertyPage<CWizard97WelcomeFinishPage<CHTMLPage2> >  BaseClass;

    // Construction
    public:
        CHTMLPage2();
        ~CHTMLPage2();
    
    //Operators
    public:
        // Dialog Data
        enum { IDD = IDD_HTML_WIZPAGE2 };
        WTL::CEdit m_strDisplay;
    
        BOOL OnSetActive();
        BOOL OnKillActive();
        BOOL OnWizardFinish();
    
    // Implementation
    protected:
        BEGIN_MSG_MAP( CShortcutPage2 );
            COMMAND_HANDLER( IDC_DISPLAYTX, EN_UPDATE, OnUpdateDisplayTX )
            MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
            CHAIN_MSG_MAP(BaseClass)
        END_MSG_MAP();

        LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
        LRESULT OnUpdateDisplayTX( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    
        void _ValidatePage(void);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CActiveXPage0 dialog

class CActiveXPage0 : public CBasePropertyPage<CWizard97WelcomeFinishPage<CActiveXPage0> >
{
    typedef CActiveXPage0                               ThisClass;
    typedef CBasePropertyPage<CWizard97WelcomeFinishPage<CActiveXPage0> >   BaseClass;

    // Construction
public:
    CActiveXPage0();
    ~CActiveXPage0();
                
        // Dialog Data
    enum { IDD = IDD_ACTIVEX_WIZPAGE0 };
    
protected: // implementation

    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP()

    LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

    // Overrides
public:
    BOOL OnSetActive();
    BOOL OnKillActive();
};


/////////////////////////////////////////////////////////////////////////////
// CActiveXPage1 dialog

class CActiveXPage1 : public CBasePropertyPage<CWizard97InteriorPage<CActiveXPage1> >
{
    typedef CActiveXPage1                           ThisClass;
    typedef CBasePropertyPage<CWizard97InteriorPage<CActiveXPage1> >    BaseClass;

    // Construction
    public:
        CActiveXPage1();
        ~CActiveXPage1();
    
        // Dialog Data
        enum 
        { 
            IDD          = IDD_ACTIVEX_WIZPAGE1,
            IDS_Title    = IDS_OCXWiz_ControlPageTitle,
            IDS_Subtitle = IDS_OCXWiz_ControlPageSubTitle,
        };


        WTL::CButton    m_InfoBT;
        int     m_nConsoleView;
    
    
        BOOL OnSetActive();
        BOOL OnKillActive();
    
    // Implementation
    protected:
        BEGIN_MSG_MAP(ThisClass)
            COMMAND_HANDLER(IDC_CATEGORY_COMBOEX, CBN_SELENDOK, OnCategorySelect)            
            NOTIFY_HANDLER( IDC_CONTROLXLS, NM_CLICK, OnComponentSelect )
            MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
            MESSAGE_HANDLER( WM_DESTROY, OnDestroy )
            CHAIN_MSG_MAP(BaseClass)
        END_MSG_MAP()

        LRESULT OnComponentSelect( int idCtrl, LPNMHDR pnmh, BOOL& bHandled );
        LRESULT OnCategorySelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

        LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
        LRESULT OnDestroy( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
        LRESULT BuildCategoryList(CArray <CATEGORYINFO*, CATEGORYINFO*>& arpCategories);
        LRESULT BuildComponentList(CArray <CComponentCategory::COMPONENTINFO*, 
                                    CComponentCategory::COMPONENTINFO*>& arpComponents);
        void _ValidatePage(void);
    
        WTL::CListViewCtrl* m_pListCtrl;
        CComboBoxEx2*       m_pComboBox;
        CComponentCategory* m_pComponentCategory;
};


/////////////////////////////////////////////////////////////////////////////
// CActiveXPage2 dialog

class CActiveXPage2 : public CBasePropertyPage<CWizard97WelcomeFinishPage<CActiveXPage2> >
{
    typedef CActiveXPage2                                ThisClass;
    typedef CBasePropertyPage<CWizard97WelcomeFinishPage<CActiveXPage2> >    BaseClass;

    // Construction
    public:
        CActiveXPage2();
        ~CActiveXPage2();
    
        // Dialog Data
        enum { IDD = IDD_ACTIVEX_WIZPAGE2 };
        WTL::CEdit m_strDisplay;
    
    
        BOOL OnSetActive();
        BOOL OnKillActive();
        BOOL OnWizardFinish();
    
    // Implementation
    protected:
        BEGIN_MSG_MAP(ThisClass)
            COMMAND_HANDLER( IDC_DISPLAYTX, EN_UPDATE, OnUpdateTargetTX )
            MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
            CHAIN_MSG_MAP(BaseClass)
        END_MSG_MAP()
    
        // Generated message map functions
        LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
        LRESULT OnUpdateTargetTX( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

        void _ValidatePage(void);
};



#endif // __NEWNODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\nmtempl.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       NMTempl.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12/11/1996   RaviR   Created
//____________________________________________________________________________
//

#ifndef NMTEMPL_H
#define NMTEMPL_H


//____________________________________________________________________________
//
//  Template:      XMapIterator
//____________________________________________________________________________
//


template<typename _MAP, typename _KEY, typename _VALUE> class XMapIterator
{
public:
    typedef _MAP MAP;
    typedef _KEY KEY;
    typedef _VALUE VALUE;

// Constructor
    inline XMapIterator(MAP& map) : m_map(map), m_pos(NULL), m_bEnd(FALSE)
    { 
        Reset(); 
    }

// Attributes
    inline BOOL IsEnd() 
    { 
        return m_bEnd; 
    }

    inline operator VALUE () 
    { 
        return m_value; 
    }

    inline KEY& GetKey(void) 
    { 
        return m_key; 
    }

    inline VALUE& GetValue(void) 
    { 
        return m_value; 
    }

// Operations
    inline void Reset() 
    { 
        m_bEnd = FALSE;
        m_pos = m_map.GetStartPosition(); 

        if (m_pos)
            m_map.GetNextAssoc(m_pos, m_key, m_value); 
        else 
            m_bEnd = TRUE;
    }

    inline void Advance() 
    { 
        ASSERT(IsEnd() == FALSE); 

        if (m_pos)
            m_map.GetNextAssoc(m_pos, m_key, m_value); 
        else 
            m_bEnd = TRUE;
    }

// Implementation
private:   
    VALUE       m_value;
    KEY         m_key;
    MAP&        m_map;
    POSITION    m_pos;
    BOOL        m_bEnd;
};




HRESULT 
DataObject_GetHGLOBALData(
    IDataObject* piDataObject, 
    CLIPFORMAT cfClipFormat,
    HGLOBAL* phGlobal);


template <typename DATATYPE>
HRESULT ExtractData(IDataObject* pDO, CLIPFORMAT cf, DATATYPE* pDATATYPE)
{
    ASSERT(pDO != NULL);
    ASSERT(pDATATYPE!= NULL);

    if (pDO == NULL || pDATATYPE == NULL)
        return E_POINTER;

    HGLOBAL hGlobal = NULL;
    HRESULT hr = DataObject_GetHGLOBALData(pDO, cf, &hGlobal);
    if (FAILED(hr))
        return hr;

    DATATYPE* pdata = reinterpret_cast<DATATYPE*>(::GlobalLock(hGlobal));
    ASSERT(pdata != NULL);
    *pDATATYPE = *pdata;
    ::GlobalUnlock(hGlobal);
    ::GlobalFree(hGlobal);
    
    return S_OK;
}




#endif // NMTEMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\nmutil.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      nmutil.h
 *
 *  Contents:  
 *
 *  History:   
 *
 *--------------------------------------------------------------------------*/

#ifndef _MMC_UTIL_H_
#define _MMC_UTIL_H_
#pragma once

class CComponentPtrArray;
class CResultItem;

COMPONENTID GetComponentID(CNode* pNode, CResultItem* pri = 0);
CComponent* GetComponent(CNode* pNode, CResultItem* pri = 0);
void GetComponentsForMultiSel(CNode* pNode, CComponentPtrArray& rgComps);


#endif // _MMC_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\node.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       Node.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9/16/1996   RaviR   Created
//
//____________________________________________________________________________

#include "stdafx.h"
#include "macros.h"
#include "strings.h"
#include "ndmgr.h"
#include "regutil.h"
#include "taskenum.h"
#include "nodemgr.h"
#include "multisel.h"
#include "rsltitem.h"
#include "colwidth.h"
#include "viewpers.h"
#include "tasks.h"
#include "conview.h"
#include "columninfo.h"
#include "util.h" // for CoTaskDupString
#include "mmcprotocol.h"
#include "nodemgrdebug.h"
#include "copypast.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*+-------------------------------------------------------------------------*
 * class CConsoleTaskpadViewExtension
 *
 *
 * PURPOSE: Implements console taskpads as a view extension
 *
 *+-------------------------------------------------------------------------*/
class CConsoleTaskpadViewExtension
{
public:
    /*+-------------------------------------------------------------------------*
     *
     * ScGetViews
     *
     * PURPOSE: Adds all console taskpad views to the view extension callback.
     *
     * PARAMETERS:
     *    CNode *   pNode                                   :
     *    LPVIEWEXTENSIONCALLBACK    pViewExtensionCallback :
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    static SC ScGetViews(CNode *pNode, LPVIEWEXTENSIONCALLBACK   pViewExtensionCallback)
    {
        DECLARE_SC(sc, TEXT("CConsoleTaskpadViewExtension::ScGetViews"));

        CScopeTree* pScopeTree = CScopeTree::GetScopeTree();

        sc = ScCheckPointers(pNode, pViewExtensionCallback, pScopeTree, E_FAIL);
        if(sc)
            return sc;

        // get a filtered list of taskpads that apply to this node.
        CConsoleTaskpadFilteredList filteredList;

        sc = pScopeTree->GetConsoleTaskpadList()->ScGetTaskpadList(pNode, filteredList);
        if(sc)
            return sc;

        for(CConsoleTaskpadFilteredList::iterator iter = filteredList.begin(); iter!= filteredList.end(); ++iter)
        {
            CConsoleTaskpad *pConsoleTaskpad = *iter;
            sc = ScAddViewForTaskpad(pConsoleTaskpad, pViewExtensionCallback);
            if(sc)
                return sc;
        }


        return sc;
    }


    /*+-------------------------------------------------------------------------*
     * ScGetTaskpadViewExtension
     *
     * Returns S_OK if the given CLSID matches the CLSID of any taskpad view
     * extension for the given node, S_FALSE or error otherwise.
     *--------------------------------------------------------------------------*/

    static SC ScGetViewExtensionTaskpad (CNode* pNode, const CLSID& clsid, CConsoleTaskpad*& pConsoleTaskpad)
    {
        DECLARE_SC (sc, _T("CConsoleTaskpadViewExtension::ScGetTaskpadViewExtension"));

        /*
         * initialize output
         */
        pConsoleTaskpad = NULL;

        /*
         * check input
         */
        sc = ScCheckPointers (pNode);
        if(sc)
            return sc;

        CScopeTree* pScopeTree = CScopeTree::GetScopeTree();
        sc = ScCheckPointers (pScopeTree, E_UNEXPECTED);
        if (sc)
            return (sc);

        // get a filtered list of taskpads that apply to this node.
        CConsoleTaskpadFilteredList filteredList;

        sc = pScopeTree->GetConsoleTaskpadList()->ScGetTaskpadList(pNode, filteredList);
        if(sc)
            return sc;

        for(CConsoleTaskpadFilteredList::iterator iter = filteredList.begin(); iter!= filteredList.end(); ++iter)
        {
            CConsoleTaskpad* pTempConsoleTaskpad = *iter;
            sc = ScCheckPointers (pTempConsoleTaskpad, E_UNEXPECTED);
            if (sc)
                return (sc);

            /*
             * if the CLSID matches the ID of this taskpad, CLSID refers to
             * a taskpad view extension
             */
            if (clsid == pTempConsoleTaskpad->GetID())
            {
                pConsoleTaskpad = pTempConsoleTaskpad;
                break;
            }
        }

        return (sc);
    }

private:


    /*+-------------------------------------------------------------------------*
     *
     * ScAddViewForTaskpad
     *
     * PURPOSE: Adds a view based on a console taskpad to the view extension
     *          callback.
     *
     * PARAMETERS:
     *    CConsoleTaskpad *        pConsoleTaskpad :
     *    LPVIEWEXTENSIONCALLBACK  pViewExtensionCallback :
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    static SC ScAddViewForTaskpad(CConsoleTaskpad *pConsoleTaskpad, LPVIEWEXTENSIONCALLBACK pViewExtensionCallback)
    {
        DECLARE_SC(sc, TEXT("CConsoleTaskpadViewExtension::ScAddViewForTaskpad"));

        // validate inputs
        sc = ScCheckPointers(pConsoleTaskpad, pViewExtensionCallback);
        if(sc)
            return sc;

        MMC_EXT_VIEW_DATA extViewData = {0};

        // get the string form of the taskpad ID.
        CCoTaskMemPtr<WCHAR> spszTaskpadID;
        sc = StringFromCLSID (pConsoleTaskpad->GetID(), &spszTaskpadID);
        if (sc)
            return sc;

        std::wstring strTaskpad = _W(MMC_PROTOCOL_SCHEMA_NAME) _W(":");
        strTaskpad += spszTaskpadID;

        extViewData.pszURL = strTaskpad.c_str();

        extViewData.bReplacesDefaultView = pConsoleTaskpad->FReplacesDefaultView() ? TRUE : FALSE; // convert from bool to BOOL
        extViewData.viewID       = pConsoleTaskpad->GetID();                            // set the GUID identifier of the view

        USES_CONVERSION;
        tstring strName = pConsoleTaskpad->GetName();
        extViewData.pszViewTitle = T2COLE(strName.data()); // set the title of the view

        if(!extViewData.pszViewTitle)
            return (sc = E_OUTOFMEMORY).ToHr();

        sc = pViewExtensionCallback->AddView(&extViewData);

        return sc;
    }

};

//############################################################################
//############################################################################
//
//  Implementation of class CComponent
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(CComponent);

void CComponent::Construct(CSnapIn * pSnapIn, CComponent* pComponent)
{
    ASSERT(pSnapIn);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponent);

    m_spSnapIn = pSnapIn;
    m_ComponentID = -1;
    m_bIComponentInitialized = false;

    if (pComponent)
    {
        ASSERT(pComponent->m_spIComponent != NULL);
        ASSERT(pComponent->m_spIFrame != NULL);

        m_spIComponent = pComponent->m_spIComponent;
        m_spIFrame = pComponent->m_spIFrame;
        m_spIRsltImageList = pComponent->m_spIRsltImageList;

        m_ComponentID = pComponent->GetComponentID();
    }
}

CComponent::~CComponent()
{
    DECLARE_SC(sc, TEXT("CComponent::~CComponent"));

    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponent);

    if (m_spIFrame)
    {
        sc = m_spIFrame->SetHeader(NULL);
        if (sc)
            sc.TraceAndClear();
    }

    if (m_spIComponent)
    {
        sc = m_spIComponent->Destroy(NULL);
        if (sc)
            sc.TraceAndClear();
    }
}

HRESULT CComponent::Init(IComponentData* pIComponentData, HMTNODE hMTNode,
                         HNODE lNode,
                         COMPONENTID nComponentID, int viewID)
{
    DECLARE_SC(sc, TEXT("CComponent::Init"));

    ASSERT(hMTNode != 0);
    ASSERT(lNode != 0);

    sc = ScCheckPointers( pIComponentData, E_POINTER );
    if (sc)
        return sc.ToHr();

    do
    {
        sc = pIComponentData->CreateComponent(&m_spIComponent);
        if (sc)
            break;

        // recheck the pointers
        sc = ScCheckPointers( m_spIComponent, E_UNEXPECTED );
        if (sc)
            break;

        // Create an IFrame for this IComponent
        #if _MSC_VER>=1100
        sc = m_spIFrame.CreateInstance(CLSID_NodeInit, NULL, MMC_CLSCTX_INPROC);
        #else
        sc = m_spIFrame.CreateInstance(CLSID_NodeInit, MMC_CLSCTX_INPROC);
        #endif
        if (sc)
            break;

        // recheck the pointer
        sc = ScCheckPointers( m_spIFrame, E_UNEXPECTED );
        if (sc)
            break;

        Debug_SetNodeInitSnapinName(m_spSnapIn, m_spIFrame.GetInterfacePtr());

        // Cache the IComponent in the NodeInit object
        sc = m_spIFrame->SetComponent(m_spIComponent);
        if (sc)
            break;

        // recheck the pointer
        sc = ScCheckPointers( m_spSnapIn, E_UNEXPECTED );
        if (sc)
            break;

        // Create scope image list
        sc = m_spIFrame->CreateScopeImageList(m_spSnapIn->GetSnapInCLSID());
        if (sc)
            break;

        sc = m_spIFrame->SetNode(hMTNode, lNode);
        if (sc)
            break;

        ASSERT(nComponentID == GetComponentID());
        sc = m_spIFrame->SetComponentID(nComponentID);
        if (sc)
            break;

        // Result Image list is optional
        m_spIRsltImageList = m_spIFrame;
        sc = ScCheckPointers( m_spIRsltImageList, E_FAIL );
        if (sc)
            sc.TraceAndClear();

        // Complete IComponent initialization.
        // Init m_spIComponent with m_spIFrame.
        sc = m_spIComponent->Initialize(m_spIFrame);
        if (sc)
            break;

        CMTNode* const pMTNode = CMTNode::FromHandle (hMTNode);
        sc = ScCheckPointers( pMTNode, E_UNEXPECTED );
        if (sc)
            break;

        CMTSnapInNode* const pSnapInNode = pMTNode->GetStaticParent();
        sc = ScCheckPointers( pSnapInNode, E_UNEXPECTED );
        if (sc)
            break;

        sc = pSnapInNode->ScInitIComponent(this, viewID);
        if (sc)
            break;

    } while (0);

    if (sc)
    {
        m_spIComponent = NULL;
        m_spIFrame = NULL;
        m_spIRsltImageList = NULL;
    }

    return sc.ToHr();
}

inline HRESULT CComponent::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event,
                                  LONG_PTR arg, LPARAM param)
{
    ASSERT(m_spIComponent != NULL);
    if (m_spIComponent == NULL)
        return E_FAIL;

    HRESULT hr = S_OK;
    __try
    {
        hr = m_spIComponent->Notify(lpDataObject, event, arg, param);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_FAIL;

        if (m_spSnapIn)
            TraceSnapinException(m_spSnapIn->GetSnapInCLSID(), TEXT("IComponent::Notify"), event);
    }

    return hr;
}

SC CComponent::ScQueryDispatch(MMC_COOKIE cookie,
                                      DATA_OBJECT_TYPES type,
                                      PPDISPATCH ppSelectedObject)
{
    DECLARE_SC(sc, _T("CComponent::ScQueryDispatch"));
    sc = ScCheckPointers(m_spIComponent, E_UNEXPECTED);
    if (sc)
        return sc;

    IComponent2Ptr spComponent2 = m_spIComponent;
    sc = ScCheckPointers(spComponent2.GetInterfacePtr(), E_NOINTERFACE);
    if (sc)
        return sc;

    sc = spComponent2->QueryDispatch(cookie, type, ppSelectedObject);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CComponent::ScResetConsoleVerbStates
//
//  Synopsis:    Reset the verbstates in the CConsoleVerbImpl (the one
//               snapin is aware of).
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent::ScResetConsoleVerbStates ()
{
    DECLARE_SC(sc, _T("CComponent::ScResetConsoleVerbStates"));

    IFramePrivate* pIFP = GetIFramePrivate();
    sc = ScCheckPointers(pIFP, E_UNEXPECTED);
    if (sc)
        return sc;

    IConsoleVerbPtr spConsoleVerb;
    sc = pIFP->QueryConsoleVerb(&spConsoleVerb);
    if (sc)
        return sc;

    sc = ScCheckPointers(spConsoleVerb, E_UNEXPECTED);
    if (sc)
        return sc;

    CConsoleVerbImpl* pCVI = dynamic_cast<CConsoleVerbImpl*>(
                                             static_cast<IConsoleVerb*>(spConsoleVerb));
    sc = ScCheckPointers(pCVI, E_UNEXPECTED);
    if (sc)
        return sc;

    pCVI->SetDisabledAll();

    return (sc);
}


//############################################################################
//############################################################################
//
//  Implementation of class CNode
//
//############################################################################
//############################################################################


DEBUG_DECLARE_INSTANCE_COUNTER(CNode);

CNode::CNode (
    CMTNode*    pMTNode,
    CViewData*  pViewData,
    bool        fRootNode) :
    m_pMTNode           (pMTNode),
    m_pViewData         (pViewData),
    m_hri               (0),
    m_dwFlags           (0),
    m_pPrimaryComponent (NULL),
    m_bInitComponents   (TRUE),
    m_fRootNode         (fRootNode),
    m_fStaticNode       (false)
{
    CommonConstruct();
}

CNode::CNode (
    CMTNode*    pMTNode,
    CViewData*  pViewData,
    bool        fRootNode,
    bool        fStaticNode) :
    m_pMTNode           (pMTNode),
    m_pViewData         (pViewData),
    m_hri               (0),
    m_dwFlags           (0),
    m_pPrimaryComponent (NULL),
    m_bInitComponents   (TRUE),
    m_fRootNode         (fRootNode),
    m_fStaticNode       (fStaticNode)
{
    CommonConstruct();
}

CNode::CNode(const CNode& other) :
    m_pMTNode           (other.m_pMTNode),
    m_pViewData         (other.m_pViewData),
    m_hri               (other.m_hri),
    m_dwFlags           (other.m_dwFlags),
    m_pPrimaryComponent (other.m_pPrimaryComponent),
    m_bInitComponents   (other.m_bInitComponents),
    m_fRootNode         (other.m_fRootNode),
    m_fStaticNode       (other.m_fStaticNode)
{
    CommonConstruct();
}


void CNode::CommonConstruct ()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CNode);

    ASSERT (m_pMTNode != NULL);
    m_pMTNode->AddRef();
}


CNode::~CNode()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CNode);

    CDataObjectCleanup::ScUnadviseNode( this );

    /*
     * if this is a non-static root node, delete the static
     * parent node that was created for us in CMTNode::GetNode
     */
    if (IsRootNode() && !IsStaticNode())
        delete GetStaticParent();

    ASSERT (m_pMTNode != NULL);
    m_pMTNode->Release();
}


/*+-------------------------------------------------------------------------*
 * CNode::FromResultItem
 *
 * Converts a CResultItem to the CNode it references.  This should only
 * be called for CResultItems that represent scope items.
 *
 * This function is out-of-line to eliminate coupling between node.h and
 * rsltitem.h.
 *--------------------------------------------------------------------------*/

CNode* CNode::FromResultItem (CResultItem* pri)
{
    CNode* pNode = NULL;

    if (pri != NULL)
    {
        /*
         * only call for scope items
         */
        ASSERT (pri->IsScopeItem());

        if (pri->IsScopeItem())
            pNode = CNode::FromHandle (pri->GetScopeNode());
    }

    return (pNode);
}

HRESULT
CNode::OnExpand(bool fExpand)
{
    HRESULT hr = S_OK;

    if (fExpand == FALSE)
    {
        return (WasExpandedAtLeastOnce() == TRUE) ? S_OK : S_FALSE;
    }

    if (WasExpandedAtLeastOnce() == TRUE)
        return S_FALSE;

    CMTNode* pMTNode = GetMTNode();

    if (pMTNode->WasExpandedAtLeastOnce() == FALSE)
        hr = pMTNode->Expand();

    return hr;
}

void CNode::ResetControlbars(BOOL bSelect, SELECTIONINFO* pSelInfo)
{
    ASSERT(pSelInfo != NULL);

    CViewData* pVD = GetViewData();
    ASSERT(pVD != NULL);
    if (!pVD)
        return;

    // Reset controlbars
    CControlbarsCache* pCtrlbarsCache =
        dynamic_cast<CControlbarsCache*>(GetControlbarsCache());
    ASSERT(pCtrlbarsCache != NULL);

    if (pCtrlbarsCache != NULL)
    {
        if (pSelInfo->m_bScope == TRUE)
            pCtrlbarsCache->OnScopeSelChange(this, bSelect);
        else if (pSelInfo->m_bBackground == FALSE)
            pCtrlbarsCache->OnResultSelChange(this, pSelInfo->m_lCookie,
                                              bSelect);
    }
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScInitializeVerbs
//
//  Synopsis:    Selection has changed so initialize the verbs for given
//               selection information.
//
//  Arguments:   [bSelect]  - [in] Select or Deselect of an item.
//               [pSelInfo] - [in] SELECTIONINFO ptr.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScInitializeVerbs (bool bSelect, SELECTIONINFO* pSelInfo)
{
    DECLARE_SC(sc, _T("CNode::ScInitializeVerbs"));
    sc = ScCheckPointers(pSelInfo);
    if (sc)
        return sc;

    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    CVerbSet *pVerbSet = dynamic_cast<CVerbSet*>(pViewData->GetVerbSet());
    sc = ScCheckPointers(pVerbSet, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = pVerbSet->ScInitialize(this, pSelInfo->m_bScope, bSelect,
                                pSelInfo->m_bBackground, pSelInfo->m_lCookie);
    if (sc)
        return sc;

    return (sc);
}


HRESULT CNode::GetDispInfo(LV_ITEMW* plvi)
{
    DECLARE_SC(sc, TEXT("CNode::GetDispInfo"));

    sc = ScCheckPointers(plvi);
    if(sc)
        return sc.ToHr();

    if (plvi->iSubItem == 0)
    {
        if (plvi->mask & LVIF_IMAGE)
        {
            plvi->iImage = GetResultImage();
            ASSERT (plvi->iImage != -1);
            if (plvi->iImage == -1)
                plvi->iImage = 0;
        }

        if (plvi->mask & LVIF_TEXT)
        {
            tstring strName = GetDisplayName();

            if (!strName.empty())
            {
                USES_CONVERSION;
                sc = StringCchCopyW (plvi->pszText, plvi->cchTextMax, T2CW (strName.data()));
                if(sc)
                    return sc.ToHr();
            }
            else
                plvi->pszText[0] = 0;
        }
    }
    else if ((plvi->mask & LVIF_TEXT) && (plvi->cchTextMax > 0))
    {
        plvi->pszText[0] = 0;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     ScGetDataObject
//
//  Synopsis:   Given scope/result and cookie (lParam, if it is result item),
//              get the dataobject of the item.
//
//  Arguments:
//              [bScopePane]        - [in] Scope or Result.
//              [lResultItemCookie] - [in] If Result pane is selected the item param.
//              [bScopeItem]        - [out] Is the dataobject returned for scope or result item.
//                                          The scope item can be in result pane.
//              [ppDataObject]      - [out] The data-object (return val)
//              [ppCComponent]      - [out] NULL def parameter. The CComponent of the item. In case
//                                          of multiselection, the items may belong to more than one
//                                          component so a NULL is returned.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CNode::ScGetDataObject(bool bScopePane, LPARAM lResultItemCookie, bool& bScopeItem,
                          LPDATAOBJECT* ppDataObject, CComponent **ppCComponent /*= NULL*/,
						  CNode **ppOwnerNode /*= NULL*/)
{
    DECLARE_SC(sc, _T("CNode::ScGetDataObject"));
    IDataObjectPtr spDataObject;
    CComponent    *pCC = NULL;

    if (ppDataObject == NULL)
        return (sc = E_POINTER);

    *ppDataObject = NULL; // init
    if (ppCComponent)
        *ppCComponent = NULL;
	if (ppOwnerNode)
		*ppOwnerNode = this;

    bScopeItem = bScopePane;

    // In MMC1.0 when result pane background is selected, for any
    // toolbar operation we pass the dataobject of scope selected item.
    // The following code is added for this compatibility.
    if (lResultItemCookie == LVDATA_BACKGROUND) // =>Result background has focus
    {
        bScopeItem = TRUE;
    }

    if (bScopeItem) // => Scope pane has focus
    {
        CMTNode* pMTNode = GetMTNode();
        if (NULL == pMTNode)
            return (sc = E_UNEXPECTED);
        sc = pMTNode->QueryDataObject(CCT_SCOPE, &spDataObject);
        if (sc)
            return sc;

        pCC = GetPrimaryComponent();
    }
    else if (lResultItemCookie == LVDATA_CUSTOMOCX) // => Custom OCX has focus
    {
        *ppDataObject = DOBJ_CUSTOMOCX;
        pCC = GetPrimaryComponent();
    }
    else if (lResultItemCookie == LVDATA_CUSTOMWEB) // => Web has focus
    {
        *ppDataObject = DOBJ_CUSTOMWEB;
        pCC = GetPrimaryComponent();
    }
    else if (lResultItemCookie == LVDATA_MULTISELECT) // => multi selection
    {
        // Do not calculate CComponent for multisel dataobject as there are multiple
        // items and they can be from different snapins (so different components).
        CViewData* pVD = GetViewData();
        if (NULL == pVD)
            return (sc = E_UNEXPECTED);

        CMultiSelection* pMS = pVD->GetMultiSelection();
        if (NULL == pMS)
            return (sc = E_UNEXPECTED);

        sc = pMS->GetMultiSelDataObject(ppDataObject);
        if (sc)
            return sc;
    }
    else // result item has focus
    {
        CViewData* pVD = GetViewData();
        if (NULL == pVD)
            return (sc = E_UNEXPECTED);

        if (! pVD->IsVirtualList())
        {
            CResultItem* pri = CResultItem::FromHandle (lResultItemCookie);

            if (pri != NULL)
            {
                bScopeItem = pri->IsScopeItem();
                lResultItemCookie = pri->GetSnapinData();

                if (! bScopeItem)
                    pCC = GetComponent(pri->GetOwnerID());
            }
        }
        else
            pCC = GetPrimaryComponent();

        if (bScopeItem)
        {
            CNode* pNode = CNode::FromHandle((HNODE) lResultItemCookie);
            CMTNode* pMTNode = pNode ? pNode->GetMTNode() : NULL;

            if (NULL == pMTNode)
                return (sc = E_UNEXPECTED);

			if (ppOwnerNode)
				*ppOwnerNode = pNode;

            sc = pMTNode->QueryDataObject(CCT_SCOPE, &spDataObject);
            if (sc)
                return sc;

            pCC = pNode->GetPrimaryComponent();
            sc = ScCheckPointers(pCC, E_UNEXPECTED);
            if (sc)
                return sc;
        }
        else
        {
            if (NULL == pCC)
                return (sc = E_UNEXPECTED);
            sc = pCC->QueryDataObject(lResultItemCookie, CCT_RESULT, &spDataObject);
            if (sc)
                return sc;
        }
    }

    // if required, get the component of this node
    if (ppCComponent)
    {
        *ppCComponent = pCC;
        sc = ScCheckPointers( *ppCComponent, E_UNEXPECTED );
        if (sc)
            return sc;
    }

    if (SUCCEEDED(sc.ToHr()) && *ppDataObject == NULL)
        *ppDataObject = spDataObject.Detach();

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CNode::ScGetDropTargetDataObject
//
//  Synopsis:    Given the context get the data object that allows the
//               to be drop target (allows paste).
//
//               In MMC1.2 the drop target is always scope node. In MMC2.0
//               it can be any non-virtual (??) result item. If the snapin
//               has RVTI_LIST_OPTIONS_ALLOWPASTE set, then if the item selected
//               is in result pane then data object corresponds to result item
//               else it is scope item.
//
//  Arguments:
//              [bScopePane]        - Scope or Result.
//              [lResultItemCookie] - If Result pane is selected the item param.
//              [ppDataObject]      - The data-object (return val)
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScGetDropTargetDataObject(bool bScopePane, LPARAM lResultItemCookie, LPDATAOBJECT *ppDataObject)
{
    DECLARE_SC(sc, _T("CNode::ScGetDropTargetDataObject"));
    sc = ScCheckPointers(ppDataObject);
    if (sc)
        return sc;

    *ppDataObject = NULL;

    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    if (pViewData->GetListOptions() & RVTI_LIST_OPTIONS_ALLOWPASTE)
    {
        bool bScopeItem;
        // MMC2.0 use the given context.
        sc = ScGetDataObject(bScopePane, lResultItemCookie, bScopeItem, ppDataObject);
        if (sc)
            return sc;
    }
    else
    {
        // MMC1.2 Always scope node.
        sc = QueryDataObject(CCT_SCOPE, ppDataObject);
        if (sc)
            return sc;
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CNode::ScGetPropertyFromINodeProperties
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    BOOL    bForScopeItem :
 *    LPARAM  resultItemParam :
 *    BSTR    bstrPropertyName :
 *    PBSTR   pbstrPropertyValue :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CNode::ScGetPropertyFromINodeProperties(LPDATAOBJECT pDataObject, BOOL bForScopeItem, LPARAM resultItemParam, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue)
{
    //DECLARE_SC(sc, TEXT("CNode::ScGetPropertyFromINodeProperties"));
    SC sc; // do not use DECLARE_SC here - want to silently ignore errors

    sc = ScCheckPointers(pDataObject, bstrPropertyName, pbstrPropertyValue);
    if(sc)
        return sc;

    if(bForScopeItem)
    {
        // get the MTNode
        CMTNode * pMTNode = GetMTNode();

        sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
        if(sc)
            return sc;

        // ask MTNode to get it
        sc = pMTNode->ScGetPropertyFromINodeProperties(pDataObject, bstrPropertyName, pbstrPropertyValue);
        if(sc)
            return sc;

        // done!
        return sc;
    }

    // for result item.

    CComponent *pComponent = GetPrimaryComponent();

    sc = ScCheckPointers(pComponent);
    if(sc)
    {
        SC scRet = sc; // returns but does not trace the error
        sc.Clear();
        return scRet;
    }

    // get the IComponent and QI for INodeProperties
    INodePropertiesPtr spNodeProperties  = pComponent->GetIComponent();

    // at this point we should have a valid interface if it is supported
    sc = ScCheckPointers(spNodeProperties, E_NOINTERFACE);
    if(sc)
        return sc;

    sc = spNodeProperties->GetProperty(pDataObject,  bstrPropertyName, pbstrPropertyValue);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CNode::ScExecuteShellCommand
 *
 * PURPOSE: Executes a shell command with the specified parameters in the
 *          specified directory with the correct window size
 *
 * PARAMETERS:
 *    BSTR  Command :
 *    BSTR  Directory :
 *    BSTR  Parameters :
 *    BSTR  WindowState :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CNode::ScExecuteShellCommand(BSTR Command, BSTR Directory, BSTR Parameters, BSTR WindowState)
{
    DECLARE_SC(sc, TEXT("CNode::ScExecuteShellCommand"));

    sc = ScCheckPointers(Command, Directory, Parameters, WindowState);
    if(sc)
        return sc;

    USES_CONVERSION;

    CStr strParameters = W2T(Parameters);
    CStr strWindowState= W2T(WindowState);

    if(strWindowState.GetLength()==0)
        strWindowState= XML_ENUM_WINDOW_STATE_RESTORED; // normal

    SHELLEXECUTEINFO sei;
    ZeroMemory (&sei, sizeof(sei));

    sei.cbSize       = sizeof(sei);
    sei.lpFile       = W2T(Command);
    sei.lpParameters = strParameters;
    sei.lpDirectory  = W2T(Directory);
    sei.fMask        = SEE_MASK_NOCLOSEPROCESS | SEE_MASK_DOENVSUBST;

    sei.nShow        = (strWindowState == XML_ENUM_WINDOW_STATE_MAXIMIZED) ? SW_SHOWMAXIMIZED :
                       (strWindowState == XML_ENUM_WINDOW_STATE_MINIMIZED) ? SW_SHOWMINIMIZED :
                                                                             SW_SHOWNORMAL ;

    if (ShellExecuteEx(&sei))
        CloseHandle (sei.hProcess);
    else
        sc = ScFromWin32((GetLastError ()));

    return sc;
}

//############################################################################
//############################################################################
//
//  Implementation of class COCX
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(COCX);


//############################################################################
//############################################################################
//
//  Implementation of class COCXNode
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(COCXNode);


HRESULT CNode::InitComponents()
{
    DECLARE_SC(sc, TEXT("CNode::InitComponents"));

    if (m_bInitComponents == FALSE)
        return S_OK;

    HRESULT hr = S_OK;

    // Initialize the component.

    CMTNode * pMTNode = GetMTNode();
    if (pMTNode == NULL)
        return (E_UNEXPECTED);

    // Ensure the master node is initialized.
    if (!pMTNode->IsInitialized())
        hr = pMTNode->Init();

    if (FAILED(hr))
        return hr;

    CMTSnapInNode* pMTSnapInNode = pMTNode->GetStaticParent();
    if (pMTSnapInNode == NULL)
        return (E_UNEXPECTED);

    HMTNODE hMTNode = CMTNode::ToHandle(pMTSnapInNode);
    HNODE   hNode   = CNode::ToHandle(GetStaticParent());

    CSnapIn* pSnapIn = pMTNode->GetPrimarySnapIn();
    if (pSnapIn == NULL)
        return (E_UNEXPECTED);

    CComponentData* pCCD = pMTSnapInNode->GetComponentData(pSnapIn->GetSnapInCLSID());
    if (pCCD == NULL)
        return E_FAIL;

    if (m_pPrimaryComponent == NULL)
        m_pPrimaryComponent = pMTSnapInNode->GetComponent(GetViewID(),
                                            pCCD->GetComponentID(), pSnapIn);

    if(m_pPrimaryComponent == NULL)
        return E_UNEXPECTED;

    ASSERT(m_pPrimaryComponent != NULL);

    //
    // Init PRIMARY Component.
    //

    if (!m_pPrimaryComponent->IsInitialized())
    {
        ASSERT(pCCD->GetComponentID() == m_pPrimaryComponent->GetComponentID());

        hr = m_pPrimaryComponent->Init(pCCD->GetIComponentData(), hMTNode, hNode,
                                       pCCD->GetComponentID(), GetViewID());

        // Abort if PRIMARY Component fails to init.
        if (FAILED(hr))
            return hr;
    }

    m_bInitComponents = FALSE;

    //
    // Now initalize the extension components. (create them if necessary)
    //

    // Get the node-type of this node
    GUID guidNodeType;
    //hr = pCCD->GetNodeType(pMTNode->GetUserParam(), &guidNodeType);
    hr = pMTNode->GetNodeType(&guidNodeType);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;

    LPCLSID pDynExtCLSID;
    int cDynExt = pMTNode->GetDynExtCLSID(&pDynExtCLSID);

    CExtensionsIterator it;
    // TODO: try to use the easier form of it.ScInitialize()
    sc = it.ScInitialize(pSnapIn, guidNodeType, g_szNameSpace, pDynExtCLSID, cDynExt);
    if(sc)
        return S_FALSE;

    BOOL fProblem = FALSE;

    for (; it.IsEnd() == FALSE; it.Advance())
    {
        pCCD = pMTSnapInNode->GetComponentData(it.GetCLSID());
        if (pCCD == NULL)
            continue;

        CComponent* pCC = pMTSnapInNode->GetComponent(GetViewID(),
                                pCCD->GetComponentID(), pCCD->GetSnapIn());

        if (pCC->IsInitialized() == TRUE)
            continue;

        hr = pCC->Init(pCCD->GetIComponentData(), hMTNode, hNode,
                       pCCD->GetComponentID(), GetViewID());

        CHECK_HRESULT(hr);
        if (FAILED(hr))
            fProblem = TRUE;    // Continue even on error.
    }

    if (fProblem == TRUE)
    {
        // TODO: Put up an error message.
        hr = S_FALSE;
    }

    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CNode::OnInitOCX
 *
 * PURPOSE: Sends the MMCN_INITOCX notification when an OCX is created.
 *
 * PARAMETERS:
 *    IUnknown* pUnk :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CNode::OnInitOCX(IUnknown* pUnk)
{
    DECLARE_SC(sc, TEXT("CNode::OnInitOCX"));

    IDataObjectPtr spdtobj;
    sc = QueryDataObject(CCT_SCOPE, &spdtobj);
    if(sc)
        return sc.ToHr();

    CComponent* pCC = GetPrimaryComponent();
    sc = ScCheckPointers(pCC);
    if(sc)
        return sc.ToHr();

    sc = pCC->Notify(spdtobj, MMCN_INITOCX, 0, reinterpret_cast<LPARAM>(pUnk));
    sc.Clear(); // must ignore errors here - Disk management returns E_UNEXPECTED.!

    return sc.ToHr();
}

HRESULT CNode::OnCacheHint(int nStartIndex, int nEndIndex)
{
    CComponent* pCC = GetPrimaryComponent();
    ASSERT(pCC != NULL);
    if (pCC == NULL)
        return E_FAIL;

    IResultOwnerDataPtr spIResultOwnerData = pCC->GetIComponent();
    if (spIResultOwnerData == NULL)
        return S_FALSE;

    return spIResultOwnerData->CacheHint(nStartIndex, nEndIndex);
}

/***************************************************************************\
 *
 * METHOD:  CNode::ScInitializeViewExtension
 *
 * PURPOSE: Sets callback representing view extension
 *
 * PARAMETERS:
 *    const CLSID& clsid    - [in] view extension CLSID
 *    CViewData *pViewData  - [in] view data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::ScInitializeViewExtension(const CLSID& clsid, CViewData *pViewData)
{
    DECLARE_SC(sc, TEXT("CNode::ScInitializeViewExtension"));

    sc = ScCheckPointers(pViewData);
    if (sc)
        return sc;

    /*
     * Get the CConsoleTaskpad that goes with it this view extension.
     * If this is an ordinary (i.e. not taskpad) view extension,
     * ScGetViewExtensionTaskpad will set pConsoleTaskpad to NULL.
     */
    CConsoleTaskpad* pConsoleTaskpad = NULL;
    sc = CConsoleTaskpadViewExtension::ScGetViewExtensionTaskpad (this, clsid, pConsoleTaskpad);
    if (sc)
        return (sc);

    typedef CComObject<CConsoleTaskCallbackImpl> t_ViewExtensionCallbackImpl;
    t_ViewExtensionCallbackImpl* pViewExtensionCallbackImpl = NULL;
    sc = t_ViewExtensionCallbackImpl::CreateInstance(&pViewExtensionCallbackImpl);
    if (sc)
        return sc;

    // recheck pointer
    sc = ScCheckPointers(pViewExtensionCallbackImpl, E_UNEXPECTED);
    if (sc)
        return sc;

    pViewData->m_spTaskCallback = pViewExtensionCallbackImpl; // this addrefs/releases the object.

    /*
     * If this is a taskpad, initialize the view extension callback as
     * a taskpad view extension.  Otherwise initialize it as an ordinary
     * view extension.
     */
    if (pConsoleTaskpad != NULL)
    {
        sc = pViewExtensionCallbackImpl->ScInitialize (pConsoleTaskpad,
                                                       CScopeTree::GetScopeTree(),
                                                       this);
    }
    else
        sc = pViewExtensionCallbackImpl->ScInitialize(clsid);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CNode::ScSetViewExtension
 *
 * PURPOSE: Forces a display of the given view extension.
 *
 * PARAMETERS:
 *    GUID * pGuidViewId : [IN]: The view extension to display.
 *    bool   bUseDefaultTaskpad : [IN}
 *    bool bSetViewSettingDirty : [IN] (See below notes)
 *
 * Note:
 * The view-extension-ID comes from
 *
 * 1. Viewsetting if one exists.
 * 2. Given by CONUI when user changes tab for different taskpad.
 * 3. There are cases in which a new view-extension installed (after the console
 *    file was created) that will be default. (This will be calculated in this method).
 *
 * In cases 1 & 3 viewsetting should not be made dirty.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CNode::ScSetViewExtension(GUID *pGuidViewId, bool bUseDefaultTaskpad, bool bSetViewSettingDirty)
{
    DECLARE_SC(sc, TEXT("CNode::ScSetViewExtension"));

    CViewData *     pViewData        = GetViewData();

    sc = ScCheckPointers(pGuidViewId, pViewData);
    if(sc)
        return sc;

    // collect the view extensions
    CViewExtCollection      vecExtensions;
    CViewExtInsertIterator  itExtensions(vecExtensions, vecExtensions.begin());
    sc = ScGetViewExtensions(itExtensions);
    if (sc)
        sc.Trace_();

    if ( bUseDefaultTaskpad )
    {
        // setup proper taskpad (tab to be selected)
        CViewExtCollection::iterator it = vecExtensions.begin();
        if (it != vecExtensions.end())
            *pGuidViewId = it->viewID; // first one if such exist
        else
            *pGuidViewId = GUID_NULL;  // default
    }
    else // locate the extension we need to select
    {
        // see if the extension really exist
        CViewExtCollection::iterator it = vecExtensions.begin();
        bool bDefaultIsReplaced = false;
        while (it != vecExtensions.end() && !IsEqualGUID(*pGuidViewId, it->viewID) )
        {
            bDefaultIsReplaced = bDefaultIsReplaced || it->bReplacesDefaultView;
            ++it;
        }

        // found it?
        bool bFound = (it != vecExtensions.end());
        // one more chance - we were looking for default and one will be added!
        bFound = bFound || ( IsEqualGUID( *pGuidViewId, GUID_NULL ) && !bDefaultIsReplaced );

        if ( !bFound )
        {
            sc = E_FAIL;
        }
    }

    if (sc) // extension missing! need to find the substitute
    {
         sc.Clear(); // ignore error

        // default to first extension or NORMAL view here
        CViewExtCollection::iterator it = vecExtensions.begin();
        if (it != vecExtensions.end())
            *pGuidViewId = it->viewID;  // first available
        else
            *pGuidViewId = GUID_NULL;   // "normal" if it's the only choice
    }

    // set the view extension if one really exist
    if (*pGuidViewId != GUID_NULL)
    {
        sc = ScInitializeViewExtension(*pGuidViewId, GetViewData());
        if (sc)
            sc.TraceAndClear(); // ignore and proceed
    }
    else
    {
        pViewData->m_spTaskCallback = NULL;
    }

    sc = ScSetTaskpadID(*pGuidViewId, bSetViewSettingDirty);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScGetResultPane
//
//  Synopsis:    Get the result pane data from snapin or persisted data.
//
//  Arguments:   [strResultPane]    -  Result pane name (If it is OCX/WEB)
//               [pViewOptions]     -  View options.
//               [pGuidTaskpadID]   -  If there is a task-pad the ID.
//
//  Returns:     SC
//
//  History:     04-29-1999       AnandhaG       Created
//
//--------------------------------------------------------------------
SC
CNode::ScGetResultPane(CResultViewType &rvt, GUID *pGuidTaskpadID)
{
    DECLARE_SC(sc, TEXT("CNode::ScGetResultPane"));
    sc = ScCheckPointers(pGuidTaskpadID);
    if (sc)
        return sc;

    CComponent *pComponent = GetPrimaryComponent();
    CViewData  *pViewData  = GetViewData();
    sc = ScCheckPointers(pComponent, pViewData, E_UNEXPECTED);
    if(sc)
        return sc;

    IComponent* pIComponent = pComponent->GetIComponent();
    sc = ScCheckPointers(pIComponent,  E_FAIL);
    if (sc)
        return sc;

    // 1. Setup any persisted/default console taskpads or view extensions.
    sc = ScSetupTaskpad(pGuidTaskpadID);
    if (sc)
        return sc;

    // 2. Get the persisted CResultViewType information.
    sc = ScGetResultViewType(rvt);
    if (sc)
        return sc;
    bool bResultViewDataIsPersisted = (sc == S_OK);

    bool bSnapinChangingView        = pViewData->IsSnapinChangingView();
    CResultViewType rvtOriginal;
    CStr strResultPane = _T(""); // init

    // 3. If there is persisted result-view-type data then ask the snapin if it
    //    wants to restore the result-view with this data. If snapin is changing
    //    its view (by re-selection of node) then dont ask this question.
    if (!bSnapinChangingView && bResultViewDataIsPersisted )
    {
        // 3.a) Ask snapin if it wants to restore the result-view with persisted data.
        sc = ScRestoreResultView(rvt);
        if (sc)
            return sc;

        if (S_OK == sc.ToHr()) // snapin accepted the resultviewtype settings so return.
            return sc;

        // 3.b) Snapin refused the persisted CResultViewType data so...

        // cache the data to see if we need to modify the settings
        rvtOriginal = rvt;
        // Throw away the data as it is not accepted by snapin.
        sc = rvt.ScReset();
        if (sc)
            return sc;
    }

    // 4. Ask the snapin for result-view-type data.
    IComponent2Ptr spIComponent2 = pIComponent;
    if(spIComponent2 != NULL)
    {
        // should be able to move all this to a separate function.
        RESULT_VIEW_TYPE_INFO rvti;
        ZeroMemory(&rvti, sizeof(rvti));

        // the snapin supports IComponent2. Use it to get the result view type.
        sc = spIComponent2->GetResultViewType2(GetUserParam(), &rvti);
        if(sc)
            return sc;

        // at this point, we have a valid RESULT_VIEW_TYPE_INFO structure. Initialize the contents into rvt, which zeros out the structure
        // and releases all the allocated strings
        sc = rvt.ScInitialize(rvti);
        if(sc)
            return sc;
    }
    else
    {
        // the snapin does not support IComponent2. Use IComponent to
        // get the result view type from the snapin.
        LPOLESTR pszView = NULL;
        long lViewOptions = 0;

        sc = pIComponent->GetResultViewType(GetUserParam(), &pszView, &lViewOptions);
        if(sc)
            return sc;

        sc = rvt.ScInitialize(pszView, lViewOptions);  // this also calls CoTaskMemFree on pszView
        if(sc)
            return sc;
    }

    /*
     * 5. Persist ResultViewType information only if
     * a. Snapin is changing the view OR
     * b. Snapin rejected the persisted view setting (we already
     *    made sure it is not changing the view above) and new view setting
     *    given is different from original one.
     */

    if ( bSnapinChangingView ||
        (bResultViewDataIsPersisted && (rvtOriginal != rvt)) )
    {
        sc = ScSetResultViewType(rvt);
        if (sc)
            return sc;
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScRestoreResultView
//
//  Synopsis:    Restore the result pane from given persisted data.
//
//  Arguments:   [rvt]    -  CResultViewType data used to restore result pane.
//
//  Returns:     SC, S_OK if successfully restored.
//                   S_FALSE if snapin refused to restore.
//
//  History:     04-29-1999       AnandhaG       Created
//
//--------------------------------------------------------------------
SC CNode::ScRestoreResultView(const CResultViewType& rvt)
{
    DECLARE_SC(sc, _T("CNode::ScRestoreResultView"));

    CComponent* pComponent = GetPrimaryComponent();
    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if (sc)
        return sc;

    IComponent2Ptr spIComponent2 = pComponent->GetIComponent();
    if( (spIComponent2 != NULL) && (!rvt.IsMMC12LegacyData()))
    {
        RESULT_VIEW_TYPE_INFO rvti;
        ZeroMemory(&rvti, sizeof(rvti));

        sc = rvt.ScGetResultViewTypeInfo (rvti);
        if (sc)
            return sc;

        // the snapin supports IComponent2. Use it to get the result view type.
        sc = spIComponent2->RestoreResultView(GetUserParam(), &rvti);
        if(sc)
        {
            // If snapin returns error, trace it and translate it to S_FALSE (snapin refused to restore).
            TraceSnapinError(TEXT("Snapin returned error from IComponent2::RestoreResultView"), sc);
            sc = S_FALSE;
            return sc;
        }

    }
    else
    {
        // the snapin does not support IComponent2. Use IComponent to
        // to restore the result view.
        LPCOLESTR pszView = NULL;
        long lViewOptions = 0;

        sc = rvt.ScGetOldTypeViewOptions(&lViewOptions);
        if (sc)
            return sc;

        IDataObjectPtr spdtobj;
        sc = QueryDataObject(CCT_SCOPE, &spdtobj);
        if (sc)
            return sc;

        // Notify MMC of persisted view being restored.
        MMC_RESTORE_VIEW mrv;
        ::ZeroMemory(&mrv, sizeof(mrv));
        mrv.cookie       = GetUserParam();
        mrv.dwSize       = sizeof(mrv);
        mrv.lViewOptions = lViewOptions;

        if (rvt.HasOCX())
        {
            pszView = rvt.GetOCX();
        }
        else if (rvt.HasWebBrowser())
        {
            pszView = rvt.GetURL();
        }

        if (pszView)
        {
            int cchViewType = wcslen(pszView) + 1;
            mrv.pViewType = (LPOLESTR)CoTaskMemAlloc( cchViewType * sizeof(OLECHAR) );
            sc = ScCheckPointers(mrv.pViewType, E_OUTOFMEMORY);
            if (sc)
                return sc;
            
            sc = StringCchCopyW(mrv.pViewType, cchViewType, pszView);
            if(sc)
                return sc;

            pszView = NULL; // Dont want to abuse it later.
        }

        // If the snapin handles this notification we use the persisted
        // data else call GetResultViewType of the snapin.
        BOOL bHandledRestoreView = FALSE;

        pComponent->Notify(spdtobj, MMCN_RESTORE_VIEW, (LPARAM)&mrv, (LPARAM)&bHandledRestoreView);
        CoTaskMemFree(mrv.pViewType);

        sc = (bHandledRestoreView) ? S_OK : S_FALSE;
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScRestoreViewMode
//
//  Synopsis:   If the view mode is persisted restore it.
//
//  Arguments:  None.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CNode::ScRestoreViewMode()
{
    DECLARE_SC(sc, _T("CNode::ScRestoreViewMode"));


    ULONG ulViewMode = 0;
    sc = ScGetViewMode(ulViewMode);
    if (sc != S_OK) // data not found or some error.
        return sc;

    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    // tell conui to change the list mode.
    CConsoleView* pConsoleView = pViewData->GetConsoleView();
    sc = ScCheckPointers(pConsoleView, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = pConsoleView->ScChangeViewMode (ulViewMode);
    if (sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CNode::ScSetupTaskpad
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    GUID *          pTaskpadID :      [OUT]: The guid of the taskpad, else GUID_NULL
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CNode::ScSetupTaskpad(GUID *pGuidTaskpadID)
{
    DECLARE_SC(sc, _T("CNode::SetupTaskpad"));
    sc = ScCheckPointers(pGuidTaskpadID);
    if (sc)
        return sc.ToHr();

    // this is the case when the document is closed. Do nothing
    // VERY IMPORTANT - don't remove. Several functions down the line
    // will barf and eventually cause a dialog to be displayed.
    if(!m_pViewSettingsPersistor) 
        return sc = S_FALSE;

    *pGuidTaskpadID = GUID_NULL;

    // Get the persisted taskpad id if there is one.
    sc = ScGetTaskpadID(*pGuidTaskpadID);
    if (sc)
        return sc;

    // restore the taskpad if we've got a ViewSettings object.
    // do not use default tab even in case view seting does not have a valid guid
    // it only means the "Default" tab needs to be selected
    // see bug #97001 - MMC does not persist select CTP when user returns to a node
    bool bUseDefaultTaskpad = ( sc == S_FALSE );

    // See ScSetViewExtension for parameter meaning.
    sc = ScSetViewExtension(pGuidTaskpadID, bUseDefaultTaskpad, /*bSetViewSettingDirty*/ false);

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CNode::ShowStandardListView
 *
 * PURPOSE:
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT CNode::ShowStandardListView()
{
    CComponent* pCC = GetPrimaryComponent();
    ASSERT(pCC != NULL);
    if (pCC == NULL)
        return E_FAIL;

    IDataObjectPtr spDataObject = NULL;
    HRESULT hr = QueryDataObject(CCT_SCOPE, &spDataObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    IExtendContextMenuPtr spIExtendContextMenu = pCC->GetIComponent();
    if(!spIExtendContextMenu.GetInterfacePtr())
        return S_FALSE;

    hr = spIExtendContextMenu->Command(MMCC_STANDARD_VIEW_SELECT, spDataObject);
    return hr;
}

HRESULT
CNode::OnListPad(LONG_PTR arg, LPARAM param)
{
    HRESULT hr = S_OK;

    IDataObjectPtr spdtobj;
    hr = QueryDataObject(CCT_SCOPE, &spdtobj);
    ASSERT(SUCCEEDED(hr));
    if (SUCCEEDED(hr))
    {
        CComponent* pCC = GetPrimaryComponent();
        ASSERT(pCC != NULL);
        hr = pCC->Notify(spdtobj, MMCN_LISTPAD, arg, param);
        CHECK_HRESULT(hr);
    }

    return hr;
}

HRESULT
CNode::OnGetPrimaryTask(IExtendTaskPad **ppExtendTaskPad)
{
    HRESULT hr = S_OK;

    IExtendTaskPadPtr spExtendTaskPad = GetPrimaryComponent()->GetIComponent();
    if (spExtendTaskPad == NULL)
       return E_NOINTERFACE;

    *ppExtendTaskPad = spExtendTaskPad.Detach();

    return hr;
}

IFramePrivate *
CNode::GetIFramePrivate()
{
    CComponent* pCC = GetPrimaryComponent();
    if (pCC == NULL)
        return (NULL);

    IFramePrivate* pFramePrivate = pCC->GetIFramePrivate();

    ASSERT (pFramePrivate != NULL);
    return (pFramePrivate);
}

HRESULT
CNode::GetTaskEnumerator(LPOLESTR pszTaskGroup, IEnumTASK** ppEnumTask)
{
    DECLARE_SC(sc, TEXT("CNode::GetTaskEnumerator"));

    ASSERT(pszTaskGroup != NULL);
    ASSERT(ppEnumTask != NULL);

    if (!pszTaskGroup|| !ppEnumTask)
        return E_INVALIDARG;

    *ppEnumTask = NULL; // init

    if (GetPrimaryComponent() == NULL)
    {
        ASSERT(0 && "UNexpected");
        return S_FALSE;
    }

    CMTNode* pMTNode = GetMTNode();
    ASSERT(pMTNode != NULL);

    CMTSnapInNode* pMTSnapIn = pMTNode->GetStaticParent();
    ASSERT(pMTSnapIn != NULL);

    CComponentData* pComponentData = pMTNode->GetPrimaryComponentData();
    ASSERT(pComponentData != NULL);

    GUID guidNodeType;
    HRESULT hr = pMTNode->GetNodeType(&guidNodeType);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    //
    // Add primary task pad.
    //

    IExtendTaskPadPtr spExtendTaskPad =
        GetPrimaryComponent()->GetIComponent();

    if (spExtendTaskPad == NULL)
        return S_FALSE;

    IDataObjectPtr spDataObject;
    hr = pMTNode->QueryDataObject(CCT_SCOPE, &spDataObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    IEnumTASKPtr spEnumTASK;
    hr = spExtendTaskPad->EnumTasks(spDataObject, pszTaskGroup, &spEnumTASK);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    CComObject<CTaskEnumerator>* pTaskEnumerator = new CComObject<CTaskEnumerator>;
    ASSERT(pTaskEnumerator != NULL);
    pTaskEnumerator->AddTaskEnumerator(pComponentData->GetCLSID(), spEnumTASK);

    IEnumTASKPtr spEnumTask = pTaskEnumerator;
    ASSERT(spEnumTask != NULL);
    if (spEnumTask)
        *ppEnumTask = spEnumTask.Detach();

    //
    // Add extension task pads.
    //
    CArray<GUID,GUID&> DynExtens;
    ExtractDynExtensions(spDataObject, DynExtens);

    CExtensionsIterator it;
    sc = it.ScInitialize(pComponentData->GetSnapIn(), guidNodeType, g_szTask, DynExtens.GetData(), DynExtens.GetSize());
    if (sc.IsError() || it.IsEnd() == TRUE)
        return S_OK;

    for (; it.IsEnd() == FALSE; it.Advance())
    {
        CComponentData* pCCD = pMTSnapIn->GetComponentData(it.GetCLSID());

        if (pCCD == NULL)
        {
            // See if taskpad extension supports IComponentData. If so, we will add the it to
            // the static node's component list and reuse the same instance each time its needed.
            IComponentDataPtr spIComponentData;
            hr = CreateSnapIn(it.GetCLSID(), &spIComponentData, FALSE);
            if (SUCCEEDED(hr))
            {
                CSnapInPtr spSnapIn;

                // If a dynamic extension, we have to get the snap-in ourselves
                // otherwise the iterator has it
                if (it.IsDynamic())
                {
                    CSnapInsCache* const pCache = theApp.GetSnapInsCache();
                    ASSERT(pCache != NULL);

                    SC sc = pCache->ScGetSnapIn(it.GetCLSID(), &spSnapIn);
                    ASSERT(!sc.IsError());

                    // On failure, continue with other extensions
                    if (sc)
                        continue;
                }
                else
                {
                    spSnapIn = it.GetSnapIn();
                }

                ASSERT(spSnapIn != NULL);

                pCCD = new CComponentData(spSnapIn);

                if (pCCD != NULL)
                {
                    pCCD->SetIComponentData(spIComponentData);
                    pMTSnapIn->AddComponentDataToArray(pCCD);

                }
            }
        }

        // Initialize and load component data if not already done
        if (pCCD != NULL && pCCD->IsInitialized() == FALSE)
        {
            sc = pCCD->Init(CMTNode::ToHandle(pMTSnapIn));

            if ( !sc.IsError() )
            {
                sc = pMTSnapIn->ScInitIComponentData(pCCD);
                if (sc)
                {
                    sc.TraceAndClear();
                    // On failure, continue with other extensions
                    continue;
                }
            }
            else
            {
                // if failed to initialize, remove it from the component data array
                pMTSnapIn->CompressComponentDataArray();
                sc.TraceAndClear();
                // On failure, continue with other extensions
                continue;
            }
        }

        IExtendTaskPadPtr spExtendTaskPad;

        if (pCCD)
        {
            CComponent* pCC = pMTSnapIn->GetComponent(GetViewID(),
                                    pCCD->GetComponentID(), pCCD->GetSnapIn());
            ASSERT(pCC != NULL);
            if (pCC)
            {
                // Ensure the IComponent is initialized.
                if (!pCC->IsInitialized())
                {
                    ASSERT(pCCD->GetComponentID() == pCC->GetComponentID());

                    hr = pCC->Init(pCCD->GetIComponentData(),
                                   CMTNode::ToHandle(pMTSnapIn),
                                   ToHandle(this),
                                   pCCD->GetComponentID(),
                                   GetViewID());

                    // Abort if PRIMARY Component fails to init.
                    if (FAILED(hr))
                        return hr;
                }

                spExtendTaskPad = pCC->GetIComponent();
            }
        }
        else
        {
            hr = spExtendTaskPad.CreateInstance(it.GetCLSID(),
                #if _MSC_VER >= 1100
                NULL,
                #endif
                MMC_CLSCTX_INPROC);

            ASSERT(SUCCEEDED(hr));
            if (FAILED(hr))
                continue;
        }

        if (spExtendTaskPad != NULL)
        {
            IEnumTASKPtr spEnumTASK;
            HRESULT hr = spExtendTaskPad->EnumTasks(spDataObject, pszTaskGroup,
                                                 &spEnumTASK);
            ASSERT(SUCCEEDED(hr));
            if (hr == S_OK)
                pTaskEnumerator->AddTaskEnumerator(it.GetCLSID(), spEnumTASK);
        }

    } // end for


    // Return S_OK rather than hr because a failed extension shouldn't prevent the
    // taskpad from coming up
    return S_OK;

}

HRESULT
CNode::GetListPadInfo(IExtendTaskPad* pExtendTaskPad, LPOLESTR szTaskGroup,
                                    MMC_ILISTPAD_INFO* pIListPadInfo)
{
    if ((GetPrimaryComponent()    == NULL)  )
    {
        ASSERT(0 && "Asking for ListPadInfo on a node that has no snapin");
        return S_FALSE;
    }

    // get primary snapin's IComponentData...
    CMTNode* pMTNode = GetMTNode();
    ASSERT(pMTNode != NULL);
    CComponentData* pComponentData = pMTNode->GetPrimaryComponentData();
    ASSERT(pComponentData != NULL);

    // ... so we can get CLSID
    pIListPadInfo->szClsid = NULL;
    HRESULT hr = StringFromCLSID (pComponentData->GetCLSID(), &pIListPadInfo->szClsid);
    ASSERT (pIListPadInfo->szClsid != NULL);
    if (pIListPadInfo->szClsid == NULL) {
        if (hr) return hr;
        else    return E_FAIL;  // just in case.
    }

    // finally call taskpad extension for info
    return pExtendTaskPad->GetListPadInfo (szTaskGroup, (MMC_LISTPAD_INFO*)pIListPadInfo);
}

void
CNode::OnTaskNotify(LONG_PTR arg, LPARAM param)
{
    CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(GetStaticParent());
    ASSERT(pSINode != NULL);

    IDataObjectPtr spDataObject;
    QueryDataObject(CCT_SCOPE, &spDataObject);

    IExtendTaskPadPtr spExtendTaskPad;
    CComponent* pCC;
    LPOLESTR pszClsid = reinterpret_cast<LPOLESTR>(arg);
    if (pszClsid[0] == 0)
    {
        pCC = GetPrimaryComponent();
        if (!pCC)
            return;
        spExtendTaskPad = pCC->GetIComponent();
    }
    else
    {
        CLSID clsid;
        HRESULT hr = ::CLSIDFromString(pszClsid, &clsid);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return;

        // try to get IExtendTaskPad from IComponent, first;
        // if that fails, just create using CLSID
        pCC = pSINode->GetComponent(const_cast<const CLSID&>(clsid));
        if (pCC)
            spExtendTaskPad = pCC->GetIComponent();
        if (spExtendTaskPad == NULL)
            hr = spExtendTaskPad.CreateInstance(clsid,
                                      #if _MSC_VER >= 1100
                                      NULL,
                                      #endif
                                      MMC_CLSCTX_INPROC);
    }

    ASSERT (spExtendTaskPad != NULL);
    if (spExtendTaskPad != NULL)
    {
        VARIANT** ppvarg = reinterpret_cast<VARIANT**>(param);
        spExtendTaskPad->TaskNotify(spDataObject, ppvarg[0], ppvarg[1]);
    }
}

HRESULT
CNode::OnScopeSelect(bool bSelect, SELECTIONINFO* pSelInfo)
{
    DECLARE_SC (sc, _T("CNode::OnScopeSelect"));
    sc = ScCheckPointers(pSelInfo);
    if (sc)
        return sc.ToHr();

    /*
     * Bug 178484: reset the sort parameters when scope selection changes
     */
    if (bSelect)
    {
        CComponent *pCC = GetPrimaryComponent();
        sc = ScCheckPointers(pCC, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        IFramePrivate *pFrame = pCC->GetIFramePrivate();
        sc = ScCheckPointers(pFrame, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        pFrame->ResetSortParameters();
    }

    if (bSelect == TRUE && WasExpandedAtLeastOnce() == FALSE)
    {
        sc = OnExpand(TRUE);
        if (sc)
            return (sc.ToHr());
    }

    ASSERT(IsInitialized() == TRUE);

    sc = OnSelect(pSelInfo->m_pView, bSelect, pSelInfo->m_bResultPaneIsWeb);
    if (sc)
        return (sc.ToHr());

    return (sc.ToHr());
}


HRESULT CNode::OnActvate(LONG_PTR lActivate)
{
    return (DeepNotify (MMCN_ACTIVATE, lActivate, 0));
}


HRESULT CNode::OnMinimize(LONG_PTR fMinimized)
{
    return (DeepNotify (MMCN_MINIMIZED, fMinimized, 0));
}


//+-------------------------------------------------------------------
//
//  Member:     SendShowEvent
//
//  Synopsis:   Send MMCN_SHOW notification to snapin, persist column
//              data if necessary.
//
//  Arguments:  [bSelect] - TRUE if the node is selected.
//
//--------------------------------------------------------------------
HRESULT CNode::SendShowEvent(BOOL bSelect)
{
    DECLARE_SC(sc, _T("CNode::SendShowEvent"));

    CComponent* pCC = m_pPrimaryComponent;
    ASSERT(pCC != NULL);

    // Get the data object for the node and pass it to the primary snap-in
    // and all the namespace extensions to the node.
    IDataObjectPtr spDataObject;
    HRESULT hr = QueryDataObject(CCT_SCOPE, &spDataObject);
    if (FAILED(hr))
        return hr;

    CMTNode* pMTNode = GetMTNode();

    IFramePrivatePtr     spFrame = pCC->GetIFramePrivate();
    sc = ScCheckPointers(spFrame, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    IImageListPrivatePtr spImageList;
    hr = spFrame->QueryResultImageList(reinterpret_cast<LPIMAGELIST*>(&spImageList));
    ASSERT(SUCCEEDED(hr));
    ASSERT(spImageList != NULL);

    HSCOPEITEM hScopeItem = CMTNode::ToScopeItem(pMTNode);

    if (bSelect == TRUE)
    {
        hr = pCC->Notify(spDataObject, MMCN_ADD_IMAGES,
                         reinterpret_cast<LPARAM>((LPIMAGELIST)spImageList),
                         hScopeItem);
        CHECK_HRESULT(hr);
        //if (FAILED(hr))
        //    return hr;
    }

    hr = pCC->Notify(spDataObject, MMCN_SHOW, bSelect, hScopeItem);

    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;

    if (bSelect)
    {
        CViewData *pViewData = GetViewData();
        sc = ScCheckPointers(pViewData, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (pViewData->HasList() || pViewData->HasListPad())
        {
            sc = ScRestoreSortFromPersistedData();
            if (sc)
                return sc.ToHr();

            // Now try to restore the view mode.
            sc =ScRestoreViewMode();
            if (sc)
                return sc.ToHr();
        }
    }

    return hr;
}


HRESULT CNode::DeepNotify(MMC_NOTIFY_TYPE event, LONG_PTR arg, LPARAM param)
{
    DECLARE_SC(sc, TEXT("CNode::DeepNotify"));

    CComponent* pCC = m_pPrimaryComponent;
    ASSERT(pCC != NULL);
    if (pCC == NULL)
        return E_UNEXPECTED;

    // Get the data object for the node and pass it to the primary snap-in
    // and all the namespace extensions to the node.
    IDataObjectPtr spDataObject;
    HRESULT hr = QueryDataObject(CCT_SCOPE, &spDataObject);
    if (FAILED(hr))
        return hr;

    hr = pCC->Notify(spDataObject, event, arg, param);
    CHECK_HRESULT(hr);
    //if (FAILED(hr))
    //    return hr;

    //
    //  Notify extensions.
    //

    CMTNode* pMTNode = GetMTNode();

    // Get the node-type of this node
    GUID guidNodeType;
    hr = pMTNode->GetNodeType(&guidNodeType);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;

    LPCLSID pDynExtCLSID;
    int cDynExt = pMTNode->GetDynExtCLSID(&pDynExtCLSID);

    CExtensionsIterator it;
    sc = it.ScInitialize(pMTNode->GetPrimarySnapIn(), guidNodeType, g_szNameSpace, pDynExtCLSID, cDynExt);
    if (sc)
        return S_FALSE;

    BOOL fProblem = FALSE;
    CSnapInNode* pSINode = GetStaticParent();

    for (; it.IsEnd() == FALSE; it.Advance())
    {
        CComponent* pCC = pSINode->GetComponent(it.GetCLSID());
        if (pCC == NULL)
            continue;

        hr = pCC->Notify(spDataObject, event, arg, param);
        CHECK_HRESULT(hr);

        // continue even if an error occurs with extension snapins
        if (FAILED(hr))
            fProblem = TRUE;
    }

    return (fProblem == TRUE) ? S_FALSE : S_OK;
}

HRESULT CNode::OnSelect(LPUNKNOWN lpView, BOOL bSelect,
                                  BOOL bResultPaneIsWeb)
{
    DECLARE_SC(sc, TEXT("CNode::OnSelect"));

#ifdef DBG
    if (lpView == NULL)
        ASSERT(bSelect == FALSE);
    else
        ASSERT(bSelect == TRUE);
#endif

    sc = ScCheckPointers(m_pPrimaryComponent, E_UNEXPECTED);
    if (sc)
    {
        sc.TraceAndClear();
        return sc.ToHr();
    }

    CComponent* pCC = m_pPrimaryComponent;
    sc = ScCheckPointers(pCC, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    IFramePrivate *pFrame = pCC->GetIFramePrivate();
    sc = ScCheckPointers(pFrame, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // set the correct view in the primary snap-in before it adds items
    if (bSelect == TRUE)
        pFrame->SetResultView(lpView);

    IDataObjectPtr spDataObject;
    sc = QueryDataObject(CCT_SCOPE, &spDataObject);
    if (sc)
        return sc.ToHr();

    CMTNode*  pMTNode    = GetMTNode();
    LPARAM    hScopeItem = CMTNode::ToScopeItem(pMTNode);

    // Send only the MMCN_SHOW message if result pane is the web view.
    if (bResultPaneIsWeb)
    {
        return pCC->Notify(spDataObject, MMCN_SHOW, bSelect, hScopeItem);
    }

    // Send necessary events like MMCN_ADD_IMAGES and MMCN_SHOW to snapin
    sc = SendShowEvent(bSelect);
    if (sc)
        return sc.ToHr();

    // set the correct view in the primary snap-in after it's notified
    if (bSelect == FALSE)
        pFrame->SetResultView(NULL);    //
    // Deal with extension ssnap-ins
    //

    // Get the node-type of this node
    GUID guidNodeType;
    sc = pMTNode->GetNodeType(&guidNodeType);
    if (sc)
        return sc.ToHr();

    LPCLSID pDynExtCLSID;
    int cDynExt = pMTNode->GetDynExtCLSID(&pDynExtCLSID);

    CExtensionsIterator it;
    sc = it.ScInitialize(pMTNode->GetPrimarySnapIn(), guidNodeType, g_szNameSpace, pDynExtCLSID, cDynExt);
    if (sc)
        return S_FALSE;

    BOOL fProblem = FALSE;
    CSnapInNode* pSINode = GetStaticParent();

    for (; it.IsEnd() == FALSE; it.Advance())
    {
        CComponent* pCCExtnSnapin = pSINode->GetComponent(it.GetCLSID());
        if (pCCExtnSnapin == NULL)
            continue;

        IFramePrivate *pFrameExtnSnapin = pCCExtnSnapin->GetIFramePrivate();
        sc = ScCheckPointers(pFrameExtnSnapin, E_UNEXPECTED);
        if (sc)
        {
            sc.TraceAndClear();
            continue;
        }

        // set the correct view in the snap-in before it adds items
        if (bSelect == FALSE)
        {
            pFrameExtnSnapin->SetResultView(NULL);
            continue;
        }
        else
        {
            pFrameExtnSnapin->SetResultView(lpView);

            IImageListPrivatePtr spImageList;
            sc = pCCExtnSnapin->GetIFramePrivate()->QueryResultImageList(
                                   reinterpret_cast<LPIMAGELIST*>(&spImageList));
            if (sc)
            {
                sc.TraceAndClear();
                fProblem = TRUE;
                continue;
            }

            sc = ScCheckPointers(spImageList, E_UNEXPECTED);
            if (sc)
            {
                sc.TraceAndClear();
                fProblem = TRUE;
                continue;
            }

            SC scNoTrace = pCCExtnSnapin->Notify(spDataObject, MMCN_ADD_IMAGES,
                                       reinterpret_cast<LPARAM>((LPIMAGELIST)spImageList),
                                       hScopeItem);
            if (scNoTrace)
            {
                TraceSnapinError(TEXT("Snapin returned error from IComponent::Notify MMCN_ADD_IMAGES"), scNoTrace);
            }
        }
    }

    return (fProblem == TRUE) ? S_FALSE : S_OK;
}

void CNode::Reset()
{
    m_pPrimaryComponent = NULL;
    m_bInitComponents = TRUE;
}

HRESULT CNode::GetDispInfoForListItem(LV_ITEMW* plvi)
{
    DECLARE_SC(sc, TEXT("CNode::GetDispInfoForListItem"));
    ASSERT(plvi != NULL);

    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));

    if (plvi->mask & LVIF_TEXT)
    {
        ASSERT (!IsBadWritePtr (plvi->pszText, plvi->cchTextMax * sizeof (TCHAR)));
        rdi.mask |= RDI_STR;
    }

    if (plvi->mask & LVIF_IMAGE)
        rdi.mask |= RDI_IMAGE;

    if (plvi->mask & LVIF_STATE)
        rdi.mask |= RDI_STATE;

    rdi.nCol = plvi->iSubItem;


    CComponent* pCC = NULL;

    // if virtual list
    if (GetViewData()->IsVirtualList())
    {
        pCC = GetPrimaryComponent();
        ASSERT(pCC != NULL);

        // all we can pass is the item index
        rdi.nIndex = plvi->iItem;

        // no default for virtual lists
        rdi.nImage = MMCLV_NOICON;
    }
    else
    {
        CResultItem* pri = CResultItem::FromHandle (plvi->lParam);

        if (pri != NULL)
        {
            if (pri->IsScopeItem()) // Folder
            {
                // convert to real type
                CNode* pNodeSubFldr = CNode::FromResultItem (pri);
                ASSERT(IsBadReadPtr(pNodeSubFldr, sizeof(CNode)) == FALSE);

                if (pNodeSubFldr->IsStaticNode() == TRUE) // Static folders
                {
                    return pNodeSubFldr->GetDispInfo(plvi);
                }
                else                                      // Enumerated folders
                {
                    // Remap the LParam information.
                    rdi.lParam = pNodeSubFldr->GetUserParam();
                    rdi.bScopeItem = TRUE;

                    pCC = pNodeSubFldr->GetPrimaryComponent();
                    rdi.nImage = pNodeSubFldr->GetResultImage();
                }
            }
            else // Leaf item
            {
                // Remap the LParam information.
                rdi.nImage = pri->GetImageIndex();
                rdi.lParam = pri->GetSnapinData();
                pCC = GetPrimaryComponent();
                ASSERT(GetComponent(pri->GetOwnerID()) == GetPrimaryComponent());
                ASSERT(pCC != NULL);
            }
        }
    }

    HRESULT hr = pCC->GetDisplayInfo(&rdi);

    if (hr == S_OK)
    {
        if (rdi.mask & RDI_IMAGE)
        {
            if (rdi.nImage == MMCLV_NOICON)
            {
                plvi->iImage = rdi.bScopeItem ? eStockImage_Folder : eStockImage_File;
            }
            else
            {
                IImageListPrivate *pIL = pCC->GetIImageListPrivate();
                HRESULT hr2 = pIL->MapRsltImage(pCC->GetComponentID(), rdi.nImage,
                                                          &(plvi->iImage));
                if (FAILED(hr2))
                {
                    Dbg(DEB_USER1, "can't map image provided by snapin. Using default image.\n");
                    plvi->iImage = rdi.bScopeItem ? eStockImage_Folder : eStockImage_File;
                }
            }
        }

        // Move all other info from rdi into lviItem
        if (rdi.mask & RDI_STR)
        {
            if (!IsBadStringPtrW (rdi.str, plvi->cchTextMax))
			{
                // ignore errors in the next line - if there's not enough space take what we can get.
                StringCchCopyW (plvi->pszText, plvi->cchTextMax, rdi.str);
            }
            else if (plvi->cchTextMax > 0)
                plvi->pszText[0] = 0;
        }

        if (rdi.mask & RDI_STATE)
            plvi->state = rdi.nState;
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:      CNode::ScSaveSortData
//
//  Synopsis:    Save the given sort data for persistence.
//
//  Arguments:   [nCol] - sort column.
//               [dwOptions] - sort options.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScSaveSortData (int nCol, DWORD dwOptions)
{
    DECLARE_SC(sc, _T("CNode::ScSaveSortData"));
    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    CLSID          guidSnapin;
    CXMLAutoBinary columnID;
    sc = ScGetSnapinAndColumnDataID(guidSnapin, columnID);
    if (sc)
        return sc;

    CXMLBinaryLock sLock(columnID);
    SColumnSetID* pColID = NULL;
    sc = sLock.ScLock(&pColID);
    if (sc)
        return sc;

    sc = ScCheckPointers(pColID, E_UNEXPECTED);
    if (sc)
        return sc;

    CColumnSortInfo colSortInfo;
    colSortInfo.m_nCol          = nCol;
    colSortInfo.m_dwSortOptions = dwOptions;
    colSortInfo.m_lpUserParam   = NULL;

    sc = pViewData->ScSaveColumnSortData(guidSnapin, *pColID, colSortInfo);
    if (sc)
        return sc;

    // Column data when saved includes the width/order data (column info list) and sort data.
    // The width/order data should always be saved regardless of whether sort data is
    // persisted or not. So save the width/order data.
    CColumnInfoList   columnInfoList;
    TStringVector    strColNames; // unused

    // get the current data
    sc = ScGetCurrentColumnData( columnInfoList, strColNames );
    if (sc)
        return sc;

    sc = pViewData->ScSaveColumnInfoList(guidSnapin, *pColID, columnInfoList);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:     OnColumnClicked
//
//  Synopsis:   Ask snapin to sort.
//
//  Arguments:  [nCol] - Column to be sorted.
//
//  Note:       When column is clicked sort options and user param
//              are unknown. So we set them to 0 (zero). In InternalSort
//              the sort option is computed.
//
//  Returns:    HRESULT
//
//  History:                RaviR    Created
//              07-27-1999  AnandhaG renamed OnSort to OnColumnClicked
//--------------------------------------------------------------------
HRESULT CNode::OnColumnClicked(LONG_PTR nCol)
{
    CComponent* pComponent = GetPrimaryComponent();
    ASSERT(pComponent != NULL);
    if (NULL == pComponent)
    return E_FAIL;

    IResultDataPrivatePtr pResult = pComponent->GetIFramePrivate();
    ASSERT(pResult != NULL);
    if (NULL == pResult)
        return E_FAIL;

    HRESULT hr = pResult->InternalSort( nCol, 0, NULL,
                                        TRUE /*column header clicked*/);

    if (hr == S_OK)
    {
        BOOL bAscending = TRUE;
        hr = pResult->GetSortDirection(&bAscending);
        if (hr == S_OK)
            hr = ScSaveSortData(nCol, bAscending ? 0 : RSI_DESCENDING).ToHr();
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     RestoreSort
//
//  Synopsis:   Sort the list view with persisted data.
//              Restore the sort with saved column # and
//              sort-options (User param is NULL as this
//              is user initiated MMCN_COLUMN_CLICK)*/
//
//  Arguments:  [nCol]           - Column to be sorted.
//              [dwSortOptions]  - Sortoptions, ascend/descend...
//
//  Note:       Unlike OnColumnClicked this method wont set columns dirty
//              after successful sort.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
HRESULT CNode::RestoreSort(INT nCol, DWORD dwSortOptions)
{
    CComponent* pComponent = GetPrimaryComponent();
    ASSERT(pComponent != NULL);
    if (NULL == pComponent)
    return E_FAIL;

    IResultDataPrivatePtr pResult = pComponent->GetIFramePrivate();
    ASSERT(pResult != NULL);
    if (NULL == pResult)
        return E_FAIL;

    HRESULT hr = pResult->InternalSort( nCol, dwSortOptions,
                                        NULL /*NULL user param as this is user initiated*/,
                                        FALSE /* Let us not send MMCN_COLUMN_CLICK*/);

    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScRestoreSortFromPersistedData
//
//  Synopsis:    Get persisted sort data if any and apply it to list-view.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScRestoreSortFromPersistedData ()
{
    DECLARE_SC(sc, _T("CNode::ScRestoreSortFromPersistedData"));
    CViewData *pViewData = GetViewData();

    if (! pViewData->HasList() && ! pViewData->HasListPad() )
        return (sc = S_FALSE); // OCX gets MMCN_SHOW which may try to restore sort so this is no failure.

    // To get CColumnSetData first get the column-id & snapin guid.
    CLSID          guidSnapin;
    CXMLAutoBinary columnID;
    sc = ScGetSnapinAndColumnDataID(guidSnapin, columnID);
    if (sc)
        return sc;

    CXMLBinaryLock sLock(columnID);
    SColumnSetID* pColID = NULL;
    sc = sLock.ScLock(&pColID);
    if (sc)
        return sc;

    sc = ScCheckPointers(pColID, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get persisted data.
    CColumnSetData columnSetData;
    BOOL bRet = pViewData->RetrieveColumnData(guidSnapin, *pColID, columnSetData);

    if (!bRet)
        return (sc = S_FALSE);

    CColumnInfoList* pColInfoList = columnSetData.get_ColumnInfoList();
    if (!pColInfoList)
        return (sc = S_FALSE);

    IFramePrivatePtr spFrame = GetIFramePrivate();
    sc = ScCheckPointers(spFrame, E_UNEXPECTED);
    if (sc)
        return sc;

    // First check if the number of columns inserted are same as the
    // number that is persisted. If not remove the persisted data.
    IHeaderCtrlPrivatePtr  spHeader = spFrame;
    sc = ScCheckPointers(spHeader, E_UNEXPECTED);
    if (sc)
        return sc;

    int cColumns = 0;
    sc = spHeader->GetColumnCount(&cColumns);
    if (sc)
        return sc;

    // If the persisted columns and number of columns inserted
    // do not match remove the persisted data.
    if (pColInfoList->size() != cColumns)
    {
        pViewData->DeleteColumnData(guidSnapin, *pColID);
        return sc;
    }

    // Set sorting column, order
    CColumnSortList* pSortList = columnSetData.get_ColumnSortList();

    if (pSortList && ( pSortList->size() > 0))
    {
        CColumnSortList::iterator itSortInfo = pSortList->begin();

        // Restore the sort with saved column # and
        // sort-options (User param is NULL as this
        // is user initiated MMCN_COLUMN_CLICK)*/
        RestoreSort(itSortInfo->getColumn(), itSortInfo->getSortOptions());
    }

    return (sc);
}


/***************************************************************************\
 *
 * METHOD:  CNode::ScGetCurrentColumnData
 *
 * PURPOSE: collects current column data to collections passed as args
 *          [ initially code used to be in OnColumns method ]
 *
 * PARAMETERS:
 *    CColumnInfoList& columnInfoList
 *    TStringVector& strColNames
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::ScGetCurrentColumnData( CColumnInfoList& columnInfoList, TStringVector& strColNames)
{
    DECLARE_SC(sc, TEXT("CNode::ScGetCurrentColumnData"));
    columnInfoList.clear();
    strColNames.clear();

    IHeaderCtrlPrivatePtr spHeader = GetIFramePrivate();
    sc = ScCheckPointers(spHeader, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = spHeader->GetColumnInfoList(&columnInfoList);
    if (sc)
        return sc;

    int cColumns = columnInfoList.size();

    USES_CONVERSION;

    for (int i = 0; i < cColumns; i++)
    {
        CCoTaskMemPtr<OLECHAR> spColumnText;

        sc = spHeader->GetColumnText(i, &spColumnText);
        if (sc)
            return sc;

        strColNames.push_back(OLE2T(spColumnText));
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNode::ScSetUpdatedColumnData
 *
 * PURPOSE: updates column by data specified in collections passed as args
 *          [ initially code used to be in OnColumns method ]
 *
 * PARAMETERS:
 *    CColumnInfoList& oldColumnInfoList - column data befor the change
 *    CColumnInfoList& newColumnInfoList - updated column data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::ScSetUpdatedColumnData( CColumnInfoList& oldColumnInfoList, CColumnInfoList& newColumnInfoList)
{
    DECLARE_SC(sc, TEXT("CNode::ScSetUpdatedColumnData"));

    CColumnInfoList::iterator itColInfo1, itColInfo2;

    // Check if there is any change in visible/hidden columns.
    // If so send MMCN_COLUMNS_CHANGE notification
    for (itColInfo1 = newColumnInfoList.begin(); itColInfo1 != newColumnInfoList.end(); ++itColInfo1)
    {
        // Get the same column from old list.
        itColInfo2 = find_if(oldColumnInfoList.begin(), oldColumnInfoList.end(),
                             bind2nd( ColPosCompare(), itColInfo1->GetColIndex()) );

        if (itColInfo2 == oldColumnInfoList.end())
            return sc = E_UNEXPECTED;

        // Compare the hidden flag.
        if ( itColInfo2->IsColHidden() != itColInfo1->IsColHidden() )
        {
            // Send MMCN_COLUMNS_CHANGED notification
            sc = OnColumnsChange(newColumnInfoList);
            if (sc)
                return sc;

            break; // done anyway
        }
    }

    sc = ScSaveColumnInfoList(newColumnInfoList);
    if (sc)
        return sc;

    IHeaderCtrlPrivatePtr spHeader = GetIFramePrivate();
    sc = ScCheckPointers(spHeader, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = spHeader->ModifyColumns(newColumnInfoList);
    if (sc)
        return sc;

    sc = ScRestoreSortFromPersistedData();
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     OnColumns
//
//  Synopsis:   Display Columns customization dialog and if necessary
//              apply changes made by the user.
//
//--------------------------------------------------------------------
void CNode::OnColumns()
{
    DECLARE_SC(sc, TEXT("CNode::OnColumns"));

    // first - get the columns
    CColumnInfoList   columnInfoList;
    TStringVector    strColNames;

    // 1. get the current data
    sc = ScGetCurrentColumnData( columnInfoList, strColNames );
    if (sc)
        return;

    // 2. Cache the column data.
    CColumnInfoList columnInfoListOld = columnInfoList;

    // 3. get the default column settings.
    CViewData *pViewData = GetViewData();
    IHeaderCtrlPrivatePtr spHeader = GetIFramePrivate();
    sc = ScCheckPointers(pViewData, spHeader, E_UNEXPECTED);
    if (sc)
        return;

    CColumnInfoList defaultColumnInfoList;
    sc = spHeader->GetDefaultColumnInfoList(defaultColumnInfoList);
    if (sc)
        return;

    // 5. display the dialog
    CColumnsDlg dlg(&columnInfoList, &strColNames, defaultColumnInfoList);
    INT_PTR nRet = dlg.DoModal();

    if (nRet == -1)
    {
        sc = E_UNEXPECTED;
        return;
    }

    if (nRet == IDOK)
    {
        // update columns by modified data
        sc = ScSetUpdatedColumnData( columnInfoListOld, columnInfoList );
        if (sc)
            return;
    }

    // If reset is true then throw away present persisted column data
    // and apply the default settings.
    if (nRet == IDC_RESTORE_DEFAULT_COLUMNS)
    {
        // To get CColumnSetData first get the column-id & snapin guid.
        CLSID          guidSnapin;
        CXMLAutoBinary columnID;
        sc = ScGetSnapinAndColumnDataID(guidSnapin, columnID);
        if (sc)
            return;

        CXMLBinaryLock sLock(columnID);
        SColumnSetID* pColID = NULL;
        sc = sLock.ScLock(&pColID);
        if (sc)
            return;

        sc = ScCheckPointers(pColID, E_UNEXPECTED);
        if (sc)
            return;

        pViewData->DeleteColumnData(guidSnapin, *pColID);

        sc = spHeader->ModifyColumns(defaultColumnInfoList);
        if (sc)
            return;
    }
}

/***************************************************************************\
 *
 * METHOD:  CNode::ScShowColumn
 *
 * PURPOSE: shows/hides column. notifies snapin on action
 *
 * PARAMETERS:
 *    int iColIndex - index of column to change
 *    bool bVisible - show/hide flag
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::ScShowColumn(int iColIndex, bool bShow)
{
    DECLARE_SC(sc, TEXT("CNode::ScShowColumn"));

    // first - get the current column data
    CColumnInfoList   columnInfoList;
    TStringVector    strColNames;

    sc = ScGetCurrentColumnData( columnInfoList, strColNames );
    if (sc)
        return sc;

    // Save the column data.
    CColumnInfoList columnInfoListOld = columnInfoList;


    // find the column and change its status
    CColumnInfoList::iterator itColInfo = find_if(columnInfoList.begin(), columnInfoList.end(),
                                                  bind2nd( ColPosCompare(), iColIndex) );

    // check if we did find the column
    if (itColInfo == columnInfoList.end())
        return sc = E_INVALIDARG; // assume it's not a valid index

    // now modify the column status acording to parameters
    if (bShow)
    {
        itColInfo->SetColHidden(false);
        // move column to the end
        columnInfoList.splice(columnInfoList.end(), columnInfoList, itColInfo);
    }
    else
    {
        itColInfo->SetColHidden();
    }

    // update columns by modified data
    sc = ScSetUpdatedColumnData( columnInfoListOld, columnInfoList);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNode::ScGetSortColumn
 *
 * PURPOSE: return currently used sort column
 *
 * PARAMETERS:
 *    int *piSortCol - sort column index [retval]
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::ScGetSortColumn(int *piSortCol)
{
    DECLARE_SC(sc, TEXT("CNode::ScGetSortColumn"));

    // parameter check
    sc = ScCheckPointers(piSortCol);
    if (sc)
        return sc;

    // retrieve IResultDataPrivate interface
    CComponent* pComponent = GetPrimaryComponent();
    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if (sc)
        return sc;

    IResultDataPrivatePtr pResult = pComponent->GetIFramePrivate();
    sc = ScCheckPointers(pResult, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward the call to IResultDataPrivate
    sc = pResult->GetSortColumn(piSortCol);
    if (sc)
        return sc;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CNode::ScSetSortColumn
 *
 * PURPOSE: sorts result data by specified column
 *          [uses private result data interface to implement]
 *
 * PARAMETERS:
 *    int iSortCol      - index of column to sort by
 *    bool bAscending   - sorting order
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::ScSetSortColumn(int iSortCol, bool bAscending)
{
    DECLARE_SC(sc, TEXT("CNode::ScSetSortColumn"));

    // retrieve IResultDataPrivate interface
    CComponent* pComponent = GetPrimaryComponent();
    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if (sc)
        return sc;

    IResultDataPrivatePtr pResult = pComponent->GetIFramePrivate();
    sc = ScCheckPointers(pResult, E_UNEXPECTED);
    if (sc)
        return sc;

    DWORD dwSortOptions = bAscending ? 0 : RSI_DESCENDING;

    // forward the call to IResultDataPrivate
    sc = pResult->InternalSort( iSortCol, dwSortOptions, NULL, FALSE );
    if (sc)
        return sc;

    // If sort went thru - save.
    if (sc == SC(S_OK))
        sc = ScSaveSortData(iSortCol, dwSortOptions);

    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     OnColumnsChange
//
//  Synopsis:   Send MMCN_COLUMNS_CHANGE notification to snapin.
//
//  Arguments:  [colInfoList]  - Columns data.
//
//--------------------------------------------------------------------
HRESULT CNode::OnColumnsChange(CColumnInfoList& colInfoList)
{
    CComponent* pCC = m_pPrimaryComponent;
    ASSERT(pCC != NULL);

    // Get the data object for the node and pass it to the primary snap-in
    // and all the namespace extensions to the node.
    IDataObjectPtr spDataObject;
    HRESULT hr = QueryDataObject(CCT_SCOPE, &spDataObject);
    if (FAILED(hr))
        return hr;

    int nVisibleColumns = 0;

    // Count the number of columns that are visible.
    CColumnInfoList::iterator itColInfo;
    for (itColInfo = colInfoList.begin(); itColInfo != colInfoList.end();
        ++itColInfo)
    {
        if (! itColInfo->IsColHidden())
            nVisibleColumns++;
    }

    int size = sizeof(MMC_VISIBLE_COLUMNS) + nVisibleColumns * sizeof(INT);
    HGLOBAL hGlobal = ::GlobalAlloc(GPTR, size);
    if (! hGlobal)
        return E_OUTOFMEMORY;

    MMC_VISIBLE_COLUMNS* pColData = reinterpret_cast<MMC_VISIBLE_COLUMNS*>(hGlobal);
    pColData->nVisibleColumns = nVisibleColumns;

    // Get the list of visible columns into MMC_VISIBLE_COLUMNS struct.
    int i = 0;
    for (itColInfo = colInfoList.begin(); itColInfo != colInfoList.end();
        ++itColInfo)
    {
        if (! itColInfo->IsColHidden())
            pColData->rgVisibleCols[i++] = itColInfo->GetColIndex();
    }

    LPARAM lParam = reinterpret_cast<LPARAM>(pColData);
    hr = pCC->Notify(spDataObject, MMCN_COLUMNS_CHANGED, 0, lParam);

    ::GlobalFree(hGlobal);

    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;


    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     ScSaveColumnInfoList
//
//  Synopsis:   Save the column data in internal data structures.
//
//  Arguments:  [colInfoList]  - Columns data.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CNode::ScSaveColumnInfoList(CColumnInfoList& columnInfoList)
{
    DECLARE_SC(sc, TEXT("CNode::ScSaveColumnInfoList"));

    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    CLSID          clsidSnapin;
    CXMLAutoBinary columnID;
    sc = ScGetSnapinAndColumnDataID(clsidSnapin, columnID);
    if (sc)
        return sc;

    CXMLBinaryLock sLock(columnID);
    SColumnSetID* pColID = NULL;
    sc = sLock.ScLock(&pColID);
    if (sc)
        return sc;

    sc = ScCheckPointers(pColID, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = pViewData->ScSaveColumnInfoList(clsidSnapin, *pColID, columnInfoList);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScGetSnapinAndColumnDataID
//
//  Synopsis:   Returns the snapin guid & column-id in CXMLAutoBinary for this node.
//
//  Arguments:  [snapinGuid] - [out], snapin guid.
//              [columnID]   - [out], column-id in CXMLAutoBinary.
//
//  Note:       Pass in a CXMLAutoBinary object, will return column id in that object.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CNode::ScGetSnapinAndColumnDataID(GUID& snapinGuid, CXMLAutoBinary& columnID)
{
    DECLARE_SC(sc, TEXT("CNode::ScGetSnapinAndColumnDataID"));

    // Get Snapin Guid
    snapinGuid = GetPrimarySnapInCLSID();

    columnID.ScFree(); // clear any data.

    IDataObjectPtr spDataObject;
    sc = QueryDataObject(CCT_SCOPE, &spDataObject);
    if (sc)
        return sc;

    HGLOBAL hGlobal;
    sc = ExtractColumnConfigID(spDataObject, hGlobal);

    if (! sc.IsError())
    {
        int cbSize = GlobalSize(hGlobal);
        if (0 == cbSize)
            return sc.FromLastError();

        columnID.Attach(hGlobal, cbSize);
    }
    else
    {
        // Let us use the NodeTypeGUID as the Column Data Identifier
        CLSID clsidColID;
        sc = GetNodeType(&clsidColID);
        if (sc)
            return sc;

        int cbSize = sizeof(SColumnSetID) + sizeof(CLSID) - 1;
        sc = columnID.ScAlloc(cbSize, true);
        if (sc)
            return sc;

        CXMLBinaryLock sLock(columnID);
        SColumnSetID* pColID = NULL;
        sc = sLock.ScLock(&pColID);
        if (sc)
            return sc;

        sc = ScCheckPointers(pColID, E_UNEXPECTED);
        if (sc)
            return sc;

        pColID->cBytes = sizeof(CLSID);
        pColID->dwFlags = 0;

        CopyMemory(pColID->id, (BYTE*)&clsidColID, sizeof(pColID->id));
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 * class CViewExtensionCallback
 *
 *
 * PURPOSE: Implements IViewExtensionCallback
 *
 *+-------------------------------------------------------------------------*/
class CViewExtensionCallback :
    public CComObjectRoot,
    public IViewExtensionCallback
{

public:
    typedef CViewExtensionCallback ThisClass;

BEGIN_COM_MAP(ThisClass)
    COM_INTERFACE_ENTRY(IViewExtensionCallback)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(ThisClass)

IMPLEMENTS_SNAPIN_NAME_FOR_DEBUG()

    CViewExtensionCallback() : m_pItExt(NULL) {}

    SC ScInitialize(CViewExtInsertIterator & itExt)
    {
        DECLARE_SC(sc, TEXT("CViewExtensionCallback::ScInitialize"));
        m_pItExt = &itExt;
        return sc;
    }

    SC ScDeinitialize()
    {
        DECLARE_SC (sc, _T("CViewExtensionCallback::ScDeinitialize"));
        m_pItExt       = NULL;
        return (sc);
    }


public:
    STDMETHODIMP AddView(PMMC_EXT_VIEW_DATA pExtViewData) {return ScAddView(pExtViewData).ToHr();}

private:

    SC ScAddView(PMMC_EXT_VIEW_DATA pExtViewData)
    {
        DECLARE_SC(sc, TEXT("CViewExtensionCallback::ScAddView"));

        sc = ScCheckPointers(pExtViewData, pExtViewData->pszURL, pExtViewData->pszViewTitle);
        if(sc)
            return sc; // TODO add snapin error

        sc = ScCheckPointers(m_pItExt, E_UNEXPECTED);
        if(sc)
            return sc; // TODO add snapin error, e.g. "IExtendViewCallback::AddView called outside of IExtendView::GetViews"

        /*
         * prep the input to IConsoleView::ScAddViewExtension
         */
        CViewExtensionData ved;
        ved.strURL               = pExtViewData->pszURL;
        ved.strName              = pExtViewData->pszViewTitle;
        ved.viewID               = pExtViewData->viewID;
        ved.bReplacesDefaultView = pExtViewData->bReplacesDefaultView;

        /*
         * std::basic_string's can't assign from NULL, so we have to check first
         */
        if (pExtViewData->pszTooltipText)
            ved.strTooltip = pExtViewData->pszTooltipText;

        /*
         * validate output:  URL and title are required, tooltip is optional
         */
        if (ved.strURL.empty())
        {
            TraceSnapinError(TEXT("Invalid parameter to IViewExtensionCallback::AddView (empty URL)"), E_INVALIDARG);
            return (sc = E_INVALIDARG);
        }

        if (ved.strName.empty())
        {
            TraceSnapinError(TEXT("Invalid parameter to IViewExtensionCallback::AddView (empty title)"), E_INVALIDARG);
            return (sc = E_INVALIDARG);
        }

        /*
         * add the extension to the view
         */
        *(*m_pItExt)++ = ved;

        return sc;
    }

private:
    CViewExtInsertIterator *m_pItExt;

};


/*+-------------------------------------------------------------------------*
 * CNode::ScGetViewExtensions
 *
 *
 *--------------------------------------------------------------------------*/

SC CNode::ScGetViewExtensions (CViewExtInsertIterator itExt)
{
    DECLARE_SC (sc, _T("CNode::ScGetViewExtensions"));

    IDataObjectPtr spDataObject;
    bool bScopeItem ;
    sc = ScGetDataObject(/*bScopePane*/ true, NULL /*lResultItemCookie*/, bScopeItem, &spDataObject);
    if(sc)
        return sc;

    CSnapIn* pSnapIn = GetPrimarySnapIn();
    sc = ScCheckPointers (pSnapIn, E_FAIL);
    if (sc)
        return (sc);

    CArray<GUID, GUID&> DynExtens;
    ExtractDynExtensions(spDataObject, DynExtens);

    GUID guidNodeType;
    sc = ::ExtractObjectTypeGUID(spDataObject, &guidNodeType);
    if(sc)
        return sc;

    CExtensionsIterator it;
    sc = it.ScInitialize(pSnapIn, guidNodeType, g_szView, DynExtens.GetData(), DynExtens.GetSize());
    if(sc)
        return sc;

    typedef CComObject<CViewExtensionCallback> t_ViewExtensionCallback;

    t_ViewExtensionCallback *pViewExtensionCallback = NULL;
    sc = t_ViewExtensionCallback::CreateInstance(&pViewExtensionCallback);
    if(sc)
        return sc;

    if(NULL == pViewExtensionCallback)
        return (sc = E_UNEXPECTED);

    sc = pViewExtensionCallback->ScInitialize(itExt);
    if(sc)
        return sc;

    IViewExtensionCallbackPtr spViewExtensionCallback = pViewExtensionCallback;

    // add all the console taskpads first
    sc = CConsoleTaskpadViewExtension::ScGetViews(this, spViewExtensionCallback);
    if(sc)
        return sc;

    for (; !it.IsEnd(); it.Advance())
    {
        // any errors in this block should just go on to the next snap-in. Can't let one snap-in
        // hose all the others.

        /*
         * create the extension
         */
        IExtendViewPtr spExtendView;
        sc = spExtendView.CreateInstance(it.GetCLSID(), NULL, MMC_CLSCTX_INPROC);
        if(sc)
        {
            #ifdef DBG
            USES_CONVERSION;
            tstring strMsg = _T("Failed to create snapin ");
            CCoTaskMemPtr<WCHAR> spszCLSID;
            if (SUCCEEDED (StringFromCLSID (it.GetCLSID(), &spszCLSID)))
                strMsg += W2T(spszCLSID);
            TraceSnapinError(strMsg.data(), sc);
            #endif
            sc.Clear();
            continue;
        }

        /*
         * get the view extension data from the extension
         */
        sc = spExtendView->GetViews(spDataObject, spViewExtensionCallback);
        if(sc)
        {
            TraceSnapinError(TEXT("Snapin returned error on call to IExtendView::GetView"), sc);
            sc.Clear();
            continue;
        }
    }

    /*
     * View extensions aren't supposed to hold onto IExtendViewCallback,
     * but buggy view extensions might.  This will neuter the callback
     * so buggy view extensions won't reference stale data.
     */
    sc = pViewExtensionCallback->ScDeinitialize();
    if (sc)
        return (sc);

    return (sc);
}

/*******************************************************\
|  helper function to avoid too many stack allocations
\*******************************************************/
static std::wstring T2W_ForLoop(const tstring& str)
{
#if defined(_UNICODE)
    return str;
#else
    USES_CONVERSION;
    return A2CW(str.c_str());
#endif
}

/***************************************************************************\
|
| Implementation of subclass CNode::CDataObjectCleanup
| Responsible for data object clenup
|
| Cleanup works by these rules:
|
|  1. Data object created for cut , copy or dragdrop registers every node added to it
|  2. Nodes are registered in the static multimap, mapping node to the data object it belongs to.
|  3. Node destructor checks the map and triggers cleanup for all affected data objects.
|  4. Data Object cleanup is:   a) unregistering its nodes,
|               b) release contained data objects
|               b) entering invalid state (allowing only removal of cut objects to succeed)
|               c) revoking itself from clipboard if it is on the clipboard.
|  It will not do any of following: a) release references to IComponents as long as is alive
|               b) prevent MMCN_CUTORMOVE to be send by invoking RemoveCutItems()
|
\***************************************************************************/


// declare static variable
CNode::CDataObjectCleanup::CMapOfNodes CNode::CDataObjectCleanup::s_mapOfNodes;

/***************************************************************************\
 *
 * METHOD:  CNode::CDataObjectCleanup::ScRegisterNode
 *
 * PURPOSE: registers node to trigger clipboard clenup on destructor
 *
 * PARAMETERS:
 *    CNode *pNode                      [in] - node to register
 *    CMMCClipBoardDataObject *pObject  [in] - data object to remove from clipboard
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::CDataObjectCleanup::ScRegisterNode(CNode *pNode, CMMCClipBoardDataObject *pObject)
{
    DECLARE_SC(sc, TEXT("CNode::CClipboardClenup::ScRegisterNode"));

    // parameter check
    sc = ScCheckPointers( pNode, pObject );
    if (sc)
        return sc;

    // add to the multimap
    s_mapOfNodes.insert( CMapOfNodes::value_type( pNode, pObject ) );

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNode::CDataObjectCleanup::ScUnadviseDataObject
 *
 * PURPOSE: Removes nodes-'clenup triggers' kept for the object
 *
 * PARAMETERS:
 *    CMMCClipBoardDataObject *pObject [in] object going away
 *    bool bForceDataObjectCleanup     [in] whether need to ask DO to clenup / unregister itself
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::CDataObjectCleanup::ScUnadviseDataObject(CMMCClipBoardDataObject *pObject, bool bForceDataObjectCleanup /*= true*/)
{
    DECLARE_SC(sc, TEXT("CNode::CDataObjectCleanup::ScUnadviseDataObject"));

    // remove all nodes associated with the data object
    CMapOfNodes::iterator it = s_mapOfNodes.begin();
    while ( it != s_mapOfNodes.end() )
    {
        // remove or skip the entry
        if ( it->second == pObject )
            it = s_mapOfNodes.erase( it );
        else
            ++it;
    }

    // invalidate data object when required
    if ( bForceDataObjectCleanup )
    {
        sc = pObject->ScInvalidate();
        if (sc)
            return sc;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNode::CDataObjectCleanup::ScUnadviseNode
 *
 * PURPOSE: Does data object claenup triggered by the node
 *
 * PARAMETERS:
 *    CNode *pNode [in] - node initiating cleanup
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::CDataObjectCleanup::ScUnadviseNode(CNode *pNode)
{
    DECLARE_SC(sc, TEXT("CNode::CClipboardClenup::ScUnadviseNode"));

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    // find the node in the map
    CMapOfNodes::iterator it;
    while ( s_mapOfNodes.end() != ( it = s_mapOfNodes.find(pNode) ) )
    {
        // one node triggers clenup for whole data object
        sc = ScUnadviseDataObject( it->second );
        if (sc)
            return sc;
    }

    return sc;
}


//############################################################################
//############################################################################
//
//  Implementation of class CSnapInNode
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapInNode);

CSnapInNode::CSnapInNode(
    CMTSnapInNode*  pMTNode,
    CViewData*      pViewData,
    bool            fRootNode)
    : CNode(pMTNode, pViewData, fRootNode, true)
{
    m_spData.CreateInstance();

    ASSERT(pMTNode != NULL);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapInNode);

    pMTNode->AddNode(this);
}

CSnapInNode::CSnapInNode(const CSnapInNode& other) :
    CNode (other),
    m_spData (other.m_spData)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapInNode);
}

void CSnapInNode::Reset()
{
    m_spData->Reset();
    ResetFlags();
    CNode::Reset();
}

CSnapInNode::~CSnapInNode()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapInNode);

    CMTSnapInNode* pMTSINode = dynamic_cast<CMTSnapInNode*>(GetMTNode());
    ASSERT(pMTSINode != NULL);

    if (pMTSINode)
        pMTSINode->RemoveNode(this);
}

void CSnapInNode::AddComponentToArray(CComponent* pCC)
{
    ASSERT((pCC->GetComponentID() >= GetComponentArray().size()) ||
            (GetComponentArray().size() > 0) &&
            (GetComponentArray()[pCC->GetComponentID()] == NULL));

    if (pCC->GetComponentID() >= GetComponentArray().size())
        GetComponentArray().resize(pCC->GetComponentID() + 1);

    GetComponentArray()[pCC->GetComponentID()] = pCC;
}

CComponent* CSnapInNode::CreateComponent(CSnapIn* pSnapIn, int nID)
{
    ASSERT(pSnapIn != NULL);

    CComponent* pCC = new CComponent(pSnapIn);
	if ( pCC != NULL )
	{
		pCC->SetComponentID(nID);
		AddComponentToArray(pCC);
	}
    return pCC;
}

//+-------------------------------------------------------------------
//
//  Member:      CSnapInNode::GetResultImage
//
//  Synopsis:    Get the image-index in result-image list for this node.
//
//  Note:        The CSnapInNode member ImageListPrivate is not set all
//               the time (if the window is rooted at snapin node), so
//               set it temporarily when we need the icon index.
//               The member is set while adding sub-folders
//               The only other case this will affect is when called for
//               the image index for static snapin nodes displayed in result-pane.
//               But when static snapin nodes are displayed in result-pane the
//               AddSubFolders added it so the imagelist is already set.
//
//  Arguments:
//
//  Returns:     Image index for this item in result-pane.
//
//--------------------------------------------------------------------
UINT CSnapInNode::GetResultImage()
{
    IImageListPrivate *pImageList = GetImageList();

    if (!pImageList)
    {
        CComponent *pCC = GetPrimaryComponent();
        if (pCC)
            pImageList = pCC->GetIImageListPrivate();
    }

    CMTSnapInNode* pMTSnapInNode = dynamic_cast<CMTSnapInNode*>(GetMTNode());

    if (pMTSnapInNode)
        return pMTSnapInNode->GetResultImage ((CNode*)this, pImageList);

    return CNode::GetResultImage();
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapInNode::GetControl
 *
 * PURPOSE:       Given the CLSID of the OCX, see if we have stored this
 *                OCX, if so return the OCXWrapper's IUnknown ptr.
 *
 * PARAMETERS:
 *    CLSID clsid: class-id of the OCX.
 *
 * RETURNS:
 *    LPUNKNOWN of wrapper OCX.
 *
 *+-------------------------------------------------------------------------*/
LPUNKNOWN CSnapInNode::GetControl(CLSID& clsid)
{
    for (int i=0; i <= GetOCXArray().GetUpperBound(); i++)
    {
        if (GetOCXArray()[i].IsControlCLSID(clsid) == TRUE)
            return GetOCXArray()[i].GetControlUnknown();
    }

    return NULL;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapInNode::SetControl
 *
 * PURPOSE:       Given the CLSID of the OCX and of the wrapper.
 *
 * PARAMETERS:
 *    CLSID clsid : of a OCX.
 *    IUnknown *pUnknown: of OCX wrapper.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapInNode::SetControl(CLSID& clsid, IUnknown* pUnknown)
{
    // check for slot in cache
    int iLast = GetOCXArray().GetUpperBound();
    for (int i=0; i <= iLast;  i++)
    {
        if (GetOCXArray()[i].IsControlCLSID(clsid) == TRUE)
            break;
    }

    // if not in cache, add one more entry
    if (i > iLast)
        GetOCXArray().SetSize(i + 1);

    GetOCXArray()[i].SetControl(clsid, pUnknown);
}


/*+-------------------------------------------------------------------------*
 *
 * CSnapInNode::GetControl
 *
 * PURPOSE:       Given the IUnknown of the OCX, see if we have stored this
 *                OCX, if so return the OCXWrapper's IUnknown ptr.
 *
 * PARAMETERS:
 *    IUnknown *pUnkOCX : of a OCX.
 *
 * RETURNS:
 *    LPUNKNOWN of wrapper OCX.
 *
 *+-------------------------------------------------------------------------*/
LPUNKNOWN CSnapInNode::GetControl(LPUNKNOWN pUnkOCX)
{
    for (int i=0; i <= GetOCXArray().GetUpperBound(); i++)
    {
        // Compare IUnknowns.
        if (GetOCXArray()[i].IsSameOCXIUnknowns(pUnkOCX) == TRUE)
            return GetOCXArray()[i].GetControlUnknown();
    }

    return NULL;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapInNode::SetControl
 *
 * PURPOSE:       Given the IUnknown of the OCX and of the wrapper.
 *
 * PARAMETERS:
 *    IUnknown *pUnkOCX : of a OCX.
 *    IUnknown *pUnknown: of OCX wrapper.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapInNode::SetControl(LPUNKNOWN pUnkOCX, IUnknown* pUnknown)
{
    // check for slot in cache
    int iLast = GetOCXArray().GetUpperBound();
    for (int i=0; i <= iLast;  i++)
    {
        if (GetOCXArray()[i].IsSameOCXIUnknowns(pUnkOCX) == TRUE)
            break; // found the OCX, so replace with given OCXwrapper.
    }

    // if not in cache, add one more entry
    if (i > iLast)
        GetOCXArray().SetSize(i + 1);

    GetOCXArray()[i].SetControl(pUnkOCX, pUnknown);
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScGetConsoleTaskpad
//
//  Synopsis:    Get the console taskpad identified by given GUID for this node.
//
//  Arguments:   [guidTaskpad] - [in param]
//               [ppTaskpad]   - [out param]
//
//  Returns:     SC, S_FALSE if none exists
//
//--------------------------------------------------------------------
SC CNode::ScGetConsoleTaskpad (const GUID& guidTaskpad, CConsoleTaskpad **ppTaskpad)
{
    DECLARE_SC(sc, _T("CNode::ScGetConsoleTaskpad"));
    sc = ScCheckPointers(ppTaskpad);
    if (sc)
        return sc;

    *ppTaskpad = NULL;

    CScopeTree* pScopeTree = CScopeTree::GetScopeTree();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if(sc)
        return sc;

    CConsoleTaskpadList *pConsoleTaskpadList = pScopeTree->GetConsoleTaskpadList();
    sc = ScCheckPointers(pConsoleTaskpadList, E_UNEXPECTED);
    if (sc)
        return sc;

    // get a filtered list of taskpads that apply to this node.
    CConsoleTaskpadFilteredList filteredList;

    sc = pConsoleTaskpadList->ScGetTaskpadList(this, filteredList);
    if(sc)
        return sc;

    for(CConsoleTaskpadFilteredList::iterator iter = filteredList.begin(); iter!= filteredList.end(); ++iter)
    {
        CConsoleTaskpad *pTaskpad = *iter;
        sc = ScCheckPointers(pTaskpad, E_UNEXPECTED);
        if (sc)
            return sc;

        if (pTaskpad->GetID() == guidTaskpad)
        {
            *ppTaskpad = pTaskpad;
            return sc;               // found
        }
    }

    return (sc = S_FALSE);    // not found
}



/*************************************************************************
 *
 * There is only one CViewSettingsPersistor object per document.
 *
 * The object stored as static variable inside CNode as CNode needs
 * to access this object frequently.
 *
 * The Document needs to initialize/save the object by loading/savind
 * from/to console file. It calls below ScQueryViewSettingsPersistor.
 *
 * The object is created with first call to ScQueryViewSettingsPersistor.
 * The object is destroyed when DocumentClosed event is received.
 *
 *************************************************************************/
CComObject<CViewSettingsPersistor>* CNode::m_pViewSettingsPersistor = NULL;

//+-------------------------------------------------------------------
//
//  Member:      CNode::ScQueryViewSettingsPersistor
//
//  Synopsis:    Static method to get IPersistStream to load CViewSettingsPersistor
//               object from old style console file.
//
//               If the CViewSettingsObject is not created then create one.
//
//  Arguments:   [ppStream] - [out]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScQueryViewSettingsPersistor (IPersistStream **ppStream)
{
    DECLARE_SC(sc, _T("CNode::ScQueryViewSettingsPersistor"));
    sc = ScCheckPointers(ppStream);
    if (sc)
        return sc;

   // Create new CViewSettingsPersistor if none exists
   if (NULL == m_pViewSettingsPersistor)
   {
        sc = CComObject<CViewSettingsPersistor>::CreateInstance (&m_pViewSettingsPersistor);
        if (sc)
            goto ObjectCreationFailed;

        sc = ScCheckPointers(m_pViewSettingsPersistor, E_UNEXPECTED);
        if (sc)
            goto ObjectCreationFailed;

        m_pViewSettingsPersistor->AddRef();
    }

    sc = ScCheckPointers(m_pViewSettingsPersistor, E_UNEXPECTED);
    if (sc)
        goto ObjectCreationFailed;

    *ppStream = static_cast<IPersistStream*>(m_pViewSettingsPersistor);
    if (NULL == *ppStream)
        return (sc = E_UNEXPECTED);

    (*ppStream)->AddRef();

Cleanup:
    return (sc);

ObjectCreationFailed:
    CStr strMsg;
    strMsg.LoadString(GetStringModule(), IDS_ViewSettingCouldNotBePersisted);
    ::MessageBox(NULL, strMsg, NULL, MB_OK|MB_SYSTEMMODAL);
    goto Cleanup;
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScQueryViewSettingsPersistor
//
//  Synopsis:    Static method to get CXMLObject to load or save
//               CViewSettingsPersistor object from XML console file.
//
//               If the CViewSettingsObject is not created then create one.
//
//  Arguments:   [ppXMLObject] - [out]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScQueryViewSettingsPersistor (CXMLObject **ppXMLObject)
{
    DECLARE_SC(sc, _T("CNode::ScQueryViewSettingsPersistor"));
    sc = ScCheckPointers(ppXMLObject);
    if (sc)
        return sc;

    // Create new CViewSettingsPersistor if none exists
    if (NULL == m_pViewSettingsPersistor) // Create new one
    {
         sc = CComObject<CViewSettingsPersistor>::CreateInstance (&m_pViewSettingsPersistor);
         if (sc)
             goto ObjectCreationFailed;

         sc = ScCheckPointers(m_pViewSettingsPersistor, E_UNEXPECTED);
         if (sc)
             goto ObjectCreationFailed;

         m_pViewSettingsPersistor->AddRef();
     }

     sc = ScCheckPointers(m_pViewSettingsPersistor, E_UNEXPECTED);
     if (sc)
         goto ObjectCreationFailed;

     *ppXMLObject = static_cast<CXMLObject*>(m_pViewSettingsPersistor);
     if (NULL == *ppXMLObject)
         return (sc = E_UNEXPECTED);

 Cleanup:
     return (sc);

 ObjectCreationFailed:
     CStr strMsg;
     strMsg.LoadString(GetStringModule(), IDS_ViewSettingCouldNotBePersisted);
     ::MessageBox(NULL, strMsg, NULL, MB_OK|MB_SYSTEMMODAL);
     goto Cleanup;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CNode::ScDeleteViewSettings
//
//  Synopsis:    Delete the CViewSettings object for given view-id as the
//               view is being closed.
//
//  Arguments:   [nViewID] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScDeleteViewSettings (int nViewID)
{
    DECLARE_SC(sc, _T("CNode::ScDeleteViewSettings"));

    sc = ScCheckPointers(m_pViewSettingsPersistor, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_pViewSettingsPersistor->ScDeleteDataOfView(nViewID);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScOnDocumentClosing
//
//  Synopsis:    The document is closing, destroy any document related
//               objects like CViewSettingsPersistor.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScOnDocumentClosing ()
{
    DECLARE_SC(sc, _T("CNode::ScOnDocumentClosing"));

    if (m_pViewSettingsPersistor)
    {
        m_pViewSettingsPersistor->Release();
        m_pViewSettingsPersistor = NULL;
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CNode::ScSetFavoriteViewSettings
//
//  Synopsis:    A favorite is selected and it sets viewsettings
//               before re-selecting the node so that after re-selection
//               the new settings are set for the view.
//
//  Arguments:   [nViewID]      -
//               [bookmark]     -
//               [viewSettings] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScSetFavoriteViewSettings (int nViewID, const CBookmark& bookmark,
                                     const CViewSettings& viewSettings)
{
    DECLARE_SC(sc, _T("CNode::ScSetFavoriteViewSettings"));
    sc = ScCheckPointers(m_pViewSettingsPersistor, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_pViewSettingsPersistor->ScSetFavoriteViewSettings (nViewID, bookmark, viewSettings);
    if (sc)
        return sc;

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CNode::ScGetViewMode
//
//  Synopsis:    Get the viewmode if any persisted for this node.
//
//  Arguments:   [ulViewMode] - [out]
//
//  Returns:     SC, S_FALSE if none persisted.
//
//--------------------------------------------------------------------
SC CNode::ScGetViewMode (ULONG& ulViewMode)
{
    DECLARE_SC(sc, _T("CNode::ScGetViewMode"));

    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc;

    CBookmark *pBookmark = pMTNode->GetBookmark();
    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(m_pViewSettingsPersistor, pBookmark, pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_pViewSettingsPersistor->ScGetViewMode (pViewData->GetViewID(),
                                                  *pBookmark,
                                                  ulViewMode);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScSetViewMode
//
//  Synopsis:    Set the viewmode in persisted viewsettings.
//
//  Arguments:   [ulViewMode] - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScSetViewMode (ULONG ulViewMode)
{
    DECLARE_SC(sc, _T("CNode::ScSetViewMode"));

    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc;

    CBookmark *pBookmark = pMTNode->GetBookmark();
    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(m_pViewSettingsPersistor, pBookmark, pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_pViewSettingsPersistor->ScSetViewMode (pViewData->GetViewID(),
                                                  *pBookmark,
                                                  ulViewMode);
    if (sc)
        return sc;

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CNode::ScGetResultViewType
//
//  Synopsis:    Get the CResultViewType if any persisted for this node.
//
//  Arguments:   [rvt] - [out]
//
//  Returns:     SC, S_FALSE if none persisted.
//
//--------------------------------------------------------------------
SC CNode::ScGetResultViewType (CResultViewType& rvt)
{
    DECLARE_SC(sc, _T("CNode::ScGetResultViewType"));

    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc;

    CBookmark *pBookmark = pMTNode->GetBookmark();
    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(m_pViewSettingsPersistor, pBookmark, pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_pViewSettingsPersistor->ScGetResultViewType (pViewData->GetViewID(),
                                                        *pBookmark,
                                                        rvt);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScSetResultViewType
//
//  Synopsis:    Set the CResultViewType in persisted viewsettings.
//
//  Arguments:   [rvt] - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScSetResultViewType (const CResultViewType& rvt)
{
    DECLARE_SC(sc, _T("CNode::ScSetResultViewType"));

    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc;

    CBookmark *pBookmark = pMTNode->GetBookmark();
    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(m_pViewSettingsPersistor, pBookmark, pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_pViewSettingsPersistor->ScSetResultViewType (pViewData->GetViewID(),
                                                        *pBookmark,
                                                        rvt);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScGetTaskpadID
//
//  Synopsis:    Get the taskpad-id if any persisted for this node.
//               First see if there are any node-specific taskpad-id
//               else get the node-type-specific setting if one exists.
//
//  Arguments:   [rvt] - [out]
//
//  Returns:     SC, S_FALSE if none persisted.
//
//--------------------------------------------------------------------
SC CNode::ScGetTaskpadID (GUID& guidTaskpad)
{
    DECLARE_SC(sc, _T("CNode::ScGetTaskpadID"));

    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc;

    CViewData *pViewData = GetViewData();
    CBookmark *pBookmark = pMTNode->GetBookmark();
    sc = ScCheckPointers(m_pViewSettingsPersistor, pViewData, pBookmark, E_UNEXPECTED);
    if (sc)
        return sc;

    // 1. Try to get node-specific taskpad-id
    sc = m_pViewSettingsPersistor->ScGetTaskpadID (pViewData->GetViewID(),
                                                   *pBookmark,
                                                   guidTaskpad);
    if (sc == S_OK)
        return sc;

    // 2. Try to get nodetype specific taskpad-id.
    GUID guidNodeType;
    sc = pMTNode->GetNodeType(&guidNodeType);
    if (sc)
        return sc;

    sc = m_pViewSettingsPersistor->ScGetTaskpadID(pViewData->GetViewID(),
                                                  guidNodeType,
                                                  guidTaskpad);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScSetTaskpadID
//
//  Synopsis:    Set the taskpad-id in persisted viewsettings. Also see if
//               the taskpad is node-specific or nodetype-specific and persist
//               accordingly.
//
//  Arguments:   [guidTaskpad]   - [in]
//               [bSetDirty]     - [in], set the console file dirty.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScSetTaskpadID (const GUID& guidTaskpad, bool bSetDirty)
{
    DECLARE_SC(sc, _T("CNode::ScSetTaskpadID"));

    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc;

    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(m_pViewSettingsPersistor, pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    // Need to know if this task-pad is nodespecific or not.
    bool bNodeSpecific = false;
    CConsoleTaskpad *pTaskpad = NULL;
    sc = ScGetConsoleTaskpad (guidTaskpad, &pTaskpad);

    if (sc == S_OK) // S_OK if taskpad exists
    {
        sc = ScCheckPointers(pTaskpad, E_UNEXPECTED);
        if (sc)
            return sc;

        bNodeSpecific = pTaskpad->IsNodeSpecific();
    }
   // else  it may be viewextension or normal view (which are nodetype-specific).

    CBookmark *pBookmark = pMTNode->GetBookmark();
    sc = ScCheckPointers(pBookmark, E_UNEXPECTED);
    if (sc)
        return sc;

    if (bNodeSpecific)
    {
        // Per node taskpad
        sc = m_pViewSettingsPersistor->ScSetTaskpadID (pViewData->GetViewID(),
                                                       *pBookmark,
                                                       guidTaskpad,
                                                       bSetDirty);
    }
    else
    {
        // Per nodetype taskpad.
        GUID guidNodeType;
        sc = pMTNode->GetNodeType(&guidNodeType);
        if (sc)
            return sc;

        sc = m_pViewSettingsPersistor->ScSetTaskpadID(pViewData->GetViewID(),
                                                      guidNodeType,
                                                      *pBookmark,
                                                      guidTaskpad,
                                                      bSetDirty);
    }

    if (sc)
        return sc;

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\node.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      node.inl
 *
 *  Contents:  Inline functions for node.h
 *
 *  History:   9-Mar-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once


//_____________________________________________________________________________
//
//  Inlines for class:  CComponent
//_____________________________________________________________________________
//

inline CComponent::CComponent(CSnapIn * pSnapIn)
{
    Construct(pSnapIn, NULL);
}

inline HRESULT CComponent::Initialize(LPCONSOLE lpConsole)
{
    ASSERT(m_spIComponent != NULL);
    if (m_spIComponent == NULL)
        return E_FAIL;

    return m_spIComponent->Initialize(lpConsole);
}


inline HRESULT CComponent::Destroy(MMC_COOKIE cookie)
{
    ASSERT(m_spIComponent != NULL);
    if (m_spIComponent == NULL)
        return E_FAIL;

    return m_spIComponent->Destroy(cookie);
}

inline HRESULT CComponent::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                           LPDATAOBJECT* ppDataObject)
{
    ASSERT(m_spIComponent != NULL);
    if (m_spIComponent == NULL)
        return E_FAIL;

    ASSERT(type == CCT_RESULT || type == CCT_UNINITIALIZED);
    return m_spIComponent->QueryDataObject(cookie, type, ppDataObject);
}

inline HRESULT CComponent::GetResultViewType(MMC_COOKIE cookie, LPOLESTR* ppszViewType, long* pViewOptions)
{
    ASSERT(m_spIComponent != NULL);
    if (m_spIComponent == NULL)
        return E_FAIL;

    return m_spIComponent->GetResultViewType(cookie, ppszViewType, pViewOptions);
}

inline HRESULT CComponent::GetDisplayInfo(RESULTDATAITEM* pResultDataItem)
{
    ASSERT(m_spIComponent != NULL);
    if (m_spIComponent == NULL)
        return E_FAIL;

    return m_spIComponent->GetDisplayInfo(pResultDataItem);
}


//_____________________________________________________________________________
//
//  Inlines for class:  COCX
//_____________________________________________________________________________
//

inline COCX::COCX(void)
    : m_clsid(CLSID_NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(COCX);
}

inline COCX::~COCX(void)
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(COCX);
}

inline void COCX::SetControl(CLSID& clsid, IUnknown* pUnknown)
{
    m_clsid = clsid;
    m_spOCXWrapperUnknown = pUnknown;
}

inline void COCX::SetControl(LPUNKNOWN pUnkOCX, LPUNKNOWN pUnkOCXWrapper)
{
    m_spOCXUnknown = pUnkOCX;
    m_spOCXWrapperUnknown = pUnkOCXWrapper;
}


//____________________________________________________________________________
//
//  Inlines for class:      CNode
//____________________________________________________________________________
//


/*+-------------------------------------------------------------------------*
 * CNode::ToHandle
 * CNode::FromHandle
 *
 * Converts between HNODE's and CNode*'s.  Currently this is a direct mapping
 * via casting, but enventually there will be an indirect mapping that will
 * allow detection of stale HNODEs.
 *--------------------------------------------------------------------------*/

inline CNode* CNode::FromHandle (HNODE hNode)
{
    return (reinterpret_cast<CNode*>(hNode));
}

inline HNODE CNode::ToHandle (const CNode* pNode)
{
    return (reinterpret_cast<HNODE>(const_cast<CNode*>(pNode)));
}

inline void CNode::ResetFlags(void)
{
    //m_dwFlags &= ~flag_expanded_at_least_once;
    m_dwFlags = 0;
}

inline void CNode::SetExpandedAtLeastOnce(void)
{
    m_dwFlags |= flag_expanded_at_least_once;
}

inline BOOL CNode::WasExpandedAtLeastOnce(void)
{
    return (m_dwFlags & flag_expanded_at_least_once) ? TRUE : FALSE;
}

inline void CNode::SetExpandedVisually(bool bExpanded)
{
    if (bExpanded)
        m_dwFlags |= flag_expanded_visually;
    else
        m_dwFlags &= ~flag_expanded_visually;
}

inline bool CNode::WasExpandedVisually(void)
{
    return (m_dwFlags & flag_expanded_visually) ? true : false;
}

inline const CLSID& CNode::GetPrimarySnapInCLSID(void)
{
    CSnapIn* const pSnapIn = GetPrimarySnapIn();
    if (pSnapIn == NULL)
        return (GUID_NULL);

    return pSnapIn->GetSnapInCLSID();
}

inline CComponent* CNode::GetPrimaryComponent(void)
{
    ASSERT ((m_pPrimaryComponent != NULL) && m_pPrimaryComponent->IsInitialized());
    return m_pPrimaryComponent;
}

inline LPARAM CNode::GetUserParam(void)
{
    DECLARE_SC (sc, _T("CNode::GetUserParam"));

    CMTNode* pMTNode = GetMTNode();
    sc = ScCheckPointers (pMTNode, E_UNEXPECTED);
    if (sc)
        return (0);

    return (pMTNode->GetUserParam());
}

inline HRESULT CNode::GetNodeType(GUID* pGuid)
{
    DECLARE_SC (sc, _T("CNode::GetNodeType"));

    sc = ScCheckPointers (pGuid);
    if (sc)
        return (sc.ToHr());

    CMTNode* pMTNode = GetMTNode();
    sc = ScCheckPointers (pMTNode, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    return pMTNode->GetNodeType(pGuid);
}

inline HRESULT CNode::QueryDataObject(DATA_OBJECT_TYPES type,
                                                LPDATAOBJECT* ppdtobj)
{
    DECLARE_SC (sc, _T("CNode::QueryDataObject"));

    sc = ScCheckPointers (ppdtobj);
    if (sc)
        return (sc.ToHr());

    CMTNode* pMTNode = GetMTNode();
    sc = ScCheckPointers (pMTNode, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    return pMTNode->QueryDataObject(type, ppdtobj);
}

/*--------------------------------------------------------------------------*
 * CNode::ExtractColumnConfigID
 *
 *
 *--------------------------------------------------------------------------*/
inline HRESULT CNode::ExtractColumnConfigID(IDataObject* pDataObj, HGLOBAL& hGlobal)
{
    ASSERT(pDataObj != NULL);
    // Get the data
    return (DataObject_GetHGLOBALData (pDataObj, GetColumnConfigIDCF(),&hGlobal));
}

/*--------------------------------------------------------------------------*
 * CNode::GetColumnConfigIDCF
 *
 *
 *--------------------------------------------------------------------------*/
inline CLIPFORMAT CNode::GetColumnConfigIDCF()
{
    static CLIPFORMAT cfColumnConfigID = 0;

    if (cfColumnConfigID == 0)
    {
        USES_CONVERSION;
        cfColumnConfigID = (CLIPFORMAT) RegisterClipboardFormat (W2T (CCF_COLUMN_SET_ID));
        ASSERT (cfColumnConfigID != 0);
    }

    return (cfColumnConfigID);
}

inline CSnapInNode* CNode::GetStaticParent(void)
{
    CMTSnapInNode* pMTSINode = GetMTNode()->GetStaticParent();

    CNodeList& nodeList = pMTSINode->GetNodeList();
    POSITION pos = nodeList.GetHeadPosition();
    CNode* pNode = NULL;

    while (pos)
    {
        pNode = nodeList.GetNext(pos);
        if (pNode->GetViewID() == GetViewID())
            break;
    }
    ASSERT(pNode != NULL);

    return dynamic_cast<CSnapInNode*>(pNode);
}

inline CComponent* CNode::GetComponent(COMPONENTID nID)
{
    CMTSnapInNode* pMTSnapInNode = GetMTNode()->GetStaticParent();

    CComponent* pCC = pMTSnapInNode->GetComponent(GetViewID(), nID,
                                                  GetPrimarySnapIn());
    ASSERT(pCC != NULL);

    return pCC;
}

inline LPUNKNOWN CNode::GetControl(CLSID& clsid)
{
    DECLARE_SC(sc, TEXT("CNode::GetControl"));
    CSnapInNode* pSINode = GetStaticParent();

    sc = ScCheckPointers(pSINode, E_UNEXPECTED);
    if (sc)
        return NULL;

    return pSINode->GetControl(clsid);
}

inline void CNode::SetControl(CLSID& clsid, IUnknown* pUnknown)
{
    DECLARE_SC(sc, TEXT("CNode::SetControl"));

    CSnapInNode* pSINode = GetStaticParent();
    sc = ScCheckPointers(pSINode, E_UNEXPECTED);
    if (sc)
        return;

    pSINode->SetControl(clsid, pUnknown);
}

inline LPUNKNOWN CNode::GetControl(LPUNKNOWN pUnkOCX)
{
    DECLARE_SC(sc, TEXT("CNode::GetControl"));
    CSnapInNode* pSINode = GetStaticParent();
    sc = ScCheckPointers(pSINode, E_UNEXPECTED);
    if (sc)
        return NULL;

    return pSINode->GetControl(pUnkOCX);
}

inline void CNode::SetControl(LPUNKNOWN pUnkOCX, IUnknown* pUnknown)
{
    DECLARE_SC(sc, TEXT("CNode::SetControl"));
    CSnapInNode* pSINode = GetStaticParent();
    sc = ScCheckPointers(pSINode, E_UNEXPECTED);
    if (sc)
        return;

    pSINode->SetControl(pUnkOCX, pUnknown);
}

//_____________________________________________________________________________
//
//  Inlines for class:  CSnapInNode
//_____________________________________________________________________________
//

inline CComponent* CSnapInNode::GetComponent(const CLSID& clsid)
{
    for (int i=0; i < GetComponentArray().size(); i++)
    {
        if (GetComponentArray()[i] != NULL &&
            IsEqualCLSID(clsid, GetComponentArray()[i]->GetCLSID()) == TRUE)
            return GetComponentArray()[i];
    }
    return NULL;
}

inline CComponent* CSnapInNode::GetComponent(COMPONENTID nID)
{
    if (nID < GetComponentArray().size())
        return GetComponentArray()[nID];

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\nmutil.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      nmutil.cpp
 *
 *  Contents:  
 *
 *  History:   
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "nmutil.h"
#include "rsltitem.h"


COMPONENTID GetComponentID (CNode* pNode, CResultItem* pri /* =0 */)
{
    ASSERT(pNode != NULL || ((pri != NULL) && (pri->IsScopeItem())));

    CNode* pNodeContext = pNode;

    if ((pri != NULL) && pri->IsScopeItem())
        pNodeContext = CNode::FromResultItem (pri);

    ASSERT(pNodeContext != NULL);
    ASSERT(pNodeContext->IsInitialized() == TRUE);
    ASSERT(pNodeContext->GetPrimaryComponent() != NULL);
    return pNodeContext->GetPrimaryComponent()->GetComponentID();
}


CComponent* GetComponent (CNode* pNode, CResultItem* pri /* =0 */)
{
    ASSERT(pNode != NULL);

    if (pri != NULL)
    {
        if (pri->IsScopeItem())
        {
            CNode* pNode = CNode::FromResultItem (pri);
            if (pNode == NULL)
                return (NULL);

            if (pNode->IsInitialized() == FALSE)
            {
                HRESULT hr = pNode->InitComponents();
                if (FAILED(hr))
                    return NULL;
            }

            return pNode->GetPrimaryComponent();
        }
        else 
        {
            return pNode->GetComponent (pri->GetOwnerID());
        }
    }

    return pNode->GetPrimaryComponent();
}

void GetComponentsForMultiSel (CNode* pNode, CComponentPtrArray& rgComps)
{
    ASSERT(pNode != NULL);
    ASSERT(pNode->GetViewData() != NULL);
    ASSERT(rgComps.GetSize() == 0);

    HWND hwnd = pNode->GetViewData()->GetListCtrl();
    BOOL bVirtual = pNode->GetViewData()->IsVirtualList();

    ASSERT(hwnd != NULL);
    ASSERT(::IsWindow(hwnd));

    int iNext = ListView_GetNextItem(hwnd, -1, LVNI_SELECTED);

    CComponent* pCC;
    long lData;

    if (bVirtual)
    {
        pCC = pNode->GetPrimaryComponent();
    }
    else
    {
        lData = ListView_GetItemData(hwnd, iNext);
        ASSERT(lData != 0);
        pCC = ::GetComponent(pNode, CResultItem::FromHandle (lData));
    }

    if (pCC == NULL)
    {
        rgComps.RemoveAll();
        return;
    }
    
    rgComps.AddComponent(pCC);

    // if virtual list, all items are from the same component
    if (bVirtual)
        return;

    while ((iNext = ListView_GetNextItem(hwnd, iNext, LVNI_SELECTED)) != -1)
    {
        lData = ListView_GetItemData(hwnd, iNext);
        ASSERT(lData != 0);
        CComponent* pCCTemp = GetComponent(pNode, CResultItem::FromHandle (lData));
        
        if (pCCTemp == NULL)
        {
            rgComps.RemoveAll();
            return;
        }

        if (pCCTemp != pCC)
            rgComps.AddComponent(pCCTemp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\nodeinit.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       nodeinit.cpp
//
//--------------------------------------------------------------------------

// NodeInit.cpp : Implementation of CNodeMgrApp and DLL registration.

#include "stdafx.h"

#include "menuitem.h"           // MENUITEM_BASE_ID
#include "scopimag.h"
#include <bitmap.h>
#include "NodeMgr.h"
#include "amcmsgid.h"
#include "scopndcb.h"
#include "conframe.h"
#include "conview.h"
#include "constatbar.h"
#include "util.h"
#include "helpdoc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DEBUG_DECLARE_INSTANCE_COUNTER(CNodeInitObject);

IScopeTreePtr CNodeInitObject::m_spScopeTree = NULL;
// NTRAID#NTBUG9-461280-03-SEP-2002-jrowlett
// delimit chm urls with "::" instead of "::/"
#define TOPIC_DELIMITER _T("::")


/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNodeInitObject::InterfaceSupportsErrorInfo(REFIID riid)
{
    if (riid == IID_IConsole)
        return S_OK;
    return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// IFramePrivate implementation


CNodeInitObject::CNodeInitObject()
{
    Construct();
}

CNodeInitObject::~CNodeInitObject()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CNodeInitObject);
    TRACE_DESTRUCTOR (CNodeInitObject);
    Destruct();
}

void CNodeInitObject::Construct()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CNodeInitObject);
    TRACE_CONSTRUCTOR (CNodeInitObject);

    m_pLVImage = NULL;
    m_pTVImage = NULL;
    m_pToolbar = NULL;
    m_pImageListPriv = NULL;
    m_componentID = -1;

    m_pMTNode = NULL;
    m_pNode = NULL;
    m_bExtension = FALSE;

    m_spComponent = NULL;
    m_spConsoleVerb = NULL;

    m_sortParams.bAscending = TRUE;
    m_sortParams.nCol = -1;
    m_sortParams.lpResultCompare = NULL;
    m_sortParams.lpResultCompareEx = NULL;
    m_sortParams.lpUserParam = NULL;

    // IContextMenuProvider attributes
    VERIFY(SUCCEEDED(EmptyMenuList()));
}

void CNodeInitObject::Destruct()
{
    // Release all interfaces from the snap-in
    SAFE_RELEASE(m_pLVImage);
    SAFE_RELEASE(m_pTVImage);
    SAFE_RELEASE(m_pToolbar);
    SAFE_RELEASE(m_pImageListPriv);

// IContextMenuProvider attributes
    VERIFY( SUCCEEDED(EmptyMenuList()) );
}


STDMETHODIMP CNodeInitObject::ResetSortParameters()
{
    m_sortParams.nCol = -1;
    return (S_OK);
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetHeader
//
//  Synopsis:    This method is obsolete in MMC1.2
//
//  Arguments:
//
//  Note:        Should be called by IComponent object.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetHeader(IHeaderCtrl* pHeader)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::SetHeader"));

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetToolbar
//
//  Synopsis:    The toolbar interface used by IComponent.
//
//  Arguments:   [pToolbar]
//
//  Note:        Should be called by IComponent object.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetToolbar(IToolbar* pToolbar)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::SetToolbar"));

    if (GetComponent() == NULL)
    {
        sc = E_UNEXPECTED;
        TraceSnapinError(_T("This method is valid for IConsole of IComponent"), sc);
        return sc.ToHr();
    }

    // Release the OLD one
    SAFE_RELEASE(m_pToolbar);

    if (pToolbar != NULL)
    {
        m_pToolbar = pToolbar;
        m_pToolbar->AddRef();
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::QueryScopeImageList
//
//  Synopsis:    Get scope-pane's image list.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::QueryScopeImageList(LPIMAGELIST* ppImageList)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::QueryScopeImageList"));

    if (ppImageList == NULL)
    {
         sc = E_INVALIDARG;
         TraceSnapinError(_T("NULL LPIMAGELIST ptr"), sc);
         return sc.ToHr();
    }

    sc = ScCheckPointers(m_pImageListPriv, E_FAIL);
    if (sc)
        return sc.ToHr();

    *ppImageList = (IImageList*)m_pImageListPriv;
    m_pImageListPriv->AddRef();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::CreateScopeImageList
//
//  Synopsis:    Create the ScopeImage list.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::CreateScopeImageList(REFCLSID refClsidSnapIn)
{
    DECLARE_SC(sc, _T("CNodeInitObject::CreateScopeImageList"));

    if (m_pImageListPriv != NULL)
        return sc.ToHr();      // Already exists.

    try
    {
        CScopeTree* pScopeTree =
            dynamic_cast<CScopeTree*>((IScopeTree*)m_spScopeTree);

        sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CSnapInImageList *psiil =
            new CSnapInImageList(pScopeTree->GetImageCache(),
                                 refClsidSnapIn);

        m_pImageListPriv = (LPIMAGELISTPRIVATE)psiil;
    }
    catch( std::bad_alloc )
    {
        sc = E_OUTOFMEMORY;
    }

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::QueryResultImageList
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::QueryResultImageList(LPIMAGELIST *ppImageList)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::QueryResultImageList"));

    LPCONSOLE pConsole = (LPCONSOLE)this;
    sc = ScCheckPointers(pConsole, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pConsole->QueryInterface(IID_IImageList, (void**)ppImageList);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::UpdateAllViews
//
//  Synopsis:    Update all the views.
//
//  Arguments:   [lpDataObject] -
//               [data]
//               [hint]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::UpdateAllViews(LPDATAOBJECT lpDataObject,
                              LPARAM data, LONG_PTR hint)

{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::UpdateAllViews"));

    COMPONENTID id;
    GetComponentID(&id);

    sc = ScCheckPointers(m_pMTNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CMTSnapInNode* pMTSINode = m_pMTNode->GetStaticParent();

    sc = ScCheckPointers(pMTSINode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CNodeList& nodes = pMTSINode->GetNodeList();
    POSITION pos = nodes.GetHeadPosition();

    while (pos)
    {
        CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(nodes.GetNext(pos));

        sc = ScCheckPointers(pSINode, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CComponent* pCC = pSINode->GetComponent(id);
        sc = ScCheckPointers(pCC, E_UNEXPECTED);
        if (sc)
		{
			sc.TraceAndClear();
			continue;
		}

        pCC->Notify(lpDataObject, MMCN_VIEW_CHANGE, data, hint);
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::InsertColumn
//
//  Synopsis:    Insert a column is ListView.
//
//  Arguments:   [nCol]      - Column index.
//               [lpszTitle] - Name of the column.
//               [nFormat]   - Column style.
//               [nWidth]    - Column width.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::InsertColumn(int nCol, LPCWSTR lpszTitle, int nFormat, int nWidth)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::InsertColumn"));

    if (nCol < 0)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Column index is negative"), sc);
        return sc.ToHr();
    }

    if (!lpszTitle || !*lpszTitle)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Column name is NULL"), sc);
        return sc.ToHr();
    }

    if (nCol == 0 && nFormat != LVCFMT_LEFT)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Column zero must be LVCFMT_LEFT"), sc);
        return sc.ToHr();
    }

    if (nFormat != LVCFMT_LEFT && nFormat != LVCFMT_CENTER && nFormat != LVCFMT_RIGHT)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Unknown format for the Column"), sc);
        return sc.ToHr();
    }

    // Cannot hide column 0.
    if ( (0 == nCol) && (HIDE_COLUMN == nWidth))
        nWidth = AUTO_WIDTH;

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Insert the column into the listview
    sc = m_spListViewPrivate->InsertColumn(nCol, lpszTitle, nFormat, nWidth);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::DeleteColumn
//
//  Synopsis:    Delete a column
//
//  Arguments:   [nCol] - column index.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::DeleteColumn(int nCol)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::DeleteColumn"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->DeleteColumn(nCol);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetColumnText
//
//  Synopsis:    Modify column text.
//
//  Arguments:   [title] - new name.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetColumnText(int nCol, LPCWSTR title)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::SetColumnText"));

     if (!title || !*title)
     {
         sc = E_INVALIDARG;
         TraceSnapinError(_T("NULL column text"), sc);
         return sc.ToHr();
     }

     sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
     if (sc)
         return sc.ToHr();

     sc = m_spListViewPrivate->SetColumn(nCol, title, MMCLV_NOPARAM, MMCLV_NOPARAM);

     return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetColumnText
//
//  Synopsis:    Get the name of a column.
//
//  Arguments:   [nCol]  - Index of Column whose name is sought.
//               [pText] - Name.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetColumnText(int nCol, LPWSTR* pText)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::GetColumnText"));

    if (pText == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL text ptr"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->GetColumn(nCol, pText, MMCLV_NOPTR, MMCLV_NOPTR);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetColumnWidth
//
//  Synopsis:    Change width of a column
//
//  Arguments:   [nCol]   - Column index.
//               [nWidth] - new width.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetColumnWidth(int nCol, int nWidth)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::SetColumnWidth"));

    if (nCol < 0)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Negative column index"), sc);
        return sc.ToHr();
    }

    // job on parameter checking nWidth
    if (nWidth < 0 && ( (nWidth != MMCLV_AUTO) && (nWidth != HIDE_COLUMN) ) )
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid column width"), sc);
        return sc.ToHr();
    }

    // Cannot hide column 0.
    if ( (0 == nCol) && (HIDE_COLUMN == nWidth))
        nWidth = AUTO_WIDTH;

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->SetColumn(nCol, MMCLV_NOPTR, MMCLV_NOPARAM, nWidth);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetColumnWidth
//
//  Synopsis:    Get width of a column.
//
//  Arguments:   [nCol]   - col index.
//               [pWidth] - width.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetColumnWidth(int nCol, int* pWidth)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::GetColumnWidth"));

    if (nCol < 0 )
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Negative column index"), sc);
        return sc.ToHr();
    }

    if (pWidth == NULL)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("NULL width pointer"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->GetColumn(nCol, MMCLV_NOPTR, MMCLV_NOPTR, pWidth);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetColumnCount
//
//  Synopsis:    Returns the number of columns in listview.
//
//  Arguments:   [pnCol] - [out param], number of cols.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetColumnCount (INT* pnCol)
{
    DECLARE_SC(sc, _T("CNodeInitObject::GetColumnCount"));
    sc = ScCheckPointers(pnCol);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->GetColumnCount(pnCol);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetColumnInfoList
//
//  Synopsis:    Get the CColumnInfoList for current list-view headers.
//
//  Arguments:   [pColumnsList] - [out param], ptr to CColumnInfoList.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetColumnInfoList (CColumnInfoList *pColumnsList)
{
    DECLARE_SC(sc, _T("CNodeInitObject::GetColumnInfoList"));
    sc = ScCheckPointers(pColumnsList);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->GetColumnInfoList(pColumnsList);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::ModifyColumns
//
//  Synopsis:    Modify the columns with given data.
//
//  Arguments:   [columnsList] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::ModifyColumns (const CColumnInfoList& columnsList)
{
    DECLARE_SC(sc, _T("CNodeInitObject::ModifyColumns"));
    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->ModifyColumns(columnsList);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetDefaultColumnInfoList
//
//  Synopsis:    Get the original column settings supplied by the snapin.
//
//  Arguments:   [columnsList] - [out] the column settings
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetDefaultColumnInfoList (CColumnInfoList& columnsList)
{
    DECLARE_SC(sc, _T("CNodeInitObject::RestoreDefaultColumnSettings"));
    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->GetDefaultColumnInfoList(columnsList);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::ImageListSetIcon
//
//  Synopsis:    Set an icon in imagelist.
//
//  Arguments:   [pIcon] - HICON ptr.
//               [nLoc]  - index of this item.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::ImageListSetIcon(PLONG_PTR pIcon, LONG nLoc)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IImageList::ImageListSetIcon"));

    if (!pIcon)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL pIcon ptr"), sc);
        return sc.ToHr();
    }

    if(nLoc < 0)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Negative index"), sc);
        return sc.ToHr();
    }

    COMPONENTID id;
    GetComponentID(&id);

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->SetIcon(id, reinterpret_cast<HICON>(pIcon), nLoc);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::ImageListSetStrip
//
//  Synopsis:    Add strip of icons to image list.
//
//  Arguments:   [pBMapSm]   - Ptr to HBITMAP of 16x16.
//               [pBMapLg]   - Ptr to HBITMAP of 32x32.
//               [nStartLoc] - Start index.
//               [cMask]     - mask.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::ImageListSetStrip (
	PLONG_PTR	pBMapSm,
	PLONG_PTR	pBMapLg,
	LONG		nStartLoc,
	COLORREF	cMask)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IImageList::ImageListSetStrip"));

	HBITMAP hbmSmall = (HBITMAP) pBMapSm;
	HBITMAP hbmLarge = (HBITMAP) pBMapLg;

	/*
	 * valid start index?
	 */
    if (nStartLoc < 0)
    {
		sc = E_INVALIDARG;
        TraceSnapinError (_T("Negative start index"), sc);
        return (sc.ToHr());
    }

	/*
	 * valid bitmaps?
	 */
	sc = ScCheckPointers (hbmSmall, hbmLarge);
	if (sc)
	{
        TraceSnapinError (_T("Invalid bitmap"), sc);
		return (sc.ToHr());
	}

    BITMAP bmSmall;
    if (!GetObject (hbmSmall, sizeof(BITMAP), &bmSmall))
    {
		sc.FromLastError();
        TraceSnapinError (_T("Invalid Small bitmap object"), sc);
        return (sc.ToHr());
    }

    BITMAP bmLarge;
    if (!GetObject (hbmLarge, sizeof(BITMAP), &bmLarge))
    {
		sc.FromLastError();
        TraceSnapinError (_T("Invalid Large bitmap object"), sc);
        return (sc.ToHr());
    }

	/*
	 * are the small and large bitmaps of the integral dimensions,
	 * and do they have the same number of images?
	 */
    if ( (bmSmall.bmHeight != 16) || (bmLarge.bmHeight != 32) ||
		 (bmSmall.bmWidth   % 16) || (bmLarge.bmWidth   % 32) ||
		((bmSmall.bmWidth   / 16) != (bmLarge.bmWidth   / 32)))
    {
		sc = E_INVALIDARG;
        TraceSnapinError (_T("Invalid Bitmap size"), sc);
        return (sc.ToHr());
    }

    COMPONENTID id;
    GetComponentID(&id);

	/*
	 * m_spListViewPrivate == NULL is unexpected, however because we send
	 * MMCN_ADD_IMAGES when the result pane is an OCX (see CNode::OnSelect),
	 * this function often gets called when m_spListViewPrivate == NULL.
	 * Tracing this failure would be too noisy, since most OCX-based snap-ins
	 * would trigger it, so we'll return E_UNEXPECTED here without tracing.
	 * This is equivalent to MMC 1.2 behavior.
	 */
	if (m_spListViewPrivate == NULL)
		return (E_UNEXPECTED);

	/*
	 * add them to the imagelist
	 */
    sc = m_spListViewPrivate->SetImageStrip (id, hbmSmall, hbmLarge, nStartLoc, cMask);
    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::MapRsltImage
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::MapRsltImage(COMPONENTID id, int nSnapinIndex, int *pnConsoleIndex)
{
    DECLARE_SC(sc, _T("CNodeInitObject::MapRsltImage"));
    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Ret val can be E_, no need to check.
    sc = m_spListViewPrivate->MapImage(id, nSnapinIndex, pnConsoleIndex);
    HRESULT hr = sc.ToHr();
    sc.Clear();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::UnmapRsltImage
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::UnmapRsltImage(COMPONENTID id, int nConsoleIndex, int *pnSnapinIndex)
{
    DECLARE_SC(sc, _T("CNodeInitObject::UnmapRsltImage"));
    return (sc = E_NOTIMPL).ToHr();		// not needed now
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetChangeTimeOut
//
//  Synopsis:    Change timeout interval for filter attributes.
//
//  Arguments:   [uTimeout] - timeout
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetChangeTimeOut(unsigned long uTimeout)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::SetChangeTimeOut"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->SetChangeTimeOut(uTimeout);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetColumnFilter
//
//  Synopsis:    Set filter for a column.
//
//  Arguments:   [nColumn]     - Column index.
//               [dwType]      - Filter type.
//               [pFilterData] - Filter data.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetColumnFilter(UINT nColumn, DWORD dwType, MMC_FILTERDATA* pFilterData)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::SetColumnFilter"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->SetColumnFilter(nColumn, dwType, pFilterData);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetColumnFilter
//
//  Synopsis:    Get filter data.
//
//  Arguments:   [nColumn]     - Column index.
//               [pdwType]      - Filter type.
//               [pFilterData] - Filter data.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetColumnFilter(UINT nColumn, LPDWORD pdwType, MMC_FILTERDATA* pFilterData)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::GetColumnFilter"));

    if (pdwType == NULL)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("NULL filtertype ptr"), sc);
        return sc.ToHr();
    }

    if (NULL == pFilterData)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("NULL FilterData ptr"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->GetColumnFilter(nColumn, pdwType, pFilterData);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::ShowTopic
//
//  Synopsis:    Display specified help topic.
//
//  Arguments:   [pszHelpTopic]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::ShowTopic(LPOLESTR pszHelpTopic)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IDisplayHelp::ShowTopic"));

    // Get the AMCView window
    CConsoleView* pConsoleView = GetConsoleView();
    sc = ScCheckPointers(pConsoleView, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();


    /*
     * first MUI localize the help topic if possible so it matches what we have in the collection
     *
     */

    //NOTE: WTL::CString may throw exceptions; the following code matches exception handling behavior of CHelpDoc, 
    //which is to just let exceptions bubble up
    
    USES_CONVERSION;
    WTL::CString strPathTopic = W2T(pszHelpTopic);

    //the topic will be passed in formed like: "WINDOWS\help\sys_srv.chm::/sys_srv_overview.htm"
    //parse off the path and topic, which is delimited by "::"
    int iDelim = strPathTopic.Find(TOPIC_DELIMITER);
    if (iDelim == -1)
    {
        //invalid format
        sc = E_INVALIDARG;
        TraceSnapinError(_T("ShowTopic - Malformed help topic"), sc);
        return sc.ToHr();
    }

    //pass the path to CHelpDoc::ScRedirectHelpFile, which will localize it if possible
    WTL::CString strPath  = strPathTopic.Left(iDelim);
    WTL::CString strTopic = strPathTopic.Mid(iDelim + sizeof(TOPIC_DELIMITER)/sizeof(TOPIC_DELIMITER[0]) - 1);

    //langID is an out param; we aren't concerned with the results of it here
    LANGID langID;
    //ScRedirectHelpFile will convert strPath to localized path if possible
    sc = CHelpDoc::ScRedirectHelpFile(strPath, langID);
    if (sc)
        return sc.ToHr();

    //build the help topic back up
    strPathTopic.Format(_T("%s") TOPIC_DELIMITER _T("%s"),strPath, strTopic);

    sc = pConsoleView->ScShowSnapinHelpTopic ( (LPCTSTR)strPathTopic);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::AddExtension
//
//  Synopsis:    Add a dynamic extension snapin to given HSCOPEITEM.
//
//  Arguments:   [hItem]   -
//               [lpclsid] - CLSID of snapin to be added.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::AddExtension(HSCOPEITEM hItem, LPCLSID lpclsid)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::AddExtension"));

    COMPONENTID nID;
    GetComponentID(&nID);

    if (nID == -1)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    if (lpclsid == NULL)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("NULL LPCLSID ptr"), sc);
        return sc.ToHr();
    }

    CMTNode *pMTNode = CMTNode::FromScopeItem (hItem);

    if (pMTNode == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid hItem"), sc);
        return sc.ToHr();
    }

    // Can not add extensions to other components' nodes
    // Do we need to protect TV owned nodes that do not represent this snapin?
    if (pMTNode->GetOwnerID() != nID && pMTNode->GetOwnerID() != TVOWNED_MAGICWORD)
    {
        sc = E_INVALIDARG;
        return sc.ToHr();
    }

    sc = pMTNode->AddExtension(lpclsid);

    return sc.ToHr();
}


///////////////////////////////////////////////////////////////////////////////
// Private methods

HRESULT CNodeInitObject::CheckArgument(VARIANT* pArg)
{
    if (pArg == NULL)
        return E_POINTER;

    // VT_NULL is acceptable
    if (pArg->vt == VT_NULL)
        return S_OK;

    // VT_UNKNOWN with a valid pointer is acceptable
    if (pArg->punkVal != NULL)
    {
        if (pArg->vt == VT_UNKNOWN)
            return S_OK;
        else
            return E_INVALIDARG;
    }
    else
    {
        return E_POINTER;
    }

    // any other VT type is unacceptable
    return E_INVALIDARG;
}


///////////////////////////////////////////////////////////////////////////////
//
//
//
//

///////////////////////////////////////////////////////////////////////////////



STDMETHODIMP CNodeInitObject::QueryScopeTree(IScopeTree** ppScopeTree)
{

    ASSERT(ppScopeTree != NULL);

    if (ppScopeTree == NULL)
        return E_POINTER;

    ASSERT(m_spScopeTree != NULL);
    if (m_spScopeTree == NULL)
        return E_UNEXPECTED;

    *ppScopeTree = m_spScopeTree;
    (*ppScopeTree)->AddRef();

    return S_OK;

}

STDMETHODIMP CNodeInitObject::SetScopeTree(IScopeTree* pScopeTree)
{

    m_spScopeTree = pScopeTree;
    return S_OK;

}

HRESULT CNodeInitObject::GetSnapInAndNodeType(LPDATAOBJECT pDataObject,
                                    CSnapIn** ppSnapIn, GUID* pguidObjectType)
{
    ASSERT(pDataObject != NULL);
    ASSERT(ppSnapIn != NULL);
    ASSERT(pguidObjectType != NULL);


    CLSID clsidSnapin;
    HRESULT hr = ExtractSnapInCLSID(pDataObject, &clsidSnapin);
    if (FAILED(hr))
        return hr;

    CSnapIn* pSnapIn = NULL;
    SC sc = theApp.GetSnapInsCache()->ScGetSnapIn(clsidSnapin, &pSnapIn);
    if (sc)
        return sc.ToHr();
    // else
    ASSERT(pSnapIn != NULL);
    *ppSnapIn = pSnapIn;

    hr = ExtractObjectTypeGUID(pDataObject, pguidObjectType);

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SelectScopeItem
//
//  Synopsis:    Select given scope-item.
//
//  Arguments:   [hScopeItem]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SelectScopeItem(HSCOPEITEM hScopeItem)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::SelectScopeItem"));

    CViewData* pVD = (NULL == m_pNode ) ? NULL : m_pNode->GetViewData();

    CMTNode* pMTNode = CMTNode::FromScopeItem (hScopeItem);
    
    sc = ScCheckPointers(pMTNode);
    if (sc)
    {
        //bad handle passed in
        return sc.ToHr();
    }

    MTNODEID id = pMTNode->GetID();

    // If the currently selected node is same as the node being
    // asked to be selected, there is high probability that the
    // snapin is trying to change the view.
    // So set the viewchanging flag.
    CNode* pSelNode = (NULL == pVD) ? NULL : pVD->GetSelectedNode();
    CMTNode* pSelMTNode = (NULL == pSelNode) ? NULL : pSelNode->GetMTNode();

    if (pVD && pSelMTNode && (pSelMTNode == pMTNode) )
    {
        pVD->SetSnapinChangingView();
    }

    // Get the AMCView window
    CConsoleView* pConsoleView = GetConsoleView();

    sc = ScCheckPointers(pConsoleView, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CConsoleView::ViewPane ePane = pConsoleView->GetFocusedPane ();
    sc = pConsoleView->ScSelectNode (id);

    if (sc)
        return sc.ToHr();

    // ePane == ePane_None means active view is unknown
    if (ePane != CConsoleView::ePane_None)
        pConsoleView->ScSetFocusToPane (ePane);


    // Always reset the view changing flag.
    if (pVD)
    {
        pVD->ResetSnapinChangingView();
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::QueryConsoleVerb
//
//  Synopsis:    Get the IConsoleVerb for setting standard verbs.
//
//  Arguments:   [ppConsoleVerb]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::QueryConsoleVerb(LPCONSOLEVERB* ppConsoleVerb)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::QueryConsoleVerb"));

    if (ppConsoleVerb == NULL)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("NULL LPCONSOLEVERB ptr"), sc);
        return sc.ToHr();
    }

    if (m_pNode == NULL)
    {
        sc = E_FAIL;
        TraceSnapinError(_T("You can query console verb only from the IConsole associated with IComponents"), sc);
        return sc.ToHr();
    }

    if (m_spConsoleVerb == NULL)
    {
        // Create new CConsoleVerbImpl.
        CComObject<CConsoleVerbImpl>* pVerb;
        sc = CComObject<CConsoleVerbImpl>::CreateInstance(&pVerb);
        if (sc)
            return sc.ToHr();

        if (NULL == pVerb)
        {
            sc = E_OUTOFMEMORY;
            return sc.ToHr();
        }

        CViewData* pViewData = m_pNode->GetViewData();
        if (NULL == pViewData)
        {
            sc = E_UNEXPECTED;
            return sc.ToHr();
        }

        pVerb->SetVerbSet(m_pNode->GetViewData()->GetVerbSet());

        m_spConsoleVerb = pVerb;
        if (NULL == m_spConsoleVerb)
        {
            sc = E_NOINTERFACE;
            return sc.ToHr();
        }

    }

    *ppConsoleVerb = (IConsoleVerb*)m_spConsoleVerb;
    (*ppConsoleVerb)->AddRef();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::NewWindow
//
//  Synopsis:    Create a new window from given node.
//
//  Arguments:   [hScopeItem] - Root of new window.
//               [lOptions]   - New window options.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::NewWindow(HSCOPEITEM hScopeItem, unsigned long lOptions)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::NewWindow"));

    if (!hScopeItem)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL HSCOPEITEM"), sc);
        return sc.ToHr();
    }

    CConsoleFrame* pFrame = GetConsoleFrame();
    if (pFrame == NULL)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    CMTNode* pMTNode = CMTNode::FromScopeItem (hScopeItem);
    if (NULL == pMTNode)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    CreateNewViewStruct cnvs;
    cnvs.idRootNode     = pMTNode->GetID();
    cnvs.lWindowOptions = lOptions;
    cnvs.fVisible       = true;

    sc = pFrame->ScCreateNewView(&cnvs).ToHr();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::Expand
//
//  Synopsis:    Visually expand or collapse an item.
//
//  Arguments:   [hScopeItem] - Item to be expanded/collapsed.
//               [bExpand]    - Expand/Collapse.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::Expand( HSCOPEITEM hScopeItem, BOOL bExpand)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::Expand"));

    if (m_pNode == NULL || m_pNode->GetViewData() == NULL)
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    long id = 0;

    CMTNode* pMTNode = CMTNode::FromScopeItem (hScopeItem);
    if (pMTNode == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL HSCOPEITEM"), sc);
        return sc.ToHr();
    }

    id = pMTNode->GetID();

    {
        /*
         * tell this node's view to expand the node (use only this node's
         * view, don't default to the active view if we have no node)
         */
        CConsoleView* pConsoleView = GetConsoleView (false);
        if (pConsoleView == NULL)
        {
            sc = E_UNEXPECTED;
            return sc.ToHr();
        }

        sc = pConsoleView->ScExpandNode (id, bExpand, true);
    }

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::IsTaskpadViewPreferred
//
//  Synopsis:    Obsolete method.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::IsTaskpadViewPreferred()
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::IsTaskpadViewPreferred"));

    /*
     * taskpads always "preferred"
     */
    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetStatusText
//
//  Synopsis:    Change status bar text.
//
//  Arguments:   [pszStatusBarText]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetStatusText (LPOLESTR pszStatusBarText)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::SetStatusText"));

    if (m_pMTNode == NULL)
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    if (m_pNode == NULL)
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    CViewData* pViewData = m_pNode->GetViewData();
    if (NULL == pViewData)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    CNode* pSelectedNode = pViewData->GetSelectedNode();

    if (pSelectedNode == NULL)
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    CMTNode* pMTSelectedNode = pSelectedNode->GetMTNode();
    if (NULL == pMTSelectedNode)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    /*
     * fail if not from the selected node's branch of the scope tree
     */
    if (m_pMTNode->GetStaticParent() != pMTSelectedNode->GetStaticParent())
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    COMPONENTID nOwnerID = pSelectedNode->GetOwnerID();
    COMPONENTID nID;
    GetComponentID(&nID);

    /*
     * fail if not either the selected component or the static node
     */
    if (!((nOwnerID == nID) || ((nOwnerID == TVOWNED_MAGICWORD) && (nID == 0))))
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    CConsoleStatusBar* pStatusBar = pViewData->GetStatusBar();

    if (pStatusBar == NULL)
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    USES_CONVERSION;
    sc = pStatusBar->ScSetStatusText (W2CT (pszStatusBarText));

    return (sc.ToHr());
}

/*+-------------------------------------------------------------------------*
 *
 * CNodeInitObject::RenameScopeItem
 *
 * PURPOSE: Puts the specified scope item into rename mode.
 *
 * PARAMETERS:
 *    HSCOPEITEM  hScopeItem :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CNodeInitObject::RenameScopeItem(HSCOPEITEM hScopeItem)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, TEXT("IConsole3::RenameScopeItem"));

    CMTNode* pMTNode = CMTNode::FromScopeItem (hScopeItem);
    if (pMTNode == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL HSCOPEITEM"), sc);
        return sc.ToHr();
    }

    // get the console view object
    CConsoleView* pConsoleView = GetConsoleView (true); // default to the active view if m_pNode == NULL
    if (pConsoleView == NULL)
        return (sc = E_UNEXPECTED).ToHr();

    sc = pConsoleView->ScRenameScopeNode(CMTNode::ToHandle(pMTNode) /*convert to HMTNODE*/);

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 * CNodeInitObject::GetStatusBar
 *
 * Returns the status bar interface for the CNodeInitObject.
 *--------------------------------------------------------------------------*/

CConsoleStatusBar* CNodeInitObject::GetStatusBar(
    bool fDefaultToActive /* =true */) const
{
    CConsoleStatusBar* pStatusBar = NULL;

    /*
     * if we have a node, get the status bar from its view data
     */
    if (m_pNode != NULL)
    {
        ASSERT (m_pNode->GetViewData() != NULL);
        pStatusBar = m_pNode->GetViewData()->GetStatusBar();
    }

    /*
     * if we don't have a status bar yet, ask the main frame which one to use
     */
    if ((pStatusBar == NULL) && fDefaultToActive)
    {
        CConsoleFrame* pFrame = GetConsoleFrame();
        ASSERT (pFrame != NULL);

        if (pFrame != NULL)
            pFrame->ScGetActiveStatusBar(pStatusBar);
    }

    return (pStatusBar);
}


/*+-------------------------------------------------------------------------*
 * CNodeInitObject::GetConsoleView
 *
 * Returns the status bar interface for the CNodeInitObject.
 *--------------------------------------------------------------------------*/

CConsoleView* CNodeInitObject::GetConsoleView (
    bool fDefaultToActive /* =true */) const
{
    CConsoleView* pConsoleView = NULL;

    /*
     * if we have a node, get the console view from its view data
     */
    if (m_pNode != NULL)
    {
        ASSERT (m_pNode->GetViewData() != NULL);
        pConsoleView = m_pNode->GetViewData()->GetConsoleView();
    }

    /*
     * if we don't have a console view yet and we want to default to the
     * active view, ask the main frame which one to use
     */
    if ((pConsoleView == NULL) && fDefaultToActive)
    {
        CConsoleFrame* pFrame = GetConsoleFrame();
        ASSERT (pFrame != NULL);

        if (pFrame != NULL)
            pFrame->ScGetActiveConsoleView (pConsoleView);
    }

    return (pConsoleView);
}


/*+-------------------------------------------------------------------------*
 * CNodeInitObject::GetConsoleFrame
 *
 * Returns the CConsoleFrame interface for the console.
 *--------------------------------------------------------------------------*/

CConsoleFrame* CNodeInitObject::GetConsoleFrame() const
{
    CConsoleFrame*  pFrame = NULL;
    CScopeTree*     pTree  = dynamic_cast<CScopeTree*>(m_spScopeTree.GetInterfacePtr());
    ASSERT (pTree != NULL);

    if (pTree != NULL)
        pFrame = pTree->GetConsoleFrame();

    return (pFrame);
}


/*+-------------------------------------------------------------------------*
 * STRING_TABLE_FORWARDER_PROLOG
 *
 * Standard prolog code for IStringTable forwarder functions.
 *--------------------------------------------------------------------------*/

#define STRING_TABLE_FORWARDER_PROLOG(clsid, pSTP)              \
    CLSID clsid;                                                \
    VERIFY (SUCCEEDED (GetSnapinCLSID (clsid)));                \
                                                                \
    IStringTablePrivate* pSTP = CScopeTree::GetStringTable();   \
                                                                \
    if (pSTP == NULL)                                           \
        return (E_FAIL);                                        \
    else                                                        \
        (void) 0



//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::AddString
//
//  Synopsis:    Add a string to the string table.
//
//  Arguments:   [pszAdd] - string to add
//               [pID]    - ret, string id.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::AddString (
    LPCOLESTR       pszAdd,
    MMC_STRING_ID*  pID)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IStringTable::AddString"));

    STRING_TABLE_FORWARDER_PROLOG (clsid, pStringTablePrivate);
    sc = pStringTablePrivate->AddString (pszAdd, pID, &clsid);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetString
//
//  Synopsis:    Get the string represented by given id.
//
//  Arguments:   [id]
//               [cchBuffer] - Size of buffer.
//               [lpBuffer]
//               [pchchOut]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetString (
    MMC_STRING_ID   id,
    ULONG           cchBuffer,
    LPOLESTR        lpBuffer,
    ULONG*          pcchOut)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IStringTable::GetString"));

    STRING_TABLE_FORWARDER_PROLOG (clsid, pStringTablePrivate);
    sc = pStringTablePrivate->GetString (id, cchBuffer, lpBuffer, pcchOut, &clsid);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetStringLength
//
//  Synopsis:    Get the length of string represented by given string id.
//
//  Arguments:   [id] - string id.
//               [pcchString] - ret ptr to len.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetStringLength (
    MMC_STRING_ID   id,
    ULONG*          pcchString)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IStringTable::GetStringLength"));

    STRING_TABLE_FORWARDER_PROLOG (clsid, pStringTablePrivate);
    sc = pStringTablePrivate->GetStringLength (id, pcchString, &clsid);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::DeleteString
//
//  Synopsis:    Delete the string represented by given string id.
//
//  Arguments:   [id]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::DeleteString (
    MMC_STRING_ID   id)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IStringTable::DeleteString"));

    STRING_TABLE_FORWARDER_PROLOG (clsid, pStringTablePrivate);
    sc = pStringTablePrivate->DeleteString (id, &clsid);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::DeleteAllStrings
//
//  Synopsis:    Delete all strings (for this snapin).
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::DeleteAllStrings ()
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IStringTable::DeleteAllStrings"));

    STRING_TABLE_FORWARDER_PROLOG (clsid, pStringTablePrivate);
    sc = pStringTablePrivate->DeleteAllStrings (&clsid);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::FindString
//
//  Synopsis:    Find if given string exists, if so ret its string-id.
//
//  Arguments:   [pszFind] - string to find.
//               [pID]     - string id (retval).
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::FindString (
    LPCOLESTR       pszFind,
    MMC_STRING_ID*  pID)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IStringTable::FindString"));

    STRING_TABLE_FORWARDER_PROLOG (clsid, pStringTablePrivate);
    sc = pStringTablePrivate->FindString (pszFind, pID, &clsid);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::Enumerate
//
//  Synopsis:    Get an enumerator to (this snapins) string table.
//
//  Arguments:   [ppEnum]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::Enumerate (
    IEnumString**   ppEnum)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IStringTable::Enumerate"));

    STRING_TABLE_FORWARDER_PROLOG (clsid, pStringTablePrivate);
    sc = pStringTablePrivate->Enumerate (ppEnum, &clsid);

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 * CNodeInitObject::GetSnapinCLSID
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT CNodeInitObject::GetSnapinCLSID (CLSID& clsid) const
{
    SC sc; // We do not want to break if this function returns failure
           // so we do not use DECLARE_SC.

    ASSERT (!IsBadWritePtr (&clsid, sizeof (CLSID)));

    if (NULL == m_pMTNode)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    CSnapIn* pSnapin = m_pMTNode->GetPrimarySnapIn();

    if (NULL == pSnapin)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    clsid = pSnapin->GetSnapInCLSID();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodeInitObject::ReleaseCachedOleObjects
 *
 * PURPOSE: Releases cached OLE objects. Calls are made from CONUI
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
HRESULT CNodeInitObject::ReleaseCachedOleObjects()
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::GetSnapinCLSID"));

    sc = COleCacheCleanupManager::ScReleaseCachedOleObjects();
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\node.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       Node.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9/16/1996   RaviR   Created
//
//____________________________________________________________________________

#ifndef _MMC_NODE_H_
#define _MMC_NODE_H_
#pragma once

#include "amcmsgid.h"
#include "refcount.h"   // for CRefCountedObject

// A vector of strings to store column names
typedef std::vector<tstring> TStringVector;



///////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

class CComponent;
class CDataNotifyInfo;

class CNode;
    class CSnapInNode;


///////////////////////////////////////////////////////////////////////////////
// Forward declarations
class CConsoleTaskpad;
class CResultItem;
class CResultViewType;
class CMMCClipBoardDataObject;
class CViewSettingsPersistor;

///////////////////////////////////////////////////////////////////////////////
// Class declarations

//____________________________________________________________________________
//
//  class:      CComponent
//____________________________________________________________________________
//

class CComponent
{
    DECLARE_NOT_COPIABLE  (CComponent);
    DECLARE_NOT_ASSIGNABLE(CComponent);
public:
// Constructor & Destructor
    CComponent(CSnapIn * pSnapIn);
    virtual ~CComponent();

// Attributes
    const CLSID& GetCLSID() const
    {
        if (m_spSnapIn == NULL)
            return (GUID_NULL);

        return m_spSnapIn->GetSnapInCLSID();
    }

    CSnapIn* GetSnapIn(void) const
    {
        return m_spSnapIn;
    }

    IComponent* GetIComponent(void) const
    {
        return m_spIComponent;
    }

    IFramePrivate* GetIFramePrivate(void) const
    {
        return m_spIFrame;
    }

    IImageListPrivate* GetIImageListPrivate(void) const
    {
        return m_spIRsltImageList;
    }

// Operations
    // Initialization
    HRESULT Init(IComponentData* pIComponentData, HMTNODE hMTNode, HNODE lNode,
                 COMPONENTID nComponentID, int viewID);

    BOOL IsInitialized()
    {
        return (m_spIFrame != NULL);
    }

    LPUNKNOWN GetUnknownToLoad(void) const
    {
        return m_spIComponent;
    }

    // IComponent interface methods
    HRESULT Initialize(LPCONSOLE lpConsole);
    HRESULT Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LONG_PTR arg, LPARAM param);
    HRESULT Destroy(MMC_COOKIE cookie);
    HRESULT QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                            LPDATAOBJECT* ppDataObject);
    HRESULT GetResultViewType(MMC_COOKIE cookie, LPOLESTR* ppszViewType, long* pViewOptions);
    HRESULT GetDisplayInfo(RESULTDATAITEM* pResultDataItem);

    // IComponent2 helper
    SC      ScQueryDispatch(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, PPDISPATCH ppSelectedObject);

    void SetComponentID(COMPONENTID nID)
    {
        ASSERT(nID < 1000);
        m_ComponentID = nID;
    }

    COMPONENTID GetComponentID(void) const
    {
        return m_ComponentID;
    }

    void ResetComponentID(COMPONENTID id)
    {
        m_spIFrame->SetComponentID(m_ComponentID = id);
    }

    SC  ScResetConsoleVerbStates ();

    // loaded from stream/storage; initailized with the new one; or does not need initialization
    bool IsIComponentInitialized() 
    { 
        return m_bIComponentInitialized; 
    }

    // loaded from stream/storage; initailized with the new one; or does not need initialization
    void SetIComponentInitialized()
    { 
        m_bIComponentInitialized = true; 
    }

private:
// Implementation
    CSnapInPtr              m_spSnapIn;

    IComponentPtr           m_spIComponent;
    IFramePrivatePtr        m_spIFrame;
    IImageListPrivatePtr    m_spIRsltImageList;

    COMPONENTID             m_ComponentID;
    bool                    m_bIComponentInitialized;

    // Helper methods
    void Construct(CSnapIn * pSnapIn, CComponent* pComponent);

}; // class CComponent

class CComponentPtrArray : public CArray<CComponent*, CComponent*>
{
public:
    void AddComponent(CComponent* pCC)
    {
        for (int i = GetUpperBound(); i >= 0; --i)
        {
            if (GetAt(i) == pCC)
                return;
        }

        Add(pCC);
    }
};


//____________________________________________________________________________
//
//  class:      CNode
//
//  PURPOSE:    Each master tree node class (ie CMTxxx) has a matching CNode-derived
//              class. The CNode-derived class objects encapsulate the view-dependent
//              settings of the CMTNode derived object.
//
//____________________________________________________________________________
//

class CNode
{
    DECLARE_NOT_ASSIGNABLE(CNode);

// Constructor & Destructor
protected:
    // only from CSnapInNode
    CNode(CMTNode * pMTNode, CViewData* pViewData, bool fRootNode, bool fStaticNode);
public:
    CNode(CMTNode * pMTNode, CViewData* pViewData, bool fRootNode);
    CNode(const CNode& other);
    virtual ~CNode();

// converters
    static CNode*       FromHandle (HNODE hNode);
    static CNode*       FromResultItem (CResultItem* pri);
    static HNODE        ToHandle (const CNode* pNode);

// Attributes
    CViewData*          GetViewData(void)const      {ASSERT(m_pViewData != NULL); return m_pViewData;}
    int                 GetViewID(void)             {ASSERT(m_pViewData != NULL);return m_pViewData->GetViewID();}
    virtual UINT        GetResultImage()            {return m_pMTNode->GetImage();}
    void                SetDisplayName(LPCTSTR pName){m_pMTNode->SetDisplayName(pName);}
    void                SetResultItem(HRESULTITEM hri){m_hri = hri;}
    long                GetOwnerID(void) const{return m_pMTNode->GetOwnerID();}

    void                ResetFlags();
    void                SetExpandedAtLeastOnce();
    BOOL                WasExpandedAtLeastOnce();
    void                SetExpandedVisually(bool bExpanded);
    bool                WasExpandedVisually(void);
    bool                AllowNewWindowFromHere() const { return (m_pMTNode->AllowNewWindowFromHere()); }

    tstring             GetDisplayName(){return m_pMTNode->GetDisplayName();}
    CMTNode*            GetMTNode() const           {return m_pMTNode;}
    HRESULTITEM         GetResultItem() const       {return m_hri;}
    virtual BOOL        NeedsViewToBePersisted(void){return FALSE;}

    virtual CComponent* GetComponent(COMPONENTID nID);
    CComponent*         GetPrimaryComponent(void);
    HRESULT             InitComponents();

    // Overridables
    SC                  ScGetResultPane(CResultViewType &rvt, GUID *pGuidTaskpadID);
    BOOL                IsDynamicNode() const       {return !IsStaticNode();}
    BOOL                IsStaticNode() const        {return (m_fStaticNode);}

    BOOL                IsConsoleRoot(){return (GetMTNode()->Parent() == NULL);}
    BOOL                IsRootNode() const          {return m_fRootNode;}
    virtual LPUNKNOWN   GetControl(CLSID& clsid);
    virtual LPUNKNOWN   GetControl(LPUNKNOWN pUnkOCX);

    virtual void        SetControl(CLSID& clsid, IUnknown* pUnknown);
    virtual void        SetControl(LPUNKNOWN pUnkOCX, IUnknown* pUnknown);

    CSnapIn*            GetPrimarySnapIn(void)      {return GetPrimaryComponent()->GetSnapIn();}
    BOOL                IsInitialized(void)         {return !m_bInitComponents;}
    IUnknown*           GetControlbarsCache(void)
                                    {return m_pViewData->GetControlbarsCache();}

    HRESULT             OnSelect(LPUNKNOWN lpView, BOOL bSelect, BOOL bResultPaneIsWeb);
    HRESULT             OnScopeSelect(bool bSelect, SELECTIONINFO* pSelInfo);
    HRESULT             OnListPad(LONG_PTR arg, LPARAM param);
    HRESULT             IsTargetNode(CNode *pNodeTest)        {return E_FAIL;} // do not change.
    HRESULT             OnExpand(bool fExpand);
    HRESULT             OnGetPrimaryTask(IExtendTaskPad **ppExtendTaskPad);
    IFramePrivate *     GetIFramePrivate();
    HRESULT             GetTaskEnumerator(LPOLESTR pszTaskGroup, IEnumTASK** ppEnumTask);
    HRESULT             GetListPadInfo(IExtendTaskPad* pExtendTaskPad, LPOLESTR szTaskGroup,
                                    MMC_ILISTPAD_INFO* pIListPadInfo);
    void                ResetControlbars(BOOL bSelect, SELECTIONINFO* pSelInfo);

    void                ResetVerbSets(BOOL bSelect, SELECTIONINFO* pSelInfo);
    HRESULT             GetDataInfo(BOOL bSelect, SELECTIONINFO* pSelInfo, CDataNotifyInfo* pDNI);
    SC                  ScInitializeVerbs (bool bSelect, SELECTIONINFO* pSelInfo);

    void                OnTaskNotify(LONG_PTR arg, LPARAM param);
    virtual void        OnWebContextMenu()                       {};
    LPARAM              GetUserParam(void);
    HRESULT             GetDispInfoForListItem(LV_ITEMW* plvi);
    HRESULT             GetDispInfo(LV_ITEMW* plvi);

    HRESULT             OnColumnClicked(LONG_PTR nCol);
    HRESULT             OnInitOCX(IUnknown* pUnk);
    HRESULT             OnCacheHint(int nStartIndex, int nEndIndex);

    HRESULT             SendShowEvent(BOOL bSelect);

    HRESULT             OnColumnsChange(CColumnInfoList& colInfoList);
    SC                  ScSetViewExtension(GUID *pGuidViewId, bool bUseDefaultTaskpad, bool bSetViewSettingsDirty);
    SC                  ScGetDataObject(bool bScopePane, LPARAM lResultItemCookie, bool& bScopeItem, LPDATAOBJECT* ppDataObject, CComponent **ppCComponent = NULL, CNode **ppOwnerNode = NULL);
    SC                  ScGetPropertyFromINodeProperties(LPDATAOBJECT pDataObject, BOOL bForScopeItem, LPARAM resultItemParam, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue);
    SC                  ScExecuteShellCommand(BSTR Command, BSTR Directory, BSTR Parameters, BSTR WindowState);
    SC                  ScGetDropTargetDataObject(bool bScope, LPARAM lResultItemCookie, LPDATAOBJECT *ppDataObject);

    CSnapInNode*        GetStaticParent(void);
    HRESULT             QueryDataObject(DATA_OBJECT_TYPES type, LPDATAOBJECT* ppdtobj);
    HRESULT             GetNodeType(GUID* pGuid);
    SC                  ScSetupTaskpad(GUID *pGuidTaskpadID);
    HRESULT             RestoreSort(INT nCol, DWORD dwSortOptions);
    SC                  ScRestoreSortFromPersistedData();
    SC                  ScSaveSortData (int nCol, DWORD dwOptions);
    SC                  ScGetSnapinAndColumnDataID(GUID& snapinGuid, CXMLAutoBinary& columnID);
    SC                  ScRestoreResultView(const CResultViewType& rvt);
    SC                  ScRestoreViewMode();
    SC                  ScSaveColumnInfoList(CColumnInfoList& columnInfoList);
    const CLSID&        GetPrimarySnapInCLSID(void);
    HRESULT             ExtractColumnConfigID(IDataObject* pDataObj, HGLOBAL& phGlobal);
    CLIPFORMAT          GetColumnConfigIDCF();

    void                SetPrimaryComponent(CComponent* p) { ASSERT(m_pPrimaryComponent == NULL); m_pPrimaryComponent = p; }

    SC                  ScGetCurrentColumnData( CColumnInfoList& columnInfoList, TStringVector& strColNames);
    SC                  ScShowColumn(int iColIndex, bool bShow);
    SC                  ScSetUpdatedColumnData( CColumnInfoList& oldColumnInfoList, CColumnInfoList& newColumnInfoList);
    SC                  ScGetSortColumn(int *piSortCol);
    SC                  ScSetSortColumn(int iSortCol, bool bAscending);
    SC                  ScGetViewExtensions(CViewExtInsertIterator it);

    HRESULT             ShowStandardListView();
    HRESULT             OnActvate(LONG_PTR lActivate);
    HRESULT             OnMinimize(LONG_PTR fMinimized);

    void                Reset();
    void                SetInitComponents(BOOL b)          { m_bInitComponents = b; }
    void                OnColumns();

    /***************************************************************************\
     *
     * CLASS:  CDataObjectCleanup
     *
     * PURPOSE: Groups methods to register/trigger data object clenup when
     *          CNode, which data is put to data object goes away
     *
     * USAGE:   Used from CMMCClipBoardDataObject to register nodes put to it
     *          And used from ~CNode to trigger the cleanup
     *
    \***************************************************************************/
    class CDataObjectCleanup
    {
    public:
        static SC ScRegisterNode(CNode *pNode, CMMCClipBoardDataObject *pObject);
        static SC ScUnadviseDataObject(CMMCClipBoardDataObject *pObject, bool bForceDataObjectCleanup = true);
        static SC ScUnadviseNode(CNode *pNode);

        // mapping CNode to data object which contains it's data
        typedef std::multimap<CNode *, CMMCClipBoardDataObject *> CMapOfNodes;

    private:
        static CMapOfNodes s_mapOfNodes;
    };

    // CViewSettingsPersistor's persistence interfaces.
    static SC ScQueryViewSettingsPersistor(IPersistStream **ppStream);
    static SC ScQueryViewSettingsPersistor(CXMLObject     **ppXMLObject);
    static SC ScOnDocumentClosing();
    static SC ScDeleteViewSettings(int nVieWID);
    static SC ScSetFavoriteViewSettings (int nViewID, const CBookmark& bookmark, const CViewSettings& viewSettings);

    SC   ScSetViewMode (ULONG ulViewMode);
    SC   ScSetTaskpadID(const GUID& guidTaskpad, bool bSetDirty);

// Implementation
private:
    HRESULT             DeepNotify (MMC_NOTIFY_TYPE event, LONG_PTR arg, LPARAM param);
    SC                  ScInitializeViewExtension(const CLSID& clsid, CViewData *pViewData);

    void                CommonConstruct();

    // Get & Set persisted ViewSettings data.
    SC   ScGetTaskpadID(GUID& guidTaskpad);
    SC   ScGetConsoleTaskpad (const GUID& guidTaskpad, CConsoleTaskpad **ppTaskpad);

    SC   ScGetViewMode (ULONG& ulViewMode);

    SC   ScGetResultViewType   (CResultViewType& rvt);
    SC   ScSetResultViewType   (const CResultViewType& rvt);

private:
    CMTNode* const      m_pMTNode;              // ptr back to the master node.
    HRESULTITEM         m_hri;                  // this node's result item handle
    CViewData*          m_pViewData;
    DWORD               m_dwFlags;

    enum
    {
        flag_expanded_at_least_once = 0x00000001,
        flag_expanded_visually      = 0x00000002,
    };

    CComponent*     m_pPrimaryComponent;
    bool            m_bInitComponents : 1;
    const bool      m_fRootNode       : 1;
    const bool      m_fStaticNode     : 1;

    static CComObject<CViewSettingsPersistor>* m_pViewSettingsPersistor;
};


//____________________________________________________________________________
//
//  class:      COCX
//
//  Purpose:    Store the IUnknown ptr of OCX wrapper and an identifier for
//              the OCX. The identifier may be CLSID of the OCX or
//              the IUnknown ptr of the OCX.
//
//              In essence a OCXWrapper can be saved using CLSID of OCX as
//              the key (IComponent::GetResultViewType) or IUnknown* of OCX
//              as the key (IComponent2::GetResultViewType2).
//
//              Therefore we have overloaded version of SetControl below.
//
//____________________________________________________________________________
//

class COCX
{
public:
// Constructor & Destructor
    COCX(void);
    ~COCX(void);

// Attributes
    void SetControl(CLSID& clsid, IUnknown* pUnknown);
    BOOL IsControlCLSID(CLSID clsid) { return IsEqualCLSID(clsid, m_clsid); }
    IUnknown* GetControlUnknown()    { return m_spOCXWrapperUnknown;}

    void SetControl(LPUNKNOWN pUnkOCX, LPUNKNOWN pUnkOCXWrapper);

    //
    // Compare the IUnknown given and the one stored.
    //
    bool IsSameOCXIUnknowns(IUnknown *pOtherOCXUnknown) { return m_spOCXUnknown.IsEqualObject(pOtherOCXUnknown);}

// Implementation
private:

    // Only one of CLSID or m_spOCXUnknown is valid, see class purpose for details.
    CLSID               m_clsid;
    CComPtr<IUnknown>   m_spOCXUnknown;

    CComPtr<IUnknown>   m_spOCXWrapperUnknown;

}; // COCX


//____________________________________________________________________________
//
//  class:      CSnapInNode
//____________________________________________________________________________
//

class CSnapInNode : public CNode
{
public:
// Constructor & Destructor
    CSnapInNode(CMTSnapInNode* pMTNode, CViewData* pViewData, bool fRootNode);
    CSnapInNode(const CSnapInNode& other);
    ~CSnapInNode();

// Attributes
    virtual UINT GetResultImage();
    virtual BOOL NeedsViewToBePersisted(void) { return TRUE; }

    virtual void SetControl(CLSID& clsid, IUnknown* pUnknown);
    virtual LPUNKNOWN GetControl(CLSID& clsid);
    void CloseControls() { GetOCXArray().RemoveAll(); }
    virtual void SetControl(LPUNKNOWN pUnkOCX, IUnknown* pUnknown);
    virtual LPUNKNOWN GetControl(LPUNKNOWN pUnkOCX);

    CComponentArray& GetComponentArray(void)  { return m_spData->GetComponentArray(); }


// Operations
    // User interactions
    BOOL Activate(LPUNKNOWN pUnkResultsPane);
    BOOL DeActivate(HNODE hNode);
    BOOL Show(HNODE hNode);
    void Reset();

    int GetNumberOfComponents()
    {
        return GetComponentArray().size();
    }

    void AddComponentToArray(CComponent* pCC);
    CComponent* CreateComponent(CSnapIn* pSnapIn, int nID);
    CComponent* GetComponent(const CLSID& clsid);
    virtual CComponent* GetComponent(COMPONENTID nID);
    void DeleteComponent(COMPONENTID nID)
    {
        ASSERT(nID >= 0);
        int iMax = GetComponentArray().size() -1;
        ASSERT(nID <= iMax);

        if (nID < iMax)
        {
            delete GetComponentArray()[nID];
            GetComponentArray()[nID] = GetComponentArray()[iMax];
            GetComponentArray()[iMax] = 0;
            GetComponentArray()[iMax]->ResetComponentID(nID);
        }
        GetComponentArray().resize(iMax);
    }

    void SetResultImageList (IImageListPrivate* pImageList) { m_spData->SetImageList(pImageList); }

// Implementation
private:
    class CDataImpl
    {
    public:
        CDataImpl() :
            m_pImageList(NULL)
        {}

        ~CDataImpl()
        {
            Reset();
        }

        void Reset()
        {
            for (int i=0; i < m_ComponentArray.size(); i++)
                delete m_ComponentArray[i];

            m_ComponentArray.clear();
        }

    private:
        IImageListPrivate* m_pImageList;    // result image list

        // Components array.
        CComponentArray         m_ComponentArray;
        CArray<COCX, COCX&>     m_rgOCX;

    public:
        void                    SetImageList(IImageListPrivate *pImageList)
                                                    {m_pImageList = pImageList;}
        IImageListPrivate *     GetImageList()     {return m_pImageList;}
        CComponentArray &       GetComponentArray(){return m_ComponentArray;}
        CArray<COCX, COCX&> &   GetOCXArray()      {return m_rgOCX;}

    };  // CSnapInNode::CDataImpl

    typedef CRefCountedObject<CDataImpl>    CData;
    CData::SmartPtr                         m_spData;

    IImageListPrivate *         GetImageList()     {return m_spData->GetImageList();}
    CArray<COCX, COCX&> &       GetOCXArray()      {return m_spData->GetOCXArray();}

}; // CSnapInNode


#include "node.inl"

#endif // _MMC_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\nodeinit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       nodeinit.h
//
//--------------------------------------------------------------------------

// NodeInit.h : Declaration of the CNodeInitObject

#ifndef _NODEINIT_H_
#define _NODEINIT_H_

class CMenuItem;
class SnapinStruct;
class CCommandSink;
class CImageIndexMap;
class CMTNode;
class CNode;
class CSnapIn;
class CConsoleFrame;
class CConsoleView;
class CConsoleStatusBar;
class CContextMenu;
class CMenuItem;

interface IExtendContextMenu;

typedef CList<CMenuItem*, CMenuItem*> MenuItemList;
typedef CList<SnapinStruct*, SnapinStruct*> SnapinStructList;

typedef long MENU_OWNER_ID;

/////////////////////////////////////////////////////////////////////////////
// NodeMgr

#include <pshpack8.h>

class CNodeInitObject :
    public IFramePrivate,
    public IHeaderCtrlPrivate,
    public IContextMenuProvider,
    public IResultDataPrivate,
    public IScopeDataPrivate,
    public IImageListPrivate,
    public ISupportErrorInfo,
    public IDisplayHelp,
    public IStringTable,
    public CPropertySheetProvider,
    public CColumnData,
    public CComObjectRoot,
    public CComCoClass<CNodeInitObject, &CLSID_NodeInit>
{
// Constructor/Destructor
public:
    CNodeInitObject();
    ~CNodeInitObject();

    friend CColumnData;

BEGIN_COM_MAP(CNodeInitObject)
    COM_INTERFACE_ENTRY(IFramePrivate)
    COM_INTERFACE_ENTRY(IConsole)
    COM_INTERFACE_ENTRY(IConsole2)
    COM_INTERFACE_ENTRY(IConsole3)
    COM_INTERFACE_ENTRY(IHeaderCtrl)
    COM_INTERFACE_ENTRY(IHeaderCtrl2)
    COM_INTERFACE_ENTRY(IHeaderCtrlPrivate)
    COM_INTERFACE_ENTRY(IContextMenuProvider)
//  THis interface used to be exposed on this class, and removing it may
//  expose compatibility problems [vivekj]
//  COM_INTERFACE_ENTRY(IContextMenuCallback)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IResultData)
    COM_INTERFACE_ENTRY(IResultData2)
    COM_INTERFACE_ENTRY(IResultDataPrivate)
    COM_INTERFACE_ENTRY(IConsoleNameSpace)
    COM_INTERFACE_ENTRY(IConsoleNameSpace2)
    COM_INTERFACE_ENTRY(IScopeDataPrivate)
    COM_INTERFACE_ENTRY(IImageList)
    COM_INTERFACE_ENTRY(IImageListPrivate)
    COM_INTERFACE_ENTRY(IPropertySheetProviderPrivate)
    COM_INTERFACE_ENTRY(IPropertySheetProvider)
    COM_INTERFACE_ENTRY(IPropertySheetCallback)
    COM_INTERFACE_ENTRY(IPropertySheetNotify)
    COM_INTERFACE_ENTRY(IDisplayHelp)
    COM_INTERFACE_ENTRY(IStringTable)
    COM_INTERFACE_ENTRY_FUNC(IID_IColumnData, 0, ColumnInterfaceFunc)
END_COM_MAP()
// Use DECLARE_NOT_AGGREGATABLE(CNodeInitObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CNodeInitObject)

DECLARE_MMC_OBJECT_REGISTRATION (
    g_szMmcndmgrDll,                    // implementing DLL
    CLSID_NodeInit,                     // CLSID
    _T("NodeInit 1.0 Object"),          // class name
    _T("NODEMGR.NodeInitObject.1"),     // ProgID
    _T("NODEMGR.NodeInitObject"))       // version-independent ProgID

IMPLEMENTS_SNAPIN_NAME_FOR_DEBUG()

public:
// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
#ifdef DBG
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
    int dbg_InstID;
#endif // DBG

// IFramePrivate
public:
    STDMETHOD(CreateScopeImageList)(REFCLSID refClsidSnapIn);
    STDMETHOD(SetResultView)(LPUNKNOWN pUnknown);
    STDMETHOD(IsResultViewSet)(BOOL* pbIsLVSet);
    STDMETHOD(SetTaskPadList)(LPUNKNOWN pUnknown);
    STDMETHOD(GetComponentID)(COMPONENTID* lpComponentID);
    STDMETHOD(SetComponentID)(COMPONENTID id);
    STDMETHOD(SetNode)(HMTNODE hMTNode, HNODE hNode = NULL);
    STDMETHOD(QueryScopeTree)(IScopeTree** ppScopeTree);
    STDMETHOD(SetScopeTree)(IScopeTree* pScopeTree);
    STDMETHOD(SetComponent)(LPCOMPONENT lpComponent);
    STDMETHOD(SetUsedByExtension)(BOOL bExtension);
    STDMETHOD(IsUsedByExtension)(void);
    STDMETHOD(GetMainWindow)(HWND* phwnd);

    HWND GetMainWindow()
    {
        ASSERT(m_spScopeTree != NULL);
		if (m_spScopeTree == NULL)
			return NULL;

        CScopeTree* const pst = dynamic_cast<CScopeTree*>(&*m_spScopeTree);
        ASSERT(pst != NULL);
        return (pst != NULL && m_spScopeTree != NULL) ?
            pst->GetMainWindow() : NULL;
    }

    CMTNode* GetMTNode() { return m_pMTNode;}

    STDMETHOD(InitViewData)(LONG_PTR lViewData);
    STDMETHOD(CleanupViewData)(LONG_PTR lViewData);
    STDMETHOD(ResetSortParameters)();

    STDMETHOD(ReleaseCachedOleObjects)();

// IConsole2
public:
    STDMETHOD(Expand)(HSCOPEITEM hItem, BOOL bExpand);
    STDMETHOD(IsTaskpadViewPreferred)();
    STDMETHOD(SetStatusText)(LPOLESTR pszStatusText);

// IConsole3
public:
    STDMETHOD(RenameScopeItem)(HSCOPEITEM hScopeItem);

protected:
    static IScopeTreePtr    m_spScopeTree;
    IConsoleVerbPtr         m_spConsoleVerb;
    CMTNode*                m_pMTNode;
    CNode*                  m_pNode;
    BOOL                    m_bExtension;

// IFrame
public:
    STDMETHOD(QueryResultView)(LPUNKNOWN* ppIUnknown);
    STDMETHOD(SetHeader)(IHeaderCtrl* pHeader);
    STDMETHOD(SetToolbar)(IToolbar* pToolbar);
    STDMETHOD(QueryScopeImageList)(LPIMAGELIST *ppImageList);
    STDMETHOD(QueryResultImageList)(LPIMAGELIST *ppImageList);
    STDMETHOD(MessageBox)(LPCWSTR lpszText, LPCWSTR lpszTitle, UINT fuStyle, int* piRetval);
    STDMETHOD(UpdateAllViews)(LPDATAOBJECT lpDataObject, LPARAM data, LONG_PTR hint);
    STDMETHOD(QueryConsoleVerb)(LPCONSOLEVERB* ppConsoleVerb);
    STDMETHOD(SelectScopeItem)(HSCOPEITEM hScopeItem);
    STDMETHOD(NewWindow)(HSCOPEITEM hScopeItem, unsigned long lOptions);

// IFrames members
protected:
    LPUNKNOWN           m_pLVImage;
    LPUNKNOWN           m_pTVImage;
    LPUNKNOWN           m_pToolbar;
    LPIMAGELISTPRIVATE  m_pImageListPriv;
    COMPONENTID         m_componentID;
    IComponentPtr       m_spComponent;

    IUnknownPtr         m_spResultViewUnk;      // IUnknown for the result view

public:
    CConsoleFrame*     GetConsoleFrame() const;
    CConsoleView*      GetConsoleView(bool fDefaultToActive = true) const;
    CConsoleStatusBar* GetStatusBar  (bool fDefaultToActive = true) const;

///////////////////////////////////////////////////////////////////////////////
// IHeaderCtrl interface

protected:
    STDMETHOD(InsertColumn)(int nCol, LPCWSTR lpszTitle, int nFormat, int nWidth);
    STDMETHOD(DeleteColumn)(int nCol);
    STDMETHOD(SetColumnWidth)(int nCol, int nWidth);
    STDMETHOD(GetColumnText)(int nCol, LPWSTR* pText);
    STDMETHOD(SetColumnText)(int nCol, LPCWSTR title);
    STDMETHOD(GetColumnWidth)(int nCol, int* pWidth);

// IHeaderCtrl2 interface
    STDMETHOD(SetChangeTimeOut)(unsigned long uTimeout);
    STDMETHOD(SetColumnFilter)(UINT nColumn, DWORD dwType, MMC_FILTERDATA* pFilterData);
    STDMETHOD(GetColumnFilter)(UINT nColumn, LPDWORD pType, MMC_FILTERDATA* pFilterData);

// IHeaderCtrlPrivate interface.
    STDMETHOD(GetColumnCount)(INT* pnCol);
    STDMETHOD(GetColumnInfoList)(/*[out]*/ CColumnInfoList *pColumnsList);
    STDMETHOD(ModifyColumns)(/*[in]*/ const CColumnInfoList& columnsList);
    STDMETHOD(GetDefaultColumnInfoList)(/*[out]*/ CColumnInfoList& columnsList);

private:
    CCLVSortParams          m_sortParams;


///////////////////////////////////////////////////////////////////////////////
// IDisplayHelp interface

protected:
    STDMETHOD(ShowTopic)(LPOLESTR pszHelpTopic);


///////////////////////////////////////////////////////////////////////////////
// IStringTable interface

protected:
    STDMETHOD(AddString)        (LPCOLESTR pszAdd, MMC_STRING_ID* pID);
    STDMETHOD(GetString)        (MMC_STRING_ID id, ULONG cchBuffer, LPOLESTR lpBuffer, ULONG* pcchOut);
    STDMETHOD(GetStringLength)  (MMC_STRING_ID id, ULONG* pcchString);
    STDMETHOD(DeleteString)     (MMC_STRING_ID id);
    STDMETHOD(DeleteAllStrings) ();
    STDMETHOD(FindString)       (LPCOLESTR pszFind, MMC_STRING_ID* pID);
    STDMETHOD(Enumerate)        (IEnumString** ppEnum);

    HRESULT GetSnapinCLSID (CLSID& pclsid) const;

///////////////////////////////////////////////////////////////////////////////
// IResultDataPrivate interface

protected:
    IMMCListViewPtr m_spListViewPrivate;

    STDMETHOD(Arrange)(long style);
    STDMETHOD(InsertItem)(LPRESULTDATAITEM item);
    STDMETHOD(DeleteItem)(HRESULTITEM itemID, int nCol);
    STDMETHOD(FindItemByLParam)(LPARAM lParam, HRESULTITEM *pItemID);
    STDMETHOD(DeleteAllRsltItems)();
    STDMETHOD(SetItem)(LPRESULTDATAITEM item);
    STDMETHOD(GetItem)(LPRESULTDATAITEM item);
    STDMETHOD(ModifyItemState)(int nIndex, HRESULTITEM ItemID, UINT uAdd, UINT uRemove);
    STDMETHOD(ModifyViewStyle)(MMC_RESULT_VIEW_STYLE add, MMC_RESULT_VIEW_STYLE remove);
    STDMETHOD(GetNextItem)(LPRESULTDATAITEM item);
    STDMETHOD(SetViewMode)(LONG nViewMode);
    STDMETHOD(GetViewMode)(LONG* nViewMode);
    STDMETHOD(ResetResultData)();
    STDMETHOD(GetListStyle)(long * pStyle);
    STDMETHOD(SetListStyle)(long Style);
    STDMETHOD(UpdateItem)(HRESULTITEM itemID);
    STDMETHOD(Sort)(int nCol, DWORD dwSortOptions, LPARAM lUserParam);
    STDMETHOD(InternalSort)(INT nCol, DWORD dwSortOptions, LPARAM lUserParam, BOOL bColumnClicked);
    STDMETHOD(SetDescBarText)(LPOLESTR DescText);
    STDMETHOD(SetItemCount)(int nItemCount, DWORD dwOptions);
    STDMETHOD(SetLoadMode)(BOOL bState);
    STDMETHOD(GetSortColumn)(INT* pnCol);
    STDMETHOD(GetSortDirection)(BOOL* pbAscending);

    // IResultData2
    STDMETHOD(RenameResultItem)(HRESULTITEM itemID);

///////////////////////////////////////////////////////////////////////////////
// IScopeData interface

protected:
// IConsoleNameSpace methods
    STDMETHOD(InsertItem)(LPSCOPEDATAITEM item);
    STDMETHOD(DeleteItem)(HSCOPEITEM hItem, long fDeleteThis);
    STDMETHOD(SetItem)(LPSCOPEDATAITEM  item);
    STDMETHOD(GetItem)(LPSCOPEDATAITEM  item);
    STDMETHOD(GetChildItem)(HSCOPEITEM item, HSCOPEITEM* pItemChild,
                            MMC_COOKIE* pCookie);
    STDMETHOD(GetNextItem)(HSCOPEITEM item, HSCOPEITEM* pItemNext,
                            MMC_COOKIE* pCookie);
    STDMETHOD(GetParentItem)(HSCOPEITEM item, HSCOPEITEM* pItemParent,
                            MMC_COOKIE* pCookie);

// IConsoleNameSpace2 method(s)
    STDMETHOD(Expand)(HSCOPEITEM hItem);
    STDMETHOD(AddExtension)(HSCOPEITEM hItem, LPCLSID lpclsid);

private:

    enum EGetItem
    {
        egiParent = 1,
        egiChild = 2,
        egiNext = 3
    };

    HRESULT GetRelativeItem(EGetItem egi, HSCOPEITEM item, HSCOPEITEM* pItem,
                            MMC_COOKIE* pCookie);


///////////////////////////////////////////////////////////////////////////////
// IContextMenuCallback interface

public:
    STDMETHOD(AddItem) ( CONTEXTMENUITEM* pItem );

///////////////////////////////////////////////////////////////////////////////
// IContextMenuProvider interface

public:
    STDMETHOD(EmptyMenuList) ();
    STDMETHOD(AddThirdPartyExtensionItems) (
                                IDataObject* piDataObject );
    STDMETHOD(AddPrimaryExtensionItems) (
                                IUnknown*    piCallback,
                                IDataObject* piDataObject );
    STDMETHOD(ShowContextMenu) (HWND    hwndParent,
                                LONG    xPos,
                                LONG    yPos,
                                LONG*   plSelected);

private:
    ContextMenuPtr              m_spContextMenu;
    CContextMenu *              GetContextMenu();

///////////////////////////////////////////////////////////////////////////////
// IImageListPrivate interface
public:
    STDMETHOD(ImageListSetIcon)(PLONG_PTR pIcon, LONG nLoc);
    STDMETHOD(ImageListSetStrip)(PLONG_PTR pBMapSm, PLONG_PTR pBMapLg,
                                 LONG nStartLoc, COLORREF cMask);

    STDMETHOD(MapRsltImage)(COMPONENTID id, int nSnapinIndex, int *pnConsoleIndex);
    STDMETHOD(UnmapRsltImage)(COMPONENTID id, int nConsoleIndex, int *pnSnapinIndex);

///////////////////////////////////////////////////////////////////////////////
// IToobar interface

///////////////////////////////////////////////////////////////////////////////
// Node Manager internal members
private:
    void Construct();
    void Destruct();

    HRESULT CheckArgument(VARIANT* pArg);

    SC      ScIsVirtualList(bool& bVirtual);
public:
    HRESULT static GetSnapInAndNodeType(LPDATAOBJECT pDataObject,
                                 CSnapIn** ppSnapIn, GUID* pguidObjectType);

    IComponent* GetComponent() { return m_spComponent;}
};

#include <poppack.h>

inline STDMETHODIMP CNodeInitObject::GetComponentID(COMPONENTID* lpComponentID)
{
    ASSERT(m_componentID != -1); // The component ID has not been set yet!!!
    ASSERT(lpComponentID);

    *lpComponentID = m_componentID;

    return S_OK;
}

inline STDMETHODIMP CNodeInitObject::SetComponentID(COMPONENTID id)
{
/* for dynamic icon, we need to change this value temporarily
    if (m_componentID != -1)
    {
        ASSERT(FALSE);  // ID already has been set!!!
        return E_UNEXPECTED;
    }

    ASSERT(id != -1);
*/
    m_componentID = id;
    return S_OK;
}

inline STDMETHODIMP CNodeInitObject::SetNode(HMTNODE hMTNode, HNODE hNode)
{
    m_pMTNode = CMTNode::FromHandle(hMTNode);
    m_pNode   = CNode::FromHandle(hNode);
    return S_OK;
}

inline STDMETHODIMP CNodeInitObject::SetComponent(LPCOMPONENT lpComponent)
{
    if (lpComponent == NULL)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    m_spComponent = lpComponent;

    return S_OK;
}

inline STDMETHODIMP CNodeInitObject::SetUsedByExtension(BOOL bExtension)
{
    m_bExtension = bExtension;
    return S_OK;
}

inline STDMETHODIMP CNodeInitObject::IsUsedByExtension(void)
{
    return m_bExtension ? S_OK : S_FALSE;
}

inline SC  CNodeInitObject::ScIsVirtualList(bool& bVirtual)
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::ScIsVirtualList"));
    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc;

    long lStyle = m_spListViewPrivate->GetListStyle();

    bVirtual = (lStyle & LVS_OWNERDATA);

    return sc;
}


inline STDMETHODIMP CNodeInitObject::GetMainWindow(HWND* phwnd)
{
    if (phwnd == NULL)
        return E_POINTER;
    *phwnd = GetMainWindow();
    ASSERT(*phwnd != NULL);
    return (*phwnd != NULL) ? S_OK : E_UNEXPECTED;
}

// Used for getting snapin name for debug info.

inline void Debug_SetNodeInitSnapinName(CSnapInPtr pSnapIn, IFramePrivate* pIFrame)
{
#ifdef DBG
    CNodeInitObject* pNodeInitObj = dynamic_cast<CNodeInitObject*>(pIFrame);

    if ((pSnapIn != NULL) && (pNodeInitObj != NULL))
    {
        WTL::CString strSnapInName;
        SC sc = pSnapIn->ScGetSnapInName(strSnapInName);
        if (sc)
            return;

        if (!strSnapInName.IsEmpty())
        {
            pNodeInitObj->SetSnapinName(strSnapInName);
            CColumnData* pColumnData = dynamic_cast<CColumnData*>(pNodeInitObj);
            if (pColumnData)
                pColumnData->SetSnapinName(strSnapInName);
        }
    };
#endif
}


#endif // _NODEINIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\nodemgr.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       nodemgr.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1/27/1997   RaviR   Created
//____________________________________________________________________________
//



#ifndef MMC_NODEMGR_H_
#define MMC_NODEMGR_H_

class CSnapInsCache;

class CNodeMgrApp : public COleCacheCleanupObserver
{
public:
    CNodeMgrApp() : m_pSnapInsCache(NULL), m_bProcessingSnapinChanges(FALSE)
    {
        // register to be notified when everything cached needs to be released.
        COleCacheCleanupManager::AddOleObserver(this);
    }

    ~CNodeMgrApp()
    {
    }
    
    virtual SC ScOnReleaseCachedOleObjects();

    virtual void Init();
    virtual void DeInit();

    CSnapInsCache* GetSnapInsCache(void) 
    { 
        return m_pSnapInsCache; 
    }

    void SetSnapInsCache(CSnapInsCache* pSIC);

    void SetProcessingSnapinChanges(BOOL bProcessing)
    {
        m_bProcessingSnapinChanges = bProcessing;
    }

    BOOL ProcessingSnapinChanges()
    {
        return m_bProcessingSnapinChanges;
    }

private:
    CSnapInsCache* m_pSnapInsCache;
    BOOL m_bProcessingSnapinChanges;

}; // CNodeMgrApp


EXTERN_C CNodeMgrApp theApp;

#endif // MMC_NODEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\nodemgr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       nodemgr.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#ifdef BUILD_FOR_1381
#if defined(_UNICODE)
    inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNextW(lp);}
#elif defined(OLE2ANSI)
    inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNext(lp);}
#else
    //CharNextW doesn't work on Win95 so we use this
    inline LPOLESTR CharNextO(LPCOLESTR lp) {return (LPOLESTR)(lp+1);}
#endif
#endif

#include "atlimpl.cpp"
#include "atlwin.cpp"
#include "atlctl.cpp"

#include "initguid.h"
#include "doccnfg.h"
#include "NodeMgr.h"
#include "msgview.h"
#include "fldrsnap.h"
#include "tasksymbol.h"
#include "power.h"
#include "viewext.h"
#include "IconControl.h"
#include "mmcprotocol.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IID_DEFINED

/*
 * define our own Win64 symbol to make it easy to include 64-bit only
 * code in the 32-bit build, so we can exercise some code on 32-bit Windows
 * where the debuggers are better
 */
#ifdef _WIN64
#define MMC_WIN64
#endif


DECLARE_INFOLEVEL(AMCNodeMgr)

CComModule _Module;



//############################################################################
//############################################################################
//
//  The nodemgr proxy exports to support  IMMCClipboardDataObject interface marshalling.
//
//############################################################################
//############################################################################
extern "C" BOOL WINAPI NDMGRProxyDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);
STDAPI NDMGRProxyDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI NDMGRProxyDllCanUnloadNow(void);
STDAPI NDMGRProxyDllRegisterServer(void);
STDAPI NDMGRProxyDllUnregisterServer(void);

//############################################################################
//############################################################################
//
//  Implementation of class CMMCVersionInfo
//
//############################################################################
//############################################################################

class CMMCVersionInfo:
    public IMMCVersionInfo,
    public CComObjectRoot,
    public CComCoClass<CMMCVersionInfo, &CLSID_MMCVersionInfo>
{
    typedef CMMCVersionInfo ThisClass;
public:
    BEGIN_COM_MAP(ThisClass)
        COM_INTERFACE_ENTRY(IMMCVersionInfo)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass)

    DECLARE_MMC_OBJECT_REGISTRATION (
		g_szMmcndmgrDll,					// implementing DLL
        CLSID_MMCVersionInfo,           	// CLSID
        _T("MMCVersionInfo 1.0 Object"),    // class name
        _T("NODEMGR.MMCVersionInfo.1"),     // ProgID
        _T("NODEMGR.MMCVersionInfo"))       // version-independent ProgID

    STDMETHOD(GetMMCVersion)(long *pVersionMajor, long *pVersionMinor)
    {
        DECLARE_SC(sc, TEXT("CMMCVersionInfo::GetMMCVersion"));

        sc = ScCheckPointers(pVersionMajor, pVersionMinor);
        if(sc)
            return sc.ToHr();

        *pVersionMajor = MMC_VERSION_MAJOR;
        *pVersionMinor = MMC_VERSION_MINOR;

        return sc.ToHr();
    }
};
/****************************************************************************/
// forward declarations
class CMMCEventConnector;

/***************************************************************************\
 *
 * CLASS:  CEventForwarder
 *
 * PURPOSE: Helper class. It is used to plug into AppEvents as an event sink
 *          to forward received events to CMMCEventConnector class.
 *          It implements IDispatch interface by:
 *              - Having own implementation of QueryInterface
 *              - Forwarding AddRef and Release to CMMCEventConnector's
 *                WeakAddRef and WeakRelease
 *              - Forwarding Invoke to CMMCEventConnector's ScInvokeOnSinks
 *              - using CMMCEventConnector to imlement the rest of IDispatch
 * USAGE:   Used as member object in CMMCEventConnector;
 *
\***************************************************************************/
class CEventForwarder : public IDispatch
{
public:
    CEventForwarder(CMMCEventConnector& connector) : m_Connector(connector)
    {
        static CMMCTypeInfoHolderWrapper wrapper(GetInfoHolder());
    }

    // IUnknown implementation
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

    // IDispatch implementation
    STDMETHOD(GetTypeInfoCount)( unsigned int FAR*  pctinfo );
    STDMETHOD(GetTypeInfo)( unsigned int  iTInfo, LCID  lcid, ITypeInfo FAR* FAR*  ppTInfo );
    STDMETHOD(GetIDsOfNames)( REFIID  riid, OLECHAR FAR* FAR*  rgszNames, unsigned int  cNames,
                              LCID   lcid, DISPID FAR*  rgDispId );
    STDMETHOD(Invoke)( DISPID  dispIdMember, REFIID  riid, LCID  lcid, WORD  wFlags,
                       DISPPARAMS FAR*  pDispParams, VARIANT FAR*  pVarResult,
                       EXCEPINFO FAR*  pExcepInfo, unsigned int FAR*  puArgErr );
private:
    CMMCEventConnector& m_Connector;
    static CComTypeInfoHolder m_TypeInfo;
public:
    // the porpose of this static function is to ensure m_TypeInfo is a static variable,
    // since static wrapper will hold on its address - it must be always valid
    static CComTypeInfoHolder& GetInfoHolder() { return m_TypeInfo; }
};

/***************************************************************************\
 *
 * CLASS:  CMMCEventConnector
 *
 * PURPOSE: Implementation of coclass AppEventsDHTMLConnector
 *          Objects of this class are used as event source for application events,
 *          in cases when it's easyier to have cocreatible object to connect to
 *          these events and MMC application is already created (DHTML scripts)
 *          Class does not generate event's itself, it plugs into Allpication
 *          as an event sink for AppEvents dispinterface and keeps forwarding the events
 *
\***************************************************************************/
class CMMCEventConnector :
    public CMMCIDispatchImpl<_EventConnector, &CLSID_AppEventsDHTMLConnector>,
    public CComCoClass<CMMCEventConnector, &CLSID_AppEventsDHTMLConnector>,
    // support for connection points (script events)
    public IConnectionPointContainerImpl<CMMCEventConnector>,
    public IConnectionPointImpl<CMMCEventConnector, &DIID_AppEvents, CComDynamicUnkArray>,
    public INodeManagerProvideClassInfoImpl<&CLSID_AppEventsDHTMLConnector, &DIID_AppEvents, &LIBID_MMC20>,
    public IObjectSafetyImpl<CMMCEventConnector, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
    {
public:
    BEGIN_MMC_COM_MAP(CMMCEventConnector)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IObjectSafety)
    END_MMC_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CMMCEventConnector)

    DECLARE_MMC_OBJECT_REGISTRATION (
		g_szMmcndmgrDll,						// implementing DLL
        CLSID_AppEventsDHTMLConnector,   		// CLSID
        _T("AppEventsDHTMLConnector 1.0 Object"),	// class name
        _T("NODEMGR.AppEventsDHTMLConnector.1"),	// ProgID
        _T("NODEMGR.AppEventsDHTMLConnector"))		// version-independent ProgID

    BEGIN_CONNECTION_POINT_MAP(CMMCEventConnector)
        CONNECTION_POINT_ENTRY(DIID_AppEvents)
    END_CONNECTION_POINT_MAP()

private:

public:
    CMMCEventConnector();
    ~CMMCEventConnector();

    ULONG InternalRelease(); // overriding the one from CComObjectRoot
    ULONG WeakAddRef();
    ULONG WeakRelease();

    STDMETHOD(ConnectTo)(PAPPLICATION Application);
    STDMETHOD(Disconnect)();

    // invokes same event w/ same params on all connected sinks
    ::SC ScInvokeOnSinks(   DISPID  dispIdMember, REFIID  riid, LCID  lcid, WORD  wFlags,
                            DISPPARAMS FAR*  pDispParams, VARIANT FAR*  pVarResult,
                            EXCEPINFO FAR*  pExcepInfo, unsigned int FAR*  puArgErr );

private:
    CEventForwarder         m_Forwarder;
    DWORD                   m_dwWeakRefs;
    DWORD                   m_dwCookie;
    IConnectionPointPtr     m_spConnectionPoint;
};

//############################################################################
//############################################################################
//
//  COM Object map
//
//############################################################################
//############################################################################

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MMCVersionInfo,  CMMCVersionInfo)
    OBJECT_ENTRY(CLSID_TaskSymbol,      CTaskSymbol)
    OBJECT_ENTRY(CLSID_NodeInit,        CNodeInitObject)
    OBJECT_ENTRY(CLSID_ScopeTree,       CScopeTree)
    OBJECT_ENTRY(CLSID_MMCDocConfig,    CMMCDocConfig)
    OBJECT_ENTRY(CLSID_MessageView,     CMessageView)
    OBJECT_ENTRY(CLSID_FolderSnapin,    CFolderSnapin)
    OBJECT_ENTRY(CLSID_HTMLSnapin,      CHTMLSnapin)
    OBJECT_ENTRY(CLSID_OCXSnapin,       COCXSnapin)
    OBJECT_ENTRY(CLSID_ConsolePower,    CConsolePower)
    OBJECT_ENTRY(CLSID_AppEventsDHTMLConnector,  CMMCEventConnector)
    OBJECT_ENTRY(CLSID_ViewExtSnapin,   CViewExtensionSnapin)
    OBJECT_ENTRY(CLSID_IconControl,     CIconControl)
    OBJECT_ENTRY(CLSID_ComCacheCleanup, CMMCComCacheCleanup)
    OBJECT_ENTRY(CLSID_MMCProtocol,     CMMCProtocol)
END_OBJECT_MAP()

CNodeMgrApp theApp;



void CNodeMgrApp::Init()
{
    DECLARE_SC(sc, TEXT("CNodeMgrApp::Init"));

    /* register the mmc:// protocol */
    /* the protocol is required for taskpads and pagebreaks */
    sc = CMMCProtocol::ScRegisterProtocol();
    if(sc)
        sc.TraceAndClear();
}

void CNodeMgrApp::DeInit()
{
    SetSnapInsCache(NULL);
}

/***************************************************************************\
 *
 * METHOD:  CNodeMgrApp::ScOnReleaseCachedOleObjects
 *
 * PURPOSE: Called prior to ole de-initialization to release any cached ole objects
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodeMgrApp::ScOnReleaseCachedOleObjects()
{
    DECLARE_SC(sc, TEXT("CNodeMgrApp::ScOnReleaseCachedOleObjects"));

    // release snapin cache - thats all the class have cached...
    SetSnapInsCache(NULL);

    return sc;
}

void CNodeMgrApp::SetSnapInsCache(CSnapInsCache* pSIC)
{
    if (m_pSnapInsCache != NULL)
        delete m_pSnapInsCache;

    m_pSnapInsCache = pSIC;
}



/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        // NATHAN FIX !!w
        //_set_new_handler( _standard_new_handler );
        _Module.Init(ObjectMap, hInstance);
        theApp.Init();
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        theApp.DeInit();
        _Module.Term();
    }

    NDMGRProxyDllMain(hInstance, dwReason, NULL);

    return TRUE;    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    if (_Module.GetLockCount()!=0)
        return S_FALSE;

    return NDMGRProxyDllCanUnloadNow();
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    if (IsEqualIID(IID_IMMCClipboardDataObject, rclsid))
        return NDMGRProxyDllGetClassObject(rclsid, riid, ppv);

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry


// Use own routine to register typelib because we don't want
// a full pathname, just a module name
static HRESULT RegisterTypeLib()
{
    USES_CONVERSION;

    TCHAR szModule[_MAX_PATH+10] = { 0 };

    GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);

    ITypeLib* pTypeLib;
    LPOLESTR lpszModule = T2OLE(szModule);
    HRESULT hr = LoadTypeLib(lpszModule, &pTypeLib);
    ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
    {
        hr = ::RegisterTypeLib(pTypeLib, const_cast<LPWSTR>(T2CW (g_szMmcndmgrDll)), NULL);
        ASSERT(SUCCEEDED(hr));
    }

    if (pTypeLib != NULL)
        pTypeLib->Release();

    return hr;
}

STDAPI DllRegisterServer(void)
{
	DECLARE_SC (sc, _T("DllRegisterServer"));

    // registers objects
    sc =  _Module.RegisterServer(FALSE);
	if (sc)
	{
		sc.Trace_();
		return ((sc = SELFREG_E_CLASS).ToHr());
	}

	CRegKeyEx regkeySoftware;
	CRegKeyEx regkeyMMC;
	CRegKeyEx regkeySnapIns;
	CRegKeyEx regkeyNodeTypes;

	if ((sc = regkeySoftware. ScOpen   (HKEY_LOCAL_MACHINE, _T("Software\\Microsoft"))).IsError() ||
		(sc = regkeyMMC.      ScCreate (regkeySoftware,		_T("MMC"))).			    IsError() ||
		(sc = regkeySnapIns.  ScCreate (regkeyMMC,			_T("SnapIns"))).		    IsError() ||
		(sc = regkeyNodeTypes.ScCreate (regkeyMMC,			_T("NodeTypes"))).          IsError())
	{
		sc.Trace_();
		return ((sc = SELFREG_E_CLASS).ToHr());
	}

    sc = ::RegisterTypeLib();
	if (sc)
	{
		sc.Trace_();
		return ((sc = SELFREG_E_TYPELIB).ToHr());
	}

    sc = NDMGRProxyDllRegisterServer();
    if (sc)
        return sc.ToHr();

    /*
     * register mmc.exe to complete the process
     * note: mmc.exe is never unregistered
     */


	// fix to windows bug #233372. ntbug09, 11/28/00
	// [ mmc.exe launched from current directory, not from where it is supposed to be]

	// get the path of node manager dll
	TCHAR szPath[_MAX_PATH];
	DWORD dwPathLen = ::GetModuleFileName(_Module.GetModuleInstance(), szPath, countof(szPath) );
	szPath[countof(szPath) -1] = 0;

	// if node manager path is found - put same directory to mmc path
	tstring strMMCPath;
	if ( dwPathLen > 0 )
	{
		tstring strNodeMgr = szPath;
		int iLastSlashPos = strNodeMgr.rfind('\\');
		if (iLastSlashPos != tstring::npos)
			strMMCPath = strNodeMgr.substr(0, iLastSlashPos + 1);
	}
	else
	{
		sc = E_UNEXPECTED;
		sc.TraceAndClear(); // ignore and continue without a path
	}

	strMMCPath += _T("mmc.exe");

#if defined(MMC_WIN64)
	LPCTSTR szRegParams = _T("-64 -RegServer");
#else
	LPCTSTR szRegParams = _T("-32 -RegServer");
#endif

    HINSTANCE hInst = ShellExecute (NULL, NULL, strMMCPath.c_str(), szRegParams,
                                    NULL, SW_SHOWNORMAL);
    if ((DWORD_PTR) hInst <= 32)
    {
        switch ((DWORD_PTR) hInst)
        {
            case 0:
                sc = E_OUTOFMEMORY;
                break;

            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
            case ERROR_BAD_FORMAT:
                sc.FromWin32 ((DWORD_PTR) hInst);
                break;

            default:
                sc = E_FAIL;
                break;
        }

        return (sc.ToHr());
    }

	return (sc.ToHr());
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hRes = S_OK;
    _Module.UnregisterServer();

    NDMGRProxyDllUnregisterServer();

    return hRes;
}

/***************************************************************************\
 *
 * STATIC OBJECT:  CEventForwarder::m_TypeInfo
 *
 * PURPOSE: manages ITypeInfo used by CEventForwarder
 *
\***************************************************************************/
CComTypeInfoHolder CEventForwarder::m_TypeInfo =
{ &DIID_AppEvents, &LIBID_MMC20, 1, 0, NULL, 0, NULL, 0 };

/***************************************************************************\
 *
 * METHOD:  CEventForwarder::AddRef
 *
 * PURPOSE: Implements IUnknown::AddRef
 *          This class is always contained within m_Connector, so it
 *          relies on outer object to count the references.
 *          To differentiate between regular references and those occuring
 *          beacuse of connecting to the sink, it calls WeakAddRef,
 *          not the regular AddRef on connector
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    ULONG    - reference count
 *
\***************************************************************************/
STDMETHODIMP_(ULONG) CEventForwarder::AddRef()
{
    return m_Connector.WeakAddRef();
}

/***************************************************************************\
 *
 * METHOD:  CEventForwarder::Release
 *
 * PURPOSE: Implements IUnknown::Release
 *          This class is always contained within m_Connector, so it
 *          relies on outer object to count the references.
 *          To differentiate between regular references and those occuring
 *          beacuse of connecting to the sink, it calls WeakRelease,
 *          not the regular Release on connector
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    ULONG    - reference count
 *
\***************************************************************************/
STDMETHODIMP_(ULONG) CEventForwarder::Release()
{
    return m_Connector.WeakRelease();
}


/***************************************************************************\
 *
 * METHOD:  CEventForwarder::QueryInterface
 *
 * PURPOSE: Implements IUnknown::QueryInterface
 *          returns self, when requested for IUnknow, IDispatch, AppEvents
 *
 * PARAMETERS:
 *    REFIID iid
 *    void ** ppvObject
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CEventForwarder::QueryInterface(REFIID iid, void ** ppvObject)
{
    DECLARE_SC(sc, TEXT(""));

    // parameter check
    sc = ScCheckPointers(ppvObject);
    if (sc)
        return sc.ToHr();

    // initialization
    *ppvObject = NULL;

    // check IID
    if (IsEqualGUID(iid, IID_IUnknown)
     || IsEqualGUID(iid, IID_IDispatch)
     || IsEqualGUID(iid, DIID_AppEvents))
    {
        *ppvObject = this;
        AddRef();
        return sc.ToHr();
    }

    // not an error - do not assign to sc
    return E_NOINTERFACE;
}

/***************************************************************************\
 *
 * METHOD:  CEventForwarder::GetTypeInfoCount
 *
 * PURPOSE: implements method on IDispatch
 *
 * PARAMETERS:
 *    unsigned int FAR*  pctinfo
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CEventForwarder::GetTypeInfoCount( unsigned int FAR*  pctinfo )
{
    if (pctinfo == NULL) return E_INVALIDARG;
    *pctinfo = 1;
    return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  CEventForwarder::GetTypeInfo
 *
 * PURPOSE: implements method on IDispatch
 *
 * PARAMETERS:
 *    unsigned int  iTInfo
 *    LCID  lcid
 *    ITypeInfo FAR* FAR*  ppTInfo
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CEventForwarder::GetTypeInfo( unsigned int  iTInfo, LCID  lcid, ITypeInfo FAR* FAR*  ppTInfo )
{
    return m_TypeInfo.GetTypeInfo( iTInfo, lcid, ppTInfo );
}


/***************************************************************************\
 *
 * METHOD:  CEventForwarder::GetIDsOfNames
 *
 * PURPOSE:implements method on IDispatch
 *
 * PARAMETERS:
 *    riid
 *    rgszNames
 *    cNames
 *    lcid
 *    rgDispId
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CEventForwarder::GetIDsOfNames( REFIID  riid, OLECHAR FAR* FAR*  rgszNames, unsigned int  cNames,
                                             LCID   lcid, DISPID FAR*  rgDispId )
{
    return m_TypeInfo.GetIDsOfNames( riid, rgszNames, cNames, lcid, rgDispId );
}


/***************************************************************************\
 *
 * METHOD:  CEventForwarder::Invoke
 *
 * PURPOSE: implements method on IDispatch. Forwards calls to connector.
 *          In order to distinguish between calls made on itself, connector
 *          must provide method, which has different name : ScInvokeOnSinks
 *
 * PARAMETERS:
 *    DISPID  dispIdMember
 *    REFIID  riid
 *    LCID  lcid
 *    WORD  wFlags
 *    DISPPARAMS FAR*  pDispParams
 *    VARIANT FAR*  pVarResult
 *    EXCEPINFO FAR*  pExcepInfo
 *    unsigned int FAR*  puArgErr
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CEventForwarder::Invoke( DISPID  dispIdMember, REFIID  riid, LCID  lcid, WORD  wFlags,
                                      DISPPARAMS FAR*  pDispParams, VARIANT FAR*  pVarResult,
                                      EXCEPINFO FAR*  pExcepInfo, unsigned int FAR*  puArgErr )
{
    DECLARE_SC(sc, TEXT("CEventForwarder::Invoke"));

    sc = m_Connector.ScInvokeOnSinks( dispIdMember, riid, lcid, wFlags, pDispParams,
                                      pVarResult, pExcepInfo, puArgErr );
    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::CMMCEventConnector
 *
 * PURPOSE: constructor
 *
\***************************************************************************/
CMMCEventConnector::CMMCEventConnector() :
m_Forwarder(*this),
m_dwCookie(0),
m_dwWeakRefs(0)
{
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::~CMMCEventConnector
 *
 * PURPOSE: Destructor
 *
\***************************************************************************/
CMMCEventConnector::~CMMCEventConnector()
{
    Disconnect(); // most likely not needed. Just for sanity
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::InternalRelease
 *
 * PURPOSE: Overrides method from CComObjectRoot to detect when last "real"
 *          reference is released. Refs made because of connecting to the
 *          sink does not count - we would have a deadlock else
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    ULONG   - ref count
 *
\***************************************************************************/
ULONG CMMCEventConnector::InternalRelease()
{
    ULONG uRefsLeft = CComObjectRoot::InternalRelease();

    if ((uRefsLeft != 0) && (uRefsLeft == m_dwWeakRefs))
    {
        // seems like we are alive just because we still connected to the connection point
        // disconnect ( no-one uses it anyway )
        InternalAddRef(); // Addref to have balance
        Disconnect();     // disconnect from the connection point
        uRefsLeft = CComObjectRoot::InternalRelease(); // release again
    }

    return uRefsLeft;
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::WeakAddRef
 *
 * PURPOSE: counts reference from connection points. AddRefs regularly as well
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    ULONG   - ref count
 *
\***************************************************************************/
ULONG CMMCEventConnector::WeakAddRef()
{
    ++m_dwWeakRefs;
    return AddRef();
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::WeakRelease
 *
 * PURPOSE: counts reference from connection points. Releases regularly as well
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    ULONG   - ref count
 *
\***************************************************************************/
ULONG CMMCEventConnector::WeakRelease()
{
    --m_dwWeakRefs;
    return Release();
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::ScInvokeOnSinks
 *
 * PURPOSE: This method has a signature of IDispath::Invoke and is
 *          called from connection point to inform about the event
 *          Method's job is to fork the call to each own connected sink
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCEventConnector::ScInvokeOnSinks( DISPID  dispIdMember, REFIID  riid, LCID  lcid, WORD  wFlags,
                                        DISPPARAMS FAR*  pDispParams, VARIANT FAR*  pVarResult,
                                        EXCEPINFO FAR*  pExcepInfo, unsigned int FAR*  puArgErr )
{
    DECLARE_SC(sc, TEXT("CMMCEventConnector::ScInvokeOnSinks"));

    // find connection point
    IConnectionPointPtr spConnectionPoint;
    sc = FindConnectionPoint(DIID_AppEvents, &spConnectionPoint);
    if (sc)
        return sc;

    // get connections
    IEnumConnectionsPtr spEnumConnections;
    sc = spConnectionPoint->EnumConnections(&spEnumConnections);
    if (sc)
        return sc.ToHr();

    // recheck the pointer
    sc = ScCheckPointers(spEnumConnections, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // reset iterator
    sc = spEnumConnections->Reset();
    if (sc)
        return sc.ToHr();

    // iterate thru sinks until Next returns S_FALSE.
    CONNECTDATA connectdata;
    SC sc_last_error;
    while (1) // will use <break> to exit
    {
        // get the next sink
        ZeroMemory(&connectdata, sizeof(connectdata));
        sc = spEnumConnections->Next( 1, &connectdata, NULL );
        if (sc)
            return sc.ToHr();

        // done if no more sinks
        if (sc == SC(S_FALSE))
            break;

        // recheck the pointer
        sc = ScCheckPointers(connectdata.pUnk, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        // QI for IDispatch
        IDispatchPtr spDispatch = (IDispatch *)connectdata.pUnk;
        connectdata.pUnk->Release();

        // recheck the pointer
        sc = ScCheckPointers(spDispatch, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        // invoke on the sink
        sc = spDispatch->Invoke( dispIdMember, riid, lcid, wFlags, pDispParams,
                            pVarResult, pExcepInfo, puArgErr );
        if (sc)
        {
            sc_last_error = sc; // continue even if some calls failed
            sc.TraceAndClear();
        }
    }

    return sc_last_error.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::ConnectTo
 *
 * PURPOSE: Connects to Application object and starts forwarding its events
 *
 * PARAMETERS:
 *    PAPPLICATION Application
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCEventConnector::ConnectTo(PAPPLICATION Application)
{
    DECLARE_SC(sc, TEXT("ConnectTo"));

    // disconnect from former connections
    sc = Disconnect();
    if (sc)
        return sc.ToHr();

    // check if com object supports IConnectionPointContainer;
    IConnectionPointContainerPtr spContainer = Application;
    sc = ScCheckPointers(spContainer);
    if (sc)
        return sc.ToHr();

    // get connection point
    sc = spContainer->FindConnectionPoint(DIID_AppEvents, &m_spConnectionPoint);
    if (sc)
        return sc.ToHr();

    sc = m_spConnectionPoint->Advise(&m_Forwarder, &m_dwCookie);
    if (sc)
        return sc.ToHr();

    return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::Disconnect
 *
 * PURPOSE: Disconnects from connection point if is connected to one
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCEventConnector::Disconnect()
{
    DECLARE_SC(sc, TEXT("CMMCEventConnector::Disconnect"));

    if (m_dwCookie)
    {
        if (m_spConnectionPoint != NULL)
        {
            sc = m_spConnectionPoint->Unadvise(m_dwCookie);
            if (sc)
                sc.TraceAndClear();
        }
        m_dwCookie = 0;
        m_spConnectionPoint = NULL;
    }

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\nodemgrdebug.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       nodemgrdebug.h
//
//  Contents:   Debugging helpers for MMC & Snapins.
//
//  History:    10-May-2000 AnandhaG     Created
//
//--------------------------------------------------------------------
#pragma once

/*+-------------------------------------------------------------------------*
 *
 * TraceSnapinException
 *
 * PURPOSE:     When a snapin throws an exception and is caught by MMC this
 *              function traces that exception.
 *
 * PARAMETERS:
 *    CLSID& clsidSnapin     - Class id of the offending snapin, used to get name.
 *    LPCTSTR szFunctionName - the method in snapin called by mmc.
 *    int event              - MMC_NOTIFY_EVENT
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
inline void TraceSnapinException(const CLSID& clsidSnapin, LPCTSTR szFunctionName, int event)
{
#ifdef DBG
    SC sc = E_FAIL;
    sc.SetFunctionName(szFunctionName);

    tstring strSnapinName = TEXT("Unknown");
    GetSnapinNameFromCLSID(clsidSnapin, strSnapinName);

    sc.SetSnapinName(strSnapinName.data());

	WTL::CString strErrorMessage;
    strErrorMessage.Format(TEXT("threw an exception during the notify event : 0x%x\n"), event);

    TraceSnapinError(strErrorMessage, sc);
	sc.Clear();   // dont want sc to trace again.
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\nodepath.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      nodepath.h
 *
 *  Contents:  Dynamic node path generation helpers
 *
 *  History:   31-Mar-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef NODEPATH_H
#define NODEPATH_H

// Forward declarations
class CMTNode;
class CBookmark;
class CDynamicPathEntryEx;

/*+-------------------------------------------------------------------------*
 *class CBookmarkEx
 *
 *PURPOSE: Provides added functionality to the CBookmark class with methods
 *         for locating CMTNodes and CNodes.
 *
 *
 *+-------------------------------------------------------------------------*/

class CBookmarkEx : public CBookmark
{
    typedef CBookmark BC;

public:
    enum { ID_ConsoleRoot = -10 };

                            // Constructor / destructor
                            CBookmarkEx(MTNODEID idStatic = ID_Unknown);
                            CBookmarkEx(bool bIsFastBookmark);
                            CBookmarkEx(const CBookmark &rhs)   {*this = rhs;}
                            CBookmarkEx(const CBookmarkEx &rhs) {*this = rhs;}
                            ~CBookmarkEx();

    // casts
    CBookmarkEx &           operator = (const CBookmark   &rhs) {BC::operator = (rhs); return *this;}
    CBookmarkEx &           operator = (const CBookmarkEx &rhs) {BC::operator = (rhs); return *this;}

    SC                      ScGetMTNode(bool bExactMatchRequired, CMTNode **ppMTNode, bool& bExactMatchFound);
    std::auto_ptr<CNode>    GetNode(CViewData *pViewData);
    SC                      ScRetarget(CMTNode *pMTNode, bool bFastRetrievalOnly);
    void                    ResetUI();

    // from the old CNodePath class
public:
    SC                      ScInitialize(CMTNode* pMTNode, CMTNode* pMTViewRootNode, bool bFastRetrievalOnly);
protected:
    BOOL                    IsNodeIDOK(CDynamicPathEntryEx &nodeid);

    // find a node directly under the parent node whose node ID matches the specified CDynamicPathEntryEx.
    SC                      ScFindMatchingMTNode(CMTNode *pMTNodeParent, CDynamicPathEntryEx &entry,
                                                 CMTNode **ppMatchingMTNode);
};

#endif  /* NODEPATH_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\objfmts.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       objfmts.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "objfmts.h"



//____________________________________________________________________________
//
//  Members:     IEnumFORMATETC methods
//____________________________________________________________________________

STDMETHODIMP
CObjFormats::Next(
    ULONG celt,
    FORMATETC *rgelt,
    ULONG *pceltFethed)
{
    UINT    cfetch = 0;
    HRESULT hr = S_FALSE; // assume less numbers

    if (m_iFmt < m_cFmt)
    {
        cfetch = m_cFmt - m_iFmt;

        if (cfetch >= celt)
        {
            cfetch = celt;
            hr = S_OK;
        }

        CopyMemory(rgelt, &m_aFmt[m_iFmt], cfetch * sizeof(FORMATETC));
        m_iFmt += cfetch;
    }

    if (pceltFethed)
    {
        *pceltFethed = cfetch;
    }

    return hr;
}


STDMETHODIMP
CObjFormats::Skip(
    ULONG celt)
{
    m_iFmt += celt;

    if (m_iFmt > m_cFmt)
    {
        m_iFmt = m_cFmt;
        return S_FALSE;
    }

    return S_OK;
}

STDMETHODIMP
CObjFormats::Reset()
{
    m_iFmt = 0;
    return S_OK;
}

STDMETHODIMP
CObjFormats::Clone(
    IEnumFORMATETC ** ppenum)
{
    return E_NOTIMPL;
}

//____________________________________________________________________________
//
//  Function:     Function to obtain the IEnumFORMATETC interface.
//____________________________________________________________________________

HRESULT
GetObjFormats(
    UINT        cfmt,
    FORMATETC * afmt,
    LPVOID    * ppvObj)
{
    ASSERT(ppvObj != NULL);
    ASSERT(afmt != NULL);

    FORMATETC * pFmt = new FORMATETC[cfmt];

    if (pFmt == NULL)
        return E_OUTOFMEMORY;

    CopyMemory(pFmt, afmt, cfmt * sizeof(FORMATETC));

    CComObject<CObjFormats>* pObjFormats;
    CComObject<CObjFormats>::CreateInstance(&pObjFormats);

    if (pObjFormats == NULL)
    {
        delete [] pFmt;
        return E_OUTOFMEMORY;
    }
    
    pObjFormats->Init(cfmt, pFmt);

    return pObjFormats->QueryInterface(IID_IEnumFORMATETC, 
                                       reinterpret_cast<void**>(ppvObj));
}



//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////



//____________________________________________________________________________
//
//  Members:     CObjFormatsEx::IEnumFORMATETC methods
//____________________________________________________________________________

STDMETHODIMP
CObjFormatsEx::Next(
    ULONG celt,
    FORMATETC *rgelt,
    ULONG *pceltFethed)
{
    if (m_iCur == 1)
        return m_rgspEnums[1]->Next(celt, rgelt, pceltFethed);

    ULONG celtFethed1 = 0;
    HRESULT hr = m_rgspEnums[0]->Next(celt, rgelt, &celtFethed1);
    if (hr == S_OK)
        return S_OK;

    ULONG celt2 = celt - celtFethed1;
    ULONG celtFethed2 = 0;
    
    m_iCur = 1;
    hr = m_rgspEnums[1]->Next(celt2, &rgelt[celtFethed1], &celtFethed2);
    if (pceltFethed)
        *pceltFethed = celtFethed1 + celtFethed2;
    return hr;
}


STDMETHODIMP
CObjFormatsEx::Skip(
    ULONG celt)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CObjFormatsEx::Reset()
{
    m_iCur = 0;
    m_rgspEnums[0]->Reset();
    m_rgspEnums[1]->Reset();
    return S_OK;
}

STDMETHODIMP
CObjFormatsEx::Clone(
    IEnumFORMATETC ** ppenum)
{
    return E_NOTIMPL;
}



HRESULT 
GetObjFormatsEx(
    IEnumFORMATETC* pEnum1, 
    IEnumFORMATETC* pEnum2,
    IEnumFORMATETC** ppEnumOut)
{
    ASSERT(pEnum1 != NULL);
    ASSERT(pEnum2 != NULL);
    ASSERT(ppEnumOut != NULL);
    if (!pEnum1 || !pEnum2 || !ppEnumOut)
        return E_INVALIDARG;


    CComObject<CObjFormatsEx>* pObj;
    CComObject<CObjFormatsEx>::CreateInstance(&pObj);

    if (pObj == NULL)
        return E_OUTOFMEMORY;
    
    pObj->Init(pEnum1, pEnum2);

    return pObj->QueryInterface(IID_IEnumFORMATETC, 
                                reinterpret_cast<void**>(ppEnumOut));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\nodepath.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      nodepath.h
 *
 *  Contents:  Dynamic node path generation helpers
 *
 *  History:   31-Mar-98 JeffRo     Created
 *
 *
 * The persisted format of a node path (aka bookmark) is as follows:
 *
 * DWORD    idStatic;           // the MTNODEID of the static root of the node
 * DWORD    cDynamicBytes;      // count of bytes in the dynamic portion of the
 *                              // bookmark
 * BYTE     rgDynamicBytes[];   // array of bytes representing the dynamic
 *                              // portion of the bookmark
 *
 *
 * For MMC v1.0 consoles, rgDynamicBytes is a double-NULL terminated list
 * of Unicode strings representing the names of the dynamic nodes.  For a
 * tree that looks like this:
 *
 *      Static Node (id == 3)
 *          Dynamic Node1
 *              Dynamic Node2
 *
 * the full bookmark for Dynamic Node 2 would be:
 *
 * 00000000  03 00 00 00 00 00 00 00 44 00 79 00 6E 00 61 00  ........D.y.n.a.
 * 00000010  6D 00 69 00 63 00 20 00 4E 00 6F 00 64 00 65 00  m.i.c. .N.o.d.e.
 * 00000020  31 00 00 00 44 00 79 00 6E 00 61 00 6D 00 69 00  1...D.y.n.a.m.i.
 * 00000030  63 00 20 00 4E 00 6F 00 64 00 65 00 32 00 00 00  c. .N.o.d.e.2...
 * 00000040  00 00                                            ..
 *
 *
 * For MMC v1.1 and higher consoles, rgDynamic looks like this:
 *
 * BYTE     rgSignature[16];    // "MMCCustomStream"
 * DWORD    dwStreamVersion;    // version number, currently 0x0100
 *
 * followed by 1 or more dynamic node IDs, each of which looks like:
 *
 * BYTE     byNodeIDType;       // NDTYP_STRING (0x01) means the snap-in
 *                              // did not support CCF_NODEID(2) and the
 *                              // ID is the NULL-terminated Unicode name
 *                              // of the node
 *                              // NDTYP_CUSTOM (0x02) means the snap-in
 *                              // supported CCF_NODEID(2) and what follows
 *                              // is the SNodeID structure
 *
 * BYTE     rgNodeIDBytes[];    // bytes for the dynamic node ID
 *
 *
 * For a tree that looks like this:
 *
 *      Static Node (id == 3)
 *          Dynamic Node1 (doesn't support CCF_NODEID(2))
 *              Dynamic Node2 (suports CCF_NODEID, returns DWORD 0x12345678)
 *
 * the full bookmark for Dynamic Node 2 would be:
 *
 * 00000000  03 00 00 00 3A 00 00 00 4D 4D 43 43 75 73 74 6F  ....:...MMCCusto
 * 00000010  6D 53 74 72 65 61 6D 00 00 00 01 00 01 44 00 79  mStream......D.y
 * 00000020  00 6E 00 61 00 6D 00 69 00 63 00 20 00 4E 00 6F  .n.a.m.i.c. .N.o
 * 00000030  00 64 00 65 00 31 00 00 00 02 04 00 00 00 78 56  .d.e.1........xV
 * 00000040  34 12                                            4.
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "nodepath.h"
#include <comdef.h>
#include "nmtempl.h"
#include "conview.h"

using namespace std;

/*+-------------------------------------------------------------------------*
 * class CDynamicPathEntryEx
 *
 *
 * PURPOSE: Adds functionality (but NO MEMBER VARIABLES) to the
 *          CDynamicPathEntry class, to initialize from an MTNode.
 *
 *+-------------------------------------------------------------------------*/
class CDynamicPathEntryEx : public CDynamicPathEntry
{
    typedef CDynamicPathEntry BC;
public:
    // initialize from a node.
    SC      ScInitialize(CMTNode *pMTNode, bool bFastRetrievalOnly);

    // assignment
    CDynamicPathEntryEx & operator = (const CDynamicPathEntryEx &rhs)
    {
        BC::operator =(rhs);
        return *this;
    }

    CDynamicPathEntryEx & operator = (const CDynamicPathEntry &rhs)
    {
        BC::operator =(rhs);
        return *this;
    }

private:
    CLIPFORMAT GetCustomNodeIDCF ();
    CLIPFORMAT GetCustomNodeID2CF();
};


/*+-------------------------------------------------------------------------*
 *
 * CDynamicPathEntryEx::ScInitialize
 *
 * PURPOSE: Initializes the CDynamicPathEntryEx structure from the given MTNode.
 *
 *          This handles all the backward compatibility cases. Refer to the
 *          SDK docs to see how CCF_NODEID and CCF_NODEID2 are handled.
 *
 * PARAMETERS:
 *    CMTNode* pMTNode :
 *    DWORD    dwFlags :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CDynamicPathEntryEx::ScInitialize(CMTNode* pMTNode, bool bFastRetrievalOnly)
{
    DECLARE_SC(sc, TEXT("CDynamicPathEntryEx::ScInitialize"));
    USES_CONVERSION;

    // get the data object for the node
    IDataObjectPtr  spDataObject;
    sc = pMTNode->QueryDataObject (CCT_SCOPE, &spDataObject);
    m_type = 0; // initialize

	// Got data object then try to get NodeID2 or NodeID
    if(!sc.IsError())
	{
		// extract the CCF_NODEID2 format from the data object
		HGLOBAL hGlobal = NULL;
		sc = DataObject_GetHGLOBALData (spDataObject, GetCustomNodeID2CF(), &hGlobal);
		if(!sc.IsError()) // succeeded
		{
			// build the DynamicNodeID from the custom node ID struct
			SNodeID2 *pNodeID2 =  reinterpret_cast<SNodeID2*>(GlobalLock (hGlobal));
			sc = ScCheckPointers(pNodeID2);
			if(sc)
				return sc;

			// if the client needs a fast path ONLY but the snapin can't provide one,
			// return E_INVALIDARG;
			// Bug 175684: this is a "valid" error return, so we don't want to trace it
			if ( ( (pNodeID2->dwFlags & MMC_NODEID_SLOW_RETRIEVAL) &&
					bFastRetrievalOnly)  ||
				 ( pNodeID2->cBytes <= 0) )
			{
				SC scNoTrace = E_INVALIDARG;
				return (scNoTrace);
			}

			m_byteVector.insert (m_byteVector.end(),
								 pNodeID2->id, pNodeID2->id + pNodeID2->cBytes);

			m_type |= NDTYP_CUSTOM;
		}
		else    // the CCF_NODEID2 format was not supported. Try CCF_NODEID.
		{
			sc = DataObject_GetHGLOBALData (spDataObject, GetCustomNodeIDCF(), &hGlobal);
			if(!sc)
			{
				// build the DynamicNodeID from the custom node ID struct
				m_type |= NDTYP_CUSTOM;
				SNodeID *pNodeID =  reinterpret_cast<SNodeID*>(GlobalLock (hGlobal));

				sc = ScCheckPointers(pNodeID);
				if(sc)
					return sc;

				// if pNodeID->cBytes is zero, this is a legacy indication that the
				// node does not support fast retrieval. But, if the client is OK
				// with slow retrieval, we supply the display name instead.

				if(pNodeID->cBytes != 0)
				{
					m_byteVector.insert (m_byteVector.end(),
										 pNodeID->id, pNodeID->id + pNodeID->cBytes);
				}
				else
				{
					// cBytes == 0 here. If the client indicated fast retrieval, must return an error.
					// Bug 175684: this is a "valid" error return, so we don't want to trace it
					if(bFastRetrievalOnly)
					{
						SC scNoTrace = E_INVALIDARG;
						return (scNoTrace);
					}
				}
			}
		};

		// let go of the data
		if (hGlobal)
		{
			GlobalUnlock (hGlobal);
			GlobalFree (hGlobal);
		}
	}

    // always save the display name as well.
    sc.Clear();
    m_type |= NDTYP_STRING;

    tstring strName = pMTNode->GetDisplayName();
    if (!strName.empty())
        m_strEntry = T2CW(strName.data());
    else
        return (sc = E_INVALIDARG);

    return sc;
}

/*--------------------------------------------------------------------------*
 * CDynamicPathEntryEx::GetCustomNodeIDCF
 *
 *
 *--------------------------------------------------------------------------*/

CLIPFORMAT CDynamicPathEntryEx::GetCustomNodeIDCF()
{
    static CLIPFORMAT cfCustomNodeID = 0;

    if (cfCustomNodeID == 0)
    {
        USES_CONVERSION;
        cfCustomNodeID = (CLIPFORMAT) RegisterClipboardFormat (W2T (CCF_NODEID));
        ASSERT (cfCustomNodeID != 0);
    }

    return (cfCustomNodeID);
}

/*--------------------------------------------------------------------------*
 * CDynamicPathEntryEx::GetCustomNodeID2CF
 *
 *
 *--------------------------------------------------------------------------*/

CLIPFORMAT CDynamicPathEntryEx::GetCustomNodeID2CF()
{
    static CLIPFORMAT cfCustomNodeID2 = 0;

    if (cfCustomNodeID2 == 0)
    {
        USES_CONVERSION;
        cfCustomNodeID2 = (CLIPFORMAT) RegisterClipboardFormat (W2T (CCF_NODEID2));
        ASSERT (cfCustomNodeID2 != 0);
    }

    return (cfCustomNodeID2);
}



//############################################################################
//############################################################################
//
//  Implementation of class CBookmarkEx
//
//############################################################################
//############################################################################

CBookmarkEx::CBookmarkEx(MTNODEID idStatic) : BC(idStatic)
{
}

CBookmarkEx::CBookmarkEx(bool bIsFastBookmark) : BC(bIsFastBookmark)
{
}


/*+-------------------------------------------------------------------------*
 * CBookmarkEx::~CBookmarkEx
 *
 * PURPOSE:     Destructor
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
/*+-------------------------------------------------------------------------*/
CBookmarkEx::~CBookmarkEx()
{
}


/*+-------------------------------------------------------------------------*
 *
 * CBookmarkEx::ScRetarget
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CMTNode * pMTNode :
 *    bool      bFastRetrievalOnly :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CBookmarkEx::ScRetarget(CMTNode *pMTNode, bool bFastRetrievalOnly)
{
    DECLARE_SC(sc, TEXT("CBookmarkEx::ScRetarget"));

    if(pMTNode)
    {
        sc = ScInitialize (pMTNode, NULL, bFastRetrievalOnly);
        if(sc)
            return sc;
    }
    else
        Reset();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CBookmarkEx::ResetUI
 *
 * PURPOSE: Reset's the state of the bookmark. Will put up the Retry/Cancel
 *          UI if the node is not available.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CBookmarkEx::ResetUI()
{
}

/* CBookmarkEx::GetNode
 *
 * PURPOSE:     Returns a CNode corresponding to the bookmark for a particular view.
 *              NOTE: This will return a new instance every time. To reuse the same
 *              instance, cache it.
 *
 * PARAMETERS:
 *      CViewData *  pViewData: The view for which a node is requested
 *
 * RETURNS:
 *      CNode * : NULL if the MTNode could not be found.
 */
std::auto_ptr<CNode>
CBookmarkEx::GetNode(CViewData *pViewData)
{
    DECLARE_SC(sc, TEXT("CBookmarkEx::GetNode"));

    CNode *             pNode       = NULL;
    CMTNode *           pMTNode     = NULL;

    // The NULL return value for failure conditions.
    std::auto_ptr<CNode> spNodeNull;

    // validate parameters
    if(NULL == pViewData)
    {
        sc = E_UNEXPECTED;
        return spNodeNull;
    }

    //  Get the target node.
    bool bExactMatchFound = false; // out value from ScGetMTNode, unused
    sc = ScGetMTNode(true, &pMTNode, bExactMatchFound);
    if( sc.IsError() || !pMTNode) // could not find the node - abort.
    {
        return spNodeNull;
    }

    // make sure the node is expanded (invisibly) in the tree
    CConsoleView* pConsoleView = pViewData->GetConsoleView();
    if (pConsoleView == NULL)
    {
        sc = E_UNEXPECTED;
        return spNodeNull;
    }

    sc = pConsoleView->ScExpandNode (pMTNode->GetID(), true, false);
    if(sc)
        return spNodeNull;

    pNode = pMTNode->GetNode(pViewData, false);
    if (pNode == NULL)
    {
        sc = E_OUTOFMEMORY;
        return spNodeNull;
    }

    if (FAILED (pNode->InitComponents()))
    {
        delete pNode;
        sc = E_UNEXPECTED;
        return spNodeNull;
    }

    return (std::auto_ptr<CNode>(pNode));
}



/*+-------------------------------------------------------------------------*
 *
 * CBookmarkEx::ScInitialize
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CMTNode* pMTNode :
 *    CMTNode* pMTViewRootNode :
 *    bool     bFastRetrievalOnly : true by default. If true, this
 *                                  function returns E_INVALIDARG for
 *                                  any node that cannot be quickly
 *                                  retrieved.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CBookmarkEx::ScInitialize (CMTNode* pMTNode, CMTNode* pMTViewRootNode, bool bFastRetrievalOnly)
{
    DECLARE_SC(sc, TEXT("CBookmarkEx::ScInitialize"));

    // check pointers
    sc = ScCheckPointers(pMTNode);
    if(sc)
        return sc;

    BC::Reset();

    // 1. Get the static node ID
    m_idStatic = pMTNode->GetID();

    // If this is a static node, we're done.
    if(pMTNode->IsStaticNode())
        return sc;

    bool fPassedViewRootNode = false;

    // get a descriptor for each dynamic node at the end of the branch
    // (from leaf to root)
    while ((pMTNode != NULL) && !pMTNode->IsStaticNode())
    {
        CDynamicPathEntryEx   entry;

        sc = entry.ScInitialize(pMTNode, bFastRetrievalOnly);
        if(sc.IsError() && !(sc == E_INVALIDARG) ) // E_INVALIDARG means that fast retrieval was not available.
            return sc;

        if(sc) // must be E_INVALIDARG
        {
            // if the node's data object gave us an empty custom node ID,
            // we don't want to persist this node or any below it, so purge the list
            m_dynamicPath.clear(); // clear the path
            sc.Clear();
        }
        // otherwise, put it this node ID on the front of the list
        else
            m_dynamicPath.push_front (entry);

        /*
         * remember if we've passed the node at the root of our view
         * on our way up the tree to the first static node
         */
        if (pMTNode == pMTViewRootNode)
            fPassedViewRootNode = true;

        /*
         * If we've passed the view's root node and the list is empty, it means
         * that a node between the view's root node and the first static node
         * (specifically, this one) supports CCF_NODEID and has requested
         * that the node not be persisted.  If a node isn't persisted,
         * nothing below it is persisted, either, so we can bail out.
         */
        if (fPassedViewRootNode && m_dynamicPath.empty())
            break;

        pMTNode = pMTNode->Parent();
    }

    // assume success
    sc.Clear();
    if(!pMTNode || !pMTNode->IsStaticNode())
        return (sc = E_UNEXPECTED);

    //  Get the static node ID of the static parent
    m_idStatic = pMTNode->GetID();

    // if we don't have a dynamic node path, return so
    if (m_dynamicPath.empty ())
        return (sc = S_FALSE);

    // if we hit the root before we hit a static node, we have an error
    if (pMTNode == NULL)
        sc = E_FAIL;

    return sc;

}


/*+-------------------------------------------------------------------------*
 *
 * CBookmarkEx::ScGetMTNode
 *
 * PURPOSE: Returns the MTNode of the node with the given path relative to
 *          the static node.
 *
 * PARAMETERS:
 *    bool bExactMatchRequired: [IN] Do we need exact match?
 *    CMTNode ** ppMTNode     : [OUT]: The MTNode, if found.
 *    bool bExactMatchFound   : [OUT] Did we find exact match?
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CBookmarkEx::ScGetMTNode(bool bExactMatchRequired, CMTNode **ppMTNode, bool& bExactMatchFound)
{
    DECLARE_SC(sc, TEXT("CBookmarkEx::ScGetMTNode"));

    // check parameters
    sc = ScCheckPointers(ppMTNode);
    if(sc)
        return sc;

    // init out param
    *ppMTNode = NULL;
    bExactMatchFound = false;

    CScopeTree *pScopeTree = CScopeTree::GetScopeTree();
    if(!pScopeTree)
    {
        sc = E_POINTER;
        return sc;
    }

    if (m_idStatic == ID_ConsoleRoot)
    {
        sc = ScRetarget (pScopeTree->GetRoot(), true /*bFastRetrievalOnly*/);
        if(sc)
            return sc;
    }

    // find the MTNode of the static node closest to the required node.
    CMTNode* pMTNode = NULL;
    sc = pScopeTree->Find(m_idStatic, &pMTNode);
    if(sc)
        return sc;

    sc = ScCheckPointers(pMTNode);
    if(sc)
        return sc;

    *ppMTNode = pMTNode; // initialize

    CDynamicPath::iterator iter;

    for(iter = m_dynamicPath.begin(); iter != m_dynamicPath.end(); iter++)
    {
        CDynamicPathEntryEx entry;

        entry = *iter;

        // check the next segment of the path.
        sc = ScFindMatchingMTNode(pMTNode, entry, ppMTNode);

        // handle the special case of the node not being found but an exact match
        // not being needed. In this case, we use the closest ancestor node that
        // was available.

		if ( (sc == ScFromMMC(IDS_NODE_NOT_FOUND)) && !bExactMatchRequired )
        {
            // set the output.
            *ppMTNode = pMTNode;
            sc.Clear();
            return sc;
		}


        // bail on all other errors
        if(sc)
            return sc;

        sc = ScCheckPointers(*ppMTNode);
        if(sc)
            return sc;

        pMTNode = *ppMTNode; //prime the MTNode for the next round, if there is one.
    }

    // we've found a match if we ran out of entries.
    bExactMatchFound = (iter == m_dynamicPath.end());

    if(bExactMatchRequired && !bExactMatchFound) // could not find the exact node.
    {
        *ppMTNode = NULL;
        return (sc = ScFromMMC(IDS_NODE_NOT_FOUND));
    }

    // a NULL pMTNode is not an error, we just need to make sure that
    // nodes are initialized before use.
    if ((pMTNode != NULL) && !pMTNode->IsInitialized() )
    {
        sc = pMTNode->Init();
        if(sc)
            sc.TraceAndClear(); // does not invalidate the locating operation
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CBookmarkEx::ScFindMatchingMTNode
 *
 * PURPOSE: Finds the first child node directly beneath the given parent node
 *          whose node ID (ie one of CCF_NODEID2, CCF_NODEID, or the display
 *          name) matches the specified CDynamicPathEntryEx object.
 *
 * PARAMETERS:
 *    CMTNode *             pMTNodeParent :
 *    CDynamicPathEntryEx & entry :
 *    CMTNode **            ppMatchingMTNode :      [OUT]: The child node, if found.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CBookmarkEx::ScFindMatchingMTNode(CMTNode *pMTNodeParent, CDynamicPathEntryEx &entry,
                                  CMTNode **ppMatchingMTNode)
{
    DECLARE_SC(sc, TEXT("CBookmarkEx::ScFindMatchingMTNode"));

    sc = ScCheckPointers(pMTNodeParent, ppMatchingMTNode);
    if(sc)
        return sc;

    *ppMatchingMTNode = NULL; // initialize

    // expand the parent node if not already done so.
    if (pMTNodeParent->WasExpandedAtLeastOnce() == FALSE)
    {
        sc = pMTNodeParent->Expand();
        if(sc)
            return sc;
    }

    // see if any of the children of this node match the next segment of the stored path
    for (CMTNode *pMTNode = pMTNodeParent->Child(); pMTNode != NULL; pMTNode = pMTNode->Next())
    {
        CDynamicPathEntryEx entryTemp;
        sc = entryTemp.ScInitialize(pMTNode, false /*bFastRetrievalOnly :
        at this point, we know the node is created, so we don't care about retrieval speed*/);
        if(sc)
            return sc;

        if(entryTemp == entry) // found it.
        {
            *ppMatchingMTNode = pMTNode;
            return sc;
        }
    }

    // could not find the node.
    return (sc = ScFromMMC(IDS_NODE_NOT_FOUND));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\objfmts.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       objfmts.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6/12/1997   RaviR   Created
//____________________________________________________________________________
//


#ifndef _OBJFMTS_H_
#define _OBJFMTS_H_


HRESULT GetObjFormats(UINT cfmt, FORMATETC *afmt, LPVOID *ppvObj);
HRESULT GetObjFormatsEx(IEnumFORMATETC* pEnum1, IEnumFORMATETC* pEnum2,
                        IEnumFORMATETC** ppEnumOut);


//____________________________________________________________________________
//
//  Class:      CObjFormats
//
//  Purpose:    Impements IEnumFORMATETC for objects.
//____________________________________________________________________________


class CObjFormats : public IEnumFORMATETC,
                    public CComObjectRoot
{
public:
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CObjFormats)
BEGIN_COM_MAP(CObjFormats)
    COM_INTERFACE_ENTRY(IEnumFORMATETC)
END_COM_MAP()

public:
    CObjFormats() : m_iFmt(0), m_cFmt(0), m_aFmt(NULL) 
    {
    }

    ~CObjFormats() { if (m_aFmt) delete [] m_aFmt; }

    void Init(UINT cfmt, FORMATETC * afmt)
    {
        m_cFmt = cfmt; 
        m_aFmt = afmt;
    }

    //  IEnumFORMATETC methods
    STDMETHODIMP Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumFORMATETC ** ppenum);

private:
    UINT            m_iFmt;
    UINT            m_cFmt;
    FORMATETC     * m_aFmt;

}; // class CObjFormats


//____________________________________________________________________________
//
//  Class:      CObjFormatsEx
//
//  Purpose:    Impements IEnumFORMATETC for objects.
//____________________________________________________________________________


class CObjFormatsEx : public IEnumFORMATETC,
                      public CComObjectRoot
{
public:
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CObjFormatsEx)
BEGIN_COM_MAP(CObjFormatsEx)
    COM_INTERFACE_ENTRY(IEnumFORMATETC)
END_COM_MAP()

public:
    CObjFormatsEx() : m_iCur(0)
    {
    }

    ~CObjFormatsEx() 
    { 
    }

    bool Init(IEnumFORMATETC* pEnum1, IEnumFORMATETC* pEnum2)
    {
        ASSERT(pEnum1 && pEnum2);
        if (!pEnum1 || !pEnum2)
            return false;
        
        m_rgspEnums[0] = pEnum1;
        m_rgspEnums[1] = pEnum2;
        return true;
    }

    //  IEnumFORMATETC methods
    STDMETHODIMP Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumFORMATETC ** ppenum);

private:
    UINT                m_iCur;
    IEnumFORMATETCPtr   m_rgspEnums[2];

}; // class CObjFormatsEx


#endif // _OBJFMTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\oncmenu.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       oncmenu.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1/9/1997   RaviR   Created
//____________________________________________________________________________
//


#include "stdafx.h"
#include "tasks.h"
#include "oncmenu.h"
#include <comcat.h>             // COM Component Categories Manager
#include "compcat.h"
#include "guids.h"
#include "newnode.h"
#include "..\inc\amcmsgid.h"
#include "multisel.h"
#include "scopndcb.h"
#include "cmenuinfo.h"
#include "contree.h"
#include "conview.h"
#include "conframe.h"
#include "rsltitem.h"
#include "variant.h" // ConvertByRefVariantToByValue

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// forward reference
class CConsoleStatusBar;

//############################################################################
//############################################################################
//
//  Language-independent menu names. DO NOT CHANGE THESE!!
//
//  the macro expands out to something like
//  const LPCTSTR szCONTEXTHELP = TEXT("_CONTEXTHELP")
//
//############################################################################
//############################################################################
#define DECLARE_MENU_ITEM(_item) const LPCTSTR sz##_item = TEXT("_")TEXT(#_item);

DECLARE_MENU_ITEM(CONTEXTHELP)
DECLARE_MENU_ITEM(VIEW)
DECLARE_MENU_ITEM(CUSTOMIZE)
DECLARE_MENU_ITEM(COLUMNS)
DECLARE_MENU_ITEM(VIEW_LARGE)
DECLARE_MENU_ITEM(VIEW_SMALL)
DECLARE_MENU_ITEM(VIEW_LIST)
DECLARE_MENU_ITEM(VIEW_DETAIL)
DECLARE_MENU_ITEM(VIEW_FILTERED)
DECLARE_MENU_ITEM(ORGANIZE_FAVORITES)
DECLARE_MENU_ITEM(CUT)
DECLARE_MENU_ITEM(COPY)
DECLARE_MENU_ITEM(PASTE)
DECLARE_MENU_ITEM(DELETE)
DECLARE_MENU_ITEM(PRINT)
DECLARE_MENU_ITEM(RENAME)
DECLARE_MENU_ITEM(REFRESH)
DECLARE_MENU_ITEM(SAVE_LIST)
DECLARE_MENU_ITEM(PROPERTIES)
DECLARE_MENU_ITEM(OPEN)
DECLARE_MENU_ITEM(EXPLORE)
DECLARE_MENU_ITEM(NEW_TASKPAD_FROM_HERE)
DECLARE_MENU_ITEM(EDIT_TASKPAD)
DECLARE_MENU_ITEM(DELETE_TASKPAD)
DECLARE_MENU_ITEM(ARRANGE_ICONS)
DECLARE_MENU_ITEM(ARRANGE_AUTO)
DECLARE_MENU_ITEM(LINE_UP_ICONS)
DECLARE_MENU_ITEM(TASK)
DECLARE_MENU_ITEM(CREATE_NEW)

//############################################################################
//############################################################################
//
//  Trace Tags
//
//############################################################################
//############################################################################
#ifdef DBG
CTraceTag tagOnCMenu(TEXT("OnCMenu"), TEXT("OnCMenu"));
#endif

//############################################################################
//############################################################################
//
//  Implementation of class CCustomizeViewDialog
//
//############################################################################
//############################################################################
class CCustomizeViewDialog : public CDialogImpl<CCustomizeViewDialog>
{
    typedef CCustomizeViewDialog               ThisClass;
    typedef CDialogImpl<CCustomizeViewDialog>  BaseClass;

public:
    // Operators
    enum { IDD = IDD_CUSTOMIZE_VIEW };
    CCustomizeViewDialog(CViewData *pViewData);

protected:
    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER    (WM_INITDIALOG,  OnInitDialog)
        CONTEXT_HELP_HANDLER()
        COMMAND_ID_HANDLER (IDOK,           OnOK)
        COMMAND_HANDLER    (IDC_CUST_STD_MENUS,      BN_CLICKED, OnClick)
        COMMAND_HANDLER    (IDC_CUST_SNAPIN_MENUS,   BN_CLICKED, OnClick)
        COMMAND_HANDLER    (IDC_CUST_STD_BUTTONS,    BN_CLICKED, OnClick)
        COMMAND_HANDLER    (IDC_CUST_SNAPIN_BUTTONS, BN_CLICKED, OnClick)
        COMMAND_HANDLER    (IDC_CUST_STATUS_BAR,     BN_CLICKED, OnClick)
        COMMAND_HANDLER    (IDC_CUST_DESC_BAR,       BN_CLICKED, OnClick)
        COMMAND_HANDLER    (IDC_CUST_CONSOLE_TREE,   BN_CLICKED, OnClick)
        COMMAND_HANDLER    (IDC_CUST_TASKPAD_TABS,   BN_CLICKED, OnClick)
    END_MSG_MAP();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_CUSTOMIZE_VIEW);

    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK         (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel     (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnClick      (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);


    bool PureIsDlgButtonChecked (int nIDButton) const
        { return (IsDlgButtonChecked(nIDButton) == BST_CHECKED); }

private:
    CViewData *   m_pViewData;
    bool          m_bStdMenus       : 1;
    bool          m_bSnapinMenus    : 1;
    bool          m_bStdButtons     : 1;
    bool          m_bSnapinButtons  : 1;
    bool          m_bStatusBar      : 1;
    bool          m_bDescBar        : 1;
    bool          m_bConsoleTree    : 1;
    bool          m_bTaskpadTabs    : 1;
};

CCustomizeViewDialog::CCustomizeViewDialog(CViewData *pViewData)
: m_pViewData(pViewData)
{
    DWORD dwToolbarsDisplayed = pViewData->GetToolbarsDisplayed();

    m_bStdMenus       =  dwToolbarsDisplayed & STD_MENUS;
    m_bSnapinMenus    =  dwToolbarsDisplayed & SNAPIN_MENUS;
    m_bStdButtons     =  dwToolbarsDisplayed & STD_BUTTONS;
    m_bSnapinButtons  =  dwToolbarsDisplayed & SNAPIN_BUTTONS;
    m_bStatusBar      =  pViewData->IsStatusBarVisible();
    m_bDescBar        =  pViewData->IsDescBarVisible();
    m_bConsoleTree    =  pViewData->IsScopePaneVisible();
    m_bTaskpadTabs    =  pViewData->AreTaskpadTabsAllowed();
}

LRESULT
CCustomizeViewDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    /*
     * Since these two values correspond to the possible values of a bool,
     * we don't have to have an ugly conditional operator below, i.e.:
     *
     *      CheckDlgButton (..., (m_bStdMenus) ? BST_CHECKED : BST_UNCHECKED);
     */
    ASSERT (BST_CHECKED   == true);
    ASSERT (BST_UNCHECKED == false);

    CheckDlgButton (IDC_CUST_SNAPIN_MENUS,   m_bSnapinMenus);
    CheckDlgButton (IDC_CUST_SNAPIN_BUTTONS, m_bSnapinButtons);
    CheckDlgButton (IDC_CUST_STATUS_BAR,     m_bStatusBar);
    CheckDlgButton (IDC_CUST_DESC_BAR,       m_bDescBar);
    CheckDlgButton (IDC_CUST_TASKPAD_TABS,   m_bTaskpadTabs);

    // if snap-in has disabled standard menus and toolbars, don't
    // allow user to enable them.
    // (Note: NOTOOLBARS disables both menus and toolbars)
    if (m_pViewData->GetWindowOptions() & MMC_NW_OPTION_NOTOOLBARS)
    {
        CheckDlgButton (IDC_CUST_STD_MENUS,      false);
        CheckDlgButton (IDC_CUST_STD_BUTTONS,    false);

        ::EnableWindow (GetDlgItem(IDC_CUST_STD_MENUS),   false);
        ::EnableWindow (GetDlgItem(IDC_CUST_STD_BUTTONS), false);
    }
    else
    {
        CheckDlgButton (IDC_CUST_STD_MENUS,   m_bStdMenus);
        CheckDlgButton (IDC_CUST_STD_BUTTONS, m_bStdButtons);
    }

    // if snap-in has disable the scope pane, then don't let user
    // try to enable/disable scope tree access.
    if (m_pViewData->GetWindowOptions() & MMC_NW_OPTION_NOSCOPEPANE)
    {
        CheckDlgButton (IDC_CUST_CONSOLE_TREE, false);

        ::EnableWindow (GetDlgItem(IDC_CUST_CONSOLE_TREE), false);
    }
    else
    {
        CheckDlgButton (IDC_CUST_CONSOLE_TREE, m_bConsoleTree);
    }

    // Disable/Remove the "Close"/"ALT+F4" from the dialog.
    HMENU hSysMenu = GetSystemMenu(FALSE);
    if (hSysMenu)
        VERIFY(RemoveMenu(hSysMenu, SC_CLOSE, MF_BYCOMMAND));

    return 0;
}


LRESULT
CCustomizeViewDialog::OnClick (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    CConsoleView* pConsoleView = m_pViewData->GetConsoleView();
    ASSERT (pConsoleView != NULL);

    switch (wID)
    {
        case IDC_CUST_STD_MENUS:
            m_pViewData->ToggleToolbar(MID_STD_MENUS);
            break;

        case IDC_CUST_SNAPIN_MENUS:
            m_pViewData->ToggleToolbar(MID_SNAPIN_MENUS);
            break;

        case IDC_CUST_STD_BUTTONS:
            m_pViewData->ToggleToolbar(MID_STD_BUTTONS);
            break;

        case IDC_CUST_SNAPIN_BUTTONS:
            m_pViewData->ToggleToolbar(MID_SNAPIN_BUTTONS);
            break;

        case IDC_CUST_STATUS_BAR:
            if (pConsoleView != NULL)
                pConsoleView->ScToggleStatusBar();
            break;

        case IDC_CUST_DESC_BAR:
            if (pConsoleView != NULL)
                pConsoleView->ScToggleDescriptionBar();
            break;

        case IDC_CUST_CONSOLE_TREE:
            if (pConsoleView != NULL)
                pConsoleView->ScToggleScopePane();
            break;

        case IDC_CUST_TASKPAD_TABS:
            if (pConsoleView != NULL)
                pConsoleView->ScToggleTaskpadTabs();
            break;
    }

    return (0);
}

LRESULT
CCustomizeViewDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndDialog(IDOK);
    return 0;
}


//############################################################################
//############################################################################
//
//  Implementation of class CContextMenu
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(CContextMenu);

CContextMenu::CContextMenu() :
    m_pNode(NULL),
    m_pNodeCallback(NULL),
    m_pCScopeTree(NULL),
    m_eDefaultVerb((MMC_CONSOLE_VERB)0),
    m_lCommandIDMax(0),
    m_pStatusBar(NULL),
    m_pmenuitemRoot(NULL),
    m_MaxPrimaryOwnerID(OWNERID_PRIMARY_MIN),
    m_MaxThirdPartyOwnerID(OWNERID_THIRD_PARTY_MIN),
    m_CurrentExtensionOwnerID(OWNERID_NATIVE),
    m_nNextMenuItemID(MENUITEM_BASE_ID),
    m_fPrimaryInsertionFlags(0),
    m_fThirdPartyInsertionFlags(0),
    m_fAddingPrimaryExtensionItems(false),
    m_fAddedThirdPartyExtensions(false),
    m_SnapinList(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CContextMenu);

    // Fix!!
    m_SnapinList = new SnapinStructList;
    ASSERT(m_SnapinList);
}

SC
CContextMenu::ScInitialize(
    CNode* pNode,
    CNodeCallback* pNodeCallback,
    CScopeTree* pCScopeTree,
    const CContextMenuInfo& contextInfo)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScInitialize"));

    m_pNode         = pNode;
    m_pNodeCallback = pNodeCallback;
    m_pCScopeTree   = pCScopeTree;
    m_ContextInfo   = contextInfo;

    return sc;
}


CContextMenu::~CContextMenu()
{
    EmptyMenuList();

    ASSERT(m_SnapinList != NULL);
    if (m_SnapinList != NULL)
    {
        #ifdef DBG
        int const count = m_SnapinList->GetCount();
        ASSERT( count == 0);
        #endif
        delete m_SnapinList;
    }


    DEBUG_DECREMENT_INSTANCE_COUNTER(CContextMenu);
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::SetStatusBar
 *
 * PURPOSE: Sets the status bar pointer.
 *
 * PARAMETERS:
 *    CConsoleStatusBar * pStatusBar :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CContextMenu::SetStatusBar(CConsoleStatusBar *pStatusBar)
{
    if(NULL != pStatusBar)
        m_pStatusBar = pStatusBar;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::GetStatusBar
 *
 * PURPOSE: Returns a pointer to the status bar to use when displaying the menu.
 *
 * RETURNS:
 *    CConsoleStatusBar *
 *
 *+-------------------------------------------------------------------------*/
CConsoleStatusBar *
CContextMenu::GetStatusBar()
{
    DECLARE_SC(sc, TEXT("CContextMenu::GetStatusBar"));

    if(m_pStatusBar)
        return m_pStatusBar;

    if(m_pNode && m_pNode->GetViewData())
    {
        m_pStatusBar = m_pNode->GetViewData()->GetStatusBar();
        return m_pStatusBar;
    }

    // last try, use the console view
    if(m_ContextInfo.m_pConsoleView)
    {
        sc = m_ContextInfo.m_pConsoleView->ScGetStatusBar(&m_pStatusBar);
        if(sc)
            return NULL;
    }

    return m_pStatusBar;
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScCreateInstance
 *
 * PURPOSE: Creates a new context menu instance.
 *
 * PARAMETERS:
 *    ContextMenu **  ppContextMenu :   pointer to the ContextMenu interface on
 *                                      the instance. This maintains the lifetime.
 *
 *    CContextMenu **ppCContextMenu :   If non-null, returns the derived object pointer.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScCreateInstance(ContextMenu **ppContextMenu, CContextMenu **ppCContextMenu)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScCreateInstance"));

    sc = ScCheckPointers(ppContextMenu, E_UNEXPECTED);
    if(sc)
        return sc;

    CComObject<CMMCNewEnumImpl<CContextMenu, CContextMenu::Position, CContextMenu> > *pContextMenu = NULL;
    sc = pContextMenu->CreateInstance(&pContextMenu);

    if(sc.IsError() || !pContextMenu)
        return (sc = E_UNEXPECTED).ToHr();

    *ppContextMenu = pContextMenu; // handles the lifetime.
    (*ppContextMenu)->AddRef();   // addref for client.

    if(ppCContextMenu != NULL)
        *ppCContextMenu = pContextMenu;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScCreateContextMenu
 *
 * PURPOSE: Creates a context menu for the specified node.
 *
 * PARAMETERS:
 *    PNODE          pNode :
 *    PPCONTEXTMENU  ppContextMenu :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScCreateContextMenu( PNODE pNode,  HNODE hNode, PPCONTEXTMENU ppContextMenu,
                                   CNodeCallback *pNodeCallback, CScopeTree *pScopeTree)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScCreateContextMenu"));

    CNode *pNodeTarget = CNode::FromHandle(hNode);

    // validate parameters
    sc = ScCheckPointers(pNode, pNodeTarget, ppContextMenu);
    if(sc)
        return sc;

    // init out parameter
    *ppContextMenu = NULL;

    BOOL bIsScopeNode = false;

    sc = pNode->IsScopeNode(&bIsScopeNode);
    if(sc)
        return sc;

    if(!bIsScopeNode)
        return (sc = E_NOTIMPL); // TODO: result items and multiselect items.


    // create a context menu object initialized to the specified node.
    CContextMenu *pContextMenu = NULL;
    // not using upt parameter directly to avoid returning the object
    // with an error result code. See bug 139528
    // will assign at the end when we now that everything succeeded
    ContextMenuPtr spContextMenu;
    sc = CContextMenu::ScCreateContextMenuForScopeNode(pNodeTarget, pNodeCallback, pScopeTree,
                                                       &spContextMenu, pContextMenu);
    if(sc)
        return sc;

    sc = pContextMenu->ScBuildContextMenu();
    if(sc)
        return sc;

    // return the object
    *ppContextMenu = spContextMenu.Detach();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CContextMenu::ScCreateContextMenuForScopeNode
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CNode *pNode                  - [in] node on which the context menu will be created
 *    CNodeCallback *pNodeCallback  - [in] node callback
 *    CScopeTree *pScopeTree        - [in] scope tree
 *    PPCONTEXTMENU ppContextMenu   - [out] context menu interface
 *    CContextMenu * &pContextMenu  - [out] context menu raw pointer
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC
CContextMenu::ScCreateContextMenuForScopeNode(CNode *pNode, CNodeCallback *pNodeCallback,
                                              CScopeTree *pScopeTree,
                                              PPCONTEXTMENU ppContextMenu,
                                              CContextMenu * &pContextMenu)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScCreateContextMenuForScopeNode"));

    // validate parameters
    sc = ScCheckPointers(ppContextMenu);
    if(sc)
        return sc;

    CContextMenuInfo contextInfo;

    // always use the temp verbs - cannot depend on what the active pane is
    contextInfo.m_dwFlags = CMINFO_USE_TEMP_VERB;

    bool fScopeItem = true;

    // initialize the context info structure.
    {
        contextInfo.m_eContextMenuType      = MMC_CONTEXT_MENU_DEFAULT;
        contextInfo.m_eDataObjectType       = fScopeItem ? CCT_SCOPE: CCT_RESULT;
        contextInfo.m_bBackground           = FALSE;
        contextInfo.m_hSelectedScopeNode    = NULL; //assigned below
        contextInfo.m_resultItemParam       = NULL; //resultItemParam;
        contextInfo.m_bMultiSelect          = FALSE; //(resultItemParam == LVDATA_MULTISELECT);
        contextInfo.m_bScopeAllowed         = fScopeItem;
        contextInfo.m_dwFlags              |= CMINFO_SHOW_SCOPEITEM_OPEN; // when called through the object model, always add the open item so that this can be accessed.


    if ( pNode!= NULL )
    {

        CViewData    *pViewData = pNode->GetViewData();
        CConsoleView *pView = NULL;
        if (NULL != pViewData && NULL != (pView = pViewData->GetConsoleView()))
        {
            // set the owner of the view
            contextInfo.m_hSelectedScopeNode = pView->GetSelectedNode();

            //if the scope node is also the owner of the view ,
            // add more menu items
            if (contextInfo.m_hSelectedScopeNode == CNode::ToHandle(pNode))
            {
                contextInfo.m_dwFlags |= CMINFO_SHOW_VIEWOWNER_ITEMS;

                // show view items as well
                contextInfo.m_dwFlags |= CMINFO_SHOW_VIEW_ITEMS;

                //.. and if there is a list it can be saved
                if ( NULL != pViewData->GetListCtrl() )
                    contextInfo.m_dwFlags |= CMINFO_SHOW_SAVE_LIST;
            }
        }

        contextInfo.m_hWnd                  = pNode->GetViewData()->GetView();
        contextInfo.m_pConsoleView          = pNode->GetViewData()->GetConsoleView();
    }
    }
    // create a context menu object initialized to the specified node.
    sc = CContextMenu::ScCreateInstance(ppContextMenu, &pContextMenu);
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = pContextMenu->ScInitialize(pNode, pNodeCallback, pScopeTree, contextInfo);
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScCreateSelectionContextMenu
 *
 * PURPOSE:  Creates a context menu object for the selection in the list view.
 *
 * PARAMETERS:
 *    HNODE              hNodeScope :
 *    CContextMenuInfo * pContextInfo :
 *    PPCONTEXTMENU      ppContextMenu :
 *    CNodeCallback *    pNodeCallback :
 *    CScopeTree *       pScopeTree :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScCreateSelectionContextMenu( HNODE hNodeScope, const CContextMenuInfo *pContextInfo, PPCONTEXTMENU ppContextMenu,
                                            CNodeCallback *pNodeCallback, CScopeTree *pScopeTree)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScCreateSelectionContextMenu"));

    CNode *pNodeSel = CNode::FromHandle(hNodeScope);

    // validate parameters
    sc = ScCheckPointers(pNodeSel, ppContextMenu);
    if(sc)
        return sc;


    // create a context menu object initialized to the specified node.
    CContextMenu *pContextMenu = NULL;

    sc = CContextMenu::ScCreateInstance(ppContextMenu, &pContextMenu);
    if(sc.IsError() || !pContextMenu)
    {
        return (sc = E_OUTOFMEMORY);
    }

    sc = pContextMenu->ScInitialize(pNodeSel, pNodeCallback, pScopeTree, *pContextInfo);
    if(sc)
        return sc;

    sc = pContextMenu->ScBuildContextMenu();
    if(sc)
        return sc;


    return sc;

}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScGetItem
 *
 * PURPOSE: Returns the iItem'th menu item.
 *
 * PARAMETERS:
 *    int         iItem : The zero-based item index.
 *    CMenuItem** ppMenuItem :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScGetItem(int iItem, CMenuItem** ppMenuItem)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScGetItem"));

    sc = ScCheckPointers(ppMenuItem, E_UNEXPECTED);
    if(sc)
        return sc;

    // init out param
    *ppMenuItem = NULL;

    sc = ScGetItem(GetMenuItemList(), iItem, ppMenuItem);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScGetItem
 *
 * PURPOSE: Returns the nth item in the list of menu items, or NULL if
 *          there are insufficient items.
 *          Also returns the total count of items in the list.
 *
 * NOTE:    This method allows the context menu to be traversed. Just call it
 *          with increasing iItem, for 0 <= iItem < count.
 *
 * NOTE:    ScGetItemCount benefits from knowledge about implementation details
 *          of this function.
 *
 * PARAMETERS:
 *    MenuItemList * pMenuItemList : [in] The context menu to traverse.
 *    int &          iItem : [in, destroyed on exit]: the (zero-based) item index
 *    CMenuItem**    ppMenuItem : [out]: The iItem'th menu item.
 *
 * RETURNS:
 *    SC  : S_OK for success, an error code for error.
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScGetItem(MenuItemList *pMenuItemList, int &iItem, CMenuItem** ppMenuItem)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScGetItem"));

    sc = ScCheckPointers(pMenuItemList, ppMenuItem, E_UNEXPECTED);
    if(sc)
        return sc;

    *ppMenuItem = NULL;

    POSITION position = pMenuItemList->GetHeadPosition(); // presumably we're already at the head position.

    while(position!=NULL && *ppMenuItem == NULL)
    {
        CMenuItem*  pMenuItem = pMenuItemList->GetNext(position);

        if( (pMenuItem->IsSpecialSubmenu() || pMenuItem->IsPopupMenu() )
            && pMenuItem->HasChildList())
        {
            // recurse through the submenus
            sc = ScGetItem( &pMenuItem->GetMenuItemSubmenu(), iItem, ppMenuItem );
            if(sc)
                return sc; // errors get reported right away.
        }
        else if( !pMenuItem->IsSpecialSeparator() && !pMenuItem->IsSpecialInsertionPoint()
            && !(pMenuItem->GetMenuItemFlags() & MF_SEPARATOR))
        {
            if(iItem-- == 0) // found the i'th item, but keep going to find the count of items.
                *ppMenuItem = pMenuItem;
        }
    }

    // either found one or iterated to the end ...

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CContextMenu::ScGetItemCount
 *
 * PURPOSE: Counts menu items by iterating thu them
 *
 * NOTE:    benefits from knowledge about implementation details of ScGetItem
 *
 * PARAMETERS:
 *    UINT &count
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC
CContextMenu::ScGetItemCount(UINT &count)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScGetItemCount"));

    count = 0;

    // set iItem to invalid index - so ScGetItem will iterate to the end
    const int iInvalidIndexToSearch = -1;
    int iItem = iInvalidIndexToSearch;

    CMenuItem * pMenuItem = NULL;
    sc = ScGetItem(GetMenuItemList(), iItem, &pMenuItem);
    if(sc)
        return sc;

    ASSERT( pMenuItem == NULL); // we do not expect it to be found!

    // since iItem was decremented for each element - we can easily
    // calculate how many items we've got

    count = -(iItem - iInvalidIndexToSearch);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScEnumNext
 *
 * PURPOSE: Returns a pointer to the next menu item
 *
 * PARAMETERS:
 *    Position &  pos :
 *    PDISPATCH & pDispatch :
 *
 * RETURNS:
 *    ::SC
 *
 *+-------------------------------------------------------------------------*/
::SC
CContextMenu::ScEnumNext(Position &pos, PDISPATCH & pDispatch)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScEnumNext"));

    // initialize out parameter
    pDispatch = NULL;

    long cnt = 0;
    sc = get_Count(&cnt);
    if (sc)
        return sc;

    // false if no more items
    if (cnt <= pos)
        return sc = S_FALSE;

    MenuItem *pMenuItem = NULL; // deliberately not a smart pointer.
    sc = get_Item(CComVariant((int)pos+1) /*convert from zero-based to one-based*/, &pMenuItem);
    if(sc.IsError() || sc == ::SC(S_FALSE))
        return sc;  // failed of no with such an index items (S_FALSE)

    // increment position
    pos++;

    pDispatch = pMenuItem; //retains the refcount.

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScEnumSkip
 *
 * PURPOSE: Skips the specified number of menu items.
 *
 * PARAMETERS:
 *    unsigned   long :
 *    unsigned   long :
 *    Position & pos :
 *
 * RETURNS:
 *    ::SC
 *
 *+-------------------------------------------------------------------------*/
::SC
CContextMenu::ScEnumSkip(unsigned long celt, unsigned long& celtSkipped,  Position &pos)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScEnumSkip"));

    long count = 0;

    sc = get_Count(&count);
    if(sc)
        return sc;

    if(count <= pos + celt) // could not skip as many as needed
    {
        celtSkipped = count - celt - 1;
        pos = count; // one past the end.
        return (sc = S_FALSE);
    }
    else  // could skip as many as needed.
    {
        celtSkipped = celt;
        pos += celt;

        return sc;
    }
}

::SC
CContextMenu::ScEnumReset(Position &pos)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScEnumReset"));

    pos = 0;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::get_Count
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    PLONG  pCount :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CContextMenu::get_Count(PLONG pCount)
{
    DECLARE_SC(sc, TEXT("CMMCContextMenu::get_Count"));

    sc = ScCheckPointers(pCount);
    if(sc)
        return sc.ToHr();

    // init out param
    *pCount = 0;

    UINT count = 0;
    sc = ScGetItemCount(count);
    if(sc)
        return sc.ToHr();

    *pCount = count;

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::get_Item
 *
 * PURPOSE: Returns the menu item specified by the index.
 *
 * PARAMETERS:
 *    long        Index :  The one-based index of the menu item to return.
 *    PPMENUITEM  ppMenuItem :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CContextMenu::get_Item(VARIANT IndexOrName, PPMENUITEM ppMenuItem)
{
    DECLARE_SC(sc, TEXT("CMMCContextMenu::get_Item"));

    sc = ScCheckPointers(ppMenuItem);
    if(sc)
        return sc.ToHr();

    // init out param
    *ppMenuItem = NULL;

    VARIANT* pvarTemp = ConvertByRefVariantToByValue(&IndexOrName);
    sc = ScCheckPointers( pvarTemp, E_UNEXPECTED );
    if(sc)
        return sc.ToHr();

    bool bByReference = ( 0 != (V_VT(pvarTemp) & VT_BYREF) ); // value passed by reference
    UINT uiVarType = (V_VT(pvarTemp) & VT_TYPEMASK); // get variable type (strip flags)

    CMenuItem *    pMenuItem = NULL;

    // compute the one-based index of the item
    if (uiVarType == VT_I4) // int type in C++; Long type in VB
    {
        // index: get I4 properly ( see if it's a reference )
        UINT uiIndex = bByReference ? *(pvarTemp->plVal) : pvarTemp->lVal;

        // find menu item by index
        sc = ScGetItem(uiIndex -1 /* convert from one-based to zero-based */, &pMenuItem);
        if(sc)
            return sc.ToHr();
    }
    else if (uiVarType == VT_I2) // short type in C++; Integer type in VB
    {
        // index: get I2 properly ( see if it's a reference )
        UINT uiIndex = bByReference ? *(pvarTemp->piVal) : pvarTemp->iVal;

        // find menu item by index
        sc = ScGetItem(uiIndex -1 /* convert from one-based to zero-based */, &pMenuItem);
        if(sc)
            return sc.ToHr();
    }
    else if (uiVarType == VT_BSTR) // BSTR type in C++; String type in VB
    {
        // Name: get string properly ( see if it's a reference )
        LPOLESTR lpstrPath = bByReference ? *(pvarTemp->pbstrVal) : pvarTemp->bstrVal;

        // look for subitem of root menu item
        if (m_pmenuitemRoot)
        {
            USES_CONVERSION;
            // convert to string. Avoid NULL pointer (change to empty string)
            LPCTSTR lpctstrPath = lpstrPath ? OLE2CT(lpstrPath) : _T("");
            // find menu item by path
            pMenuItem = m_pmenuitemRoot->FindItemByPath( lpctstrPath );
        }
    }
    else // something we did not expect
    {
        // we expect either index (VT_I2 , VT_I4) or path (VT_BSTR) only
        // anything else is treatead as invalid agument
        return (sc = E_INVALIDARG).ToHr();
    }

    if(!pMenuItem) // did not find it - return null
    {
        *ppMenuItem = NULL;
        return (sc = S_FALSE).ToHr();
    }

    // construct com object
    sc = pMenuItem->ScGetMenuItem(ppMenuItem);

    return sc.ToHr();
}



HRESULT CContextMenu::CreateContextMenuProvider()
{
    if (PContextInfo()->m_bBackground == TRUE &&
        PContextInfo()->m_eDataObjectType == CCT_SCOPE)
        return S_OK;

    ASSERT(m_pNode != NULL);
    if (m_pNode == NULL)
        return E_FAIL;

    HRESULT hr = S_OK;

    do // not a loop
    {
        //
        //  Use the standard verb present for this view.
        //

        if (!(PContextInfo()->m_dwFlags & CMINFO_USE_TEMP_VERB))
        {
            m_spVerbSet = m_pNode->GetViewData()->GetVerbSet();
            break;
        }

        //
        //  Create a temporary Standard verb ..
        //

        // .. for a scope item
        if (PContextInfo()->m_eDataObjectType == CCT_SCOPE)
        {
            hr = CreateTempVerbSet(true);
            break;
        }

        // .. for a list item
        if (!IS_SPECIAL_LVDATA(PContextInfo()->m_resultItemParam))
        {
            hr = CreateTempVerbSet(false);
            break;
        }

        // .. for a multi-sel in list view
        if (PContextInfo()->m_resultItemParam == LVDATA_MULTISELECT)
        {
            hr = CreateTempVerbSetForMultiSel();
            break;
        }
        else
        {
            ASSERT(0);
            hr = E_FAIL;
            break;
        }

    } while (0);

    if (FAILED(hr))
        return hr;


    m_spVerbSet->GetDefaultVerb(&m_eDefaultVerb);

    return S_OK;
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddInsertionPoint
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    long  lCommandID :
 *    long  lInsertionPointID :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddInsertionPoint(long lCommandID, long lInsertionPointID /*= CCM_INSERTIONPOINTID_ROOT_MENU*/)
{
    SC sc;
    CONTEXTMENUITEM contextmenuitem;

    ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
    contextmenuitem.strName = NULL;
    contextmenuitem.strStatusBarText = NULL;
    contextmenuitem.lCommandID = lCommandID;
    contextmenuitem.lInsertionPointID = lInsertionPointID;
    contextmenuitem.fFlags = 0;
    contextmenuitem.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;

    sc = AddItem(&contextmenuitem);
    if(sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(TEXT("CContextMenu::ScAddInsertionPoint"), sc);
    goto Cleanup;
}



/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddSeparator
 *
 * PURPOSE: Adds a separator to the context menu
 *
 * PARAMETERS:
 *    long  lInsertionPointID :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddSeparator(long lInsertionPointID /* = CCM_INSERTIONPOINTID_ROOT_MENU */)
{
    SC                      sc;
    CONTEXTMENUITEM         contextmenuitem;

    ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
    contextmenuitem.strName = NULL;
    contextmenuitem.strStatusBarText = NULL;
    contextmenuitem.lCommandID = 0;
    contextmenuitem.lInsertionPointID = lInsertionPointID;
    contextmenuitem.fFlags = MF_SEPARATOR;
    contextmenuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;

    sc = AddItem( &contextmenuitem);
    if(sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(TEXT("CContextMenu::ScAddSeparator"), sc);
    goto Cleanup;
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItem
 *
 * PURPOSE: Adds a menu item to the context menu.
 *
 * PARAMETERS:
 *    UINT      nResourceID : contains text and status text separated by '\n'
 *    long      lCommandID  : the ID used to notify the IExtendContextMenu when an item is selected
 *    long      lInsertionPointID : the location to insert the item
 *    long      fFlags :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItem(
    UINT     nResourceID, // contains text and status text separated by '\n'
    LPCTSTR  szLanguageIndependentName,
    long     lCommandID,
    long     lInsertionPointID /* = CCM_INSERTIONPOINTID_ROOT_MENU */,
    long     fFlags /* = 0 */)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItem"));

    sc = ScCheckPointers(szLanguageIndependentName, E_UNEXPECTED);
    if(sc)
        return sc;

    USES_CONVERSION;

    HINSTANCE             hInst                 = GetStringModule();
    CONTEXTMENUITEM2       contextmenuitem2;

    // load the resource
    CStr strText;
    strText.LoadString(hInst,  nResourceID );
    ASSERT( !strText.IsEmpty() );

    // split the resource into the menu text and status text
    CStr strStatusText;
    int iSeparator = strText.Find(_T('\n'));
    if (0 > iSeparator)
    {
        ASSERT( FALSE );
        strStatusText = strText;
    }
    else
    {
        strStatusText = strText.Right( strText.GetLength()-(iSeparator+1) );
        strText = strText.Left( iSeparator );
    }

    // add the menu item
    ::ZeroMemory( &contextmenuitem2, sizeof(contextmenuitem2) );
    contextmenuitem2.strName                    = T2OLE(const_cast<LPTSTR>((LPCTSTR)strText));
    contextmenuitem2.strLanguageIndependentName = T2OLE(const_cast<LPTSTR>(szLanguageIndependentName));
    contextmenuitem2.strStatusBarText           = T2OLE(const_cast<LPTSTR>((LPCTSTR)strStatusText));
    contextmenuitem2.lCommandID                 = lCommandID;
    contextmenuitem2.lInsertionPointID          = lInsertionPointID;
    contextmenuitem2.fFlags                     = fFlags;
    contextmenuitem2.fSpecialFlags              = ((fFlags & MF_POPUP) ? CCM_SPECIAL_SUBMENU : 0L) |
                                                  ((fFlags & MF_DEFAULT) ? CCM_SPECIAL_DEFAULT_ITEM : 0L);

    sc = AddItem(&contextmenuitem2);
    if(sc)
        return sc;

    return sc;
}


HRESULT
CContextMenu::CreateTempVerbSetForMultiSel(void)
{
    DECLARE_SC(sc, TEXT("CContextMenu::CreateTempVerbSetForMultiSel"));
    sc = ScCheckPointers(m_pNode, m_pNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // set standard bars
    CComObject<CTemporaryVerbSet>*  pVerbSet;
    sc = CComObject<CTemporaryVerbSet>::CreateInstance(&pVerbSet);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pVerbSet, E_OUTOFMEMORY);
    if (sc)
        return sc.ToHr();

    m_spVerbSet = pVerbSet;

    sc = m_pNodeCallback->ScInitializeTempVerbSetForMultiSel(m_pNode, *pVerbSet);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


/* CContextMenu::CreateTempVerbSet
 *
 * PURPOSE:     Used to create a temporary CVerbSet
 *
 * PARAMETERS:
 *      bool    bForScopeItem:
 *
 * RETURNS:
 *      HRESULT
 */
HRESULT CContextMenu::CreateTempVerbSet(bool bForScopeItem)
{
    DECLARE_SC(sc, TEXT("CContextMenu::CreateTempVerbSet"));
    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // ensure component is initialized !!!
    // for instance task wizard will call this for static nodes which aren't expanded yet
    // Does not hurt to check anyway - better safe than sorry
    sc = m_pNode->InitComponents ();
    if(sc)
        return sc.ToHr();

    CComponent* pCC = m_pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pCC, E_FAIL);
    if (sc)
        return sc.ToHr();

    sc = pCC->ScResetConsoleVerbStates();
    if (sc)
        return sc.ToHr();

    CComObject<CTemporaryVerbSet>*  pVerb;
    sc = CComObject<CTemporaryVerbSet>::CreateInstance(&pVerb);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pVerb, E_OUTOFMEMORY);
    if (sc)
        return sc.ToHr();

    sc = pVerb->ScInitialize(m_pNode, PContextInfo()->m_resultItemParam, bForScopeItem);
    if (sc)
    {
        delete pVerb;
        return sc.ToHr();
    }

    m_spVerbSet = pVerb;

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::AddMenuItems
 *
 * PURPOSE: Adds all menu items into the menu.
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CContextMenu::AddMenuItems()
{
    DECLARE_SC(sc, TEXT("CContextMenu::AddMenuItems"));

    sc = EmptyMenuList();
    if(sc)
        return sc.ToHr();

    // Add menu items

    if (PContextInfo()->m_eContextMenuType == MMC_CONTEXT_MENU_VIEW)
    {
         sc = ScAddMenuItemsForViewMenu(MENU_LEVEL_TOP);
         if(sc)
             return sc.ToHr();
    }
    else if (PContextInfo()->m_dwFlags & CMINFO_FAVORITES_MENU)
    {
        sc = ScAddMenuItemsforFavorites();
        if(sc)
            return sc.ToHr();
    }
    else if (PContextInfo()->m_bBackground == TRUE)
    {
        if (PContextInfo()->m_eDataObjectType != CCT_SCOPE)
        {
            sc = ScAddMenuItemsForLVBackgnd();
            if(sc)
                return sc.ToHr();
        }
    }
    else
    {
        if (PContextInfo()->m_eDataObjectType == CCT_SCOPE)
        {
            sc = ScAddMenuItemsForTreeItem();
            if(sc)
                return sc.ToHr();
        }
        else if ( m_pNode && (PContextInfo()->m_eDataObjectType == CCT_RESULT) &&
                  (m_pNode->GetViewData()->HasOCX()) )
        {
            // Selection is an OCX
            sc = ScAddMenuItemsForOCX();
            if(sc)
                return sc.ToHr();
        }
        else if ( m_pNode && (PContextInfo()->m_eDataObjectType == CCT_RESULT) &&
                  (m_pNode->GetViewData()->HasWebBrowser()) )
        {
            // do nothing for web pages.
        }
        else if (PContextInfo()->m_bMultiSelect == FALSE)
        {
            sc = ScAddMenuItemsForLV();
            if(sc)
                return sc.ToHr();
        }
        else
        {
            sc = ScAddMenuItemsForMultiSelect();
            if(sc)
                return sc.ToHr();
        }
    }

    // Add "Help" to every context menu except the view menu
    if (PContextInfo()->m_eContextMenuType != MMC_CONTEXT_MENU_VIEW)
    {
        sc = ScAddSeparator(); // make sure there is a separator.
        if(sc)
            return sc.ToHr();

        sc = ScAddMenuItem (IDS_MMC_CONTEXTHELP, szCONTEXTHELP, MID_CONTEXTHELP);
        if(sc)
            return sc.ToHr();
    }


    return sc.ToHr();
}


void
CContextMenu::RemoveTempSelection (CConsoleTree* pConsoleTree)
{
    if (pConsoleTree != NULL)
        pConsoleTree->ScRemoveTempSelection ();
}

/*+-------------------------------------------------------------------------*
 * CContextMenu::Display
 *
 * PURPOSE:   Creates the context menu tree, and shows it, if needed.
 *
 * PARAMETERS:
 *      BOOL   b: FALSE: (Normal): Display the context menu
 *                TRUE:            Don't show the context menu
 *
 * RETURNS:
 *      HRESULT
/*+-------------------------------------------------------------------------*/
HRESULT
CContextMenu::Display(BOOL b)
{
    TRACE_METHOD(CContextMenu, Display);
    HRESULT hr = S_OK;

    // b == 0    => normal
    // b == TRUE => don't show context menu

    // Validate menu type
    if (PContextInfo()->m_eContextMenuType >= MMC_CONTEXT_MENU_LAST)
    {
        ASSERT(FALSE);
        return S_FALSE;
    }


    // Display a context menu for the scope or result side
    if (PContextInfo()->m_eDataObjectType != CCT_SCOPE &&
        PContextInfo()->m_eDataObjectType != CCT_RESULT)
    {
        ASSERT(FALSE);
        return S_FALSE;
    }

    hr = CreateContextMenuProvider();
    if (FAILED(hr))
        return hr;

    hr = AddMenuItems();
    if(FAILED(hr))
        return hr;

    // Display the context menu
    long lSelected = 0;  // 0 means no selection
    hr = ShowContextMenuEx(PContextInfo()->m_hWnd,
                    PContextInfo()->m_displayPoint.x,
                    PContextInfo()->m_displayPoint.y,
                    &PContextInfo()->m_rectExclude,
                    PContextInfo()->m_bAllowDefaultItem,
                    &lSelected);


    TRACE(_T("hr = %X, Command %ld\n"), hr, lSelected);

    RemoveTempSelection (PContextInfo()->m_pConsoleTree);  // remove the temporary selection, if any.

    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScBuildContextMenu
 *
 * PURPOSE: Builds the context menu.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScBuildContextMenu()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScBuildContextMenu"));

    sc = EmptyMenuList();
    if(sc)
        return sc;

    // Validate menu type
    if (PContextInfo()->m_eContextMenuType >= MMC_CONTEXT_MENU_LAST)
        return (sc = S_FALSE);


    // Display a context menu for the scope or result side
    if (PContextInfo()->m_eDataObjectType != CCT_SCOPE &&
        PContextInfo()->m_eDataObjectType != CCT_RESULT)
        return (sc = S_FALSE);

    sc = CreateContextMenuProvider();
    if(sc)
        return sc;

    sc = AddMenuItems();
    if(sc)
        return sc;

    CConsoleTree* pConsoleTree = PContextInfo()->m_pConsoleTree; // get this value BEFORE calling BuildAndTraverseCOntextMenu.

    WTL::CMenu menu;
    VERIFY( menu.CreatePopupMenu() );

    START_CRITSEC_BOTH;

    if (NULL == m_pmenuitemRoot)
        return S_OK;

    sc = BuildContextMenu(menu);    // build the context menu
    if(sc)
        return sc;

    END_CRITSEC_BOTH;

    /* NOTE: Do NOT use the "this" object or any of its members after this point
     * because it might have been deleted. This happens, for instance, when a selection
     * change occurs.
     */

    // remove the temporary selection, if any.
    RemoveTempSelection (pConsoleTree);

    return sc;
}


inline BOOL CContextMenu::IsVerbEnabled(MMC_CONSOLE_VERB verb)
{
    DECLARE_SC(sc, TEXT("CContextMenu::IsVerbEnabled"));

    if (verb == MMC_VERB_PASTE)
    {
        ASSERT(m_pNode);
        ASSERT(m_pNodeCallback);
        if (m_pNode == NULL || m_pNodeCallback == NULL)
            return false;

        bool bPasteAllowed = false;
        // From given context determine whether scope pane or result pane item is selected.
        bool bScope = ( m_ContextInfo.m_bBackground || (m_ContextInfo.m_eDataObjectType == CCT_SCOPE));
        LPARAM lvData = bScope ? NULL : m_ContextInfo.m_resultItemParam;

        sc = m_pNodeCallback->QueryPasteFromClipboard(CNode::ToHandle(m_pNode), bScope, lvData, bPasteAllowed);
        if (sc)
            return (bPasteAllowed = false);

        return bPasteAllowed;
    }
    else
    {
        ASSERT(m_spVerbSet != NULL);
        if (m_spVerbSet == NULL)
            return FALSE;

        BOOL bFlag = FALSE;
        m_spVerbSet->GetVerbState(verb, HIDDEN, &bFlag);
        if (bFlag == TRUE)
            return FALSE;

        m_spVerbSet->GetVerbState(verb, ENABLED, &bFlag);
        return bFlag;
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsForViewMenu
 *
 * PURPOSE: Adds the menu items for the View menu
 *
 * PARAMETERS:
 *    MENU_LEVEL  menuLevel :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsForViewMenu(MENU_LEVEL menuLevel)
{
    DECLARE_SC(sc, TEXT("CContextMenu::AddMenuItemsForViewMenu"));

    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if(sc)
        return sc;

    CViewData* pViewData = m_pNode->GetViewData();

    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if(sc)
        return sc;

    ASSERT(pViewData != NULL);

    LONG lInsertID = 0;

    int nViewMode = -1;

    if (PContextInfo()->m_spListView)
        nViewMode = PContextInfo()->m_spListView->GetViewMode();

    // If no a top level menu, insert the view submenu item
    // and insert view items under it
    if (menuLevel == MENU_LEVEL_SUB)
    {
        sc = ScAddMenuItem(IDS_VIEW, szVIEW, MID_VIEW, 0, MF_POPUP);
        if(sc)
            return sc;

        lInsertID = MID_VIEW;
    }

    // Add cols only if it is List View in report or filtered mode.
    if ((m_pNode->GetViewData() )      &&
        (m_pNode->GetViewData()->GetListCtrl() ) &&
        ( (nViewMode == MMCLV_VIEWSTYLE_REPORT) ||
          (nViewMode == MMCLV_VIEWSTYLE_FILTERED) ) )
    {
        sc = ScAddMenuItem(IDS_COLUMNS, szCOLUMNS, MID_COLUMNS, lInsertID);
        if(sc)
            return sc;
    }

    sc = ScAddSeparator( lInsertID);
    if(sc)
        return sc;

    DWORD dwListOptions = pViewData->GetListOptions();
    DWORD dwMiscOptions = pViewData->GetMiscOptions();

    // If allowed, insert the standard listview choices
    if (!(dwMiscOptions & RVTI_MISC_OPTIONS_NOLISTVIEWS))
    {
        #define STYLECHECK(Mode) ((Mode == nViewMode) ? MF_CHECKED|MFT_RADIOCHECK : 0)


        sc = ScAddMenuItem(IDS_VIEW_LARGE,  szVIEW_LARGE,    MID_VIEW_LARGE,  lInsertID, STYLECHECK(LVS_ICON));
        if(sc)
            return sc;

        sc = ScAddMenuItem(IDS_VIEW_SMALL,  szVIEW_SMALL,    MID_VIEW_SMALL,  lInsertID, STYLECHECK(LVS_SMALLICON));
        if(sc)
            return sc;

        sc = ScAddMenuItem(IDS_VIEW_LIST,   szVIEW_LIST,     MID_VIEW_LIST,   lInsertID, STYLECHECK(LVS_LIST));
        if(sc)
            return sc;

        sc = ScAddMenuItem(IDS_VIEW_DETAIL, szVIEW_DETAIL,   MID_VIEW_DETAIL, lInsertID, STYLECHECK(LVS_REPORT));
        if(sc)
            return sc;

        if (dwListOptions & RVTI_LIST_OPTIONS_FILTERED)
        {
            sc = ScAddMenuItem(IDS_VIEW_FILTERED, szVIEW_FILTERED, MID_VIEW_FILTERED, lInsertID, STYLECHECK(MMCLV_VIEWSTYLE_FILTERED));
            if(sc)
                return sc;

        }

        sc = ScAddSeparator( lInsertID);
        if(sc)
             return sc;
    }

    // Ask IComponent to insert view items
    if (m_spIDataObject == NULL)
    {
        sc = ScCheckPointers (m_pNode->GetMTNode(), E_UNEXPECTED);
        if (sc)
            return sc;

        sc = m_pNode->GetMTNode()->QueryDataObject(CCT_SCOPE, &m_spIDataObject);
        if(sc)
            return sc;
    }

    sc = ScCheckPointers(m_spIDataObject, E_UNEXPECTED);
    if(sc)
        return sc;

    CComponent* pCC = m_pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pCC, E_UNEXPECTED);
    if(sc)
        return sc;

    IUnknownPtr spUnknown = pCC->GetIComponent();
    sc = ScCheckPointers(spUnknown);
    if(sc)
        return sc;

    // Add insertion point for primary custom views
    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_VIEW, lInsertID);
    if(sc)
        return sc;

    sc = AddPrimaryExtensionItems(spUnknown, m_spIDataObject);
    if(sc)
        return sc;

    if (pViewData->AllowViewCustomization())
    {
        // "Customize" menu item
        sc = ScAddSeparator( lInsertID);
        if(sc)
            return sc;

        sc = ScAddMenuItem( IDS_CUSTOMIZE, szCUSTOMIZE, MID_CUSTOMIZE, lInsertID);
        if(sc)
            return sc;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsforFavorites
 *
 * PURPOSE:   Adds items for the Favorites menu
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsforFavorites()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItemsforFavorites"));

    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if(sc)
        return sc;

    CViewData*  pViewData = m_pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if(sc)
        return sc;

    if (pViewData->IsAuthorMode())
    {
        sc = ScAddMenuItem( IDS_ORGANIZEFAVORITES, szORGANIZE_FAVORITES, MID_ORGANIZE_FAVORITES);
        if(sc)
            return sc;

        sc = ScAddSeparator();
        if(sc)
            return sc;
    }

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsForVerbSets
 *
 * PURPOSE: Adds the built-in menu items for the verbs
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsForVerbSets()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItemsForVerbSets"));

    // Add print menu item
    sc = ScAddSeparator();
    if(sc)
        return sc;


    if (IsVerbEnabled(MMC_VERB_CUT) == TRUE)
    {
        sc = ScAddMenuItem( IDS_CUT, szCUT, MID_CUT);
        if(sc)
            return sc;
    }

    if (IsVerbEnabled(MMC_VERB_COPY) == TRUE)
    {
        sc = ScAddMenuItem( IDS_COPY, szCOPY, MID_COPY);
        if(sc)
            return sc;
    }

    if (IsVerbEnabled(MMC_VERB_PASTE) == TRUE)
    {
        sc = ScAddMenuItem( IDS_PASTE, szPASTE, MID_PASTE);
        if(sc)
            return sc;
    }

    if (IsVerbEnabled(MMC_VERB_DELETE) == TRUE)
    {
        sc = ScAddMenuItem( IDS_DELETE, szDELETE, MID_DELETE);
        if(sc)
            return sc;
    }

    if (IsVerbEnabled(MMC_VERB_PRINT) == TRUE)
    {
        sc = ScAddMenuItem( IDS_PRINT, szPRINT, MID_PRINT);
        if(sc)
            return sc;
    }

    if (IsVerbEnabled(MMC_VERB_RENAME) == TRUE)
    {
        sc = ScAddMenuItem( IDS_RENAME, szRENAME, MID_RENAME);
        if(sc)
            return sc;
    }

    if (IsVerbEnabled(MMC_VERB_REFRESH) == TRUE)
    {
        sc = ScAddMenuItem( IDS_REFRESH, szREFRESH, MID_REFRESH);
        if(sc)
            return sc;
    }

    // NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB

    // In the verb add command because it is diaplayed next to the verbs

    // Send a message to the list asking if it has anything on it.
    // If so, display the 'save list' item

    if (PContextInfo()->m_dwFlags & CMINFO_SHOW_SAVE_LIST)
    {
        sc = ScAddMenuItem( IDS_SAVE_LIST, szSAVE_LIST, MID_LISTSAVE);
        if(sc)
            return sc;
    }

    // NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB

    sc = ScAddSeparator();
    if(sc)
        return sc;

    // Ask the node whether it will put up property pages. If so add the
    // "Properties" menu item
    if (IsVerbEnabled(MMC_VERB_PROPERTIES) == TRUE)
    {
		// Do not make properties bold for scope items.
		bool bScopeItemInScopePane = (CMINFO_DO_SCOPEPANE_MENU & m_ContextInfo.m_dwFlags);
		bool bEnablePropertiesAsDefaultMenu = ( (m_eDefaultVerb == MMC_VERB_PROPERTIES) && (! bScopeItemInScopePane) );

        sc = ScAddMenuItem( IDS_PROPERTIES, szPROPERTIES, MID_PROPERTIES, 0,
                            bEnablePropertiesAsDefaultMenu ? MF_DEFAULT : 0);
        if(sc)
            return sc;


        sc = ScAddSeparator();
        if(sc)
            return sc;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsForTreeItem
 *
 * PURPOSE: Adds menu items for a scope node in the tree
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsForTreeItem()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItemsForTreeItem"));

    sc = ScCheckPointers(m_pNode);
    if(sc)
        return sc;

    CMTNode*    pMTNode   = m_pNode->GetMTNode();
    CViewData*  pViewData = m_pNode->GetViewData();

    sc = ScCheckPointers(pMTNode, pViewData);
    if(sc)
        return sc;

    // Show Open item if enabled or forced by caller
    if ( IsVerbEnabled(MMC_VERB_OPEN) == TRUE ||
         PContextInfo()->m_dwFlags & CMINFO_SHOW_SCOPEITEM_OPEN )
    {
        sc = ScAddMenuItem( IDS_OPEN, szOPEN, MID_OPEN, 0,
                           (m_eDefaultVerb == MMC_VERB_OPEN) ? MF_DEFAULT : 0);
        if(sc)
            return sc;
    }

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_TOP);
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

    // Add "Create New" menu item
    sc = ScAddSubmenu_CreateNew(m_pNode->IsStaticNode());
    if(sc)
        return sc;

    // Add "Task" menu item
    sc = ScAddSubmenu_Task();
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

    // Show the view menu
    if (PContextInfo()->m_dwFlags & CMINFO_SHOW_VIEW_ITEMS)
    {
        sc = ScAddMenuItemsForViewMenu(MENU_LEVEL_SUB);
        if(sc)
            return sc;
    }

    // New window is allowed only if the view allows customization and
    // it is not SDI user mode.
    if (m_pNode->AllowNewWindowFromHere() && !pViewData->IsUser_SDIMode())
        ScAddMenuItem( IDS_EXPLORE, szEXPLORE, MID_EXPLORE);


    // Taskpad editing only allowed in author mode and for node that owns the view
    if (pViewData->IsAuthorMode() && (PContextInfo()->m_dwFlags & CMINFO_SHOW_VIEWOWNER_ITEMS))
    {
        // add the "New Taskpad..." menu item
        sc = ScAddSeparator();
        if(sc)
            return sc;

        sc = ScAddMenuItem( IDS_NEW_TASKPAD_FROM_HERE, szNEW_TASKPAD_FROM_HERE,
                           MID_NEW_TASKPAD_FROM_HERE);
        if(sc)
            return sc;


        // add the "Edit Taskpad" and "Delete Taskpad" menus item if the callback pointer is non-null.
        if ((pViewData->m_spTaskCallback != NULL) &&
			(pViewData->m_spTaskCallback->IsEditable() == S_OK))
        {
            sc = ScAddMenuItem( IDS_EDIT_TASKPAD,   szEDIT_TASKPAD,   MID_EDIT_TASKPAD);
            if(sc)
                return sc;

            sc = ScAddMenuItem( IDS_DELETE_TASKPAD, szDELETE_TASKPAD, MID_DELETE_TASKPAD);
            if(sc)
                return sc;

        }
    }

    sc = ScAddMenuItemsForVerbSets();
    if(sc)
        return sc;

    // Ask the snap-ins to add there menu items.
    CComponentData* pCCD = pMTNode->GetPrimaryComponentData();

    if (m_spIDataObject == NULL)
    {
         sc = pMTNode->QueryDataObject(CCT_SCOPE, &m_spIDataObject);
         if(sc)
             return sc;
    }

    //ASSERT(m_pNode->GetPrimaryComponent() != NULL);
    //IUnknownPtr spUnknown = m_pNode->GetPrimaryComponent()->GetIComponent();
    // TODO: This is temporary. All context menu notifications should
    // go to IComponent's in the future.
    IUnknownPtr spUnknown = pCCD->GetIComponentData();
    ASSERT(spUnknown != NULL);

    sc = AddPrimaryExtensionItems(spUnknown, m_spIDataObject);
    if(sc)
        return sc;


    sc = AddThirdPartyExtensionItems(m_spIDataObject);
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsForMultiSelect
 *
 * PURPOSE: Menu for use when multiple items are selected and the right mouse button is pressed
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsForMultiSelect()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItemsForMultiSelect"));

    sc = EmptyMenuList();
    if(sc)
        return sc;


    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_TOP);
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

    // no Create New menu for result items
    sc = ScAddSubmenu_Task();
    if(sc)
        return sc;

    sc = ScAddMenuItemsForVerbSets();
    if(sc)
        return sc;

    {
        ASSERT(m_pNode != NULL);
        sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
        if(sc)
            return sc;

        sc = ScCheckPointers(m_pNode->GetViewData(), E_UNEXPECTED);
        if(sc)
            return sc;

        CMultiSelection* pMS = m_pNode->GetViewData()->GetMultiSelection();
        if (pMS != NULL)
        {
            IDataObjectPtr spIDataObject;
            sc = pMS->GetMultiSelDataObject(&spIDataObject);
            if(sc)
                return sc;

            CSnapIn* pSI = m_pNode->GetPrimarySnapIn();
            if (pSI != NULL &&
                pMS->IsAnExtensionSnapIn(pSI->GetSnapInCLSID()) == TRUE)
            {
                sc = ScCheckPointers(m_pNode->GetPrimaryComponent(), E_UNEXPECTED);
                if(sc)
                    return sc;

                IComponent* pIComponent = m_pNode->GetPrimaryComponent()->GetIComponent();

                sc = AddPrimaryExtensionItems(pIComponent, spIDataObject);
                if(sc)
                    return sc;
            }

            sc = AddMultiSelectExtensionItems(reinterpret_cast<LONG_PTR>(pMS));
            if(sc)
                return sc;
        }
    }

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsForOCX
 *
 * PURPOSE: This method will be called if there is an OCX in
 *          Result pane and some thing is selected in OCX and
 *          the user clicked "Action" menu.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsForOCX()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItemsForOCX"));

    LPCOMPONENT pIComponent = NULL;    // IComponent interface to the snap-in
    CComponent* pComponent  = NULL;    // Internal component structure
    MMC_COOKIE cookie;

    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = EmptyMenuList();
    if(sc)
        return sc;

    if (IsVerbEnabled(MMC_VERB_OPEN) == TRUE)
    {
        sc = ScAddMenuItem( IDS_OPEN, szOPEN, MID_OPEN, 0,
                           (m_eDefaultVerb == MMC_VERB_OPEN) ? MF_DEFAULT : 0);
        if(sc)
            return sc;
    }

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_TOP);
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

    // no Create New menu for result items
    sc = ScAddSubmenu_Task();
    if(sc)
        return sc;

    sc = ScAddMenuItemsForVerbSets();
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

    LPDATAOBJECT lpDataObj = (m_pNode->GetViewData()->HasOCX()) ?
                             DOBJ_CUSTOMOCX : DOBJ_CUSTOMWEB;

    // Item must be from primary component
    pComponent = m_pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if(sc)
        return sc;

    pIComponent = pComponent->GetIComponent();
    sc = ScCheckPointers(pIComponent, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = AddPrimaryExtensionItems(pIComponent, lpDataObj);
    if(sc)
        return sc;


    return TRUE;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsForLV
 *
 * PURPOSE: Add menu items for a list view item
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsForLV()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItemsForLV"));

    LPCOMPONENT pIComponent;    // IComponet interface to the snap-in
    CComponent* pComponent;     // Internal component structure
    MMC_COOKIE cookie;

    ASSERT(m_pNode != NULL);
    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if (sc)
        return sc;

    // if virtual list
    if (m_pNode->GetViewData()->IsVirtualList())
    {
        // ItemParam is the item index, use it as the cookie
        cookie = PContextInfo()->m_resultItemParam;

        // Item must be from primary component
        pComponent = m_pNode->GetPrimaryComponent();
    }
    else
    {
        // ItemParam is list item data, get cookie and component ID from it
        ASSERT(PContextInfo()->m_resultItemParam != 0);
        CResultItem* pri = GetResultItem();

        if (pri != NULL)
        {
            ASSERT(!pri->IsScopeItem());

            cookie = pri->GetSnapinData();
            pComponent = m_pNode->GetComponent(pri->GetOwnerID());
        }
    }

    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if(sc)
        return sc;

    pIComponent = pComponent->GetIComponent();

    sc = ScCheckPointers(pIComponent);
    if(sc)
        return sc;

    // Load the IDataObject for the snap-in's cookie
    if (m_spIDataObject == NULL)
    {
        sc = pIComponent->QueryDataObject(cookie, CCT_RESULT, &m_spIDataObject);
        if(sc)
            return sc;
    }

    sc = EmptyMenuList();
    if(sc)
        return sc;

    if (IsVerbEnabled(MMC_VERB_OPEN) == TRUE)
    {
        sc = ScAddMenuItem( IDS_OPEN, szOPEN, MID_OPEN, 0, (m_eDefaultVerb == MMC_VERB_OPEN) ? MF_DEFAULT : 0);
        if(sc)
            return sc;
    }

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_TOP);
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

        // no Create New menu for result items
    sc = ScAddSubmenu_Task();
    if(sc)
        return sc;

    sc = ScAddMenuItemsForVerbSets();
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

    sc = AddPrimaryExtensionItems(pIComponent, m_spIDataObject);
    if(sc)
        return sc;

    sc = AddThirdPartyExtensionItems(m_spIDataObject);
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsForLVBackgnd
 *
 * PURPOSE: This handles a right mouse click on the result pane side (Assuming our listview)
 *          It displays also adds the currently selected folders context menu items
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsForLVBackgnd()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItemsForLVBackgnd"));

    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = EmptyMenuList();
    if(sc)
        return sc;

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_TOP);
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

    sc = ScAddSubmenu_CreateNew(m_pNode->IsStaticNode());
    if(sc)
        return sc;

    sc = ScAddSubmenu_Task();
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

   // Add relevant standard verbs.
    if (IsVerbEnabled(MMC_VERB_PASTE) == TRUE)
    {
        sc = ScAddMenuItem( IDS_PASTE, szPASTE, MID_PASTE);
        if(sc)
            return sc;
    }

    if (IsVerbEnabled(MMC_VERB_REFRESH) == TRUE)
    {
        sc = ScAddMenuItem( IDS_REFRESH, szREFRESH, MID_REFRESH);
        if(sc)
            return sc;
    }

    // Displays the save list icon if necessary
    if ((PContextInfo()->m_pConsoleView != NULL) &&
        (PContextInfo()->m_pConsoleView->GetListSize() > 0))
    {
        sc = ScAddMenuItem( IDS_SAVE_LIST, szSAVE_LIST, MID_LISTSAVE);
        if(sc)
            return sc;
    }

    sc = ScAddSeparator();
    if(sc)
        return sc;

    // Add view submenu
    sc = ScAddMenuItemsForViewMenu(MENU_LEVEL_SUB);
    if(sc)
        return sc;

    // Add Arrange Icons
    sc = ScAddSeparator();
    if(sc)
        return sc;

    sc = ScAddMenuItem( IDS_ARRANGE_ICONS, szARRANGE_ICONS, MID_ARRANGE_ICONS, 0, MF_POPUP);
    if(sc)
        return sc;

    long lStyle = 0;
    if (PContextInfo()->m_spListView)
    {
        lStyle = PContextInfo()->m_spListView->GetListStyle();
        ASSERT(lStyle != 0);
    }


        // auto arrange
    sc = ScAddMenuItem( IDS_ARRANGE_AUTO, szARRANGE_AUTO, MID_ARRANGE_AUTO, MID_ARRANGE_ICONS,
                       ((lStyle & LVS_AUTOARRANGE) ? MF_CHECKED : MF_UNCHECKED));
    if(sc)
        return sc;

    sc = ScAddMenuItem( IDS_LINE_UP_ICONS, szLINE_UP_ICONS, MID_LINE_UP_ICONS);
    if(sc)
        return sc;

// Ask the node whether it will put up property pages. If so add the
// "Properties" menu item
    if (IsVerbEnabled(MMC_VERB_PROPERTIES) == TRUE)
    {
        sc = ScAddMenuItem( IDS_PROPERTIES, szPROPERTIES, MID_PROPERTIES);
        if(sc)
            return sc;

        sc = ScAddSeparator();
        if(sc)
            return sc;
    }


    // if there is a valid data object we would have gotten it when adding the
    // view menu itmes, so we don't need to duplicate the code to get it here
    if (m_spIDataObject != NULL)
    {
        CComponent* pCC = m_pNode->GetPrimaryComponent();
        sc = ScCheckPointers(pCC, E_UNEXPECTED);
        if(sc)
            return sc;

        IUnknownPtr spUnknown = pCC->GetIComponent();
        sc = ScCheckPointers(spUnknown);
        if(sc)
            return sc;

        sc = AddPrimaryExtensionItems(spUnknown, m_spIDataObject);
        if(sc)
            return sc;

        sc = AddThirdPartyExtensionItems(m_spIDataObject);
        if(sc)
            return sc;
    }

    return sc;
}

void OnCustomizeView(CViewData* pViewData)
{
    CCustomizeViewDialog dlg(pViewData);
    dlg.DoModal();
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::AddMenuItems
 *
 * PURPOSE: Unimplemented, but needed because this class implements
 *          IExtendContextMenu
 *
 * PARAMETERS:
 *    LPDATAOBJECT           pDataObject :
 *    LPCONTEXTMENUCALLBACK  pCallback :
 *    long *                 pInsertionAllowed :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItems( LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallback, long * pInsertionAllowed)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItems"));
    ASSERT(0 && "Should not come here!");
    return sc = E_UNEXPECTED;
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::Command
 *
 * PURPOSE: Handles the built- in menu item execution.
 *
 * PARAMETERS:
 *    long          lCommandID :
 *    LPDATAOBJECT  pDataObject :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScCommand(long lCommandID, LPDATAOBJECT pDataObject)
{
    DECLARE_SC(sc, TEXT("CContextMenu::Command"));

    CNodeCallback * pNodeCallback=GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback, E_UNEXPECTED);
    if(sc)
        return sc;

    /*+-------------------------------------------------------------------------*/
    // special case: MID_CONTEXTHELP: m_pNode can be NULL when help clicked on scope node background,
    // so we handle this first.
    if(MID_CONTEXTHELP == lCommandID)
    {
        sc = ScCheckPointers(PContextInfo());
        if(sc)
            return sc;

        CConsoleView*   pConsoleView = PContextInfo()->m_pConsoleView;
        sc = ScCheckPointers(pConsoleView);
        if(sc)
            return sc;

        if (PContextInfo()->m_bMultiSelect)
        {
            sc = pConsoleView->ScContextHelp ();
            if(sc)
                return sc;
        }
        else
        {
            sc = pNodeCallback->Notify(CNode::ToHandle(m_pNode), NCLBK_CONTEXTHELP,
                                             ((PContextInfo()->m_eDataObjectType == CCT_SCOPE) ||
                                              (PContextInfo()->m_bBackground == TRUE)),
                                             PContextInfo()->m_resultItemParam);

            // if snap-in did not handle the help request, show mmc topics
            if (sc.ToHr() != S_OK)
                sc = PContextInfo()->m_pConsoleView->ScHelpTopics ();

            return sc;
        }

        return sc;
    }
    /*+-------------------------------------------------------------------------*/


    // must have a non-null m_pNode.
    sc = ScCheckPointers(m_pNode);
    if(sc)
        return sc;

    HNODE           hNode       = CNode::ToHandle(m_pNode);
    BOOL            bModeChange = FALSE;
    int             nNewMode;

    // some widely used objects
    CViewData *     pViewData   = m_pNode->GetViewData();
    sc = ScCheckPointers(pViewData);
    if(sc)
        return sc;

    CConsoleFrame*  pFrame      = pViewData->GetConsoleFrame();
    CMTNode*        pMTNode     = m_pNode->GetMTNode();
    CConsoleView*   pConsoleView= pViewData->GetConsoleView();

    sc = ScCheckPointers(pFrame, pMTNode, pConsoleView, E_UNEXPECTED);
    if(sc)
        return sc;

    // handle the correct item
    switch (lCommandID)
    {

    case MID_RENAME:
        sc = pConsoleView->ScOnRename(PContextInfo());
        if(sc)
            return sc;
        break;

    case MID_REFRESH:
        {
            BOOL bScope = ( (PContextInfo()->m_eDataObjectType == CCT_SCOPE) ||
                            (PContextInfo()->m_bBackground == TRUE) );

            sc = pConsoleView->ScOnRefresh(hNode, bScope, PContextInfo()->m_resultItemParam);
            if(sc)
                return sc;
        }
        break;

    case MID_LINE_UP_ICONS:
        sc = pConsoleView->ScLineUpIcons();
        if(sc)
            return sc;
        break;

    case MID_ARRANGE_AUTO:
        sc = pConsoleView->ScAutoArrangeIcons();
        if(sc)
            return sc;
        break;


    case MID_ORGANIZE_FAVORITES:
        sc = pConsoleView->ScOrganizeFavorites();
        if(sc)
            return sc;
        break;


    case MID_DELETE:
        {
            bool  bScope                             = (CCT_SCOPE == PContextInfo()->m_eDataObjectType);
            bool  bScopeItemInResultPane             = PContextInfo()->m_dwFlags & CMINFO_SCOPEITEM_IN_RES_PANE;
            bool  bScopeItemInScopePaneOrResultPane  = bScope || bScopeItemInResultPane;

            LPARAM lvData = PContextInfo()->m_resultItemParam;

            if (PContextInfo()->m_bBackground)
                lvData = LVDATA_BACKGROUND;
            else if (PContextInfo()->m_bMultiSelect)
                lvData = LVDATA_MULTISELECT;

            sc = pNodeCallback->Notify(hNode, NCLBK_DELETE,
                      bScopeItemInScopePaneOrResultPane ,
                      lvData);
            if(sc)
                return sc;
            break;
        }


    case MID_NEW_TASKPAD_FROM_HERE:
        sc = pNodeCallback->Notify(hNode, NCLBK_NEW_TASKPAD_FROM_HERE, 0, 0);
        if(sc)
            return sc;
        break;

    case MID_EDIT_TASKPAD:
        sc = pNodeCallback->Notify(hNode, NCLBK_EDIT_TASKPAD, 0, 0);
        if(sc)
            return sc;
        break;

    case MID_DELETE_TASKPAD:
        sc = pNodeCallback->Notify(hNode, NCLBK_DELETE_TASKPAD, 0, 0);
        if(sc)
            return sc;
        break;

    case MID_EXPLORE:       // New window from here
        {
            CreateNewViewStruct cnvs;
            cnvs.idRootNode     = pMTNode->GetID();
            cnvs.lWindowOptions = MMC_NW_OPTION_NONE;
            cnvs.fVisible       = true;

            sc = pFrame->ScCreateNewView(&cnvs);
            if(sc)
                return sc;
        }
        break;

    case MID_OPEN:
        {
            sc = pConsoleView->ScSelectNode (pMTNode->GetID());
            if(sc)
                return sc;
        }
        break;

    case MID_PROPERTIES:
        if (NULL == m_pNode)
            return (sc = E_UNEXPECTED);

        sc = ScDisplaySnapinPropertySheet();
        if(sc)
            return sc;

        break;

    case MID_VIEW_LARGE:
        bModeChange = TRUE;
        nNewMode = LVS_ICON;
        break;

    case MID_VIEW_SMALL:
        bModeChange = TRUE;
        nNewMode = LVS_SMALLICON;
        break;

    case MID_VIEW_LIST:
        bModeChange = TRUE;
        nNewMode = LVS_LIST;
        break;

    case MID_VIEW_DETAIL:
        bModeChange = TRUE;
        nNewMode = LVS_REPORT;
        break;

    case MID_VIEW_FILTERED:
        bModeChange = TRUE;
        nNewMode = MMCLV_VIEWSTYLE_FILTERED;
        break;

    case MID_CUT:
        sc = pNodeCallback->Notify(CNode::ToHandle(m_pNode), NCLBK_CUT,
                                         (PContextInfo()->m_eDataObjectType == CCT_SCOPE),
                                         PContextInfo()->m_resultItemParam);
        if(sc)
            return sc;

        sc = pConsoleView->ScCut (PContextInfo()->m_htiRClicked);
        if(sc)
            return sc;

        break;

    case MID_COPY:
        sc = pNodeCallback->Notify(CNode::ToHandle(m_pNode), NCLBK_COPY,
                                         (PContextInfo()->m_eDataObjectType == CCT_SCOPE),
                                         PContextInfo()->m_resultItemParam);
        if(sc)
            return sc;
        break;

    case MID_PASTE:
        sc = pNodeCallback->Paste(CNode::ToHandle(m_pNode),
                                  ((PContextInfo()->m_eDataObjectType == CCT_SCOPE) ||
                                   (PContextInfo()->m_bBackground == TRUE)),
                                  PContextInfo()->m_resultItemParam);

        if(sc)
            return sc;

        sc = pConsoleView->ScPaste ();
        if(sc)
            return sc;

        break;

    case MID_COLUMNS:
        ASSERT(m_pNode);
        if (m_pNode)
            m_pNode->OnColumns();
        break;

    case MID_LISTSAVE:
        // If the listsave menu item has been activated, then tell the view to
        // save the active list
        sc = pConsoleView->ScSaveList();
        if(sc)
            return sc;

        break;

    case MID_PRINT:
        sc = pNodeCallback->Notify(CNode::ToHandle(m_pNode), NCLBK_PRINT,
                                         ((PContextInfo()->m_eDataObjectType == CCT_SCOPE) ||
                                          (PContextInfo()->m_bBackground == TRUE)),
                                         PContextInfo()->m_resultItemParam);
        if(sc)
            return sc;
        break;

    case MID_CUSTOMIZE:
        if (pViewData)
            OnCustomizeView(pViewData);
        break;


    default:
        ASSERT(0 && "Should not come here");
        break;

    }

    if (bModeChange)
    {
        sc = ScChangeListViewMode(nNewMode);
        if(sc)
            return sc;
    }

    return sc;
}



/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScChangeListViewMode
 *
 * PURPOSE: Changes the list view mode to the specified  mode.
 *
 * PARAMETERS:
 *    int  nNewMode : The mode to change to.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScChangeListViewMode(int nNewMode)
{

    DECLARE_SC(sc, TEXT("CContextMenu::ScChangeListViewMode"));

    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if(sc)
        return sc;

    // If switching from a snapin custom to a standard listview
    // send snapin a notification command
    if ((PContextInfo()->m_spListView == NULL))
    {
        sc = ScCheckPointers(m_spIDataObject.GetInterfacePtr(), E_UNEXPECTED);
        if(sc)
            return sc;

        CComponent* pCC = m_pNode->GetPrimaryComponent();
        sc = ScCheckPointers(pCC, E_UNEXPECTED);
        if(sc)
            return sc;

        IExtendContextMenuPtr spIExtendContextMenu = pCC->GetIComponent();
        if(spIExtendContextMenu)
		{
			try
			{
				sc = spIExtendContextMenu->Command(MMCC_STANDARD_VIEW_SELECT, m_spIDataObject);
				if(sc)
					return sc;
			}
			catch ( std::bad_alloc )
			{
				return (sc = E_OUTOFMEMORY);
			}
			catch ( std::exception )
			{
				return (sc = E_UNEXPECTED);
			}
		}
    }

    CViewData *pViewData = m_pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    // Persist the new mode.
    sc = m_pNode->ScSetViewMode(nNewMode);
    if (sc)
        return sc;

    // tell conui to change the list mode.
    CConsoleView* pConsoleView = pViewData->GetConsoleView();
    sc = ScCheckPointers(pConsoleView, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = pConsoleView->ScChangeViewMode (nNewMode);
    if (sc)
        return sc;

    return sc;
}



/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddSubmenu_Task
 *
 * PURPOSE: Adds the Task submenu
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddSubmenu_Task()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddSubmenu_Task"));
    sc = ScAddMenuItem(IDS_TASK, szTASK, MID_TASK, 0, MF_POPUP);
    if(sc)
        return sc;

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_TASK, MID_TASK);
    if(sc)
        return sc;

    sc = ScAddSeparator( MID_TASK );
    if(sc)
        return sc;

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_3RDPARTY_TASK, MID_TASK);
    if(sc)
        return sc;

    sc = ScAddSeparator( MID_TASK);
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddSubmenu_CreateNew
 *
 * PURPOSE: Adds the New submenu
 *
 * PARAMETERS:
 *    BOOL  fStaticFolder :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddSubmenu_CreateNew(BOOL fStaticFolder)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddSubmenu_CreateNew"));

    sc = ScAddMenuItem(IDS_CREATE_NEW, szCREATE_NEW, MID_CREATE_NEW, 0, MF_POPUP);
    if(sc)
        return sc;

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_NEW, MID_CREATE_NEW);
    if(sc)
        return sc;

    sc = ScAddSeparator( MID_CREATE_NEW);
    if(sc)
        return sc;

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_3RDPARTY_NEW, MID_CREATE_NEW);
    if(sc)
        return sc;

    sc = ScAddSeparator( MID_CREATE_NEW);
    if(sc)
        return sc;

    return sc;
}



/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScDisplaySnapinPropertySheet
 *
 * PURPOSE:
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScDisplaySnapinPropertySheet()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScDisplaySnapinPropertySheet"));

    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if (sc)
        return sc;

    if (CCT_SCOPE == PContextInfo()->m_eDataObjectType ||
        PContextInfo()->m_bBackground == TRUE)
    {
        sc = ScDisplaySnapinNodePropertySheet(m_pNode);
        if(sc)
            return sc;
    }
    else
    {
        // Get the view type.
        ASSERT(m_pNode->GetViewData());
        CViewData *pViewData = m_pNode->GetViewData();

        if (PContextInfo()->m_bMultiSelect)
        {
            // Must be in the result pane.
            sc = ScDisplayMultiSelPropertySheet(m_pNode);
            if(sc)
                return sc;
        }
        else if (m_pNode->GetViewData()->IsVirtualList())
        {
            // if virtual list, must be leaf item and resultItemParam is the cookie
            sc = ScDisplaySnapinLeafPropertySheet(m_pNode, PContextInfo()->m_resultItemParam);
            if(sc)
                return sc;
        }
        else if( (pViewData->HasOCX()) || (pViewData->HasWebBrowser()) )
        {
            LPDATAOBJECT pdobj = (pViewData->HasOCX()) ? DOBJ_CUSTOMOCX
                                                              : DOBJ_CUSTOMWEB;
            CComponent* pCC = m_pNode->GetPrimaryComponent();
            ASSERT(pCC != NULL);

            // The custom view was selected and "properties" was selected from "Action Menu".
            // We dont know anything about the view, so we fake "Properties" button click.
            pCC->Notify(pdobj, MMCN_BTN_CLICK, 0, MMC_VERB_PROPERTIES);
        }
        else
        {
            CResultItem* pri = GetResultItem();

            if (pri != NULL)
            {
                if (pri->IsScopeItem())
                {
                    sc = ScDisplaySnapinNodePropertySheet(m_pNode);
                    if(sc)
                        return sc;
                }
                else
                {
                    sc = ScDisplaySnapinLeafPropertySheet(m_pNode, pri->GetSnapinData());
                    if(sc)
                        return sc;
                }
            }
        }
    }

    return sc;
}

/************************************************************************
 * -----------------------------------------
 * Order:  Calling function
 *         Called function 1
 *         Called function 2
 * -----------------------------------------
 *
 *
 * CContextMenu::ProcessSelection()
 *     CContextMenu::ScDisplaySnapinPropertySheet()
 *                 ScDisplaySnapinNodePropertySheet(CNode* pNode)
 *                     ScDisplaySnapinPropertySheet
 *                         FindPropertySheet
 *                 ScDisplayMultiSelPropertySheet(CNode* pNode)
 *                     ScDisplaySnapinPropertySheet
 *                         FindPropertySheet
 *                 ScDisplaySnapinLeafPropertySheet(CNode* pNode, LPARAM lParam)
 *                     ScDisplaySnapinPropertySheet
 *                         FindPropertySheet
 *
 * CNodeCallback::OnProperties(CNode* pNode, BOOL bScope, LPARAM lvData)
 *     ScDisplaySnapinNodePropertySheet(CNode* pNode)
 *         ScDisplaySnapinPropertySheet
 *             FindPropertySheet
 *     ScDisplayMultiSelPropertySheet(CNode* pNode)
 *         ScDisplaySnapinPropertySheet
 *             FindPropertySheet
 *     ScDisplaySnapinLeafPropertySheet(CNode* pNode, LPARAM lParam)
 *         ScDisplaySnapinPropertySheet
 *             FindPropertySheet
 ************************************************************************/


SC ScDisplaySnapinPropertySheet(IComponent* pComponent,
                                IComponentData* pComponentData,
                                IDataObject* pDataObject,
                                EPropertySheetType type,
                                LPCWSTR pName,
                                LPARAM lUniqueID,
                                CMTNode* pMTNode);
//--------------------------------------------------------------------------

SC ScDisplaySnapinNodePropertySheet(CNode* pNode)
{
    DECLARE_SC(sc, TEXT("ScDisplaySnapinNodePropertySheet"));

    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = ScDisplayScopeNodePropertySheet(pNode->GetMTNode());
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScDisplayScopeNodePropertySheet
 *
 * PURPOSE:  Displays a property sheet for a scope node.
 *
 * PARAMETERS:
 *    CMTNode * pMTNode : The scope node.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
ScDisplayScopeNodePropertySheet(CMTNode *pMTNode)
{
    DECLARE_SC(sc, TEXT("ScDisplayScopeNodePropertySheet"));

    IDataObjectPtr spIDataObject;
    sc = pMTNode->QueryDataObject(CCT_SCOPE, &spIDataObject);
    if(sc)
        return sc;

    CComponentData* pCCD = pMTNode->GetPrimaryComponentData();
    sc = ScCheckPointers(pCCD);
    if(sc)
        return sc;

    LPARAM lUniqueID = CMTNode::ToScopeItem(pMTNode);
	tstring strName = pMTNode->GetDisplayName();

	if (strName.empty())
		strName = _T("");

    USES_CONVERSION;
    sc = ScDisplaySnapinPropertySheet(NULL, pCCD->GetIComponentData(),
                               spIDataObject,
                               epstScopeItem,
                               T2CW (strName.data()),
                               lUniqueID,
                               pMTNode);

    return sc;

}

/*+-------------------------------------------------------------------------*
 *
 * ScDisplayMultiSelPropertySheet
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CNode* pNode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC ScDisplayMultiSelPropertySheet(CNode* pNode)
{
    DECLARE_SC(sc, TEXT("ScDisplayMultiSelPropertySheet"));

    USES_CONVERSION;

    // check inputs
    sc = ScCheckPointers(pNode);
    if(sc)
        return sc;

    sc = ScCheckPointers(pNode->GetViewData(), E_UNEXPECTED);
    if(sc)
        return sc;

    CMultiSelection* pMS = pNode->GetViewData()->GetMultiSelection();
    sc = ScCheckPointers(pMS, E_UNEXPECTED);
    if(sc)
        return sc;

    ASSERT(pMS->IsSingleSnapinSelection());
    if (pMS->IsSingleSnapinSelection() == false)
        return (sc = E_UNEXPECTED);

    IDataObjectPtr spIDataObject = pMS->GetSingleSnapinSelDataObject();
    sc = ScCheckPointers(spIDataObject, E_UNEXPECTED);
    if(sc)
        return sc;

    CComponent* pCC = pMS->GetPrimarySnapinComponent();
    sc = ScCheckPointers(pCC, E_UNEXPECTED);
    if(sc)
        return sc;

    LPARAM lUniqueID = reinterpret_cast<LPARAM>(pMS);

    CStr strName;
    strName.LoadString(GetStringModule(), IDS_PROP_ON_MULTIOBJ);
    LPWSTR pwszDispName = T2W((LPTSTR)(LPCTSTR)strName);

    sc = ScDisplaySnapinPropertySheet(pCC->GetIComponent(), NULL,
                               spIDataObject,
                               epstMultipleItems,
                               pwszDispName,
                               lUniqueID,
                               pNode->GetMTNode());
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScDisplaySnapinLeafPropertySheet
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CNode*  pNode :
 *    LPARAM  lParam :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
ScDisplaySnapinLeafPropertySheet(CNode* pNode, LPARAM lParam)
{
    DECLARE_SC(sc, TEXT("ScDisplaySnapinLeafPropertySheet"));

    ASSERT(!(IS_SPECIAL_COOKIE(lParam)));

    sc = ScCheckPointers(pNode);
    if(sc)
        return sc;

    sc = ScCheckPointers(pNode->GetViewData(), E_UNEXPECTED);
    if(sc)
        return sc;

    ASSERT(lParam != 0 || pNode->GetViewData()->IsVirtualList());

    CComponent* pCC = pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pCC, E_UNEXPECTED);
    if(sc)
        return sc;

    IComponent* pIComponent = pCC->GetIComponent();
    sc = ScCheckPointers(pIComponent, E_UNEXPECTED);
    if(sc)
        return sc;

    // Get the IDataObject for the snap-in's cookie
    IDataObjectPtr spIDataObject;
    sc = pIComponent->QueryDataObject(lParam, CCT_RESULT, &spIDataObject);
    if(sc)
        return sc;

    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));

    if (pNode->GetViewData()->IsVirtualList())
        rdi.nIndex = lParam;
    else
        rdi.lParam = lParam;

    rdi.mask = RDI_STR;

    LPWSTR pName = L"";
    sc = pIComponent->GetDisplayInfo(&rdi);
    if (!sc.IsError() && rdi.str != NULL)
        pName = rdi.str;

    sc = ScDisplaySnapinPropertySheet(pIComponent, NULL,
                               spIDataObject,
                               epstResultItem,
                               pName,
                               0,
                               pNode->GetMTNode());
    return sc;
}

/*+-------------------------------------------------------------------------*
 * ScDisplaySnapinPropertySheet
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
SC ScDisplaySnapinPropertySheet(IComponent* pComponent,
                                IComponentData* pComponentData,
                                IDataObject* pDataObject,
                                EPropertySheetType type,
                                LPCWSTR pName,
                                LPARAM lUniqueID,
                                CMTNode* pMTNode)
{
    DECLARE_SC(sc, TEXT("ScDisplaySnapinPropertySheet"));

    // one of pComponent and pComponentData must be non-null
    if(pComponentData == NULL && pComponent == NULL)
        return (sc = E_INVALIDARG);

    // check other parameters
    sc = ScCheckPointers(pDataObject, pName, pMTNode);
    if(sc)
        return sc;

    IUnknown *pUnknown = (pComponent != NULL) ? (IUnknown *)pComponent : (IUnknown *)pComponentData;

    IPropertySheetProviderPrivatePtr spPropSheetProviderPrivate;

    do
    {
        ASSERT(pDataObject != NULL);
        ASSERT(pUnknown != NULL);

        sc = spPropSheetProviderPrivate.CreateInstance(CLSID_NodeInit, NULL, MMC_CLSCTX_INPROC);
        if(sc)
            break;


        sc = ScCheckPointers(spPropSheetProviderPrivate, E_UNEXPECTED);
        if(sc)
            break;

        // See if the prop page for this is already up
        sc = spPropSheetProviderPrivate->FindPropertySheetEx(lUniqueID, pComponent, pComponentData, pDataObject);
        if (sc == S_OK)
            break;

        // No it is not present. So create a property sheet.
        DWORD dwOptions = (type == epstMultipleItems) ? MMC_PSO_NO_PROPTITLE : 0;
        sc = spPropSheetProviderPrivate->CreatePropertySheet(pName, TRUE, lUniqueID, pDataObject, dwOptions);
        if(sc)
            break;

        // This data is used to get path to property sheet owner for tooltips
        spPropSheetProviderPrivate->SetPropertySheetData(type, CMTNode::ToHandle(pMTNode));

        sc = spPropSheetProviderPrivate->AddPrimaryPages(pUnknown, TRUE, NULL,
                                                  (type == epstScopeItem));

//#ifdef EXTENSIONS_CANNOT_ADD_PAGES_IF_PRIMARY_DOESNT
        // note that only S_OK continues execution, S_FALSE breaks out
        if (!(sc == S_OK) ) // ie if sc != S_OK
            break;
//#endif

        // Enable adding extensions
        if (type == epstMultipleItems)
        {
            IPropertySheetProviderPrivatePtr spPSPPrivate = spPropSheetProviderPrivate;
            sc = spPSPPrivate->AddMultiSelectionExtensionPages(lUniqueID);
        }
        else
        {
            sc = spPropSheetProviderPrivate->AddExtensionPages();
        }

        // any errors from extensions are thrown away.

        CWindow w(CScopeTree::GetScopeTree()->GetMainWindow());
        sc = spPropSheetProviderPrivate->Show((LONG_PTR)w.m_hWnd, 0);

    } while (0);

    // Clean up the 'Created' property sheet if there was an error
    if (spPropSheetProviderPrivate != NULL && sc.IsError())
        spPropSheetProviderPrivate->Show(-1, 0);

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CContextMenu::GetResultItem
 *
 * Returns the CResultItem pointer for the result item represented by the
 * context info.
 *
 * This function is out-of-line to eliminate coupling between oncmenu.h and
 * rsltitem.h.
 *--------------------------------------------------------------------------*/

CResultItem* CContextMenu::GetResultItem () const
{
    return (CResultItem::FromHandle (PContextInfo()->m_resultItemParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\plex.cpp ===
// This was a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation, 1992 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CPlex

CPlex* PASCAL CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
	ASSERT(nMax > 0 && cbElement > 0);
	CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
	if (p == NULL)
		return NULL;

	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
	CPlex* p = this;
	while (p != NULL)
	{
		BYTE* bytes = (BYTE*) p;
		CPlex* pNext = p->pNext;
		delete[] bytes;
		p = pNext;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\oncmenu.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       oncmenu.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//____________________________________________________________________________
//

#ifndef _MMC_ONCMENU_H_
#define _MMC_ONCMENU_H_
#pragma once

class CNode;
class CNodeCallback;
class CConsoleTree;
class CResultItem;

#include <pshpack8.h>   // Sundown
#include "cmenuinfo.h"
#include "menuitem.h"

//############################################################################
//############################################################################
//
// DEADLOCK PREVENTION:
// A thread holding m_CritsecSnapinList may try to take m_CritsecMenuList
// A thread holding m_CritsecMenuList may NOT try to take m_CritsecSnapinList
//
//############################################################################
//############################################################################


#define START_CRITSEC(critsec)                  \
        CSingleLock lock_##critsec( &critsec ); \
        try {                                   \
            lock_##critsec.Lock();

#define END_CRITSEC(critsec)                    \
        } catch ( std::exception e) {                \
            lock_##critsec.Unlock(); }

#define START_CRITSEC_MENU START_CRITSEC(m_CritsecMenuList)
#define END_CRITSEC_MENU END_CRITSEC(m_CritsecMenuList)
#define START_CRITSEC_SNAPIN START_CRITSEC(m_CritsecSnapinList)
#define END_CRITSEC_SNAPIN END_CRITSEC(m_CritsecSnapinList)

#define START_CRITSEC_BOTH                      \
        CSingleLock lock_snapin( &m_CritsecSnapinList ); \
        CSingleLock lock_menu( &m_CritsecMenuList ); \
        try {                                   \
            lock_snapin.Lock();                 \
            lock_menu.Lock();

#define END_CRITSEC_BOTH                        \
        } catch ( std::exception e) {           \
            lock_menu.Unlock();                 \
            lock_snapin.Unlock(); }


/*+-------------------------------------------------------------------------*
 * class CContextMenu.
 *
 *
 * PURPOSE: Holds a context menu structure, which is a tree of menu items.
 *
 *+-------------------------------------------------------------------------*/
class CContextMenu :
    public CTiedObject,
    public IContextMenuCallback,
    public IContextMenuCallback2,
    public CMMCIDispatchImpl<ContextMenu>
{
protected:

    typedef CContextMenu ThisClass;
    // CMMCNewEnumImpl tmplate needs following type to be defined.
    // see template class comments for more info
    typedef void CMyTiedObject;

public:
    CContextMenu();
    ~CContextMenu();

    static ::SC  ScCreateInstance(ContextMenu **ppContextMenu, CContextMenu **ppCContextMenu = NULL);    // creates a new instance of a context menu.
           ::SC  ScInitialize(CNode* pNode, CNodeCallback* pNodeCallback,
                              CScopeTree* pCScopeTree, const CContextMenuInfo& contextInfo); // initializes a context menu
    static ::SC  ScCreateContextMenu( PNODE pNode,  HNODE hNode, PPCONTEXTMENU ppContextMenu,
                                   CNodeCallback *pNodeCallback, CScopeTree *pScopeTree); // creates and returns a ContextMenu interface for the given node.
    static ::SC  ScCreateContextMenuForScopeNode(CNode *pNode,
                                   CNodeCallback *pNodeCallback, CScopeTree *pScopeTree,
                                   PPCONTEXTMENU ppContextMenu, CContextMenu * &pContextMenu);
    static ::SC  ScCreateSelectionContextMenu( HNODE hNodeScope, const CContextMenuInfo *pContextInfo, PPCONTEXTMENU ppContextMenu,
                                               CNodeCallback *pNodeCallback, CScopeTree *pScopeTree);

    // com entry points
    BEGIN_MMC_COM_MAP(ThisClass)
        COM_INTERFACE_ENTRY(IContextMenuCallback) // the IContextMenuProvider and IContextMenu
        COM_INTERFACE_ENTRY(IContextMenuCallback2)
    END_MMC_COM_MAP()

    DECLARE_POLY_AGGREGATABLE(ThisClass)

    // ContextMenu Methods
    STDMETHOD(get_Item)(VARIANT varIndexOrName, PPMENUITEM ppMenuItem);
    STDMETHOD(get_Count)(PLONG pCount);

    // ContextMenu collection methods
    typedef UINT Position;  // just uses the index of the menu item.

    // these enumerator methods only enumerate "real" menu items - not submenu items or separators
    ::SC  ScEnumNext(Position &pos, PDISPATCH & pDispatch);
    ::SC  ScEnumSkip(unsigned long celt, unsigned long& celtSkipped,  Position &pos);
    ::SC  ScEnumReset(Position &pos);

    // used by the collection methods
    typedef ThisClass * PMMCCONTEXTMENU;

    // IExtendContexMenu methods
    ::SC ScAddMenuItems( LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallback, long * pInsertionAllowed); // does nothing.
    ::SC ScCommand     ( long lCommandID, LPDATAOBJECT pDataObject);

    CNodeCallback * GetNodeCallback() {return m_pNodeCallback;}
    HRESULT Display(BOOL b);
    ::SC    ScDisplaySnapinPropertySheet();
    ::SC    ScBuildContextMenu();
    ::SC    ScGetItem(int iItem, CMenuItem** ppMenuItem);  // get the i'th item - easy accessor
    HRESULT CreateContextMenuProvider();
    HRESULT CreateTempVerbSet(bool bForScopeItem);
    HRESULT CreateTempVerbSetForMultiSel(void);


private:
    ::SC ScAddMenuItem(UINT     nResourceID, // contains text and status text separated by '\n'
                       LPCTSTR  szLanguageIndependentName,
                       long lCommandID, long lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU,
                       long fFlags = 0);

    ::SC ScAddInsertionPoint(long lCommandID, long lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU );
    ::SC ScAddSeparator(long lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU);


    ::SC ScAddSubmenu_Task();
    ::SC ScAddSubmenu_CreateNew(BOOL fStaticFolder);
    ::SC ScChangeListViewMode(int nNewMode);   // changes the list view mode to the specified mode.
    ::SC ScGetItem(MenuItemList *pMenuItemList, int &iItem, CMenuItem** ppMenuItem);  // get the i'th item.
    ::SC ScGetItemCount(UINT &count);

private:
    typedef enum _MENU_LEVEL
    {
        MENU_LEVEL_TOP = 0,
        MENU_LEVEL_SUB = 1
    } MENU_LEVEL;

    ::SC ScAddMenuItemsForTreeItem();
    ::SC ScAddMenuItemsForViewMenu(MENU_LEVEL menuLevel);
    ::SC ScAddMenuItemsForVerbSets();
    ::SC ScAddMenuItemsforFavorites();

    ::SC ScAddMenuItemsForLVBackgnd();
    ::SC ScAddMenuItemsForMultiSelect();
    ::SC ScAddMenuItemsForLV();
    ::SC ScAddMenuItemsForOCX();

    HRESULT AddMenuItems();
    static void RemoveTempSelection(CConsoleTree* lConsoleTree);

    CResultItem* GetResultItem() const;

public:
    CContextMenuInfo *PContextInfo() {return &m_ContextInfo;}
    const CContextMenuInfo *PContextInfo() const {return &m_ContextInfo;}

    void    SetStatusBar(CConsoleStatusBar *pStatusBar);
    ::SC    ScAddItem ( CONTEXTMENUITEM* pItem, bool bPassCommandBackToSnapin = false );

private:
    CConsoleStatusBar *     GetStatusBar();

    BOOL IsVerbEnabled(MMC_CONSOLE_VERB verb);

    CNode*                  m_pNode;
    CNodeCallback*          m_pNodeCallback;
    CScopeTree*             m_pCScopeTree;
    CContextMenuInfo        m_ContextInfo;

    IDataObjectPtr          m_spIDataObject;

    IConsoleVerbPtr         m_spVerbSet;
    MMC_CONSOLE_VERB        m_eDefaultVerb;

    long                    m_lCommandIDMax;
    CConsoleStatusBar *     m_pStatusBar;


///////////////////////////////////////////////////////////////////////////////
// IContextMenuCallback interface

public:
    STDMETHOD(AddItem) ( CONTEXTMENUITEM* pItem );
    
///////////////////////////////////////////////////////////////////////////////
// IContextMenuCallback interface

public:
    STDMETHOD(AddItem) ( CONTEXTMENUITEM2* pItem );

///////////////////////////////////////////////////////////////////////////////
// IContextMenuProvider interface

public:
    STDMETHOD(EmptyMenuList) ();
    STDMETHOD(AddThirdPartyExtensionItems) (
                                IDataObject* piDataObject );
    STDMETHOD(AddPrimaryExtensionItems) (
                                IUnknown*    piCallback,
                                IDataObject* piDataObject );
    STDMETHOD(ShowContextMenu) (HWND    hwndParent,
                                LONG    xPos,
                                LONG    yPos,
                                LONG*   plSelected);

	// this isn't part of IContextMenuProvider, but ShowContextMenu calls it
    STDMETHOD(ShowContextMenuEx) (HWND    hwndParent,
                                LONG    xPos,
                                LONG    yPos,
								LPCRECT	prcExclude,
								bool    bAllowDefaultMenuItem,
                                LONG*   plSelected);

// IContextMenuProviderPrivate
    STDMETHOD(AddMultiSelectExtensionItems) (LONG_PTR lMultiSelection );

private:
    CMenuItem* m_pmenuitemRoot;
    SnapinStructList* m_SnapinList;
    MENU_OWNER_ID m_MaxPrimaryOwnerID;
    MENU_OWNER_ID m_MaxThirdPartyOwnerID;
    MENU_OWNER_ID m_CurrentExtensionOwnerID;
    long    m_nNextMenuItemID;
    long    m_fPrimaryInsertionFlags;
    long    m_fThirdPartyInsertionFlags;
    bool    m_fAddingPrimaryExtensionItems;
    bool    m_fAddedThirdPartyExtensions;
    CStr m_strObjectGUID;
    CCriticalSection m_CritsecMenuList;
    CCriticalSection m_CritsecSnapinList;

    STDMETHOD(DoAddMenuItem) (  LPCTSTR lpszName,
                                LPCTSTR lpszStatusBarText,
                                LPCTSTR lpszLanguageIndependentName,
                                LONG    lCommandID,
                                LONG    lInsertionPointID,
                                LONG    fFlags,
                                LONG    fSpecialFlags,
                                MENU_OWNER_ID lOwnerID,
                                CMenuItem** ppMenuItem = NULL,
                                bool    bPassCommandBackToSnapin = false );
    ::SC ScAddSnapinToList_GUID(
                const CLSID& clsid,
                IDataObject* piDataObject,
                MENU_OWNER_ID ownerid );
    ::SC ScAddSnapinToList_IUnknown(
                IUnknown* piUnknown,
                IDataObject* piDataObject,
                MENU_OWNER_ID ownerid );
    ::SC ScAddSnapinToList_IExtendContextMenu(
                IExtendContextMenu*  pIExtendContextMenu,
                IDataObject* piDataObject,
                MENU_OWNER_ID ownerid );
    SnapinStruct* FindSnapin( MENU_OWNER_ID nOwnerID );
public:
    MenuItemList* GetMenuItemList();
    HRESULT       ExecuteMenuItem(CMenuItem *pItem);
private:
    void ReleaseSnapinList();

public:
    HRESULT    BuildContextMenu(WTL::CMenu &menu);
    CMenuItem* FindMenuItem( LONG_PTR nMenuItemID, BOOL fFindSubmenu = FALSE );
    CMenuItem* ReverseFindMenuItem( long nCommandID, MENU_OWNER_ID nOwnerID, CStr &strPath, CStr &strLanguageIndependentPath);
    CMenuItem* FindNthItemInSubmenu( HMENU hmenuParent, UINT iPosition, LPTSTR lpszMenuName);
};

#include <poppack.h>    // Sundown

void OnCustomizeView(CViewData* pViewData);

SC ScDisplaySnapinNodePropertySheet(CNode* pNode);
SC ScDisplaySnapinLeafPropertySheet(CNode* pNode, LPARAM lParam);
SC ScDisplayMultiSelPropertySheet(CNode* pNode);
SC ScDisplayScopeNodePropertySheet(CMTNode *pMTNode);

#endif // _MMC_ONCMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\policy.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       policy.h
//
//  Contents:   Helper class to determine policy for each snapin
//
//  Classes:    CPolicy
//
//  Functions:
//
//  History:    10/07/1998   AnandhaG   Created
//              12/04/1998   AnandhaG   Modified according to spec.
//____________________________________________________________________________


#ifndef _POLICY_H_
#define _POLICY_H_

class CPolicy
{
public:
// Constructor & destructor
    CPolicy() :
        m_bRestrictAuthorMode(FALSE),
        m_bRestrictedToPermittedList(FALSE)
    {
        // Set data above data members to reflect default
        // NT4 configuration. Always allow author mode
        // and allow snapins not in permitted list.
    }

    ~CPolicy()
    {
    }

    SC ScInit();

    bool IsPermittedSnapIn(REFCLSID refSnapInCLSID);
    bool IsPermittedSnapIn(LPCWSTR  pszSnapInCLSID);

// Data members.
private:
    CRegKeyEx       m_rPolicyRootKey;

    bool            m_bRestrictAuthorMode;
    bool            m_bRestrictedToPermittedList;
};

#endif // _POLICY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\power.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      power.cpp
 *
 *  Contents:  Implementation file for CConsolePower
 *
 *  History:   25-Feb-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include <stdafx.h>
#include "power.h"


/*
 * allocate a TLS index for CConsolePower objects
 */
const DWORD CConsolePower::s_dwTlsIndex = TlsAlloc();

const DWORD CConsolePower::s_rgExecStateFlag[CConsolePower::eIndex_Count] =
{
    ES_SYSTEM_REQUIRED,     // eIndex_System
    ES_DISPLAY_REQUIRED,    // eIndex_Display
};

const CConsolePower::ExecutionStateFunc CConsolePower::s_FuncUninitialized =
		(ExecutionStateFunc)(LONG_PTR) -1;

CConsolePower::ExecutionStateFunc CConsolePower::SetThreadExecutionState_ =
		s_FuncUninitialized;


/*+-------------------------------------------------------------------------*
 * ScPrepExecutionStateFlag
 *
 * This function increments or decrements the count for dwTestBit for this
 * object, and for the thread.  On exit dwSTESArg contains the appropriate
 * flag to pass to SetThreadExecutionState for dwTestBit.  That is, if the
 * thread count for dwTestBit is non-zero, dwSTESArg will contain dwTestBit
 * on return; if the thread count is zero, dwSTESArg will not contain
 * dwTestBit.
 *--------------------------------------------------------------------------*/

static SC ScPrepExecutionStateFlag (
    DWORD   dwTestBit,              /* I:single ES_* flag to test           */
    DWORD   dwAdd,                  /* I:flags to add                       */
    DWORD   dwRemove,               /* I:flags to remove                    */
    DWORD * pdwSTESArg,             /* I/O:arg to SetThreadExecutionState   */
    LONG *  pcObjectRequests,       /* I/O:request count for this object    */
    LONG *  pcThreadRequests,       /* I/O:request count for this thread    */
    UINT    cIterations = 1)        /* I:times to add/remove dwTestBit      */
{
    DECLARE_SC (sc, _T("ScPrepExecutionStateFlag"));

    /*
     * validate inputs -- DO NOT clear these output variables, the
     * existing values are modified here
     */
    sc = ScCheckPointers (pdwSTESArg, pcObjectRequests, pcThreadRequests);
    if (sc)
        return (sc);

    /*
     * make sure the bit isn't to be both removed and added
     */
    if ((dwAdd & dwTestBit) && (dwRemove & dwTestBit))
        return (sc = E_INVALIDARG);

    /*
     * We should always have a non-negative number of requests for the bit
     * under test for this object, and at least as many requests for the
     * thread as we do for this object.
     */
    ASSERT (*pcObjectRequests >= 0);
    ASSERT (*pcThreadRequests >= *pcObjectRequests);
    if ((*pcObjectRequests < 0) || (*pcThreadRequests < *pcObjectRequests))
        return (sc = E_UNEXPECTED);

    /*
     * If we're adding the test bit, bump up the request count for this
     * object and this thread.
     */
    if (dwAdd & dwTestBit)
    {
        *pcObjectRequests += cIterations;
        *pcThreadRequests += cIterations;
    }

    /*
     * Otherwise, if we're removing the test bit, bump down the request counts
     * for this object and this thread.
     */
    else if (dwRemove & dwTestBit)
    {
        /*
         * Can't remove the bit under test if we don't have an outstanding
         * request for it on this object.
         */
        if (*pcObjectRequests < cIterations)
            return (sc = E_INVALIDARG);

        *pcObjectRequests -= cIterations;
        *pcThreadRequests -= cIterations;
    }

    /*
     * If the net count for this thread is non-zero, the bit under
     * test needs to be in the argument for SetThreadExecutionState;
     * if not, the bit under test needs to be removed.
     */
    if (*pcThreadRequests != 0)
        *pdwSTESArg |=  dwTestBit;
    else
        *pdwSTESArg &= ~dwTestBit;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::CConsolePower
 *
 * Constructs a CConsolePower object.
 *--------------------------------------------------------------------------*/

CConsolePower::CConsolePower () :
    m_wndPower (this)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CConsolePower);

    /*
     * If any of these fail, s_rgExecStateFlag is out of order.  It would
     * be better to use COMPILETIME_ASSERT here, but using that gives us
     *
     *      error C2051: case expression not constant
     *
     * Bummer.
     */
    ASSERT (s_rgExecStateFlag[eIndex_System]  == ES_SYSTEM_REQUIRED);
    ASSERT (s_rgExecStateFlag[eIndex_Display] == ES_DISPLAY_REQUIRED);
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::~CConsolePower
 *
 * Destroys a CConsolePower object.  If this object holds references to
 * ES_SYSTEM_REQUIRED or ES_DISPLAY_REQUIRED settings, they will be cleared.
 *--------------------------------------------------------------------------*/

CConsolePower::~CConsolePower ()
{
    DECLARE_SC (sc, _T("CConsolePower::~CConsolePower"));

    DEBUG_DECREMENT_INSTANCE_COUNTER(CConsolePower);

    /*
     * clean up outstanding references, if any
     */
    if (!IsBadCodePtr ((FARPROC) SetThreadExecutionState_) &&
		((m_Counts.m_rgCount[eIndex_System]  != 0) ||
         (m_Counts.m_rgCount[eIndex_Display] != 0)))
    {
        try
        {

            /*
             * get the thread counts
             */
            sc = ScCheckPointers (m_spThreadCounts, E_UNEXPECTED);
            if (sc)
                sc.Throw();

            DWORD dwFlags = ES_CONTINUOUS;

            /*
             * clean up each individual count
             */
            for (int i = 0; i < eIndex_Count; i++)
            {
                /*
                 * prevent underflow
                 */
                if (m_Counts.m_rgCount[i] > m_spThreadCounts->m_rgCount[i])
                    (sc = E_UNEXPECTED).Throw();

                sc = ScPrepExecutionStateFlag (s_rgExecStateFlag[i],    // dwTestBit
                                               0,                       // dwAdd
                                               s_rgExecStateFlag[i],    // dwRemove
                                               &dwFlags,
                                               &m_Counts.m_rgCount[i],
                                               &m_spThreadCounts->m_rgCount[i],
                                               m_Counts.m_rgCount[i]);
                if (sc)
                    sc.Throw();
            }

            /*
             * clean up the execution state for this thread
             */
            if (!SetThreadExecutionState_(dwFlags))
            {
                sc.FromLastError();
                sc.Throw();
            }
        }
        catch (SC& scCaught)
        {
            sc = scCaught;
        }
    }
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::FinalConstruct
 *
 * This isn't the typical use of FinalConstruct in ATL objects.  It is
 * typically used for creating aggregated objects, but using it in this
 * way allows us to prevent the creation of CConsolePower objects without
 * throwing an exception from the ctor, which ATL can't handle.
 *--------------------------------------------------------------------------*/

HRESULT CConsolePower::FinalConstruct ()
{
    DECLARE_SC (sc, _T("CConsolePower::FinalConstruct"));

	/*
	 * if this is the first time a CConsolePower has been created, try to
	 * dynaload SetThreadExecutionState (it's not supported on WinNT and
	 * Win95)
	 */
	if (SetThreadExecutionState_ == s_FuncUninitialized)
	{
        SetThreadExecutionState_ =
				(ExecutionStateFunc) GetProcAddress (
											GetModuleHandle (_T("kernel32.dll")),
											"SetThreadExecutionState");
	}

	/*
	 * if SetThreadExecutionState is supported on this platform, do the
	 * other initialization we'll need
	 */
	if (!IsBadCodePtr ((FARPROC) SetThreadExecutionState_))
	{
		/*
		 * if we couldn't get the thread-local CRefCountedTlsExecutionCounts
		 * object for this thread, CConsolePower is useless, so fail creation
		 */
		sc = ScGetThreadCounts (&m_spThreadCounts);
		if (sc)
			return (sc.ToHr());

		sc = ScCheckPointers (m_spThreadCounts, E_UNEXPECTED);
		if (sc)
			return (sc.ToHr());

		/*
		 * create the window to handle WM_POWERBROADCAST
		 */
		sc = m_wndPower.ScCreate ();
		if (sc)
			return (sc.ToHr());
	}

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::ScGetThreadCounts
 *
 * Returns a pointer to the thread-local CRefCountedTlsExecutionCounts object
 * for this thread, allocating one if necessary.
 *
 * NOTE:  The returned pointer has a reference added.  It is the client's
 * responsibility to release the reference.
 *--------------------------------------------------------------------------*/

SC CConsolePower::ScGetThreadCounts (CRefCountedTlsExecutionCounts** ppThreadCounts)
{
    DECLARE_SC (sc, _T("CConsolePower::ScGetThreadCounts"));

	/*
	 * we shouldn't get here if we're on a platform that doesn't support
	 * SetThreadExecutionState
	 */
	ASSERT (!IsBadCodePtr ((FARPROC) SetThreadExecutionState_));
	if (IsBadCodePtr ((FARPROC) SetThreadExecutionState_))
		return (sc = E_UNEXPECTED);

    sc = ScCheckPointers (ppThreadCounts);
    if (sc)
        return (sc);

    /*
     * init output
     */
    (*ppThreadCounts) = NULL;

    /*
     * couldn't allocate a TLS index?  fail
     */
    if (s_dwTlsIndex == TLS_OUT_OF_INDEXES)
        return (sc = E_OUTOFMEMORY);

    /*
     * Get the existing thread counts structure.  If this is the first
     * time through (i.e. the first CConsolePower created on this thread),
     * we won't have a thread counts structure, so we'll allocate one now.
     */
    CTlsExecutionCounts* pTEC = CTlsExecutionCounts::GetThreadInstance(s_dwTlsIndex);

    if (pTEC == NULL)
    {
        /*
         * allocate the struct for this thread
         */
        (*ppThreadCounts) = CRefCountedTlsExecutionCounts::CreateInstance();
        if ((*ppThreadCounts) == NULL)
            return (sc = E_OUTOFMEMORY);

        /*
         * put it in our TLS slot
         */
        sc = (*ppThreadCounts)->ScSetThreadInstance (s_dwTlsIndex);
        if (sc)
            return (sc);
    }
    else
        (*ppThreadCounts) = static_cast<CRefCountedTlsExecutionCounts*>(pTEC);

    /*
     * put a reference on for the caller
     */
    (*ppThreadCounts)->AddRef();

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::SetExecutionState
 *
 * This method wraps the ::SetThreadExecutionState API in a manner that is
 * safe in the presence of multiple COM servers (i.e. snap-ins) that might
 * need to call ::SetThreadExecutionState.
 *
 * The problem is that ::SetThreadExecutionState doesn't maintain reference
 * counts on the flags that it is passed.  For instance:
 *
 *      SetThreadExecutionState (ES_CONTINUOUS | ES_SYSTEM_REQUIRED);
 *      SetThreadExecutionState (ES_CONTINUOUS | ES_SYSTEM_REQUIRED);
 *      SetThreadExecutionState (ES_CONTINUOUS);
 *
 * will result in the ES_SYSTEM_REQUIRED bit being off, even though it was
 * set twice and only cleared once.  This can lead to conflicts between
 * snap-ins, like in this scenario:
 *
 * SnapinA:
 *      SetThreadExecutionState (ES_CONTINUOUS | ES_SYSTEM_REQUIRED);
 *
 * SnapinB:
 *      SetThreadExecutionState (ES_CONTINUOUS | ES_SYSTEM_REQUIRED);
 *      SetThreadExecutionState (ES_CONTINUOUS);
 *
 * (a Long Time passes)
 *
 * SnapinA:
 *      SetThreadExecutionState (ES_CONTINUOUS);
 *
 * Because of the nature of SetThreadExecutionState, during
 * the Long Time, SnapinA thinks the ES_SYSTEM_REQUIRED bit is set, even
 * though SnapinB has turned it off.
 *
 * The CConsolePower object maintains a per-snap-in count of the execution
 * state bits, so they can all happily coexist.
 *--------------------------------------------------------------------------*/

STDMETHODIMP CConsolePower::SetExecutionState (
    DWORD   dwAdd,                      /* I:flags to add                   */
    DWORD   dwRemove)                   /* I:flags to remove                */
{
    DECLARE_SC (sc, _T("CConsolePower::SetExecutionState"));
#ifdef DBG
    /*
     * this object is CoCreated so we can't tell what the snap-in name is
     */
    sc.SetSnapinName (_T("<unknown>"));
#endif

	/*
	 * if SetExecutionState isn't supported on this platform, don't do
	 * anything, but still "succeed"
	 */
	if (IsBadCodePtr ((FARPROC) SetThreadExecutionState_))
		return ((sc = S_FALSE).ToHr());

    const DWORD dwValidFlags = ES_SYSTEM_REQUIRED | ES_DISPLAY_REQUIRED;
    DWORD       dwFlags      = 0;

    /*
     * if either dwAdd or dwRemove contain flags we don't recognize
     * (including ES_CONTINUOUS, which we expect to get in fContinuous)
     * fail
     */
    if (((dwAdd | dwRemove) & ~dwValidFlags) != 0)
        return ((sc = E_INVALIDARG).ToHr());

    /*
     * if we didn't get any flags, fail
     */
    if ((dwAdd == 0) && (dwRemove == 0))
        return ((sc = E_INVALIDARG).ToHr());


    /*
     * make sure we've got our thread counts
     */
    sc = ScCheckPointers (m_spThreadCounts, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    dwFlags = ES_CONTINUOUS;


    /*
     * add/remove each individual flag
     */
    for (int i = 0; i < eIndex_Count; i++)
    {
        sc = ScPrepExecutionStateFlag (s_rgExecStateFlag[i],    // dwTestBit
                                       dwAdd,
                                       dwRemove,
                                       &dwFlags,
                                       &m_Counts.m_rgCount[i],
                                       &m_spThreadCounts->m_rgCount[i]);
        if (sc)
            return (sc.ToHr());
    }

    /*
     * set the execution state for this thread
     */
    if (!SetThreadExecutionState_(dwFlags))
        sc.FromLastError().ToHr();

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::ResetIdleTimer
 *
 * Simple wrapper for SetThreadExecutionState (without ES_CONTINUOUS).
 *--------------------------------------------------------------------------*/

STDMETHODIMP CConsolePower::ResetIdleTimer (DWORD dwFlags)
{
    DECLARE_SC (sc, _T("CConsolePower::ResetIdleTimer"));
#ifdef DBG
    /*
     * this object is CoCreated so we can't tell what the snap-in name is
     */
    sc.SetSnapinName (_T("<unknown>"));
#endif

	/*
	 * if SetExecutionState isn't supported on this platform, don't do
	 * anything, but still "succeed"
	 */
	if (IsBadCodePtr ((FARPROC) SetThreadExecutionState_))
		return ((sc = S_FALSE).ToHr());

    /*
     * Set the execution state for this thread.  SetThreadExecutionState
     * will do all parameter validation.
     */
    if (!SetThreadExecutionState_(dwFlags))
        sc.FromLastError().ToHr();

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::OnPowerBroadcast
 *
 * WM_POWERBROADCAST handler for CConsolePower.
 *--------------------------------------------------------------------------*/

LRESULT CConsolePower::OnPowerBroadcast (WPARAM wParam, LPARAM lParam)
{
    /*
     * PBT_APMQUERYSUSPEND is the only event that the recipient can
     * deny.  If a snap-in denies (by returning BROADCAST_QUERY_DENY),
     * there's no need to continue to fire the event to other snap-ins,
     * so we can break out and return the denial.
     */
    bool fBreakIfDenied = (wParam == PBT_APMQUERYSUSPEND);

    int cConnections = m_vec.GetSize();

    for (int i = 0; i < cConnections; i++)
    {
        CComQIPtr<IConsolePowerSink> spPowerSink = m_vec.GetAt(i);

        if (spPowerSink != NULL)
        {
            LRESULT lResult = TRUE;
            HRESULT hr = spPowerSink->OnPowerBroadcast (wParam, lParam, &lResult);

            /*
             * if the snap-in denied a PBT_APMQUERYSUSPEND, short out here
             */
            if (SUCCEEDED(hr) && fBreakIfDenied && (lResult == BROADCAST_QUERY_DENY))
                return (lResult);
        }
    }

    return (TRUE);
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::CExecutionCounts::CExecutionCounts
 *
 * Constructs a CConsolePower::CExecutionCounts object.
 *--------------------------------------------------------------------------*/

CConsolePower::CExecutionCounts::CExecutionCounts ()
{
    for (int i = 0; i < countof (m_rgCount); i++)
        m_rgCount[i] = 0;
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::CTlsExecutionCounts::CTlsExecutionCounts
 *
 * Constructs a CConsolePower::CTlsExecutionCounts object.
 *--------------------------------------------------------------------------*/

CConsolePower::CTlsExecutionCounts::CTlsExecutionCounts () :
    m_dwTlsIndex (Uninitialized)
{
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::CTlsExecutionCounts::~CTlsExecutionCounts
 *
 * Destroys a CConsolePower::CTlsExecutionCounts object.
 *--------------------------------------------------------------------------*/

CConsolePower::CTlsExecutionCounts::~CTlsExecutionCounts ()
{
    if (m_dwTlsIndex != Uninitialized)
        TlsSetValue (m_dwTlsIndex, NULL);
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::CTlsExecutionCounts::ScSetThreadInstance
 *
 * Accepts a valid TLS index and stores a pointer to this object in the
 * TLS slot identified by dwTlsIndex.
 *--------------------------------------------------------------------------*/

SC CConsolePower::CTlsExecutionCounts::ScSetThreadInstance (DWORD dwTlsIndex)
{
    DECLARE_SC (sc, _T("CConsolePower:CTlsExecutionCounts::ScSetThreadInstance"));

    /*
     * this can only be called once
     */
    ASSERT (m_dwTlsIndex == Uninitialized);
    if (m_dwTlsIndex != Uninitialized)
        return (sc = E_UNEXPECTED);

    /*
     * there shouldn't already be something in this slot
     */
    if (TlsGetValue (dwTlsIndex) != NULL)
        return (sc = E_UNEXPECTED);

    /*
     * save a pointer to ourselves in the TLS slot
     */
    if (!TlsSetValue (dwTlsIndex, this))
        return (sc.FromLastError());

    /*
     * save the TLS index
     */
    m_dwTlsIndex = dwTlsIndex;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::CTlsExecutionCounts::GetThreadInstance
 *
 *
 *--------------------------------------------------------------------------*/

CConsolePower::CTlsExecutionCounts*
CConsolePower::CTlsExecutionCounts::GetThreadInstance (DWORD dwTlsIndex)
{
    return ((CTlsExecutionCounts*) TlsGetValue (dwTlsIndex));
}


/*+-------------------------------------------------------------------------*
 * CConsolePowerWnd::CConsolePowerWnd
 *
 * Constructs a CConsolePowerWnd object.
 *--------------------------------------------------------------------------*/

CConsolePowerWnd::CConsolePowerWnd (CConsolePower* pConsolePower) :
    m_pConsolePower(pConsolePower)
{
}


/*+-------------------------------------------------------------------------*
 * CConsolePowerWnd::~CConsolePowerWnd
 *
 * Destroys a CConsolePowerWnd object.
 *--------------------------------------------------------------------------*/

CConsolePowerWnd::~CConsolePowerWnd ()
{
    /*
     * the Windows window for this class should never outlive the
     * C++ class that wraps it.
     */
    if (IsWindow ())
        DestroyWindow();
}


/*+-------------------------------------------------------------------------*
 * CConsolePowerWnd::ScCreate
 *
 * Creates the window for a CConsolePowerWnd object.  This window will
 * handle WM_POWERBROADCAST.
 *--------------------------------------------------------------------------*/

SC CConsolePowerWnd::ScCreate ()
{
    DECLARE_SC (sc, _T("CConsolePowerWnd::ScCreate"));

    /*
     * create an invisible top-level window (only top-level windows receive
     * WM_POWERBROADCAST).
     */
    RECT rectEmpty = { 0, 0, 0, 0 };

    if (!Create (GetDesktopWindow(), rectEmpty))
        return (sc.FromLastError());

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CConsolePowerWnd::OnPowerBroadcast
 *
 * WM_POWERBROADCAST handler for CConsolePowerWnd.
 *--------------------------------------------------------------------------*/

LRESULT CConsolePowerWnd::OnPowerBroadcast (
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    /*
     * if we aren't connected to a CConsolePower (shouldn't happen),
     * we can't handle the message
     */
    ASSERT (m_pConsolePower != NULL);
    if (m_pConsolePower == NULL)
    {
        bHandled = false;
        return (0);
    }

    return (m_pConsolePower->OnPowerBroadcast (wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\power.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      power.h
 *
 *  Contents:  Interface file for CConsolePower
 *
 *  History:   25-Feb-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#include "refcount.h"


class CConsolePower;


/*+-------------------------------------------------------------------------*
 * CConsolePowerWnd
 *
 * Receives WM_POWERBROADCAST messages on behalf of a CConsolePower object.
 *--------------------------------------------------------------------------*/

class CConsolePowerWnd : public CWindowImpl<CConsolePowerWnd, CWindow, CNullTraits>
{
public:
    CConsolePowerWnd (CConsolePower* pConsolePower);
   ~CConsolePowerWnd ();

    SC ScCreate ();

    BEGIN_MSG_MAP(CConsolePower)
        MESSAGE_HANDLER (WM_POWERBROADCAST, OnPowerBroadcast);
    END_MSG_MAP()

    LRESULT OnPowerBroadcast (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    CConsolePower* const    m_pConsolePower;    // weak reference
};


/*+-------------------------------------------------------------------------*
 * CConsolePower
 *
 * Implements IConsolePower and IConnectionPoint for IID_IConsolePowerSink.
 *--------------------------------------------------------------------------*/

class CConsolePower :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CConsolePower, &CLSID_ConsolePower>,
    public IConnectionPointContainerImpl<CConsolePower>,
    public IConnectionPointImpl<CConsolePower, &IID_IConsolePowerSink>,
    public IConsolePower
{
public:
    enum
    {
        eIndex_System,                      // for ES_SYSTEM_REQUIRED
        eIndex_Display,                     // for ES_DISPLAY_REQUIRED

        // must be last
        eIndex_Count,
    };

    CConsolePower();
   ~CConsolePower();

    DECLARE_NOT_AGGREGATABLE(CConsolePower)

    DECLARE_MMC_OBJECT_REGISTRATION (
		g_szMmcndmgrDll,						// implementing DLL
        CLSID_ConsolePower,                 	// CLSID
        _T("ConsolePower Class"),               // class name
        _T("ConsolePower.ConsolePower.1"),      // ProgID
        _T("ConsolePower.ConsolePower"))        // version-independent ProgID

    BEGIN_COM_MAP(CConsolePower)
        COM_INTERFACE_ENTRY(IConsolePower)
        COM_INTERFACE_ENTRY(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CConsolePower)
        CONNECTION_POINT_ENTRY(IID_IConsolePowerSink)
    END_CONNECTION_POINT_MAP()

    // IConsolePower methods
    STDMETHOD(SetExecutionState) (DWORD dwAdd, DWORD dwRemove);
    STDMETHOD(ResetIdleTimer)    (DWORD dwFlags);

    DECLARE_PROTECT_FINAL_CONSTRUCT()
    HRESULT FinalConstruct();

    LRESULT OnPowerBroadcast (WPARAM wParam, LPARAM lParam);


private:
    class CExecutionCounts
    {
    public:
        CExecutionCounts ();

    public:
        LONG    m_rgCount[CConsolePower::eIndex_Count];
    };

    class CTlsExecutionCounts : public CExecutionCounts
    {
    public:
        CTlsExecutionCounts();
       ~CTlsExecutionCounts();

        static CTlsExecutionCounts* GetThreadInstance (DWORD dwTlsIndex);
        SC ScSetThreadInstance (DWORD dwTlsIndex);

    private:
        enum { Uninitialized = TLS_OUT_OF_INDEXES };
        DWORD   m_dwTlsIndex;
    };

    typedef CRefCountedObject<CTlsExecutionCounts> CRefCountedTlsExecutionCounts;
	typedef EXECUTION_STATE (WINAPI* ExecutionStateFunc)(EXECUTION_STATE);

    static SC ScGetThreadCounts (CRefCountedTlsExecutionCounts** ppThreadCounts);



private:
    CConsolePowerWnd                        m_wndPower;
    CExecutionCounts                        m_Counts;
    CRefCountedTlsExecutionCounts::SmartPtr m_spThreadCounts;

    static const DWORD  			s_dwTlsIndex;
    static const DWORD  			s_rgExecStateFlag[eIndex_Count];
	static const ExecutionStateFunc	s_FuncUninitialized;
	static       ExecutionStateFunc	SetThreadExecutionState_;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\policy.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       policy.cpp
//
//  Contents:   Helper class to determine policy for each snapin
//
//  Classes:    CPolicy
//
//  Functions:
//
//  History:    12/04/1998   AnandhaG   Created
//____________________________________________________________________________

#include "stdafx.h"
#include "policy.h"


/*+-------------------------------------------------------------------------*
 *
 * CPolicy::ScInit
 *
 * PURPOSE: Initializes the policy object from registry.
 *
 * PARAMETERS:
 *    None.
 *
 * RETURNS:
 *    SC - Right now always returns success.
 *
 *+-------------------------------------------------------------------------*/
SC CPolicy::ScInit()
{
	DECLARE_SC (sc, _T("CPolicy::ScInit"));

	// Default NT4 configuration. Always allow author mode
	// and allow snapins not in permitted list.
	m_bRestrictAuthorMode        = FALSE;
	m_bRestrictedToPermittedList = FALSE;

	// Check if the policy key exists. If not return success immediately.
	sc = m_rPolicyRootKey.ScOpen (HKEY_CURRENT_USER, POLICY_KEY, KEY_READ);
	if (sc)
	{
		if (sc = ScFromWin32 (ERROR_FILE_NOT_FOUND))
		{
			TRACE(_T("CPolicy::Policy does not exist\n"));
			sc.Clear();
		}

		return (sc);
	}

	bool bRestrictAuthorMode        = false;
	bool bRestrictedToPermittedList = false;

	// Read the values of RestrictAuthorMode and whether
	// snapins not in the list are permitted or not.
	if (m_rPolicyRootKey.IsValuePresent(g_szRestrictAuthorMode))
	{
		DWORD  dwValue;
		DWORD  dwSize = sizeof(dwValue);
		DWORD  dwType = REG_DWORD;

		sc = m_rPolicyRootKey.ScQueryValue (g_szRestrictAuthorMode, &dwType,
											&dwValue, &dwSize);
		if (sc)
			sc.Clear();
		else
			bRestrictAuthorMode = !!dwValue;
	}

	if (m_rPolicyRootKey.IsValuePresent(g_szRestrictToPermittedList))
	{
		DWORD  dwValue = 0;
		DWORD  dwSize = sizeof(dwValue);
		DWORD  dwType = REG_DWORD;

		sc = m_rPolicyRootKey.ScQueryValue (g_szRestrictToPermittedList, &dwType,
											&dwValue, &dwSize);
		if (sc)
			sc.Clear();
		else
			bRestrictedToPermittedList = !!dwValue;
	}

	m_bRestrictAuthorMode        = bRestrictAuthorMode;
	m_bRestrictedToPermittedList = bRestrictedToPermittedList;
    return sc;
}


/*+-------------------------------------------------------------------------*
 * CPolicy::IsPermittedSnapIn
 *
 * Determines if a snap-in is permitted according to this policy.  The
 * real work happens in
 *
 *      IsPermittedSnapIn (LPCWSTR);
 *--------------------------------------------------------------------------*/

bool CPolicy::IsPermittedSnapIn(REFCLSID refSnapInCLSID)
{
    CCoTaskMemPtr<WCHAR> spwzSnapinClsid;

    /*
     * Get the string representation of the CLSID.  If that fails,
     * permit the snap-in.
     */
    if (FAILED (StringFromCLSID (refSnapInCLSID, &spwzSnapinClsid)))
        return TRUE;

    /*
     * forward to the real worker
     */
    return (IsPermittedSnapIn (spwzSnapinClsid));
}


/*+-------------------------------------------------------------------------*
 * CPolicy::IsPermittedSnapIn
 *
 * Determines if a snap-in is permitted according to this policy.
 *--------------------------------------------------------------------------*/

bool CPolicy::IsPermittedSnapIn(LPCWSTR lpszCLSID)
{
    /*
     * No CLSID?  Allow it.
     */
    if (lpszCLSID == NULL)
        return (TRUE);

    /*
     * No policy key?  Allow everything.
     */
    if (m_rPolicyRootKey == NULL)
        return (true);

    // See if this snapin policy is defined or not.
    bool bRestricted = FALSE;
    bool bSnapinFound = FALSE;

	USES_CONVERSION;
	CRegKeyEx regKeyTemp;
	bSnapinFound = !regKeyTemp.ScOpen (m_rPolicyRootKey, W2CT(lpszCLSID), KEY_READ).IsError();

	if (bSnapinFound && regKeyTemp.IsValuePresent(g_szRestrictRun))
	{
		// Read the value of Restrict_Run.
		DWORD dwValue = 0;
		DWORD dwSize = sizeof(DWORD);
		DWORD dwType = REG_DWORD;

		regKeyTemp.ScQueryValue (g_szRestrictRun, &dwType, &dwValue, &dwSize);
		bRestricted = !!dwValue;
	}

    // At this point we know policies root key exists. So if the
    // snapin key is not found, then we have to see if the administrator
    // allows snapins not in the permitted list (therefore snapin key
    // does not exist).
    if (! bSnapinFound)
    {
        if(m_bRestrictedToPermittedList)
            return false; // because if the snap-in is not on the list, and
                          // restrictions are set, disallow by default
        else
            return true;  // NT4 behavior - no restrictions set, and per-snap-in
                         // entry not found, so allow by default.
    }

    // At this point snapin's Restrict_Run key was read so use it.
    return (!bRestricted);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\propsht.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       propsht.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "menuitem.h"
#include "amcmsgid.h"
#include "regutil.h"
#include "multisel.h"
#include "ndmgrp.h"
#include <process.h>
#include "cicsthkl.h"
#include "util.h"

/*
 * multimon.h is included by stdafx.h, without defining COMPILE_MULTIMON_STUBS
 * first.  We need to include it again here after defining COMPILE_MULTIMON_STUBS
 * so we'll get the stub functions.
 */
#if (_WIN32_WINNT < 0x0500)
#define COMPILE_MULTIMON_STUBS
#include <multimon.h>
#endif


// static variables.
CThreadToSheetMap CPropertySheetProvider::TID_LIST;


UINT __stdcall PropertySheetThreadProc(LPVOID dwParam);
HRESULT PropertySheetProc(AMC::CPropertySheet* pSheet);
DWORD SetPrivilegeAttribute(LPCTSTR PrivilegeName, DWORD NewPrivilegeAttribute, DWORD *OldPrivilegeAttribute);

STDMETHODIMP CPropertySheetProvider::Notify(LPPROPERTYNOTIFYINFO pNotify, LPARAM lParam)
{
    TRACE_METHOD(CPropertySheetProvider, Update);

    if (pNotify == 0)
        return E_INVALIDARG;

    if (!IsWindow (pNotify->hwnd))
        return (E_FAIL);

    // Cast it to the internal type and post the message to the window
    LPPROPERTYNOTIFYINFO pNotifyT =
            reinterpret_cast<LPPROPERTYNOTIFYINFO>(
                    ::GlobalAlloc(GPTR, sizeof(PROPERTYNOTIFYINFO)));

    if (pNotifyT == NULL)
        return E_OUTOFMEMORY;

    *pNotifyT = *pNotify;

    ::PostMessage (pNotifyT->hwnd, MMC_MSG_PROP_SHEET_NOTIFY,
                   reinterpret_cast<WPARAM>(pNotifyT), lParam);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPropertySheet

DEBUG_DECLARE_INSTANCE_COUNTER(CPropertySheet);

namespace AMC
{
    CPropertySheet::CPropertySheet()
        :   m_dwThreadID (GetCurrentThreadId ())
    {
        CommonConstruct();
        DEBUG_INCREMENT_INSTANCE_COUNTER(CPropertySheet);
    }

    CPropertySheet::~CPropertySheet()
    {
        DEBUG_DECREMENT_INSTANCE_COUNTER(CPropertySheet);
    }

    void CPropertySheet::CommonConstruct()
    {
        TRACE_METHOD(CPropertySheet, CommonConstruct);

        ZeroMemory(&m_pstHeader, sizeof(m_pstHeader));
        ZeroMemory(&m_pages, sizeof(m_pages));

        m_hDlg                   = NULL;
        m_msgHook                = NULL;
        m_hDataWindow            = NULL;
        m_cookie                 = 0;
        m_lpMasterNode           = NULL;

        m_pStream                = NULL;
        m_bModalProp             = FALSE;
        m_pThreadLocalDataObject = NULL;
        m_bAddExtension          = FALSE;

        m_pMTNode                = NULL;
    }

    BOOL CPropertySheet::Create(LPCTSTR lpszCaption, bool fPropSheet,
        MMC_COOKIE cookie, LPDATAOBJECT pDataObject, LONG_PTR lpMasterNode, DWORD dwOptions)
    {
        TRACE_METHOD(CPropertySheet, Create);

        // Save the data object and the master tree node pointer
        m_spDataObject = pDataObject;
        m_lpMasterNode = pDataObject ? 0 : cookie;

        DWORD dwStyle = PSH_DEFAULT;

        // is it a property sheet?
        if (fPropSheet)
        {
            if (!(dwOptions & MMC_PSO_NO_PROPTITLE))
                dwStyle |= PSH_PROPTITLE;

            if (dwOptions & MMC_PSO_NOAPPLYNOW)
                dwStyle |= PSH_NOAPPLYNOW;
        }

        // nope, wizard
        else
        {
            dwStyle |= PSH_PROPTITLE;

            if (dwOptions & MMC_PSO_NEWWIZARDTYPE)
                dwStyle |= PSH_WIZARD97;
            else
                dwStyle |= PSH_WIZARD;
        }

        ASSERT(lpszCaption != NULL);

        m_cookie = cookie;
        m_pstHeader.dwSize    = sizeof(m_pstHeader);
        m_pstHeader.dwFlags   = dwStyle & ~PSH_HASHELP; // array contains handles
        m_pstHeader.hInstance = _Module.GetModuleInstance();

        // Assume no bitmaps or palette
        m_pstHeader.hbmWatermark = NULL;
        m_pstHeader.hbmHeader    = NULL;
        m_pstHeader.hplWatermark = NULL;

        // deep copy the title
        m_title = lpszCaption;
        m_pstHeader.pszCaption = m_title;
        m_pstHeader.nPages     = 0;
        m_pstHeader.phpage     = m_pages;

        return TRUE;
    }

    BOOL CPropertySheet::CreateDataWindow(HWND hParent)
    {
        TRACE_METHOD(CPropertySheet, CreateDataWindow);

        HINSTANCE hInstance = _Module.GetModuleInstance();
        WNDCLASS wndClass;

        // See if the class is registered and register a new one if not
        USES_CONVERSION;
        if (!GetClassInfo(hInstance, OLE2T(DATAWINDOW_CLASS_NAME), &wndClass))
        {
            ZeroMemory(&wndClass, sizeof(wndClass));
            wndClass.lpfnWndProc   = DataWndProc;

            // This holds the cookie and the HWND for the sheet
            wndClass.cbWndExtra    = WINDOW_DATA_SIZE;
            wndClass.hInstance     = hInstance;
            wndClass.lpszClassName = OLE2T(DATAWINDOW_CLASS_NAME);

            if (!RegisterClass(&wndClass))
                return FALSE;
        }

        m_hDataWindow = CreateWindowEx (WS_EX_APPWINDOW, OLE2T(DATAWINDOW_CLASS_NAME),
                                        NULL, WS_DLGFRAME | WS_BORDER | WS_DISABLED,
                                        CW_USEDEFAULT, CW_USEDEFAULT, 0, 0, NULL, NULL,
                                        hInstance, NULL);

        return (m_hDataWindow != 0);
    }


    HRESULT CPropertySheet::DoSheet(HWND hParent, int nPage)
    {
        TRACE_METHOD(CPropertySheet, DoSheet);

        // A NULL hParent is allowed for property sheets
        // but not for wizards
        if (hParent != NULL)
        {
            if (!IsWindow(hParent))
                return E_FAIL;
        }
        else
        {
            if (IsWizard())
                return E_INVALIDARG;
        }

        if (nPage < 0 || m_dwTid != 0)
        {
            ASSERT(FALSE); // Object is already running!
            return E_FAIL;
        }

        m_pstHeader.nStartPage = nPage;
        m_pstHeader.hwndParent = hParent;


        HRESULT hr = S_OK;

        if (IsWizard())
        {
            if (m_pstHeader.nPages > 0)
            {
                // Don't create a thread, it's a wizard
                hr = PropertySheetProc (this);
                ASSERT(SUCCEEDED(hr));
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else // modal or modeless prop sheet with data window
        {
            do
            {
                // Create data window for a property sheet
                if (CreateDataWindow(hParent) == FALSE)
                {
                    hr = E_FAIL;
                    break;
                }

                // Setup data in the hidden window
                DataWindowData* pData = GetDataWindowData (m_hDataWindow);
                pData->cookie       = m_cookie;
                pData->lpMasterNode = m_lpMasterNode;
                pData->spDataObject = m_spDataObject;
                pData->spComponent  = m_spComponent;
                pData->spComponentData = m_spComponentData;
                pData->hDlg         = NULL;

                if (m_bModalProp == TRUE)
                {
                    // Don't create a thread, it's a modal property sheet
                    hr = PropertySheetProc (this);
                    ASSERT(SUCCEEDED(hr));
                }
                else
                {
                    // If non-null data object, marshal interface to stream
                    if (m_spDataObject != NULL)
                    {
                        hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject,
                                m_spDataObject, &m_pStream);

                        /*
                         * Bug 318357: once it's marshalled, we're done with
                         * the data object on this thread, release it
                         */
                        m_spDataObject = NULL;

                        if (hr != S_OK)
                        {
                            TRACE(_T("DoSheet(): Marshalling Failed (%0x08x)\n"), hr);
                            break;
                        }

                        ASSERT(m_pStream != NULL);

                        for (int i = 0; i < m_Extenders.size(); i++)
                        {
                            IStream* pstm;

                            hr = CoMarshalInterThreadInterfaceInStream (
                                            IID_IUnknown,
                                            m_Extenders[i],
                                            &pstm);

                            if (FAILED (hr))
                            {
                                TRACE(_T("DoSheet(): Marshalling Failed (%0x08x)\n"), hr);
                                break;
                            }

                            m_ExtendersMarshallStreams.push_back (pstm);
                        }

                        BREAK_ON_FAIL (hr);

                        /*
                         * Clear out the extenders vector to keep the ref
                         * counting correct.  It'll be repopulated when
                         * the interfaces are unmarshalled later.
                         */
                        ASSERT (m_Extenders.size() == m_ExtendersMarshallStreams.size());
                        m_Extenders.clear();
                    }

                    m_pstHeader.hwndParent = m_hDataWindow;

                    HANDLE hThread = reinterpret_cast<HANDLE>(
                            _beginthreadex (NULL, 0, PropertySheetThreadProc,
                                            this, 0, &m_dwTid));
                    CloseHandle (hThread);
                }

            } while(0);

        }

        return hr;
    }

    void CPropertySheet::GetWatermarks (IExtendPropertySheet2* pExtend2)
    {
        ASSERT (IsWizard97());

		/*
		 * make sure our resource management objects are empty
         *
         * Bug 187702: Note that we Detach here rather than calling
         * DeleteObject.  Yes, it leaks, but it's required for app compat.
		 */
		if (!m_bmpWatermark.IsNull())	
			m_bmpWatermark.Detach();

		if (!m_bmpHeader.IsNull())	
			m_bmpHeader.Detach();

		if (!m_Palette.IsNull())	
			m_Palette.Detach();

		BOOL bStretch = FALSE;
		HRESULT hr = pExtend2->GetWatermarks (m_spDataObject,
											  &m_bmpWatermark.m_hBitmap,
											  &m_bmpHeader.m_hBitmap,
											  &m_Palette.m_hPalette,
											  &bStretch);

		/*
		 * If we failed to get watermark info, revert to an old-style
		 * wizard for MMC 1.1 compatibility.
		 */
		if (FAILED (hr))
		{
			ForceOldStyleWizard();
			return;
		}

		if (!m_bmpWatermark.IsNull())	
        {
            m_pstHeader.dwFlags |= (PSH_USEHBMWATERMARK | PSH_WATERMARK);
            m_pstHeader.hbmWatermark = m_bmpWatermark;
        }

		if (!m_bmpHeader.IsNull())	
        {
            m_pstHeader.dwFlags |= (PSH_USEHBMHEADER | PSH_HEADER);
            m_pstHeader.hbmHeader = m_bmpHeader;
        }

		if (!m_Palette.IsNull())	
        {
            m_pstHeader.dwFlags |= PSH_USEHPLWATERMARK;
            m_pstHeader.hplWatermark = m_Palette;
        }

        if (bStretch)
            m_pstHeader.dwFlags |= PSH_STRETCHWATERMARK;
    }

    BOOL CPropertySheet::AddExtensionPages()
    {
        TRACE_METHOD(CPropertySheet, AddExtensionPages);

#ifdef EXTENSIONS_CANNOT_ADD_PAGES_IF_PRIMARY_DOESNT
        if (m_pstHeader.nPages == 0)
        {
            ASSERT(m_pstHeader.nPages != 0);
            return FALSE;
        }
#endif

        POSITION pos;
        int nCount = m_pstHeader.nPages;

        pos = m_PageList.GetHeadPosition();

        if (pos != NULL)
        {
            while(pos && nCount < MAXPROPPAGES)
            {
                m_pages[nCount++] =
                    reinterpret_cast<HPROPSHEETPAGE>(m_PageList.GetNext(pos));
            }

            ASSERT(nCount < MAXPROPPAGES);
            m_pstHeader.nPages = nCount;

            // Empty the list for the extensions
            m_PageList.RemoveAll();

        }

        return TRUE;
    }

    void CPropertySheet::AddNoPropsPage ()
    {
        m_pages[m_pstHeader.nPages++] = m_NoPropsPage.Create();
    }


    LRESULT CPropertySheet::OnCreate(CWPRETSTRUCT* pMsg)
    {
        if (m_hDlg != 0)
            return 0;

        // Assign the hwnd in the object
        // Get the class name of the window to make sure it's the propsheet
        TCHAR name[256];

        if (GetClassName(pMsg->hwnd, name, sizeof(name)/sizeof(TCHAR)))
        {
            ASSERT(m_hDlg == 0);
            if (_tcsncmp(name, _T("#32770"), 6) == 0)
            {
                m_hDlg = pMsg->hwnd;
            }
        }
        return 0;
    }

    static RECT s_rectLastPropertySheetPos;
    static bool s_bLastPropertySheetPosValid = false;

    void SetLastPropertySheetPosition(HWND hWndPropertySheet)
    {
        ::GetWindowRect(hWndPropertySheet, &s_rectLastPropertySheetPos);
    }


    /*+-------------------------------------------------------------------------*
     *
     * SetPropertySheetPosition
     *
     * PURPOSE: The algorithm for positioning a property sheet.   (See bug 8584)
     *  1) The first property sheet in an mmc process is always brought up centered on the MMC application window. If it falls off the screen, it is
     *     displayed at the top-left.
     *  2) MMC stores the initial position of the last property sheet that was brought up, or the final position of the last property sheet that was destroyed.
     *  3) When a new property sheet is brought up, mmc starts by using the rectangle stored in (2) above.
     *  4) If there is already a property sheet from the same MMC instance in this position, MMC staggers the position down and to the right.
     *  5) Step 4 is repeated until a positon is located that does not collide with any other property sheets from the same thread.
     *  6) If the property sheet in this new postion does not completely lie on the screen, it is displayed at the top-left of the desktop.
     *
     * PARAMETERS:
     *    HWND  hWndPropertySheet :
     *
     * RETURNS:
     *    void
     *
     *+-------------------------------------------------------------------------*/
    void SetPropertySheetPosition(HWND hWndPropertySheet)
    {
        // Find the height and width of the property sheet for later use
        RECT rectCurrentPos;
        ::GetWindowRect(hWndPropertySheet, &rectCurrentPos); //get the current position

        int  width  = rectCurrentPos.right  - rectCurrentPos.left;
        int  height = rectCurrentPos.bottom - rectCurrentPos.top;


        // Initialize the position
        if (!s_bLastPropertySheetPosValid)
        {
            s_rectLastPropertySheetPos.top    = 0;
            s_rectLastPropertySheetPos.left   = 0;
            s_rectLastPropertySheetPos.bottom = 0;
            s_rectLastPropertySheetPos.right  = 0;

            CScopeTree * pScopeTree = CScopeTree::GetScopeTree();
            if(pScopeTree) // if pScopeTree == NULL, can still execute gracefully by using zero rect.
            {
                HWND hWndMain = pScopeTree->GetMainWindow();
                RECT rectTemp;
                GetWindowRect(hWndMain, &rectTemp);

                // center the property sheet on the center of the main window
                s_rectLastPropertySheetPos.top    = (rectTemp.top  + rectTemp.bottom)/2 - (height/2);
                s_rectLastPropertySheetPos.left   = (rectTemp.left + rectTemp.right )/2 - (width/2);
                s_rectLastPropertySheetPos.right  = s_rectLastPropertySheetPos.left + width;        // these last two are not strictly needed
                s_rectLastPropertySheetPos.bottom = s_rectLastPropertySheetPos.top  + height;       // but are here for consistency.
            }

            s_bLastPropertySheetPosValid = true;
        }

        RECT rectNewPos = s_rectLastPropertySheetPos; // try this initially

        int    offset = GetSystemMetrics(SM_CYDLGFRAME) + GetSystemMetrics(SM_CYCAPTION); // how much to stagger the windows by

        bool    bPosOK         = true;
        HWND    hWnd = NULL;

        typedef std::set<UINT> t_set;
        t_set s;

        // collect all the window positions into a vector
        while (1)
        {
            // make sure there isn't a property sheet already at this location
            hWnd = ::FindWindowEx(NULL, hWnd, MAKEINTATOM(32770), NULL);

            // No windows found, use the position
            if (hWnd == NULL)
                break;

            // Check if the window belongs to the current process
            DWORD   dwPid;
            ::GetWindowThreadProcessId(hWnd, &dwPid);
            if (dwPid != ::GetCurrentProcessId())
                continue;

            if(hWnd == hWndPropertySheet) // don't check against the same window.
                continue;

            RECT rectPos;
            ::GetWindowRect(hWnd, &rectPos);

            // look only for possible collisions starting from the point and to the right and below it.
            if(rectPos.top >= rectNewPos.top)
            {
                UINT offsetTemp = (rectPos.top - rectNewPos.top) / offset;

                if(rectPos.left != (offsetTemp * offset + rectNewPos.left) )
                    continue;

                if(rectPos.top != (offsetTemp * offset + rectNewPos.top) )
                    continue;

                s.insert(offsetTemp);
            }
        }

        // at this point s contains all the offsets that can collide.
        for(UINT i = 0; /*empty*/ ; i++)
        {
            if(s.find(i) == s.end()) // located the end
                break;
        }

        rectNewPos.left     += i*offset;
        rectNewPos.top      += i*offset;
        rectNewPos.bottom    = rectNewPos.top   + height;
        rectNewPos.right     = rectNewPos.left  + width;

        /*
         * Bug 211145: make sure the new position is within the work area
         */
        HMONITOR hmon = MonitorFromPoint (WTL::CPoint (rectNewPos.left,
                                                       rectNewPos.top),
                                          MONITOR_DEFAULTTONEAREST);
        MONITORINFO mi = { sizeof (mi) };
        WTL::CRect rectWorkArea;

        /*
         * if we could get the info for the monitor containing the window origin,
         * use it's workarea as the bounding rectangle; otherwise get the workarea
         * for the default monitor; if that failed as well, default to 640x480
         */
        if (GetMonitorInfo (hmon, &mi))
            rectWorkArea = mi.rcWork;
        else if (!SystemParametersInfo (SPI_GETWORKAREA, 0, &rectWorkArea, false))
            rectWorkArea.SetRect (0, 0, 639, 479);

        if (rectNewPos.left < rectWorkArea.left)
        {
            rectNewPos.left  = rectWorkArea.left;
            rectNewPos.right = rectNewPos.left + width;
        }

        if (rectNewPos.top < rectWorkArea.top)
        {
            rectNewPos.top = rectWorkArea.top;
            rectNewPos.bottom = rectNewPos.top + height;
        }

        // is the window completely visible?
        POINT ptTopLeft     = {rectNewPos.left,  rectNewPos.top};
        POINT ptBottomRight = {rectNewPos.right, rectNewPos.bottom};

        if(  (MonitorFromPoint(ptTopLeft,     MONITOR_DEFAULTTONULL) == NULL) ||
             (MonitorFromPoint(ptBottomRight, MONITOR_DEFAULTTONULL) == NULL))
        {
            // the property sheet is not completely visible. Move it to the top-left.
            rectNewPos.left   = rectWorkArea.left;
            rectNewPos.top    = rectWorkArea.top;
            rectNewPos.bottom = rectNewPos.top + height;
            rectNewPos.right  = rectNewPos.left + width;
        }

        MoveWindow(hWndPropertySheet, rectNewPos.left, rectNewPos.top, width, height, true /*bRepaint*/);

        // save the position
        s_rectLastPropertySheetPos = rectNewPos;
    }

    LRESULT CPropertySheet::OnInitDialog(CWPRETSTRUCT* pMsg)
    {
        if (m_hDlg != pMsg->hwnd)
            return 1;

        if (!IsWizard())
        {
            SetPropertySheetPosition(m_hDlg);

            ASSERT (IsWindow (m_hDataWindow));

            // Add data dialog hanndle to hidden window
            if (IsWindow (m_hDataWindow))
            {
                DataWindowData* pData = GetDataWindowData (m_hDataWindow);
                pData->hDlg = m_hDlg;

                // Create the marshalled data object pointer from stream
                if (m_pStream != NULL)
                {
                    // Unmarshall the Data object
                    HRESULT hr = ::CoGetInterfaceAndReleaseStream(m_pStream, IID_IDataObject,
                        reinterpret_cast<void**>(&m_pThreadLocalDataObject));

                    ASSERT(hr == S_OK);
                    TRACE(_T("WM_INITDIALOG:  Unmarshalled returned %X\n"), hr);

                    for (int i = 0; i < m_ExtendersMarshallStreams.size(); i++)
                    {
                        IUnknown* pUnk = NULL;

                        hr = CoGetInterfaceAndReleaseStream (
                                        m_ExtendersMarshallStreams[i],
                                        IID_IUnknown,
                                        reinterpret_cast<void**>(&pUnk));

                        ASSERT (hr == S_OK);
                        ASSERT (pUnk != NULL);
                        TRACE(_T("WM_INITDIALOG:  Unmarshalled returned %X\n"), hr);

                        /*
                         * m_Extenders is a collection of smart pointers, which
                         * will AddRef.  We don't need to AddRef an interface
                         * that's returned to us, so Release here to keep the
                         * bookkeeping straight.
                         */
                        m_Extenders.push_back (pUnk);
						if (pUnk)
							pUnk->Release();
                    }

                    ASSERT (m_Extenders.size() == m_ExtendersMarshallStreams.size());
                    m_ExtendersMarshallStreams.clear();
                }
            }

            /*
             * Bug 215593:  If we're running at low resolution we don't want
             * more than two rows of tabs.  If we find that is the case, use
             * a single scrolling row of tabs instead of multiple rows.
             */
            if (GetSystemMetrics (SM_CXSCREEN) < 800)
            {
                WTL::CTabCtrl wndTabCtrl = PropSheet_GetTabControl (m_hDlg);
                ASSERT (wndTabCtrl.m_hWnd != NULL);

                /*
                 * if we have more than two rows, remove the multiline style
                 */
                if (wndTabCtrl.GetRowCount() > 2)
                    wndTabCtrl.ModifyStyle (TCS_MULTILINE, 0);
            }

            // Create tooltip control for the property sheet.
            do
            {
                if (IsWizard())
                    break;

                HWND hWnd = m_PropToolTips.Create(m_hDlg);
                ASSERT(hWnd);

                if (NULL == hWnd)
                    break;

                TOOLINFO ti;

                RECT rc;
                GetWindowRect(m_hDlg, &rc);

                // Set the tooltip for property sheet title.
                // Set the control for a rectangle from (0, - (titlewidth))
                // to (right-end,0)
                ti.cbSize = sizeof(TOOLINFO);
                ti.uFlags = TTF_SUBCLASS;
                ti.hwnd = m_hDlg;

                // This is the id used for the tool tip control for property sheet
                // title. So when we get TTN_NEEDTEXT we can identify if the text
                // is for title or a tab.
                ti.uId = PROPSHEET_TITLE_TOOLTIP_ID;
                ti.rect.left = 0;
                ti.rect.right = rc.right - rc.left;
                ti.rect.top = -GetSystemMetrics(SM_CXSIZE);
                ti.rect.bottom = 0;
                ti.hinst = _Module.GetModuleInstance();
                ti.lpszText = LPSTR_TEXTCALLBACK ;

                m_PropToolTips.AddTool(&ti);
                m_PropToolTips.Activate(TRUE);

                // Now add tooltips for the tab control
                WTL::CTabCtrl wndTabCtrl = PropSheet_GetTabControl (m_hDlg);
                ASSERT (wndTabCtrl.m_hWnd != NULL);

                if (NULL == wndTabCtrl.m_hWnd)
                    break;

                ::ZeroMemory(&ti, sizeof(ti));
                ti.cbSize = sizeof(TOOLINFO);
                ti.uFlags = TTF_SUBCLASS;
                ti.hwnd = wndTabCtrl.m_hWnd;
                ti.uId = (LONG)::GetDlgCtrlID((HWND)wndTabCtrl.m_hWnd);
                ti.hinst = _Module.GetModuleInstance();
                ti.lpszText = LPSTR_TEXTCALLBACK;

                //define the rect area (for each tab) and the tool tip associated withit
                for (int i=0; i<wndTabCtrl.GetItemCount(); i++)
                {
                    // get rect area of each tab
                    wndTabCtrl.GetItemRect(i, &rc);
                    POINT p[2];
                    p[0].x = rc.left;
                    p[0].y = rc.top;
                    p[1].x = rc.right;
                    p[1].y = rc.bottom;

                    // Map the co-ordinates relative to property sheet.
                    MapWindowPoints(wndTabCtrl.m_hWnd, m_hDlg, p, 2);
                    ti.rect.left   = p[0].x;
                    ti.rect.top    = p[0].y;
                    ti.rect.right  = p[1].x;
                    ti.rect.bottom = p[1].y ;

                    m_PropToolTips.AddTool(&ti);
                }

                m_PropToolTips.Activate(TRUE);

            } while (FALSE);

        }

        // Add third party extension
        if (m_bAddExtension)
        {
            //AddExtensionPages();
            m_bAddExtension = FALSE;
        }

        return 0;
    }

    LRESULT CPropertySheet::OnNcDestroy(CWPRETSTRUCT* pMsg)
    {
        if (m_hDlg != pMsg->hwnd)
            return 1;

        SetLastPropertySheetPosition(m_hDlg);

        ASSERT(m_msgHook != NULL);
        UnhookWindowsHookEx(m_msgHook);

        // Clean up the key and the object
        CPropertySheetProvider::TID_LIST.Remove(GetCurrentThreadId());

        if (m_pThreadLocalDataObject != NULL)
            m_pThreadLocalDataObject->Release();

        // Only Property Sheets have Data windows
        if (!IsWizard())
        {
            // Close the data window
            ASSERT(IsWindow(m_hDataWindow));
            SendMessage(m_hDataWindow, WM_CLOSE, 0, 0);
        }

        delete this;
        return 0;
    }

    LRESULT CPropertySheet::OnWMNotify(CWPRETSTRUCT* pMsg)
    {
        LPNMHDR pHdr = (LPNMHDR)pMsg->lParam;

        if (NULL == pHdr)
            return 0;

        switch(pHdr->code)
        {
        case TTN_NEEDTEXT:
            {
                /*
                 * we only want to do our thing if the Ctrl key is
                 * pressed, so bail if it's not
                 */
                if (!(GetKeyState(VK_CONTROL) < 0))
                    break;

                // Make sure our property sheet tooltip sent this message.
                if (pHdr->hwndFrom != ((CWindow)m_PropToolTips).m_hWnd)
                    break;

                LPTOOLTIPTEXT lpttt = (LPTOOLTIPTEXT)pMsg->lParam;
                lpttt->lpszText = NULL;

                // This is the id used for the tool tip control for property sheet
                // title. So check if the text is for title or a tab.
                if (pHdr->idFrom == PROPSHEET_TITLE_TOOLTIP_ID)
                    lpttt->lpszText = (LPTSTR)m_PropToolTips.GetFullPath();
                else
                {
                    // A tab is selected, find out which tab.
                    HWND hTabCtrl = PropSheet_GetTabControl(m_hDlg);
                    if (NULL == hTabCtrl)
                        break;

                    POINT pt;
                    GetCursorPos(&pt);
                    ScreenToClient(hTabCtrl, &pt);

                    TCHITTESTINFO tch;
                    tch.flags = TCHT_ONITEM;
                    tch.pt = pt;
                    int n = TabCtrl_HitTest(hTabCtrl, &tch);

                    if ((-1 == n) || (m_PropToolTips.GetNumPages() <= n) )
                        break;

                    lpttt->lpszText = (LPTSTR)m_PropToolTips.GetSnapinPage(n);
                }
            }
            break;

        default:
            break;
        }

        return 0;
    }

    void CPropertySheet::ForceOldStyleWizard ()
    {
        /*
         * We shouldn't be forcing old-style wizard behavior on a
         * property sheet that's not already a wizard.
         */
        ASSERT (IsWizard());

        m_pstHeader.dwFlags |=  PSH_WIZARD;
        m_pstHeader.dwFlags &= ~PSH_WIZARD97;

        /*
         * The sheet should still be a wizard, but not a Wiz97 wizard.
         */
        ASSERT ( IsWizard());
        ASSERT (!IsWizard97());
    }
}


DEBUG_DECLARE_INSTANCE_COUNTER(CPropertySheetProvider);

CPropertySheetProvider::CPropertySheetProvider()
{
    TRACE_METHOD(CPropertySheetProvider, CPropertySheetProvider);

    m_pSheet = NULL;
    DEBUG_INCREMENT_INSTANCE_COUNTER(CPropertySheetProvider);
}

CPropertySheetProvider::~CPropertySheetProvider()
{
    TRACE_METHOD(CPropertySheetProvider, ~CPropertySheetProvider);

    m_pSheet = NULL;

    DEBUG_DECREMENT_INSTANCE_COUNTER(CPropertySheetProvider);
}

///////////////////////////////////////////////////////////////////////////////
// IPropertySheetProvider
//


BOOL CALLBACK MyEnumThreadWindProc (HWND current, LPARAM lParam)
{  // this enumerates non-child-windows created by a given thread

   if (!IsWindow (current))
      return TRUE;   // this shouldn't happen, but does!!!

   if (!IsWindowVisible (current))  // if they've explicitly hidden a window,
      return TRUE;                  // don't set focus to it.

   // we'll return hwnd in here
   HWND * hwnd = (HWND *)lParam;

   // don't bother returning property sheet dialog window handle
   if (*hwnd == current)
      return TRUE;

   // also, don't return OleMainThreadWndClass window
   TCHAR szCaption[14];
   GetWindowText (current, szCaption, countof(szCaption));
   if (!lstrcmp (szCaption, _T("OLEChannelWnd")))
      return TRUE;

   // anything else will do
   *hwnd = current;
   return FALSE;
}

STDMETHODIMP CPropertySheetProvider::FindPropertySheet(MMC_COOKIE cookie,
                                                       LPCOMPONENT lpComponent,
                                                       LPDATAOBJECT lpDataObject)
{
    return FindPropertySheetEx(cookie, lpComponent, NULL, lpDataObject);
}

STDMETHODIMP
CPropertySheetProvider::FindPropertySheetEx(MMC_COOKIE cookie, LPCOMPONENT lpComponent,
                                   LPCOMPONENTDATA lpComponentData, LPDATAOBJECT lpDataObject)
{
    TRACE_METHOD(CPropertySheetProvider, FindPropertySheet);

    using AMC::CPropertySheet;

    if ((cookie == NULL) && ( (lpComponent == NULL && lpComponentData == NULL) || lpDataObject == NULL))
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    HRESULT hr   = S_FALSE;
    HWND    hWnd = NULL;

    while (1)
    {
        USES_CONVERSION;
        hWnd = FindWindowEx(NULL, hWnd, OLE2T(DATAWINDOW_CLASS_NAME), NULL);

        // No windows found
        if (hWnd == NULL)
        {
            hr = S_FALSE;
            break;
        }

        // Check if the window belongs to the current process
        DWORD   dwPid;
        ::GetWindowThreadProcessId(hWnd, &dwPid);
        if (dwPid != ::GetCurrentProcessId())
            continue;

        // Get the extra bytes and compare the data objects
        ASSERT(GetClassLong(hWnd, GCL_CBWNDEXTRA) == WINDOW_DATA_SIZE);
        ASSERT(IsWindow(hWnd));

        // The original Data object can be NULL if there isn't an IComponent.
        // this occurs with built-in nodes(i.e. nodes owned by the console)
        DataWindowData* pData = GetDataWindowData (hWnd);

        // Ask the snapin of the the two data objects are the same
        // Does this one match?
        if (lpComponent != NULL)
        {
            ASSERT(pData->spDataObject != NULL);
            hr = lpComponent->CompareObjects(lpDataObject, pData->spDataObject);
        }
        else
        {
            // Although the NULL cookie is the static folder, the cookie stored in the data
            // window is the pointer to the master tree node.  This is why it is not null.
            ASSERT(cookie != NULL);

            // Compare the cookies if it's a scope item
            if (pData->cookie == cookie)
                hr = S_OK;
        }

        // bring the property sheet to the foreground
        // note: hDlg can be null if the secondary thread has not finished creating
        //        the property sheet
        if (hr == S_OK)
        {
            if (pData->hDlg != NULL)
            {
                //
                // Found previous instance, restore the
                // window plus its popups
                //

               SetActiveWindow (pData->hDlg);
               SetForegroundWindow (pData->hDlg);

               // grab first one that isn't property sheet dialog
               HWND hwnd = pData->hDlg;
               EnumThreadWindows(::GetWindowThreadProcessId(pData->hDlg, NULL),
                                 MyEnumThreadWindProc, (LPARAM)&hwnd);
               if (hwnd)
               {
                   SetActiveWindow (hwnd);
                   SetForegroundWindow (hwnd);
               }
            }
            break;
        }
    }

    return hr;
}

STDMETHODIMP
CPropertySheetProvider::CreatePropertySheet(
    LPCWSTR title,
    unsigned char bType,
    MMC_COOKIE cookie,
    LPDATAOBJECT pDataObject,
    DWORD dwOptions)
{
    return CreatePropertySheetEx(title, bType, cookie, pDataObject, NULL, dwOptions);
}

STDMETHODIMP CPropertySheetProvider::CreatePropertySheetEx(LPCWSTR title, unsigned char bType, MMC_COOKIE cookie,
                                                           LPDATAOBJECT pDataObject, LONG_PTR lpMasterTreeNode, DWORD dwOptions)
{
    TRACE_METHOD(CPropertySheetProvider, CreatePropertySheet);

    using AMC::CPropertySheet;

    if (!title)
        return E_POINTER;

    // You called CreatePropertySheet more than once.
    // Either release the object or call ::Show(-1, 0)
    // to free the resources
    if (m_pSheet != NULL)
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }

    // Create the actual sheet and the list for page management
    m_pSheet = new CPropertySheet();

    // Add it to the list of sheets and add it to the list
    USES_CONVERSION;
    m_pSheet->Create(OLE2CT(title), bType, cookie, pDataObject, lpMasterTreeNode, dwOptions);

    return S_OK;
}

STDMETHODIMP CPropertySheetProvider::Show(LONG_PTR window, int page)
{
    TRACE_METHOD(CPropertySheetProvider, Show);

    return ShowEx(reinterpret_cast<HWND>(window), page, FALSE);
}

STDMETHODIMP CPropertySheetProvider::ShowEx(HWND hwnd, int page, BOOL bModalPage)
{
    TRACE_METHOD(CPropertySheetProvider, ShowEx);

    HRESULT hr = E_UNEXPECTED;

    if (page < 0)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (m_pSheet == NULL)
    {
        // didn't call Create()
        ASSERT(FALSE);
        goto exit;
    }

    m_pSheet->m_bModalProp = bModalPage;
    hr = m_pSheet->DoSheet(hwnd, page);
    // Note: lifetime management of m_pSheet is not trivial here:
    // 1. upon successfull execution the object deletes itself post WM_NCDESTROY;
    // 2. In case the sheet executes on the main thread, and the error is encountered,
    //    the object is deleted in this function (below)
    // 3. In case sheet is executed on the non-main thread, thread function will
    //    take ownership of object:
    //    3.1. In case of successfull execution - same as #1.
    //    3.2. In case error occurres before spawning the thread - same as #2
    //    3.3. In case error occurres in the thread, thread function deletes the object.
    //
    // Re-design of this should be considered in post-whistler releases.

    if (SUCCEEDED(hr))
    {
        // gets delete after sheet is destroyed
        m_pSheet = NULL;
        return hr;
    }

// The m_pSheet needs to be deleted if hr is != S_OK
exit:
    delete m_pSheet;
    m_pSheet = NULL;

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// IPropertySheetCallback
//

STDMETHODIMP CPropertySheetProvider::AddPage(HPROPSHEETPAGE lpPage)
{
    TRACE_METHOD(CPropertySheetProvider, AddPage);

    if (!lpPage)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    ASSERT(m_pSheet != NULL);
    if (m_pSheet->m_PageList.GetCount() >= MAXPROPPAGES)
        return S_FALSE;

    m_pSheet->m_PageList.AddTail(lpPage);

    // Add the snapin name for this page in
    // the array for tooltips
    m_pSheet->m_PropToolTips.AddSnapinPage();

    return S_OK;
}

STDMETHODIMP CPropertySheetProvider::RemovePage(HPROPSHEETPAGE lpPage)
{
    TRACE_METHOD(CPropertySheetProvider, RemovePage);

    if (!lpPage)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    ASSERT(m_pSheet != NULL);
    if (m_pSheet->m_PageList.IsEmpty())
    {
        TRACE(_T("Page list is empty"));
        return S_OK;
    }

    POSITION pos = m_pSheet->m_PageList.Find(lpPage);

    if (pos == NULL)
        return S_FALSE;

    m_pSheet->m_PageList.RemoveAt(pos);
    return S_OK;
}

UINT __stdcall PropertySheetThreadProc(LPVOID dwParam)
{
    TRACE_FUNCTION(PropertySheetThreadProc);

    HRESULT hr = S_OK;
    using AMC::CPropertySheet;
    CPropertySheet* pSheet = reinterpret_cast<CPropertySheet*>(dwParam);

    ASSERT(pSheet != NULL);
    if ( pSheet == NULL )
        return E_INVALIDARG;

    /*
     * Bug 372188: Allow this thread to inherit the input locale (aka
     * keyboard layout) of the originating thread.
     */

    /* Bug 608076 */
    HKL hklThread = GetKeyboardLayout(pSheet->GetOriginatingThreadID());
    BOOL fUseCicSubstitehKL = FALSE;

    if (SUCCEEDED(CoInitialize(0)))
    {
        //
        // On CUAS/AIMM12 environment, GetKeyboardLayout() could return
        // non-IME hKL but Cicero Keyboard TIP is running, we need to get
        // the substitute hKL of the current language.
        //
        HKL hkl = CicSubstGetDefaultKeyboardLayout((LANGID)(DWORD)HandleToLong(hklThread));
        CoUninitialize();

        if (hkl && (hkl != hklThread))
        {
            fUseCicSubstitehKL = TRUE;
            ActivateKeyboardLayout(hkl, 0);
        }
    }

    if (!fUseCicSubstitehKL)
       ActivateKeyboardLayout (hklThread, 0);

    // do the property sheet
    hr = PropertySheetProc( pSheet );

    if ( FAILED(hr) )
    {
        // the error occured - thread needs to clenup
        delete pSheet;
        return hr;
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     MmcIsolationAwarePropertySheet
//
//  Synopsis:   Gets the isolation aware PropertySheet on fusion
//              aware systems.
//
// Description:	Bug:
//              A non-themed snapin calls calls COMCTL32 v5 ! CreatePropertySheetPageW
//              mmcndmgr calls comctl32v6 ! PropertySheetW, via IsolationAwarePropertySheetW
//              v5 propertysheetpages have no context IsolationAwarePropertySheetW pushs
//              mmcndmgr's context, which gives comctl v6 so, pages with "no" context 
//              (not even the null context) get the activation context of the container. 
//              This is wrong, they should get NULL.
//
//              Cause: (see windows bug # 342553)
//              Before this change, the PropertySheetW wrapper in shfusion1 activated null actually.
//              But activating not NULL is what many scenarios expect (hosted code, but not hosted
//              property sheet/pages), and a number of people hit this, so comctl team changed 
//              IsolationAwarePropertySheetW.
//
//              Fix:
//              There is no win-win here. As a hoster of third party property pages, mmcmdmgr should
//              push null around PropertySheetW. It'd call IsolationAwareLoadLibrary to get the HMODULE
//              to comctl v6, GetProcess, IsolationAwareActivateActCtx to get a delayloaded ActivateActCtx...
//              Basically, hosters (with manifest) of fusion unaware plugins I think cannot call IsolationAwarePropertySheetW
//
//  Arguments:
//              [lpph]   -  See PropertySheet Windows API for details
//
//--------------------------------------------------------------------
typedef int ( WINAPI * PFN_PROPERTY_SHEET)( LPCPROPSHEETHEADER lppph);
int MmcIsolationAwarePropertySheet( LPCPROPSHEETHEADER lpph)
{
	static PFN_PROPERTY_SHEET s_pfn;
	ULONG_PTR ulCookie;
	int i = -1;

	if (s_pfn == NULL)
	{
		HMODULE hmod = LoadLibrary( TEXT("Comctl32.dll") ); // actually IsolationAwareLoadLibrary, via the macros in winbase.inl
		if (hmod == NULL)
			return i;

#ifdef UNICODE
		s_pfn = (PFN_PROPERTY_SHEET) GetProcAddress(hmod, "PropertySheetW");
#else  //UNICODE
		s_pfn = (PFN_PROPERTY_SHEET) GetProcAddress(hmod, "PropertySheetA");
#endif //!UNICODE

		if (s_pfn == NULL)
			return i;
	}

	if (!MmcDownlevelActivateActCtx(NULL, &ulCookie))
		return i;

	__try
	{
		i = s_pfn(lpph);
	}
	__finally
	{
		MmcDownlevelDeactivateActCtx(0, ulCookie);
	}

	return i;
}


/***************************************************************************\
 *
 * METHOD:  PropertySheetProc
 *
 * PURPOSE: Property sheet procedure used both from the main thread, as
 *          well from other threads
 *
 * PARAMETERS:
 *    CPropertySheet* pSheet [in] pointer to the sheet
 *
 * RETURNS:
 *    HRESULT    - result code (NOTE: cannot use SC, since it isn't thread-safe)
 *    NOTE:      if error is returned , caller needs to delete the sheet,
 *               else the sheet will be deleted when the window is closed
 *
\***************************************************************************/
HRESULT PropertySheetProc(AMC::CPropertySheet* pSheet)
{
    // parameter check
    if ( pSheet == NULL )
        return E_INVALIDARG;

    using AMC::CPropertySheet;
    HWND hwnd = NULL;
    int nReturn = -1;

    BOOL bIsWizard = (pSheet->IsWizard() || pSheet->m_bModalProp == TRUE);
    DWORD tid = GetCurrentThreadId();
    pSheet->m_dwTid = tid;

    // if there aren't any pages, add the No Props page
    if (pSheet->m_pstHeader.nPages == 0)
        pSheet->AddNoPropsPage();

    if (pSheet->m_pstHeader.nPages == 0)
    {
        TRACE(_T("PropertySheetProc(): No pages for the property sheet\n"));
        return E_FAIL;
    }

    // Hook the WndProc to get the message
    pSheet->m_msgHook = SetWindowsHookEx(WH_CALLWNDPROCRET, MessageProc,
                                GetModuleHandle(NULL), tid);


    if (pSheet->m_msgHook == NULL)
    {
        TRACE(_T("PropertySheetProc(): Unable to create hook\n"), GetLastError());
        return E_FAIL;
    }
    else
    {
        if (!bIsWizard)
        {
            HRESULT hr = ::CoInitialize(NULL);
            if ( FAILED(hr) )
                return hr;
        }

        CPropertySheetProvider::TID_LIST.Add(tid, pSheet);
        nReturn = MmcIsolationAwarePropertySheet(&pSheet->m_pstHeader);

        if (!bIsWizard)
            ::CoUninitialize();
    }

    // Reboot the system if the propsheet wants it.
    if (nReturn == ID_PSREBOOTSYSTEM || nReturn == ID_PSRESTARTWINDOWS)
    {
            DWORD OldState, Status;
            DWORD dwErrorSave;

            SetLastError(0);        // Be really safe about last error value!

            // detect if we are running on Win95 and skip security
            DWORD dwVer = GetVersion();
            if (!((dwVer & 0x80000000) && LOBYTE(LOWORD(dwVer)) == 4))
            {
                SetPrivilegeAttribute(SE_SHUTDOWN_NAME,
                                               SE_PRIVILEGE_ENABLED,
                                               &OldState);
            }
            dwErrorSave = GetLastError();       // ERROR_NOT_ALL_ASSIGNED sometimes

            // the SHTDN_REASON_MINOR_MMC flag was added in .NET Server and is ignored on all previous versions.
            if (dwErrorSave != NO_ERROR || !ExitWindowsEx(EWX_REBOOT, SHTDN_REASON_MAJOR_OTHER | SHTDN_REASON_MINOR_MMC)) 
            {
                CStr strText;
                strText.LoadString(GetStringModule(), IDS_NO_PERMISSION_SHUTDOWN);
                MessageBox(NULL, strText, NULL, MB_ICONSTOP);
            }
    }

    // return the value from the Win32 PropertySheet call
    return (nReturn == IDOK) ? S_OK : S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
// Hidden Data Window
//

LRESULT CALLBACK DataWndProc(HWND hWnd, UINT nMsg, WPARAM  wParam, LPARAM  lParam)
{
    switch (nMsg)
    {
        case WM_CREATE:
            // this structure is initialized by the creator of the data window
            SetWindowLongPtr (hWnd, WINDOW_DATA_PTR_SLOT,
                              reinterpret_cast<LONG_PTR>(new DataWindowData));
            _Module.Lock();  // Lock the dll so that it does not get unloaded when 
                             // property sheet is up (507338).
            break;

        case WM_DESTROY:
            delete GetDataWindowData (hWnd);
            _Module.Unlock(); // See above Lock for comments.
            break;
    }

    return DefWindowProc(hWnd, nMsg, wParam, lParam);
}

///////////////////////////////////////////////////////////////////////////////
// Callback procedures
//


LRESULT CALLBACK MessageProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    using AMC::CPropertySheet;
    CPropertySheet* pSheet = NULL;

    BOOL b = CPropertySheetProvider::TID_LIST.Find(GetCurrentThreadId(), pSheet);

    if (!b)
    {
        ASSERT(FALSE);
        return 0;
    }

    // WM_NCDESTROY will delete pSheet, so make a copy of the hook
    ASSERT (pSheet            != NULL);
    ASSERT (pSheet->m_msgHook != NULL);
    HHOOK hHook = pSheet->m_msgHook;

	if (nCode == HC_ACTION)
	{
		CWPRETSTRUCT* pMsg = reinterpret_cast<CWPRETSTRUCT*>(lParam);

		switch (pMsg->message)
		{
			case WM_CREATE:
				pSheet->OnCreate(pMsg);
				break;
	
			case WM_INITDIALOG:
				pSheet->OnInitDialog(pMsg);
				break;
	
			case WM_NCDESTROY:
				pSheet->OnNcDestroy(pMsg);
				break;
	
			case WM_NOTIFY:
				pSheet->OnWMNotify(pMsg);
				break;
	
			default:
				break;
		}
	}

	return CallNextHookEx(hHook, nCode, wParam, lParam);
}

STDMETHODIMP CPropertySheetProvider::AddPrimaryPages(LPUNKNOWN lpUnknown,
                                      BOOL bCreateHandle, HWND hNotifyWindow, BOOL bScopePane)
{
    // The primary pages are added first before the sheet is created
    // Use the internal list to collect the pages, then empty it for the
    // extensions

    // NULL IComponent means the owner of the provider has added pages
    // without implementing IExtendPropertySheet


    LPPROPERTYNOTIFYINFO pNotify = NULL;
    HRESULT hr = S_OK;

    if (lpUnknown != NULL)
    {
        ASSERT(m_pSheet != NULL);

        if(bScopePane)
        {
            IComponentDataPtr spComponentData = lpUnknown;
            m_pSheet->SetComponentData(spComponentData);
        }
        else
        {
            IComponentPtr spComponent = lpUnknown;
            m_pSheet->SetComponent(spComponent);
        }

        // Bug 149211:  Allow callers to pass a NULL IDataObject* to CreatePropertySheet
        // ASSERT(m_pSheet->m_spDataObject != NULL);

        IExtendPropertySheetPtr  spExtend  = lpUnknown;
        IExtendPropertySheet2Ptr spExtend2 = lpUnknown;

        // determine which pointer to use
        IExtendPropertySheet* pExtend;

        if (spExtend2 != NULL)
            pExtend = spExtend2;
        else
            pExtend = spExtend;

        if (pExtend == NULL)
            return E_NOINTERFACE;

        /*
         * Bug 282932: make sure this property sheet extension
         * stays alive for the life of the property sheet
         */
        m_pSheet->m_Extenders.push_back (pExtend);

        hr = pExtend->QueryPagesFor(m_pSheet->m_spDataObject);
        if (hr != S_OK)
            return hr;

        // Create the notify object
        if (bCreateHandle == TRUE)
        {
            pNotify = reinterpret_cast<LPPROPERTYNOTIFYINFO>(
                            ::GlobalAlloc(GPTR, sizeof(PROPERTYNOTIFYINFO)));
			if (!pNotify)
				return E_OUTOFMEMORY;

            pNotify->pComponentData = NULL;
            pNotify->pComponent     = NULL;
            pNotify->fScopePane     = bScopePane;

            /*
             * Bug 190060:  Ignore the window passed in.  We always want to
             * notify the main frame window because that's the only window
             * that knows how to process MMC_MSG_PROP_SHEET_NOTIFY.
             */
//          pNotify->hwnd = hNotifyWindow;
            pNotify->hwnd = CScopeTree::GetScopeTree()->GetMainWindow();

            // The component data and component are not ref counted.
            // This is OK because the snap-in has to exist.
            // Because the snapin and it's in another thread
            // and I would have to marshall the pointers.
            if (bScopePane == TRUE)
            {
                IComponentDataPtr spCompData = lpUnknown;
                pNotify->pComponentData = spCompData;
            }
            else
            {
                IComponentPtr spComp = lpUnknown;
                pNotify->pComponent = spComp;
            }
        }

        /*
         * if it's a new-style wizard, get the watermark info
         */
        if (m_pSheet->IsWizard97())
        {
            /*
             * we get the watermark info with IExtendPropertySheet2
             */
            if (spExtend2 != NULL)
            {
				/*
				 * this may force an old-style wizard
				 */
				m_pSheet->GetWatermarks (spExtend2);
            }

            /*
             * If the snap-in doesn't support IExtendPropertySheet2,
             * we'll give him an old-style wizard.  This is
             * broken, but it maintains compatibility with 1.1
             * snap-ins (e.g. SMS) that counted on not getting a Wizard97-
             * style wizard, even though they asked for one with
             * MMC_PSO_NEWWIZARDTYPE.
             */
            else
                m_pSheet->ForceOldStyleWizard();
        }

        if (! m_pSheet->IsWizard())
        {
            // If m_pSheet->m_pMTNode is null then we get the mtnode
            // from CNodeInitObject. But this is root node of snapin
            // So add ellipses to full path.
            BOOL bAddEllipses = FALSE;
            if (NULL == m_pSheet->m_pMTNode)
            {
                // Looks like the snapin used property sheet provider. So get the
                // root master node of the snapin.
                CNodeInitObject* pNodeInitObj = dynamic_cast<CNodeInitObject*>(this);
                m_pSheet->m_pMTNode = pNodeInitObj ? pNodeInitObj->GetMTNode() : NULL;

                // We need to add ellipses
                bAddEllipses = TRUE;
            }

            if (m_pSheet->m_pMTNode)
            {
                LPOLESTR lpszPath = NULL;

                CScopeTree::GetScopeTree()->GetPathString(NULL,
                                                          CMTNode::ToHandle(m_pSheet->m_pMTNode),
                                                          &lpszPath);

                USES_CONVERSION;
                m_pSheet->m_PropToolTips.SetFullPath(OLE2T(lpszPath), bAddEllipses);
                ::CoTaskMemFree((LPVOID)lpszPath);
            }

            // Now let us get the primary snapin name.
            LPDATAOBJECT lpDataObject = (m_pSheet->m_spDataObject) ?
                                                m_pSheet->m_spDataObject :
                                                m_pSheet->m_pThreadLocalDataObject;

            // Get the snapin name that is going to add pages.
            // This is stored in temp member of CPropertySheetToolTips
            // so that IPropertySheetCallback::AddPage knows which snapin
            // is adding pages.

            CLSID clsidSnapin;
            SC sc = ExtractSnapInCLSID(lpDataObject, &clsidSnapin);
            if (sc)
            {
                sc.TraceAndClear();
            }
            else
            {
                tstring strName;
                if ( GetSnapinNameFromCLSID(clsidSnapin, strName))
                    m_pSheet->m_PropToolTips.SetThisSnapin(strName.data());
            }
        }

        hr = pExtend->CreatePropertyPages(
            dynamic_cast<LPPROPERTYSHEETCALLBACK>(this),
            reinterpret_cast<LONG_PTR>(pNotify), // deleted in Nodemgr
            m_pSheet->m_spDataObject);
    }

	/*
	 * Bug 28193:  If we're called with a NULL IUnknown, we also want to
	 * force old-style wizards.
	 */
	else if (m_pSheet->IsWizard97())
		m_pSheet->ForceOldStyleWizard();

    // Build the property sheet structure from the list of pages
    if (hr == S_OK)
    {
        POSITION pos;
        int nCount = 0;

        pos = m_pSheet->m_PageList.GetHeadPosition();

        {
            while(pos)
            {
                m_pSheet->m_pages[nCount] =
                    reinterpret_cast<HPROPSHEETPAGE>(m_pSheet->m_PageList.GetNext(pos));
                nCount++;
            }

            ASSERT(nCount < MAXPROPPAGES);
            m_pSheet->m_pstHeader.nPages = nCount;

            // must be page 0 for wizards
            if (m_pSheet->IsWizard())
                m_pSheet->m_pstHeader.nStartPage = 0;

            // Empty the list for the extensions
            m_pSheet->m_PageList.RemoveAll();

            return S_OK;  // All done
        }
    }

// Reached here because of error or the snap-in decided not to add any pages
    if (FAILED(hr) && pNotify != NULL)
        ::GlobalFree(pNotify);

    return hr;
}

STDMETHODIMP CPropertySheetProvider::AddExtensionPages()
{
    DECLARE_SC(sc, TEXT("CPropertySheetProvider::AddExtensionPages"));

    if (m_pSheet == NULL)
        return E_UNEXPECTED;

    // Note: extension are not added until the WM_INITDIALOG of the sheet
    // This insures that the primaries pages are created the original size
    // and will make the extension pages conform
    if (m_pSheet->m_PageList.GetCount() != 0)
        return E_UNEXPECTED;

    // Make sure I have one of the two data objects(main or marshalled)
    ASSERT ((m_pSheet->m_spDataObject == NULL) != (m_pSheet->m_pThreadLocalDataObject == NULL));
    if ((m_pSheet->m_spDataObject == NULL) == (m_pSheet->m_pThreadLocalDataObject == NULL))
        return E_UNEXPECTED;

    LPDATAOBJECT lpDataObject = (m_pSheet->m_spDataObject) ?
                                        m_pSheet->m_spDataObject :
                                        m_pSheet->m_pThreadLocalDataObject;

    CExtensionsIterator it;
    sc = it.ScInitialize(lpDataObject, g_szPropertySheet);
    if (sc)
    {
        return S_FALSE;
    }

    IExtendPropertySheetPtr spPropertyExtension;

    LPPROPERTYSHEETCALLBACK pCallBack = dynamic_cast<LPPROPERTYSHEETCALLBACK>(this);
    ASSERT(pCallBack != NULL);

    // CoCreate each snap-in and have it add a sheet
    for ( ;!it.IsEnd(); it.Advance())
    {
        sc = spPropertyExtension.CreateInstance(it.GetCLSID(), NULL, MMC_CLSCTX_INPROC);

        if (!sc.IsError())
        {
            // Get the snapin name that is going to add pages.
            // This is stored in temp member of CPropertySheetToolTips
            // so that IPropertySheetCallback::AddPage knows which snapin
            // is adding pages.
			WTL::CString strName;
			// Fix for bug #469922(9/20/2001):	DynamicExtensions broken in MMC20
			// Snapin structures are only avail on static extensions - 
			// get the name from reg for DynExtensions

			if (!it.IsDynamic())
			{
				if (!it.GetSnapIn()->ScGetSnapInName(strName).IsError())
					m_pSheet->m_PropToolTips.SetThisSnapin(strName);
			}
			else
			{
				if(!ScGetSnapinNameFromRegistry(it.GetCLSID(),strName).IsError())
					m_pSheet->m_PropToolTips.SetThisSnapin(strName);
			}

            spPropertyExtension->CreatePropertyPages(pCallBack, NULL, lpDataObject);

            /*
             * Bug 282932: make sure this property sheet extension
             * stays alive for the life of the property sheet
             */
            m_pSheet->m_Extenders.push_back (spPropertyExtension);
        }
        else
        {
#if 0 //#ifdef DBG
            USES_CONVERSION;
            wchar_t buf[64];
            StringFromGUID2 (spSnapIn->GetSnapInCLSID(), buf, countof(buf));
            TRACE(_T("CLSID %s does not implement IID_IExtendPropertySheet\n"), W2T(buf));
#endif
        }

    }


    m_pSheet->AddExtensionPages();
    m_pSheet->m_bAddExtension = TRUE;

    return S_OK;
}


STDMETHODIMP
CPropertySheetProvider::AddMultiSelectionExtensionPages(LONG_PTR lMultiSelection)
{
    if (m_pSheet == NULL)
        return E_UNEXPECTED;

    if (lMultiSelection == 0)
        return E_INVALIDARG;

    CMultiSelection* pMS = reinterpret_cast<CMultiSelection*>(lMultiSelection);
    ASSERT(pMS != NULL);

    // Note: extension are not added until the WM_INITDIALOG of the sheet
    // This insures that the primaries pages are created the original size
    // and will make the extension pages conform
    if (m_pSheet->m_PageList.GetCount() != 0)
        return E_UNEXPECTED;

    // Make sure I have one of the two data objects(main or marshalled)
    ASSERT ((m_pSheet->m_spDataObject == NULL) != (m_pSheet->m_pThreadLocalDataObject == NULL));
    if ((m_pSheet->m_spDataObject == NULL) == (m_pSheet->m_pThreadLocalDataObject == NULL))
        return E_UNEXPECTED;

    do // not a loop
    {
        CList<CLSID, CLSID&> snapinClsidList;
        HRESULT hr = pMS->GetExtensionSnapins(g_szPropertySheet, snapinClsidList);
        BREAK_ON_FAIL(hr);

        POSITION pos = snapinClsidList.GetHeadPosition();
        if (pos == NULL)
            break;

        IDataObjectPtr spDataObject;
        hr = pMS->GetMultiSelDataObject(&spDataObject);
        ASSERT(SUCCEEDED(hr));
        BREAK_ON_FAIL(hr);

        BOOL fProblem = FALSE;
        IExtendPropertySheetPtr spPropertyExtension;
        LPPROPERTYSHEETCALLBACK pCallBack = dynamic_cast<LPPROPERTYSHEETCALLBACK>(this);
        ASSERT(pCallBack != NULL);

        while (pos)
        {
           CLSID clsid = snapinClsidList.GetNext(pos);

            // CoCreate each snap-in and have it add a sheet
            //
            hr = spPropertyExtension.CreateInstance(clsid, NULL,
                                                    MMC_CLSCTX_INPROC);
            CHECK_HRESULT(hr);
            if (FAILED(hr))
            {
#ifdef DBG
                wchar_t buf[64];
                buf[0] = NULL;

                StringFromCLSID(clsid, (LPOLESTR*)&buf);
                TRACE(_T("CLSID %s does not implement IID_IExtendPropertySheet\n"), &buf);
#endif

                fProblem = TRUE;    // Continue even on error.
                continue;
            }

            spPropertyExtension->CreatePropertyPages(pCallBack, NULL, spDataObject);
        }

        if (fProblem == TRUE)
            hr = S_FALSE;

    } while (0);

    m_pSheet->AddExtensionPages();
    m_pSheet->m_bAddExtension = TRUE;

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     SetPropertySheetData
//
//  Synopsis:   Data pertaining to property sheet
//
//  Arguments:  [nPropertySheetType] - EPropertySheetType enum (scope item, result item...)
//              [hMTNode] - The master node that owns the property sheet for scope item
//                          or that owns list view item of property sheet.
//
//--------------------------------------------------------------------
STDMETHODIMP CPropertySheetProvider::SetPropertySheetData(INT nPropSheetType, HMTNODE hMTNode)
{
    m_pSheet->m_PropToolTips.SetPropSheetType((EPropertySheetType)nPropSheetType);

    if (hMTNode)
    {
        m_pSheet->m_pMTNode = CMTNode::FromHandle(hMTNode);
    }

    return S_OK;
}


// Copied from security.c in shell\shelldll
/*++

Routine Description:

    This routine sets the security attributes for a given privilege.
Arguments:

    PrivilegeName - Name of the privilege we are manipulating.
    NewPrivilegeAttribute - The new attribute value to use.
    OldPrivilegeAttribute - Pointer to receive the old privilege value. OPTIONAL

Return value:
    NO_ERROR or WIN32 error.

--*/

DWORD SetPrivilegeAttribute(LPCTSTR PrivilegeName, DWORD NewPrivilegeAttribute, DWORD *OldPrivilegeAttribute)
{
    LUID             PrivilegeValue;
    BOOL             Result;
    TOKEN_PRIVILEGES TokenPrivileges, OldTokenPrivileges;
    DWORD            ReturnLength;
    HANDLE           TokenHandle;

    //
    // First, find out the LUID Value of the privilege
    //

    if(!LookupPrivilegeValue(NULL, PrivilegeName, &PrivilegeValue)) {
        return GetLastError();
    }

    //
    // Get the token handle
    //
    if (!OpenProcessToken (
             GetCurrentProcess(),
             TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
             &TokenHandle
             )) {
        return GetLastError();
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = PrivilegeValue;
    TokenPrivileges.Privileges[0].Attributes = NewPrivilegeAttribute;

    ReturnLength = sizeof(TOKEN_PRIVILEGES);
    if (!AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &TokenPrivileges,
                sizeof(OldTokenPrivileges),
                &OldTokenPrivileges,
                &ReturnLength
                )) {
        CloseHandle(TokenHandle);
        return GetLastError();
    }
    else {
        if (OldPrivilegeAttribute != NULL) {
            *OldPrivilegeAttribute = OldTokenPrivileges.Privileges[0].Attributes;
        }
        CloseHandle(TokenHandle);
        return NO_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\propsht.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       propsht.h
//
//--------------------------------------------------------------------------


// Declaration for callback functions
LRESULT CALLBACK MessageProc(int nCode, WPARAM wParam, LPARAM lParam);

// Declaration for data window wnd Proc
LRESULT CALLBACK DataWndProc(HWND hWnd, UINT nMsg, WPARAM  wParam, LPARAM  lParam);

// Forward declarations
class CNodeInitObject;
class CPropertySheetProvider;

// Type definitions
typedef CList<HANDLE, HANDLE> PAGE_LIST;

#include "tstring.h"

enum EPropertySheetType
{
    epstScopeItem = 0,
    epstResultItem = 1,
    epstMultipleItems = 2,
};

///////////////////////////////////////////////////////////////////////////////
// CThreadData - Base class for thread based objects
//

namespace AMC
{
    class CThreadData
    {
        public:
            CThreadData() {m_dwTid = 0;};

        public:
            UINT m_dwTid;
    };
}


class CNoPropsPropertyPage : public WTL::CPropertyPageImpl<CNoPropsPropertyPage>
{
    typedef WTL::CPropertyPageImpl<CNoPropsPropertyPage> BaseClass;

public:
    CNoPropsPropertyPage() {}
    ~CNoPropsPropertyPage() {}

public:
    enum { IDD = IDD_NOPROPS_PROPPAGE };
    BEGIN_MSG_MAP(CSnapinAboutPage)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP()
};


//+-------------------------------------------------------------------
//
//  Class:      CPropertySheetToolTips
//
//  Purpose:    This class has stores tooltip data for
//              the property sheets. This includes fullpath
//              from the console root to property sheet owner
//              node, owner name and an array of snapin name
//              indexed by property page tab number.
//
//  History:    06-18-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CPropertySheetToolTips : public WTL::CToolTipCtrl
{
    // This is the id used for the tool tip control for property sheet
    // title. So when we get TTN_NEEDTEXT we can identify if the text
    // is for title or a tab.
    #define PROPSHEET_TITLE_TOOLTIP_ID            1234

private:
    tstring m_strThisSnapinName; // This is a temp member variable that has
                                 // snapin that is currently adding pages
                                 // This is used while constructing below
                                 // array of pages.
    std::vector<tstring> m_strSnapins; // Property page (tab) owner snapins array

    tstring m_strFullPath;
    tstring m_strItemName;
    EPropertySheetType m_PropSheetType;

public:
    CPropertySheetToolTips()
    {
    }

    CPropertySheetToolTips(const CPropertySheetToolTips& sp)
    {
        m_strThisSnapinName = sp.m_strThisSnapinName;
        m_strSnapins = sp.m_strSnapins;
        m_strFullPath = sp.m_strFullPath;
    }

    CPropertySheetToolTips& operator=(const CPropertySheetToolTips& sp)
    {
        if (this != &sp)
        {
            m_strThisSnapinName = sp.m_strThisSnapinName;
            m_strSnapins = sp.m_strSnapins;
            m_strFullPath = sp.m_strFullPath;
        }
        return (*this);
    }

    void SetThisSnapin(LPCTSTR szName)
    {
        m_strThisSnapinName = szName;
    }

    LPCTSTR GetThisSnapin()
    {
        return m_strThisSnapinName.data();
    }

    void AddSnapinPage()
    {
        m_strSnapins.push_back(m_strThisSnapinName);
    }


    LPCTSTR GetSnapinPage(int nIndex)
    {
        return m_strSnapins[nIndex].data();
    }

    INT GetNumPages()
    {
        return m_strSnapins.size();
    }

    LPCTSTR GetFullPath()
    {
        return m_strFullPath.data();
    }

    void SetFullPath(LPTSTR szName, BOOL bAddEllipses = FALSE)
    {
        m_strFullPath = szName;

        if (bAddEllipses)
            m_strFullPath += _T("...");
    }

    void SetItemName(LPTSTR szName)
    {
        m_strItemName = szName;
    }

    LPCTSTR GetItemName()
    {
        return m_strItemName.data();
    }

    void SetPropSheetType(EPropertySheetType propSheetType)
    {
        m_PropSheetType = propSheetType;
    }

    EPropertySheetType GetPropSheetType()
    {
        return m_PropSheetType;
    }

};


///////////////////////////////////////////////////////////////////////////////
// CPropertySheet - Basic property sheet class
//

namespace AMC
{
    class CPropertySheet : public AMC::CThreadData
    {
        friend class CPropertySheetProvider;

    // Constructor/Destructor
    public:
        CPropertySheet();
        virtual ~CPropertySheet();

    private:
        /*
         * copy construction and assignment aren't supported;
         * insure the compiler doesn't generate defaults
         */
        CPropertySheet (const CPropertySheet& other);
        CPropertySheet& operator= (const CPropertySheet& other);

    // Interface
    public:
        void CommonConstruct();
        BOOL Create(LPCTSTR lpszCaption, bool fPropSheet, MMC_COOKIE cookie, LPDATAOBJECT pDataObject,
            LONG_PTR lpMasterTreeNode, DWORD dwOptions);

        HRESULT DoSheet(HWND hParent, int nPage);  // create property sheet/pages and go modeless
        BOOL AddExtensionPages();
        void AddNoPropsPage();
        BOOL CreateDataWindow(HWND hParent);    // create the hidden data window
        bool IsWizard()   const { return (m_pstHeader.dwFlags & (PSH_WIZARD97 | PSH_WIZARD)); }
        bool IsWizard97() const { return (m_pstHeader.dwFlags &  PSH_WIZARD97); }
        void GetWatermarks (IExtendPropertySheet2* pExtend2);

        DWORD GetOriginatingThreadID () const
        {
            return (m_dwThreadID);
        }

        void ForceOldStyleWizard ();

        // Attributes
    public:
        PROPSHEETHEADER m_pstHeader;    //
        PAGE_LIST       m_PageList;     // page list for property sheet
        MMC_COOKIE      m_cookie;
        LONG_PTR        m_lpMasterNode; // master tree pointer
        LPSTREAM        m_pStream;              // Stream for marshalled pointer
        LPDATAOBJECT    m_pThreadLocalDataObject; // Marshalled data object pointer

        CMTNode*        m_pMTNode;       // MTNode of property sheet owner
        const DWORD     m_dwThreadID;   // ID of thread that created property sheet

        /*
         * Bug 187702: Use CXxxHandle instead of CXxx so the resources
         * will *not* be cleaned up on destruction.  Yes, this may leak if
         * the if the snap-in doesn't manage the object lifetime (which it
         * shouldn't have to do because these are OUT parameters for
         * IExtendPropertySheet2::GetWatermarks), but it's required for app
         * compat.
         */
		WTL::CBitmapHandle	m_bmpWatermark;
		WTL::CBitmapHandle	m_bmpHeader;
		WTL::CPaletteHandle	m_Palette;


    public:
        void                SetDataObject(   IDataObject    *pDataObject)   {m_spDataObject    = pDataObject;}
        void                SetComponent(    IComponent     *pComponent)    {m_spComponent     = pComponent;}
        void                SetComponentData(IComponentData *pComponentData){m_spComponentData = pComponentData;}

        IDataObject*        GetDataObject()    { return m_spDataObject.GetInterfacePtr();}
        IComponent *        GetComponent()     { return m_spComponent.GetInterfacePtr();}
        IComponentData *    GetComponentData() { return m_spComponentData.GetInterfacePtr();}

    private:
        IDataObjectPtr      m_spDataObject;
        IComponentDataPtr   m_spComponentData;
        IComponentPtr       m_spComponent;


        // components that extend this prop sheet
        std::vector<IUnknownPtr> m_Extenders;

        // streams containing exterders' marshalled interfaces (if required)
        std::vector<IStream*>    m_ExtendersMarshallStreams;

// Message handlers
    public:
    LRESULT OnCreate(CWPRETSTRUCT* pMsg);
    LRESULT OnInitDialog(CWPRETSTRUCT* pMsg);
    LRESULT OnNcDestroy(CWPRETSTRUCT* pMsg);
    LRESULT OnWMNotify(CWPRETSTRUCT* pMsg);

    public:
        HWND    m_hDlg;         // property sheet hwnd
        HHOOK   m_msgHook;      // hook handle for page, only valid through WM_INITDIALOG
        HWND    m_hDataWindow;  // hidden data window
        BOOL    m_bModalProp;   // TRUE if the property sheet should be modal
        BOOL    m_bAddExtension;// TRUE if we need to add extension pages

    private:
        HPROPSHEETPAGE          m_pages[MAXPROPPAGES];
        CStr                    m_title;
        CNoPropsPropertyPage    m_NoPropsPage;

    public:
        // Tooltip data
        CPropertySheetToolTips        m_PropToolTips;
    };
}

///////////////////////////////////////////////////////////////////////////////
// CThreadToSheetMap - Maps thread IDs to CPropertySheetObjects.
//
class CThreadToSheetMap
{
public:
    typedef DWORD                   KEY;
    typedef AMC::CPropertySheet *   VALUE;
    typedef std::map<KEY, VALUE>    CMap;

    CThreadToSheetMap(){};
    ~CThreadToSheetMap(){};

public:
    void Add(KEY id, VALUE pObject)
    {
        CSingleLock lock(&m_critSection, TRUE);
        m_map[id] = pObject;
    }

    void Remove(KEY id)
    {
        CSingleLock lock(&m_critSection, TRUE);
        m_map.erase(id);
    }

    BOOL Find(KEY id, VALUE& pObject)
    {
        CSingleLock lock(&m_critSection, TRUE);

        std::map<KEY, VALUE>::iterator it = m_map.find(id);
        if(it == m_map.end())
            return false;

        pObject = it->second;
        return true;
    }

public:
    CCriticalSection    m_critSection;

private:
    CMap m_map;
};


///////////////////////////////////////////////////////////////////////////////
// CPropertySheetProvider - The implementation for the IPropertySheetProvider
//                            interface.

class CPropertySheetProvider :
    public IPropertySheetProviderPrivate,
    public IPropertySheetCallback,
    public IPropertySheetNotify

{
    friend class AMCPropertySheet;

public:
    CPropertySheetProvider();
    ~CPropertySheetProvider();

// IPropertySheetProviderPrivate
public:
    STDMETHOD(CreatePropertySheet)(LPCWSTR title, unsigned char bType, MMC_COOKIE cookie,
              LPDATAOBJECT pDataObject, DWORD dwOptions);
    STDMETHOD(CreatePropertySheetEx)(LPCWSTR title, unsigned char bType, MMC_COOKIE cookie,
        LPDATAOBJECT pDataObject, LONG_PTR lpMasterTreeNode, DWORD dwOptions);
    STDMETHOD(Show)(LONG_PTR window, int page);
    STDMETHOD(ShowEx)(HWND hwnd, int page, BOOL bModalPage);
    STDMETHOD(FindPropertySheet)(MMC_COOKIE cookie, LPCOMPONENT lpComponent, LPDATAOBJECT lpDataObject);
    STDMETHOD(AddPrimaryPages)(LPUNKNOWN lpUnknown, BOOL bCreateHandle, HWND hNotifyWindow, BOOL bScopePane);
    STDMETHOD(AddExtensionPages)();
    STDMETHOD(AddMultiSelectionExtensionPages)(LONG_PTR lMultiSelection);
    STDMETHOD(FindPropertySheetEx)(MMC_COOKIE cookie, LPCOMPONENT lpComponent,
                                   LPCOMPONENTDATA lpComponentData, LPDATAOBJECT lpDataObject);
    STDMETHOD(SetPropertySheetData)(INT nPropSheetType, HMTNODE hMTNode);


// IPropertySheetCallback
public:
    STDMETHOD(AddPage)(HPROPSHEETPAGE page);
    STDMETHOD(RemovePage)(HPROPSHEETPAGE page);

// IPropertySheetNotify
public:
   STDMETHOD(Notify)(LPPROPERTYNOTIFYINFO pNotify, LPARAM lParam);

// Objects in common with all instances of IPropertySheetProvider(s)
    static CThreadToSheetMap TID_LIST;

public:
    AMC::CPropertySheet*    m_pSheet;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\ptrlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ptrlist.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

  
#define ASSERT_VALID(ptr) /*ptr*/


MMC::CPtrList::CPtrList(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

void MMC::CPtrList::RemoveAll()
{
	ASSERT_VALID(this);

	// destroy elements


	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

MMC::CPtrList::~CPtrList()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
/*
 * Implementation note: CNode's are stored in CPlex blocks and
 *  chained together. Free blocks are maintained in a singly linked list
 *  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
 *  Used blocks are maintained in a doubly linked list using both 'pNext'
 *  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
 *   as the head/tail.
 *
 * We never free a CPlex block unless the List is destroyed or RemoveAll()
 *  is used - so the total number of CPlex blocks may grow large depending
 *  on the maximum past size of the list.
 */

MMC::CPtrList::CNode*
MMC::CPtrList::NewNode(MMC::CPtrList::CNode* pPrev, MMC::CPtrList::CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	MMC::CPtrList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow


	ZeroMemory(&pNode->data, sizeof(void*));  // zero fill

	return pNode;
}

void MMC::CPtrList::FreeNode(MMC::CPtrList::CNode* pNode)
{

	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow
}

/////////////////////////////////////////////////////////////////////////////

POSITION MMC::CPtrList::AddHead(void* newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

POSITION MMC::CPtrList::AddTail(void* newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

void MMC::CPtrList::AddHead(CPtrList* pNewList)
{
	ASSERT_VALID(this);

	ASSERT(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

void MMC::CPtrList::AddTail(CPtrList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

void* MMC::CPtrList::RemoveHead()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!
	ASSERT(_IsValidAddress(m_pNodeHead, sizeof(CNode)));

	CNode* pOldNode = m_pNodeHead;
	void* returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

void* MMC::CPtrList::RemoveTail()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
	ASSERT(_IsValidAddress(m_pNodeTail, sizeof(CNode)));

	CNode* pOldNode = m_pNodeTail;
	void* returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

POSITION MMC::CPtrList::InsertBefore(POSITION position, void* newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		ASSERT(_IsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeHead);
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

POSITION MMC::CPtrList::InsertAfter(POSITION position, void* newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	ASSERT(_IsValidAddress(pOldNode, sizeof(CNode)));
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		ASSERT(_IsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeTail);
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

void MMC::CPtrList::RemoveAt(POSITION position)
{
	ASSERT_VALID(this);

	CNode* pOldNode = (CNode*) position;
	ASSERT(_IsValidAddress(pOldNode, sizeof(CNode)));

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		ASSERT(_IsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		ASSERT(_IsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}


/////////////////////////////////////////////////////////////////////////////
// slow operations

POSITION MMC::CPtrList::FindIndex(int nIndex) const
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nCount)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

POSITION MMC::CPtrList::Find(void* searchValue, POSITION startAfter) const
{
	ASSERT_VALID(this);

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (pNode->data == searchValue)
			return (POSITION) pNode;
	return NULL;
}

#ifdef _DBG
void MMC::CPtrList::AssertValid() const
{
	if (m_nCount == 0)
	{
		// empty list
		ASSERT(m_pNodeHead == NULL);
		ASSERT(m_pNodeTail == NULL);
	}
	else
	{
		// non-empty list
		ASSERT(_IsValidAddress(m_pNodeHead, sizeof(CNode)));
		ASSERT(_IsValidAddress(m_pNodeTail, sizeof(CNode)));
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\regkeyex.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       regkeyex.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"


//____________________________________________________________________________
//
//  Member:     CRegKeyEx::ScCreate
//
//  Synopsis:   Same meaning as for RegCreateKeyEx API.
//
//  Arguments:  [hKeyAncestor] -- IN
//              [lpszKeyName] -- IN
//              [security] -- IN
//              [pdwDisposition] -- OUT
//              [dwOption] -- IN
//              [pSecurityAttributes] -- OUT
//
//  Returns:    SC
//
//  History:    5/24/1996   RaviR   Created
//____________________________________________________________________________
//

SC CRegKeyEx::ScCreate (
	HKEY					hKeyParent,
	LPCTSTR					lpszKeyName,
	LPTSTR					lpszClass,
	DWORD					dwOptions,
	REGSAM					samDesired,
	LPSECURITY_ATTRIBUTES	lpSecAttr,
	LPDWORD					lpdwDisposition)
{
	DECLARE_SC (sc, _T("CRegKeyEx::ScCreate"));

    LONG error = Create (hKeyParent, lpszKeyName, lpszClass, dwOptions,
						 samDesired, lpSecAttr, lpdwDisposition);

	return (sc = ScFromWin32(error));
}

//____________________________________________________________________________
//
//  Member:     CRegKeyEx::ScOpen
//
//  Synopsis:   Same meaning as RegOpenKeyEx
//
//  Arguments:  [hKeyAncestor] -- IN
//              [lpszKeyName] -- IN
//              [security] -- IN
//
//  Returns:    SC
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

SC CRegKeyEx::ScOpen (
    HKEY        hKeyAncestor,
    LPCTSTR     lpszKeyName,
    REGSAM      security)
{
	/*
	 * Open will frequently return ERROR_FILE_NOT_FOUND, which we
	 * don't want to be inundated with.  Don't assign to a tracing SC.
	 */
	return (ScFromWin32 (Open(hKeyAncestor, lpszKeyName, security)));
}


//____________________________________________________________________________
//
//  Member:     IsValuePresent
//
//  Arguments:  [lpszValueName] -- IN
//
//  Returns:    BOOL.
//
//  History:    3/21/1997   RaviR   Created
//____________________________________________________________________________
//

BOOL CRegKeyEx::IsValuePresent(LPCTSTR lpszValueName)
{
    DWORD cbData = 0;
    LONG error = ::RegQueryValueEx (m_hKey, lpszValueName, 0, NULL,
                                    NULL, &cbData);

    return (error == ERROR_SUCCESS);
}


//____________________________________________________________________________
//
//  Member:     CRegKeyEx::ScQueryValue
//
//  Synopsis:   Same meaning as for RegQueryValueEx API.
//
//  Arguments:  [lpszValueName] -- IN
//              [pType] -- IN
//              [pData] -- IN
//              [pLen] -- IN
//
//  Returns:    SC
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

SC CRegKeyEx::ScQueryValue (
    LPCTSTR lpszValueName,
    LPDWORD pType,
    PVOID   pData,
    LPDWORD pLen)
{
    ASSERT(pLen != NULL);
    ASSERT(m_hKey != NULL);

    LONG error = ::RegQueryValueEx (m_hKey, lpszValueName, 0, pType,
                                                  (LPBYTE)pData, pLen);

    // Do not trace the error as it is legal for ScQueryValue to fail.
	return (ScFromWin32 (error));
}


//____________________________________________________________________________
//
//  Member:     CRegKeyEx::ScEnumKey
//
//  Synopsis:   Same meaning as for RegEnumKeyEx API.
//
//  Arguments:  [iSubkey] -- IN
//              [lpszName] -- OUT place to store the name
//              [dwLen] -- IN
//              [lpszLastModified] -- IN
//
//  Returns:    SC
//
//  History:    5/22/1996   RaviR   Created
//
//____________________________________________________________________________

SC CRegKeyEx::ScEnumKey (
    DWORD       iSubkey,
    LPTSTR      lpszName,
    LPDWORD     lpcchName,
    PFILETIME   lpftLastModified)
{
	DECLARE_SC (sc, _T("CRegKeyEx::ScEnumKey"));

	/*
	 * validate input
	 */
	sc = ScCheckPointers (lpszName, lpcchName);
	if (sc)
		return (sc);

	if (*lpcchName == 0)
		return (sc = E_UNEXPECTED);

	/*
	 * make sure the key is open
	 */
	if (m_hKey == NULL)
		return (sc = E_UNEXPECTED);

    LONG error = ::RegEnumKeyEx (m_hKey, iSubkey, lpszName, lpcchName,
                                 NULL, NULL, NULL, lpftLastModified);

	/*
	 * RegEnumKeyEx will frequently return ERROR_NO_MORE_ITEMS, which we
	 * don't want to be inundated with.  Don't assign to a tracing SC.
	 */
	return (ScFromWin32 (error));
}

//____________________________________________________________________________
//
//  Member:     CRegKeyEx::ScEnumValue
//
//  Synopsis:   Same meaning as for RegEnumValue API.
//
//  Arguments:  [iValue] -- IN
//              [lpszValue] -- OUT
//              [lpcchValue] -- OUT
//              [lpdwType] -- OUT
//              [lpbData] -- OUT
//              [lpcbData] -- OUT
//
//  Returns:    SC
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

SC CRegKeyEx::ScEnumValue (
    DWORD   iValue,
    LPTSTR  lpszValue,
    LPDWORD lpcchValue,
    LPDWORD lpdwType,
    LPBYTE  lpbData,
    LPDWORD lpcbData)
{
	DECLARE_SC (sc, _T("CRegKeyEx::ScEnumValue"));

	/*
	 * validate input
	 */
	sc = ScCheckPointers (lpszValue, lpcchValue);
	if (sc)
		return (sc);

    if ((lpcbData == NULL) && (lpbData != NULL))
		return (sc = E_INVALIDARG);

	/*
	 * make sure the key is open
	 */
	if (m_hKey == NULL)
		return (sc = E_UNEXPECTED);

    LONG error = ::RegEnumValue (m_hKey, iValue, lpszValue, lpcchValue,
                                 NULL, lpdwType, lpbData, lpcbData);

	/*
	 * RegEnumValue will frequently return ERROR_NO_MORE_ITEMS, which we
	 * don't want to be inundated with.  Don't assign to a tracing SC.
	 */
	return (ScFromWin32 (error));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\regkeyex.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       regkeyex.h
//
//--------------------------------------------------------------------------

#pragma once

#include "shlwapip.h"	// for SHLoadRegUIString

/*
    regkeyex.h

    This class extends the ATL CRegKey class to make a replacement for
    the AMC::CRegKey class

    Much of this code is taken from the AMC::CRegKey class by RaviR
*/

class CRegKeyEx : public MMC_ATL::CRegKey
{
public:
	SC ScCreate (
		HKEY					hKeyParent,
		LPCTSTR					lpszKeyName,
		LPTSTR					lpszClass       = REG_NONE,
		DWORD					dwOptions       = REG_OPTION_NON_VOLATILE,
		REGSAM					samDesired      = KEY_ALL_ACCESS,
		LPSECURITY_ATTRIBUTES	lpSecAttr       = NULL,
		LPDWORD					lpdwDisposition = NULL);

	SC ScOpen(
			HKEY        hKey,
			LPCTSTR     lpszKeyName,
			REGSAM      security = KEY_ALL_ACCESS);

	BOOL IsValuePresent (LPCTSTR lpszValueName);

	SC ScQueryValue (LPCTSTR lpszValueName, LPDWORD pType,
					 PVOID pData, LPDWORD pLen);

	SC ScEnumKey (DWORD iSubkey, LPTSTR lpszName, LPDWORD lpcchName,
				  PFILETIME lpftLastModified = NULL);

	SC ScEnumValue (DWORD iValue, LPTSTR lpszValue, LPDWORD lpcchValue,
					LPDWORD lpdwType = NULL, LPBYTE lpbData = NULL,
					LPDWORD lpcbData = NULL);

#include "regkeyex.inl"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\regkeyex.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      regkeyex.inl
 *
 *  Contents:  Inline files for CRegKeyEx class
 *
 *  History:   7-Apr-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/


/*+-------------------------------------------------------------------------*
 * CRegKeyEx::ScQueryString
 *
 * Loads a string from the given value name.
 *
 * The template type StringType can be any string class that supports
 * MFC's CString interface (i.e. MFC's CString, WTL::CString, or MMC's
 * CStr).
 *--------------------------------------------------------------------------*/

template<class StringType>
SC ScQueryString (
	LPCTSTR		pszValueName,		/* I:name of value to read				*/
	StringType&	strData,			/* O:contents of the value				*/
	DWORD*		pdwType /*=NULL*/)	/* O:REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ*/
{
	DECLARE_SC (sc, _T("CRegKeyEx::ScQueryString"));
		
	/*
	 * clear out existing contents
	 */
	strData.Empty ();

	/*
	 * find out how much space we need to load the string
	 */
    DWORD dwType   = REG_SZ;
    DWORD cbBuffer = 0;

	sc = ScQueryValue (pszValueName, &dwType, NULL, &cbBuffer);
	if (sc)
		return (sc);

	/*
	 * if we're not loading a string type, return an error
	 */
	if (pdwType != NULL)
		*pdwType = dwType;

	if ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ) && (dwType != REG_MULTI_SZ))
		return (sc = ScFromWin32 (ERROR_INVALID_DATATYPE));

	/*
	 * allocate a buffer for the string
	 */
	DWORD	cchBuffer = cbBuffer / sizeof (TCHAR);
	LPTSTR	pBuffer   = strData.GetBuffer (cchBuffer);
	if (pBuffer == NULL)
		return (sc = E_OUTOFMEMORY);

	/*
	 * load the string from the registry
	 */
	sc = ScQueryValue (pszValueName, &dwType, pBuffer, &cbBuffer);
	strData.ReleaseBuffer (cchBuffer);
	if (sc)
		return (sc);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CRegKeyEx::ScLoadRegUIString
 *
 * Wrapper around SHLoadRegUIString, which is used to support MUI.
 *
 * SHLoadRegUIString will read a string of the form
 *
 *		@[path\]<dllname>,-<strId>
 *
 * The string with id <strId> is loaded from <dllname>.  If no explicit
 * path is provided then the DLL will be chosen according to pluggable UI
 * specifications, if possible.
 *
 * If the registry string is not of the special form described here,
 * SHLoadRegUIString will return the string intact.
 *
 * The template type StringType can be any string class that supports
 * MFC's CString interface (i.e. MFC's CString, WTL::CString, or MMC's
 * CStr).
 *--------------------------------------------------------------------------*/

template<class StringType>
SC ScLoadRegUIString (
	LPCTSTR		pszValueName,			/* I:name of value to read			*/
	StringType&	strData)				/* O:logical contents of the value	*/
{
	DECLARE_SC (sc, _T("CRegKeyEx::ScLoadRegUIString"));
		
	/*
	 * clear out existing contents
	 */
	strData.Empty ();

	const int	cbGrow   = 256;
	int			cbBuffer = 0;

	do
	{
		/*
		 * allocate a larger buffer for the string
		 */
		cbBuffer += cbGrow;
		LPTSTR pBuffer = strData.GetBuffer (cbBuffer);
		if (pBuffer == NULL)
			return (sc = E_OUTOFMEMORY);

		/*
		 * load the string from the registry
         * Most of the snapins do not have MUI string so we do not want to trace
         * this error as the caller takes care of error condition and reads registry
         * directly.
		 */
		SC scNoTrace = SHLoadRegUIString (m_hKey, pszValueName, pBuffer, cbBuffer);
		strData.ReleaseBuffer();
		if (scNoTrace)
			return scNoTrace;

		/*
		 * If we filled up the buffer, we'll pessimistically assume that
		 * there's more data available.  We'll loop around, grow the buffer,
		 * and try again.
		 */
	} while (strData.GetLength() == cbBuffer-1);

	/*
	 * free up extra space
	 */
	strData.FreeExtra();

	return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\regutil.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       regutil.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/21/1997   RaviR   Created
//____________________________________________________________________________
//



#include "stdafx.h"

#include "regutil.h"
#include "..\inc\strings.h"
#include "policy.h"

TCHAR g_szNodeTypesKey[] = TEXT("Software\\Microsoft\\MMC\\NodeTypes\\");

CExtensionsIterator::CExtensionsIterator() :
 m_pExtSI(NULL),
 m_ppExtUsed(NULL),
 m_pDynExtCLSID(NULL),
 m_cDynExt(0),
 m_nDynIndex(0),
 m_pMMCPolicy(NULL)
{
    #ifdef DBG
        dbg_m_fInit = FALSE;
    #endif
}

CExtensionsIterator::~CExtensionsIterator()
{
    if (NULL != m_pMMCPolicy)
        delete m_pMMCPolicy;

    delete [] m_ppExtUsed;
}

/*+-------------------------------------------------------------------------*
 *
 * CExtensionsIterator::ScInitialize
 *
 * PURPOSE: 1st variation - initializes the iterator from a dataobject and an extension type
 *
 * PARAMETERS:
 *    LPDATAOBJECT  pDataObject :
 *    LPCTSTR       pszExtensionTypeKey :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CExtensionsIterator::ScInitialize(LPDATAOBJECT pDataObject, LPCTSTR pszExtensionTypeKey)
{
    DECLARE_SC(sc, TEXT("CExtensionsIterator::ScInitialize"));

    // validate inputs
    sc = ScCheckPointers(pDataObject, pszExtensionTypeKey);
    if(sc)
        return sc;

    // get the nodetype and the snap-in pointer
    CSnapInPtr spSnapIn;
    GUID guidNodeType;
    sc = CNodeInitObject::GetSnapInAndNodeType(pDataObject, &spSnapIn, &guidNodeType);
    if (sc)
        return sc;

	// Fix for bug #469922(9/20/2001):	DynamicExtensions broken in MMC20
	// Use member variable - stack variable lifetime is not long enough.
    ExtractDynExtensions(pDataObject, m_cachedDynExtens);

    //call the second init function
    sc = ScInitialize(spSnapIn,guidNodeType, pszExtensionTypeKey, m_cachedDynExtens.GetData(), m_cachedDynExtens.GetSize());

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CExtensionsIterator::ScInitialize
 *
 * PURPOSE: 2nd variation (legacy)
 *
 * PARAMETERS:
 *    CSnapIn * pSnapIn :
 *    GUID&     rGuidNodeType :
 *    LPCTSTR   pszExtensionTypeKey :
 *    LPCLSID   pDynExtCLSID :
 *    int       cDynExt :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CExtensionsIterator::ScInitialize(CSnapIn *pSnapIn, GUID& rGuidNodeType, LPCTSTR pszExtensionTypeKey, LPCLSID pDynExtCLSID, int cDynExt)
{
    DECLARE_SC(sc, TEXT("CExtensionsIterator::ScInitialize"));

    // validate inputs
    sc = ScCheckPointers(pSnapIn, pszExtensionTypeKey);
    if(sc)
        return sc;

    // store the inputs
    m_spSnapIn      = pSnapIn;
    m_pDynExtCLSID  = pDynExtCLSID,
    m_cDynExt       = cDynExt;

    // Count the static extensions
    CExtSI* pExtSI = m_spSnapIn->GetExtensionSnapIn();
    int cExtStatic = 0;
    while (pExtSI != NULL)
    {
        cExtStatic++;
        pExtSI = pExtSI->Next();
    }

    // Allocate array of extension pointers
    m_ppExtUsed = new CExtSI*[cExtStatic];
    m_cExtUsed = 0;

    m_pMMCPolicy = new CPolicy;
    ASSERT(NULL != m_pMMCPolicy);

    // call init
    sc = Init(rGuidNodeType, pszExtensionTypeKey);
    if(sc)
        return sc;

    return sc;
}


HRESULT CExtensionsIterator::Init(GUID& rGuidNodeType, LPCTSTR pszExtensionTypeKey)
{
	DECLARE_SC (sc, _T("CExtensionsIterator::Init"));
    CStr strBufDynExt;

    CStr strBuf = g_szNodeTypesKey;

    CCoTaskMemPtr<WCHAR> spszNodeType;
    sc = StringFromCLSID(rGuidNodeType, &spszNodeType);
    if (sc)
		return (sc.ToHr());

    strBuf += static_cast<WCHAR*>(spszNodeType);
    strBuf += _T("\\");

    strBufDynExt = strBuf;
    strBufDynExt += g_szDynamicExtensions;

    strBuf += g_szExtensions;
    strBuf += _T("\\");
    strBuf += pszExtensionTypeKey;

	// Try to open the optional dynamic extensions key (ignoring errors)
	m_rkeyDynExt.ScOpen (HKEY_LOCAL_MACHINE, strBufDynExt, KEY_READ);

	//  Open the key
	sc = m_rkey.ScOpen (HKEY_LOCAL_MACHINE, strBuf, KEY_READ);
	if (sc)
	{
		/*
		 * ignore ERROR_FILE_NOT_FOUND
		 */
		if (sc == ScFromWin32 (ERROR_FILE_NOT_FOUND))
			sc.Clear();
		else
			return (sc.ToHr());
	}

	if (NULL == m_pMMCPolicy)
		return ((sc = E_OUTOFMEMORY).ToHr());

	sc = m_pMMCPolicy->ScInit();
	if (sc)
		return (sc.ToHr());

#ifdef DBG
	dbg_m_fInit = TRUE;
#endif

    Reset();
	return (sc.ToHr());
}


BOOL CExtensionsIterator::_Extends(BOOL bStatically)
{
    BOOL fRet = FALSE;

    ASSERT(!IsEnd());

    LPOLESTR polestr = NULL;
    HRESULT hr = StringFromCLSID(GetCLSID(), &polestr);
    CHECK_HRESULT(hr);

    if (SUCCEEDED(hr))
    {
        USES_CONVERSION;
        LPTSTR pszTemp = OLE2T(polestr);

        fRet = m_rkey.IsValuePresent( pszTemp) && m_pMMCPolicy->IsPermittedSnapIn(GetCLSID());

        if (fRet && bStatically)
            fRet = !((HKEY)m_rkeyDynExt && m_rkeyDynExt.IsValuePresent(pszTemp));

        CoTaskMemFree(polestr);
    }

    return fRet;
}


HRESULT MMCGetExtensionsForSnapIn(const CLSID& clsid,
                                  CExtensionsCache& extnsCache)
{
	DECLARE_SC (sc, _T("MMCGetExtensionsForSnapIn"));

	CStr strBuf = SNAPINS_KEY;
	strBuf += _T("\\");

	CCoTaskMemPtr<WCHAR> spszNodeType;
	sc = StringFromCLSID(clsid, &spszNodeType);
	if (sc)
		return (sc.ToHr());

	strBuf += static_cast<WCHAR*>(spszNodeType);
	strBuf += _T("\\");
	strBuf += g_szNodeTypes;

	//  Open the key
	CRegKeyEx	rkeyNodeTypes;
	WORD		wResId;

	sc = rkeyNodeTypes.ScOpen (HKEY_LOCAL_MACHINE, strBuf, KEY_READ);
	if (sc)
	{
		if (sc == ScFromWin32 (ERROR_FILE_NOT_FOUND))
			sc = S_FALSE;

		return (sc.ToHr());
	}

	USES_CONVERSION;
	TCHAR szSubKey[100];

	for (DWORD iSubkey = 0; ; ++iSubkey)
	{
		DWORD cchName = countof(szSubKey);

		sc = rkeyNodeTypes.ScEnumKey (iSubkey, szSubKey, &cchName);
		if (sc)
		{
			if (sc == ScFromWin32 (ERROR_NO_MORE_ITEMS))
				sc.Clear();

			return (sc.ToHr());
		}

		GUID guid;

		if ((sc = CLSIDFromString( T2W(szSubKey), &guid)).IsError() ||
			(sc = ScGetExtensionsForNodeType(guid, extnsCache)).IsError())
		{
			sc.Clear();
			continue;
		}
	}

	return (sc.ToHr());
}


SC ScGetExtensionsForNodeType(GUID& guid, CExtensionsCache& extnsCache)
{
	DECLARE_SC (sc, _T("ScGetExtensionsForNodeType"));

	CStr strBuf = NODE_TYPES_KEY;
	strBuf += _T("\\");

	CCoTaskMemPtr<WCHAR> spszNodeType;
	sc = StringFromCLSID(guid, &spszNodeType);
	if (sc)
		return (sc.ToHr());

	strBuf += static_cast<WCHAR*>(spszNodeType);

	// Open Dynamic Extensions key
	CStr strBufDyn = strBuf;
	strBufDyn += _T("\\");
	strBufDyn += g_szDynamicExtensions;

	CRegKeyEx rkeyDynExtns;
	sc = rkeyDynExtns.ScOpen (HKEY_LOCAL_MACHINE, strBufDyn, KEY_READ);
	BOOL bDynExtnsKey = !sc.IsError();
	sc.Clear();

	// Open Extensions key
	strBuf += _T("\\");
	strBuf += g_szExtensions;

	CRegKeyEx rkeyExtensions;
	sc = rkeyExtensions.ScOpen (HKEY_LOCAL_MACHINE, strBuf, KEY_READ);
	if (sc)
	{
		if (sc == ScFromWin32 (ERROR_FILE_NOT_FOUND))
			sc = S_FALSE;

		return (sc.ToHr());
	}

	USES_CONVERSION;
	TCHAR szValue[100];
	LPCTSTR apszExtnType[] = {g_szNameSpace, g_szContextMenu,
							  g_szToolbar,   g_szPropertySheet,
							  g_szTask,      g_szView};

	int iExtnTypeFlag[] = { CExtSI::EXT_TYPE_NAMESPACE, CExtSI::EXT_TYPE_CONTEXTMENU,
							CExtSI::EXT_TYPE_TOOLBAR,   CExtSI::EXT_TYPE_PROPERTYSHEET,
							CExtSI::EXT_TYPE_TASK,      CExtSI::EXT_TYPE_VIEW};

	for (int i=0; i < countof(apszExtnType); ++i)
	{
		CRegKeyEx rkeyTemp;
		sc = rkeyTemp.ScOpen (rkeyExtensions, apszExtnType[i], KEY_READ);
		if (sc)
		{
			if (sc == ScFromWin32 (ERROR_FILE_NOT_FOUND))
			{
				sc.Clear();
				continue;
			}

			return (sc.ToHr());
		}

		for (DWORD iValue = 0; ; ++iValue)
		{
			DWORD cchValue = countof(szValue);

			sc = rkeyTemp.ScEnumValue (iValue, szValue, &cchValue);
			if (sc)
			{
				if (sc == ScFromWin32 (ERROR_NO_MORE_ITEMS))
					sc.Clear();
                else
                    sc.TraceAndClear();

                break; // do NOT return; still need to loop through all snapins
			}

			GUID guid;
			sc = ::CLSIDFromString( T2W(szValue), &guid);
			if (sc)
			{
				sc.Clear();
				continue;
			}

			int iCurTypes = 0;
			extnsCache.Lookup(guid, iCurTypes);

            /*
            * After getting the snapin that extends given nodetype we should check if the
            * snapin is registered under SNAPINS key. If not do not add the entry to the
            * CExtensionsCache.
            */
            CRegKeyEx rkeySnapins;
            tstring strSnapin = SNAPINS_KEY;
            strSnapin += TEXT("\\");
            strSnapin += szValue;
            sc = rkeySnapins.ScOpen(HKEY_LOCAL_MACHINE, strSnapin.data(), KEY_READ);
            if (sc)
            {
                sc.TraceAndClear();
                continue;
            }

			iCurTypes |= iExtnTypeFlag[i];

			if (bDynExtnsKey && rkeyDynExtns.IsValuePresent(szValue))
				iCurTypes |= CExtSI::EXT_TYPE_DYNAMIC;
			else
				iCurTypes |= CExtSI::EXT_TYPE_STATIC;

			extnsCache.SetAt(guid, iCurTypes);
		}
	}

	return (sc.ToHr());
}


BOOL ExtendsNodeNameSpace(GUID& rguidNodeType, CLSID* pclsidExtn)
{
    BOOL bExtendsNameSpace = FALSE;

	USES_CONVERSION;
	OLECHAR szguid[40];

	int iStat = StringFromGUID2(rguidNodeType, szguid, countof(szguid));
	ASSERT(iStat != 0);

	// Create reg key string
	CStr strTestBuf = NODE_TYPES_KEY;
	strTestBuf += _T("\\");
	strTestBuf += OLE2T(szguid);
	strTestBuf += _T("\\");
	strTestBuf += g_szExtensions;
	strTestBuf += _T("\\");
	strTestBuf += g_szNameSpace;

	CRegKeyEx rKey;
	SC sc = rKey.ScOpen (HKEY_LOCAL_MACHINE, strTestBuf, KEY_READ);
	if (sc)
		return (false);

	// checking for any extension or a particular extension
	if (pclsidExtn == NULL)
	{
		DWORD dwValues;
		LONG lResult = ::RegQueryInfoKey( rKey, NULL, NULL, NULL, NULL, NULL, NULL,
										  &dwValues, NULL, NULL, NULL, NULL);
		ASSERT(lResult == ERROR_SUCCESS);

		bExtendsNameSpace = (dwValues != 0);
	}
	else
	{
		iStat = StringFromGUID2(*pclsidExtn, szguid, countof(szguid));
		ASSERT(iStat != 0);

		bExtendsNameSpace = rKey.IsValuePresent(OLE2T(szguid));
	}

    return bExtendsNameSpace;
}


//+-------------------------------------------------------------------
//
//  Member:     GetSnapinNameFromCLSID
//
//  Synopsis:   Get the name of the snapin provided class id.
//
//  Arguments:  [clsid]          - Class id of the snapin.
//              [wszSnapinName]  - Name.
//
//  Returns:    true if success else false
//
//--------------------------------------------------------------------
bool GetSnapinNameFromCLSID(/*[in]*/  const CLSID& clsid,
                            /*[out]*/ tstring& tszSnapinName)
{
    tszSnapinName.erase();

	WTL::CString strName;
    SC sc = ScGetSnapinNameFromRegistry (clsid, strName);
    if (sc)
        return false;

    tszSnapinName = strName;

    return true;
}


//+-------------------------------------------------------------------
//
//  Member:     ScGetAboutFromSnapinCLSID
//
//  Synopsis:   Get the CLSID of about object of given snapin.
//
//  Arguments:  [clsidSnapin] - Class id of the snapin.
//              [clsidAbout]  - out param, about object class-id.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC ScGetAboutFromSnapinCLSID(/*[in]*/  const CLSID& clsidSnapin,
                             /*[out]*/ CLSID& clsidAbout)
{
    DECLARE_SC(sc, TEXT("ScGetAboutFromSnapinCLSID"));

    // convert class id to string
    CCoTaskMemPtr<WCHAR> spszClsid;
    sc = StringFromCLSID(clsidSnapin, &spszClsid);
    if (sc)
        return sc;

    USES_CONVERSION;
    SC scNoTrace = ScGetAboutFromSnapinCLSID(OLE2CT(spszClsid), clsidAbout);
    if (scNoTrace)
        return scNoTrace;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScGetAboutFromSnapinCLSID
//
//  Synopsis:   Get the CLSID of about object of given snapin.
//
//  Arguments:  [lpszClsidSnapin] - Class id of the snapin.
//              [clsidAbout]      - out param, about object class-id.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC ScGetAboutFromSnapinCLSID(/*[in]*/  LPCTSTR lpszClsidSnapin,
                             /*[out]*/ CLSID& clsidAbout)
{
    DECLARE_SC(sc, TEXT("ScGetAboutFromSnapinCLSID"));

    // Get About
    CRegKeyEx SnapinKey;
    LONG lRet = SnapinKey.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY, KEY_READ);
    if (ERROR_SUCCESS != lRet)
        return (sc = E_FAIL);

    lRet = SnapinKey.Open(SnapinKey, lpszClsidSnapin, KEY_READ);
    if (ERROR_SUCCESS != lRet)
        return (sc = E_FAIL);

    TCHAR  szAbout[100];
    DWORD  dwSize = countof(szAbout);
    DWORD  dwType = REG_SZ;

    SC scNoTrace = SnapinKey.ScQueryValue (g_szAbout, &dwType, szAbout, &dwSize);
	if (scNoTrace)
		return (scNoTrace);

    USES_CONVERSION;
    sc = CLSIDFromString(T2OLE(szAbout), &clsidAbout);
    if (sc)
        return sc;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\regutil.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      regutil.inl
 *
 *  Contents:  Inline functions for regutil.h
 *
 *  History:   24-Apr-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#include "regkeyex.h"


/*+-------------------------------------------------------------------------*
 * IsIndirectStringSpecifier
 *
 * Returns true if the given string looks like it might be an indirect
 * string specifier acceptable to SHLoadRegUIString, i.e. "@dllname,-id".
 *
 * Returns false otherwise
 *--------------------------------------------------------------------------*/

inline bool IsIndirectStringSpecifier (LPCTSTR psz)
{
	return ((psz != NULL) && (psz[0] == _T('@')) && (_tcsstr(psz, _T(",-")) != NULL));
}


/*+-------------------------------------------------------------------------*
 * ScGetSnapinNameFromRegistry
 *
 * Loads the name of a snap-in from the given snap-in CLSID.
 *
 * The template type StringType can be any string class that supports
 * MFC's CString interface (i.e. MFC's CString, WTL::CString, or MMC's
 * CStr).
 *--------------------------------------------------------------------------*/

template<class StringType>
SC ScGetSnapinNameFromRegistry (
	const CLSID&	clsid,
	StringType& 	str)
{
	DECLARE_SC (sc, _T("ScGetSnapinNameFromRegistry"));

	/*
	 * convert class id to string
	 */
	OLECHAR szClsid[40];
    if (!StringFromGUID2 (clsid, szClsid, countof(szClsid)))
		return (sc = E_INVALIDARG);

	/*
	 * load the name
	 */
	USES_CONVERSION;
	sc = ScGetSnapinNameFromRegistry (OLE2T(szClsid), str);
	if (sc)
		return (sc);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * ScGetSnapinNameFromRegistry
 *
 * Loads the name of a snap-in from the given snap-in CLSID string.
 *
 * The template type StringType can be any string class that supports
 * MFC's CString interface (i.e. MFC's CString, WTL::CString, or MMC's
 * CStr).
 *--------------------------------------------------------------------------*/

template<class StringType>
SC ScGetSnapinNameFromRegistry (
	LPCTSTR		pszClsid,
	StringType& str)
{
	DECLARE_SC (sc, _T("ScGetSnapinNameFromRegistry"));

	/*
	 * open HKLM\Software\Microsoft\MMC\SnapIns\{CLSID}
	 */
	StringType strKeyName = StringType(SNAPINS_KEY) + _T("\\") + pszClsid;
    CRegKeyEx SnapinKey;
    LONG lRet = SnapinKey.Open (HKEY_LOCAL_MACHINE, strKeyName, KEY_READ);
    if (ERROR_SUCCESS != lRet)
		return (sc = HRESULT_FROM_WIN32 (lRet));

	/*
	 * load the string
	 */
	sc = ScGetSnapinNameFromRegistry (SnapinKey, str);
	if (sc)
		return (sc);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * ScGetSnapinNameFromRegistry
 *
 * Loads the name of a snap-in from the given open snap-in registry key.
 * First, we'll try to use SHLoadRegUIString to resolve an indirect name
 * in the "NameStringIndirect" value.  If that fails (because "NameString-
 * Indirect" isn't registered, because the registered DLL can't be loaded,
 * etc.), we'll fall back to the old "NameString" entry.
 *
 * The template type StringType can be any string class that supports
 * MFC's CString interface (i.e. MFC's CString, WTL::CString, or MMC's
 * CStr).
 *--------------------------------------------------------------------------*/

template<class StringType>
SC ScGetSnapinNameFromRegistry (
	CRegKeyEx&	key,					/* I:snap-in's key, opened for read	*/
	StringType&	str)					/* O:name of snap-in				*/
{
	DECLARE_SC (sc, _T("ScGetSnapinNameFromRegistry"));

	/*
	 * try to load the MUI-friendly name first, ignoring errors
	 */
	sc = key.ScLoadRegUIString (g_szNameStringIndirect, str);

	/*
	 * if an error occurred, or ScLoadReagUIString couldn't resolve the
	 * @dllname syntax, or the returned string was empty, fall back
	 * on the legacy registry entry
	 */
	if (sc.IsError() || str.IsEmpty() || IsIndirectStringSpecifier(str))
		sc = key.ScQueryString (g_szNameString, str, NULL);

	return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nodemgr.rc
//
#include "mmcres.h"

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "MMC Node Manager DLL"
#define VER_INTERNALNAME_STR            "mmcndmgr.dll"
#define VER_ORIGINALFILENAME_STR        "mmcndmgr.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\regutil.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       regutil.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/20/1997   RaviR   Created
//____________________________________________________________________________
//

#pragma once
#include "nmtempl.h"

#ifdef COMMENTS_ONLY

/*
                    REGISTRY LAYOUT USED BY MMC:

                            SNAPINS

HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\SnapIns
    {04ebc1e6-a16c-11d0-a799-00c04fd8d565}                       // See N-1.
        NameString = REG_SZ "Snapin Name"
        About = REG_SZ "{128ac4e6-a16c-11d0-a799-00c04fd8d565}"  // See N-2.
        NodeTypes                                                // See N-3.
            {c713e06c-a16e-11d0-a799-00c04fd8d565}
            {c713e06d-a16e-11d0-a799-00c04fd8d565}
            {c713e06e-a16e-11d0-a799-00c04fd8d565}
            {c713e06f-a16e-11d0-a799-00c04fd8d565}
        StandAlone                                               // See N-4.
        RequiredExtensions                                       // See N-5.
            {a2087336-a16c-11d0-a799-00c04fd8d565}
            {70098cd3-a16c-11d0-a799-00c04fd8d565}



N-1) Snapin clsid. Only snapins that add to the name space should be
     entered here.

N-2) Clisd of the object that will be cocreated to get the IAbout interface
     ptr for the snapin.

N-3) Enumerate all the node type GUIDs that may be put up by this snapin.

N-4) [Optional] Add the 'StandAlone' key only if the snapin can appear by
     itself under the Console Root. If this key is not present the snapin is
     assumed to be name space extension snapin. Note: A stand alone snapin
     can also be an extension snapin (i.e. it can extend some other snapin).

N-5) [Optional] Enumerate the CLSIDs of extension snapins that are required
     for this snapin to function.


                            NODETYPES


HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes
    {12345601-EA27-11CF-ADCF-00AA00A80033}              // Node type GUID
        = REG_SZ "Log object"
        Extensions
            NameSpace       // See N-7.
                {19876201-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Alert SnapIn"
                {34346202-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Viewer SnapIn"
            ContextMenu     // See N-8.
                {19876202-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Alert SnapIn"
                {34346202-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Viewer SnapIn"
            ToolBar         // See N-9.
                {19876202-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Alert SnapIn"
                {00234ca8-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Pure toolbar extn obj"
            PropertySheet   // See N-10.
                {12222222-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Pure propery sheet extn obj"
            View            // See N-12.
                {12222222-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "View extn obj"
            Task            // See N-13.
                {12222222-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Snapin Taskpad extn obj"
            Taskpad         // See N-14.
                {12222222-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "MMC2.0 Taskpad extn obj"
         Dynamic Extensions  // See N-11
            {34346202-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Viewer SnapIn"

N-7) Under the key 'NameSpace' list the CLSIDs of snapins that can extend the
     name space of this nodetype.

N-8) Under the 'ContextMenu' key list the CLSIDs of snapins that can extend
     the context menu of items put up by this nodetype.

N-9) Under the 'ToolBar' key list the CLSIDs of snapins that can extend
     the toolbar of items put up by this nodetype.

N-10)Under the 'PropertySheet' key list the CLSIDs of snapins that can extend
     the property sheet of items put up by this nodetype.

N-11)Under the 'Dynamic Extensions' Key list the CLSIDs of extensions that can only
     be enabled dynamically, not by the snap-in manager. Any CLSIDs listed here
     should also appear under one on the other extension sub-keys.

N-12)Under the 'View' key list the CLSIDs of snapins that can extend
     the view of items put up by this nodetype.

N-13)Under the 'Task' key list the CLSIDs of snapins that can extend
     the Taskpad of items put up by this nodetype.

*/

#endif // COMMENTS_ONLY


#ifndef _REGUTIL_H_
#define _REGUTIL_H_


#ifdef DBG
    #define ASSERT_INITIALIZED     ASSERT(dbg_m_fInit == TRUE)
#else
    #define ASSERT_INITIALIZED
#endif

// Forward decl
class CPolicy;

/*+-------------------------------------------------------------------------*
 * class CExtensionsIterator
 *
 *
 * PURPOSE: Allows iterating through all the extension snap-ins for a particular
 *          nodetype.
 *          Once initialized, returns, in order, all the registered extensions
 *          followed by all the dynamic extensions. If a dynamic extension was
 *          also a static extension, does not repeat the snap-in.
 *
 *
 * USAGE:   Initialize the object, then make calls to GetCLSID() followed by
 *          Advance() until IsEnd() returns true.
 *
 *+-------------------------------------------------------------------------*/
class CExtensionsIterator
{
public:
// Constructor & destructor
    CExtensionsIterator();
    ~CExtensionsIterator();

    // 1st variation - initializes the iterator from a dataobject and an extension type
    SC  ScInitialize(LPDATAOBJECT pDataObject, LPCTSTR pszExtensionTypeKey);

    // 2nd variation (legacy)
    SC  ScInitialize(CSnapIn *pSnapIn, GUID& rGuidNodeType, LPCTSTR pszExtensionTypeKey, LPCLSID pDynExtCLSID = NULL, int cDynExt = 0);

// Attributes
    BOOL IsEnd()
    {
        ASSERT_INITIALIZED;
        return (m_pExtSI == NULL && m_nDynIndex >= m_cDynExt);
    }

    BOOL IsDynamic()
    {
        ASSERT_INITIALIZED;
        return (m_pExtSI == NULL);
    }

    void Reset()
    {
        ASSERT_INITIALIZED;

        m_pExtSI = m_spSnapIn->GetExtensionSnapIn();
        m_nDynIndex = 0;
        m_cExtUsed = 0;

        _EnsureExtension();
    }

    void Advance()
    {
        ASSERT_INITIALIZED;

        if (m_pExtSI != NULL)
            m_pExtSI = m_pExtSI->Next();
        else
            m_nDynIndex++;

        _EnsureExtension();
    }

    const CLSID& GetCLSID()
    {
        ASSERT_INITIALIZED;

        if (m_pExtSI != NULL)
            return m_pExtSI->GetCLSID();
        else if (m_nDynIndex < m_cDynExt)
            return m_pDynExtCLSID[m_nDynIndex];

        ASSERT(FALSE);
        return GUID_NULL;
    }


    CSnapIn* GetSnapIn()
    {
        ASSERT_INITIALIZED;
        if (m_pExtSI != NULL)
        {
            return m_pExtSI->GetSnapIn();
        }

        ASSERT(FALSE);
        return NULL;
    }

private:
    HRESULT Init(GUID& rGuidNodeType, LPCTSTR pszExtensionTypeKey);

// Implementation
private:
    CSnapInPtr      m_spSnapIn;
    CRegKeyEx       m_rkey;
    CRegKeyEx       m_rkeyDynExt;
    CExtSI*         m_pExtSI;
    CExtSI**        m_ppExtUsed;
    CArray<GUID,GUID&> m_cachedDynExtens;
    LPCLSID         m_pDynExtCLSID;
    int             m_cDynExt;
    int             m_nDynIndex;
    int             m_cExtUsed;
    CPolicy*        m_pMMCPolicy;


#ifdef DBG
    BOOL        dbg_m_fInit;
#endif

    void _EnsureExtension()
    {
        ASSERT_INITIALIZED;

        // Step through the snap-in's static extensions first
        for (; m_pExtSI != NULL; m_pExtSI = m_pExtSI->Next())
        {
            if (m_pExtSI->IsNew() == TRUE)
                continue;

            // Is this registered as the correct extension type?
            // Note: if extension is required, then it doesn't
            //       have to be registered as a static extension
            if (_Extends(!m_pExtSI->IsRequired()) == TRUE)
            {
                m_ppExtUsed[m_cExtUsed++] = m_pExtSI;
                return;
            }
        }

        // When they are exhausted, go through the dynamic list
        for (; m_nDynIndex < m_cDynExt; m_nDynIndex++)
        {
            if (_Extends() == FALSE)
                continue;

            // Don't use dynamic extension that is already used statically
            for (int i=0; i< m_cExtUsed; i++)
            {
                if (IsEqualCLSID(m_pDynExtCLSID[m_nDynIndex], m_ppExtUsed[i]->GetCLSID()))
                    break;
            }

            if (i == m_cExtUsed)
                return;
        }
    }

    BOOL _Extends(BOOL bStatically = FALSE);

    // Undefined
    CExtensionsIterator(const CExtensionsIterator& rhs);
    CExtensionsIterator& operator= (const CExtensionsIterator& rhs);

}; // class CExtensionsIterator

template<>
inline UINT HashKey(GUID& guid)
{
    unsigned short* Values = (unsigned short *)&guid;

    return (Values[0] ^ Values[1] ^ Values[2] ^ Values[3] ^
            Values[4] ^ Values[5] ^ Values[6] ^ Values[7]);
}

class CExtensionsCache : public CMap<GUID, GUID&, int, int>
{
public:
    CExtensionsCache()
    {
        InitHashTable(31);
    }

    void Add(GUID& guid)
    {
        SetAt(guid, 0);
    }

}; // class CExtensionsCache

typedef XMapIterator<CExtensionsCache, GUID, int> CExtensionsCacheIterator;

HRESULT ExtractDynExtensions(IDataObject* pdataObj, CArray<GUID, GUID&>& arrayGuid);
SC      ScGetExtensionsForNodeType(GUID& guid, CExtensionsCache& extnsCache);
HRESULT MMCGetExtensionsForSnapIn(const CLSID& clsid,
                                  CExtensionsCache& extnsCache);

BOOL ExtendsNodeNameSpace(GUID& rguidNodeType, CLSID* pclsidExtn);
bool GetSnapinNameFromCLSID(const CLSID& clsid, tstring& tszSnapinName);
SC   ScGetAboutFromSnapinCLSID(LPCTSTR szClsidSnapin, CLSID& clsidAbout);
SC   ScGetAboutFromSnapinCLSID(const CLSID& clsidSnapin, CLSID& clsidAbout);

bool IsIndirectStringSpecifier (LPCTSTR psz);

template<class StringType> SC ScGetSnapinNameFromRegistry (const CLSID& clsid, StringType& str);
template<class StringType> SC ScGetSnapinNameFromRegistry (LPCTSTR pszClsid,   StringType& str);
template<class StringType> SC ScGetSnapinNameFromRegistry (CRegKeyEx& key,     StringType& str);

inline BOOL HasNameSpaceExtensions(GUID& rguidNodeType)
{
    return ExtendsNodeNameSpace(rguidNodeType, NULL);
}


#include "regutil.inl"

#endif // _REGUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\rsltdata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       rsltdata.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "menuitem.h" // MENUITEM_BASE_ID
#include "amcmsgid.h"
#include "conview.h"
#include "rsltitem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetResultView
//
//  Synopsis:    Save the result view ptr.
//
//  Arguments:   [pUnknown] -
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetResultView(LPUNKNOWN pUnknown)
{
    DECLARE_SC(sc, _T("CNodeInitObject::SetResultView"));

    m_spResultViewUnk   = pUnknown;
    m_spListViewPrivate = pUnknown;

    // If the resultview is reset then reset the desc bar.
    if (NULL == pUnknown)
        SetDescBarText( L"" );

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::IsResultViewSet
//
//  Synopsis:    Is the ResultView ptr set (so that conui can query
//               before invoking ResultView methods).
//
//  Arguments:   [pbIsLVSet] - Ptr to BOOL. (TRUE means ResultView is set).
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::IsResultViewSet(BOOL* pbIsLVSet)
{
    DECLARE_SC(sc, _T("CNodeInitObject::IsResultViewSet"));
    sc = ScCheckPointers(pbIsLVSet);
    if (sc)
        return sc.ToHr();

    *pbIsLVSet = FALSE;

    if (m_spListViewPrivate)
        *pbIsLVSet = TRUE;

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetTaskPadList
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetTaskPadList(LPUNKNOWN pUnknown)
{
    DECLARE_SC(sc, _T("CNodeInitObject::SetTaskPadList"));

    if (pUnknown == NULL)
    {
        m_spListViewPrivate = NULL;
    }
    else
    {
        if (m_spListViewPrivate == pUnknown)
        {
            return sc.ToHr();
        }
        else
        {
            ASSERT(m_spListViewPrivate == NULL);
            m_spListViewPrivate = pUnknown;
        }
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::QueryResultView
//
//  Synopsis:    IConsole2 method for snapins to get resultview's IUnknown.
//
//  Arguments:   [ppUnk] - return IUnknown to snapin.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::QueryResultView(LPUNKNOWN* ppUnk)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::QueryResultView"));

    if (!ppUnk)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Null LPUNKNOWN pointer passed in"), sc);
        return sc.ToHr();
    }

    (*ppUnk) = m_spResultViewUnk;

    sc = ScCheckPointers((*ppUnk), E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    (*ppUnk)->AddRef();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::MessageBox
//
//  Synopsis:    IConsole2 member, called by snapin to display a message box.
//
//  Arguments:   [lpszText]  - Text to display.
//               [lpszTitle] -
//               [fuStyle]   -
//               [piRetval]  -
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::MessageBox(
    LPCWSTR lpszText, LPCWSTR lpszTitle, UINT fuStyle, int* piRetval)

{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::MessageBox"));

    USES_CONVERSION;

    // find the main frame window and use it as the owner of the message box
    INT iRetval = ::MessageBox(
        GetMainWindow(),
        W2CT(lpszText),
        W2CT(lpszTitle),
        fuStyle );

    if (NULL != piRetval)
        *piRetval = iRetval;

    return sc.ToHr();
}



//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetListStyle
//
//  Synopsis:    Get the current list view style.
//
//  Arguments:   [pStyle] -
//
//  Note:        IResultDataPrivate member, internal to MMC.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetListStyle(long * pStyle)
{
    DECLARE_SC(sc, _T("CNodeInitObject::GetListStyle"));

    // must have pStyle
    if (!pStyle)
    {
        sc = E_INVALIDARG;
        TraceError(_T("CNodeinitObject::GetListStyle, style ptr passed is NULL"), sc);
        return sc.ToHr();
    }

    if (NULL == m_spListViewPrivate)
    {
        sc = E_UNEXPECTED;
        TraceError(_T("CNodeinitObject::GetListStyle, ListView ptr is NULL"), sc);
        return sc.ToHr();
    }

    *pStyle = m_spListViewPrivate->GetListStyle();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetListStyle
//
//  Synopsis:    Modify the list view style.
//
//  Arguments:   [style] -
//
//  Note:        IResultDataPrivate member, internal to MMC.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetListStyle(long style)
{
    DECLARE_SC(sc, _T("CNodeInitObject::SetListStyle"));

    if (NULL == m_spListViewPrivate)
    {
        sc = E_UNEXPECTED;
        TraceError(_T("CNodeinitObject::GetListStyle, ListView ptr is NULL"), sc);
        return sc.ToHr();
    }

    sc = m_spListViewPrivate->SetListStyle(style);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::ModifyItemState
//
//  Synopsis:    Enables snapin to modify the state of an item.
//
//  Arguments:   [nIndex]  - index of the item to be modified (used only if itemID is 0).
//               [itemID]  - HRESULTITEM if not virtual-list (Virtual list use above index).
//               [uAdd]    - States to add.
//               [uRemove] - States to be removed.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::ModifyItemState(int nIndex, HRESULTITEM hri,
                                              UINT uAdd, UINT uRemove)

{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::ModifyItemState"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->ModifyItemState(nIndex, CResultItem::FromHandle(hri), uAdd, uRemove);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::ModifyViewStyle
//
//  Synopsis:    Allows snapin to modify list view style.
//
//  Arguments:   [add]    - Styles to be set.
//               [remove] - Styles to be removed.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::ModifyViewStyle(MMC_RESULT_VIEW_STYLE add,
                                              MMC_RESULT_VIEW_STYLE remove)

{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::ModifyViewStyle"));

    typedef struct {
        MMC_RESULT_VIEW_STYLE   mmcFlag;
        DWORD                   lvsFlag;
    } FlagMapEntry;

    FlagMapEntry flagMap[] =
    {
        {MMC_SINGLESEL,             LVS_SINGLESEL},
        {MMC_SHOWSELALWAYS,         LVS_SHOWSELALWAYS},
        {MMC_NOSORTHEADER,          LVS_NOSORTHEADER},
        {MMC_ENSUREFOCUSVISIBLE,    MMC_LVS_ENSUREFOCUSVISIBLE},
        {(MMC_RESULT_VIEW_STYLE)0,  0}
    };

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Get the old style.
    DWORD dwLVStyle = static_cast<DWORD>(m_spListViewPrivate->GetListStyle());

    // convert MMC_ flags to LVS_ flags and apply to current style
    for (FlagMapEntry* pMap = flagMap; pMap->mmcFlag; pMap++)
    {
        if (add & pMap->mmcFlag)
            dwLVStyle |= pMap->lvsFlag;

        if (remove & pMap->mmcFlag)
            dwLVStyle &= ~pMap->lvsFlag;
    }

    sc = m_spListViewPrivate->SetListStyle(static_cast<long>(dwLVStyle));

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::InsertItem
//
//  Synopsis:    Insert an item into ListView (IResultData member).
//
//  Arguments:   [item] -
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::InsertItem(LPRESULTDATAITEM item)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::InsertItem"));

    // MUST have an item structure.
    if (!item)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("The LPRESULTDATAITEM ptr passed in is NULL"), sc);
        return sc.ToHr();
    }

    COMPONENTID nID;
    GetComponentID(&nID);

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CResultItem* pri = NULL;
    sc =  m_spListViewPrivate->InsertItem(
                         item->mask & RDI_STR   ? item->str    : MMCLV_NOPTR,
                         item->mask & RDI_IMAGE ? item->nImage : MMCLV_NOICON,
                         item->mask & RDI_PARAM ? item->lParam : MMCLV_NOPARAM,
                         item->mask & RDI_STATE ? item->nState : MMCLV_NOPARAM,
                         nID, item->nIndex, pri);
    if (sc)
        return (sc.ToHr());

    if (pri == NULL)
        return ((sc = E_UNEXPECTED).ToHr());

    item->itemID = CResultItem::ToHandle(pri);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::DeleteItem
//
//  Synopsis:    Delete the given item (IResultData member).
//
//  Arguments:   [itemID] - item identifier.
//               [nCol]   - column to delete.
//
//  Note:        nCol must be zero.
//
//  Returns:     HREsULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::DeleteItem(HRESULTITEM itemID, int nCol)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::DeleteItem"));

    if (nCol != 0)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Column index must be zero"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->DeleteItem ( itemID, nCol);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::UpdateItem
//
//  Synopsis:    Redraw the given item.
//
//  Arguments:   [itemID] - Item identifier.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::UpdateItem(HRESULTITEM itemID)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::UpdateItem"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->UpdateItem(itemID);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:     Sort
//
//  Synopsis:   IResultData member, snapins can call this to sort the
//              result pane items. This calls InternalSort to do sort.
//
//  Arguments:  [nCol]          - Column to be sorted.
//              [dwSortOptions] - Sort options.
//              [lUserParam]    - User (snapin) param.
//
//  Returns:    HRESULT
//
//  History:             RaviR   Created
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::Sort(int nCol, DWORD dwSortOptions, LPARAM lUserParam)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::Sort"));

    sc = ScCheckPointers(m_spComponent, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    int nColumnCnt;
    sc = m_spListViewPrivate->GetColumnCount(&nColumnCnt);
    if (sc)
        return sc.ToHr();

    if (nCol < 0 || nCol >= nColumnCnt)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Column index is invalid"), sc);
        return sc.ToHr();
    }

    sc = InternalSort(nCol, dwSortOptions, lUserParam, FALSE);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     InternalSort
//
//  Synopsis:   Private member MMC calls to sort the result pane items.
//
//  Arguments:  [nCol]           - Column to be sorted.
//              [dwSortOptions]  - Sort options.
//              [lUserParam]     - User (snapin) param.
//              [bColumnClicked] - Is sort due to column click.
//
//  Note:       If column is clicked the lUserParam will be NULL.
//              The sort options is set depending on ascend/descend,
//              and cannot include RSI_NOSORTICON as this option is
//              only for snapin initiated sort.
//
//  Returns:    HRESULT
//
//  History:                RaviR    Created
//              07-02-1999  AnandhaG added setsorticon.
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::InternalSort(INT nCol, DWORD dwSortOptions,
                                           LPARAM lUserParam, BOOL bColumnClicked)
{
    DECLARE_SC(sc, _T("CNodeInitObject::InternalSort"));

    // Save old sort-column to reset its sort icon.
    int  nOldCol    = m_sortParams.nCol;
    BOOL bAscending = m_sortParams.bAscending;

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // If column is clicked the sortoption and user param are
    // already 0. Set only the sortoptions below.
    if (bColumnClicked)
    {
        if(nOldCol != nCol)
            bAscending = TRUE;
        else
            bAscending = !m_sortParams.bAscending;

        dwSortOptions |= (bAscending ? 0 : RSI_DESCENDING);

        // Notify component of sort parameter change
        m_spComponent->Notify(NULL, MMCN_COLUMN_CLICK, nCol,dwSortOptions);
    }

    bool bIsVirtualList = false;
    sc = ScIsVirtualList(bIsVirtualList);
    if (sc)
        return sc.ToHr();

    if ( bIsVirtualList )
    {
        // see if the snap-in handle owner data methods
        IResultOwnerDataPtr pResultOwnerData = m_spComponent;
        if (pResultOwnerData != NULL)
        {
            sc = pResultOwnerData->SortItems(nCol,dwSortOptions,lUserParam );

            // if reordering done, save the sort data and repaint the list view.
            if (S_OK == sc.ToHr())
            {
                m_sortParams.nCol         = nCol;
                m_sortParams.bAscending   = !(dwSortOptions & RSI_DESCENDING);
                m_sortParams.bSetSortIcon = !(dwSortOptions & RSI_NOSORTICON);
                m_sortParams.lpUserParam  = lUserParam;

                /*
                * Bug 414256:  We need to save the sort data only if
                * it is user initiated sort. Is this user initiated?
                */
                m_sortParams.bUserInitiatedSort = bColumnClicked;

                sc = m_spListViewPrivate->Repaint(TRUE);
                if (sc)
                    return sc.ToHr();
            }
        }
        else
        {
            sc = E_UNEXPECTED;
        }
    }
    else
    {
        // Query for compare interfaces
        IResultDataComparePtr   spResultCompare   = m_spComponent;
        IResultDataCompareExPtr spResultCompareEx = m_spComponent;

        // Set the sort parameters.
        m_sortParams.nCol = nCol;
        m_sortParams.bAscending   = !(dwSortOptions & RSI_DESCENDING);
        m_sortParams.bSetSortIcon = !(dwSortOptions & RSI_NOSORTICON);
        m_sortParams.lpUserParam  = lUserParam;

        m_sortParams.lpResultCompare   = spResultCompare;
        m_sortParams.lpResultCompareEx = spResultCompareEx;

        /*
        * Bug 414256:  We need to save the sort data only if
        * it is user initiated sort. Is this user initiated?
        */
        m_sortParams.bUserInitiatedSort = bColumnClicked;

        sc = m_spListViewPrivate->Sort(lUserParam, (long*)&m_sortParams);

        m_sortParams.lpResultCompare   = NULL;
        m_sortParams.lpResultCompareEx = NULL;
    }

    // Set sort icon only if Sort went through.
    if (S_OK == sc.ToHr())
    {
        sc = m_spListViewPrivate->SetColumnSortIcon( m_sortParams.nCol, nOldCol,
                                                     m_sortParams.bAscending,
                                                     m_sortParams.bSetSortIcon);
    }

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodeInitObject::GetSortDirection
 *
 * PURPOSE: returns sorting direction
 *
 * PARAMETERS:
 *    BOOL* pbAscending    - resulting sort column dir
 *
 * RETURNS:
 *    SC    - result code. S_FALSE ( in combination with -1 col) if no sorting.
 *
\***************************************************************************/
STDMETHODIMP CNodeInitObject::GetSortDirection(BOOL* pbAscending)
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::GetSortDirection"));

    if (pbAscending == NULL)
    {
        sc = E_INVALIDARG;
        return sc.ToHr();
    }

    *pbAscending = m_sortParams.bAscending;

    // If no sorting is performed then return S_FALSE.
    sc = m_sortParams.nCol >= 0 ? S_OK : S_FALSE;

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodeInitObject::GetSortColumn
 *
 * PURPOSE: returns sorting column
 *          sort column regardless if the user has initiated the sort or not.
 *
 * PARAMETERS:
 *    INT* pnCol    - resulting sort column index
 *
 * RETURNS:
 *    SC    - result code. S_FALSE ( in combination with -1 col) if no sorting.
 *
\***************************************************************************/
STDMETHODIMP CNodeInitObject::GetSortColumn(INT* pnCol)
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::GetSortColumn"));

    if (pnCol == NULL)
    {
        sc = E_INVALIDARG;
        return sc.ToHr();
    }

    *pnCol = m_sortParams.nCol;

    // return code depending if the valid column was got
    sc = m_sortParams.nCol >= 0 ? S_OK : S_FALSE;

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::FindItemByLParam
//
//  Synopsis:    Find the ItemID using the user-param.
//
//  Arguments:   [lParam] - lParam (RESULTDATAITEM.lParam)
//               [pItemID] - return the item-id.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::FindItemByLParam(LPARAM lParam, HRESULTITEM *pItemID)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::FindItemByLParam"));

    if(!pItemID)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("the HRESULTITEM* ptr is NULL"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    COMPONENTID id;
    GetComponentID(&id);

    /*
     * init the output param
     */
    *pItemID = NULL;

    CResultItem* pri = NULL;
    sc = m_spListViewPrivate->FindItemByLParam (id, lParam, pri);
    if (sc == SC(E_FAIL)) // E_FAIL is legal return value.
    {
        sc.Clear();
        return E_FAIL;
    }

    sc = ScCheckPointers (pri, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    *pItemID = CResultItem::ToHandle(pri);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::DeleteAllRsltItems
//
//  Synopsis:    Delete all the result items
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::DeleteAllRsltItems()
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::DeleteAllRsltItems"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    COMPONENTID id;
    GetComponentID(&id);

    sc = m_spListViewPrivate->DeleteAllItems(id);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetItem
//
//  Synopsis:    Modify attributes of an item.
//
//  Arguments:   [item]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetItem(LPRESULTDATAITEM item)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::SetItem"));

    // MUST have an item structure.
    if (!item)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL LPRESULTDATAITEM ptr"), sc);
        return sc.ToHr();
    }

    // Cannot set an lParam on a subItem.  (thank Win32 for this)
    if((item->mask & RDI_PARAM) && (item->nCol != 0))
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Cannot set lParam for subitem"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    COMPONENTID id;
    GetComponentID(&id);

    CResultItem* pri = CResultItem::FromHandle (item->itemID);

    sc = m_spListViewPrivate->SetItem(
                         item->nIndex,
                         pri, item->nCol,
                         item->mask & RDI_STR ? item->str : MMCLV_NOPTR,
                         item->mask & RDI_IMAGE ? item->nImage : MMCLV_NOICON,
                         item->mask & RDI_PARAM ? item->lParam : MMCLV_NOPARAM,
                         item->mask & RDI_STATE ? item->nState : MMCLV_NOPARAM,
                         id);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetNextItem
//
//  Synopsis:    Get the next item with specified flag set.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetNextItem(LPRESULTDATAITEM item)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::GetNextItem"));

    if (NULL == item)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL LPRESULTDATAITEM ptr"), sc);
        return sc.ToHr();
    }

    if (NULL == (item->mask & RDI_STATE))
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("RDI_STATE mask not set"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    COMPONENTID id;
    GetComponentID(&id);


    bool bIsVirtualList = false;
    sc = ScIsVirtualList(bIsVirtualList);
    if (sc)
        return sc.ToHr();

    HRESULT hr = S_OK;
    long nIndex = item->nIndex;
    CResultItem* pri = NULL;

    // Assume error
    item->nIndex = -1;
    item->lParam = 0;

    while (1)
    {
        sc = m_spListViewPrivate->GetNextItem (id, nIndex, item->nState,
                                               pri, nIndex);
        if (sc.ToHr() != S_OK)
        {
            break;
        }

        // Virtual list item, just return the index (lParam is zero).
        if (bIsVirtualList)
        {
            item->nIndex = nIndex;
            item->bScopeItem = FALSE;
            break;
        }

        sc = ScCheckPointers (pri, E_FAIL);
        if (sc)
            break;

        // Non-virtual leaf item.
        if (pri->GetOwnerID() == id)
        {
            item->nIndex = nIndex;
            item->bScopeItem = FALSE;
            item->lParam = pri->GetSnapinData();
            break;
        }

        if (!pri->IsScopeItem())
        {
            sc = E_UNEXPECTED;
            break;
        }

        // This is a tree item, get the lUserParam.
        CNode* pNode = CNode::FromResultItem (pri);
        sc = ScCheckPointers(pNode, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (pNode->IsStaticNode() == TRUE)
            break;

        CMTNode* pMTNode = pNode->GetMTNode();
        sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (pMTNode->GetPrimaryComponentID() == id)
        {
            item->nIndex     = nIndex;
            item->bScopeItem = TRUE;
            item->lParam     = pMTNode->GetUserParam();
            break;
        }

    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetItem
//
//  Synopsis:    Get the parameters of an item.
//
//  Arguments:   [item] - itemID is used to get the item, if itemID = 0,
//                        then nIndex is used.
//
//  Note:        For VLists itemID = 0, nIndex is used.
//               nCol must be zero.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetItem(LPRESULTDATAITEM item)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::GetItem"));

    // MUST have an item structure.
    if (!item)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL LPRESULTDATAITEM ptr."), sc);
        return sc.ToHr();
    }

    COMPONENTID id;
    GetComponentID(&id);

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CResultItem* pri = CResultItem::FromHandle(item->itemID);

    sc =  m_spListViewPrivate->GetItem(
                            item->nIndex,
                            pri, item->nCol,
                            item->mask & RDI_STR   ? &item->str    : MMCLV_NOPTR,
                            item->mask & RDI_IMAGE ? &item->nImage : MMCLV_NOPTR,
                            item->mask & RDI_PARAM ? &item->lParam : MMCLV_NOPTR,
                            item->mask & RDI_STATE ? &item->nState : MMCLV_NOPTR,
                            &item->bScopeItem);
    if (sc)
        return (sc.ToHr());

    if (pri == NULL)
        return ((sc = E_UNEXPECTED).ToHr());

    if (pri->IsScopeItem())
    {
        item->bScopeItem = TRUE;

        // This is a tree item, get the lUserParam.
        CNode* pNode = CNode::FromResultItem (pri);
        sc = ScCheckPointers(pNode, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        // When the static node is visible in result-pane the result pane is
        // owned not by that static node's snapin so this is unexpected.
        if (pNode->IsStaticNode())
            return (sc = E_UNEXPECTED).ToHr();

        CMTNode* pMTNode = pNode->GetMTNode();
        sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (pMTNode->GetPrimaryComponentID() != id)
            return (sc = E_INVALIDARG).ToHr();

        if (RDI_PARAM & item->mask)
            item->lParam = pMTNode->GetUserParam();

        if (RDI_IMAGE & item->mask)
            item->nImage = pMTNode->GetImage();
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetViewMode
//
//  Synopsis:    Change the ListView mode (detail...)
//
//  Arguments:   [nViewMode] - new mode.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetViewMode(LONG nViewMode)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::SetViewMode"));

    if (FALSE == (nViewMode >= 0 && nViewMode <= MMCLV_VIEWSTYLE_FILTERED))
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid view mode"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc =  m_spListViewPrivate->SetViewMode(nViewMode);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::Arrange
//
//  Synopsis:    Arrange the items is LV.
//
//  Arguments:   [style]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::Arrange(long style)
{
    DECLARE_SC(sc, _T("CNodeInitObject::Arrange"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->Arrange(style);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetViewMode
//
//  Synopsis:    Get the current view mode.
//
//  Arguments:   [pnViewMode] - view mode [out]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetViewMode(LONG * pnViewMode)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::GetViewMode"));

    if (pnViewMode == MMCLV_NOPTR)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL ViewMode pointer"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    *pnViewMode = m_spListViewPrivate->GetViewMode();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::ResetResultData
//
//  Synopsis:    Reset the result view.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::ResetResultData()
{
    DECLARE_SC(sc, _T("CNodeInitObject::ResetResultData"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Dont know what this assert means? (AnandhaG).
    ASSERT(TVOWNED_MAGICWORD == m_componentID);

    sc = m_spListViewPrivate->Reset();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetLoadMode
//
//  Synopsis:    Used for re-drawing LV/delay sorting.
//
//  Note:        If ListView setup (snapin is inserting columns/items,
//               MMC is applying column/view/sort settings) is going on
//               then delay sorting and also turn off drawing.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetLoadMode(BOOL bState)
{
    DECLARE_SC(sc, _T("CNodeInitObject::SetLoadMode"));

    // Dont know what this assert means? (AnandhaG).
    ASSERT(TVOWNED_MAGICWORD == m_componentID);

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->SetLoadMode(bState);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetDescBarText
//
//  Synopsis:    Set the desc bar text for ResultPane.
//
//  Arguments:   [pszDescText]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetDescBarText(LPOLESTR pszDescText)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::SetDescBarText"));

    CConsoleView* pConsoleView = GetConsoleView();

    sc = ScCheckPointers(pConsoleView, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // What happens if desc text is NULL?
    USES_CONVERSION;
    sc = pConsoleView->ScSetDescriptionBarText (W2T (pszDescText));

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetItemCount
//
//  Synopsis:    Set the number of items in Virtual List.
//
//  Arguments:   [nItemCount] - # items.
//               [dwOptions]  - option flags.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetItemCount(int nItemCount, DWORD dwOptions)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::SetItemCount"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->SetItemCount(nItemCount, dwOptions);

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CNodeInitObject::RenameResultItem
 *
 * PURPOSE: Places the specified result item into rename mode.
 *
 * PARAMETERS:
 *    HRESULTITEM  itemID :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CNodeInitObject::RenameResultItem(HRESULTITEM itemID)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, TEXT("IResultData2::RenameResultItem"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->RenameItem(itemID);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\scopdata.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ScopData.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//____________________________________________________________________________
//



#include "stdafx.h"
#include "ScopImag.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CDoc;


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::InsertItem
//
//  Synopsis:    Insert an item in TreeView (IConsoleNameSpace method).
//
//  Arguments:   [pSDI] - LPSCOPEDATEITEM
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::InsertItem(LPSCOPEDATAITEM pSDI)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::InsertItem"));

    if (!pSDI)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL LPSCOPEDATAITEM ptr"), sc);
        return sc.ToHr();
    }

    if (IsBadWritePtr(pSDI, sizeof(SCOPEDATAITEM)) != 0)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("BadWrite Ptr LPSCOPEDATAITEM"), sc);
        return sc.ToHr();
    }

    COMPONENTID nID;
    GetComponentID(&nID);

    if (nID == TVOWNED_MAGICWORD)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    if (nID == -1)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    if (pSDI->relativeID == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("RelativeID is NULL"), sc);
        return sc.ToHr();
    }

    if ( 0 == (pSDI->mask & SDI_STR))
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("SDI_STR mask is not set"), sc);
        return sc.ToHr();
    }

    if (0 == (pSDI->mask & SDI_PARAM))
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("SDI_PARAM mask is not set"), sc);
        return sc.ToHr();
    }

    if (pSDI->displayname != MMC_TEXTCALLBACK)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Display name must be MMC_TEXTCALLBACK"), sc);
        return sc.ToHr();
    }

    SCOPEDATAITEM sdiTemp;
    CopyMemory(&sdiTemp, pSDI, sizeof(sdiTemp));

    sdiTemp.nImage = sdiTemp.nOpenImage = 0;

    if (pSDI->mask & SDI_IMAGE)
    {
        m_pImageListPriv->MapRsltImage(nID, pSDI->nImage, &sdiTemp.nImage);
        sdiTemp.nOpenImage = sdiTemp.nImage;
    }

    if (pSDI->mask & SDI_OPENIMAGE)
        m_pImageListPriv->MapRsltImage(nID, pSDI->nOpenImage, &sdiTemp.nOpenImage);

    try
    {
        CScopeTree* pScopeTree =
            dynamic_cast<CScopeTree*>((IScopeTree*)m_spScopeTree);
        sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CMTNode* pMTNodeNew = NULL;
        sc = pScopeTree->ScInsert(&sdiTemp, nID, &pMTNodeNew);
        if(sc)
            return sc.ToHr();

        sc = ScCheckPointers(pMTNodeNew, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        pSDI->ID = sdiTemp.ID;
        ASSERT (CMTNode::FromScopeItem(pSDI->ID) == pMTNodeNew);
    }
    catch( std::bad_alloc )
    {
        sc = E_OUTOFMEMORY;
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::DeleteItem
//
//  Synopsis:    Delete the given item.
//
//  Arguments:   [hItem]       - ItemID of item to be deleted.
//               [fDeleteThis] - If true Delete this item & its children
//                               else just the children.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::DeleteItem(HSCOPEITEM hItem, long fDeleteThis)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::DeleteItem"));

    COMPONENTID nID;
    GetComponentID(&nID);

    if (nID == -1)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    CMTNode *pMTNode = CMTNode::FromScopeItem (hItem);

    if (pMTNode == NULL)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("HSCOPEITEM is not valid"), sc);
        return sc.ToHr();
    }

    CScopeTree* pScopeTree = CScopeTree::GetScopeTree();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Delete from scope tree.
    sc = pScopeTree->ScDelete(pMTNode, fDeleteThis ? TRUE : FALSE, nID);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetItem
//
//  Synopsis:    Change the attributes of an item.
//
//  Arguments:   [pSDI] -
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetItem(LPSCOPEDATAITEM pSDI)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::SetItem"));

    if (!pSDI)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL LPSCOPEDATAITEM ptr"), sc);
        return sc.ToHr();
    }

    if (IsBadReadPtr(pSDI, sizeof(SCOPEDATAITEM)) != 0)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("LPSCOPEDATAITEM is bad read ptr"), sc);
        return sc.ToHr();
    }

    COMPONENTID nID;
    GetComponentID(&nID);

    if (nID == -1)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    CMTNode* pMTNode = CMTNode::FromScopeItem (pSDI->ID);

    if (pMTNode == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid ID in LPSCOPEDATAITEM"), sc);
        return sc.ToHr();
    }

    if (pMTNode->GetOwnerID() != nID &&
        pMTNode->GetOwnerID() != TVOWNED_MAGICWORD)
    {
        sc = E_INVALIDARG;
        return sc.ToHr();
    }

    if (pSDI->mask & SDI_PARAM)
        pMTNode->SetUserParam(pSDI->lParam);

    if (pSDI->mask & SDI_STATE)
        pMTNode->SetState(pSDI->nState);

    if (pSDI->mask & SDI_STR)
	{
        // Only static node's string can be modified, other node's use MMC_TEXTCALLBACK.
        if ((pSDI->displayname != MMC_TEXTCALLBACK) && (!pMTNode->IsStaticNode()) )
        {
            /*
                * We should be tracing and returning E_INVALIDARG. But this code is in existence
                * for more than 3 years and has high impact. So we just trace and proceed as if
                * no error occurred.
                */
            //sc = E_INVALIDARG;
            TraceSnapinError(_T("Display name must be MMC_TEXTCALLBACK"), sc);
            //return sc.ToHr();
            sc = S_OK;
        }
        else
        {
            USES_CONVERSION;
            LPCTSTR lpstrDisplayName = NULL;
            if ( pSDI->displayname != MMC_TEXTCALLBACK )
                lpstrDisplayName = W2T(pSDI->displayname);
            else
                lpstrDisplayName = reinterpret_cast<LPCTSTR>(MMC_TEXTCALLBACK);

            pMTNode->SetDisplayName( lpstrDisplayName );
        }
    }

    int nTemp;

    if (pSDI->mask & SDI_IMAGE)
    {
        // Change the image.
        nTemp = pSDI->nImage;
        if (pSDI->nImage == MMC_IMAGECALLBACK)
            {
            CComponentData* pCCD = pMTNode->GetPrimaryComponentData();
            if (pCCD)
            {
                SCOPEDATAITEM ScopeDataItem;
                ZeroMemory(&ScopeDataItem, sizeof(ScopeDataItem));
                ScopeDataItem.mask   = SDI_IMAGE;
                ScopeDataItem.lParam = pMTNode->GetUserParam();
                ScopeDataItem.nImage = 0;
                sc = pCCD->GetDisplayInfo(&ScopeDataItem);
                if (sc)
                    return sc.ToHr();

                pSDI->nImage = ScopeDataItem.nImage;
            }
        }

        sc = m_pImageListPriv->MapRsltImage (nID, pSDI->nImage, &nTemp);
        if (sc)
		{
			TraceSnapinError(_T("The snapin specified image was never added initially"), sc);
			sc.Clear();
		}

        pMTNode->SetImage (nTemp);
        CMTSnapInNode* pMTSnapInNode = dynamic_cast<CMTSnapInNode*>(pMTNode);
        if (pMTSnapInNode)
            pMTSnapInNode->SetResultImage (MMC_IMAGECALLBACK);
    }

    if (pSDI->mask & SDI_OPENIMAGE)
    {
        nTemp = pSDI->nOpenImage;
        if (pSDI->nOpenImage == MMC_IMAGECALLBACK)
        {
            CComponentData* pCCD = pMTNode->GetPrimaryComponentData();
            if (pCCD)
            {
                SCOPEDATAITEM ScopeDataItem;
                ZeroMemory(&ScopeDataItem, sizeof(ScopeDataItem));
                ScopeDataItem.mask   = SDI_OPENIMAGE;
                ScopeDataItem.lParam = pMTNode->GetUserParam();
                ScopeDataItem.nOpenImage = 1;
                sc = pCCD->GetDisplayInfo(&ScopeDataItem);
                if (sc)
                    return sc.ToHr();

                pSDI->nOpenImage = ScopeDataItem.nOpenImage;
            }
        }
        sc = m_pImageListPriv->MapRsltImage (nID, pSDI->nOpenImage, &nTemp);
        if (sc)
		{
			TraceSnapinError(_T("The snapin specified image was never added initially"), sc);
			sc.Clear();
		}

        pMTNode->SetOpenImage (nTemp);
    }

    if (pSDI->mask & SDI_CHILDREN)
    {
        pMTNode->SetNoPrimaryChildren(pSDI->cChildren == 0);
    }

    // Now inform the views to modify as needed.
    SViewUpdateInfo vui;
    // Snapin nodes result pane will be handled by the snapins
    vui.flag = VUI_REFRESH_NODE;
    pMTNode->CreatePathList(vui.path);
    CScopeTree* pScopeTree =
        dynamic_cast<CScopeTree*>((IScopeTree*)m_spScopeTree);

    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    pScopeTree->UpdateAllViews(VIEW_UPDATE_MODIFY,
                                reinterpret_cast<LPARAM>(&vui));

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetItem
//
//  Synopsis:    Get the attributes of an item given ItemID.
//
//  Arguments:   [pSDI]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetItem(LPSCOPEDATAITEM pSDI)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::GetItem"));

    if (!pSDI)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL LPSCOPEDATAITEM ptr"), sc);
        return sc.ToHr();
    }

    if (IsBadWritePtr(pSDI, sizeof(SCOPEDATAITEM)) != 0)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("BadWrite Ptr LPSCOPEDATAITEM"), sc);
        return sc.ToHr();
    }

    COMPONENTID nID;
    GetComponentID(&nID);

    if (nID == -1)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    CMTNode* pMTNode = CMTNode::FromScopeItem (pSDI->ID);

    sc = ScCheckPointers(pMTNode);
    if (sc)
        return sc.ToHr();

    if (pMTNode->GetOwnerID() != nID &&
        pMTNode->GetOwnerID() != TVOWNED_MAGICWORD)
    {
        sc = E_INVALIDARG;
        return sc.ToHr();
    }

    if (pSDI->mask & SDI_IMAGE)
	{
		sc = m_pImageListPriv->UnmapRsltImage (nID, pMTNode->GetImage(), &pSDI->nImage);
		if (sc)
			return (sc.ToHr());
	}

    if (pSDI->mask & SDI_OPENIMAGE)
	{
		sc = m_pImageListPriv->UnmapRsltImage (nID, pMTNode->GetOpenImage(), &pSDI->nOpenImage);
		if (sc)
			return (sc.ToHr());
	}

    if (pSDI->mask & SDI_STATE)
        pSDI->nState = pMTNode->GetState();

    if (pSDI->mask & SDI_PARAM)
        pSDI->lParam = pMTNode->GetUserParam();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetRelativeItem
//
//  Synopsis:    Helper function, Get Parent/Child/Sibling item.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CNodeInitObject::GetRelativeItem(EGetItem egi, HSCOPEITEM item,
                        HSCOPEITEM* pItem, MMC_COOKIE* pCookie)

{
    DECLARE_SC(sc, _T("CNodeInitObject::GetRelativeItem"));

    if (item == 0)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("The HSCOPEITEM is NULL"), sc);
        return sc.ToHr();
    }

    if (pItem == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL HSCOPEITEM ptr"), sc);
        return sc.ToHr();
    }

    if (pCookie == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL MMC_COOKIE ptr"), sc);
        return sc.ToHr();
    }

    COMPONENTID nID;
    GetComponentID(&nID);

    if (nID == -1)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    // init
    *pItem = 0;
    *pCookie = 0;

    if (item != 0)
    {
        CMTNode* pMTNode = CMTNode::FromScopeItem (item);

        if (pMTNode == NULL)
        {
            sc = E_INVALIDARG;
            TraceSnapinError(_T("Invalid HSCOPEITEM"), sc);
            return sc.ToHr();
        }

        CMTNode* pMTNodeTemp = pMTNode;

        switch (egi)
        {
        case egiParent:
            if (pMTNodeTemp->GetPrimaryComponentID() != nID &&
                pMTNodeTemp->GetPrimaryComponentID() != TVOWNED_MAGICWORD)
            {
                sc = E_FAIL;
                return sc.ToHr();
            }

            if (pMTNodeTemp->IsStaticNode() == TRUE)
            {
                sc = E_FAIL;
                return sc.ToHr();
            }

            pMTNodeTemp = pMTNodeTemp->Parent();
            break;

        case egiChild:
            pMTNodeTemp = pMTNodeTemp->Child();

            while (pMTNodeTemp != NULL)
            {
                // Backed out change made for bug# 525959 because of
                // regression (bug# 713914)
                if (pMTNodeTemp->GetPrimaryComponentID() == nID) 
                    break;

                pMTNodeTemp = pMTNodeTemp->Next();
            }
            break;

        case egiNext:
            if (pMTNodeTemp->GetPrimaryComponentID() != nID &&
                pMTNodeTemp->GetPrimaryComponentID() != TVOWNED_MAGICWORD)
            {
                sc = E_FAIL;
                return sc.ToHr();
            }

            while (1)
            {
                pMTNodeTemp = pMTNodeTemp->Next();
                if (pMTNodeTemp == NULL)
                    break;

                if (pMTNodeTemp->GetPrimaryComponentID() == nID)
                    break;
            }
            break;

        default:
            sc = E_UNEXPECTED;
            break;
        }


        if (pMTNodeTemp != NULL)
        {
            *pItem   = CMTNode::ToScopeItem(pMTNodeTemp);
            *pCookie = pMTNodeTemp->GetUserParam();
        }
        else
        {
            sc = S_FALSE;
        }
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetChildItem
//
//  Synopsis:    Get the child item
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetChildItem(HSCOPEITEM item,
                                   HSCOPEITEM* pItemChild, MMC_COOKIE* pCookie)

{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::GetChildItem"));

    sc = GetRelativeItem(egiChild, item, pItemChild, pCookie);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetNextItem
//
//  Synopsis:    Get the next (sibling) item.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------

STDMETHODIMP CNodeInitObject::GetNextItem(HSCOPEITEM item,
                                   HSCOPEITEM* pItemNext, MMC_COOKIE* pCookie)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::GetNextItem"));

    sc = GetRelativeItem(egiNext, item, pItemNext, pCookie);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetParentItem
//
//  Synopsis:    Get the parent item.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------

STDMETHODIMP CNodeInitObject::GetParentItem(HSCOPEITEM item,
                                   HSCOPEITEM* pItemParent, MMC_COOKIE* pCookie)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::GetParentItem"));

    sc = GetRelativeItem(egiParent, item, pItemParent, pCookie);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::Expand
//
//  Synopsis:    Expand the given item (not visually, this will send
//               MMCN_EXPAND to snapin if the item is not already
//               expanded.)
//
//  Arguments:  [hItem] - Item to be expanded.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::Expand(HSCOPEITEM hItem)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::Expand"));

    CMTNode* pMTNode = CMTNode::FromScopeItem (hItem);

    if (pMTNode == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid HSCOPEITEM"), sc);
        return sc.ToHr();
    }

    if (pMTNode->WasExpandedAtLeastOnce() == TRUE)
    {
        // Item is already expanded.
        sc = S_FALSE;
        return sc.ToHr();
    }

    sc = pMTNode->Expand();

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\scopimag.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ScopImag.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10/4/1996   RaviR   Created
//____________________________________________________________________________
//


#include "stdafx.h"

#include "bitmap.h"
#include "scopimag.h"
#include "util.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef WORD ICONID;
typedef DWORD SNAPINICONID;
typedef int ILINDEX; // image list index

#define MAKESNAPINICONID(ICONID, SNAPINID)  MAKELONG(ICONID, SNAPINID)
#define GETSNAPINID(SNAPINICONID)           ((int)(short)HIWORD(SNAPINICONID))
#define GETICONID(SNAPINICONID)             ((int)(short)LOWORD(SNAPINICONID))

//______________________________________________________________________
//______________________________________________________________________
//______________________________________________________________________
//______________________________________________________________________
//

class CGuidArrayEx : public CArray<GUID, REFGUID>
{
public:
    CGuidArrayEx() { SetSize(0, 10); }
    ~CGuidArrayEx() {}

    int Find(REFGUID refGuid);

}; // class CGuidArrayEx


static CGuidArrayEx s_GuidArray;

int CGuidArrayEx::Find(REFGUID refGuid)
{
    for (int i=0; i <= GetUpperBound(); i++)
    {
        if (IsEqualGUID(refGuid, (*this)[i]) == TRUE)
            return i;
    }

    return -1;
}


//______________________________________________________________________
//______________________________________________________________________
//______________________________________________________________________
//______________________________________________________________________
//

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapInImageList);

CSnapInImageList::CSnapInImageList(
    CSPImageCache *pSPImageCache,
    REFGUID refGuidSnapIn)
        :
        m_ulRefs(1),
        m_pSPImageCache(pSPImageCache)
{
    ASSERT(pSPImageCache != NULL);

    m_pSPImageCache = pSPImageCache;

    m_pSPImageCache->AddRef();

    int iRet = s_GuidArray.Find(refGuidSnapIn);

    if (iRet == -1)
        iRet = s_GuidArray.Add(refGuidSnapIn);

    m_snapInId = static_cast<WORD>(iRet);

    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapInImageList);
}

CSnapInImageList::~CSnapInImageList()
{
    SAFE_RELEASE(m_pSPImageCache);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapInImageList);
}

// IUnknown methods

STDMETHODIMP_(ULONG) CSnapInImageList::AddRef()
{
    return InterlockedIncrement((LONG*)&m_ulRefs);
}

STDMETHODIMP_(ULONG) CSnapInImageList::Release()
{
    ULONG ulRet = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == ulRet)
    {
        delete this;
    }
    return ulRet;
}



STDMETHODIMP
CSnapInImageList::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    LPUNKNOWN punk = NULL;

    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IImageList, riid))
    {
        punk = (IUnknown*)(IImageList*) this;
    }
    else if (IsEqualIID(IID_IImageListPrivate, riid))
    {
        punk = (IUnknown*)(IImageListPrivate*) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    *ppvObj = punk;
    punk->AddRef();

    return S_OK;
}

STDMETHODIMP
CSnapInImageList::ImageListSetIcon(
    PLONG_PTR pIcon,
    LONG nLoc)
{
    return m_pSPImageCache->SetIcon(m_snapInId, reinterpret_cast<HICON>(pIcon), nLoc);
}



STDMETHODIMP
CSnapInImageList::ImageListSetStrip(
    PLONG_PTR pBMapSm,
    PLONG_PTR pBMapLg,
    LONG nStartLoc,
    COLORREF cMask)
{
    BITMAP szSmall;

    ASSERT(pBMapSm != NULL);

    //HBITMAP hBMapSm = reinterpret_cast<HBITMAP>(pBMapSm);
    HBITMAP hBMapSm = (HBITMAP)pBMapSm;

    if (GetObject(hBMapSm, sizeof(BITMAP), &szSmall) == 0)
    {
        if (GetBitmapBits(hBMapSm, sizeof(BITMAP), &szSmall) == 0)
        {
            LRESULT lr = GetLastError();
            return HRESULT_FROM_WIN32(lr);
        }
    }

    int nEntries = szSmall.bmWidth/16;

    if ((szSmall.bmHeight != 16) || (szSmall.bmWidth % 16))
        return E_INVALIDARG;

    return (m_pSPImageCache->SetImageStrip (m_snapInId, (HBITMAP)pBMapSm,
											nStartLoc, cMask, nEntries));
}


STDMETHODIMP
CSnapInImageList::MapRsltImage(
    COMPONENTID id,
    int nSnapinIndex,
    int *pnConsoleIndex)
{
	DECLARE_SC (sc, _T("CSnapInImageList::MapRsltImage"));

	sc = ScCheckPointers (pnConsoleIndex);
	if (sc)
		return (sc.ToHr());

    sc = m_pSPImageCache->ScMapSnapinIndexToScopeIndex(m_snapInId, nSnapinIndex, *pnConsoleIndex);
	if (sc)
		return (sc.ToHr());

	return (sc.ToHr());
}


STDMETHODIMP
CSnapInImageList::UnmapRsltImage(
    COMPONENTID id,
    int nConsoleIndex,
    int *pnSnapinIndex)
{
	DECLARE_SC (sc, _T("CSnapInImageList::MapRsltImage"));

	sc = ScCheckPointers (pnSnapinIndex);
	if (sc)
		return (sc.ToHr());

    sc = m_pSPImageCache->ScMapScopeIndexToSnapinIndex(m_snapInId, nConsoleIndex, *pnSnapinIndex);
	if (sc)
		return (sc.ToHr());

	return (sc.ToHr());
}



//______________________________________________________________________
//______________________________________________________________________
//______________________________________________________________________
//______________________________________________________________________
//

DEBUG_DECLARE_INSTANCE_COUNTER(CSPImageCache);

CSPImageCache::CSPImageCache()
    :
    m_map(20),
    m_il(),
    m_cRef(1)
{
    m_map.InitHashTable(223);

    BOOL fReturn = m_il.Create(16, 16, ILC_COLOR8 | ILC_MASK, 20, 10);
    ASSERT((fReturn != 0) && "Failed to create ImageList");

    DEBUG_INCREMENT_INSTANCE_COUNTER(CSPImageCache);
}


CSPImageCache::~CSPImageCache()
{
    m_il.Destroy();
    ASSERT(m_cRef == 0);

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSPImageCache);
}

HRESULT
CSPImageCache::SetIcon(
    SNAPINID    sid,
    HICON       hIcon,
    LONG        nLoc)
{
    SNAPINICONID key = MAKESNAPINICONID(nLoc, sid);
    ULONG nNdx1;
    ULONG nNdx2;

    HRESULT hr = S_OK;


    //m_critSec.Lock(m_hWnd);

    if (m_map.Lookup(key, nNdx1))
    {
        nNdx2 = m_il.ReplaceIcon(nNdx1, hIcon);

        if (nNdx2 == -1)
        {
            hr = E_FAIL;
            CHECK_HRESULT(hr);
        }
        else if (nNdx2 != nNdx1)
        {
            hr  = E_UNEXPECTED;
            CHECK_HRESULT(hr);
        }
    }
    else
    {
        // Add the icon to imagelist
        nNdx1 = m_il.AddIcon(hIcon);

        if (nNdx1 == -1)
        {
            hr = E_FAIL;
            CHECK_HRESULT(hr);
        }
        else
        {
            // Generate a new key and store the values in the maps
            m_map.SetAt(key, nNdx1);
        }
    }

    //m_critSec.Unlock();

    return hr;
}



HRESULT
CSPImageCache::SetImageStrip(
    SNAPINID    sid,
    HBITMAP     hBMap,
    LONG        nStartLoc,
    COLORREF    cMask,
    int         nEntries)
{
    DECLARE_SC(sc, TEXT("CSPImageCache::SetImageStrip"));

    ULONG nNdx;


    // The CImageList::Add modifies the input bitmaps so make a copy first.
    WTL::CBitmap bmSmall;
    bmSmall.Attach(CopyBitmap(hBMap));

    if (bmSmall.IsNull())
		return (sc.FromLastError().ToHr());

    nNdx = m_il.Add( bmSmall, cMask);

    if (nNdx == -1)
        return (sc = E_FAIL).ToHr();

    // Keep the map updated for each newly inserted image.
    for (int i=0; i < nEntries; i++)
    {
        // REVIEW: review this part of the code.
        SNAPINICONID key = MAKESNAPINICONID(nStartLoc, sid);
        m_map.SetAt(key, nNdx);
        ++nStartLoc;
        ++nNdx;
    }

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 * ScMapSnapinIndexToScopeIndex
 *
 * Maps a snap-in's typically zero-based image index to an index for the
 * common scope tree image list
 *--------------------------------------------------------------------------*/

SC CSPImageCache::ScMapSnapinIndexToScopeIndex (
	SNAPINID	sid,			// I:what snap-in is this for?
	int			nSnapinIndex,	// I:index by which the snap-in refers to the image
	int&		nScopeIndex)	// O:index by which the scope tree refers to the image
{
	DECLARE_SC (sc, _T("ScMapSnapinIndexToScopeIndex"));

    SNAPINICONID key = MAKESNAPINICONID(nSnapinIndex, sid);
	ASSERT (GETSNAPINID (key) == sid);
	ASSERT (GETICONID   (key) == nSnapinIndex);

    ULONG ul;
    if (!m_map.Lookup(key, ul))
		return (sc = E_FAIL);

    nScopeIndex = ul;
    return (sc);
}


/*+-------------------------------------------------------------------------*
 * ScMapScopeIndexToSnapinIndex
 *
 * Maps a scope tree image index to the given snap-in's image index.
 *--------------------------------------------------------------------------*/

SC CSPImageCache::ScMapScopeIndexToSnapinIndex (
	SNAPINID	sid,			// I:what snap-in is this for?
	int			nScopeIndex,	// I:index by which the scope tree refers to the image
	int&		nSnapinIndex)	// O:index by which the snap-in refers to the image
{
	DECLARE_SC (sc, _T("ScMapScopeIndexToSnapinIndex"));
	sc = E_FAIL;	// assume failure

	/*
	 * iterate through the map looking for scope indices matching the requested one
	 */
	for (POSITION pos = m_map.GetStartPosition(); pos != NULL; )
	{
		SNAPINICONID key;
		DWORD value;
		m_map.GetNextAssoc (pos, key, value);

		/*
		 * if this value matches the requested scope image index and it
		 * belongs to the given snap-in, we've found a match; return it
		 */
		if ((value == nScopeIndex) && (GETSNAPINID(key) == sid))
		{
			nSnapinIndex = GETICONID (key);
			sc = S_OK;
			break;
		}
	}

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\scopimag.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ScopImag.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10/4/1996   RaviR   Created
//____________________________________________________________________________
//


#ifndef _SCOPIMAG_H_
#define _SCOPIMAG_H_

typedef WORD SNAPINID;


typedef CMap<DWORD, DWORD&, DWORD, DWORD&> CSIIconIdToILIndexMap;


class CSPImageCache
{
public:
// Constructor
    CSPImageCache();

// Attributes
    WTL::CImageList* GetImageList() { return &m_il; }

// Operations
    // Image manipulation.
    HRESULT SetIcon(SNAPINID sid, HICON hIcon, LONG  nLoc);
    HRESULT SetImageStrip(SNAPINID sid, HBITMAP hBMapSm,
                          LONG nStartLoc, COLORREF cMask, int nEntries);
    SC ScMapSnapinIndexToScopeIndex (SNAPINID sid, int nSnapinIndex, int& nScopeIndex);
    SC ScMapScopeIndexToSnapinIndex (SNAPINID sid, int nScopeIndex, int& nSnapinIndex);

    // Reference counting
    void AddRef();
    void Release();

// Implementation
private:
    CSIIconIdToILIndexMap   m_map;
    WTL::CImageList         m_il;
    ULONG                   m_cRef;

// Destructor - called only by Release
    ~CSPImageCache();

}; // class CSPImageCache



class CSnapInImageList : public IImageListPrivate
{
public:
// Constructor & Destructor
    CSnapInImageList(CSPImageCache *pSPImageCache, REFGUID refGuidSnapIn);
    ~CSnapInImageList();

// Interfaces
    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IImageListPrivate methods
    STDMETHOD(ImageListSetIcon)(PLONG_PTR pIcon, LONG nLoc);
    STDMETHOD(ImageListSetStrip)(PLONG_PTR pBMapSm, PLONG_PTR pBMapLg,
                                 LONG nStartLoc, COLORREF cMask);

    STDMETHOD(MapRsltImage)(COMPONENTID id, int nSnapinIndex, int *pnConsoleIndex);
    STDMETHOD(UnmapRsltImage)(COMPONENTID id, int nConsoleIndex, int *pnSnapinIndex);
    STDMETHOD(GetImageList)(BOOL bLargeImageList, HIMAGELIST *phImageList)
    {
        // Not needed now, GetImageList is implemented for NodeInitObject.
        return E_NOTIMPL;
    }


// Implementation
private:
    CSPImageCache *     m_pSPImageCache;
    ULONG               m_ulRefs;
    SNAPINID            m_snapInId;

}; // class CSnapInImageList



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//////////////              INLINES                 ///////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


//_____________________________________________________________________________
//
//  Inlines for class:  CSPImageCache
//_____________________________________________________________________________
//

inline void CSPImageCache::AddRef()
{
    ++m_cRef;
}

inline void CSPImageCache::Release()
{
    ASSERT(m_cRef >= 1);
    --m_cRef;

    if (m_cRef == 0)
        delete this;
}


#endif // _SCOPIMAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\scopiter.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ScopIter.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//____________________________________________________________________________
//

#include "stdafx.h"
#include "scopiter.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DEBUG_DECLARE_INSTANCE_COUNTER(CScopeTreeIterator);

//+-------------------------------------------------------------------
//
//  Member:    CScopeTreeIterator::CScopeTreeIterator
//
//  Synopsis:  constructor for CScopeTreeIterator
//
//  Arguments: -
//
//  Returns:  - 
//
//--------------------------------------------------------------------

CScopeTreeIterator::CScopeTreeIterator() : m_pMTNodeCurr(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CScopeTreeIterator);
}

//+-------------------------------------------------------------------
//
//  Member:    CScopeTreeIterator::~CScopeTreeIterator
//
//  Synopsis:  destructor for CScopeTreeIterator
//
//  Arguments: -
//
//  Returns:  - 
//
//--------------------------------------------------------------------
CScopeTreeIterator::~CScopeTreeIterator()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CScopeTreeIterator);
}

//+-------------------------------------------------------------------
//
//  Member:    CScopeTreeIterator::SetCurrent
//
//  Synopsis:  Set's the iterator's current node
//
//  Arguments: hMTNode: node to set as current
//
//  Returns:   HRESULT (E_INVALIDARG or S_OK)
//
//--------------------------------------------------------------------
STDMETHODIMP CScopeTreeIterator::SetCurrent(HMTNODE hMTNode)
{
    DECLARE_SC(sc, TEXT("CScopeTreeIterator::SetCurrent"));

    if (hMTNode == 0)
    {
        sc = E_INVALIDARG;
        return (sc.ToHr());
    }

    m_pMTNodeCurr = CMTNode::FromHandle(hMTNode);

    return sc.ToHr();

}

//+-------------------------------------------------------------------
//
//  Member:    CScopeTreeIterator::Next
//
//  Synopsis:  Sets the next node (if any) as current and returns a pointer to 
//             the same. (May be NULL)
//
//  Arguments: phScopeItem: [OUT] Non-null Pointer to location for the 
//             node to be returned.
//
//  Returns:   HRESULT (E_INVALIDARG or S_OK)
//
//--------------------------------------------------------------------
STDMETHODIMP CScopeTreeIterator::Next(HMTNODE* phScopeItem)
{
    DECLARE_SC(sc, TEXT("CScopeTreeIterator::Next"));

    sc = ScCheckPointers(phScopeItem);
    if(sc)
        return sc.ToHr();

    if(m_pMTNodeCurr)
        m_pMTNodeCurr = m_pMTNodeCurr->Next();

    CMTNode** pMTNode = reinterpret_cast<CMTNode**>(phScopeItem);
    *pMTNode = m_pMTNodeCurr;

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:    CScopeTreeIterator::Prev
//
//  Synopsis:  Sets the prev node (if any) as current and returns a pointer to 
//             the same. (May be NULL)
//
//  Arguments: phScopeItem: [OUT] Non-null Pointer to location for the 
//             node to be returned.
//
//  Returns:   HRESULT (E_INVALIDARG or S_OK)
//
//--------------------------------------------------------------------
STDMETHODIMP CScopeTreeIterator::Prev(HMTNODE* phScopeItem)
{
    DECLARE_SC(sc, TEXT("CScopeTreeIterator::Prev"));

    sc = ScCheckPointers(phScopeItem);
    if(sc)
        return sc.ToHr();

    if(m_pMTNodeCurr)
        m_pMTNodeCurr = m_pMTNodeCurr->Prev();

    CMTNode** pMTNode = reinterpret_cast<CMTNode**>(phScopeItem);
    *pMTNode = m_pMTNodeCurr;

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:    CScopeTreeIterator::Child
//
//  Synopsis:  Returns the child of the current node. NULL if either 
//             current node or child is NULL.
//
//  Arguments: phsiChild: [OUT] Non-null Pointer to location for the 
//             node to be returned.
//
//  Returns:   HRESULT (E_INVALIDARG or S_OK)
//
//--------------------------------------------------------------------
STDMETHODIMP CScopeTreeIterator::Child(HMTNODE* phsiChild)
{
    DECLARE_SC(sc, TEXT("CScopeTreeIterator::Child"));

    sc = ScCheckPointers(phsiChild);
    if(sc)
        return sc.ToHr();

    *phsiChild = 0; // init

    if (m_pMTNodeCurr != NULL)
        *phsiChild = CMTNode::ToHandle(m_pMTNodeCurr->Child());

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:    CScopeTreeIterator::LastChild
//
//  Synopsis:  Returns the last child of the current node. NULL if either 
//             current node or last child is NULL.
//
//  Arguments: phsiLastChild: [OUT] Non-null Pointer to location for the 
//             node to be returned.
//
//  Returns:   HRESULT (E_INVALIDARG or S_OK)
//
//--------------------------------------------------------------------
STDMETHODIMP CScopeTreeIterator::LastChild(HMTNODE* phsiLastChild)
{
    DECLARE_SC(sc, TEXT("CScopeTreeIterator::LastChild"));

    sc = ScCheckPointers(phsiLastChild);
    if(sc)
        return sc.ToHr();

    *phsiLastChild = 0; // init

    if (m_pMTNodeCurr != NULL)
        *phsiLastChild = CMTNode::ToHandle(m_pMTNodeCurr->LastChild());

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\scopiter.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ScopIter.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    
//____________________________________________________________________________
//

#ifndef _SCOPITER_H_
#define _SCOPITER_H_

class CMTNode;

class CScopeTreeIterator : public IScopeTreeIter, public CComObjectRoot
{
// Constructor/Destructor
public:
    CScopeTreeIterator();
    ~CScopeTreeIterator();

public:
BEGIN_COM_MAP(CScopeTreeIterator)
    COM_INTERFACE_ENTRY(IScopeTreeIter)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CScopeTreeIterator)

// COM interfaces
public:
    // IScopeTreeIter methods
    STDMETHOD(SetCurrent)(HMTNODE hStartMTNode);
    STDMETHOD(Next)(HMTNODE* phScopeItem);
    STDMETHOD(Prev)(HMTNODE* phScopeItem);
    STDMETHOD(Child)(HMTNODE* phsiChild);
    STDMETHOD(LastChild)(HMTNODE* phsiLastChild);

// Implementation
private:
    CMTNode*    m_pMTNodeCurr;
};



#endif // _SCOPITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\scopndcb.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ScopNdCb.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12/31/1996   RaviR   Created
//____________________________________________________________________________
//


#ifndef _MMC_SCOPNDCB_H_
#define _MMC_SCOPNDCB_H_

class CNode;
class CComponentData;
class CComponent;

class CNodeCallback : public INodeCallback, public CComObjectRoot
{
// Constructor/Destructor
public:
    CNodeCallback();
    ~CNodeCallback();

public:
BEGIN_COM_MAP(CNodeCallback)
    COM_INTERFACE_ENTRY(INodeCallback)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CNodeCallback)

// COM interfaces
public:
    // INodeCallback methods
    STDMETHOD(Initialize)(IScopeTree* pIScopeTree);
    STDMETHOD(GetImages)(HNODE hNode, int* iImage, int* iSelectedImage);
    STDMETHOD(GetDisplayName)(HNODE hNode, tstring& strName);
    STDMETHOD(GetWindowTitle)(HNODE hNode, tstring& strTitle);
    STDMETHOD(GetDispInfo)(HNODE hNode, LV_ITEMW* plvi);
    STDMETHOD(GetResultPane)(HNODE hNode, CResultViewType& rvt, GUID *pGuidTaskpadID);
    STDMETHOD(RestoreResultView)(HNODE hNode, const CResultViewType& rvt);
    STDMETHOD(GetState)(HNODE hNode, UINT* pnState);
    STDMETHOD(Notify)(HNODE hNode, NCLBK_NOTIFY_TYPE event, LONG_PTR arg, LPARAM param);
    STDMETHOD(GetMTNodeID)(HNODE hNode, MTNODEID* pnID);
    STDMETHOD(GetNodeOwnerID)(HNODE hNode, COMPONENTID* pOwnerID);
    STDMETHOD(GetNodeCookie)(HNODE hNode, MMC_COOKIE* pCookie);
    STDMETHOD(IsTargetNodeOf)(HNODE hNode, HNODE hTestNode);
    STDMETHOD(GetPath)(HNODE hNode, HNODE hRootNode, LPBYTE pbm_);
    STDMETHOD(GetStaticParentID)(HNODE hNode, MTNODEID* pnID);
    STDMETHOD(GetMTNode)(HNODE hNode, HMTNODE* phMTNode);
    STDMETHOD(GetMTNodePath)(HNODE hNode, HMTNODE** pphMTNode, long* plLength);
    STDMETHOD(SetResultItem)  (HNODE hNode, HRESULTITEM hri);
    STDMETHOD(GetResultItem)  (HNODE hNode, HRESULTITEM* phri);
    STDMETHOD(GetControl)(     HNODE hNode, CLSID clsid, IUnknown **ppUnkControl);
    STDMETHOD(SetControl)(     HNODE hNode, CLSID clsid, IUnknown* pUnknown);
    STDMETHOD(GetControl)(     HNODE hNode, LPUNKNOWN pUnkOCX, IUnknown **ppUnkControl);
    STDMETHOD(SetControl)(     HNODE hNode, LPUNKNOWN pUnkOCX, IUnknown* pUnknown);
    STDMETHOD(InitOCX)(        HNODE hNode, IUnknown* pUnknown);

    STDMETHOD(IsExpandable)(HNODE hNode);
    STDMETHOD(GetConsoleVerb)(HNODE hNode, LPCONSOLEVERB* ppConsoleVerb);
    STDMETHOD(GetDragDropDataObject)(HNODE hNode, BOOL bScope, BOOL bMultiSel,
                                MMC_COOKIE cookie, LPDATAOBJECT* ppDataObject,
                                bool& bCopyAllowed, bool& bMoveAllowed);
    STDMETHOD(GetTaskEnumerator)(HNODE hNode, LPCOLESTR pszTaskGroup,
                                 IEnumTASK** ppEnumTask);
    STDMETHOD(GetListPadInfo)(HNODE hNode, IExtendTaskPad* pExtendTaskPad,
                              LPCOLESTR szTaskGroup,
                              MMC_ILISTPAD_INFO* pIListPadInfo);
    STDMETHOD(UpdateWindowLayout)(LONG_PTR lViewData, long lToolbarsDisplayed);
    STDMETHOD(AddCustomFolderImage)(HNODE hNode, IImageListPrivate* pImageList);
    STDMETHOD(PreLoad)(HNODE hNode);
    STDMETHOD(SetTaskPadList)(HNODE hNode, LPUNKNOWN pUnknown);
    STDMETHOD(SetTaskpad)    (HNODE hNodeSelected, GUID *pGuidTaskpad);
    STDMETHOD(OnCustomizeView) (LONG_PTR lViewData);
    STDMETHOD(SetViewSettings)(int nViewID, HBOOKMARK hbm, HVIEWSETTINGS hvs);
    STDMETHOD(ExecuteScopeItemVerb)(MMC_CONSOLE_VERB verb, HNODE hNode, LPOLESTR lpszNewName);
    STDMETHOD(ExecuteResultItemVerb)( MMC_CONSOLE_VERB verb, HNODE hNode, LPARAM lvData, LPOLESTR lpszNewName);
    STDMETHOD(QueryCompDataDispatch)(PNODE pNode, PPDISPATCH ScopeNodeObject);
    STDMETHOD(QueryComponentDispatch)(HNODE hNode, LPARAM lvData, /*[out]*/ PPDISPATCH SelectedObject);
    STDMETHOD(CreateContextMenu)( PNODE pNode, HNODE hNode, PPCONTEXTMENU ppContextMenu);
    STDMETHOD(CreateSelectionContextMenu)( HNODE hNodeScope, CContextMenuInfo *pContextInfo, PPCONTEXTMENU ppContextMenu);
    // Implementation helpers for Column com object.
    STDMETHOD(ShowColumn)(HNODE hNodeSelected, int iColIndex, bool bShow);
    STDMETHOD(GetSortColumn)(HNODE hNodeSelected, int *piSortCol);
    STDMETHOD(SetSortColumn)(HNODE hNodeSelected, int iSortCol, bool bAscending);
    STDMETHOD(GetProperty)(HNODE hNodeScope, BOOL bForScopeItem, LPARAM resultItemParam, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue);
    STDMETHOD(GetNodetypeForListItem)(HNODE hNodeScope, BOOL bForScopeItem, LPARAM resultItemParam, PBSTR pbstrNodetype);
    STDMETHOD(GetNodeViewExtensions)(/*[in]*/ HNODE hNodeScope, /*[out]*/ CViewExtInsertIterator it);
    STDMETHOD(SaveColumnInfoList) (/*[in]*/HNODE hNode, /*[in]*/const CColumnInfoList& columnsList);
    STDMETHOD(GetPersistedColumnInfoList) (/*[in]*/HNODE hNode, /*[in]*/CColumnInfoList *pColumnsList);
    STDMETHOD(DeletePersistedColumnData) (/*[in]*/HNODE hNode);
    STDMETHOD(DoesAboutExist) (/*[in]*/HNODE hNode, /*[out]*/ bool *pbAboutExists);
    STDMETHOD(ShowAboutInformation) (/*[in]*/HNODE hNode);
    STDMETHOD(ExecuteShellCommand)(/*[in]*/ HNODE hNode, /*[in]*/ BSTR Command, /*[in]*/ BSTR Directory, /*[in]*/ BSTR Parameters, /*[in]*/ BSTR WindowState);
    STDMETHOD(UpdatePasteButton)(/*[in]*/ HNODE hNode, /*[in]*/ BOOL bScope, /*[in]*/ LPARAM lCookie);
    STDMETHOD(QueryPaste)(/*[in]*/ HNODE hNode, /*[in]*/ BOOL bScope, /*[in]*/ LPARAM lCookie, /*[in]*/ IDataObject *pDataObject, /*[out]*/bool& bPasteAllowed, /*[out]*/ bool& bCopyOperatationIsDefault);
    STDMETHOD(QueryPasteFromClipboard)(/*[in]*/ HNODE hNode, /*[in]*/ BOOL bScope, /*[in]*/ LPARAM lCookie, /*[out]*/bool& bPasteAllowed);
    STDMETHOD(Drop) (/*[in]*/HNODE hNode, /*[in]*/BOOL bScope, /*[in]*/LPARAM lCookie, /*[in]*/IDataObject *pDataObjectToPaste, /*[in]*/BOOL bIsDragOperationMove);
    STDMETHOD(Paste) (/*[in]*/HNODE hNode, /*[in]*/BOOL bScope, /*[in]*/LPARAM lCookie);
    STDMETHOD(QueryViewSettingsPersistor) (/*[out]*/IPersistStream** ppStream);
    STDMETHOD(QueryViewSettingsPersistor) (/*[out]*/CXMLObject** ppXMLObject);
    STDMETHOD(DocumentClosing) ();
    STDMETHOD(GetSnapinName)(/*[in]*/HNODE hNode, /*[out]*/LPOLESTR* ppszName,  /*[out]*/ bool& bValidName); // Given the node get the snapin name
    STDMETHOD(IsDummySnapin)(/*[in]*/HNODE hNode, /*[out]*/bool& bDummySnapin); // Given the node see if it is dummy snapin
    STDMETHOD(DoesStandardSnapinHelpExist)(/*[in]*/HNODE hNode, /*[out]*/bool& bStandardHelpExists); // See if the snapin supports standard MMC help (ISnapinHelp interfaces)

    // snapin property access helpers
    static SC ScGetProperty(IDataObject *pDataObject, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue);
    static SC ScGetNodetype(IDataObject *pDataObject, PBSTR pbstrNodetype);

    static SC ScExtractLVData(CNode* pNodeViewOwner,
                              BOOL bScopePaneSelected,
                              LONG_PTR lvData,
                              CNode** ppSelectedNode,
                              BOOL& bScopeItemSelected,
                              MMC_COOKIE& cookie);
    SC        ScInitializeTempVerbSetForMultiSel(CNode *pNode, CTemporaryVerbSet& tempVerb);

// Notify handlers
private:
    void OnSelect(CNode* pNode, BOOL bSelect, SELECTIONINFO* pSelInfo);
    void OnMultiSelect(CNode* pNode, BOOL bSelect);
    void _OnMultiSelect(CNode* pNode, BOOL bSelect);

    HRESULT OnActvate(CNode* pNode, LONG_PTR arg);
    HRESULT OnDblClk(CNode* pNode, LONG_PTR lvData);
    HRESULT OnContextMenu(CNode* pNode, LONG_PTR arg, LPARAM param);
    HRESULT OnCutCopy(CNode* pNode, BOOL bScope, LPARAM param, BOOL bCut);
    HRESULT OnDelete(CNode* pNode, BOOL bScope, LPARAM lvData);
    HRESULT OnExpand(CNode* pNode, BOOL fExpand);
    HRESULT OnExpanded(CNode* pNode);
    HRESULT OnFindResultItem(CNode* pNode, RESULTFINDINFO* pFindInfo, LRESULT* pResult);
    HRESULT OnMinimize(CNode* pNode, LONG_PTR arg);
    HRESULT OnNewNodeUpdate(CNode* pNode, LONG_PTR lFlags);
    HRESULT OnPrint(CNode* pNode, BOOL bScope, LPARAM lvData);
    HRESULT OnProperties(CNode* pNode, BOOL bScope, LPARAM param);
    HRESULT OnNewTaskpadFromHere(CNode* pNode);
    HRESULT OnEditTaskpad(CNode* pNode);
    HRESULT OnDeleteTaskpad(CNode *pNode);
    HRESULT OnRefresh(CNode* pNode, BOOL bScope, LPARAM lvData);
    HRESULT OnRename(CNode* pNode, SELECTIONINFO* pSelInfo, LPOLESTR pszNewName);
    HRESULT OnScopeSelect(CNode* pNode, BOOL bSelect, SELECTIONINFO* pSelInfo);
    HRESULT OnColumnClicked(CNode* pNode, LONG_PTR nCol);
    HRESULT OnContextHelp(CNode* pNode, BOOL bScope, MMC_COOKIE cookie);
    HRESULT OnSnapInHelp(CNode* pNode, BOOL bScope, MMC_COOKIE cookie);
    HRESULT OnFilterChange(CNode* pNode, LONG_PTR Code, LPARAM nCol);
    HRESULT OnFilterBtnClick(CNode* pNode, LONG_PTR nCol, LPRECT pRect);
    HRESULT OnGetPrimaryTask(CNode* pNode, LPARAM param);
    HRESULT OnGetHelpDoc(HELPDOCINFO* pHelpInfo, LPOLESTR* ppszHelpFile);
    HRESULT OnHasHelpDoc(CNode* pNode);
    HRESULT OnUpdateHelpDoc(HELPDOCINFO* pCurDocInfo, HELPDOCINFO* pNewDocInfo);
    HRESULT OnDeleteHelpDoc(HELPDOCINFO* pHelpInfo);

// Helpers
private:

    HRESULT _InitializeNode(CNode* pNode);

    SC      _ScQueryPaste (CNode *pNode, IDataObject *pTargetDataObject,
                           IDataObject *pSourceDataObject,
                           bool bCanSendMMCNQueryPaste2, bool& bPasteAllowed,
                           bool& bCopyOperatationIsDefault);

    SC      ScPaste (HNODE hNode, BOOL bScope, LPARAM lCookie,
                     IDataObject *pDataObjectToPaste, BOOL bDragDrop,
                     BOOL bIsDragOperationCut);

    SC      _ScPaste (CNode *pNode,
                      IDataObject *pTargetDataObject,
                      IDataObject *pSourceDataObject,
                      IDataObject **ppCutDataObject,
                      bool bCutOrMove);

    SC      _ScGetVerbState(CNode* pNode, MMC_CONSOLE_VERB verb, IDataObject* pDOSel,
                            BOOL bScopePane, LPARAM lResultCookie,
                            BOOL bMultiSelect, BOOL& bIsVerbSet);

    CScopeTree*     m_pCScopeTree;
    CNode*          m_pNodeUnderInit;

};  // CNodeCallback


IFramePrivate* GetIFramePrivateFromNode (CNode* pNode);

inline IFramePrivate* GetIFramePrivateFromNode (HNODE hNode)
    { return (GetIFramePrivateFromNode (CNode::FromHandle(hNode))); }

#endif // _MMC_SCOPNDCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\scopndcb.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       scopndcb.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "scopndcb.h"
#include "oncmenu.h"
#include "util.h"
#include "amcmsgid.h"
#include "multisel.h"
#include "nmutil.h"
#include "nodemgr.h"
#include "copypast.h"
#include "regutil.h"
#include "taskenum.h"
#include "nodepath.h"
#include "rsltitem.h"
#include "bookmark.h"
#include "tasks.h"
#include "viewpers.h"
#include "colwidth.h"
#include "conframe.h"
#include "constatbar.h"
#include "about.h"
#include "conview.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//############################################################################
//############################################################################
//
//  Trace Tags
//
//############################################################################
//############################################################################
#ifdef DBG
CTraceTag tagNodeCallback(TEXT("NodeCallback"), TEXT("NodeCallback"));
#endif


void AddSubmenu_CreateNew(IContextMenuProvider* pICMP, BOOL fStaticFolder );
void AddSubmenu_Task(IContextMenuProvider* pICMP );

DEBUG_DECLARE_INSTANCE_COUNTER(CNodeCallback);

#define INVALID_COMPONENTID     -9


void DeleteMultiSelData(CNode* pNode)
{
    ASSERT(pNode != NULL);
    ASSERT(pNode->GetViewData() != NULL);
    CMultiSelection* pMultiSel = pNode->GetViewData()->GetMultiSelection();
    if (pMultiSel != NULL)
    {
        pMultiSel->ReleaseMultiSelDataObject();
        pMultiSel->Release();
        pNode->GetViewData()->SetMultiSelection(NULL);
    }
}

CNodeCallback::CNodeCallback()
    :   m_pCScopeTree(NULL), m_pNodeUnderInit(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CNodeCallback);
}

CNodeCallback::~CNodeCallback()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CNodeCallback);
}

STDMETHODIMP CNodeCallback::Initialize(IScopeTree* pScopeTree)
{
    IF_NULL_RETURN_INVALIDARG(pScopeTree);

    m_pCScopeTree = dynamic_cast<CScopeTree*>(pScopeTree);
    ASSERT(m_pCScopeTree != NULL);

    return S_OK;
}

STDMETHODIMP CNodeCallback::GetImages(HNODE hNode, int* piImage, int* piSelectedImage)
{
    IF_NULL_RETURN_INVALIDARG(hNode);

    // They should ask for at least one of the images.
    if (piImage == NULL && piSelectedImage == NULL)
        return E_INVALIDARG;

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);

    if (piImage != NULL)
        *piImage = pNode->GetMTNode()->GetImage();

    if (piSelectedImage != NULL)
        *piSelectedImage = pNode->GetMTNode()->GetOpenImage();

    return S_OK;
}

STDMETHODIMP CNodeCallback::GetDisplayName(HNODE hNode, tstring& strName)
{
    DECLARE_SC (sc, _T("CNodeCallback::GetDisplayName"));

    /*
     * clear out the output string
     */
    strName.erase();

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers (pNode);
    if (sc)
        return (sc.ToHr());

    strName = pNode->GetDisplayName();
    return (sc.ToHr());
}


STDMETHODIMP CNodeCallback::GetWindowTitle(HNODE hNode, tstring& strTitle)
{
    DECLARE_SC (sc, _T("CNodeCallback::GetWindowTitle"));

    /*
     * clear out the output string
     */
    strTitle.erase();

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers (pNode);
    if (sc)
        return (sc.ToHr());

    CComponent* pCC = pNode->GetPrimaryComponent();
    sc = ScCheckPointers (pCC, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    IDataObjectPtr spdtobj;
    sc = pCC->QueryDataObject(MMC_WINDOW_COOKIE, CCT_UNINITIALIZED, &spdtobj);
    if (sc)
        return (sc.ToHr());

    USES_CONVERSION;
    static CLIPFORMAT cfWindowTitle =
            (CLIPFORMAT) RegisterClipboardFormat(OLE2T(CCF_WINDOW_TITLE));

    sc = ExtractString(spdtobj, cfWindowTitle, strTitle);
    if (sc)
        return (sc.ToHr());

    return (sc.ToHr());
}

inline HRESULT CNodeCallback::_InitializeNode(CNode* pNode)
{
    ASSERT(pNode != NULL);

    m_pNodeUnderInit = pNode;
    HRESULT hr = pNode->InitComponents();
    m_pNodeUnderInit = NULL;
    return hr;
}

STDMETHODIMP CNodeCallback::GetResultPane(HNODE hNode, CResultViewType& rvt, GUID *pGuidTaskpadID)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetResultPane"));

    IF_NULL_RETURN_INVALIDARG(hNode);

    USES_CONVERSION;

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    ASSERT(pNode != NULL);

    if (pNode->IsInitialized() == FALSE)
    {
        sc = _InitializeNode(pNode);
        if(sc)
            return sc.ToHr();
    }

    sc = pNode->ScGetResultPane(rvt, pGuidTaskpadID);
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}

//
// 'hNodeSel' is the curreently selected node in the scope pane. 'lDispInfo' is
// the LV disp info struct.
STDMETHODIMP CNodeCallback::GetDispInfo(HNODE hNodeSel, LV_ITEMW* plvi)
{
    IF_NULL_RETURN_INVALIDARG2(hNodeSel, plvi);

    if (theApp.ProcessingSnapinChanges() == TRUE)
        return E_FAIL;

    // convert to real types
    CNode* pNodeSel = CNode::FromHandle(hNodeSel);

    if (IsBadWritePtr (plvi, sizeof(*plvi)))
        return E_INVALIDARG;

    return pNodeSel->GetDispInfoForListItem(plvi);
}


STDMETHODIMP CNodeCallback::AddCustomFolderImage (HNODE hNode, IImageListPrivate* pImageList)
{
    CNode* pNode = CNode::FromHandle(hNode);
    if (pNode) {
        CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(pNode);
        if (pSINode)
            pSINode->SetResultImageList (pImageList);
    }
    return S_OK;
}

STDMETHODIMP CNodeCallback::GetState(HNODE hNode, UINT* pnState)
{
    IF_NULL_RETURN_INVALIDARG2(hNode, pnState);

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);

    *pnState = pNode->GetMTNode()->GetState();

    return S_OK;
}

STDMETHODIMP CNodeCallback::Notify(HNODE hNode, NCLBK_NOTIFY_TYPE event,
                                   LONG_PTR arg, LPARAM param)
{
    HRESULT hr = S_OK;

    if (hNode == NULL)
    {
        switch (event)
        {
        case NCLBK_CONTEXTMENU:
            // Process further.
            break;

        case NCLBK_GETHELPDOC:
            return OnGetHelpDoc((HELPDOCINFO*)arg, (LPOLESTR*)param);

        case NCLBK_UPDATEHELPDOC:
            return OnUpdateHelpDoc((HELPDOCINFO*)arg, (HELPDOCINFO*)param);

        case NCLBK_DELETEHELPDOC:
            return OnDeleteHelpDoc((HELPDOCINFO*)arg);

            // When the view is closed and NCLBK_SELECT is sent with HNODE NULL (as
            // there is no selected node) handle this case.
        case NCLBK_SELECT:
            return S_OK;

        default:
            return E_INVALIDARG;
        }
    }

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);

    if (m_pNodeUnderInit && pNode && (m_pNodeUnderInit == pNode))
        return E_FAIL;

    // See if snapin-cache is being modified.
    if (theApp.ProcessingSnapinChanges() == TRUE)
    {
        // If it is selection/de-selection of node then do not return error
        // after the modifications are done (for snapin-cache) the node will
        // be selected.
        if ( (event == NCLBK_SELECT) ||
             (event == NCLBK_MULTI_SELECT) )
             return S_OK;
        else
            return E_FAIL;
    }

    switch (event)
    {
    case NCLBK_ACTIVATE:
        hr = OnActvate(pNode, arg);
        break;

    case NCLBK_CACHEHINT:
        pNode->OnCacheHint(arg, param);
        break;

    case NCLBK_CLICK:
        ASSERT(0);
        break;

    case NCLBK_CONTEXTMENU:
        hr = OnContextMenu(pNode, arg, param);
        break;

    case NCLBK_DBLCLICK:
        hr = OnDblClk(pNode, arg);
        break;

    case NCLBK_CUT:
    case NCLBK_COPY:
        OnCutCopy(pNode, static_cast<BOOL>(arg), param, (event == NCLBK_CUT));
        break;

    case NCLBK_DELETE:
        {
            hr = OnDelete(pNode, arg, param);

            // 5. Purge the snapin cache
            CSnapInsCache* pSnapInCache = theApp.GetSnapInsCache();
            ASSERT(pSnapInCache != NULL);
            if (pSnapInCache != NULL)
                pSnapInCache->Purge();
        }
        break;

    case NCLBK_EXPAND:
        hr = OnExpand(pNode, arg);
        break;

    case NCLBK_EXPANDED:
        hr = OnExpanded(pNode);
        break;

    case NCLBK_GETEXPANDEDVISUALLY:
        hr = (pNode->WasExpandedVisually() == true) ? S_OK : S_FALSE;
        break;

    case NCLBK_SETEXPANDEDVISUALLY:
        pNode->SetExpandedVisually(static_cast<bool>(arg));
        break;

    case NCLBK_PROPERTIES:
        hr = OnProperties(pNode, static_cast<BOOL>(arg), param);
        break;

    case NCLBK_REFRESH:
        hr = OnRefresh(pNode, static_cast<BOOL>(arg), param);
        break;

    case NCLBK_NEW_TASKPAD_FROM_HERE:
        hr = OnNewTaskpadFromHere(pNode);
        break;

    case NCLBK_EDIT_TASKPAD:
        hr = OnEditTaskpad(pNode);
        break;

    case NCLBK_DELETE_TASKPAD:
        hr = OnDeleteTaskpad(pNode);
        break;

    case NCLBK_PRINT:
        hr = OnPrint(pNode, static_cast<BOOL>(arg), param);
        break;

    case NCLBK_NEW_NODE_UPDATE:
        hr = OnNewNodeUpdate(pNode, arg);
        break;

    case NCLBK_RENAME:
        hr = OnRename(pNode, reinterpret_cast<SELECTIONINFO*>(arg),
                      reinterpret_cast<LPOLESTR>(param));
        break;

    case NCLBK_MULTI_SELECT:
        OnMultiSelect(pNode, static_cast<BOOL>(arg));
        break;

    case NCLBK_SELECT:
        OnSelect(pNode, static_cast<BOOL>(arg),
                 reinterpret_cast<SELECTIONINFO*>(param));
        break;

    case NCLBK_FINDITEM:
        OnFindResultItem(pNode, reinterpret_cast<RESULTFINDINFO*>(arg),
                         reinterpret_cast<LRESULT*>(param));
        break;

    case NCLBK_COLUMN_CLICKED:
        hr = OnColumnClicked(pNode, param);
        break;

    case NCLBK_CONTEXTHELP:
        hr = OnContextHelp(pNode, static_cast<BOOL>(arg), param);
        break;

    case NCLBK_SNAPINHELP:
        hr = OnSnapInHelp(pNode, static_cast<BOOL>(arg), param);
        break;

    case NCLBK_FILTER_CHANGE:
        hr = OnFilterChange(pNode, arg, param);
        break;

    case NCLBK_FILTERBTN_CLICK:
        hr = OnFilterBtnClick(pNode, arg, reinterpret_cast<LPRECT>(param));
        break;

    case NCLBK_TASKNOTIFY:
        pNode->OnTaskNotify(arg, param);
        break;

    case NCLBK_GETPRIMARYTASK:
        hr = OnGetPrimaryTask (pNode, param);
        break;

    case NCLBK_MINIMIZED:
        hr = OnMinimize (pNode, arg);
        break;

    case NCLBK_LISTPAD:
        hr = pNode->OnListPad(arg, param);
        break;

    case NCLBK_WEBCONTEXTMENU:
        pNode->OnWebContextMenu();
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    return hr;
}


STDMETHODIMP CNodeCallback::GetMTNode(HNODE hNode, HMTNODE* phMTNode)
{
    IF_NULL_RETURN_INVALIDARG2(hNode, phMTNode);

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);

    *phMTNode = CMTNode::ToHandle(pNode->GetMTNode());

    return S_OK;
}

STDMETHODIMP CNodeCallback::SetResultItem(HNODE hNode, HRESULTITEM hri)
{
    IF_NULL_RETURN_INVALIDARG(hNode);

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    pNode->SetResultItem(hri);
    return S_OK;
}

STDMETHODIMP CNodeCallback::GetResultItem(HNODE hNode, HRESULTITEM* phri)
{
    IF_NULL_RETURN_INVALIDARG(hNode);

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    *phri = pNode->GetResultItem();
    return S_OK;
}

STDMETHODIMP CNodeCallback::GetMTNodeID(HNODE hNode, MTNODEID* pnID)
{
    IF_NULL_RETURN_INVALIDARG(pnID);

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);

    *pnID = pNode->GetMTNode()->GetID();

    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::IsTargetNodeOf
 *
 * PURPOSE: Is one node a target of another
 *
 * PARAMETERS:
 *    HNODE  hNode :    The node that contains the target
 *    HNODE  hTestNode : The alleged target
 *
 * RETURNS:
 *    STDMETHODIMP
 *          S_OK    - yes
 *          S_FALSE - uses a different target node
 *          E_FAIL  - doesn't use a target node
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP CNodeCallback::IsTargetNodeOf(HNODE hNode, HNODE hTestNode)
{
    ASSERT(hNode && hTestNode);

    CNode* pNode = CNode::FromHandle(hNode);
    CNode* pTestNode = CNode::FromHandle(hTestNode);
    ASSERT(pNode);

    return pNode->IsTargetNode(pTestNode);
}


STDMETHODIMP CNodeCallback::GetPath(HNODE hNode, HNODE hRootNode,
                                    LPBYTE pbm)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetPath"));

    sc = ScCheckPointers((PVOID)hNode, (PVOID)hRootNode, pbm);
    if(sc)
        return sc.ToHr();

    // convert to real type
    CNode* pNode     = CNode::FromHandle(hNode);
    CNode* pRootNode = CNode::FromHandle(hRootNode);
    CBookmark* pbmOut   = reinterpret_cast<CBookmark *>(pbm);

    CBookmarkEx bm;

    sc = bm.ScInitialize(pNode->GetMTNode(), pRootNode->GetMTNode(), true).ToHr();
    if(sc)
        return sc.ToHr();

    // set the out parameter.
    *pbmOut = bm;

    return sc.ToHr();
}

STDMETHODIMP CNodeCallback::GetStaticParentID(HNODE hNode, MTNODEID* pnID)
{
    IF_NULL_RETURN_INVALIDARG2(hNode, pnID);

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    CMTNode* pMTNode = pNode->GetMTNode();
    ASSERT(pMTNode != NULL);

    while (pMTNode != NULL && pMTNode->IsStaticNode() == FALSE)
    {
        pMTNode = pMTNode->Parent();
    }

    ASSERT(pMTNode != NULL);

    if (pMTNode != NULL)
    {
        *pnID = pMTNode->GetID();
        return S_OK;
    }

    return E_UNEXPECTED;
}

// The path for the node is stored in pphMTNode. The path is an array of
// HMTNODE's starting from the console root, followed by its child node and
// continuing in this fashion till the HMTNODE of the root node.
STDMETHODIMP CNodeCallback::GetMTNodePath(HNODE hNode, HMTNODE** pphMTNode,
                                          long* plLength)
{
    IF_NULL_RETURN_INVALIDARG3(hNode, pphMTNode, plLength);

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);

    CMTNode* pMTNode = pNode->GetMTNode();
    pMTNode = pMTNode->Parent(); // skip this node

    for (*plLength = 0; pMTNode != NULL; pMTNode = pMTNode->Parent())
        ++(*plLength);

    if (*plLength != 0)
    {
        HMTNODE* phMTNode = (HMTNODE*)CoTaskMemAlloc(sizeof(HMTNODE) *
                                                              (*plLength));
        if (phMTNode == NULL)
        {
            CHECK_HRESULT(E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }

        *pphMTNode = phMTNode;

        pMTNode = pNode->GetMTNode();
        pMTNode = pMTNode->Parent(); // skip this node

        phMTNode = phMTNode + (*plLength - 1);

        for (; pMTNode != NULL; pMTNode = pMTNode->Parent(), --phMTNode)
            *phMTNode = CMTNode::ToHandle(pMTNode);

        ASSERT(++phMTNode == *pphMTNode);
    }
    else
    {
        pphMTNode = NULL;
    }

    return S_OK;
}


/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::GetNodeOwnerID
 *
 * PURPOSE: Get the ID of the snap-in component that owns this node.
 *          If not a snap-in owned node, TVOWNED_MAGICWORD is returned.
 *
 * PARAMETERS:
 *    HNODE  hNode :  Node to query
 *    COMPONENTID* :  ptr to returned ID
 *
 * RETURNS:
 *    STDMETHODIMP
 *          S_OK         - ID returned
 *          E_INVALIDARG -
 *          E_FAIL       - probably an invalid hNode
 *
 *+-------------------------------------------------------------------------*/

/*******************************************************************************
 * >>>>>>>>>>>>>> READ THIS BEFORE USING GetNodeOwnerID <<<<<<<<<<<<<<<<<<<<<<<
 *
 * This method differs from the GetOwnerID method exposed by CNode (and CMTNode)
 * in that it returns a zero ID for snap-in static nodes, indicating that the
 * owner is the snap-in primary component. The CNode method returns
 * TVOWNED_MAGICWORD for snap-in static nodes, inidcating MMC ownership. For
 * most purposes the zero ID is more appropriate and I think the node method
 * should be changed. This requires looking at all uses of the owner ID and
 * verifying nothing will break.    rswaney 5/5/99
 *******************************************************************************/

STDMETHODIMP CNodeCallback::GetNodeOwnerID(HNODE hNode, COMPONENTID* pOwnerID)
{
    IF_NULL_RETURN_INVALIDARG2(hNode, pOwnerID);

    CNode* pNode = CNode::FromHandle(hNode);

    if (pNode->IsStaticNode())
        *pOwnerID = 0;
    else
        *pOwnerID = pNode->GetOwnerID();

    return S_OK;
}


STDMETHODIMP CNodeCallback::GetNodeCookie(HNODE hNode, MMC_COOKIE* pCookie)
{
    IF_NULL_RETURN_INVALIDARG2(hNode, pCookie);

    // only dynamic nodes have cookies
    CNode* pNode = CNode::FromHandle(hNode);
    if (!pNode->IsDynamicNode())
        return E_FAIL;

    *pCookie = pNode->GetUserParam();

    return S_OK;
}


/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::GetControl
 *
 * PURPOSE:       See if there is a OCX with given CLSID for the given node.
 *                If so return it.
 *
 * PARAMETERS:
 *    HNODE       hNode :
 *    CLSID       clsid :
 *    IUnknown ** ppUnkControl :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CNodeCallback::GetControl(HNODE hNode, CLSID clsid, IUnknown **ppUnkControl)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetControl"));

    sc = ScCheckPointers((void *)hNode, ppUnkControl);
    if(sc)
        return sc.ToHr();

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    *ppUnkControl = pNode->GetControl(clsid);
    if(!*ppUnkControl)
        return sc.ToHr();

    // addref the interface for the client.

    (*ppUnkControl)->AddRef();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::SetControl
 *
 * PURPOSE:      For the given node & clsid of OCX save the OCX window IUnknown*.
 *
 * PARAMETERS:
 *    HNODE     hNode :
 *    CLSID     clsid :
 *    IUnknown* pUnknown :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CNodeCallback::SetControl(HNODE hNode, CLSID clsid, IUnknown* pUnknown)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::SetControl"));
    sc = ScCheckPointers((void*)hNode, pUnknown);
    if (sc)
        return sc.ToHr();

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    pNode->SetControl(clsid, pUnknown);

    return sc.ToHr();

}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::GetControl
//
//  Synopsis:    For given node & IUnknown* of OCX get the OCX wrapper if one exists.
//
//  Arguments:   [hNode]
//               [pUnkOCX]
//               [ppUnkControl]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::GetControl (HNODE hNode, LPUNKNOWN pUnkOCX, IUnknown **ppUnkControl)
{
    DECLARE_SC(sc, _T("CNodeCallback::GetControl"));
    sc = ScCheckPointers((void*)hNode, pUnkOCX, ppUnkControl);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    *ppUnkControl = pNode->GetControl(pUnkOCX);
    if(!*ppUnkControl)
        return sc.ToHr();

    // addref the interface for the client.

    (*ppUnkControl)->AddRef();


    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      SetControl
//
//  Synopsis:    For given node & IUnknown of OCX save the IUnknown of
//               OCX wrapper.
//
//  Arguments:   [hNode]
//               [pUnkOCX]
//               [pUnknown]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::SetControl (HNODE hNode, LPUNKNOWN pUnkOCX, IUnknown* pUnknown)
{
    DECLARE_SC(sc, _T("SetControl"));
    sc = ScCheckPointers((void*) hNode, pUnkOCX, pUnknown);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    pNode->SetControl(pUnkOCX, pUnknown);

    return (sc.ToHr());
}



STDMETHODIMP
CNodeCallback::InitOCX(HNODE hNode, IUnknown* pUnknown)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::InitOCX"));

    sc = ScCheckPointers((void *)hNode);
    if(sc)
        return sc.ToHr();

    CNode* pNode = CNode::FromHandle(hNode);
    sc = pNode->OnInitOCX(pUnknown);

    return sc.ToHr();
}

/////////////////////////////////////////////////////////////////////////////
// Notify handlers


HRESULT CNodeCallback::OnActvate(CNode* pNode, LONG_PTR arg)
{
    DECLARE_SC (sc, _T("CNodeCallback::OnActvate"));
    sc = ScCheckPointers (pNode);
    if (sc)
        return (sc.ToHr());

    return pNode->OnActvate(arg);
}


HRESULT CNodeCallback::OnMinimize(CNode* pNode, LONG_PTR arg)
{
    DECLARE_SC (sc, _T("CNodeCallback::OnMinimize"));
    sc = ScCheckPointers (pNode);
    if (sc)
        return (sc.ToHr());

    return pNode->OnMinimize(arg);
}

HRESULT CNodeCallback::OnDelete(CNode* pNode, BOOL bScopePaneSelected, LPARAM lvData)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnDelete"));

    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, bScopePaneSelected, lvData,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // If result-pane cookie should be valid.
    ASSERT( (bScopeItemSelected) || cookie != LVDATA_ERROR);
    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return E_FAIL;

    HRESULT hr = S_OK;

    if (!bScopeItemSelected)
    {
        CMultiSelection* pMultiSel = pSelectedNode->GetViewData()->GetMultiSelection();
        if (pMultiSel != NULL)
        {
            ASSERT(lvData == LVDATA_MULTISELECT);
            pMultiSel->ScVerbInvoked(MMC_VERB_DELETE);
            return S_OK;
        }
        else
        {
            ASSERT(lvData != LVDATA_MULTISELECT);

            CComponent* pCC = pSelectedNode->GetPrimaryComponent();
            ASSERT(pCC != NULL);

            if (pCC != NULL)
            {
                if (IS_SPECIAL_LVDATA(lvData))
                {
                    LPDATAOBJECT pdobj = (lvData == LVDATA_CUSTOMOCX) ?
                                            DOBJ_CUSTOMOCX : DOBJ_CUSTOMWEB;

                    hr = pCC->Notify(pdobj, MMCN_DELETE, 0, 0);
                    CHECK_HRESULT(hr);
                }
                else
                {
                    IDataObjectPtr spdtobj;
                    hr = pCC->QueryDataObject(cookie, CCT_RESULT, &spdtobj);

                    ASSERT( NULL != pCC->GetIComponent() );

                    if (SUCCEEDED(hr))
                    {
                        hr = pCC->Notify(spdtobj, MMCN_DELETE, 0, 0);
                        CHECK_HRESULT(hr);
                    }
                }
            }
        }
    }
    else
    {
        CMTNode* pMTNode = pSelectedNode->GetMTNode();
        if (pMTNode->Parent() == NULL)
            return S_FALSE;

        if (pSelectedNode->IsStaticNode() == TRUE) // All static nodes can be deleted
        {
            ASSERT(m_pCScopeTree != NULL);

            if (pMTNode->DoDelete(pSelectedNode->GetViewData()->GetMainFrame()) == false)
                return S_FALSE;

            // Delete storage
            hr = pMTNode->DestroyElements();
            ASSERT(SUCCEEDED(hr));

            // Delete the node.
            m_pCScopeTree->DeleteNode(pMTNode);

        }
        else // Tell the snapin that put up the dynamic node to delete.
        {
            CComponentData* pCD = pMTNode->GetPrimaryComponentData();
            ASSERT(pCD != NULL);

            IDataObjectPtr spDataObject;
            hr = pCD->QueryDataObject(pMTNode->GetUserParam(), CCT_SCOPE, &spDataObject);
            CHECK_HRESULT(hr);

            ASSERT( NULL != pCD->GetIComponentData() );

            if (hr == S_OK)
            {
                hr = pCD->Notify(spDataObject, MMCN_DELETE, 0, 0);
                CHECK_HRESULT(hr);
            }
        }
    }

    return hr;
}

HRESULT CNodeCallback::OnFindResultItem(CNode* pNode, RESULTFINDINFO* pFindInfo, LRESULT* pResult)
{
    IF_NULL_RETURN_INVALIDARG3(pNode, pFindInfo, pResult);

    // init result to -1 (item not found)
    *pResult = -1;

    CComponent* pCC = pNode->GetPrimaryComponent();
    ASSERT(pCC != NULL);
    if (pCC == NULL)
        return E_FAIL;

    IResultOwnerDataPtr spIResultOwnerData = pCC->GetIComponent();
    if (spIResultOwnerData == NULL)
        return S_FALSE;

    return spIResultOwnerData->FindItem(pFindInfo, reinterpret_cast<int*>(pResult));
}



HRESULT CNodeCallback::OnRename(CNode* pNode, SELECTIONINFO *pSelInfo,
                                LPOLESTR pszNewName)
{
    HRESULT hr = S_OK;

    if (pSelInfo->m_bScope)
    {
        CMTNode* pMTNode = pNode->GetMTNode();

        hr = pMTNode->OnRename(1, pszNewName);
    }
    else
    {
        CComponent* pCC = pNode->GetPrimaryComponent();
        ASSERT(pCC != NULL);
        if (pCC != NULL)
        {
            IDataObjectPtr spDataObject;
            hr = pCC->QueryDataObject(pSelInfo->m_lCookie, CCT_RESULT,
                                      &spDataObject);
            if (FAILED(hr))
                return hr;

            hr = pCC->Notify(spDataObject, MMCN_RENAME, 1,
                             reinterpret_cast<LPARAM>(pszNewName));
            CHECK_HRESULT(hr);
            return hr;
        }
    }

    if (hr == S_OK)
    {
        if (pNode->IsStaticNode() == TRUE) {
            USES_CONVERSION;
            pNode->SetDisplayName( W2T(pszNewName) );
        }

        // Now inform the views to modify as needed.
        SViewUpdateInfo vui;
        // Snapin nodes result pane will be handled by the snapins
        vui.flag = VUI_REFRESH_NODE;
        pNode->GetMTNode()->CreatePathList(vui.path);
        m_pCScopeTree->UpdateAllViews(VIEW_UPDATE_MODIFY,
                                      reinterpret_cast<LPARAM>(&vui));
    }

    return hr;
}

HRESULT CNodeCallback::OnNewNodeUpdate(CNode* pNode, LONG_PTR lFlags)
{
    pNode->GetMTNode()->SetPropertyPageIsDisplayed(FALSE);

    // Inform the views to modify.
    SViewUpdateInfo vui;
    vui.flag = lFlags;
    pNode->GetMTNode()->CreatePathList(vui.path);
    m_pCScopeTree->UpdateAllViews(VIEW_UPDATE_MODIFY,
                                  reinterpret_cast<LPARAM>(&vui));
    return S_OK;
}

HRESULT CNodeCallback::OnExpand(CNode* pNode, BOOL fExpand)
{
    HRESULT hr = S_OK;
    ASSERT(pNode != 0);

    // initialize the node if needed.
    if (  fExpand && (pNode->WasExpandedAtLeastOnce() == FALSE)  &&
                     (pNode->IsInitialized() == FALSE))
    {
        hr = _InitializeNode(pNode);
        if ((FAILED(hr)))
        {
            return hr;
        }
    }

    return pNode->OnExpand(fExpand);
}

HRESULT CNodeCallback::OnExpanded(CNode* pNode)
{
    ASSERT(pNode != 0);

    pNode->SetExpandedAtLeastOnce();

    return S_OK;
}

HRESULT CNodeCallback::OnScopeSelect(CNode* pNode, BOOL bSelect,
                                     SELECTIONINFO* pSelInfo)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnScopeSelect"));
    sc = ScCheckPointers(pNode, pSelInfo);
    if (sc)
        return sc.ToHr();

    // clear out the the status bar text if we're deselecting a node
    if (! bSelect)
    {
        CViewData *pViewData = pNode->GetViewData();
        sc = ScCheckPointers(pViewData, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CConsoleStatusBar* pStatusBar = pViewData->GetStatusBar();

        if (pStatusBar != NULL)
            pStatusBar->ScSetStatusText (NULL);
    }

    if (pNode->IsInitialized() == FALSE)
    {
        sc = _InitializeNode(pNode);
        if (sc)
            return sc.ToHr();
    }

    sc = pNode->OnScopeSelect(bSelect, pSelInfo);
    if(sc)
        return sc.ToHr();


#ifdef DBG
    if (bSelect)
        Dbg(DEB_USER11, _T("Selecting %s node."), pNode->GetDisplayName());
#endif

    return sc.ToHr();
}

STDMETHODIMP CNodeCallback::SetTaskPadList(HNODE hNode, LPUNKNOWN pUnknown)
{
    IFramePrivate* pFramePrivate = GetIFramePrivateFromNode (hNode);

    if (pFramePrivate == NULL)
        return E_UNEXPECTED;

    return (pFramePrivate->SetTaskPadList(pUnknown));
}

IFramePrivate* GetIFramePrivateFromNode (CNode* pNode)
{
    if (pNode == NULL)
        return (NULL);

    return pNode->GetIFramePrivate();
}

void CNodeCallback::OnMultiSelect(CNode* pNode, BOOL bSelect)
{
    Trace(tagNodeCallback, _T("----------------->>>>>>> MULTI_SELECT<%d>\n"), bSelect);
    SC sc;
    CViewData* pViewData = NULL;

    if (NULL == pNode)
    {
        sc = E_UNEXPECTED;
        goto Error;
    }

    pViewData = pNode->GetViewData();
    if (NULL == pViewData)
    {
        sc = E_UNEXPECTED;
        goto Error;
    }

    if (pViewData->IsVirtualList())
    {
        if (bSelect == TRUE)
            DeleteMultiSelData(pNode);
    }

    _OnMultiSelect(pNode, bSelect);
    if (bSelect == FALSE)
        DeleteMultiSelData(pNode);

    // Update the std-verb tool-buttons.
    sc = pViewData->ScUpdateStdbarVerbs();
    if (sc)
        goto Error;

    pViewData->UpdateToolbars(pViewData->GetToolbarsDisplayed());

Cleanup:
    return;
Error:
    TraceError (_T("CNodeCallback::OnMultiSelect"), sc);
    goto Cleanup;
}

void CNodeCallback::_OnMultiSelect(CNode* pNode, BOOL bSelect)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::_OnMultiSelect"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return;

    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return;

    CMultiSelection* pMultiSelection = pNode->GetViewData()->GetMultiSelection();

    if (pMultiSelection)
    {
        if (pMultiSelection->IsInUse())
            return;
        else
        {
            /*
             * If result pane items are selected by dragging a mouse (that forms Marquee)
             * or if snapin sets items to selected state then the items are selected one
             * by one. That is multi-select for 1 item, multi-select for 2 items and so-on.
             * There is no deselect inbetween, so if we already have a multiselection object
             * for 2 items then when we get multi-select for 3 items we need to destroy multiselection
             * object for 2 items. This is done below.
             *
             */
            DeleteMultiSelData(pNode);
            pMultiSelection = NULL;
        }
    }

    // set standard bars
    CVerbSet* pVerbSet = dynamic_cast<CVerbSet*>(pViewData->GetVerbSet());
    sc = ScCheckPointers(pVerbSet, E_UNEXPECTED);
    if (sc)
        return;

    sc = pVerbSet->ScInitializeForMultiSelection(pNode, bSelect);
    if (sc)
        return;

    if (pMultiSelection == NULL)
    {
        if (bSelect == FALSE)
            return;

        CComponentPtrArray* prgComps = new CComponentPtrArray;
        if (pNode->IsInitialized() == FALSE)
        {
            sc = _InitializeNode(pNode);
            if (sc)
                return;
        }

        // Create CMultiSelection
        pMultiSelection = new CMultiSelection(pNode);
        sc = ScCheckPointers(pMultiSelection, E_OUTOFMEMORY);
        if (sc)
            return;

        sc = pMultiSelection->Init();
        if (sc)
            return;

        pViewData->SetMultiSelection(pMultiSelection);
    }

    pMultiSelection->SetScopeTree(m_pCScopeTree);

    IDataObjectPtr spdobj;
    sc = pMultiSelection->GetMultiSelDataObject(&spdobj);
    if (sc)
        return;

    sc = ScCheckPointers(spdobj, E_UNEXPECTED);
    if (sc)
        return;

    // give the scope item a chance to do any initialization that it needs.
    // For instance, the console taskpad uses this opportunity to gather information
    // about the selected item's context menu.
    SELECTIONINFO SelInfo;
    SelInfo.m_lCookie = LVDATA_MULTISELECT;

    //  Inform control bars of selection change.
    CControlbarsCache* pCtrlbarsCache =
        dynamic_cast<CControlbarsCache*>(pNode->GetControlbarsCache());
    sc = ScCheckPointers(pCtrlbarsCache, E_UNEXPECTED);
    if (sc)
        return;

    pCtrlbarsCache->OnMultiSelect(pNode, pMultiSelection, spdobj, bSelect);

    sc = pVerbSet->ScComputeVerbStates();
    if (sc)
        return;
}

void CNodeCallback::OnSelect(CNode* pNode, BOOL bSelect, SELECTIONINFO* pSelInfo)
{
    Trace(tagNodeCallback, _T("----------------->>>>>>> SELECT<%d>\n"), bSelect);
    SC sc;
    CViewData* pViewData = NULL;

    if (pSelInfo == NULL)
    {
        sc = E_UNEXPECTED;
        goto Error;
    }

    Trace(tagNodeCallback, _T("====>> NCLBK_SELECT<%d, %d, %c>\n"), pSelInfo->m_bScope, bSelect, pSelInfo->m_bDueToFocusChange ? _T('F') : _T('S'));

    if (NULL == pNode)
    {
        sc = E_UNEXPECTED;
        goto Error;
    }

    pViewData = pNode->GetViewData();
    if (NULL == pViewData)
    {
        sc = E_UNEXPECTED;
        goto Error;
    }

    DeleteMultiSelData(pNode);

    if (!bSelect)
    {
        // Reset controlbars
        pNode->ResetControlbars(bSelect, pSelInfo);

        // Reset standard verbs
        sc = pNode->ScInitializeVerbs(bSelect, pSelInfo);
        if (sc)
            sc.TraceAndClear();
    }

    // For scoe sel change reset result pane.
    if (pSelInfo->m_bScope == TRUE && pSelInfo->m_bDueToFocusChange == FALSE)
    {
        sc = OnScopeSelect(pNode, bSelect, pSelInfo);
        if (sc)
            goto Error;
    }

    if (bSelect)
    {
        // Reset controlbars
        pNode->ResetControlbars(bSelect, pSelInfo);

        // Reset standard verbs
        sc = pNode->ScInitializeVerbs(bSelect, pSelInfo);
        if (sc)
            sc.TraceAndClear();
    }

    // Update the std-verb tool-buttons.
    sc = pViewData->ScUpdateStdbarVerbs();

    // Dummy block
    {
        // Update the paste button
        LPARAM lvData = pSelInfo->m_lCookie;

        BOOL   bScopePaneSelected = pSelInfo->m_bScope || pSelInfo->m_bBackground;

        sc = UpdatePasteButton(CNode::ToHandle(pNode), bScopePaneSelected, lvData);
        if (sc)
            goto Error;

        // Update toolbars.
        pViewData->UpdateToolbars(pViewData->GetToolbarsDisplayed());
    }

Cleanup:
    return;
Error:
    TraceError (_T("CNodeCallback::OnSelect"), sc);
    goto Cleanup;
}


HRESULT CNodeCallback::OnDblClk(CNode* pNode, LONG_PTR lvData)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnDblClk"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    BOOL   bScopePaneSelected = FALSE;

    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, bScopePaneSelected, lvData,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // If result-pane cookie should be valid.
    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return (sc = E_FAIL).ToHr();

    // Ignore double-click on LV background.
    if (lvData == LVDATA_BACKGROUND)
        return sc.ToHr();

    CComponent* pCC = pSelectedNode->GetPrimaryComponent();
    sc = ScCheckPointers(pCC, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Get the dataobject of the item which was double-clicked.
    IDataObjectPtr spdtobj;

    if (!bScopeItemSelected) // leaf item
    {
        sc = pCC->QueryDataObject(cookie, CCT_RESULT, &spdtobj);

        if (sc)
        {
            sc.TraceAndClear();
            return sc.ToHr();
        }
    }
    else
    {
        sc = pSelectedNode->QueryDataObject(CCT_SCOPE, &spdtobj);
        if (sc)
        {
            sc.TraceAndClear();
            return sc.ToHr();
        }
    }

    sc = pCC->Notify(spdtobj, MMCN_DBLCLICK, 0, 0);
    if (sc)
        sc.TraceAndClear();

    // Snapin has asked us to do default verb action, so findout default verb.
    if (sc == S_FALSE)
    {
        CViewData *pViewData = pSelectedNode->GetViewData();
        sc = ScCheckPointers(pViewData, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CVerbSet* pVerbSet = dynamic_cast<CVerbSet*>(pViewData->GetVerbSet());
        sc = ScCheckPointers(pVerbSet, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        MMC_CONSOLE_VERB defaultVerb = MMC_VERB_NONE;
        pVerbSet->GetDefaultVerb(&defaultVerb);
        if (defaultVerb == MMC_VERB_OPEN)
        {
            return S_FALSE;
        }
        else if (defaultVerb == MMC_VERB_PROPERTIES)
        {
            OnProperties(pNode, bScopePaneSelected, lvData);
        }
    }

    return S_OK;
}

HRESULT CNodeCallback::OnContextMenu(CNode* pNode, LONG_PTR arg, LPARAM param)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnContextMenu"));

    ASSERT(param != NULL);
    CContextMenuInfo& contextInfo = *reinterpret_cast<CContextMenuInfo*>(param);

    BOOL b = static_cast<BOOL>(arg);

    if ((pNode != NULL) && !pNode->IsInitialized())
    {
        sc = pNode->InitComponents();
        if(sc)
            return sc.ToHr();
    }

    // Create a CContextMenu and initialize it.
    CContextMenu * pContextMenu = NULL;
    ContextMenuPtr spContextMenu;

    sc = CContextMenu::ScCreateInstance(&spContextMenu, &pContextMenu);
    if(sc)
        return sc.ToHr();

    sc = ScCheckPointers(pContextMenu, spContextMenu.GetInterfacePtr(), E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pContextMenu->ScInitialize(pNode, this, m_pCScopeTree, contextInfo);
    if(sc)
        return sc.ToHr();

    sc = pContextMenu->Display(b);
    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::CreateContextMenu
 *
 * PURPOSE: Creates a context menu for the specified node.
 *
 * PARAMETERS:
 *    PNODE          pNode :
 *    PPCONTEXTMENU  ppContextMenu : [OUT]: The context menu structure.
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CNodeCallback::CreateContextMenu( PNODE pNode,  HNODE hNode, PPCONTEXTMENU ppContextMenu)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::CreateContextMenu"));

    sc = ScCheckPointers(pNode, ppContextMenu);
    if(sc)
        return sc.ToHr();

    sc = CContextMenu::ScCreateContextMenu(pNode, hNode, ppContextMenu, this, m_pCScopeTree);

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::CreateSelectionContextMenu
 *
 * PURPOSE: Creates a context menu for the current selection in the result pane.
 *
 * PARAMETERS:
 *    HNODE              hNodeScope :
 *    CContextMenuInfo * pContextInfo :
 *    PPCONTEXTMENU      ppContextMenu :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CNodeCallback::CreateSelectionContextMenu( HNODE hNodeScope, CContextMenuInfo *pContextInfo, PPCONTEXTMENU ppContextMenu)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::CreateSelectionContextMenu"));

    sc = CContextMenu::ScCreateSelectionContextMenu(hNodeScope, pContextInfo, ppContextMenu, this, m_pCScopeTree);
    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::GetProperty
 *
 * PURPOSE:  Returns the specified property for the specified list item by calling
 *           IDataObject::GetData using a STREAM medium on the node's data
 *           object.
 *
 * PARAMETERS:
 *    HNODE   hNodeScope :  The parent scope item
 *    BOOL    bForScopeItem :  TRUE if the list item is a scope item in the list.
 *    LPARAM  resultItemParam : The LPARAM of the result item
 *    BSTR    bstrPropertyName : The name of the clipboard format.
 *    PBSTR   pbstrPropertyValue :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CNodeCallback::GetProperty(HNODE hNodeScope, BOOL bForScopeItem, LPARAM resultItemParam, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetProperty"));

    // check parameters
    sc = ScCheckPointers(bstrPropertyName);
    if(sc)
        return sc.ToHr();

    // initialize out parameter
    *pbstrPropertyValue = NULL;

    // convert the HNODE to a CNode *
    CNode *pNodeScope = CNode::FromHandle(hNodeScope);

    sc = ScCheckPointers(pNodeScope);
    if(sc)
        return sc.ToHr();

    // create a data object for the specified item
    IDataObjectPtr spDataObject;

    bool bScopeItem;
    sc = pNodeScope->ScGetDataObject(bForScopeItem, resultItemParam, bScopeItem, &spDataObject);
    if(sc)
        return sc.ToHr();

    // try to get the propeorty from the INodeProperties interface
    sc = pNodeScope->ScGetPropertyFromINodeProperties(spDataObject, bForScopeItem, resultItemParam, bstrPropertyName, pbstrPropertyValue);
    if( (!sc.IsError()) && (sc.ToHr() != S_FALSE)   ) // got it, exit
        return sc.ToHr();

    // didn't find it, continue
    sc.Clear();

    // get the property from data object
    sc = ScGetProperty(spDataObject, bstrPropertyName, pbstrPropertyValue);
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodeCallback::ScGetProperty
 *
 * PURPOSE: Helper (static) method to access snapin property
 *
 * PARAMETERS:
 *    IDataObject *pDataObject  - [in] data object
 *    BSTR bstrPropertyName     - [in] property (clipboard fromat) name
 *    PBSTR  pbstrPropertyValue - [out] resulting value
 *
 * RETURNS:
 *    SC    - result code. NOTE: no error is returned if the snapin does not
 *            support the specified clipboard format. In this case *pbstrPropertyValue
 *            is set to NULL.
 *
\***************************************************************************/
SC CNodeCallback::ScGetProperty(IDataObject *pDataObject, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue)
{
    DECLARE_SC(sc, TEXT("ScGetProperty"));

    // check parameters
    sc = ScCheckPointers(pDataObject, bstrPropertyName, pbstrPropertyValue);
    if(sc)
        return sc;

    // initialize out parameter
    *pbstrPropertyValue = NULL;

    // create a stream for the data object to use
    IStreamPtr pStm;
    sc = CreateStreamOnHGlobal(NULL, true, &pStm);
    if(sc)
        return sc;

    ULARGE_INTEGER zeroSize = {0, 0};
    sc = pStm->SetSize(zeroSize);
    if(sc)
        return sc;

    USES_CONVERSION;
    CLIPFORMAT cfClipFormat = (CLIPFORMAT)RegisterClipboardFormat(OLE2T(bstrPropertyName));

    // First call ExtractString which uses GetData
    CStr strOutput;
    sc = ExtractString (pDataObject, cfClipFormat, strOutput);
    if(!sc.IsError())
    {
        *pbstrPropertyValue = ::SysAllocStringLen(T2COLE(strOutput), strOutput.GetLength()/*prevents the terminating zero from being added.*/); // allocate the string and return
        return sc;
    }

    // That didn't work, so try using GetDataHere.
    FORMATETC fmt  = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM};
    STGMEDIUM stgm = {TYMED_ISTREAM, NULL, NULL};
    stgm.pstm      = pStm;

    sc = pDataObject->GetDataHere(&fmt, &stgm);
    if(sc)
    {
        // ignore errors and return a blank string
        sc.Clear();
        return sc;
    }

    STATSTG stagStg;
    ZeroMemory(&stagStg, sizeof(stagStg));

    sc = pStm->Stat(&stagStg, STATFLAG_NONAME); // do not need the name in the statistics.
    if(sc)
        return sc;

    if(stagStg.cbSize.HighPart != 0)
        return sc = E_UNEXPECTED;

    // go back to the beginning of the stream
    LARGE_INTEGER dlibMove = {0, 0};
    sc = pStm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
    if(sc)
        return sc;

    BSTR bstrValue = ::SysAllocStringLen(NULL, stagStg.cbSize.LowPart / sizeof(OLECHAR)); // one character is automatically added
    if(!bstrValue)
        return sc = E_OUTOFMEMORY;

    ULONG cbRead = 0;
    sc = pStm->Read(bstrValue, stagStg.cbSize.LowPart, &cbRead);
    if(sc)
        return sc;

    // make sure that the count of characters is what was expected
    if(cbRead != stagStg.cbSize.LowPart)
    {
        ::SysFreeString(bstrValue);
        return sc = E_UNEXPECTED;
    }

    // set the output parameter
    *pbstrPropertyValue = bstrValue;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::GetNodetypeForListItem
 *
 * PURPOSE: Returns the node type for a list item.
 *
 * PARAMETERS:
 *    HNODE   hNodeScope :
 *    BOOL    bForScopeItem :
 *    LPARAM  resultItemParam :
 *    PBSTR   pbstrNodetype :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CNodeCallback::GetNodetypeForListItem(HNODE hNodeScope, BOOL bForScopeItem, LPARAM resultItemParam, PBSTR pbstrNodetype)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetNodetypeForListItem"));

    // check parameters
    sc = ScCheckPointers(pbstrNodetype);
    if(sc)
        return sc.ToHr();

    // initialize out parameter
    *pbstrNodetype = NULL;

    // convert the HNODE to a CNode *
    CNode *pNodeScope = CNode::FromHandle(hNodeScope);

    sc = ScCheckPointers(pNodeScope);
    if(sc)
        return sc.ToHr();

    IDataObjectPtr spDataObject;

    bool bScopeItem;
    sc = pNodeScope->ScGetDataObject(bForScopeItem, resultItemParam, bScopeItem, &spDataObject);
    if(sc)
        return sc.ToHr();

    // at this point we should have a valid data object
    sc = ScCheckPointers((LPDATAOBJECT)spDataObject);
    if(sc)
        return sc.ToHr();

    sc = ScGetNodetype(spDataObject, pbstrNodetype);
    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::ScGetNodetype
 *
 * PURPOSE: Static function - returns the nodetype of a data object as a string.
 *
 * PARAMETERS:
 *    IDataObject * pDataObject :
 *    PBSTR         pbstrNodetype :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CNodeCallback::ScGetNodetype(IDataObject *pDataObject, PBSTR pbstrNodetype)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::ScGetNodetype"));

    sc = ScCheckPointers(pDataObject, pbstrNodetype);
    if(sc)
        return sc;

    // init out parameter
    *pbstrNodetype = NULL;

    GUID guidNodetype = GUID_NULL;

    sc = ExtractObjectTypeGUID(pDataObject, &guidNodetype);
    if(sc)
        return sc;

    OLECHAR szSnapInGUID[40];
    int iRet = StringFromGUID2(guidNodetype, szSnapInGUID, countof(szSnapInGUID));

    if(0 == iRet)
        return (sc = E_UNEXPECTED);

    // allocate the string, with the correct length.
    *pbstrNodetype = ::SysAllocString(szSnapInGUID);
    if(!*pbstrNodetype)
        return (sc = E_OUTOFMEMORY);

    return sc;
}

HRESULT CNodeCallback::OnSnapInHelp(CNode* pNode, BOOL bScope, MMC_COOKIE cookie)
{
    if (bScope == FALSE && pNode->GetViewData()->IsVirtualList() == FALSE)
    {
        ASSERT(cookie != NULL);
        CResultItem* pri = CResultItem::FromHandle(cookie);

        if ((pri != NULL) && pri->IsScopeItem())
        {
            pNode = CNode::FromResultItem(pri);
            ASSERT(pNode != NULL);
        }
    }

    CComponent* pCC = pNode->GetPrimaryComponent();
    ASSERT(pCC != NULL);

    HRESULT hr = pCC->Notify(NULL, MMCN_SNAPINHELP, 0, 0);
    CHECK_HRESULT(hr);

    return hr;
}


HRESULT CNodeCallback::OnContextHelp(CNode* pNode, BOOL bScope, MMC_COOKIE cookie)
{
    ASSERT(pNode != NULL);

    if (bScope == FALSE && pNode->GetViewData()->IsVirtualList() == FALSE)
    {
        ASSERT(cookie != NULL);
        if(cookie == NULL || IS_SPECIAL_COOKIE(cookie))
            return E_UNEXPECTED;

        CResultItem* pri = CResultItem::FromHandle(cookie);
        if (pri == NULL)
            return (E_UNEXPECTED);

        cookie = pri->GetSnapinData();

        bScope = pri->IsScopeItem();
        if (bScope == TRUE)
        {
            pNode = CNode::FromResultItem(pri);
            ASSERT(pNode != NULL);
        }
    }

    if (bScope == TRUE)
    {
        IDataObjectPtr spdtobj;
        HRESULT hr = pNode->GetMTNode()->QueryDataObject(CCT_SCOPE, &spdtobj);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        CComponent* pCC = pNode->GetPrimaryComponent();
		if ( pCC == NULL )
			return E_UNEXPECTED;

        hr = pCC->Notify(spdtobj, MMCN_CONTEXTHELP, 0, 0);
        CHECK_HRESULT(hr);
        return hr;
    }
    else
    {
        CComponent* pCC = pNode->GetPrimaryComponent();
        ASSERT(pCC != NULL);
		if ( pCC == NULL )
			return E_UNEXPECTED;

        IDataObjectPtr spdtobj;
        HRESULT hr = pCC->QueryDataObject(cookie, CCT_RESULT, &spdtobj);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        hr = pCC->Notify(spdtobj, MMCN_CONTEXTHELP, 0, 0);
        CHECK_HRESULT(hr);
        return hr;
    }
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::GetSnapinName
//
//  Synopsis:    Given the node get the snapin name
//
//  Arguments:   [hNode]    - [in]
//               [ppszName] - [out] ret val, caller should free using CoTaskMemFree
//               [bValidName] - [out], is the name valid or not
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::GetSnapinName (/*[in]*/HNODE hNode, /*[out]*/LPOLESTR* ppszName, /*[out]*/ bool& bValidName)
{
    DECLARE_SC(sc, _T("CNodeCallback::GetSnapinName"));
    sc = ScCheckPointers( (void*) hNode, ppszName);
    if (sc)
        return sc.ToHr();

    bValidName = false;

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    *ppszName = NULL;

    CSnapIn* pSnapIn = pNode->GetPrimarySnapIn();
    sc = ScCheckPointers (pSnapIn, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    WTL::CString strName;
    sc = pSnapIn->ScGetSnapInName(strName);
    if (sc)
        return (sc.ToHr());

    if (strName.IsEmpty())
        return sc.ToHr();

    USES_CONVERSION;
    *ppszName = CoTaskDupString (T2COLE (strName));
    if (*ppszName == NULL)
        return ((sc = E_OUTOFMEMORY).ToHr());

    bValidName = true;

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:     OnColumnClicked
//
//  Synopsis:   Ask snapin if it wants to sort and do so.
//
//  Arguments:  [pNode] - CNode* owner of list view.
//              [nCol]  - column that is clicked (to sort on this column).
//
//  Returns:    HRESULT
//
//  History:    07-27-1999  AnandhaG renamed OnSort to OnColumnClicked
//--------------------------------------------------------------------
HRESULT CNodeCallback::OnColumnClicked(CNode* pNode, LONG_PTR nCol)
{
    ASSERT(pNode != NULL);

    pNode->OnColumnClicked(nCol);
    return S_OK;
}

HRESULT CNodeCallback::OnPrint(CNode* pNode, BOOL bScopePane, LPARAM lvData)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnPrint"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    if ((!bScopePane) && (LVDATA_MULTISELECT == lvData) )
    {
        CViewData *pViewData = pNode->GetViewData();
        sc = ScCheckPointers(pViewData, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CMultiSelection* pMultiSel = pViewData->GetMultiSelection();
        sc = ScCheckPointers(pMultiSel, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        sc = pMultiSel->ScVerbInvoked(MMC_VERB_PRINT);
        if (sc)
            return sc.ToHr();

        return sc.ToHr();
    }

    IDataObjectPtr spdtobj;
    IDataObject *pdtobj = NULL;

    bool bScopeItem;
    sc = pNode->ScGetDataObject(bScopePane, lvData, bScopeItem, &pdtobj);
    if (sc)
        return sc.ToHr();

    if (! IS_SPECIAL_DATAOBJECT(pdtobj))
        spdtobj = pdtobj;

    CComponent *pComponent = pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pComponent, pdtobj, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pComponent->Notify(pdtobj, MMCN_PRINT, 0, 0);
    if (sc)
        sc.TraceAndClear();

    return sc.ToHr();
}

HRESULT
CNodeCallback::OnEditTaskpad(CNode *pNode)
{
    ASSERT(pNode);

    ITaskCallbackPtr spTaskCallback = pNode->GetViewData()->m_spTaskCallback;

    ASSERT(spTaskCallback.GetInterfacePtr());

    return spTaskCallback->OnModifyTaskpad();
}

HRESULT
CNodeCallback::OnDeleteTaskpad(CNode *pNode)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnDeleteTaskpad"));

    ASSERT(pNode);
    sc = ScCheckPointers( pNode );
    if ( sc )
        return sc.ToHr();

    ITaskCallbackPtr spTaskCallback = pNode->GetViewData()->m_spTaskCallback;

    ASSERT(spTaskCallback.GetInterfacePtr());

    // make the node dirty
    CMTNode* pMTNode = pNode->GetMTNode();
    sc = ScCheckPointers( pMTNode, E_UNEXPECTED );
    if(sc)
        return sc.ToHr();

    pMTNode->SetDirty();

    return spTaskCallback->OnDeleteTaskpad();
}

/* CNodeCallback::OnNewTaskpadFromHere
 *
 * PURPOSE:     Displays property pages for a new taskpad
 *
 * PARAMETERS:
 *      CNode*   pNode: The node that the taskpad should target to.
 *
 * RETURNS:
 *      HRESULT
 */
HRESULT
CNodeCallback::OnNewTaskpadFromHere(CNode* pNode)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnNewTaskpadFromHere"));
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CConsoleTaskpad taskpad (pNode);

    CTaskpadWizard dlg(pNode, taskpad, TRUE /*fNew*/, 0, FALSE, pNode->GetViewData());

    bool fStartTaskWizard = true;
    sc = dlg.Show(pNode->GetViewData()->GetMainFrame() /*hWndParent*/, &fStartTaskWizard);

    if (sc != S_OK)
        return sc.ToHr();

    sc = ScCheckPointers(m_pCScopeTree, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    m_pCScopeTree->InsertConsoleTaskpad (&taskpad, pNode, fStartTaskWizard);

    // modify the view settings for this node to ensure that the taskpad is shown after the reselect.
    sc = pNode->ScSetTaskpadID(taskpad.GetID(), /*bSetViewSettingDirty*/ true);
    if (sc)
        return sc.ToHr();

    m_pCScopeTree->UpdateAllViews(VIEW_RESELECT, 0);

    return sc.ToHr();
}


HRESULT CNodeCallback::OnRefresh(CNode* pNode, BOOL bScopePaneSelected, LPARAM lvData)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnRefresh"));

    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, bScopePaneSelected, lvData,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // If result-pane cookie should be valid.
    ASSERT( (bScopeItemSelected) || cookie != LVDATA_ERROR);
    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return E_FAIL;

    // Before refreshing this node, if the user has made
    // changes to list view persist it.
    CViewData* pVD = pSelectedNode->GetViewData();
    ASSERT(pVD != NULL);

    if (bScopeItemSelected)
    {
        ASSERT(pNode != NULL);
        IDataObjectPtr spdtobj;
        HRESULT hr = pSelectedNode->GetMTNode()->QueryDataObject(CCT_SCOPE, &spdtobj);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        CMTNode* pMTNode = pSelectedNode->GetMTNode();
        ASSERT(pMTNode != NULL);

        LPARAM lScopeItem = CMTNode::ToScopeItem(pMTNode);

        // Send notify to primary snap-in
        pMTNode->AddRef();
        pSelectedNode->GetPrimaryComponent()->Notify(spdtobj, MMCN_REFRESH, lScopeItem, 0);
        if (pMTNode->Release() == 0)
            return S_OK;

        // If node has been expanded, then also send notify to all namespace
        // extensions for this node
        if (pMTNode->WasExpandedAtLeastOnce())
        {
            do // dummy loop
            {
                // Get the node-type of this node
                GUID guidNodeType;
                HRESULT hr = pMTNode->GetNodeType(&guidNodeType);
                CHECK_HRESULT(hr);
                if (FAILED(hr))
                    break;

                // Get list of dynmaic extensions
                LPCLSID pDynExtCLSID;
                int cDynExt = pMTNode->GetDynExtCLSID(&pDynExtCLSID);

                // Create and init namespace extension iterator
                CExtensionsIterator it;
                sc = it.ScInitialize(pMTNode->GetPrimarySnapIn(), guidNodeType, g_szNameSpace, pDynExtCLSID, cDynExt);
                if (sc)
                    break;

                CSnapInNode* pSINode = pSelectedNode->GetStaticParent();
                ASSERT(pSINode != NULL);

                // Send refresh to each extension's component
                for (; it.IsEnd() == FALSE; it.Advance())
                {
                    CComponent* pCC = pSINode->GetComponent(it.GetCLSID());
                    if (pCC == NULL)
                        continue;

                    HRESULT hr = pCC->Notify(spdtobj, MMCN_REFRESH, lScopeItem, 0);
                    CHECK_HRESULT(hr);
                }
            } while (FALSE);
        }
    }
    else
    {
        CComponent* pCC = pSelectedNode->GetPrimaryComponent();
        ASSERT(pCC != NULL);

        if (IS_SPECIAL_LVDATA(lvData))
        {
            LPDATAOBJECT pdobj = (lvData == LVDATA_CUSTOMOCX) ?
                                    DOBJ_CUSTOMOCX : DOBJ_CUSTOMWEB;

            HRESULT hr = pCC->Notify(pdobj, MMCN_REFRESH, 0, 0);
            CHECK_HRESULT(hr);
        }
        else
        {
            IDataObjectPtr spdtobj;
            HRESULT hr = pCC->QueryDataObject(cookie, CCT_RESULT, &spdtobj);
            ASSERT(SUCCEEDED(hr));
            if (FAILED(hr))
                return hr;
            pCC->Notify(spdtobj, MMCN_REFRESH, 0, 0);
        }
    }

    // Set the view correctly using the persisted data.
    do
    {
        if (NULL == pVD)
            break;

        // After the refresh the snapin could have deleted the pSelectedNode or
        // could have moved the selection. While setting view-data we
        // just need the currently selected node (the owner of the view
        // which is not affected by temp selection) and set the view.
        CNode* pSelNode = pVD->GetSelectedNode();
        if (NULL == pSelNode)
            break;

        sc = pSelNode->ScRestoreSortFromPersistedData();
        if (sc)
            return sc.ToHr();
    } while ( FALSE );

    return S_OK;
}

UINT GetRelation(CMTNode* pMTNodeSrc, CMTNode* pMTNodeDest)
{
    if (pMTNodeSrc == pMTNodeDest)
        return 1;

    for(pMTNodeDest = pMTNodeDest->Parent();
        pMTNodeDest;
        pMTNodeDest = pMTNodeDest->Parent())
    {
        if (pMTNodeSrc == pMTNodeDest)
            return 2;
    }

    return 0;
}

STDMETHODIMP CNodeCallback::UpdatePasteButton(HNODE hNode, BOOL bScope, LPARAM lvData)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::UpdatePasteButton"));
    sc = ScCheckPointers(hNode);
    if (sc)
        return sc.ToHr();

    bool bPasteAllowed = false;
    // Update only when item is being selected.
    sc = QueryPasteFromClipboard(hNode, bScope, lvData, bPasteAllowed);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pViewData->ScUpdateStdbarVerb (MMC_VERB_PASTE, TBSTATE_ENABLED, bPasteAllowed);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::ScInitializeTempVerbSetForMultiSel
//
//  Synopsis:    For given node, initialize the tempverbset object
//               provided. For this create a multi-selection object
//               initialize it (multiselection object finds out what is
//               selected in resultpane and sends MMCN_SELECT to appropriate
//               snapins) and compute the verb states for the temp-verbset object.
//
//  Arguments:   [pNode]    - [in] owner of resultpane.
//               [tempverb] - [in] Temp verb set object which is initialzied.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNodeCallback::ScInitializeTempVerbSetForMultiSel(CNode *pNode, CTemporaryVerbSet& tempVerb)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::ScInitializeTempVerbSetForMultiSel"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    ASSERT(pNode->IsInitialized() == TRUE);

    // 1. Create a multi-selection object.
    CMultiSelection* pMultiSelection = new CMultiSelection(pNode);
    sc = ScCheckPointers(pMultiSelection, E_OUTOFMEMORY);
    if (sc)
        return sc;

    IDataObjectPtr spdobj;

    // 2. Initialize it, (it finds out what is selected in resultpane
    //    gets dataobjects from appropriate snapins and sends snapins
    //    MMCN_SELECT notifications).
    sc = pMultiSelection->Init();
    if (sc)
        goto Cleanup;

    pMultiSelection->SetScopeTree(m_pCScopeTree);

    sc = pMultiSelection->GetMultiSelDataObject(&spdobj);
    if (sc)
        goto Cleanup;

    if (spdobj == NULL)
        goto Cleanup;

    // 3. Init the verbset object.
    sc = tempVerb.ScInitializeForMultiSelection(pNode, /*bSelect*/ true);
    if (sc)
        goto Cleanup;

    tempVerb.SetMultiSelection(pMultiSelection);

    // 4. Compute the verbs that are set by snapin along with given context.
    sc = tempVerb.ScComputeVerbStates();

    if (sc)
        goto Cleanup;

Cleanup:
    pMultiSelection->Release();
    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::_ScGetVerbState
//
//  Synopsis:    For given item (dataobject), the owner node see if given
//               verb is set. A temp-verb-set object is created for this purpose.
//
//  Arguments:   [pNode]         - [in]
//               [verb]          - [in]
//               [pDOSel]        - [in] Dataobject of the item whose verb we are interested.
//               [bScopePane]    - [in]
//               [lResultCookie] - [in]
//               [bMultiSelect]  - [in]
//               [bIsVerbSet]    - [out] verb is set or not.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNodeCallback::_ScGetVerbState( CNode* pNode, MMC_CONSOLE_VERB verb, IDataObject* pDOSel,
                                   BOOL bScopePane, LPARAM lResultCookie,
                                   BOOL bMultiSelect, BOOL& bIsVerbSet)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::_GetVerbState"));
    bIsVerbSet = FALSE;

    sc = ScCheckPointers(pNode, pDOSel);
    if (sc)
        return sc;

    CComObject<CTemporaryVerbSet> stdVerbTemp;

    if (bMultiSelect)
        sc = ScInitializeTempVerbSetForMultiSel(pNode, stdVerbTemp);
    else
        sc = stdVerbTemp.ScInitialize(pDOSel, pNode, bScopePane, lResultCookie);

    if (sc)
        return sc;

    stdVerbTemp.GetVerbState(verb, ENABLED, &bIsVerbSet);

    return sc;
}

HRESULT
CNodeCallback::OnCutCopy(
    CNode* pNode,
    BOOL bScope,
    LPARAM lvData,
    BOOL bCut)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnCutCopy"));

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    // get the object
    IMMCClipboardDataObjectPtr spClipBoardDataObject;
    bool bContainsItems = false;
    sc = CMMCClipBoardDataObject::ScCreate( (bCut ? ACTION_CUT : ACTION_COPY),
                                            pNode, bScope,
                                            (lvData == LVDATA_MULTISELECT)/*bMultiSel*/,
                                            lvData, &spClipBoardDataObject ,
                                            bContainsItems);
    if (sc)
        return sc.ToHr();

    // If snapin has cut or copy then dataobject should have been added.
    if (! bContainsItems)
        return (sc = E_UNEXPECTED).ToHr();

    // QI for IDataObject
    IDataObjectPtr spDataObject = spClipBoardDataObject;
    sc = ScCheckPointers( spDataObject, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    //  Put the dataobject on the clipboard.
    sc = OleSetClipboard( spDataObject );
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::OnProperties
//
//  Synopsis:    Bring property sheet for given item.
//
//  Arguments:   CNode*   -  The node that owns result pane.
//               BOOL     -  If true bring propsheet of above node else use LVData.
//               LPARAM   -  If bScope = FALSE then use this data to get the LVData
//                           and bring its property sheet.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::OnProperties(CNode* pNode, BOOL bScopePaneSelected, LPARAM lvData)
{
    DECLARE_SC(sc, _T("CNodeCallback::OnProperties"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return (sc.ToHr());

    // NOTE: All the code below should be moved into the CNode class
    BOOL   bScopeItemSelected = FALSE;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, bScopePaneSelected, lvData,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // If result-pane cookie should be valid.
    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return (sc = E_FAIL).ToHr();

    if (bScopeItemSelected)
    {
        sc = ScDisplaySnapinNodePropertySheet(pSelectedNode);
        if(sc)
            return sc.ToHr();
    }
    else
    {
        CViewData* pViewData = pSelectedNode->GetViewData();
        sc = ScCheckPointers(pViewData, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (pViewData->HasList())
        {
            if (cookie == LVDATA_MULTISELECT)
            {
                sc = ScDisplayMultiSelPropertySheet(pSelectedNode);
                if(sc)
                    return sc.ToHr();
            }
            else
            {
                sc = ScDisplaySnapinLeafPropertySheet(pSelectedNode, cookie);
                if(sc)
                    return sc.ToHr();
            }
        }
        else
        {
            LPDATAOBJECT pdobj = (pViewData->HasOCX() ) ? DOBJ_CUSTOMOCX : DOBJ_CUSTOMWEB;
            CComponent* pCC = pSelectedNode->GetPrimaryComponent();
            sc = ScCheckPointers(pCC, E_UNEXPECTED);
            if (sc)
                return sc.ToHr();

            pCC->Notify(pdobj, MMCN_BTN_CLICK, 0, MMC_VERB_PROPERTIES);
        }
    }

    return S_OK;
}


HRESULT CNodeCallback::OnFilterChange(CNode* pNode, LONG_PTR nCode, LPARAM nCol)
{
    IF_NULL_RETURN_INVALIDARG(pNode);

    CComponent* pCC = pNode->GetPrimaryComponent();
    ASSERT(pCC != NULL);

    if (pCC != NULL)
    {
        HRESULT hr = pCC->Notify(DOBJ_NULL, MMCN_FILTER_CHANGE, nCode, nCol);
        return hr;
    }

    return E_FAIL;
}


HRESULT CNodeCallback::OnFilterBtnClick(CNode* pNode, LONG_PTR nCol, LPRECT pRect)
{
    IF_NULL_RETURN_INVALIDARG2(pNode, pRect);

    CComponent* pCC = pNode->GetPrimaryComponent();
    ASSERT(pCC != NULL);

    if (pCC != NULL)
    {
        HRESULT hr = pCC->Notify(DOBJ_NULL, MMCN_FILTERBTN_CLICK, nCol, (LPARAM)pRect);
        return hr;
    }

    return E_FAIL;
}


STDMETHODIMP CNodeCallback::IsExpandable(HNODE hNode)
{
    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    ASSERT(pNode != NULL);

    CMTNode* pMTNode = pNode->GetMTNode();
    ASSERT(pMTNode != NULL);

    return pMTNode->IsExpandable();
}

HRESULT _GetConsoleVerb(CNode* pNode, LPCONSOLEVERB* ppConsoleVerb)
{
    IF_NULL_RETURN_INVALIDARG2(pNode, ppConsoleVerb);

    HRESULT hr = S_FALSE;

    CComponent* pCC = pNode->GetPrimaryComponent();
    ASSERT(pCC != NULL);
    if (pCC == NULL)
        return E_FAIL;

    IFramePrivate* pIFP = pCC->GetIFramePrivate();
    ASSERT(pIFP != NULL);
    if (pIFP == NULL)
        return E_FAIL;

    IConsoleVerbPtr spConsoleVerb;
    hr = pIFP->QueryConsoleVerb(&spConsoleVerb);

    if (SUCCEEDED(hr))
    {
        *ppConsoleVerb = spConsoleVerb.Detach();
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CNodeCallback::GetConsoleVerb(HNODE hNode, LPCONSOLEVERB* ppConsoleVerb)
{
    ASSERT(ppConsoleVerb != NULL);

    return _GetConsoleVerb(CNode::FromHandle(hNode), ppConsoleVerb);
}



// lCookie valid if both bScope & bMultiSel are FALSE.
// lCookie is the index\lParam for virtual\regular LV
STDMETHODIMP
CNodeCallback::GetDragDropDataObject(
    HNODE hNode,
    BOOL bScope,
    BOOL bMultiSel,
    LONG_PTR lvData,
    LPDATAOBJECT* ppDataObject,
    bool& bCopyAllowed,
    bool& bMoveAllowed)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetDragDropDataObject"));

    // init allowed op's to false
    bCopyAllowed = false;
    bMoveAllowed = false;

    // parameter check
    sc = ScCheckPointers(ppDataObject);
    if (sc)
        return sc.ToHr();

    // init out parameter;
    *ppDataObject = NULL;

    // get the object
    IMMCClipboardDataObjectPtr spClipBoardDataObject;
    bool bContainsItems = false;
    sc = CMMCClipBoardDataObject::ScCreate( ACTION_DRAG,
                                            CNode::FromHandle(hNode),
                                            bScope, bMultiSel, lvData,
                                            &spClipBoardDataObject,
                                            bContainsItems );
    if (sc)
        return sc.ToHr();

    // We asked for drag&drop dataobject. If snapin does not support cut/copy then
    // the dataobjects will not be added which is not an error.
    if (! bContainsItems)
        return sc.ToHr();

    // QI for IDataObject
    IDataObjectPtr spDataObject = spClipBoardDataObject;
    sc = ScCheckPointers( spDataObject, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    // inspect data objects included to see what operations are allowed
    // (note: (spDataObject==valid) -> (spClipBoardDataObject==valid) )
    DWORD dwCount = 0;
    sc = spClipBoardDataObject->GetCount( &dwCount );
    for ( DWORD dwIdx = 0; dwIdx < dwCount; dwIdx ++ )
    {
        IDataObjectPtr spSnapinDO;
        DWORD dwOptions = 0;
        sc = spClipBoardDataObject->GetDataObject( dwIdx, &spSnapinDO, &dwOptions );
        if (sc)
            return sc.ToHr();

        // claculate allowed operations
        bCopyAllowed = bCopyAllowed || ( dwOptions & COPY_ALLOWED );
        bMoveAllowed = bMoveAllowed || ( dwOptions & MOVE_ALLOWED );

        // enabling is inclusive, so very few tests are required
        if ( bCopyAllowed && bMoveAllowed )
            break;
    }

    // return data object
    *ppDataObject = spDataObject.Detach();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::ScExtractLVData
//
//  Synopsis:    If listview item is selected, see if it is a scope item
//               in non-virtual listview (virtual listviews cannot have
//               scope items in them). If so extract that scope item else
//               the cookie of result item.
//
//  Arguments:   [pNode]  - [in, out] if scope item is selected in resultpane, then
//                                    will contain this scope item on return.
//               [bScope] - [in, out] Is scope item currently selected item (in scope or
//                                    result pane).
//               [lvData] - [in] LVDATA
//               [cookie] - [in] lParam of result item.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNodeCallback::ScExtractLVData(CNode* pNodeViewOwner,
                                  BOOL bScopePaneSelected,
                                  LONG_PTR lvData,
                                  CNode** ppSelectedNode,
                                  BOOL& bScopeItemSelected,
                                  MMC_COOKIE& cookie)
{
    DECLARE_SC(sc, _T("CNodeCallback::ScExtractLVData"));
    sc = ScCheckPointers(pNodeViewOwner, ppSelectedNode);
    if (sc)
        return sc;

    *ppSelectedNode = NULL;
    bScopeItemSelected = bScopePaneSelected;
    *ppSelectedNode = pNodeViewOwner;

    if (bScopePaneSelected)
    {
        cookie = lvData;
        return sc;
    }

    // Scope pane is not selected.
    CViewData *pViewData = pNodeViewOwner->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    cookie = lvData;

    if (IS_SPECIAL_LVDATA(lvData))
    {
        if (lvData == LVDATA_BACKGROUND)
            bScopeItemSelected = TRUE;
    }
    else if (! pViewData->IsVirtualList())
    {
        CResultItem* pri = CResultItem::FromHandle (lvData);
        sc = ScCheckPointers(pri, E_UNEXPECTED);
        if (sc)
        {
            cookie = LVDATA_ERROR;
            return sc;
        }

        if (pri->IsScopeItem())
        {
            bScopeItemSelected = TRUE;
            *ppSelectedNode = CNode::FromResultItem(pri);
            sc = ScCheckPointers(*ppSelectedNode, E_UNEXPECTED);
            if (sc)
                return sc;

            cookie = -1;
        }
        else
        {
            cookie = pri->GetSnapinData();
        }

        ASSERT(!IS_SPECIAL_LVDATA(lvData) || !bScopeItemSelected);
    }

    return (sc);
}



STDMETHODIMP
CNodeCallback::GetTaskEnumerator(
    HNODE hNode,
    LPCOLESTR pszTaskGroup,
    IEnumTASK** ppEnumTask)
{
    IF_NULL_RETURN_INVALIDARG3(hNode, pszTaskGroup, ppEnumTask);

    *ppEnumTask = NULL; // init

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);

    return pNode->GetTaskEnumerator(CComBSTR(pszTaskGroup), ppEnumTask);

}

STDMETHODIMP
CNodeCallback::GetListPadInfo(HNODE hNode, IExtendTaskPad* pExtendTaskPad,
    LPCOLESTR szTaskGroup, MMC_ILISTPAD_INFO* pIListPadInfo)
{
    IF_NULL_RETURN_INVALIDARG(hNode);

    CNode* pNode = CNode::FromHandle(hNode);
    return pNode->GetListPadInfo(pExtendTaskPad, CComBSTR(szTaskGroup), pIListPadInfo);
}

HRESULT CNodeCallback::OnGetPrimaryTask(CNode* pNode, LPARAM param)
{
    IF_NULL_RETURN_INVALIDARG(pNode);

    IExtendTaskPad** ppExtendTaskPad = reinterpret_cast<IExtendTaskPad**>(param);
    return pNode->OnGetPrimaryTask(ppExtendTaskPad);
}

STDMETHODIMP
CNodeCallback::UpdateWindowLayout(LONG_PTR lViewData, long lToolbarsDisplayed)
{
    IF_NULL_RETURN_INVALIDARG(lViewData);

    CViewData* pVD = reinterpret_cast<CViewData*>(lViewData);
    pVD->UpdateToolbars(lToolbarsDisplayed);
    return S_OK;
}

HRESULT CNodeCallback::PreLoad(HNODE hNode)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::PreLoad"));

    // parameter check
    sc = ScCheckPointers( hNode );
    if (sc)
        return sc.ToHr();

    CNode* pNode = CNode::FromHandle (hNode);
    if (pNode->IsStaticNode() == FALSE ||
        pNode->IsInitialized() == TRUE)
        return (sc = S_FALSE).ToHr();

    // if the node is:
    // 1. a snapin node;
    // 2. marked as "PreLoad"; and,
    // 3. not initialized yet.
    // if all three, then send 'em a notify containing their HSCOPEITEM
    CMTNode* pMTNode = pNode->GetMTNode();
    sc = ScCheckPointers( pMTNode, E_FAIL );
    if (sc)
        return sc.ToHr();

    CMTSnapInNode* pMTSnapInNode = dynamic_cast<CMTSnapInNode*>(pMTNode);
    sc = ScCheckPointers( pMTSnapInNode, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    if (!pMTSnapInNode->IsPreloadRequired())
        return (sc = S_FALSE).ToHr();

    if (pMTNode->IsInitialized() == FALSE)
    {
        sc = pMTSnapInNode->Init();
        if (sc)
            return sc.ToHr();
    }

    //
    //  If the snap-in needs to be preloaded, the IComponent also needs
    //  to be init so that the sanpin can insert icons in the result
    //  pane if the parent node is selected in the scope pane.
    //

    ASSERT(pNode->IsInitialized() == FALSE);
    sc = _InitializeNode(pNode);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

STDMETHODIMP CNodeCallback::SetTaskpad(HNODE hNodeSelected, GUID *pGuidTaskpad)
{
    ASSERT(hNodeSelected != NULL);
    ASSERT(pGuidTaskpad != NULL);

    CNode           *pNode           = CNode::FromHandle(hNodeSelected);

    // See ScSetViewExtension for more info on parameters in the call.
    HRESULT hr = pNode->ScSetViewExtension(pGuidTaskpad,
                                           /*bUseDefaultTaskPad*/ false,
                                           /*bSetViewSettingDirty*/ true).ToHr();

    return hr;
}


STDMETHODIMP CNodeCallback::OnCustomizeView (LONG_PTR lViewData)
{
    ::OnCustomizeView ((CViewData*) lViewData);
    return (S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::SetViewSettings
//
//  Synopsis:    Modify the view settings data that is persisted.
//
//  Arguments:   [nViewID] - [in] the view id.
//               [hbm]     - [in] bookmark.
//               [hvs]     - [in] view-settings.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::SetViewSettings(int nViewID, HBOOKMARK hbm, HVIEWSETTINGS hvs)
{
    DECLARE_SC(sc, _T("CNodeCallback::SetViewSettings"));
    sc = ScCheckPointers( (void*)hbm, (void*) hvs);
    if (sc)
        return sc.ToHr();


    CViewSettings *pViewSettings = reinterpret_cast<CViewSettings *>(hvs);
    CBookmark     *pBookmark     = reinterpret_cast<CBookmark*> (hbm);
    sc = CNode::ScSetFavoriteViewSettings(nViewID, *pBookmark, *pViewSettings);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::ExecuteScopeItemVerb
//
//  Synopsis:    Invoke the given verb with given context. Also make sure
//               the verb is enabled by snapin for this context.
//
//  Arguments:   [verb]        - The verb to be invoked.
//               [hNode]       - The node for which above verb is invoked.
//               [lpszNewName] - For "rename" represents new name.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::ExecuteScopeItemVerb (MMC_CONSOLE_VERB verb, HNODE hNode, LPOLESTR lpszNewName)
{
    DECLARE_SC(sc, _T("CNodeCallback::ExecuteScopeItemVerb"));

    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if(sc)
        return sc.ToHr();

    // Get data object for the item.
    IDataObjectPtr spDataObject;
    sc = pNode->QueryDataObject(CCT_SCOPE, &spDataObject);
    if (sc)
        return (sc.ToHr());

    BOOL bEnabled = FALSE;
    // see if the verb is enabled by the snapin.
    sc = _ScGetVerbState( pNode, verb, spDataObject,
                          /*bScopePane*/TRUE, /*lResultCookie = */ NULL,
                          /*bMultiSel*/FALSE, bEnabled);
    if (sc)
        return sc.ToHr();

    if (! bEnabled) // Verb not enabled.
        return (sc = ScFromMMC(MMC_E_TheVerbNotEnabled)).ToHr();

    switch(verb)
    {
    case MMC_VERB_PROPERTIES:
        sc = OnProperties(pNode, /*bScope*/ TRUE, /*LPARAM*/ NULL);
        if (sc)
            return sc.ToHr();
        break;

    case MMC_VERB_DELETE:
        sc = OnDelete(pNode, /*bScope*/ TRUE, /*LPARAM*/ NULL);
        if (sc)
            return sc.ToHr();
        break;

    case MMC_VERB_REFRESH:
        sc = OnRefresh(pNode, /*bScope*/ TRUE, /*LPARAM*/ NULL);
        if (sc)
            return sc.ToHr();
        break;

    case MMC_VERB_RENAME:
        {
            // To call Rename we must first initialize SELECTIONINFO.
            SELECTIONINFO selInfo;
            ZeroMemory(&selInfo, sizeof(selInfo));
            selInfo.m_bScope = TRUE;
            selInfo.m_eCmdID = MMC_VERB_RENAME;

            sc = OnRename(pNode, &selInfo, lpszNewName);
            if (sc)
                return sc.ToHr();
        }
        break;

    case MMC_VERB_COPY:
        sc = OnCutCopy(pNode, /*bScope*/ TRUE, NULL, /*bCut*/ FALSE);
        if (sc)
            return sc.ToHr();
        break;

    default:
        sc = E_UNEXPECTED;
        break;
    }

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::ExecuteResultItemVerb
//
//  Synopsis:    Invoke the given verb with given context. Also make sure
//               the verb is enabled by snapin for this context.
//
//  Arguments:   [verb]        - The verb to be invoked.
//               [hNode]       - The node that owns result pane now.
//               [lvData]      - The list view selection context.
//               [lpszNewName] - For "rename" represents new name else NULL.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::ExecuteResultItemVerb (MMC_CONSOLE_VERB verb, HNODE hNode, LPARAM lvData, LPOLESTR lpszNewName)
{
    DECLARE_SC(sc, _T("CNodeCallback::ExecuteResultItemVerb"));
    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    // We need to see if the given verb is enabled by the snapin. We need
    // dataobject for given context for this. So get the context by calling
    // ScExtractLVData().
    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, /*bScopePaneSelected*/ FALSE, lvData,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Cookie should be valid for result pane.
    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return (sc = E_FAIL).ToHr();

    BOOL bMultiSelect = (LVDATA_MULTISELECT == lvData);
    if (bMultiSelect)
        cookie = MMC_MULTI_SELECT_COOKIE;

    // Depending on whether this is scope item in result pane or result item
    // ask ComponentData or Component the data object.
    IDataObjectPtr spDataObject;
    if (bScopeItemSelected)
    {
        sc = pSelectedNode->QueryDataObject (CCT_SCOPE, &spDataObject);
        if (sc)
            return sc.ToHr();
    }
    else
    {
        CComponent* pCC = pNode->GetPrimaryComponent();
        sc = ScCheckPointers(pCC, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        sc = pCC->QueryDataObject(cookie, CCT_RESULT, &spDataObject);
        if (sc)
            return (sc.ToHr());
    }

    BOOL bEnabled = FALSE;
    // See if the verb is enabled for this selection.
    sc =  _ScGetVerbState( pSelectedNode , verb, spDataObject,
                           /*bScopePaneSelected*/ FALSE, lvData,
                           bMultiSelect, bEnabled);
    if (sc)
        return sc.ToHr();

    if (! bEnabled) // Verb not enabled.
        return (sc = ScFromMMC(MMC_E_TheVerbNotEnabled)).ToHr();


    switch(verb)
    {
    case MMC_VERB_PROPERTIES:
        sc = OnProperties(pNode, /*bScope*/ FALSE, /*LPARAM*/ lvData);
        if (sc)
            return sc.ToHr();
        break;

    case MMC_VERB_DELETE:
        sc = OnDelete(pNode, /*bScope*/ FALSE, /*LPARAM*/ lvData);
        if (sc)
            return sc.ToHr();
        break;

    case MMC_VERB_REFRESH:
        sc = OnRefresh(pNode, /*bScope*/ FALSE, /*LPARAM*/ lvData);
        if (sc)
            return sc.ToHr();
        break;

    case MMC_VERB_RENAME:
        {
            // For Rename we should also call ScExtractLVData before calling OnRename.
            // To call Rename we must first initialize SELECTIONINFO.
            SELECTIONINFO selInfo;
            ZeroMemory(&selInfo, sizeof(selInfo));
            selInfo.m_bScope = bScopeItemSelected;
            selInfo.m_lCookie = cookie;
            selInfo.m_eCmdID = MMC_VERB_RENAME;

            sc = OnRename(pNode, &selInfo, lpszNewName);
            if (sc)
                return sc.ToHr();
        }
        break;

    case MMC_VERB_COPY:
        sc = OnCutCopy(pNode, /*bScope*/ FALSE, lvData, /*bCut*/ FALSE);
        if (sc)
            return sc.ToHr();
        break;

    default:
        sc = E_INVALIDARG;
        break;
    }


    return (sc.ToHr());
}



/*+-------------------------------------------------------------------------*
 *
 * FUNCTION:  CNodeCallback::QueryCompDataDispatch
 *
 * PURPOSE:   Get the disp interface for given scope node object from snapin.
 *
 * PARAMETERS:
 *    PNODE            - The Node object for which the disp interface is required.
 *    PPDISPATCH [out] - Disp interface pointer returned by snapin.
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CNodeCallback::QueryCompDataDispatch(PNODE pNode, PPDISPATCH ppScopeNodeObject)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::QueryCompDataDispInterface"));
    sc = ScCheckPointers(m_pCScopeTree);
    if(sc)
        return sc.ToHr();

    CMTNode *pMTNode = NULL;
    sc = m_pCScopeTree->ScGetNode(pNode, &pMTNode);
    if(sc)
        return sc.ToHr();

    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pMTNode->ScQueryDispatch(CCT_SCOPE, ppScopeNodeObject);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::QueryComponentDispatch
//
//  Synopsis:   Get the disp interface for given item in resultpane from snapin.
//
//  Arguments:
//         HNODE            - The Scope Node which owns result pane.
//         LVDATA           - The LVDATA of selected item
//         PPDISPATCH [out] - Disp interface pointer returned by snapin.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::QueryComponentDispatch (HNODE hNode,
                                               LPARAM lvData,
                                               PPDISPATCH SelectedObject)
{
    DECLARE_SC(sc, _T("CNodeCallback::QueryComponentDispatch"));
    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, /*bScopePaneSelected*/ FALSE, lvData,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    /*
     * In case of multiselection, set cookie to MMC_MULTI_SELECT_COOKIE
     * which snapins can understand.
     */
    BOOL bMultiSelect = (LVDATA_MULTISELECT == lvData);
    if (bMultiSelect)
    {
        cookie = MMC_MULTI_SELECT_COOKIE;
        ASSERT(bScopeItemSelected == false);
    }

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // If result-pane cookie should be valid.
    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return (sc = E_FAIL).ToHr();

    // Scope item is selected in result pane.
    if (bScopeItemSelected)
    {
        CMTNode* pMTNode = pSelectedNode->GetMTNode();
        sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        sc = pMTNode->ScQueryDispatch(CCT_SCOPE, SelectedObject);
        if (sc)
            return sc.ToHr();
    }
    else
    {
        CComponent* pCC = pSelectedNode->GetPrimaryComponent();
        sc = ScCheckPointers(pCC, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        sc = pCC->ScQueryDispatch(cookie, CCT_RESULT, SelectedObject);
        if (sc)
            return sc.ToHr();
    }

    return (sc.ToHr());
}


/***************************************************************************\
 *
 * METHOD:  CNodeCallback::ShowColumn
 *
 * PURPOSE: Shows/hides the column. Implements both UI part as snapin notifications
 *          Used as helper implementing functionality for Column com object.
 *          [uses CNode to perform the task]
 *
 * PARAMETERS:
 *    HNODE hNodeSelected - scope node - oener of the view
 *    int iColIndex       - column index to perform action on
 *    bool bVisible       - show/hide flag for operation
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CNodeCallback::ShowColumn(HNODE hNodeSelected, int iColIndex, bool bShow)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::ShowColumn"));

    // get CNode pointer
    CNode* pNode = CNode::FromHandle(hNodeSelected);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pNode->ScShowColumn(iColIndex, bShow);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodeCallback::GetSortColumn
 *
 * PURPOSE: retrieves index of sort column
 *          Used as helper implementing functionality for Column com object.
 *          [uses CNode to perform the task]
 *
 * PARAMETERS:
 *    HNODE hNodeSelected - scope node - oener of the view
 *    int *piSortCol      - resulting index
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CNodeCallback::GetSortColumn(HNODE hNodeSelected, int *piSortCol)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetSortColumn"));

    // get CNode pointer
    CNode* pNode = CNode::FromHandle(hNodeSelected);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pNode->ScGetSortColumn(piSortCol);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodeCallback::SetSortColumn
 *
 * PURPOSE: sorts result data by specified column
 *          Used as helper implementing functionality for Column com object.
 *          [uses CNode to perform the task]
 *
 * PARAMETERS:
 *    HNODE hNodeSelected - scope node - oener of the view
 *    int iSortCol        - sort column index
 *    bool bAscending     - sort order
 *
 * RETURNS:
 *    HRESULT
 *
\***************************************************************************/
STDMETHODIMP CNodeCallback::SetSortColumn(HNODE hNodeSelected, int iSortCol, bool bAscending)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::SetSortColumn"));

    // get CNode pointer
    CNode* pNode = CNode::FromHandle(hNodeSelected);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pNode->ScSetSortColumn(iSortCol, bAscending);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


/***************************************************************************\
 *
 * METHOD:  CNodeCallback::RestoreResultView
 *
 * PURPOSE: Called by conui to restore the result view with given data.
 *          This method asks snapin (indirectly) to restore the view.
 *
 * PARAMETERS:
 *    HNODE hNode          - scope node - oener of the view
 *    CResultViewType rvt  - The resultview type data to be used for restore.
 *
 * RETURNS:
 *    HRESULT   S_OK    if snapin used the data to restore the view
 *              S_FALSE if snapin refused to restore.
 *
\***************************************************************************/
STDMETHODIMP CNodeCallback::RestoreResultView(HNODE hNode, const CResultViewType& rvt)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::RestoreResultView"));

    // get CNode pointer
    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    sc = pNode->ScRestoreResultView(rvt);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodeCallback::GetNodeViewExtensions
 *
 * PURPOSE: Forwards calls to CNode to collect view extensions
 *
 * PARAMETERS:
 *    HNODE hNodeScope
 *    CViewExtInsertIterator it
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CNodeCallback::GetNodeViewExtensions(/*[in]*/ HNODE hNodeScope, /*[out]*/ CViewExtInsertIterator it)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetNodeViewExtensions"));

    // get CNode pointer
    CNode* pNode = CNode::FromHandle(hNodeScope);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    sc = pNode->ScGetViewExtensions(it);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::SaveColumnInfoList
//
//  Synopsis:    The column-data for given node has changed persist the
//               new column data.
//
//  Arguments:   [hNode] - Node that owns result-pane.
//               [columnsList] - The new column-data.
//
//  Note:        The sort-data is not given by this call, so do not change it.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::SaveColumnInfoList (HNODE hNode, const CColumnInfoList& columnsList)
{
    DECLARE_SC(sc, _T("CNodeCallback::SaveColumnInfoList"));
    sc = ScCheckPointers(hNode);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CLSID          guidSnapin;
    CXMLAutoBinary columnID;
    sc = pNode->ScGetSnapinAndColumnDataID(guidSnapin, columnID);
    if (sc)
        return sc.ToHr();

    CXMLBinaryLock sLock(columnID);
    SColumnSetID* pColID = NULL;
    sc = sLock.ScLock(&pColID);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pColID, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Get the old persisted column data. This contains width values
    // for hidden columns which is used if the column is un-hidden.
    CColumnSetData columnSetData;
    BOOL bRet = pViewData->RetrieveColumnData(guidSnapin, *pColID, columnSetData);

    if (bRet)
    {
        CColumnInfoList*  pColInfoListOld = columnSetData.get_ColumnInfoList();

        if (columnsList.size() == pColInfoListOld->size())
        {
            // Merge the persisted column width for hidden columns
            // to the new list created.
            CColumnInfoList::iterator itColInfo1;
            CColumnInfoList::iterator itColInfo2;

            for (itColInfo1 = pColInfoListOld->begin(), itColInfo2 = columnsList.begin();
                 itColInfo1 != pColInfoListOld->end(); ++itColInfo1, ++itColInfo2)
            {
                if (itColInfo2->IsColHidden())
                    itColInfo2->SetColWidth(itColInfo1->GetColWidth());
            }
        }
    }

    // Set the new columns list in column-set-data.
    columnSetData.set_ColumnInfoList(columnsList);

    // Save the data.
    sc = pViewData->ScSaveColumnInfoList(guidSnapin, *pColID, columnsList);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::GetPersistedColumnInfoList
//
//  Synopsis:    The list-view requests the column-data (no sort data) to setup the headers
//               before any items are inserted into the list-view.
//               (Note: Modify headers after all columns are inserted before any list-view
//                      items will be inserted to reduce flicker).
//
//  Arguments:   [hNode] - node that owns result-pane for which column-data is needed.
//               [pColumnsList] - [out param], the column-data.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::GetPersistedColumnInfoList (HNODE hNode, CColumnInfoList *pColumnsList)
{
    DECLARE_SC(sc, _T("CNodeCallback::GetPersistedColumnInfoList"));
    sc = ScCheckPointers(hNode, pColumnsList);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CLSID          guidSnapin;
    CXMLAutoBinary columnID;
    sc = pNode->ScGetSnapinAndColumnDataID(guidSnapin, columnID);
    if (sc)
        return sc.ToHr();

    CXMLBinaryLock sLock(columnID);
    SColumnSetID* pColID = NULL;
    sc = sLock.ScLock(&pColID);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pColID, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Get the old persisted column data. This contains width values
    // for hidden columns which is used if the column is un-hidden.
    CColumnSetData columnSetData;
    BOOL bRet = pViewData->RetrieveColumnData(guidSnapin, *pColID, columnSetData);

    if (!bRet)
        return (sc = S_FALSE).ToHr();

    CColumnInfoList *pColListOriginal = columnSetData.get_ColumnInfoList();
    if (!pColListOriginal)
        return (sc = S_FALSE).ToHr();

    *pColumnsList = *pColListOriginal;

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::DeletePersistedColumnData
//
//  Synopsis:    The column data for given node is invalid, remove it.
//
//  Arguments:   [hNode] - The node for which the data is invalid.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::DeletePersistedColumnData(HNODE hNode)
{
    DECLARE_SC(sc, _T("CNodeCallback::DeletePersistedColumnData"));
    sc = ScCheckPointers(hNode);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CLSID          guidSnapin;
    CXMLAutoBinary columnID;
    sc = pNode->ScGetSnapinAndColumnDataID(guidSnapin, columnID);
    if (sc)
        return sc.ToHr();

    CXMLBinaryLock sLock(columnID);
    SColumnSetID* pColID = NULL;
    sc = sLock.ScLock(&pColID);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pColID, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Get the old persisted column data. This contains width values
    // for hidden columns which is used if the column is un-hidden.
    pViewData->DeleteColumnData(guidSnapin, *pColID);

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::DoesAboutExist
//
//  Synopsis:    See if about information exists for given node's snapin.
//
//  Arguments:   [hNode]         -
//               [pbAboutExists] - out param, ptr to bool, true if about exists.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::DoesAboutExist (HNODE hNode, bool *pbAboutExists)
{
    DECLARE_SC(sc, _T("CNodeCallback::DoesAboutExist"));
    sc = ScCheckPointers(hNode, pbAboutExists);
    if (sc)
        return sc.ToHr();

    *pbAboutExists = false;

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    // No about for console root eventhough it is a Folder snapin.
    if (pNode->IsConsoleRoot())
        return sc.ToHr();

    CLSID        clsidAbout;
    const CLSID& clsidSnapin = pNode->GetPrimarySnapInCLSID();
    SC scNoTrace = ScGetAboutFromSnapinCLSID(clsidSnapin, clsidAbout);
    if (scNoTrace)
        return scNoTrace.ToHr();

    CSnapinAbout snapinAbout;
    snapinAbout.GetSnapinInformation(clsidAbout);
    sc = snapinAbout.GetObjectStatus();
    if (sc)
        return sc.ToHr();

    *pbAboutExists = true;

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::ShowAboutInformation
//
//  Synopsis:    Given the context of currently selected item.
//               Show its about information.
//
//  Arguments:   [hNode]   - scope node that owns result pane.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::ShowAboutInformation (HNODE hNode)
{
    DECLARE_SC(sc, _T("CNodeCallback::ShowAboutInformation"));
    sc = ScCheckPointers(hNode);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    CLSID        clsidAbout;
    const CLSID& clsidSnapin = pNode->GetPrimarySnapInCLSID();
    sc = ScGetAboutFromSnapinCLSID(clsidSnapin, clsidAbout);
    if (sc)
        return sc.ToHr();

    CSnapinAbout snapinAbout;
    snapinAbout.GetSnapinInformation(clsidAbout);

    USES_CONVERSION;
    tstring szSnapinName;
    if (GetSnapinNameFromCLSID(clsidSnapin, szSnapinName))
        snapinAbout.SetSnapinName(T2COLE(szSnapinName.data()));

    sc = snapinAbout.GetObjectStatus();
    if (sc)
        return sc.ToHr();

    snapinAbout.ShowAboutBox();

    return (sc.ToHr());
}

/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::ExecuteShellCommand
 *
 * PURPOSE: Executes a shell command with the specified parameters in the
 *          specified directory with the correct window size
 *
 * PARAMETERS:
 *    HNODE  hNode :
 *    BSTR   Command :
 *    BSTR   Directory :
 *    BSTR   Parameters :
 *    BSTR   WindowState :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CNodeCallback::ExecuteShellCommand(HNODE hNode, BSTR Command, BSTR Directory, BSTR Parameters, BSTR WindowState)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::ExecuteShellCommand"));

    sc = ScCheckPointers(hNode);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    sc = pNode->ScExecuteShellCommand(Command, Directory, Parameters, WindowState);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::QueryPasteFromClipboard
//
//  Synopsis:    Given the context of paste target, get the clipboard dataobject
//               and see if target allows paste.
//
//  Arguments:   [hNode] -
//               [bScope] -
//               [lCookie] - All above params describe paste target context.
//               [bPasteAllowed] - [out]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::QueryPasteFromClipboard (HNODE hNode, BOOL bScope, LPARAM lCookie, bool& bPasteAllowed)
{
    DECLARE_SC(sc, _T("CNodeCallback::QueryPasteFromClipboard"));
    sc = ScCheckPointers(hNode);
    if (sc)
        return sc.ToHr();

    // 1. Get the current dataobject from clipboard.
    IDataObjectPtr spDOPaste;
    sc = OleGetClipboard(&spDOPaste);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(spDOPaste, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    bool bCopyOperatationIsDefault = false; /*unused*/

    sc = QueryPaste(hNode, bScope, lCookie, spDOPaste, bPasteAllowed, bCopyOperatationIsDefault);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::QueryPaste
//
//  Synopsis:    Given the context for current selection which is the target
//               for paste (or drop). Find out it can paste given dataobject.
//
//  Arguments:   [hNode]              - The node owning the view.
//               [bScope]             - Selection on Scope or Result pane.
//               [lCookie]            - If result pane selected the cookie for selected result item.
//               [pDataObjectToPaste] - The dataobject to be pasted.
//               [bPasteAllowed]      - [out param], paste was permitted or not.
//               [bCopyOperatationIsDefault] - [out param], is copy default operation (for r-click&l-click drag&drop)
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::QueryPaste (HNODE hNode, BOOL bScopePaneSelected, LPARAM lCookie,
                                        IDataObject *pDataObjectToPaste,
                                        bool& bPasteAllowed, bool& bCopyOperatationIsDefault)
{
    DECLARE_SC(sc, _T("CNodeCallback::NewQueryPaste"));
    bPasteAllowed = false;
    sc = ScCheckPointers(hNode, pDataObjectToPaste);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // If result-pane cookie should be valid.
    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, bScopePaneSelected, lCookie,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return (sc = E_FAIL).ToHr();

    CViewData *pViewData = pSelectedNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Do not allow paste into OCX/WEB/Multiselection
    // We can allow paste into OCX/WEB if we expose IMMCClipboardDataObject
    // interface. But paste into Multiselection should not be allowed as
    // it is not intuitive.
    if ( (!bScopeItemSelected) && IS_SPECIAL_COOKIE(lCookie))
        return sc.ToHr();

    /*
     * In MMC1.2 the drop target is always scope node. In MMC2.0
     * it can be any result item. If the snapin has RVTI_LIST_OPTIONS_ALLOWPASTE
     * set, then we need to provide proper parameters to below _GetVerbState.
     */
    if ( (bScopeItemSelected == FALSE) && (! (RVTI_LIST_OPTIONS_ALLOWPASTE & pViewData->GetListOptions())) )
        return sc.ToHr();

    IDataObjectPtr spTargetDataObject;
    sc = pSelectedNode->ScGetDropTargetDataObject(bScopeItemSelected, lCookie, &spTargetDataObject);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(spTargetDataObject, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    BOOL bFlag = FALSE;
    sc = _ScGetVerbState(pSelectedNode, MMC_VERB_PASTE, spTargetDataObject,
                         bScopeItemSelected, lCookie, /*bMultiSel*/FALSE, bFlag);
    if (sc)
        return sc.ToHr();

    if (!bFlag)
        return sc.ToHr();

    // QI to see if it is MMC's data object
    IMMCClipboardDataObjectPtr spMMCClipboardDataObj = pDataObjectToPaste;

    if (spMMCClipboardDataObj)
    {
        // This is our own dataobject.

        // 3. Get how, where it is created, and how many snapin objects are there.
        DWORD dwSourceProcess = 0;
        sc = spMMCClipboardDataObj->GetSourceProcessId( &dwSourceProcess );
        if (sc)
            return sc.ToHr();

        // If from different process then ask snapin if it can handle out of proc dataobjects.
        BOOL bSourceFromDifferentMMCProcess = ( dwSourceProcess != ::GetCurrentProcessId() );

        DWORD dwNumObjects = 0;
        sc = spMMCClipboardDataObj->GetCount(&dwNumObjects);
        if (sc)
            return sc.ToHr();

        // 4. For each snapin object, get the dataobject and ask target item if
        //    it can allow the source to be pasted.
        for (DWORD index = 0; index < dwNumObjects; ++index)
        {
            IDataObjectPtr spSourceDataObject;
            DWORD dwFlags = 0;
            sc = spMMCClipboardDataObj->GetDataObject( index, &spSourceDataObject, &dwFlags );
            if (sc)
                return sc.ToHr();

            sc = ScCheckPointers(spSourceDataObject, E_UNEXPECTED);
            if (sc)
                return sc.ToHr();

            // must have some operation allowed - else it is invalid entry
            if ( dwFlags == 0 )
                return (sc = E_UNEXPECTED).ToHr();
            /*
             * During construction of th MMCClipboardDataObject we have checked if
             * cut/copy is enabled before adding the snapin dataobject.
             * So we are sure now atleast cut or copy is enabled for each snapin
             * object and we dont have to check this again.
             */

            bool bSnapinPasteAllowed = false;
            bool bSnapinWantsCopyAsDefault = false;
            sc = _ScQueryPaste (pSelectedNode, spTargetDataObject, spSourceDataObject,
                                bSourceFromDifferentMMCProcess, bSnapinPasteAllowed,
                                bSnapinWantsCopyAsDefault);
            if (sc)
                return sc.ToHr();

            bPasteAllowed = bPasteAllowed || bSnapinPasteAllowed;
            bCopyOperatationIsDefault = bCopyOperatationIsDefault || bSnapinWantsCopyAsDefault;
        }

    }
    else
    {
        // We do not recognize the dataobject and we dont know if it is from
        // this MMC process or from any other process. So do not ask snapin if
        // it can handle outofproc dataobjects or not. (This is MMC1.2 legacy case).

        sc = _ScQueryPaste (pSelectedNode, spTargetDataObject, pDataObjectToPaste,
                             /*bSourceFromDifferentMMCProcess = */ false,
                             bPasteAllowed, bCopyOperatationIsDefault);
        if (sc)
            return sc.ToHr();
    }

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::_ScQueryPaste
//
//  Synopsis:    Send MMCN_QUERY_PASTE(2) to the snapin.
//
//  Arguments:   [pNode]              - Owner of result pane.
//               [spTargetDataObject] - Target object where we want to paste.
//               [spSourceDataObject] - The object that we want to paste.
//               [bSourceFromDifferentMMCProcess] -
//               [bPasteAllowed]            - out param
//               [bCopyOperationIsDefault]  - out param
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNodeCallback::_ScQueryPaste (CNode *pNode,
                                 IDataObject *pTargetDataObject,
                                 IDataObject *pSourceDataObject,
                                 bool bSourceFromDifferentMMCProcess,
                                 bool& bPasteAllowed,
                                 bool& bCopyOperatationIsDefault)
{
    DECLARE_SC(sc, _T("CNodeCallback::_ScQueryPaste"));
    sc = ScCheckPointers(pNode, pTargetDataObject, pSourceDataObject);
    if (sc)
        return sc;

    bCopyOperatationIsDefault = false;
    bPasteAllowed             = false;

    CComponent* pCC = pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pCC, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    BOOL bCanPasteOutOfProcDataObject = FALSE;

    sc = pCC->Notify(NULL, MMCN_CANPASTE_OUTOFPROC,
                     0, reinterpret_cast<LPARAM>(&bCanPasteOutOfProcDataObject) );

    // Snapins return E_* values so check if they are OK with above notification.
    if ( sc != S_OK)
    {
        bCanPasteOutOfProcDataObject = false;
        sc.Clear();
    }

    // Source from diff MMC process & cannot handle outofproc dataobjects then return.
    if (bSourceFromDifferentMMCProcess && (! bCanPasteOutOfProcDataObject) )
        return sc.ToHr();

    // Send MMCN_QUERY_PASTE
    DWORD dwFlags = 0;
    sc = pCC->Notify(pTargetDataObject, MMCN_QUERY_PASTE,
                     reinterpret_cast<LPARAM>(pSourceDataObject),
                     reinterpret_cast<LPARAM>(&dwFlags));
    if (sc)
    {
        // Clear any snapin returned errors.
        sc.Clear();
        return sc.ToHr();
    }

    if (sc == SC(S_OK))
        bPasteAllowed = true;

    bCopyOperatationIsDefault = (dwFlags & MMC_DEFAULT_OPERATION_COPY);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::Drop
//
//  Synopsis:    Given the drop object context & the source object to
//               be dropped. Do paste operation.
//
//  Arguments:   [hNode]              - The node owning the view.
//               [bScope]             - Selection on Scope or Result pane.
//               [lCookie]            - If result pane selected the cookie for selected result item.
//               [pDataObjectToPaste] - The dataobject to be pasted.
//               [bIsDragOperationMove]- Is the drag operation move or copy.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::Drop (HNODE hNode, BOOL bScope, LPARAM lCookie, IDataObject *pDataObjectToPaste, BOOL bIsDragOperationMove)
{
    DECLARE_SC(sc, _T("CNodeCallback::Drop"));
    sc = ScCheckPointers(hNode, pDataObjectToPaste);
    if (sc)
        return sc.ToHr();

    sc = ScPaste(hNode, bScope, lCookie, pDataObjectToPaste, TRUE, bIsDragOperationMove);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}



//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::Paste
//
//  Synopsis:    Given the target where the clipboard object is to be
//               pasted. Paste the object.
//
//  Arguments:   [hNode]              - The node owning the view.
//               [bScope]             - Selection on Scope or Result pane.
//               [lCookie]            - If result pane selected the cookie for selected result item.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::Paste (HNODE hNode, BOOL bScope, LPARAM lCookie)
{
    DECLARE_SC(sc, _T("CNodeCallback::Paste"));
    sc = ScCheckPointers(hNode);
    if (sc)
        return sc.ToHr();

    IDataObjectPtr spDOPaste;
    sc = OleGetClipboard(&spDOPaste);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(spDOPaste, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = ScPaste(hNode, bScope, lCookie, spDOPaste, /*bDragDrop*/FALSE, FALSE);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::ScPaste
//
//  Synopsis:   Given the current drop target (or paste target) context
//              paste the given data object if it is drag&drop operation
//              else paste the one from clipboard.
//
//  Arguments:   [hNode]               - The node owning the view.
//               [bScopePaneSelected]  - Selection on Scope or Result pane.
//               [lCookie]             - If result pane selected the cookie for selected result item.
//               [pDataObjectToPaste]  - The dataobject to be pasted.
//               [bDragDrop]           - Is the operation drag & drop operation.
//               [bIsDragOperationMove]- Is the drag operation move or copy.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNodeCallback::ScPaste (HNODE hNode, BOOL bScopePaneSelected, LPARAM lCookie,
                           IDataObject *pDataObjectToPaste, BOOL bDragDrop,
                           BOOL bIsDragOperationMove)
{
    DECLARE_SC(sc, _T("CNodeCallback::Paste"));
    sc = ScCheckPointers(hNode, pDataObjectToPaste);
    if (sc)
        return sc;

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc;

    // If result-pane cookie should be valid.
    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, bScopePaneSelected, lCookie,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc;

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc;

    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return (sc = E_FAIL);

    CViewData *pViewData = pSelectedNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    // Do not allow paste into OCX/WEB/Multiselection
    // We can allow paste into OCX/WEB if we expose IMMCClipboardDataObject
    // interface. But paste into Multiselection should not be allowed as
    // it is not intuitive.
    if ( (!bScopeItemSelected) && IS_SPECIAL_COOKIE(lCookie))
        return sc;

    /*
     * In MMC1.2 the drop target is always scope node. In MMC2.0
     * it can be any result item.
     * Make sure if the snapin has RVTI_LIST_OPTIONS_ALLOWPASTE.
     */
    if ( (bScopeItemSelected == FALSE) && (! (RVTI_LIST_OPTIONS_ALLOWPASTE & pViewData->GetListOptions())) )
    {
        ASSERT(0 && "UNEXPECTED: We can paste only into a folder!");
        // We can paste only into a folder.
        return (sc = E_FAIL);
    }

    if (pSelectedNode->IsInitialized() == FALSE)
    {
        sc = _InitializeNode(pSelectedNode);
        if (sc)
            return sc;
    }

    IDataObject* pTargetDataObject = NULL;
    sc = pSelectedNode->ScGetDropTargetDataObject(bScopeItemSelected, lCookie, &pTargetDataObject);
    if (sc)
        return sc;

    IDataObjectPtr spTargetDataObject;
    if (! IS_SPECIAL_DATAOBJECT(pTargetDataObject))
        spTargetDataObject = pTargetDataObject;          // Addref the object

    sc = ScCheckPointers(pTargetDataObject, E_UNEXPECTED);
    if (sc)
        return sc;

    // QI to see if it is MMC's data object
    IMMCClipboardDataObjectPtr spMMCClipboardDataObj = pDataObjectToPaste;

    if (spMMCClipboardDataObj)
    {
        // This is our own dataobject.

        // 3. Get how, where it is created, and how many snapin objects are there.

        DATA_SOURCE_ACTION eSourceAction;
        sc = spMMCClipboardDataObj->GetAction( &eSourceAction );
        if (sc)
            return sc;

        BOOL bIsCreatedForCut = FALSE;
        BOOL bIsCreatedForCopy = FALSE;

        if (bDragDrop)
        {
            bIsCreatedForCut  = bIsDragOperationMove;
            bIsCreatedForCopy = !bIsDragOperationMove;
        }
        else
        {
            bIsCreatedForCut =  ( eSourceAction == ACTION_CUT );
            bIsCreatedForCopy = ( eSourceAction == ACTION_COPY );
        }

        DWORD dwNumObjects = 0;
        sc = spMMCClipboardDataObj->GetCount(&dwNumObjects);
        if (sc)
            return sc;

        BOOL bDoCutOperation  = FALSE;
        BOOL bDoCopyOperation = FALSE;

        // 4. For each snapin object, get the dataobject and ask target to paste it.

        // need to form the array of copy objects, so that we do not delete them while
        // processing - this invalidates data object and prevents accessing the rest of
        // items
        std::vector<IDataObjectPtr> vecObjectsToCopy;
        std::vector<DWORD> vecObjectFlags;

        vecObjectsToCopy.reserve(dwNumObjects); // small optimization
        vecObjectFlags.reserve(dwNumObjects);   // small optimization

        // fill with data objects to copy
        for (DWORD index = 0; index < dwNumObjects; ++index)
        {
            IDataObjectPtr spSourceDataObject;
            DWORD dwFlags = 0;
            sc = spMMCClipboardDataObj->GetDataObject( index, &spSourceDataObject, &dwFlags );
            if (sc)
                return sc;

            vecObjectsToCopy.push_back( spSourceDataObject );
            vecObjectFlags.push_back( dwFlags );
        }

        // perform action on the data
        for (index = 0; index < dwNumObjects; ++index)
        {
            IDataObjectPtr spSourceDataObject = vecObjectsToCopy[index];
            DWORD dwFlags = vecObjectFlags[index];

            sc = ScCheckPointers(spSourceDataObject, E_UNEXPECTED);
            if (sc)
                return sc;

            BOOL bHasCutEnabled =  ( dwFlags & MOVE_ALLOWED );
            BOOL bHasCopyEnabled = ( dwFlags & COPY_ALLOWED );

            /*
             * In case of multiselection even if one of the selected
             * object enables cut, the cut operation can be performed.
             *
             * But when we paste the objects we need to see if source
             * enabled cut or not. If it did not enable then do nothing.
             *
             * Below is a table for this.
             *
             *                          Source object enables (only)
             *          -------------------------------------------
             *          |Operation   |     Cut    |    Copy       |
             *          -------------------------------------------
             *          |            |            |               |
             *          |  Cut       |   Cut      |  Do nothing   |
             * Current  |            |            |               |
             * Operation|-----------------------------------------
             *          |            |            |               |
             *          | Copy       | Do nothing |    Copy       |
             *          |            |            |               |
             *          -------------------------------------------
             */
            bDoCutOperation  = (bIsCreatedForCut && bHasCutEnabled);
            bDoCopyOperation = (bIsCreatedForCopy && bHasCopyEnabled);

            // See above table: this is "Do nothing".
            if ( (!bDoCutOperation) && (!bDoCopyOperation) )
                continue;

            IDataObjectPtr spCutDataObject;
            sc = _ScPaste (pSelectedNode, pTargetDataObject,
                           spSourceDataObject, &spCutDataObject,
                           bDoCutOperation );
            if (sc)
                return sc;

            // remove cut items when required
            if (bDoCutOperation && spCutDataObject != NULL)
            {
                sc = spMMCClipboardDataObj->RemoveCutItems( index, spCutDataObject );
                if (sc)
                    return sc;
            }
        }

        // If this is cut operation that is initiated by cut/copy/paste and
        // not by drag & drop operation then the dataobject in clipboard is
        // ours. So clear the clipboard so that we dont use that dataobject.
        if ( eSourceAction == ACTION_CUT )
            OleSetClipboard(NULL);
    }
    else
    {
        // We do not recognize the dataobject and we dont know if it is from
        // this MMC process or from any other process. We cannot decode this
        // dataobject so we just send MMCN_PASTE and ignore any dataobject
        // retuned by snapin for cut operation (this is legacy case).

        // for drag operation we can give a hint to snapin
        // what operation (copy/move) was attempted.
        // however we are not ensuring deletion of source items
        bool bCutOrMove = (bDragDrop && bIsDragOperationMove);

        IDataObjectPtr spCutDataObject;
        sc = _ScPaste (pSelectedNode, pTargetDataObject,
                       pDataObjectToPaste, &spCutDataObject,
                       bCutOrMove );
        if (sc)
            return sc;
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::_ScPaste
//
//  Synopsis:    Send MMCN_PASTE to snapin.
//
//  Arguments:   [pNode] - Owner of resultpane.
//               [pTargetDataObject] - target where we need to paste.
//               [pSourceDataObject] - source to be pasted.
//               [ppCutDataObject] - (out) cut items
//               [bCutOrMove]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNodeCallback::_ScPaste (CNode *pNode,
                            IDataObject *pTargetDataObject,
                            IDataObject *pSourceDataObject,
                            IDataObject **ppCutDataObject,
                            bool bCutOrMove)
{
    DECLARE_SC(sc, _T("CNodeCallback::_ScSendPasteNotification"));
    sc = ScCheckPointers(pNode, pTargetDataObject, pSourceDataObject, ppCutDataObject);
    if (sc)
        return sc;

    // init out param
    *ppCutDataObject = NULL;

    CComponent* pComponent = pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if (sc)
        return sc;

    IDataObject* pDataObjectToBeCutBySource = NULL;
    sc = pComponent->Notify(pTargetDataObject, MMCN_PASTE,
                            reinterpret_cast<LPARAM>(pSourceDataObject),
                            bCutOrMove ? reinterpret_cast<LPARAM>(&pDataObjectToBeCutBySource) : NULL);
    if (sc)
        return sc;

    if (! bCutOrMove)
        return sc;

    // Exchange returns NULL dataobject. Do not trace error to be compatible with MMC1.2
    if ( (pDataObjectToBeCutBySource) && (IS_SPECIAL_DATAOBJECT(pDataObjectToBeCutBySource) ) )
        return (sc = E_UNEXPECTED);

    // transfer control to the client ( no addref nor release in neaded )
    *ppCutDataObject = pDataObjectToBeCutBySource;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::QueryViewSettingsPersistor
//
//  Synopsis:    Get the IPersistStream interface of CViewSettingsPersistor
//               object to load the viewsettings (will not be asked for
//               storing as saving is always XML format).
//
//  Arguments:   [ppStream] - [out]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::QueryViewSettingsPersistor (IPersistStream** ppStream)
{
    DECLARE_SC(sc, _T("CNodeCallback::QueryViewSettingsPersistor"));
    sc = ScCheckPointers(ppStream);
    if (sc)
        return sc.ToHr();

    *ppStream = NULL;

    // Call CNode static method to get IPersistStream interface.
    sc = CNode::ScQueryViewSettingsPersistor(ppStream);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::QueryViewSettingsPersistor
//
//  Synopsis:    Get the CXMLObject interface of CViewSettingsPersistor
//               object to save/load the viewsettings from XML console file.
//
//  Arguments:   [ppXMLObject] - [out]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::QueryViewSettingsPersistor (CXMLObject** ppXMLObject)
{
    DECLARE_SC(sc, _T("CNodeCallback::QueryViewSettingsPersistor"));

    sc = ScCheckPointers(ppXMLObject);
    if (sc)
        return sc.ToHr();

    *ppXMLObject = NULL;

    // Call CNode static method to get CXMLObject interface.
    sc = CNode::ScQueryViewSettingsPersistor(ppXMLObject);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::DocumentClosing
//
//  Synopsis:    The document is to be closed, so release any document
//               related objects. (CViewSettingsPersistor).
//
//  Arguments:   None
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::DocumentClosing ()
{
    DECLARE_SC(sc, _T("CNodeCallback::DocumentClosing"));

    // 1. Call CNode static method informing document closing.
    sc = CNode::ScOnDocumentClosing();
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\scoptree.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       scoptree.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "scopiter.h"
#include "scopndcb.h"

#include "addsnpin.h"
#include "ScopImag.h"
#include "NodeMgr.h"

#include "amcmsgid.h"
#include "regutil.h"
#include "copypast.h"
#include "multisel.h"
#include "nodepath.h"
#include "tasks.h"
#include "colwidth.h"
#include "viewpers.h"
#include <comdbg.h>
#include "conframe.h"
#include "siprop.h"
#include "fldrsnap.h"
#include "variant.h"
#include "condoc.h"
#include "oncmenu.h"
#include "conview.h"
#include "eventlock.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#ifdef DBG
CTraceTag tagScopeTreeAddSnapin(TEXT("CScopeTree"), TEXT("ScAddSnapIn"));
#endif


//############################################################################
//############################################################################
//
//  Implementation of class CSnapIns
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CSnapIns
 *
 *
 * PURPOSE: Implements the SnapIns automation interface.
 *
 *+-------------------------------------------------------------------------*/
class _CSnapIns :
    public CMMCIDispatchImpl<SnapIns>,
    public CTiedComObject<CScopeTree>
{
public:
    typedef CScopeTree CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(_CSnapIns)
    END_MMC_COM_MAP()

    // SnapIns interface
public:
    MMC_METHOD4(Add,            BSTR /*bstrSnapinNameOrCLSID*/, VARIANT /*varParentSnapinNode*/, VARIANT /*varProperties*/, PPSNAPIN /*ppSnapIn*/);
    MMC_METHOD2(Item,           long /*Index*/, PPSNAPIN /*ppSnapIn*/);
    MMC_METHOD1(Remove,         PSNAPIN /*pSnapIn*/)
    MMC_METHOD1(get_Count, PLONG /*pCount*/);

    IUnknown *STDMETHODCALLTYPE get__NewEnum() {return NULL;}
};


// this typedefs the real CSnapIns class. Implements get__NewEnum using CMMCEnumerator and a CSnapIns_Positon object
typedef CMMCNewEnumImpl<_CSnapIns, CScopeTree::CSnapIns_Positon> CSnapIns;


//############################################################################
//############################################################################
//
//  Implementation of class CScopeNamespace
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CScopeNamespace
 *
 *
 * PURPOSE: Implements the ScopeNamespace automation interface.
 *
 *+-------------------------------------------------------------------------*/
class CScopeNamespace :
    public CMMCIDispatchImpl<ScopeNamespace>,
    public CTiedComObject<CScopeTree>
{
protected:

    typedef CScopeTree CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(CScopeNamespace)
    END_MMC_COM_MAP()

    // ScopeNamespace interface
public:
    MMC_METHOD2(GetParent,     PNODE /*pNode*/, PPNODE /*ppParent*/);
    MMC_METHOD2(GetChild,      PNODE /*pNode*/, PPNODE /*ppChild*/);
    MMC_METHOD2(GetNext,       PNODE /*pNode*/, PPNODE /*ppNext*/);
    MMC_METHOD1(GetRoot,       PPNODE /*ppRoot*/);
    MMC_METHOD1(Expand,        PNODE  /*pNode*/);
};



//############################################################################
//############################################################################
//
//  Implementation of class CMMCScopeNode
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CMMCScopeNode::~CMMCScopeNode
 *
 * PURPOSE: Destructor
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 *+-------------------------------------------------------------------------*/
CMMCScopeNode::~CMMCScopeNode()
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::~CMMCScopeNode"));

    CScopeTree *pScopeTree = CScopeTree::GetScopeTree();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (!sc)
    {
        sc = pScopeTree->ScUnadviseMMCScopeNode(this);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCScopeNode::ScIsValid
 *
 * PURPOSE: Returns an error if the COM object is no longer valid.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMMCScopeNode::ScIsValid()
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::ScIsValid"));

    if(!GetMTNode())
        return (sc = E_INVALIDARG);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCScopeNode::get_Name
 *
 * PURPOSE: Returns the display name of the node.
 *
 * PARAMETERS:
 *    PBSTR   pbstrName :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCScopeNode::get_Name( PBSTR  pbstrName)
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::get_Name"));

    // check parameters
    if (!pbstrName)
        return ((sc = E_INVALIDARG).ToHr());

    CMTNode* pMTNode = GetMTNode();
    sc = ScCheckPointers (pMTNode, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    tstring strName = pMTNode->GetDisplayName();

    USES_CONVERSION;
    *pbstrName = ::SysAllocString (T2COLE(strName.data())); // caller frees

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCScopeNode::ScGetDataObject
 *
 * PURPOSE: Returns the data object for a scope node.
 *
 * PARAMETERS:
 *    IDataObject ** ppDataObject :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMMCScopeNode::ScGetDataObject(IDataObject **ppDataObject)
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::ScGetDataObject"));

    sc = ScCheckPointers(ppDataObject);
    if(sc)
        return sc;

    // init out parameter
    *ppDataObject = NULL;

    // get the MT node
    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers( pMTNode, E_UNEXPECTED );
    if(sc)
        return sc;

    CComponentData* pCCD = pMTNode->GetPrimaryComponentData();
    sc = ScCheckPointers( pCCD, E_NOTIMPL ); // no component data -> no property...
    if(sc)
        return sc;

    // ensure node is expanded before requesting data object
    if (pMTNode->WasExpandedAtLeastOnce() == FALSE)
        pMTNode->Expand();

    // Get the data object for the cookie from the owner snap-in
    sc = pCCD->QueryDataObject(pMTNode->GetUserParam(), CCT_SCOPE, ppDataObject);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCScopeNode::get_Property
 *
 * PURPOSE: returns snapins property for scope node
 *
 * PARAMETERS:
 *    BSTR bstrPropertyName     -[in] property name (clipboard format)
 *    PBSTR  pbstrPropertyValue -[out] property value
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP
CMMCScopeNode::get_Property( BSTR bstrPropertyName, PBSTR  pbstrPropertyValue )
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::get_Property"));

    // parameter check
    sc = ScCheckPointers(bstrPropertyName, pbstrPropertyValue);
    if (sc)
        return sc.ToHr();

    // init out parameter
    *pbstrPropertyValue = NULL;

    IDataObjectPtr spDataObject;
    sc = ScGetDataObject(&spDataObject);
    if(sc)
        return sc.ToHr();

    // get the MT node
    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers( pMTNode, E_UNEXPECTED );
    if(sc)
        return sc.ToHr();

    // try to get the property from the INodeProperties interface
    sc = pMTNode->ScGetPropertyFromINodeProperties(spDataObject, bstrPropertyName, pbstrPropertyValue);
    if( (!sc.IsError()) && (sc != S_FALSE)   ) // got it, exit
        return sc.ToHr();

    // didn't find it, continue
    sc.Clear();

    // get the property from data object
    sc = CNodeCallback::ScGetProperty(spDataObject, bstrPropertyName,  pbstrPropertyValue);
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCScopeNode::get_Bookmark
 *
 * PURPOSE: Returns the bookmark of the node (XML format).
 *
 * PARAMETERS:
 *    PBSTR pbstrBookmark :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCScopeNode::get_Bookmark( PBSTR pbstrBookmark )
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::get_Bookmark"));

    // parameter checking
    sc = ScCheckPointers( pbstrBookmark );
    if(sc)
        return sc.ToHr();

    // cleanup result
    *pbstrBookmark = NULL;

    // get the MT node
    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers( pMTNode, E_FAIL );
    if(sc)
        return sc.ToHr();

    // get the pointer to bookmark
    CBookmark* pBookmark = pMTNode->GetBookmark();
    sc = ScCheckPointers( pBookmark, E_UNEXPECTED );
    if(sc)
        return sc.ToHr();

    std::wstring xml_contents;
    sc = pBookmark->ScSaveToString(&xml_contents);
    if(sc)
        return sc.ToHr();

    // store the result
    CComBSTR bstrBuff(xml_contents.c_str());
    *pbstrBookmark = bstrBuff.Detach();

    sc = ScCheckPointers( *pbstrBookmark, E_OUTOFMEMORY );
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCScopeNode::IsScopeNode
 *
 * PURPOSE: Returns TRUE indicating that the node is a scope node.
 *
 * PARAMETERS:
 *    PBOOL  pbIsScopeNode :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCScopeNode::IsScopeNode(PBOOL pbIsScopeNode)
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::IsScopeNode"));

    // check parameters
    if(!pbIsScopeNode)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    *pbIsScopeNode = TRUE;

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCScopeNode::get_Nodetype
 *
 * PURPOSE: Returns the nodetype of a scope node.
 *
 * PARAMETERS:
 *    PBSTR  Nodetype :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCScopeNode::get_Nodetype(PBSTR Nodetype)
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::get_Nodetype"));

    // parameter check
    sc = ScCheckPointers(Nodetype);
    if (sc)
        return sc.ToHr();

    // init out parameter
    *Nodetype = NULL;

    // get the data object
    IDataObjectPtr spDataObject;
    sc = ScGetDataObject(&spDataObject);
    if(sc)
        return sc.ToHr();

    // get the nodetype from the data object
    sc = CNodeCallback::ScGetNodetype(spDataObject, Nodetype);
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}


///////////////////////////////////////////////////////////////////////////////
//
// Forward declaration of local function
//
static SC
ScCreateMTNodeTree(PNEWTREENODE pNew, CMTNode* pmtnParent,
                   CMTNode** ppNodeCreated);
HRESULT AmcNodeWizard(MID_LIST NewNodeType, CMTNode* pNode, HWND hWnd);


//////////////////////////////////////////////////////////////////////////////
//
// Public variables
//
const wchar_t* AMCSnapInCacheStreamName = L"cash";
const wchar_t* AMCTaskpadListStreamName = L"TaskpadList";


///////////////////////////////////////////////////////////////////////////////
//
// Implementation of CScopeTree class
//

DEBUG_DECLARE_INSTANCE_COUNTER(CScopeTree);

bool                    CScopeTree::m_fRequireSyncExpand = false;
CScopeTree*             CScopeTree::m_pScopeTree         = NULL;
IStringTablePrivatePtr  CScopeTree::m_spStringTable;

CScopeTree::CScopeTree()
    :   m_pMTNodeRoot(NULL),
        m_pImageCache(NULL),
        m_pConsoleData(NULL),
        m_pConsoleTaskpads(NULL),
        m_pDefaultTaskpads(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CScopeTree);
    ASSERT (m_pScopeTree == NULL);
    m_pScopeTree = this;
}

CScopeTree::~CScopeTree()
{
    /*
     * Clear out the string table interface (before Cleanup!) to keep
     * CMTNode dtors from removing their names from the string table.
     */
    m_spStringTable = NULL;

    Cleanup();

    ASSERT (m_pScopeTree == this);
    if (m_pScopeTree == this)
        m_pScopeTree = NULL;

    DEBUG_DECREMENT_INSTANCE_COUNTER(CScopeTree);
}


HRESULT CScopeTree::SetConsoleData(LPARAM lConsoleData)
{
    m_pConsoleData = reinterpret_cast<SConsoleData*>(lConsoleData);
    return (S_OK);
}

extern const CLSID CLSID_FolderSnapin;


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetRoot
 *
 * PURPOSE: Creates the root node if necessary, and returns it. The root node
 *          is created using the built-in folder snap-in.
 *
 * PARAMETERS:
 *    voi d :
 *
 * RETURNS:
 *    CMTNode*. If unable to create the root node, the application will exit.
 *
 *+-------------------------------------------------------------------------*/
CMTNode*
CScopeTree::GetRoot(void)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetRoot"));

    if (m_pMTNodeRoot == NULL)
    {
        CSnapInPtr          spSI;
        IComponentDataPtr   spIComponentData;
        CComponentData*     pCCD                = NULL;
        CStr                rootName;

        // create a new CMTSnapInNode.
        // TODO: move this down below the CoCreateInstance and QI for
        // ISnapinProperties; if supported, create and pass CSnapinProperties
        // to CMTSnapInNode ctor.
        CMTSnapInNode *pMTSINodeRoot = new CMTSnapInNode(NULL);
        if(NULL == pMTSINodeRoot)
        {
            sc = E_OUTOFMEMORY;
            goto Error;
        }

        // Create an instance of the snapin
        sc = theApp.GetSnapInsCache()->ScGetSnapIn(CLSID_FolderSnapin, &spSI);
        if(sc)
            goto Error;

        sc = CoCreateInstance(CLSID_FolderSnapin, NULL, CLSCTX_INPROC_SERVER, IID_IComponentData, (void **)&spIComponentData);
        if(sc)
            goto Error;

        if(spIComponentData == NULL)
        {
            sc = E_OUTOFMEMORY;
            goto Error;
        }

        pMTSINodeRoot->SetPrimarySnapIn(spSI);

        pCCD = pMTSINodeRoot->GetPrimaryComponentData();
        if(!pCCD)
        {
            sc = E_UNEXPECTED;
            goto Error;
        }

        pCCD->SetIComponentData(spIComponentData);

        USES_CONVERSION;
        rootName.LoadString(GetStringModule(), IDS_ROOTFOLDER_NAME);

        //The code that follows makes use of knowledge of the Folder snapin internals.
        //There seems to be no easier way of doing this.
        // Need to prevent MMC from putting up the "Save File?" dialog every time.

        pMTSINodeRoot->OnRename(true, (LPOLESTR)T2COLE(rootName)); // clever, huh? This just renames the node to Console Root!
        pMTSINodeRoot->SetDisplayName(rootName); // this sets the dirty flag
        pMTSINodeRoot->SetDirty(false);         // this clears it.

        // need to tell the snapin to reset its dirty flag - there seems to be no way to avoid this dynamic cast.
        CFolderSnapinData *pFolderSnapinpData = dynamic_cast<CFolderSnapinData *>(pCCD->GetIComponentData());
        if(!pFolderSnapinpData)
        {
            sc = E_UNEXPECTED;
            goto Error;
        }

        pMTSINodeRoot->SetPreloadRequired(true); // this is also part of the dirty flag check.
        pFolderSnapinpData->SetDirty(false); // clear the dirty flag on the snapin.
        theApp.GetSnapInsCache()->SetDirty(false); // need to clear the dirty bit on the snapin cache too.


        m_pMTNodeRoot = pMTSINodeRoot;
    }

Cleanup:
    return m_pMTNodeRoot;
Error:
    MMCErrorBox(sc);
    exit(1);            // Fatal error - cannot continue.
    goto Cleanup;
}


STDMETHODIMP CScopeTree::Initialize(HWND hwndFrame, IStringTablePrivate* pStringTable)
{
    CSnapInsCache* pSnapInsCache = NULL;

    /*
     * assume invalid argument
     */
    SC sc = E_INVALIDARG;

    if (hwndFrame == 0)
        goto Error;

    /*
     * assume out of memory from here on
     */
    sc = E_OUTOFMEMORY;

    pSnapInsCache = new CSnapInsCache;
    if (pSnapInsCache == NULL)
        goto Error;

    theApp.SetSnapInsCache(pSnapInsCache);

    m_pImageCache = new CSPImageCache();
    if (m_pImageCache == NULL)
        goto Error;

    ASSERT (pStringTable    != NULL);
    ASSERT (m_spStringTable == NULL);
    m_spStringTable = pStringTable;

    // create the ctp list and default ctp list.
    ASSERT (m_pConsoleTaskpads == NULL);
    m_pConsoleTaskpads = new CConsoleTaskpadList;
    if (m_pConsoleTaskpads == NULL)
        goto Error;

    ASSERT (m_pDefaultTaskpads == NULL);
    m_pDefaultTaskpads = new CDefaultTaskpadList;
    if (m_pDefaultTaskpads == NULL)
        goto Error;

    /*
     * success!
     */
    return (S_OK);

Error:
    /*
     * clean up everything that might have been allocated
     */
    theApp.SetSnapInsCache (NULL);
    m_spStringTable = NULL;

    delete m_pDefaultTaskpads;  m_pDefaultTaskpads = NULL;
    delete m_pConsoleTaskpads;  m_pConsoleTaskpads = NULL;
    SAFE_RELEASE (m_pImageCache);
    delete pSnapInsCache;

    TraceError (_T("CScopeTree::Initialize"), sc);
    return (sc.ToHr());
}

STDMETHODIMP CScopeTree::QueryIterator(IScopeTreeIter** ppIter)
{
    if (ppIter == NULL)
        return E_POINTER;

    CComObject<CScopeTreeIterator>* pObject;
    CComObject<CScopeTreeIterator>::CreateInstance(&pObject);

    return  pObject->QueryInterface(IID_IScopeTreeIter,
                    reinterpret_cast<void**>(ppIter));
}

STDMETHODIMP CScopeTree::QueryNodeCallback(INodeCallback** ppNodeCallback)
{
    if (ppNodeCallback == NULL)
        return E_POINTER;

    CComObject<CNodeCallback>* pObject;
    CComObject<CNodeCallback>::CreateInstance(&pObject);

    HRESULT hr = pObject->QueryInterface(IID_INodeCallback,
                    reinterpret_cast<void**>(ppNodeCallback));

    if (*ppNodeCallback != NULL)
        (*ppNodeCallback)->Initialize(this);

    return hr;
}

STDMETHODIMP CScopeTree::CreateNode(HMTNODE hMTNode, LONG_PTR lViewData,
                                    BOOL fRootNode, HNODE* phNode)
{
    if (hMTNode == NULL)
        return E_INVALIDARG;

    if (phNode == NULL)
        return E_POINTER;

    CViewData* pViewData = reinterpret_cast<CViewData*>(lViewData);
    ASSERT(IsBadReadPtr(pViewData, sizeof(*pViewData)) == 0);

    CMTNode* pMTNode = CMTNode::FromHandle(hMTNode);
    CNode* pNode = NULL;

    if (pMTNode != NULL)
    {
        pNode = pMTNode->GetNode(pViewData, fRootNode);
        *phNode = CNode::ToHandle(pNode);
        return S_OK;
    }

    return E_FAIL;
}

HRESULT CScopeTree::CloseView(int viewID)
{
    if (m_pMTNodeRoot == NULL)
        return S_OK;

    HRESULT hr = m_pMTNodeRoot->CloseView(viewID);
    ASSERT(hr == S_OK);

    // Garbage collect view related column persistence data.
    CColumnPersistInfo* pColPersInfo = NULL;

    if ( (NULL != m_pConsoleData) && (NULL != m_pConsoleData->m_spPersistStreamColumnData) )
    {
        pColPersInfo = dynamic_cast<CColumnPersistInfo*>(
                         static_cast<IPersistStream*>(m_pConsoleData->m_spPersistStreamColumnData));

        if (pColPersInfo)
            pColPersInfo->DeleteColumnDataOfView(viewID);
    }

    // Ask the CViewSettingsPersistor to cleanup data for this view.
    hr = CNode::ScDeleteViewSettings(viewID).ToHr();

    return hr == S_OK ? S_OK : E_FAIL;
}


HRESULT CScopeTree::DeleteView(int viewID)
{
    if (m_pMTNodeRoot == NULL)
        return S_OK;

    HRESULT hr = m_pMTNodeRoot->DeleteView(viewID);
    ASSERT(hr == S_OK);
    return hr == S_OK ? S_OK : E_FAIL;
}

STDMETHODIMP CScopeTree::DestroyNode(HNODE hNode)
{
    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    delete pNode;
    return S_OK;
}

HRESULT CScopeTree::HandsOffStorage()
{
    // obsolete method.
    // this method is left here since we use IPersistStorage to export
    // persistence to CONUI side and we need to implement it.
    // But this interface will never be called to save data
    // [we will use CPersistor-based XML saving instead]
    // so the method will always fail.
    ASSERT(FALSE && "Should never come here");
    return E_NOTIMPL;
}

static const wchar_t*    AMCSignatureStreamName = L"signature";
static const long double dOldVersion10          = 0.00000015;   // MMC version 1.0
static const long double dOldVersion11          = 1.1;          // MMC version 1.1
static const BYTE        byStreamVersionMagic   = 0xFF;

HRESULT CScopeTree::InitNew(IStorage *pStg)
{
    ASSERT(m_spPersistData == NULL);
    ASSERT(pStg != NULL);
    if (pStg == NULL)
        return E_INVALIDARG;

    // Create the perist data interface and attach it to the storage
    CComObject<PersistData>* pPersistData;
    HRESULT hr = CComObject<PersistData>::CreateInstance(&pPersistData);
    m_spPersistData = pPersistData;
    ASSERT(SUCCEEDED(hr) && m_spPersistData != NULL);
    if (FAILED(hr))
        return hr;
    hr = m_spPersistData->Create(pStg);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    CMTNode* const pRoot = GetRoot();
    ASSERT(pRoot != NULL);
    if (pRoot == NULL)
        return E_POINTER;

    hr = pRoot->InitNew(m_spPersistData);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    return S_OK;
}

HRESULT CScopeTree::IsDirty()
{
    /*
     * check for dirty taskpads
     */
    CConsoleTaskpadList::iterator itDirty =
            std::find_if (m_pConsoleTaskpads->begin(),
                          m_pConsoleTaskpads->end(),
                          const_mem_fun_ref (&CConsoleTaskpad::IsDirty));

    if (itDirty != m_pConsoleTaskpads->end())
    {
        TraceDirtyFlag(TEXT("CScopeTree"), true);
        return (S_OK);
    }

    /*
     * check for dirty nodes
     */
    HRESULT hr;
    if (m_pMTNodeRoot != NULL)
    {
        hr = m_pMTNodeRoot->IsDirty();
        ASSERT(SUCCEEDED(hr));
        if (hr != S_FALSE)
        {
            TraceDirtyFlag(TEXT("CScopeTree"), true);
            return hr;
        }
    }

    /*
     * check for dirty snap-in cache
     */
    SC sc = theApp.GetSnapInsCache()->ScIsDirty();
    ASSERT(!sc.IsError());
    if(sc)
        return sc.ToHr();

    TraceDirtyFlag(TEXT("CScopeTree"), (sc==SC(S_OK)) ? true : false);
    return sc.ToHr();
}

HRESULT CScopeTree::GetFileVersion (IStorage* pstgRoot, int* pnVersion)
{
    ASSERT(pstgRoot != NULL);
    if (pstgRoot == NULL)
        return MMC_E_INVALID_FILE;

    // Open the stream containing the signature
    IStreamPtr spStream;
    HRESULT hr = OpenDebugStream(pstgRoot, AMCSignatureStreamName,
                          STGM_SHARE_EXCLUSIVE | STGM_READ, L"\\signature", &spStream);
    ASSERT(SUCCEEDED(hr) && spStream != NULL);
    if (FAILED(hr))
        return MMC_E_INVALID_FILE;

    /*
     * read the signature (stream extraction operators will throw
     * _com_error's, so we need an exception block here)
     */
    try
    {
        /*
         * MMC v1.2 and later write a marker as the first
         * byte of the signature stream.
         */
        BYTE byMagic;
        *spStream >> byMagic;

        /*
         * if this file was written by v1.2 or later,
         * read the console file version (int)
         */
        if (byMagic == byStreamVersionMagic)
        {
            *spStream >> *pnVersion;
            ASSERT (*pnVersion >= FileVer_0120);
        }

        /*
         * Otherwise, the file was written by v1.0 or v1.1.
         * Back up to re-read the marker byte, and read the old-style
         * file version (long double), then map it to a new-style version
         */
        else
        {
            LARGE_INTEGER pos = {0, 0};
            spStream->Seek (pos, STREAM_SEEK_SET, NULL);

            long double dVersion;
            *spStream >> dVersion;

            // v1.1?
            if (dVersion == dOldVersion11)
                *pnVersion = FileVer_0110;

            // v1.0?
            else if (dVersion == dOldVersion10)
            {
                /*
                 * If we got a v1.0 signature, we still may have a v1.1 file.
                 * There was a period of time where MMC v1.1 wrote a v1.0
                 * signature, but the file format had in fact changed.  We
                 * can determine this by checking the \FrameData stream in
                 * the file.  If the first DWORD in the \FrameData stream is
                 * sizeof(WINDOWPLACEMENT), we have a true v1.0 file, otherwise
                 * it's a funky v1.1 file.
                 */
                IStreamPtr spFrameDataStm;

                hr = OpenDebugStream (pstgRoot, L"FrameData",
                                           STGM_SHARE_EXCLUSIVE | STGM_READ,
                                           &spFrameDataStm);

                if (FAILED(hr))
                    return MMC_E_INVALID_FILE;

                DWORD dw;
                *spFrameDataStm >> dw;

                if (dw == sizeof (WINDOWPLACEMENT))
                    *pnVersion = FileVer_0100;
                else
                    *pnVersion = FileVer_0110;
            }

            // unexpected version
            else
            {
                ASSERT (false && "Unexpected old-style signature");
                hr = MMC_E_INVALID_FILE;
            }
        }
    }
    catch (_com_error& err)
    {
        hr = err.Error();
        ASSERT (false && "Caught _com_error");
        return (hr);
    }

    return (hr);
}


STDMETHODIMP
CScopeTree::GetIDPath(
    MTNODEID id,
    MTNODEID** ppIDs,
    long* pLength)
{
    ASSERT(ppIDs);
    ASSERT(pLength);
    if (!ppIDs || !pLength)
        return E_POINTER;

    CMTNode* pMTNode = NULL;
    HRESULT hr = Find(id, &pMTNode);

    ASSERT(pMTNode);
    if (!pMTNode)
        return E_POINTER;

    ASSERT(pMTNode->GetID() == id);

    long len = 0;
    for (CMTNode* pMTNodeTemp = pMTNode;
         pMTNodeTemp;
         pMTNodeTemp = pMTNodeTemp->Parent())
    {
        ++len;
    }

    if (!len)
    {
        *pLength = 0;
        *ppIDs = 0;
        return E_FAIL;
    }

    MTNODEID* pIDs = (MTNODEID*) CoTaskMemAlloc (len * sizeof (MTNODEID));

    if (pIDs == NULL)
    {
        *pLength = 0;
        *ppIDs = 0;
        return E_OUTOFMEMORY;
    }

    *pLength = len;
    *ppIDs = pIDs;

    for (pMTNodeTemp = pMTNode;
         pMTNodeTemp;
         pMTNodeTemp = pMTNodeTemp->Parent())
    {
        ASSERT(len != NULL);
        pIDs[--len] = pMTNodeTemp->GetID();
    }

    return S_OK;
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetNodeIDFromStream
 *
 * PURPOSE: Reads in a bookmark from the stream, and returns the NodeID of
 *          the node it represents.
 *
 * PARAMETERS:
 *    IStream * pStm :
 *    MTNODEID* pID :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CScopeTree::GetNodeIDFromStream(IStream *pStm, MTNODEID* pID)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetIDFromPath"));

    // check parameters
    sc = ScCheckPointers(pStm, pID);
    if(sc)
        return sc.ToHr();

    CBookmarkEx bm;
    *pStm >> bm;

    bool bExactMatchFound = false; // out value from GetNodeIDFromBookmark.
    return GetNodeIDFromBookmark(bm, pID, bExactMatchFound);
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetNodeIDFromBookmark
 *
 * PURPOSE: Returns the node ID of the MTNode represented by a bookmark.
 *
 * PARAMETERS:
 *    HBOOKMARK  hbm                 : [in] bookmark
 *    MTNODEID*  pID                 : [out] node-id
 *    bool&       bExactMatchFound   : [out] Is the exact match found or not.
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CScopeTree::GetNodeIDFromBookmark(HBOOKMARK hbm, MTNODEID* pID, bool& bExactMatchFound)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetNodeIDFromBookmark"));

    CBookmark *pbm = CBookmark::GetBookmark(hbm);
    bExactMatchFound = false;

    sc = ScCheckPointers(pID, pbm);
    if(sc)
        return sc.ToHr();

    CBookmarkEx bm = *pbm;

    ASSERT (bm.IsValid());

    CMTNode *pMTNode = NULL;

    sc  =  bm.ScGetMTNode(false /*bExactMatchRequired*/, &pMTNode, bExactMatchFound);
    if(sc)
        return sc.ToHr();

    if(!pMTNode)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    *pID = pMTNode->GetID();

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetNodeFromBookmark
 *
 * PURPOSE: Returns a Node object corresponding to the scope node whose
 *          Bookmark is passed in.
 *
 * PARAMETERS:
 *    HBOOKMARK     hbm              : [in] the given bookmark
 *    CConsoleView *pConsoleView     : [in]
 *    PPNODE        ppNode           : [out] the node corresponding to the bookmark.
 *    bool          bExactMatchFound : [out] did we find exactly matching node?
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CScopeTree::GetNodeFromBookmark(HBOOKMARK hbm, CConsoleView *pConsoleView, PPNODE ppNode, bool& bExactMatchFound)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetNodeFromBookmark"));

    sc = ScCheckPointers(pConsoleView, ppNode);
    if(sc)
        return sc.ToHr();

    // Get the node id
    MTNODEID id = 0;
    bExactMatchFound = false; // out value from GetNodeIDFromBookmark.
    sc = GetNodeIDFromBookmark(hbm, &id, bExactMatchFound);
    if(sc)
        return sc.ToHr();

    // find the node
    CMTNode *pMTNode = NULL;
    sc = Find(id, &pMTNode);
    if(sc)
        return sc.ToHr();

    // make sure that the node is available
    sc = pConsoleView->ScExpandNode(id, true /*bExpand*/, false /*bExpandVisually*/);
    if(sc)
        return sc.ToHr();

    // Create a Node object

    sc = ScGetNode(pMTNode, ppNode);

    return sc.ToHr();
}


HRESULT CScopeTree::GetPathString(HMTNODE hmtnRoot, HMTNODE hmtnLeaf, LPOLESTR* ppszPath)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetPathString"));
    sc = ScCheckPointers(hmtnLeaf, ppszPath);
    if(sc)
        return sc.ToHr();

    CMTNode* pmtnLeaf = CMTNode::FromHandle(hmtnLeaf);
    CMTNode* pmtnRoot = (hmtnRoot == NULL) ? m_pMTNodeRoot : CMTNode::FromHandle(hmtnRoot);

    CStr strPath;
    _GetPathString(pmtnRoot, pmtnLeaf, strPath);

    if (!strPath.IsEmpty())
    {
        int cchPath = strPath.GetLength()+1;
        *ppszPath = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc(cchPath * sizeof(OLECHAR)));
        if (*ppszPath == NULL)
            return (sc = E_OUTOFMEMORY).ToHr();

        USES_CONVERSION;
        sc = StringCchCopyW(*ppszPath, cchPath, T2COLE(strPath));
        if(sc)
            return sc.ToHr();

        return S_OK;
    }

    return (sc = E_FAIL).ToHr();
}


void CScopeTree::_GetPathString(CMTNode* pmtnRoot, CMTNode* pmtnCur, CStr& strPath)
{
    ASSERT(pmtnRoot != NULL && pmtnCur != NULL);

    // if haven't reached the root node yet, recursively get path from
    // root to current node's parent
    if (pmtnCur != pmtnRoot)
    {
        _GetPathString(pmtnRoot, pmtnCur->Parent(), strPath);
        strPath += _T('\\');
    }

    // now append the name for the current node
    strPath += pmtnCur->GetDisplayName().data();
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScAddSnapin
 *
 * PURPOSE: Adds the specified snapin to the console file beneath console root.
 *
 * TODO:    1) Allow the caller to specify the parent snapin.
 *          2) Right now specifying snapins by name does not work. Add this.
 *
 * PARAMETERS:
 *    LPCTSTR  szSnapinNameOrCLSID : The name or GUID of the snapin.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScAddSnapin (
    LPCWSTR     szSnapinNameOrCLSID,    /* I:name or CLSID of the snapin    */
    SnapIn*     pParentSnapinNode,      /* I:Parent snapin under which this snapin is added (optional)*/
    Properties* pProperties,            /* I:props to init with (optional)  */
    SnapIn*&    rpSnapIn)               /* O:the snap-in that was created   */
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScAddSnapin"));
    CSnapinManager snapinMgr(GetRoot());

    Trace(tagScopeTreeAddSnapin, TEXT("CScopeTree::ScAddSnapin"));

    // adding the snapin below this node.
    sc = snapinMgr.ScAddSnapin(szSnapinNameOrCLSID, pParentSnapinNode, pProperties);
    if(sc)
        return sc;

    // get the "list" of one node to add
    NewNodeList* pNewNodes = snapinMgr.GetNewNodes();
    if (pNewNodes == NULL)
        return (sc = E_UNEXPECTED);

    // the list should have an item in it
    CNewTreeNode* pNewNode = pNewNodes->GetHead();
    if (pNewNode == NULL)
        return (sc = E_UNEXPECTED);

    // Update the scope tree with changes made by snapin manager.
    sc = ScAddOrRemoveSnapIns(snapinMgr.GetDeletedNodesList(),
                              pNewNodes);
    if(sc)
        return sc;

    // if ScAddOrRemoveSnapIns succeeded, it better have created a CMTSnapInNode for us
    CMTSnapInNode* pNewSnapInNode = pNewNode->m_pmtNewSnapInNode;
    if (pNewSnapInNode == NULL)
        return (sc = E_UNEXPECTED);

    // get the SnapIn interface for the client
    sc = pNewSnapInNode->ScGetSnapIn (&rpSnapIn);
    if (sc)
        return (sc);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::QuerySnapIns
 *
 * PURPOSE: Creates, AddRefs, and returns a SnapIns object.
 *
 * PARAMETERS:
 *    SnapIns ** ppSnapIns :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CScopeTree::QuerySnapIns(SnapIns **ppSnapIns)
{
    DECLARE_SC(sc, TEXT("CScopeTree::QuerySnapIns"));

    // parameter check
    sc = ScCheckPointers(ppSnapIns);
    if (sc)
        return sc.ToHr();

    // init out parameter
    *ppSnapIns = NULL;

    // create a CSnapIns object if needed.
    sc = CTiedComObjectCreator<CSnapIns>::ScCreateAndConnect(*this, m_spSnapIns);
    if(sc)
        return sc.ToHr();

    if(m_spSnapIns == NULL)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    // addref the pointer for the client.
    m_spSnapIns->AddRef();
    *ppSnapIns = m_spSnapIns;

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::QueryScopeNamespace
 *
 * PURPOSE: Creates, AddRefs, and returns a ScopeNamespace object.
 *
 * PARAMETERS:
 *    ScopeNamespace ** ppScopeNamespace :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CScopeTree::QueryScopeNamespace(ScopeNamespace **ppScopeNamespace)
{
    DECLARE_SC(sc, TEXT("CScopeTree::QueryScopeNamespace"));

    // parameter check
    sc = ScCheckPointers(ppScopeNamespace);
    if (sc)
        return sc.ToHr();

    // init out parameter
    *ppScopeNamespace = NULL;

    // create a CScopeNamespace object if needed.
    sc = CTiedComObjectCreator<CScopeNamespace>::ScCreateAndConnect(*this, m_spScopeNamespace);
    if(sc)
        return sc.ToHr();

    if(m_spScopeNamespace == NULL)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    // addref the pointer for the client.
    m_spScopeNamespace->AddRef();
    *ppScopeNamespace = m_spScopeNamespace;

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 * CScopeTree::CreateProperties
 *
 * Creates a new, empty Properties object.  This function does the work
 * behind _Document::CreateProperties.
 *--------------------------------------------------------------------------*/

HRESULT CScopeTree::CreateProperties (Properties** ppProperties)
{
    DECLARE_SC (sc, _T("CScopeTree::CreateProperties"));

    /*
     * validate parameters
     */
    sc = ScCheckPointers (ppProperties);
    if (sc)
        return (sc.ToHr());

    /*
     * create a new properties collection
     */
    CComObject<CSnapinProperties> *pProperties = NULL;
    sc = CComObject<CSnapinProperties>::CreateInstance (&pProperties);
    if (sc)
        return (sc.ToHr());

    if (pProperties == NULL)
        return ((sc = E_UNEXPECTED).ToHr());

    /*
     * put a ref on for the client
     */
    (*ppProperties) = pProperties;
    (*ppProperties)->AddRef();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CScopeTree::QueryRootNode
//
//  Synopsis:    Returns COM object to the Root Node.
//
//  Arguments:   [ppRootNode] - Ptr in which root node will be returned.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CScopeTree::QueryRootNode (PPNODE ppRootNode)
{
    DECLARE_SC(sc, _T("CScopeTree::QueryRootNode"));

    sc = ScGetRootNode(ppRootNode);

    return (sc.ToHr());
}


HRESULT CScopeTree::Load(IStorage *pStg)
{
    ASSERT(m_spPersistData == NULL);
    if (m_spPersistData != NULL)
        return E_UNEXPECTED;

    ASSERT(pStg != NULL);
    if (pStg == NULL)
        return E_INVALIDARG;

    // Create the perist data interface and attach it to the storage
    CComObject<PersistData>* pPersistData;
    HRESULT hr = CComObject<PersistData>::CreateInstance(&pPersistData);
    m_spPersistData = pPersistData;
    ASSERT(SUCCEEDED(hr) && m_spPersistData != NULL);
    if (FAILED(hr))
        return hr;
    hr = m_spPersistData->Open(pStg);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    // Open the stream for the cache
    IStreamPtr spStream;
    hr = OpenDebugStream(pStg, AMCSnapInCacheStreamName,
                     STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"SnapInCache", &spStream);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    SC sc = theApp.GetSnapInsCache()->ScLoad(spStream);
    ASSERT(!sc.IsError());
    if (sc)
        return sc.ToHr();

    ASSERT(m_pMTNodeRoot == NULL);
    sc = CMTNode::ScLoad (m_spPersistData, &m_pMTNodeRoot);
    ASSERT(!sc.IsError() && m_pMTNodeRoot != NULL);
    if (sc)
        return sc.ToHr();

    hr = LoadTaskpadList(pStg);

    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::Persist
 *
 * PURPOSE: Persists the CScopeTree to the specified persistor.
 *
 * PARAMETERS:
 *    HPERSISTOR pPersistor:
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT CScopeTree::Persist(HPERSISTOR hPersistor)
{
    DECLARE_SC(sc, TEXT("CScopeTree::Persist"));

    try
    {
        sc = ScCheckPointers((void *)hPersistor,theApp.GetSnapInsCache());
        if (sc)
            sc.Throw();

        CPersistor &persistor = *reinterpret_cast<CPersistor *>(hPersistor);
        CPersistor persistorScopeTree(persistor, XML_TAG_SCOPE_TREE);

        // persist the snapin cache.
        persistorScopeTree.Persist(*theApp.GetSnapInsCache());

        // persist the MTNode hierarchy.
        CPersistor persistorMTNodes(persistorScopeTree, XML_TAG_SCOPE_TREE_NODES);
        if (persistor.IsStoring())
        {
            if(!m_pMTNodeRoot)
                sc.Throw(E_POINTER);

            persistorMTNodes.Persist(*m_pMTNodeRoot);
        }
        else
        {
            // here we imitate how the collection fixes on the element
            // despite we only have one, CMTNode::PersistNewNode thinks else
            CPersistor persistor1Node(persistorMTNodes, XML_TAG_MT_NODE);
            CPersistor persistor1NodeLocked(persistor1Node,persistor1Node.GetCurrentElement(),true);
            CMTNode::PersistNewNode(persistor1NodeLocked, &m_pMTNodeRoot);
            sc = ScCheckPointers(m_pMTNodeRoot,E_FAIL);
            if (sc)
                sc.Throw();
        }

        // persist all taskpads
        if(m_pConsoleTaskpads)
        {
            persistor.Persist(*m_pConsoleTaskpads);
        }
    }
    catch (SC e_sc)
    {
        sc = e_sc;
    }
    catch (_com_error e_com)
    {
        sc = e_com.Error();
    }
    catch (HRESULT e_hr)
    {
        sc = e_hr;
    }
    
    return sc.ToHr();
}

HRESULT CScopeTree::Save(IStorage *pStg, BOOL fSameAsLoad)
{
    // obsolete method.
    // this method is left here since we use IPersistStorage to export
    // persistence to CONUI side and we need to implement it.
    // But this interface will never be called to save data
    // [we will use CPersistor-based XML saving instead]
    // so the method will always fail.
    ASSERT(FALSE && "Should never come here");
    return E_NOTIMPL;
}


HRESULT CScopeTree::LoadTaskpadList(IStorage *pStg)
{
    HRESULT hr = S_OK;

    m_pConsoleTaskpads->clear();
    m_pDefaultTaskpads->clear();

    // Open the stream for the cache
    IStreamPtr spStream;
    hr = OpenDebugStream(pStg, AMCTaskpadListStreamName,
                     STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"TaskpadList", &spStream);
    if (FAILED(hr))
        return S_OK; // might be pre-MMC1.2, so if we don't find the stream just exit normally.

    hr = m_pConsoleTaskpads->Read(*(spStream.GetInterfacePtr()));
    if(FAILED(hr))
        return hr;

    // Read the list of default taskpads.
    hr = m_pDefaultTaskpads->Read(*(spStream.GetInterfacePtr()));
    if(FAILED(hr))
        return hr;

    return hr;
}

HRESULT CScopeTree::SaveCompleted(IStorage *pStg)
{
    // obsolete method.
    // this method is left here since we use IPersistStorage to export
    // persistence to CONUI side and we need to implement it.
    // But this interface will never be called to save data
    // [we will use CPersistor-based XML saving instead]
    // so the method will always fail.
    ASSERT(FALSE && "Should never come here");
    return E_NOTIMPL;
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::Find
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    MTNODEID  mID :
 *    CMTNode** ppMTNode :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT CScopeTree::Find(MTNODEID mID, CMTNode** ppMTNode)
{
    if (ppMTNode == NULL)
        return E_POINTER;

    *ppMTNode = NULL;

    CMTNode* pMTRootNode = GetRoot();
    if (pMTRootNode == NULL)
        return (E_FAIL);

    *ppMTNode = pMTRootNode->Find(mID);

    return ((*ppMTNode == NULL) ? E_FAIL : S_OK);
}

HRESULT CScopeTree::Find(MTNODEID mID, HMTNODE* phMTNode)
{
    if (phMTNode == NULL)
        return E_POINTER;

    *phMTNode = NULL;

    CMTNode* pMTNode;
    HRESULT hr = Find (mID, &pMTNode);
    if (FAILED (hr))
        return (hr);

    *phMTNode = CMTNode::ToHandle (pMTNode);

    return ((*phMTNode == NULL) ? E_FAIL : S_OK);
}

HRESULT CScopeTree::GetClassID(CLSID *pClassID)
{
    if (pClassID == NULL)
        return E_INVALIDARG;

    *pClassID = CLSID_ScopeTree;
    return S_OK;
}


#define SDI_RELATIVEID_MASK     (SDI_PARENT | SDI_PREVIOUS | SDI_NEXT)

SC
CScopeTree::ScInsert(LPSCOPEDATAITEM pSDI, COMPONENTID nID,
                           CMTNode** ppMTNodeNew)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScInsert"));

    // check parameters
    if (m_pMTNodeRoot == NULL)
    {
        sc = E_INVALIDARG;
        return sc;
    }

    try
    {
        *ppMTNodeNew = NULL;
        HMTNODE hMTNodePrev = (HMTNODE) TVI_LAST;

        CMTNode* pMTNodeRelative = CMTNode::FromScopeItem(pSDI->relativeID);
        CMTNode* pMTNodeParent = NULL;

        if (pSDI->mask & SDI_RELATIVEID_MASK)
        {
            if (pMTNodeRelative->GetOwnerID() != nID)
            {
                sc = E_INVALIDARG;
                return sc;
            }

            pMTNodeParent = pMTNodeRelative->Parent();
        }
        else
        {
            pMTNodeParent = pMTNodeRelative;
        }

        if (pMTNodeParent == NULL)
        {
            sc = E_INVALIDARG;
            return sc;
        }

        ASSERT(pMTNodeParent->WasExpandedAtLeastOnce() == TRUE);
        if (pMTNodeParent->WasExpandedAtLeastOnce() == FALSE)
        {
            sc = E_POINTER;
            return sc;
        }

        if (IsBadWritePtr(pMTNodeParent, sizeof(CMTNode*)) != 0)
        {
            sc = E_POINTER;
            return sc;
        }

        CMTSnapInNode* pMTSINode = pMTNodeParent->GetStaticParent();
        CComponentData* pCCD = pMTSINode->GetComponentData(nID);
        ASSERT(pCCD != NULL);


        CMTNode* pMTNode = new CMTNode;
        if (pMTNode == NULL)
            return (sc = E_OUTOFMEMORY);

        /* Determine the node to Insert after */
        CMTNode* pInsertAfter = NULL;

        if (pSDI->mask & SDI_PREVIOUS)
        {
            pInsertAfter = pMTNodeRelative;  
        }
        else if (pSDI->mask & SDI_NEXT)
        {
            pInsertAfter = pMTNodeRelative->Prev();
        }
        else if (pSDI->mask & SDI_FIRST)
        {
            pInsertAfter = NULL;
        }
        else
        {
            pInsertAfter = pMTNodeParent->LastChild();
        }

        hMTNodePrev = (pInsertAfter==NULL ? (HMTNODE)TVI_FIRST : CMTNode::ToHandle(pInsertAfter));


        /* Insert as child after pInsertAfter. If the latter is NULL, insert as 
        ** the first child
        */
        sc = pMTNodeParent->ScInsertChild(pMTNode, pInsertAfter);
        if(sc)
        {
            pMTNode->Release();
            return sc;
        }

        pMTNode->SetPrimaryComponentData(pCCD);
        pMTNode->SetOwnerID(nID);
        pMTNode->SetUserParam(pSDI->lParam);

        if (pSDI->mask & SDI_STATE)
            pMTNode->SetState(pSDI->nState);

        if (pSDI->mask & SDI_IMAGE)
            pMTNode->SetImage(pSDI->nImage);

        if (pSDI->mask & SDI_OPENIMAGE)
            pMTNode->SetOpenImage(pSDI->nOpenImage);

        if ((pSDI->mask & SDI_CHILDREN) && (pSDI->cChildren == 0))
            pMTNode->SetNoPrimaryChildren();

        pSDI->ID = reinterpret_cast<HSCOPEITEM>(pMTNode);

   
        *ppMTNodeNew = pMTNode;

        // Now inform the views to add as needed.
        SViewUpdateInfo vui;
        vui.newNode = CMTNode::ToHandle(pMTNode);
        vui.insertAfter = hMTNodePrev;

        pMTNode->Parent()->CreatePathList(vui.path);
        UpdateAllViews(VIEW_UPDATE_ADD, reinterpret_cast<LPARAM>(&vui));

    }
    catch( std::bad_alloc )
    {
        sc = E_OUTOFMEMORY;
        return sc;
    }
 
    return sc;
}


typedef CArray<COMPONENTID, COMPONENTID> CComponentIDArray;

//---------------------------------------------------------------------------------------
//  NotifyExtensionsOfNodeDeletion
//
// This method enumerated the children of a node, building a list of all the snap-in
// components that have added children. It then sends a REMOVE_CHILDREN notification to
// each of the components.
//
// The component that owns the node is treated in a special way. It is only notified if
// the node is staic or the bNotifyRoot param is TRUE. This is because we don't want
// to send notifications for nodes that belong to a subtree rooted at a node owned by
// the same component (see InformSnapinsOfDeletion).
//---------------------------------------------------------------------------------------
void NotifyExtensionsOfNodeDeletion(CMTNode* pMTNode, CComponentIDArray& rgID,
                                    BOOL bNotifyRoot = FALSE)
{
    if (pMTNode == NULL)
        return;

    CMTSnapInNode* pMTSINode = pMTNode->GetStaticParent();
    ASSERT(pMTSINode != NULL);
    if (pMTSINode == NULL)
        return;

    COMPONENTID idOwner = pMTNode->GetPrimaryComponentID();

    int nTemp = pMTSINode->GetNumberOfComponentDatas() + 1;
    rgID.SetSize(nTemp);
    for (int i=0; i < nTemp; ++i)
        rgID[i] = -1;

    // Build list of all component ID's that have added children to this node
    // except for component that owns the node.
    BOOL bOwnerChildren = FALSE;
    CMTNode* pMTNodeTemp = pMTNode->Child();
    for (int iMax = -1; pMTNodeTemp != NULL; pMTNodeTemp = pMTNodeTemp->Next())
    {
        COMPONENTID id = pMTNodeTemp->GetPrimaryComponentID();

        // if owner ID just note it, else add ID to list
        if (id == idOwner)
        {
            bOwnerChildren = TRUE;
        }
        else
        {
            // search list for ID
            for (int j=0; j <= iMax; ++j)
            {
                if (rgID[j] == id)
                    break;
            }

            // if not found, add to list
            if (j > iMax)
                rgID[++iMax] = id;
        }
    }

    // Include owner conponent only if it needs to be notified
    if (bOwnerChildren && (bNotifyRoot == TRUE || pMTNode->IsStaticNode()))
        rgID[++iMax] = idOwner;

    if (!pMTNode->IsInitialized())
        return;

    IDataObjectPtr spDataObject;
    HRESULT hr = pMTNode->QueryDataObject(CCT_SCOPE, &spDataObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return;

    LPARAM lScopeItem = CMTNode::ToScopeItem(pMTNode);

    pMTNode->SetRemovingChildren(true);
    for (i = 0; i <= iMax; ++i)
    {
        ASSERT(rgID[i] != -1);
        CComponentData* pCD = pMTSINode->GetComponentData(rgID[i]);
        ASSERT(pCD != NULL);

        Dbg(DEB_TRACE, _T("Remove Children - node = %s, ID = %d\n"), pMTNode->GetDisplayName(), rgID[i]);

        hr = pCD->Notify(spDataObject, MMCN_REMOVE_CHILDREN, lScopeItem, 0);
        CHECK_HRESULT(hr);
    }
    pMTNode->SetRemovingChildren(false);
}

//-----------------------------------------------------------------------------------------------
// InformSnapinsOfDeletion
//
// This function traverse the node subtree rooted at pMTNode and sends a REMOVE_CHILDREN to all
// snap-in components that have added children to the tree. A component is sent one notification
// for each node it has extended that belongs to another component. No notification is sent where
// a component has extended one of its own nodes. There are two exceptions to this rule. Owners
// of static nodes are always notified. Also the owner of the top node is notified if bNotifyRoot
// is TRUE.
//
// Another way to look at this is that MMC searches the tree for subtrees of nodes provided by
// a single component. It sends a notification to the component to delete the top node of the
// subtree. The component is responsible for identifying and deleting the rest of its nodes in
// the subtree.
//
// This method just handles the recursion and iteration required to traverse the whole tree. It
// calls NotifyExtensionsOfNodeDeletion to enumerate the children of a node and send notifications
// to the right components.
//
//------------------------------------------------------------------------------------------------
void InformSnapinsOfDeletion(CMTNode* pMTNode, BOOL fNext,
                             CComponentIDArray& rgID, BOOL bNotifyRoot = FALSE)
{
    if (pMTNode == NULL)
        return;

    if (pMTNode->Child() != NULL)
    {
        // Recursively clear nodes's subtree first
        InformSnapinsOfDeletion(pMTNode->Child(), TRUE, rgID, FALSE);

        // Notify extensions of node itself
        NotifyExtensionsOfNodeDeletion(pMTNode, rgID, bNotifyRoot);
    }

    // If requested, handle all siblings of this node
    // (iteratively rather than recursively to avoid deep stack use)
    if (fNext == TRUE)
    {
        CMTNode* pMTNodeNext = pMTNode->Next();

        while (pMTNodeNext != NULL)
        {
            InformSnapinsOfDeletion(pMTNodeNext, FALSE, rgID, FALSE);
            pMTNodeNext = pMTNodeNext->Next();
        }
    }
}

/*+-------------------------------------------------------------------------*
 * CScopeTree::Delete
 *
 * PURPOSE: Deletes a tree rooted at a node. Also sends a notification to
 *          the selected item in each view asking them whether they need to
 *          be reselected once the item is deleted.
 *
 *          Called by CNodeInitObject::DeleteItem
 *
 * PARAMETERS:
 *      CMTNode*      pmtn:         The root of the tree to be deleted
 *      BOOL          fDeleteThis:  Whether the root itself requires deletion as well
 *      COMPONENTID   nID:
 *
 * RETURNS:
 *      void
/*+-------------------------------------------------------------------------*/
SC
CScopeTree::ScDelete(CMTNode* pmtn, BOOL fDeleteThis, COMPONENTID nID)
{
    DECLARE_SC(sc, TEXT("CScopeTree::Delete"));

    // check parameters
    if (pmtn == NULL)
    {
        sc = E_INVALIDARG;
        return sc;
    }

    // Is this call a result of sending MMCN_REMOVE_CHILDREN to a parent node?
    // If so return immediately since MMC does delete all the child nodes.
    if (pmtn->AreChildrenBeingRemoved() == true)
        return sc;

    // if deleting node and children, just do one call to delete the
    // whole subtree.
    if (fDeleteThis)
    {
        // can't delete static root node OR nodes put up by other components!
        if ( ( pmtn->GetOwnerID() == TVOWNED_MAGICWORD) || (pmtn->GetOwnerID() != nID) )
        {
            sc = E_INVALIDARG;
            return sc;
        }

        #ifdef DBG
            CMTNode* pmtnParent = pmtn->Parent();
            CMTNode* pmtnPrev = NULL;
            CMTNode* pmtnNext = pmtn->Next();

            if (pmtnParent->Child() != pmtn)
            {
                pmtnPrev = pmtnParent->Child();

                while (pmtnPrev->Next() != pmtn)
                    pmtnPrev = pmtnPrev->Next();

                ASSERT(pmtnPrev != NULL);
            }
        #endif

        DeleteNode(pmtn);

        #ifdef DBG
            if (pmtnParent != NULL)
            {
                ASSERT(pmtnParent != NULL);

                if (pmtnPrev == NULL)
                {
                    ASSERT(pmtnParent->Child() == pmtnNext);
                }
                else
                {
                    ASSERT(pmtnPrev->Next() == pmtnNext);
                }
            }
        #endif

    }
    // else we have to enum the children and delete only the ones
    // created by the calling snap-in
    else
    {
        CMTNode* pMTNode = pmtn->Child();

        // Enum children and delete those that are owned by the
        // requesting component (i.e., with matching ID)
        while(pMTNode != NULL)
        {
            CMTNode *pMTNodeNext = pMTNode->Next();

            if (!pMTNode->IsStaticNode() &&
                (pMTNode->GetPrimaryComponentID() == nID))
            {
                DeleteNode(pMTNode);
            }

            pMTNode = pMTNodeNext;
        }
    }

    return sc;
}


void CScopeTree::DeleteNode(CMTNode* pmtn)
{
    if (pmtn == NULL)
        return;

    // always update the views
    SViewUpdateInfo vui;
    vui.flag = VUI_DELETE_THIS;
    pmtn->CreatePathList (vui.path);

    // We are changing selection, so snapin may call delete
    // on this node during this process (MMCN_SELECT, MMCN_SHOW...),
    // Do an AddRef and Release to protect ourself from such deletes.
    pmtn->AddRef();
    UpdateAllViews (VIEW_UPDATE_SELFORDELETE, reinterpret_cast<LPARAM>(&vui));
    if (pmtn->Release() == 0)
        return; // The object was already deleted during selection change.
    UpdateAllViews (VIEW_UPDATE_DELETE,       reinterpret_cast<LPARAM>(&vui));

    CComponentIDArray rgID;
    rgID.SetSize(20, 10);
    InformSnapinsOfDeletion(pmtn, FALSE, rgID, (pmtn->IsStaticNode() == FALSE));

    CMTNode* pmtnParent = pmtn->Parent();
    _DeleteNode(pmtn);

    pmtnParent->OnChildrenChanged();

    UpdateAllViews (VIEW_UPDATE_DELETE_EMPTY_VIEW, 0);
}

void CScopeTree::_DeleteNode(CMTNode* pmtn)
{
    DECLARE_SC(sc, TEXT("CScopeTree::_DeleteNode"));

    //
    //  Delete from the scope tree.
    //
    sc = ScCheckPointers(pmtn);
    if (sc)
        return;

    if (m_pMTNodeRoot == pmtn)
    {
        m_pMTNodeRoot->Release();
        m_pMTNodeRoot = NULL;
        return;
    }

    CMTNode* pmtnParent = pmtn->Parent();

    sc = (pmtnParent ? sc : E_UNEXPECTED);
    if(sc)
        return;

    sc = pmtnParent->ScDeleteChild(pmtn);
    if(sc)
        return;

    pmtnParent->SetDirty();
}

void CScopeTree::UpdateAllViews(LONG lHint, LPARAM lParam)
{
    CConsoleFrame* pFrame = GetConsoleFrame();
    ASSERT (pFrame != NULL);

    if (pFrame == NULL)
        return;

    SC sc = pFrame->ScUpdateAllScopes (lHint, lParam);
    if (sc)
        goto Error;

Cleanup:
    return;
Error:
    TraceError (_T("CScopeTree::UpdateAllViews"), sc);
    goto Cleanup;
}

void CScopeTree::DeleteDynamicNodes(CMTNode* pMTNode)
{
    ASSERT(pMTNode != NULL);
    ASSERT(pMTNode->IsStaticNode() == TRUE);

    if (pMTNode == NULL)
        return;

    CMTSnapInNode* pMTSINode = dynamic_cast<CMTSnapInNode*>(pMTNode);
    ASSERT(pMTSINode != NULL);
    if (pMTSINode == NULL)
        return;

    for (CMTNode* pMTNodeTemp = pMTNode->Child(); pMTNodeTemp != NULL;
         pMTNodeTemp = pMTNodeTemp->Next())
    {
        if (pMTNodeTemp->IsDynamicNode())
        {
            CComponentIDArray rgID;
            rgID.SetSize(20, 10);
            InformSnapinsOfDeletion(pMTNodeTemp, FALSE, rgID, FALSE);
        }
    }

    CComponentIDArray rgID;
    NotifyExtensionsOfNodeDeletion(pMTSINode, rgID, FALSE);

    CMTNode* pMTNodeNext = pMTNode->Child();
    while (pMTNodeNext != NULL)
    {
        pMTNodeTemp = pMTNodeNext;
        pMTNodeNext = pMTNodeNext->Next();

        if (pMTNodeTemp->IsStaticNode() == FALSE)
            _DeleteNode(pMTNodeTemp);
    }

}


inline BOOL CScopeTree::ExtensionsHaveChanged(CMTSnapInNode* pMTSINode)
{
    CSnapIn* pSnapIn = pMTSINode->GetPrimarySnapIn();
    ASSERT(pSnapIn != NULL);

    return pSnapIn->HasNameSpaceChanged();
}

void CScopeTree::HandleExtensionChanges(CMTNode* pMTNode)
{
    if (pMTNode == NULL)
        return;

    HandleExtensionChanges(pMTNode->Next());

    if (pMTNode->IsStaticNode() == TRUE)
    {
        HandleExtensionChanges(pMTNode->Child());

        if (ExtensionsHaveChanged(dynamic_cast<CMTSnapInNode*>(pMTNode)) == TRUE)
        {
            SViewUpdateInfo vui;
            vui.flag = VUI_DELETE_SETAS_EXPANDABLE;

            pMTNode->CreatePathList(vui.path);
            UpdateAllViews(VIEW_UPDATE_SELFORDELETE, reinterpret_cast<LPARAM>(&vui));
            UpdateAllViews(VIEW_UPDATE_DELETE, reinterpret_cast<LPARAM>(&vui));
            vui.path.RemoveAll();

            DeleteDynamicNodes(pMTNode);

            m_MTNodesToBeReset.AddHead(pMTNode);

            UpdateAllViews(VIEW_UPDATE_DELETE_EMPTY_VIEW, 0);
        }
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::RunSnapIn
 *
 * PURPOSE: Runs the Snap-In Manager to prompt the user to add and remove snap-ins.
 *
 * PARAMETERS:
 *    HWND  hwndParent :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP CScopeTree::RunSnapIn(HWND hwndParent)
{
    DECLARE_SC(sc, TEXT("CScopeTree::RunSnapIn"));

    CSnapinManager dlg(GetRoot());

    if (dlg.DoModal() == IDOK)
    {
        sc = ScAddOrRemoveSnapIns(dlg.GetDeletedNodesList(), dlg.GetNewNodes());
        if(sc)
            return sc.ToHr();
    }

    return sc.ToHr();

}


/*+-------------------------------------------------------------------------*
 * class CEnableProcessingSnapinCacheChanges
 *
 *
 * PURPOSE: A class that sets/re-sets ProcessingSnapinChanges so that
 *          the ProcessingSnapinChanges is re-set automatically when
 *          this object is destroyed.
 *
 *+-------------------------------------------------------------------------*/
class CEnableProcessingSnapinCacheChanges
{
public:
    CEnableProcessingSnapinCacheChanges()
    {
        theApp.SetProcessingSnapinChanges(TRUE);
    }
    ~CEnableProcessingSnapinCacheChanges()
    {
        theApp.SetProcessingSnapinChanges(FALSE);
    }
};


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScAddOrRemoveSnapIns
 *
 * PURPOSE: Called after a snapin is added/removed (extension is enabled/disabled)
 *          to update scopetree with those changes.
 *
 * PARAMETERS:
 *    MTNodesList * pmtnDeletedList : The list of nodes to remove. Can be NULL.
 *    NewNodeList * pnnList :         The list of nodes to add. Can be NULL.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScAddOrRemoveSnapIns(MTNodesList * pmtnDeletedList, NewNodeList * pnnList)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScAddOrRemoveSnapIns"));

    sc = ScCheckPointers(m_pConsoleData, m_pConsoleData->m_pConsoleDocument, E_UNEXPECTED);
    if (sc)
        return sc;

    CConsoleDocument *pConsoleDoc = m_pConsoleData->m_pConsoleDocument;
    ASSERT(NULL != pConsoleDoc);

    // 1. Prevent access to snapin data while processing changes.
    CEnableProcessingSnapinCacheChanges processSnapinChanges;
	// when notifications are suspended MMC & snapins get into the weirld states
	// it is safer not to let scripts to be informed about the changes as well.
	// this is there to fix windows bugs #474627 & 475801 ( 10/03/2001 )
    LockComEventInterface(AppEvents);

    // 2. Delete static nodes.
    {
        CMTNode * pmtnTemp;
        POSITION pos;

        if (pmtnDeletedList)
        {
            pos = pmtnDeletedList->GetHeadPosition();

            while (pos)
            {
                pmtnTemp = pmtnDeletedList->GetNext(pos);

                CMTSnapInNode * pMTSINode = dynamic_cast<CMTSnapInNode*>(pmtnTemp);

                // forward to the document to generate the script event
                if (pMTSINode)
                {
                    SnapInPtr spSnapIn;
                    // construct snapin com object
                    sc = pMTSINode->ScGetSnapIn(&spSnapIn);
                    if (sc)
                        sc.TraceAndClear(); // it's only events. Should not affect main functionality
                    else
                    {
                        // emit the event
                        sc = pConsoleDoc->ScOnSnapinRemoved(spSnapIn);
                        if (sc)
                            sc.TraceAndClear(); // it's only events. Should not affect main functionality
                    }
                }

                DeleteNode(pmtnTemp);
            }
        }
    }

    // 3. Handle extension changes
    HandleExtensionChanges(m_pMTNodeRoot->Child());

    CSnapInsCache* pSnapInCache = theApp.GetSnapInsCache();
    sc = ScCheckPointers(pSnapInCache, E_UNEXPECTED);
    if (sc)
        goto Error;

    // 4. Purge the snapin cache
    // (duplicates what is done in ~CSnapinManager, since doing it here is too early
    //  - snapin manager still has a reference to the snapins)
	// but some code relies in this to remove the snapin from cache
	// look at windows bug #276340 (ntbug9, 1/10/2001).
    pSnapInCache->Purge();

    // 5. Re-Init
    {
        POSITION pos = m_MTNodesToBeReset.GetHeadPosition();
        while (pos)
        {
            CMTNode* pMTNode = m_MTNodesToBeReset.GetNext(pos);

            ASSERT(pMTNode != NULL);
            if (pMTNode != NULL)
                pMTNode->Reset();
        }

        m_MTNodesToBeReset.RemoveAll();

        // Re-set processing changes explicitly eventhough the
        // dtor for CEnableProcessingSnapinCacheChanges will do this.
        theApp.SetProcessingSnapinChanges(FALSE);
    }

    // 6. Cleanup controlbar cache and reselect currently selected node.
    UpdateAllViews(VIEW_RESELECT, 0);

    // 7. Add new static nodes

    if (pnnList)
    {
        PNEWTREENODE pNew;
        CMTNode * pmtnTemp;
        POSITION pos = pnnList->GetHeadPosition();

        while (pos)
        {
            pNew = pnnList->GetNext(pos);
            sc = ScCheckPointers(pNew, E_UNEXPECTED);
            if (sc)
                goto Error;

            pmtnTemp = NULL;

            sc = ScCreateMTNodeTree(pNew, pNew->m_pmtNode, &pmtnTemp);
            if (sc)
                goto Error;

            sc = ScCheckPointers(pmtnTemp, E_UNEXPECTED);
            if (sc)
                goto Error;

            pmtnTemp->NotifyAddedToTree ();

            SViewUpdateInfo vui;
            pmtnTemp->Parent()->CreatePathList(vui.path);
            vui.newNode = CMTNode::ToHandle(pmtnTemp);
            UpdateAllViews(VIEW_UPDATE_ADD, reinterpret_cast<LPARAM>(&vui));
            vui.path.RemoveAll();

            CMTSnapInNode * pMTSINode = dynamic_cast<CMTSnapInNode*>(pmtnTemp);

            // forward to the document to generate the script event
            if (pMTSINode)
            {
                SnapInPtr spSnapIn;
                // construct snapin com object
                sc = pMTSINode->ScGetSnapIn(&spSnapIn);
                if (sc)
                    sc.TraceAndClear(); // it's only events. Should not affect main functionality
                else
                {
                    // emit the event
                    sc = pConsoleDoc->ScOnSnapinAdded(spSnapIn);
                    if (sc)
                        sc.TraceAndClear(); // it's only events. Should not affect main functionality
                }
            }
        }
        UpdateAllViews(VIEW_RESELECT, 0);
    }

    if (pSnapInCache->IsHelpCollectionDirty())
    {
        sc = ScSetHelpCollectionInvalid();
        if (sc)
            goto Error;
    }


Cleanup:
    sc.Clear();
    return sc;
Error:
    sc.Trace_();
    goto Cleanup;
}


//+-------------------------------------------------------------------
//
//  Name:      ScCreateMTNodeTree
//
//  Synopsis:  Creates the tree of CMTNodes described by the CNewTreeNode tree 
//             rooted at pNew. Attaches this subtree by inserting its root as 
//             the last child of pmtnParent.
//
//  Arguments: pNew: [IN]: Non-Null pointer to the root of the describing tree. 
//             pmtnParent: [IN]: Non-Null pointer to node under which the 
//             subtree is to be attached
//             ppNodeCreated: [OUT]: Non-null pointer to the pointer for the
//             subtree to be created.
//
//  Returns:   SC  
//
//--------------------------------------------------------------------

SC
ScCreateMTNodeTree(PNEWTREENODE pNew, CMTNode* pmtnParent,
                   CMTNode** ppNodeCreated )
{
    DECLARE_SC(sc, TEXT("ScCreateMTNodeTree"));

    sc = ScCheckPointers(ppNodeCreated);
    if (sc)
        return sc;

    *ppNodeCreated = NULL;

    sc = ScCheckPointers(pNew, pmtnParent);
    if (sc)
        return sc;

    CMTNode*    pmtnFirst = NULL;
    CMTNode*    pmtnCur = NULL;

    while (pNew != NULL)
    {
        if (pNew->m_pmtNewNode == NULL)
        {
            CSnapInPtr  spSI;
            SC sc = theApp.GetSnapInsCache()->ScGetSnapIn(pNew->m_clsidSnapIn, &spSI);
            if (sc)
                goto finally;

            CMTSnapInNode* pmtn = new CMTSnapInNode(pNew->m_spSnapinProps);
            if (pmtn == NULL)
            {
                sc = E_OUTOFMEMORY;
                goto finally;
            }

            // get hold on the node:
            // it either will be connected or deleted (on failure)
            pmtnCur = pmtn;

            pmtn->SetPrimarySnapIn(spSI);

            sc = ScCheckPointers(pNew->m_spIComponentData, E_UNEXPECTED);
            if (sc)
                goto finally;

            CComponentData* pCCD = pmtn->GetPrimaryComponentData();
            sc = ScCheckPointers(pCCD, E_UNEXPECTED);
            if (sc)
                goto finally;

            pCCD->SetIComponentData(pNew->m_spIComponentData);

            sc = pmtn->Init();
            if (sc)
            {
                TraceError (_T("CScopeTree::ScCreateMTNodeTree"), sc);
                // continue even on error
                sc.Clear();
            }

            if (pNew->m_spIComponentData != NULL)
            {
                CStr strBuf;
                sc = LoadRootDisplayName(pNew->m_spIComponentData, strBuf);
                if (sc)
                {
                    TraceError (_T("CScopeTree::ScCreateMTNodeTree"), sc);
                    // continue even on error
                    sc.Clear();
                }
                else
                {
                    pmtn->SetDisplayName(strBuf);
                }
            }

            pNew->m_pmtNewSnapInNode = pmtn;
        }
        else
        {
            pmtnCur = pNew->m_pmtNewNode;
            pmtnCur->AddRef();
        }


        if (pNew->m_pChild != NULL)
        {
            // Recursively add children 
            CMTNode* pNodeCreated = NULL;
            sc = ScCreateMTNodeTree(pNew->m_pChild, pmtnCur, &pNodeCreated);
            if (sc)
                goto finally;

            sc = ScCheckPointers(pNodeCreated, E_UNEXPECTED);
            if (sc)
                goto finally;

        }

        /* Insert Current Node after the last child. If last child is NULL,
        ** insert as the first and only child 
        */
        sc = pmtnParent->ScInsertChild(pmtnCur, pmtnParent->LastChild());
        if(sc)
            goto finally;
        

        if (pmtnFirst == NULL)
        {
            pmtnFirst = pmtnCur;
        }

        pmtnCur  = NULL;

        pNew = pNew->m_pNext;
    }

finally:

    if (sc)
    {
        // error - cleanup before return
         
        if(pmtnFirst)
        {
            // Ignore returned status code: Already in error
            pmtnParent->ScDeleteTrailingChildren(pmtnFirst);
        } 

        if (pmtnCur)
        {
            pmtnCur->Release();
        }
    }
    else
    {
        // assign the tree to be returned
        *ppNodeCreated = pmtnFirst;
    }

    return sc;
}

void CScopeTree::Cleanup(void)
{
    Dbg(DEB_USER1, "CScopeTree::CleanUp\n");

    // Reset the MT node IDs to ROOTNODEID (e.g 1) so the new scope tree
    // can start over correctly with new numbers
    CMTNode::ResetID();

    CComponentIDArray rgID;
    rgID.SetSize(20, 10);
    InformSnapinsOfDeletion(m_pMTNodeRoot, FALSE, rgID);

    SAFE_RELEASE(m_pMTNodeRoot);
    SAFE_RELEASE(m_pImageCache);

    delete m_pDefaultTaskpads;  m_pDefaultTaskpads = NULL;
    delete m_pConsoleTaskpads;  m_pConsoleTaskpads = NULL;
}

STDMETHODIMP CScopeTree::GetImageList(PLONG_PTR pImageList)
{
    if (pImageList == NULL)
        return E_POINTER;

    HIMAGELIST* phiml = reinterpret_cast<HIMAGELIST *>(pImageList);
    *phiml = GetImageList();

    return ((*phiml) ? S_OK : E_FAIL);
}

HIMAGELIST CScopeTree::GetImageList () const
{
    ASSERT(m_pImageCache != NULL);
    if (m_pImageCache == NULL)
        return NULL;

    return (m_pImageCache->GetImageList()->m_hImageList);
}

HRESULT CScopeTree::InsertConsoleTaskpad (CConsoleTaskpad *pConsoleTaskpad,
                                          CNode *pNodeTarget, bool bStartTaskWizard)
{
    DECLARE_SC (sc, _T("CScopeTree::InsertConsoleTaskpad"));

    ASSERT(pConsoleTaskpad);
    m_pConsoleTaskpads->push_back(*pConsoleTaskpad);

    // make sure the taskpad now points to the one that is inside the list.
    CConsoleTaskpad & consoleTaskpad = m_pConsoleTaskpads->back();
    pConsoleTaskpad = &consoleTaskpad;

    // reselect all nodes.
    UpdateAllViews(VIEW_RESELECT, 0);

    if(bStartTaskWizard)
    {
        typedef CComObject<CConsoleTaskCallbackImpl> t_TaskCallbackImpl;
        t_TaskCallbackImpl* pTaskCallbackImpl;
        sc = t_TaskCallbackImpl::CreateInstance(&pTaskCallbackImpl);
        if (sc)
            return (sc.ToHr());

        ITaskCallbackPtr spTaskCallback = pTaskCallbackImpl; // addrefs/releases the object.

        sc = pTaskCallbackImpl->ScInitialize(pConsoleTaskpad, this, pNodeTarget);
        if (sc)
            return (sc.ToHr());

        pTaskCallbackImpl->OnNewTask();
        UpdateAllViews(VIEW_RESELECT, 0);
    }

    return (sc.ToHr());
}

HRESULT CScopeTree::IsSynchronousExpansionRequired()
{
    return (_IsSynchronousExpansionRequired() ? S_OK : S_FALSE);
}

HRESULT CScopeTree::RequireSynchronousExpansion(BOOL fRequireSyncExpand)
{
    _RequireSynchronousExpansion (fRequireSyncExpand ? true : false);
    return (S_OK);
}



//############################################################################
//############################################################################
//
//  CScopeTree Object model methods - SnapIns collection methods
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScAdd
 *
 * PURPOSE: Adds a snap-in with the supplied CLSID or PROGID to the console.
 *
 * PARAMETERS:
 *    BSTR      bstrSnapinNameOrCLSID :
 *    VARIANT   varProperties
 *    SnapIn**  ppSnapIn
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScAdd(
    BSTR        bstrSnapinNameOrCLSID,  /* I:what snap-in?                  */
    VARIANT     varParentSnapinNode,    /* I:Snapin under which this new snapin will be added (optional)*/
    VARIANT     varProperties,          /* I:props to create with (optional)*/
    SnapIn**    ppSnapIn)               /* O:created snap-in                */
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScAdd"));

    /*
     * dereference VT_BYREF VARIANTs that VBScript might have passed us
     */
    VARIANT* pProperties = ConvertByRefVariantToByValue (&varProperties);

    VARIANT* pParentSnapinNode = ConvertByRefVariantToByValue (&varParentSnapinNode);

    /*
     * validate the parameters
     */
    sc = ScCheckPointers(ppSnapIn, pProperties, pParentSnapinNode);
    if (sc)
        return (sc);

    /*
     * Get the properties for the new snap-in.  This is an optional
     * parameter, so VT_ERROR with DISP_E_PARAMNOTFOUND is OK
     */
    PropertiesPtr spProperties;

    if (!IsOptionalParamMissing (*pProperties))
    {
        /*
         * Assign from the VARIANT (ain't smart pointers great?).
         * If the QI returned E_NOINTERFACE, the smart pointer will be
         * assigned NULL.  If the QI failed in some other way, operator=
         * will throw a _com_error containing the failure HRESULT.
         */
        try
        {
            if ((spProperties = _variant_t(*pProperties)) == NULL)
                sc = E_NOINTERFACE;
        }
        catch (_com_error& err)
        {
            sc = err.Error();
        }

        if (sc)
            return (sc.ToHr());
    }

    /*
     * Get the parent snapin node for the new snap-in.  This is an optional
     * parameter, so VT_ERROR with DISP_E_PARAMNOTFOUND is OK
     */
    SnapInPtr spParentSnapIn;

    if (!IsOptionalParamMissing (*pParentSnapinNode))
    {
        /*
         * Assign from the VARIANT (ain't smart pointers great?).
         * If the QI returned E_NOINTERFACE, the smart pointer will be
         * assigned NULL.  If the QI failed in some other way, operator=
         * will throw a _com_error containing the failure HRESULT.
         */
        try
        {
            if ((spParentSnapIn = _variant_t(*pParentSnapinNode)) == NULL)
                sc = E_NOINTERFACE;
        }
        catch (_com_error& err)
        {
            sc = err.Error();
        }

        if (sc)
            return (sc.ToHr());
    }

    sc = ScAddSnapin(bstrSnapinNameOrCLSID, spParentSnapIn, spProperties, *ppSnapIn);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CScopeTree:ScRemove
//
//  Synopsis:    Remove given snapin.
//
//  Arguments:   [pSnapIn] - the snapin (disp) interface.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScopeTree::ScRemove (PSNAPIN pSnapIn)
{
    DECLARE_SC(sc, _T("CScopeTree:ScRemove"));
    sc = ScCheckPointers(pSnapIn);
    if (sc)
        return sc;

    // Get the MTNode for this snapin root.
    CMTSnapInNode *pMTSnapinNode = NULL;

    sc = CMTSnapInNode::ScGetCMTSnapinNode(pSnapIn, &pMTSnapinNode);
    if (sc)
        return sc;

    CSnapinManager snapinMgr(GetRoot());

    // Ask snapin mgr to add this snapin to deletednodes list.
    sc = snapinMgr.ScRemoveSnapin(pMTSnapinNode);
    if (sc)
        return sc;

    // Update the scope tree with changes made by snapin manager.
    sc = ScAddOrRemoveSnapIns(snapinMgr.GetDeletedNodesList(),
                              snapinMgr.GetNewNodes());
    if (sc)
        return sc;

    return (sc);
}



/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetNextStaticNode
 *
 * PURPOSE: Returns the next static node (either the child or sibling) of the supplied node.
 *          This is slightly different from CMTNode::NextStaticNode(), which includes the node
 *          itself in the search.
 *
 * PARAMETERS:
 *    CMTNode *pMTNode : The supplied node.
 *
 * RETURNS:
 *    CMTSnapInNode *
 *
 *+-------------------------------------------------------------------------*/
CMTSnapInNode *
CScopeTree::GetNextStaticNode(CMTNode *pMTNode)
{
    CMTSnapInNode *pMTSnapInNode = NULL;

    if(!pMTNode)
        return NULL;

    // go thru all the children, then thru all the siblings.
    CMTNode *pMTNodeChild = pMTNode->Child();
    CMTNode *pMTNodeNext  = pMTNode->Next();
    CMTNode *pMTNodeParent= pMTNode->Parent();

    // see if the child is a snapin
    pMTSnapInNode = dynamic_cast<CMTSnapInNode*>(pMTNodeChild);
    if(pMTSnapInNode)
        return pMTSnapInNode;

    // the child wasn't a snap-in node. Try its children.
    if(pMTNodeChild)
    {
        pMTSnapInNode = GetNextStaticNode(pMTNodeChild);
        if(pMTSnapInNode)
            return pMTSnapInNode;
    }

    // That didn't work either. Check to see if the next node is a snapin
    pMTSnapInNode = dynamic_cast<CMTSnapInNode*>(pMTNodeNext);
    if(pMTSnapInNode)
        return pMTSnapInNode;

    // the next node wasn't a snap-in node. Try its children.
    if(pMTNodeNext)
    {
        pMTSnapInNode = GetNextStaticNode(pMTNodeNext);
        if(pMTSnapInNode)
            return pMTSnapInNode;
    }

    // nothing was found in the next node's tree. Go to the next node of the parent.

    if(pMTNodeParent)
    {
        CMTNode *pMTNodeParentNext = pMTNodeParent->Next();
        if(pMTNodeParentNext)
        {
            pMTSnapInNode = dynamic_cast<CMTSnapInNode*>(pMTNodeParentNext);
            if(pMTSnapInNode)
                return pMTSnapInNode;

            // the parent's next node was not a snapin node. Try its children
            return GetNextStaticNode(pMTNodeParentNext);
        }

    }

    // nothing left.
    return NULL;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScItem
 *
 * PURPOSE:  Returns a pointer to the i'th snap-in object.
 *
 * PARAMETERS:
 *    long      Index : 1-based.
 *    PPSNAPIN  ppSnapIn :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScItem(long Index, PPSNAPIN ppSnapIn)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScItem"));

    // check parameters.
    if( (Index <= 0) || (!ppSnapIn) )
        return (sc = E_INVALIDARG);

    CMTNode * pMTNode = GetRoot();
    if(!pMTNode)
        return (sc = E_UNEXPECTED);

    CMTSnapInNode * pMTSINode = dynamic_cast<CMTSnapInNode*>(pMTNode);
    // This should not be true as console root is a snapin.
    sc = ScCheckPointers(pMTSINode, E_UNEXPECTED);
    if (sc)
        return sc;

    while(--Index)
    {
        pMTSINode = GetNextStaticNode(pMTSINode);
        if(!pMTSINode)
            return (sc = E_INVALIDARG); // no more snap-ins. Argument was out of bounds.
    }

    if(!pMTSINode)
        return (sc = E_UNEXPECTED); // defensive. Should never happen.

    sc = pMTSINode->ScGetSnapIn(ppSnapIn);
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::Scget_Count
 *
 * PURPOSE:  Returns the number of stand alone snapins in the collection.
 *
 * PARAMETERS:
 *    PLONG     Ptr to count.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::Scget_Count(PLONG pCount)
{
    DECLARE_SC(sc, TEXT("CScopeTree::Scget_Count"));
    sc = ScCheckPointers(pCount);
    if (sc)
        return sc;

    *pCount = 0;

    CMTNode * pMTNode = GetRoot();
    if(!pMTNode)
        return (sc = E_UNEXPECTED);

    CMTSnapInNode * pMTSINode = dynamic_cast<CMTSnapInNode*>(pMTNode);
    // This should not be true as console root is a snapin.
    sc = ScCheckPointers(pMTSINode, E_UNEXPECTED);
    if (sc)
        return sc;

    // Count all the static nodes (that are snapins).
    do
    {
        (*pCount)++;
    } while( (pMTSINode = GetNextStaticNode(pMTSINode)) != NULL);

    return sc;
}


//############################################################################
//############################################################################
//
//  CScopeTree Object model methods - SnapIns enumerator
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScGetNextSnapInPos
 *
 * PURPOSE: Returns the next snap-in in position.
 *
 * PARAMETERS:
 *    CSnapIns_Positon & pos : [in, out]: Must be non-NULL.
 *
 *
 *
 * RETURNS:
 *    SC: S_FALSE if there are no more items in the collection
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScGetNextSnapInPos(CSnapIns_Positon &pos)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScGetNextSnapInPos"));

    if(pos == NULL)
       return (sc = S_FALSE);

    // for safety, copy the value and zero the output
    CSnapIns_Positon    posIn  = pos;
    pos  = NULL;

    ASSERT(posIn != NULL); //sanity check, already checked above.

    CMTNode *           pMTNode = GetRoot();
    if(!pMTNode)
    {
        return (sc = E_UNEXPECTED);
    }

    CMTSnapInNode * pMTSINode = dynamic_cast<CMTSnapInNode*>(pMTNode);
    if(!pMTSINode)
        return (sc = S_FALSE);


    // If we're not starting at the beginning, look for the current position.
    // walk down the tree looking for the snap-in.
    // although the position pointer is simply the pointer, we cannot dereference
    // it because it may not be valid anymore.
    while(pMTSINode != NULL)
    {
        CMTSnapInNode *pMTSINodeNext = GetNextStaticNode(pMTSINode);

        if(posIn == pMTSINode) // found the position. Return the next one
        {
            pos = pMTSINodeNext;
            return (sc = (pos == NULL) ? S_FALSE : S_OK);
        }

        pMTSINode = pMTSINodeNext;
    }

    return (sc = S_FALSE);
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScEnumNext
 *
 * PURPOSE: Returns the next snapin object pointer.
 *
 * PARAMETERS:
 *    _Position & pos :
 *    PDISPATCH & pDispatch :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScEnumNext(CSnapIns_Positon &pos, PDISPATCH & pDispatch)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScEnumNext"));

    if( NULL==pos )
    {
        sc = S_FALSE;
        return sc;
    }

    // at this point, we have a valid position.
    SnapInPtr spSnapIn;

    sc = pos->ScGetSnapIn(&spSnapIn);
    if(sc)
        return sc;

    if(spSnapIn == NULL)
    {
        sc = E_UNEXPECTED;  // should never happen.
        return sc;
    }

    /*
     * return the IDispatch for the object and leave a ref on it for the client
     */
    pDispatch = spSnapIn.Detach();

    //ignore this error
    ScGetNextSnapInPos(pos); // this gets the correct pointer without dereferencing the present one.

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScEnumSkip
 *
 * PURPOSE: Skips the next celt items
 *
 * PARAMETERS:
 *    unsigned           long :
 *    CSnapIns_Positon & pos :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScEnumSkip(unsigned long celt, unsigned long& celtSkipped, CSnapIns_Positon &pos)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScEnumSkip"));

    // skip celt positions, don't check the last skip.
    for(celtSkipped =0;  celtSkipped<celt; celt++)
    {
        if (pos == NULL)
        {
            sc = S_FALSE;
            return sc;
        }

        // go to the next view
        sc = ScGetNextSnapInPos(pos);
        if(sc.IsError() || sc == SC(S_FALSE))
            return sc;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScEnumReset
 *
 * PURPOSE: Sets the position to the first item
 *
 * PARAMETERS:
 *    CSnapIns_Positon & pos :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScEnumReset(CSnapIns_Positon &pos)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScEnumReset"));

    // initial case. Return Console Root.
    pos = dynamic_cast<CMTSnapInNode*>(CScopeTree::GetScopeTree()->GetRoot());

    return sc;
}

//############################################################################
//############################################################################
//
//  CScopeTree Object model methods - ScopeNamespace methods
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 *
 * ScCheckInputs
 *
 * PURPOSE: little helper for the following three functions.
 *
 * PARAMETERS:
 *    PNODE   pNode :  Checked for NULL, and that it is a CMMCScopeNode.
 *                     Also pNode->m_pMTNode is checked for NULL.
 *    PPNODE  ppNode : Checked for NULL.
 *    PMTNODE pMTNode: [out]: pNode->m_pMTNode;
 *
 * RETURNS:
 *    inline SC
 *
 *+-------------------------------------------------------------------------*/
inline SC
ScCheckInputs(PNODE pNode, PPNODE ppNode, PMTNODE & pMTNode)
{
    SC sc; // don't need DECLARE_SC here.

    // check parameters
    if( (NULL == pNode) || (NULL == ppNode) )
    {
        sc = E_INVALIDARG;
        return sc;
    }

    // make sure we have a scope node
    CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(pNode);
    if(!pScopeNode)
    {
        sc = E_INVALIDARG;
        return sc;
    }

    // make sure it's node pointer is good
    if(!pScopeNode->GetMTNode())
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    pMTNode = pScopeNode->GetMTNode();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScGetParent
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    PNODE   pNode :
 *    PPNODE  ppParent :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScGetParent(PNODE pNode, PPNODE ppParent)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScGetParent"));

    PMTNODE pMTNode = NULL;

    // check parameters
    sc = ScCheckInputs(pNode, ppParent, pMTNode);
    if(sc)
        return sc;


    sc = ScGetNode(pMTNode->Parent(), ppParent);
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScGetChild
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    PNODE   pNode :
 *    PPNODE  ppChild :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScGetChild(PNODE pNode, PPNODE ppChild)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScGetChild"));

    PMTNODE pMTNode = NULL;

    // check parameters
    sc = ScCheckInputs(pNode, ppChild, pMTNode);
    if(sc)
        return sc;


    sc = ScGetNode(pMTNode->Child(), ppChild);
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScGetNext
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    PNODE   pNode :
 *    PPNODE  ppNext :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScGetNext(PNODE pNode, PPNODE ppNext)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScGetNext"));

    PMTNODE pMTNode = NULL;

    // check parameters
    sc = ScCheckInputs(pNode, ppNext, pMTNode);
    if(sc)
        return sc;

    sc = ScGetNode(pMTNode->Next(), ppNext);
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScGetRoot
 *
 * PURPOSE: Returns a COM object for the Root the Root node.
 *
 * PARAMETERS:
 *    PPNODE  ppRoot :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScGetRoot(PPNODE ppRoot)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScGetRoot"));

    sc = ScGetRootNode(ppRoot);

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CScopeTree::ScGetRootNode
//
//  Synopsis:    Helper that returns a COM object for the Root node.
//
//  Arguments:   [ppRootNode] - The root node ptr.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScopeTree::ScGetRootNode (PPNODE ppRootNode)
{
    DECLARE_SC(sc, _T("CScopeTree::ScGetRootNode"));
    sc = ScCheckPointers(ppRootNode);
    if (sc)
        return sc;

    CMTNode* pMTRootNode = GetRoot();
    sc = ScCheckPointers(pMTRootNode, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = ScGetNode(pMTRootNode, ppRootNode);
    if (sc)
        return sc;

    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScExpand
 *
 * PURPOSE: Implements ScopeNameSpace::Expand. Expands the specified node.
 *
 * PARAMETERS:
 *    PNODE  pNode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScExpand(PNODE pNode)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScExpand"));

    // check parameters
    sc = ScCheckPointers(pNode);
    if(sc)
        return sc;

    // make sure we have a scope node
    CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(pNode);
    if(!pScopeNode)
    {
        sc = E_INVALIDARG;
        return sc;
    }

    // make sure it's node pointer is good
    CMTNode* pMTNode = pScopeNode->GetMTNode();
    if(!pMTNode)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    if ( !pMTNode->WasExpandedAtLeastOnce() )
    {
        sc = pMTNode->Expand();
        if (sc)
            return sc;
    }

    return sc;
}


SC
CScopeTree::ScGetNode(CMTNode *pMTNode, PPNODE ppOut)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScGetNode"));

    sc = ScCheckPointers(pMTNode, ppOut);
    if(sc)
        return sc;

    *ppOut = NULL;

    CMapMTNodeToMMCNode::iterator it = m_mapMTNodeToMMCNode.find(pMTNode);

    if (it == m_mapMTNodeToMMCNode.end())
    {
        // not found - got to create one
        typedef CComObject<CMMCScopeNode> CScopeNode;
        CScopeNode *pScopeNode = NULL;
        CScopeNode::CreateInstance(&pScopeNode);

        sc = ScCheckPointers(pScopeNode, E_OUTOFMEMORY);
        if(sc)
            return sc;

        // set up the internal pointer.
        pScopeNode->m_pMTNode = pMTNode;
        m_mapMTNodeToMMCNode.insert(CMapMTNodeToMMCNode::value_type(pMTNode, pScopeNode));
        *ppOut = pScopeNode;
    }
    else
    {
#ifdef DBG
        CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(it->second);
        // just doublecheck the pointers
        ASSERT(pScopeNode && pScopeNode->GetMTNode() == pMTNode);
#endif // DBG
        *ppOut = it->second;
    }


    (*ppOut)->AddRef();  // addref the object for the client.

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScGetNode
 *
 * PURPOSE: Returns the CMTNode encapsulated by a Node.
 *
 * PARAMETERS:
 *    PNODE     pNode :
 *    CMTNode * ppMTNodeOut : The return value.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScGetNode(PNODE pNode, CMTNode **ppMTNodeOut)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScGetNode"));

    sc = ScCheckPointers(pNode, ppMTNodeOut);
    if (sc)
        return sc;

    // make sure we have a scope node
    CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(pNode);
    if(!pScopeNode)
        return (sc =E_FAIL);

    *ppMTNodeOut = pScopeNode->GetMTNode();
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetHMTNode
 *
 * PURPOSE: returns the HMTNode for a node object
 *
 * PARAMETERS:
 *    PNODE     pNode :
 *    HMTNODE * phMTNode :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CScopeTree::GetHMTNode(PNODE pNode, HMTNODE *phMTNode)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetHMTNode"));

    sc = ScCheckPointers(pNode, phMTNode);
    if (sc)
        return sc.ToHr();

    // initialize output
    *phMTNode = NULL;

    // make sure we have a scope node
    CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(pNode);
    if(!pScopeNode)
    {
        // Not a valid node - that's expected. Do not assert nor trace
        return E_FAIL;
    }

    CMTNode *pMTNode = pScopeNode->GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    *phMTNode = CMTNode::ToHandle(pMTNode);

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetNodeID
 *
 * PURPOSE:    returns node id for Node object
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
HRESULT CScopeTree::GetNodeID(PNODE pNode, MTNODEID *pID)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetNodeID"));

    sc = ScCheckPointers(pNode, pID);
    if (sc)
        return sc.ToHr();

    // make sure we have a scope node
    CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(pNode);
    if(!pScopeNode)
    {
        // Not a valid node - that's expected. Do not assert nor trace
        return E_FAIL;
    }

    CMTNode *pMTNode = pScopeNode->GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    *pID = pMTNode->GetID();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetNode
 *
 * PURPOSE:    returns Node object referencing the specified node id
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
HRESULT CScopeTree::GetMMCNode(HMTNODE hMTNode, PPNODE ppNode)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetMMCNode"));

    // parameter checking
    sc = ScCheckPointers((LPVOID)hMTNode);
    if (sc)
        return sc.ToHr();

    // get the node
    sc = ScGetNode(CMTNode::FromHandle(hMTNode), ppNode);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CCScopeTree::ScUnadviseMTNode
 *
 * PURPOSE:    informs Node objects about MTNode going down
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CScopeTree::ScUnadviseMTNode(CMTNode* pMTNode)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScUnadviseMTNode"));

    sc = ScCheckPointers(pMTNode);
    if (sc)
        return sc;

    CMapMTNodeToMMCNode::iterator it = m_mapMTNodeToMMCNode.find(pMTNode);
    // need to tell the com object [if we have one] this is the end of MTNode
    if (it != m_mapMTNodeToMMCNode.end())
    {
        // make sure we have a scope node
        CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(it->second);
        sc = ScCheckPointers(pScopeNode, E_UNEXPECTED);
        if (sc)
            return sc;

        ASSERT(pScopeNode->GetMTNode() == pMTNode);
        // can forget about the object from now on
        pScopeNode->ResetMTNode();
        m_mapMTNodeToMMCNode.erase(it);
    }
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScUnadviseMMCScopeNode
 *
 * PURPOSE:    informs Scope tree about Node object about to be destroyed
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CScopeTree::ScUnadviseMMCScopeNode(PNODE pNode)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScUnadviseMMCScopeNode"));

    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(pNode);
    sc = ScCheckPointers(pScopeNode, E_UNEXPECTED);
    if (sc)
        return sc;

    CMTNode* pMTNode = pScopeNode->GetMTNode();
    if (!pMTNode)
    {
        // orphan entry - ignore
#ifdef DBG
        // to detect leaks in keeping the registry
        CMapMTNodeToMMCNode::iterator it = m_mapMTNodeToMMCNode.begin();
        while (it != m_mapMTNodeToMMCNode.end())
        {
            ASSERT(it->second != pNode);
            ++it;
        }
#endif
        return sc;
    }

    CMapMTNodeToMMCNode::iterator it = m_mapMTNodeToMMCNode.find(pMTNode);
    // need to tell the com object [i.e. itself] this is the end of relationship with MTNode
    if (it == m_mapMTNodeToMMCNode.end())
        return sc = E_UNEXPECTED;

    // make sure we really talking to itself
    ASSERT(pScopeNode->GetMTNode() == pMTNode);

    // can forget about the MTNode from now on
    pScopeNode->ResetMTNode();
    m_mapMTNodeToMMCNode.erase(it);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CScopeTree::IsSnapinInUse
 *
 * PURPOSE: checks if snapin is in use by MMC.
 *          (check is done by examining snapin cache)
 *
 * PARAMETERS:
 *    REFCLSID refClsidSnapIn - [in] - snapin to examine
 *    PBOOL pbInUse           - [out] - verification result
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CScopeTree::IsSnapinInUse(/*[in]*/ REFCLSID refClsidSnapIn, /*[out]*/ PBOOL pbInUse)
{
    DECLARE_SC(sc, TEXT("CScopeTree::IsSnapinInUse"));

    // parameter check
    sc = ScCheckPointers(pbInUse);
    if (sc)
        return sc.ToHr();

    // out parameter initialization
    *pbInUse = FALSE;

    // getting the cache
    CSnapInsCache* pCache = theApp.GetSnapInsCache();
    sc = ScCheckPointers(pCache, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // assume it exists
    *pbInUse = TRUE;

    // looup snapin
    CSnapInPtr spSnapIn;
    sc = pCache->ScFindSnapIn(refClsidSnapIn, &spSnapIn);
    if(sc)
    {
        // if failed to find - assume one does not exist
        *pbInUse = FALSE;
        // no trace if not found
        sc.Clear();
    }

    return sc.ToHr();
}

 //+-------------------------------------------------------------------
 //
 //  Member:      CScopeTree::ScSetHelpCollectionInvalid
 //
 //  Synopsis:    Inform the document that help collection is invalid
 //
 //  Arguments:
 //
 //  Returns:     SC
 //
 //--------------------------------------------------------------------
 SC CScopeTree::ScSetHelpCollectionInvalid ()
 {
     DECLARE_SC(sc, _T("CScopeTree::ScSetHelpCollectionInvalid"));

     sc = ScCheckPointers(m_pConsoleData, m_pConsoleData->m_pConsoleDocument, E_UNEXPECTED);
     if (sc)
         return sc;

     sc = m_pConsoleData->m_pConsoleDocument->ScSetHelpCollectionInvalid();

     return (sc);
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\scoptree.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ScopTree.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//____________________________________________________________________________
//

#ifndef _SCOPTREE_H_
#define _SCOPTREE_H_

class CDocument;
class CNode;
class CMTNode;
class CSPImageCache;
class CMTSnapInNode;
class CExtensionsCache;
class CSnapIn;
class CMultiSelection;
class CConsoleTaskpad;
class CConsoleTaskpadList;
class CDefaultTaskpadList;
class CConsoleFrame;
class CNewTreeNode;

typedef CNewTreeNode*  PNEWTREENODE;
typedef CList <PNEWTREENODE, PNEWTREENODE> NewNodeList;
typedef CList<HMTNODE, HMTNODE> CHMTNODEList;
typedef CTypedPtrList<MMC::CPtrList, CMTNode*> CMTNodeList;
typedef CList<CMTNode*, CMTNode*> MTNodesList;
typedef std::map<CMTNode*, PNODE> CMapMTNodeToMMCNode;

typedef CMTSnapInNode * PMTSNAPINNODE;

// forward declarations for external classes
class CBookmark;


/*+-------------------------------------------------------------------------*
 * class CMMCScopeNode
 *
 *
 * PURPOSE: Implements the Node automation interface, for a scope node
 *
 *+-------------------------------------------------------------------------*/
class CMMCScopeNode :
    public CMMCIDispatchImpl<Node>
{
    friend class CScopeTree;

public:
    BEGIN_MMC_COM_MAP(CMMCScopeNode)
    END_MMC_COM_MAP()

    // Node methods
public:
    STDMETHODIMP get_Name( PBSTR  pbstrName);
    STDMETHODIMP get_Property( BSTR PropertyName, PBSTR  PropertyValue);
    STDMETHODIMP get_Bookmark( PBSTR pbstrBookmark);
    STDMETHODIMP IsScopeNode(PBOOL pbIsScopeNode);
    STDMETHODIMP get_Nodetype(PBSTR Nodetype);


    // determines whether the object is valid or not.
    ::SC  ScIsValid();

    ~CMMCScopeNode();
public: // accessors
    CMTNode *GetMTNode() {return m_pMTNode;}
    void ResetMTNode()   {m_pMTNode = NULL;}

private:
    ::SC ScGetDataObject(IDataObject **ppDataObject); // returns the data object for the underlying scope node.

private: // implementation
    CMTNode *m_pMTNode;
};


//____________________________________________________________________________
//
//  class:      CScopeTree
//____________________________________________________________________________
//
class CScopeTree :
    public IScopeTree,
    public IPersistStorage,
    public CComObjectRoot,
    public CComCoClass<CScopeTree, &CLSID_ScopeTree>,
    public CTiedObject
{

// Constructor/Destructor
public:
    CScopeTree();
    ~CScopeTree();


public:
#ifdef DBG
    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }
    int dbg_InstID;
#endif // DBG


// ATL Map
public:
BEGIN_COM_MAP(CScopeTree)
    COM_INTERFACE_ENTRY(IScopeTree)
    COM_INTERFACE_ENTRY(IPersistStorage)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CScopeTree)

DECLARE_MMC_OBJECT_REGISTRATION (
    g_szMmcndmgrDll,                    // implementing DLL
    CLSID_ScopeTree,                    // CLSID
    _T("ScopeTree 1.0 Object"),         // class name
    _T("NODEMGR.ScopeTreeObject.1"),    // ProgID
    _T("NODEMGR.ScopeTreeObject"))      // version-independent ProgID

private: // Object model related tied COM objects
    SnapInsPtr        m_spSnapIns;
    ScopeNamespacePtr m_spScopeNamespace;

public: // Object model methods
    // SnapIns interface
    typedef PMTSNAPINNODE CSnapIns_Positon;
    CMTSnapInNode *GetNextStaticNode(CMTNode *pMTNode);

    SC      ScAdd (BSTR bstrSnapinNameOrCLSID, VARIANT varParentSnapin,
                   VARIANT varProperties, SnapIn** ppSnapIn); // add a snap-in.
    SC      ScItem(long Index, PPSNAPIN ppSnapIn);
    SC      ScRemove(PSNAPIN pSnapIn);
    SC      Scget_Count(PLONG pCount);

    // SnapIns enumerator
    SC      ScGetNextSnapInPos(CSnapIns_Positon &pos); // helper function

    SC      ScEnumNext(CSnapIns_Positon &pos, PDISPATCH & pDispatch);
    SC      ScEnumSkip(unsigned long celt, unsigned long& celtSkipped, CSnapIns_