fff) {

        State->NewSample=0x7fff;

    } else {

        if (State->NewSample < -32768) {

            State->NewSample=-32768;

        }
    }

    State->Index += IndexTable[Sample];

    if (State->Index < 0) {

        State->Index = 0;

    } else {

        if (State->Index > 88 ) {

            State->Index = 88;

        }
    }

    State->StepSize=StepSizeTable[State->Index];

    return (SHORT)State->NewSample;

}



VOID  WINAPI
DecompressADPCM(
    LPDECOMPRESS_OBJECT   State,
    BYTE               Sample,
    PSHORT                Destination
    )

{
    DWORD   ReturnValue;

    *Destination++ = AdjustGain(ADPCM4bittoPCM(State, (BYTE)(Sample & 0x0f)),State->Gain);

    *Destination++ = AdjustGain((ADPCM4bittoPCM(State, (BYTE)(Sample>>4))),State->Gain);

    return ;


}






DWORD  WINAPI
CirrusInInit(
    LPVOID  lpvObject,
    WORD    Gain
    )
{

    if (0 == Gain) {

        Gain = 0x2000; // Gain of 32
    }

    InitDecompressor(
        (LPDECOMPRESS_OBJECT)lpvObject,
        Gain
        );


    return MMSYSERR_NOERROR;
}

VOID  WINAPI  CirrusInGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    DWORD   Samples=dwBytes/2;

    *lpdwBufSizeA = 2*( ((Samples/5)*3) + ((Samples%5)*3/5) + 1 );
    *lpdwBufSizeB = (*lpdwBufSizeA) / 4;
}

DWORD  WINAPI  CirrusInRateConvert
(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
)
{
    return 2*SRConvertUp(
                 3,
                 5,
                 (short*)lpSrc,
                 dwSrcLen/2,
                 (short*)lpDest,
                 dwDestLen/2
                 );
}

DWORD WINAPI
CirrusInDecode(
    LPVOID  lpvObject,
    LPBYTE   lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    )
{

    PSHORT   EndPoint;

    DWORD    Samples=dwSrcLen * 2;

    PSHORT   Dest=(PSHORT)lpDest;

    EndPoint=Dest+Samples;

    while (Dest < EndPoint) {

        DecompressADPCM(
            lpvObject,
            *lpSrc++,
            Dest
            );

        Dest+=2;

    }

    return Samples*2;
}

DWORD  WINAPI
CirrusOutInit(
    LPVOID  lpvObject,
    WORD    Gain
    )
{
    if (0 == Gain) {

        Gain = 0x0040; // Gain of 0
    }


    InitCompressor(
        (LPCOMPRESS_OBJECT)lpvObject,
        Gain
        );


    return MMSYSERR_NOERROR;
}

VOID  WINAPI  CirrusOutGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    DWORD   SourceSamples=dwBytes/2;

    *lpdwBufSizeA =(((SourceSamples/5)*3)+((SourceSamples%5)*3/5))*2;

    *lpdwBufSizeB = *lpdwBufSizeA / 4;
}

DWORD  WINAPI  CirrusOutRateConvert
(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
)
{

    return 2 * SRConvertDown(
        5,
        3,
        (short*)lpSrc,
        dwSrcLen/2,
        (short*)lpDest,
        dwDestLen/2
        );

}

DWORD WINAPI
CirrusOutEncode(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    )
{


    DWORD cbDest = dwSrcLen / 4;

    PSHORT  Source=(PSHORT)lpSrc;

    DWORD   Samples=dwSrcLen/2;

    LPBYTE  EndPoint=lpDest+Samples/2;

    SHORT   Sample1;
    SHORT   Sample2;

    while (lpDest < EndPoint) {

        Sample1=*Source++;
        Sample2=*Source++;

        *lpDest++=CompressPCM(
            lpvObject,
            Sample1,
            Sample2
            );

    }



    return Samples/2;
}

DWORD  WINAPI  CirrusGetPosition
(
    LPVOID  lpvObject,
    DWORD dwBytes
)
{
    return ((dwBytes * 4) * 5) / 3;
}

DWORD  WINAPI GetCirrusInfo
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpxiInput->lpfnInit           = CirrusInInit;
    lpxiInput->lpfnGetPosition    = CirrusGetPosition;
    lpxiInput->lpfnGetBufferSizes = CirrusInGetBufferSizes;
    lpxiInput->lpfnTransformA     = CirrusInRateConvert;
    lpxiInput->lpfnTransformB     = CirrusInDecode;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = CirrusOutInit;
    lpxiOutput->lpfnGetPosition    = CirrusGetPosition;
    lpxiOutput->lpfnGetBufferSizes = CirrusOutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = CirrusOutRateConvert;
    lpxiOutput->lpfnTransformB     = CirrusOutEncode;

    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\umcfg\parse.cpp ===
//****************************************************************************
//
//  Module:     UMCONFIG
//  File:       PARSE.C
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//  10/17/97     JosephJ             Created
//
//
//      Top-level parser  routines.
//
//
//****************************************************************************
#include "tsppch.h"
#include "parse.h"
#include "dotapi.h"
#include "docomm.h"
#include "dotsp.h"



TOKEN Tokenize(const TCHAR **ptsz, TOKREC *pTokTable)
{
    const TCHAR *tsz = *ptsz;
    UINT uOffset=0;
    UINT uLen = lstrlen(*ptsz);
    UINT uResult;

    for (TOKREC *ptp = pTokTable; (ptp->tok!=TOK_UNKNOWN); ptp++)
    {
        uOffset = 0;

        if (ptp->ShouldIgnore())
        {
            continue;
        }

        uResult = sscanf(tsz, ptp->szPattern, &uOffset);

        if ((uResult > 0) && uOffset)
        {
            // printf(">>>Offset=%lu\n", uOffset);
            if (uOffset < uLen)
            {
                if (ptp->ShouldMatchIdent())
                {
                    if (isalnum(tsz[uOffset]))
                    {
                        continue;
                    }
                }
                else if (ptp->ShouldMatchWord())
                {
                    if (isalpha(tsz[uOffset]))
                    {
                        continue;
                    }
                }
            }

            // found it!
            break;
        }
    }
    
    // printf("Tokenize(%s): uOffset=%lu; tok=%lu(%s)\n",
    //     *ptsz, uOffset, ptp->tok, Stringize(ptp->tok, pTokTable));

    *ptsz+=uOffset;

    return ptp->tok;
}

const TCHAR * Stringize(TOKEN tok, TOKREC *pTokTable)
{

    for (TOKREC *ptp = pTokTable; (ptp->tok!=TOK_UNKNOWN); ptp++)
    {
        if (ptp->tok == tok)
        {
            break;
        }
    }

    return ptp->szName ? ptp->szName : TEXT("<No Name>");
}


BOOL parse_set(const TCHAR *szInBuf, BOOL fHelp);
BOOL parse_get(const TCHAR *szInBuf, BOOL fHelp);
BOOL parse_open(const TCHAR *szInBuf, BOOL fHelp);
BOOL parse_close(const TCHAR *szInBuf, BOOL fHelp);
BOOL parse_dump(const TCHAR *szInBuf, BOOL fHelp);

void    Parse(void)
{
    TCHAR rgch[256];
    UINT u=0;
    UINT uOffset=0;


    static TOKREC CmdTokTable[] = 
    {
        {TOK_HELP, TEXT(" help%n"), (fTOK_MATCHIDENT), TEXT("help")},
        {TOK_HELP, TEXT(" ?%n"), (0) , NULL},
    
        {TOK_QUIT, TEXT(" quit%n"), (fTOK_MATCHIDENT), TEXT("quit")},
        {TOK_QUIT, TEXT(" q%n"), (fTOK_MATCHIDENT), NULL},
        {TOK_QUIT, TEXT(" bye%n"), (fTOK_MATCHIDENT), NULL},
        {TOK_QUIT, TEXT(" exit%n"), (fTOK_MATCHIDENT), NULL},
    
        {TOK_OPEN, TEXT(" open%n"), (fTOK_MATCHIDENT), TEXT("open")},
        {TOK_OPEN, TEXT(" o%n"), (fTOK_MATCHIDENT), NULL},
    
        {TOK_CLOSE, TEXT(" close%n"), (fTOK_MATCHIDENT), TEXT("close")},
        {TOK_CLOSE, TEXT(" c%n"), (fTOK_MATCHIDENT), NULL},
    
        {TOK_SET, TEXT(" set%n"), (fTOK_MATCHIDENT), TEXT("set")},
        {TOK_SET, TEXT(" s%n"), (fTOK_MATCHIDENT), NULL},
    
        {TOK_GET, TEXT(" get%n"), (fTOK_MATCHIDENT), TEXT("get")},
        {TOK_GET, TEXT(" g%n"), (fTOK_MATCHIDENT), NULL},

        {TOK_DUMP, TEXT(" dump%n"), (fTOK_MATCHIDENT), TEXT("dump")},
    
        {TOK_UNKNOWN, TEXT("<unknown>"), (0), TEXT("<unknown>")} // should be last.
    };

    do 
    {
        const TCHAR *ptsz = rgch;
        printf("> ");
        u=scanf("%[^\n]", rgch);
    
        if (u==EOF) goto end;

        if (u)
        {
            // printf ("input=[%s]\n", rgch);
        
            BOOL fRet = FALSE;
            TOKEN tok = TOK_UNKNOWN;
            BOOL fHelp = FALSE;
    
            tok = Tokenize(&ptsz, CmdTokTable);
            //printf("tok=0x%0lx [%s]\n", tok, Stringize(tok, CmdTokTable));
    
            // Special case: help:
            if (tok == TOK_HELP)
            {
                fHelp = TRUE;
                tok = Tokenize(&ptsz, CmdTokTable);
            }

            switch(tok)
            {

            case TOK_QUIT:
                fRet = TRUE;
                break;
    
            case TOK_GET:
                fRet = parse_get(ptsz, fHelp);
                break;
    
            case TOK_SET:
                fRet = parse_set(ptsz, fHelp);
                break;
    
            case TOK_OPEN:
                fRet = parse_open(ptsz, fHelp);
                break;

            case TOK_CLOSE:
                fRet = parse_close(ptsz, fHelp);
                break;

            case TOK_DUMP:
                fRet = parse_dump(ptsz, fHelp);
                break;
    
            default:
                if (fHelp)
                {
                    printf(" try ? [open|close|set|get|dump]\n");
                }
                break;
            }

            if (!fRet && !fHelp)
            {
                printf("command error.\n");
            }
    
            if (tok == TOK_QUIT)
            {
                break;
            }

        }

        // skip past EOL
        {
            char c;
            u = scanf("%c", &c);
        }

    } while (u!=EOF);

end:

    printf("Bye.\n");


    return;
}

static TOKREC GetSetTokTable[] = 
{

    {TOK_DEBUG, TEXT(" debug%n"), (fTOK_MATCHIDENT), TEXT("debug")},

    {TOK_UNKNOWN, TEXT("<unknown>"), (0), TEXT("<unknown>")} // should be last.
};


BOOL parse_set_debug(const TCHAR *szInBuf, BOOL fHelp);

BOOL parse_set(const TCHAR *szInBuf, BOOL fHelp)
{
    TOKEN tok = TOK_UNKNOWN;
    BOOL fRet = FALSE;

    tok = Tokenize(&szInBuf, GetSetTokTable);

    switch(tok)
    {
        case TOK_DEBUG:
            fRet = parse_set_debug(szInBuf, fHelp);
            break;
        default: 
            if (fHelp)
            {
                fRet=TRUE;
                printf(" s[et] debug ...\n");
            }
            break;
    }

    return fRet;
}

BOOL parse_get_debug(const TCHAR *szInBuf, BOOL fHelp);

BOOL parse_get(const TCHAR *szInBuf, BOOL fHelp)
{
    TOKEN tok = TOK_UNKNOWN;
    BOOL fRet = FALSE;

    tok = Tokenize(&szInBuf, GetSetTokTable);

    switch(tok)
    {
        case TOK_DEBUG:
            fRet = parse_get_debug(szInBuf, fHelp);
            break;
        default: 
            if (fHelp)
            {
                printf(" g[et] debug ...\n");
                fRet = TRUE;
            }
            break;
    }

    return fRet;
}

static TOKREC ComponentTokTable[] = 
{

    {TOK_TAPI32, TEXT(" tapi32%n"), (fTOK_MATCHIDENT), TEXT("tapi32")},
    {TOK_TAPI32, TEXT(" tapi32.dll%n"), (fTOK_MATCHIDENT), NULL},

    {TOK_TAPISRV, TEXT(" tapisrv%n"), (fTOK_MATCHIDENT), TEXT("tapisv")},
    {TOK_TAPISRV, TEXT(" tapisrv.exe%n"), (fTOK_MATCHIDENT), NULL},

    {TOK_UNKNOWN, TEXT("<unknown>"), (0), TEXT("<unknown>")} // should be last.
};

BOOL parse_set_debug_tapi32(const TCHAR *szInBuf, BOOL fHelp);
BOOL parse_set_debug_tapisrv(const TCHAR *szInBuf, BOOL fHelp);

BOOL parse_set_debug(const TCHAR *szInBuf, BOOL fHelp)
{
    TOKEN tok = TOK_UNKNOWN;
    BOOL fRet = FALSE;

    tok = Tokenize(&szInBuf, ComponentTokTable);

    switch(tok)
    {
        case TOK_TAPI32:
            fRet = parse_set_debug_tapi32(szInBuf, fHelp);
            break;

        case TOK_TAPISRV:
            fRet = parse_set_debug_tapisrv(szInBuf, fHelp);
            break;

        default: 
            if (fHelp)
            {
                printf(" s[et] debug [tapisrv|tapisrv32] ...\n");
                fRet = TRUE;
            }
            break;
    }

    return fRet;
}

BOOL parse_get_debug_tapi32(const TCHAR *szInBuf, BOOL fHelp);
BOOL parse_get_debug_tapisrv(const TCHAR *szInBuf, BOOL fHelp);

BOOL parse_get_debug(const TCHAR *szInBuf, BOOL fHelp)
{
    TOKEN tok = TOK_UNKNOWN;
    BOOL fRet = FALSE;

    tok = Tokenize(&szInBuf, ComponentTokTable);

    switch(tok)
    {
        case TOK_TAPI32:
            fRet = parse_get_debug_tapi32(szInBuf, fHelp);
            break;

        case TOK_TAPISRV:
            fRet = parse_get_debug_tapisrv(szInBuf, fHelp);
            break;

        default: 
            if (fHelp)
            {
                printf(" g[et] debug [tapisrv|tapisrv32] ...\n");
                fRet = TRUE;
            }
            break;
    }

    return fRet;
}


BOOL parse_get_debug_tapisrv(const TCHAR *szInBuf, BOOL fHelp)
{
    if (fHelp)
    {
        printf(" g[et] debug tapisrv\n");
        printf("Returns TapiSrvDebugLevel value\n");
    }
    else
    {
        do_get_debug_tapi(TOK_TAPISRV);
    }
    return TRUE;
}

BOOL parse_get_debug_tapi32(const TCHAR *szInBuf, BOOL fHelp)
{
    if (fHelp)
    {
        printf(" g[et] debug tapi32\n");
        printf("Returns Tapi32DebugLevel value\n");
    }
    else
    {
        do_get_debug_tapi(TOK_TAPI32);
    }
    return TRUE;
}


BOOL parse_set_debug_tapi32(const TCHAR *szInBuf, BOOL fHelp)
{
    TCHAR rgch[256];
    BOOL fRet = FALSE;
    DWORD dw  = 0;

    if (fHelp)
    {
        printf(" s[et] debug tapi32 <level>\n");
        printf("Sets Tapi32DebugLevel value\n");
        fRet = TRUE;
    }
    else
    {
        UINT u=sscanf(szInBuf, "%lu", &dw);
        if (u && u!=EOF)
        {
            do_set_debug_tapi(TOK_TAPI32, dw);
            fRet = TRUE;
        }
    }
    return fRet;
}

BOOL parse_set_debug_tapisrv(const TCHAR *szInBuf, BOOL fHelp)
{
    TCHAR rgch[256];
    BOOL fRet = FALSE;
    DWORD dw  = 0;

    if (fHelp)
    {
        printf(" s[et] debug tapisrv <level>\n");
        printf("Sets TapiSrvDebugLevel value\n");
        fRet = TRUE;
    }
    else
    {
        UINT u=sscanf(szInBuf, "%lu", &dw);
        if (u && u!=EOF)
        {
            do_set_debug_tapi(TOK_TAPISRV, dw);
            fRet = TRUE;
        }
    }
    return fRet;
}

static TOKREC OpenTokTable[] = 
{

    {TOK_COMM, TEXT(" COM%n"), (fTOK_MATCHWORD), TEXT("COM")},
    {TOK_COMM, TEXT(" com%n"), (fTOK_MATCHWORD), TEXT("COM")},

    {TOK_UNKNOWN, TEXT("<unknown>"), (0), TEXT("<unknown>")} // should be last.
};

BOOL parse_open_comm(const TCHAR *szInBuf, BOOL fHelp);

BOOL parse_open(const TCHAR *szInBuf, BOOL fHelp)
{
    TOKEN tok = TOK_UNKNOWN;
    BOOL fRet = FALSE;

    tok = Tokenize(&szInBuf, OpenTokTable);

    switch(tok)
    {
        case TOK_COMM:
            fRet = parse_open_comm(szInBuf, fHelp);
            break;

        default: 
            if (fHelp)
            {
                printf(" o[pen] com ...\n");
                fRet = TRUE;
            }
            break;
    }

    return fRet;
}


BOOL parse_open_comm(const TCHAR *szInBuf, BOOL fHelp)
{
    BOOL fRet = FALSE;
    DWORD dw  = 0;

    if (fHelp)
    {
        printf(" o[pen] com<n>\n");
        printf("Opens COM port <n>\n");
        fRet = TRUE;
    }
    else
    {
        UINT u=sscanf(szInBuf, "%lu", &dw);
        if (u && u!=EOF)
        {
            do_open_comm(dw);
            fRet = TRUE;
        }
    }
    return fRet;
}

static TOKREC DumpTokTable[] = 
{
    {TOK_TSPDEV, TEXT(" tspdev%n"), (fTOK_MATCHWORD), TEXT("tspdev")},

    {TOK_UNKNOWN, TEXT("<unknown>"), (0), TEXT("<unknown>")} // should be last.
};

BOOL parse_dump_tspdev(const TCHAR *szInBuf, BOOL fHelp);

BOOL parse_dump(const TCHAR *szInBuf, BOOL fHelp)
{
    TOKEN tok = TOK_UNKNOWN;
    BOOL fRet = FALSE;

    tok = Tokenize(&szInBuf, DumpTokTable);

    switch(tok)
    {
        case TOK_TSPDEV:
            fRet = parse_dump_tspdev(szInBuf, fHelp);
            break;

        default: 
            if (fHelp)
            {
                printf(" dump tspdev <device#> ...\n");
                fRet = TRUE;
            }
            break;
    }

    return fRet;
}


BOOL parse_dump_tspdev(const TCHAR *szInBuf, BOOL fHelp)
{
    BOOL fRet = FALSE;
    DWORD dw  = 0;

    if (fHelp)
    {
        printf(" dump tspdev <device#>\n");
        printf("Dumps internal state of the specified TAPI device\n");
        fRet = TRUE;
    }
    else
    {
        UINT u=sscanf(szInBuf, "%lu", &dw);
        if (u && u!=EOF)
        {
            do_dump_tspdev(dw);
            fRet = TRUE;
        }
    }
    return fRet;
}


BOOL parse_close(const TCHAR *szInBuf, BOOL fHelp)
{
    TOKEN tok = TOK_UNKNOWN;
    BOOL fRet = FALSE;

    if (fHelp)
    {
        printf(" c[lose] <handle> ...\n");
    }
    else
    {
        printf(" close not implemeted ...\n");
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\umdmxfrm\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//      This file contains definitions for DEBUG builds; all debugging
//      instructions are #define-d to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG

#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "SERWVDRV"  // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef _WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
    #define ASSERT(x)
#endif

#ifdef __cplusplus
}
#endif

#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\umdmxfrm\rwadpcm.h ===
//---------------------------------------------------------------------------
//
//  Module:   rwadpcm.h
//
//  Description:
//     Header file for Rockwell ADPCM
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//
//  History:   Date       Author      Comment
//             8/31/95    MMaclin     Removed from driver.h
//
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1991 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/

#define RWADPCM_4BIT_SAMPLESTOBYTES(dwSamples) ((dwSamples)/2)
#define RWADPCM_4BIT_BYTESTOSAMPLES(dwBytes) ((dwBytes)*2)

#define RVF_SETSL 1
#define RVF_RETAIN_LSB 2
#define RVF_RETAIN_MSB 4

VOID PASCAL
RVComInit(
    UINT bps
    );

VOID PASCAL
RVDecomInit(
    int SetSLFlag, 
    UINT bps, 
    UINT (far PASCAL *SLCallBack)()
    );


DWORD PASCAL
RVDecom4bpsByteNew(
    BYTE Qdata0
    );



BYTE PASCAL
RVCom4bpsByteNew(
    DWORD Src
    );



VOID PASCAL
RWADPCMCom4bit(LPDWORD lpSrc, 
            DWORD dwSrcLen,
            LPSTR lpDst,
            DWORD dwDstLen
            );

VOID PASCAL
RWADPCMDecom4bit(LPSTR lpSrc, 
            DWORD dwSrcLen,
            LPDWORD lpDst,
            DWORD dwDstLen
            );
#if 0
VOID PASCAL
SRConvert7200to8000(LPINT lpSrc,
            DWORD dwSrcLen,
            LPINT lpDst,
            DWORD dwDstLen
            );

VOID PASCAL
SRConvert8000to7200(LPINT lpSrc,
            DWORD dwSrcLen,
            LPINT lpDst,
            DWORD dwDstLen
            );
#endif

VOID PASCAL
RWADPCMDecom4bitNoGain(LPSTR lpSrc,
            DWORD dwSrcLen,
            LPDWORD lpDst,
            DWORD dwDstLen
            );



//---------------------------------------------------------------------------
//  End of File: rwadpcm.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\umdmxfrm\sierra.c ===
//---------------------------------------------------------------------------
//
//  Module:   wavein.c
//
//  Description:
//     Wave interface for MSSB16.DRV.
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//
//  History:   Date       Author      Comment
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1994 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/

#include "xfrmpriv.h"

//#include "cirrus.h"




DWORD WINAPI  SierraInInit
(
    LPVOID  lpvObject,
    WORD    Gain
)
{

    LPDECOMPRESS_OBJECT   State=(LPDECOMPRESS_OBJECT)lpvObject;

    if (0 == Gain) {

        Gain = 0x0300; // no gain
    }

    State->Gain=Gain;

    return MMSYSERR_NOERROR;
}


DWORD WINAPI  SierraOutInit
(
    LPVOID  lpvObject,
    WORD    Gain
)
{

    LPCOMPRESS_OBJECT   State=(LPCOMPRESS_OBJECT)lpvObject;

    if (0 == Gain) {

        Gain = 0x0200; // no gain
    }

    State->Gain=Gain;


    return MMSYSERR_NOERROR;
}





//
//
//  7200
//
//

VOID WINAPI  Sierra72InGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{

    DWORD   DestLength;
    DWORD   DestSamples;

    DestSamples=dwBytes/2;


    *lpdwBufSizeA = 2*( ((DestSamples/10)*9) + ((DestSamples%10)*9/10) + 1 );


    *lpdwBufSizeB = *lpdwBufSizeA/2;

}




VOID WINAPI  Sierra72OutGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    DWORD   SourceLength=dwBytes/2;

    *lpdwBufSizeA =(((SourceLength/10)*9)+((SourceLength%10)*9/10))*2;
    *lpdwBufSizeB = *lpdwBufSizeA / 2;
}


DWORD WINAPI  Sierra72GetPosition
(
    LPVOID  lpvObject,
    DWORD dwBytes
)
{
    return ((dwBytes * 2) * 10) / 9;
}




DWORD WINAPI
RateConvert7200to8000(
    LPVOID    Object,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{

    return 2*SRConvertUp(
                 9,
                 10,
                 (short*)Source,
                 SourceLength/2,
                 (short*)Destination,
                 DestinationLength/2
                 );


}



DWORD WINAPI
RateConvert8000to7200(
    LPVOID    Object,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{

    return 2 * SRConvertDown(
        10,
        9,
        (short*)Source,
        SourceLength/2,
        (short*)Destination,
        DestinationLength/2
        );


}



DWORD WINAPI GetUnsignedPCMInfo7200
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpxiInput->lpfnInit           = SierraInInit;
    lpxiInput->lpfnGetPosition    = Sierra72GetPosition;
    lpxiInput->lpfnGetBufferSizes = Sierra72InGetBufferSizes;
    lpxiInput->lpfnTransformA     = RateConvert7200to8000;
    lpxiInput->lpfnTransformB     = Convert8PCMto16PCM;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = SierraOutInit;
    lpxiOutput->lpfnGetPosition    = Sierra72GetPosition;
    lpxiOutput->lpfnGetBufferSizes = Sierra72OutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = RateConvert8000to7200;
    lpxiOutput->lpfnTransformB     = Convert16PCMto8PCM;

    return MMSYSERR_NOERROR;
}





DWORD WINAPI  PcmInInit
(
    LPVOID  lpvObject,
    WORD    Gain
)
{
    LPDECOMPRESS_OBJECT   State=(LPDECOMPRESS_OBJECT)lpvObject;

    if (0 == Gain) {

        Gain = 0x0100; // no gain
    }

    State->Gain=Gain;

    return MMSYSERR_NOERROR;
}

VOID WINAPI  PcmInGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    *lpdwBufSizeA = ((dwBytes/2));
    *lpdwBufSizeB = 0;
}


DWORD WINAPI  PcmOutInit
(
    LPVOID  lpvObject,
    WORD    Gain
)
{
    LPCOMPRESS_OBJECT   State=(LPCOMPRESS_OBJECT)lpvObject;

    if (0 == Gain) {

        Gain = 0x0100; // no gain
    }

    State->Gain=Gain;


    return MMSYSERR_NOERROR;
}

VOID WINAPI  PcmOutGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    *lpdwBufSizeA = ((dwBytes/2));
    *lpdwBufSizeB = 0;
}


DWORD WINAPI  PcmGetPosition
(
    LPVOID  lpvObject,
    DWORD dwBytes
)
{
    return (dwBytes * 2);
}




DWORD WINAPI GetUnsignedPCM8000Info
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpxiInput->lpfnInit           = PcmInInit;
    lpxiInput->lpfnGetPosition    = PcmGetPosition;
    lpxiInput->lpfnGetBufferSizes = PcmInGetBufferSizes;
    lpxiInput->lpfnTransformA     = Convert8PCMto16PCM;
    lpxiInput->lpfnTransformB     = NULL;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = PcmOutInit;
    lpxiOutput->lpfnGetPosition    = PcmGetPosition;
    lpxiOutput->lpfnGetBufferSizes = PcmOutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = Convert16PCMto8PCM;
    lpxiOutput->lpfnTransformB     = NULL;

    return MMSYSERR_NOERROR;
}






DWORD WINAPI GetaLaw8000Info
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpxiInput->lpfnInit           = PcmInInit;
    lpxiInput->lpfnGetPosition    = PcmGetPosition;
    lpxiInput->lpfnGetBufferSizes = PcmInGetBufferSizes;
    lpxiInput->lpfnTransformA     = ConvertaLawto16PCM;
    lpxiInput->lpfnTransformB     = NULL;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = PcmOutInit;
    lpxiOutput->lpfnGetPosition    = PcmGetPosition;
    lpxiOutput->lpfnGetBufferSizes = PcmOutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = Convert16PCMtoaLaw;
    lpxiOutput->lpfnTransformB     = NULL;

    return MMSYSERR_NOERROR;
}


DWORD WINAPI GetuLaw8000Info
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpxiInput->lpfnInit           = PcmInInit;
    lpxiInput->lpfnGetPosition    = PcmGetPosition;
    lpxiInput->lpfnGetBufferSizes = PcmInGetBufferSizes;
    lpxiInput->lpfnTransformA     = ConvertuLawto16PCM;
    lpxiInput->lpfnTransformB     = NULL;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = PcmOutInit;
    lpxiOutput->lpfnGetPosition    = PcmGetPosition;
    lpxiOutput->lpfnGetBufferSizes = PcmOutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = Convert16PCMtouLaw;
    lpxiOutput->lpfnTransformB     = NULL;

    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\umdmxfrm\rateconv.c ===
//---------------------------------------------------------------------------
//
//  Module:   init.c
//
//  Description:
//     MSSB16 initialization routines
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Bryan A. Woodruff
//
//  History:   Date       Author      Comment
//              4/21/94   BryanW      Added this comment block.
//
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1994 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/




#include "xfrmpriv.h"



#pragma optimize("t",on)

DWORD WINAPI
SRConvertDown(
    LONG      NumberOfSourceSamplesInGroup,
    LONG      NumberOfDestSamplesInGroup,
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    )

{

    LONG      SourceIndex;

    LONG      DestPos;

    LONG      SourcePos;

    LONG      Sample1;
    LONG      Sample2;

    LONG      Difference;

    LONG      Distance;

    DWORD     FilledInSamples;

    short    *EndPoint;

    FilledInSamples=((SourceLength/NumberOfSourceSamplesInGroup)*NumberOfDestSamplesInGroup)
                    +((SourceLength%NumberOfSourceSamplesInGroup)*NumberOfDestSamplesInGroup/NumberOfSourceSamplesInGroup);

    EndPoint=Destination+FilledInSamples;


    DestPos=0;

    while (Destination < EndPoint) {

        //
        //  find the nearest source sample that is less than or equall
        //
        SourceIndex= DestPos/NumberOfDestSamplesInGroup;

        SourcePos=  SourceIndex*NumberOfDestSamplesInGroup;

        //
        //  get that source and the next one
        //
        Sample1=Source[SourceIndex];

        Sample2=Source[SourceIndex+1];

        //
        //  get the difference of the two samples
        //
        Difference=Sample2-Sample1;

        //
        //  determine the distance from the source sample to the dest sample
        //
        Distance=DestPos - SourcePos;

        //
        //  slope=Difference/(distance between source samples);
        //
        //  offset=slope*Distance;
        //
        //  DestSample=Source1+Offset;
        //

        *Destination++=(short)(Sample1+((Difference*Distance)/NumberOfDestSamplesInGroup));

        //
        //
        DestPos+=NumberOfSourceSamplesInGroup;
    }

    return FilledInSamples;

}


DWORD WINAPI
SRConvertUp(
    LONG      NumberOfSourceSamplesInGroup,
    LONG      NumberOfDestSamplesInGroup,
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    )

{



    LONG     NumberOfSourceSamples=9;
    LONG     NumberOfDestSamples=10;

    LONG     SourceIndex;

    LONG     DestPos;

    LONG     SourcePos;

    LONG     Sample1;
    LONG     Sample2;

    LONG     Difference;

    LONG     Distance;

    short   *EndPoint;

    DWORD    SamplesFilled;

    if (SourceLength == 0) {

        return 0;
    }


    //
    //  reduce the length, so we will have enough samples to do the conversion
    //
    SourceLength--;


    SamplesFilled=((SourceLength/NumberOfSourceSamplesInGroup)*NumberOfDestSamplesInGroup)
                       +((SourceLength%NumberOfSourceSamplesInGroup)*NumberOfDestSamplesInGroup/NumberOfSourceSamplesInGroup);


    EndPoint=Destination + SamplesFilled;


    ASSERT(EndPoint <= Destination+DestinationLength);

    DestPos=0;

    while (Destination < EndPoint) {

        //
        //  find the nearest source sample that is less than or equall
        //
        SourceIndex= DestPos/NumberOfDestSamplesInGroup;

        SourcePos=  SourceIndex*NumberOfDestSamplesInGroup;


        //
        //  determine the distance from the source sample to the dest sample
        //
        Distance=DestPos - SourcePos;

        //
        //  get that source
        //
        Sample1=Source[SourceIndex];


        if (Distance != 0) {
            //
            //  get the second sample
            //
            Sample2=Source[SourceIndex+1];

            //
            //  get the difference of the two samples
            //
            Difference=Sample2-Sample1;

            //
            //  slope=Difference/(distance between source samples);
            //
            //  offset=slope*Distance;
            //
            //  DestSample=Source1+Offset;
            //

            *Destination++=(short)(Sample1+((Difference*Distance)/NumberOfDestSamplesInGroup));

        } else {
            //
            //  source and dest are the same just copy the sample
            //
            *Destination++=(short)Sample1;
        }
        //
        //
        DestPos+=NumberOfSourceSamplesInGroup;
    }





    return SamplesFilled;

}





VOID WINAPI
SRConvert8000to7200(
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    )

{


    LONG      NumberOfSourceSamples=10;
    LONG      NumberOfDestSamples=9;

    LONG      SourceIndex;

    LONG      DestPos;

    LONG      SourcePos;

    LONG      Sample1;
    LONG      Sample2;

    LONG      Difference;

    LONG      Distance;


    short    *EndPoint=Destination+((SourceLength/10)*9)+((SourceLength%10)*9/10);


    DestPos=0;

    while (Destination < EndPoint) {

        //
        //  find the nearest source sample that is less than of equall
        //
        SourceIndex= DestPos/NumberOfDestSamples;

        SourcePos=  SourceIndex*NumberOfDestSamples;

        //
        //  get that source and the next one
        //
        Sample1=Source[SourceIndex];

        Sample2=Source[SourceIndex+1];

        //
        //  get the difference of the two samples
        //
        Difference=Sample2-Sample1;

        //
        //  determine the distance from the source sample to the dest sample
        //
        Distance=DestPos - SourcePos;

        //
        //  slope=Difference/(distance between source samples);
        //
        //  offset=slope*Distance;
        //
        //  DestSample=Source1+Offset;
        //

        *Destination++=(short)(Sample1+((Difference*Distance)/NumberOfDestSamples));

        //
        //
        DestPos+=NumberOfSourceSamples;
    }





    return;

}

#pragma optimize("",on)


DWORD WINAPI
SRConvert7200to8000(
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    )

{



    LONG     NumberOfSourceSamples=9;
    LONG     NumberOfDestSamples=10;

    LONG     SourceIndex;

    LONG     DestPos;

    LONG     SourcePos;

    LONG     Sample1;
    LONG     Sample2;

    LONG     Difference;

    LONG     Distance;

    short   *EndPoint;

    DWORD    SamplesFilled;

    if (SourceLength == 0) {

        return 0;
    }


    //
    //  reduce the length, so we will have enough samples to do the conversion
    //
    SourceLength--;


    SamplesFilled=((SourceLength/NumberOfSourceSamples)*NumberOfDestSamples)
                       +((SourceLength%NumberOfSourceSamples)*NumberOfDestSamples/NumberOfSourceSamples);


    EndPoint=Destination + SamplesFilled;


    ASSERT(EndPoint <= Destination+DestinationLength);

    DestPos=0;

    while (Destination < EndPoint) {

        //
        //  find the nearest source sample that is less than or equall
        //
        SourceIndex= DestPos/NumberOfDestSamples;

        SourcePos=  SourceIndex*NumberOfDestSamples;


        //
        //  determine the distance from the source sample to the dest sample
        //
        Distance=DestPos - SourcePos;

        //
        //  get that source
        //
        Sample1=Source[SourceIndex];


        if (Distance != 0) {
            //
            //  get the second sample
            //
            Sample2=Source[SourceIndex+1];

            //
            //  get the difference of the two samples
            //
            Difference=Sample2-Sample1;

            //
            //  slope=Difference/(distance between source samples);
            //
            //  offset=slope*Distance;
            //
            //  DestSample=Source1+Offset;
            //

            *Destination++=(short)(Sample1+((Difference*Distance)/NumberOfDestSamples));

        } else {
            //
            //  source and dest are the same just copy the sample
            //
            *Destination++=(short)Sample1;
        }
        //
        //
        DestPos+=NumberOfSourceSamples;
    }





    return SamplesFilled;

}




DWORD WINAPI
Convert8PCMto16PCM(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{
    LPDECOMPRESS_OBJECT   State=(LPDECOMPRESS_OBJECT)Context;

    PSHORT    RealDest=(PSHORT)Destination;

    LPBYTE    EndPoint=Source+SourceLength;


    while (Source < EndPoint) {

        *RealDest++= AdjustGain(
                         (SHORT)(((WORD)*Source++ - 0x80) << 8),
                         State->Gain
                         );

    }

    return SourceLength*2;

}



DWORD WINAPI
Convert16PCMto8PCM(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{

    LPCOMPRESS_OBJECT   State=(LPCOMPRESS_OBJECT)Context;

    LPWORD    RealSource=(LPWORD)Source;

    LPWORD    EndPoint=RealSource+SourceLength/2;


    while (RealSource < EndPoint) {

        *Destination++=(BYTE)((AdjustGain(*RealSource++,State->Gain) >> 8) +0x80);

    }

    return SourceLength/2;

}




//--------------------------------------------------------------------------;
//
//  Name:
//      AlawToPcmTable
//
//
//  Description:
//      this array maps A-law characters to 16-bit PCM
//
//
//  Arguments:
//      the index into the array is an A-law character
//
//  Return:
//      an element of the array is a 16-bit PCM value
//
//  Notes:
//
//
//  History:
//      07/28/93    Created.
//
//
//--------------------------------------------------------------------------;
const SHORT AlawToPcmTable[256] =
    {
         -5504,         // y[00]=   -688
         -5248,         // y[01]=   -656
         -6016,         // y[02]=   -752
         -5760,         // y[03]=   -720
         -4480,         // y[04]=   -560
         -4224,         // y[05]=   -528
         -4992,         // y[06]=   -624
         -4736,         // y[07]=   -592
         -7552,         // y[08]=   -944
         -7296,         // y[09]=   -912
         -8064,         // y[0a]=  -1008
         -7808,         // y[0b]=   -976
         -6528,         // y[0c]=   -816
         -6272,         // y[0d]=   -784
         -7040,         // y[0e]=   -880
         -6784,         // y[0f]=   -848
         -2752,         // y[10]=   -344
         -2624,         // y[11]=   -328
         -3008,         // y[12]=   -376
         -2880,         // y[13]=   -360
         -2240,         // y[14]=   -280
         -2112,         // y[15]=   -264
         -2496,         // y[16]=   -312
         -2368,         // y[17]=   -296
         -3776,         // y[18]=   -472
         -3648,         // y[19]=   -456
         -4032,         // y[1a]=   -504
         -3904,         // y[1b]=   -488
         -3264,         // y[1c]=   -408
         -3136,         // y[1d]=   -392
         -3520,         // y[1e]=   -440
         -3392,         // y[1f]=   -424
        -22016,         // y[20]=  -2752
        -20992,         // y[21]=  -2624
        -24064,         // y[22]=  -3008
        -23040,         // y[23]=  -2880
        -17920,         // y[24]=  -2240
        -16896,         // y[25]=  -2112
        -19968,         // y[26]=  -2496
        -18944,         // y[27]=  -2368
        -30208,         // y[28]=  -3776
        -29184,         // y[29]=  -3648
        -32256,         // y[2a]=  -4032
        -31232,         // y[2b]=  -3904
        -26112,         // y[2c]=  -3264
        -25088,         // y[2d]=  -3136
        -28160,         // y[2e]=  -3520
        -27136,         // y[2f]=  -3392
        -11008,         // y[30]=  -1376
        -10496,         // y[31]=  -1312
        -12032,         // y[32]=  -1504
        -11520,         // y[33]=  -1440
         -8960,         // y[34]=  -1120
         -8448,         // y[35]=  -1056
         -9984,         // y[36]=  -1248
         -9472,         // y[37]=  -1184
        -15104,         // y[38]=  -1888
        -14592,         // y[39]=  -1824
        -16128,         // y[3a]=  -2016
        -15616,         // y[3b]=  -1952
        -13056,         // y[3c]=  -1632
        -12544,         // y[3d]=  -1568
        -14080,         // y[3e]=  -1760
        -13568,         // y[3f]=  -1696
          -344,         // y[40]=    -43
          -328,         // y[41]=    -41
          -376,         // y[42]=    -47
          -360,         // y[43]=    -45
          -280,         // y[44]=    -35
          -264,         // y[45]=    -33
          -312,         // y[46]=    -39
          -296,         // y[47]=    -37
          -472,         // y[48]=    -59
          -456,         // y[49]=    -57
          -504,         // y[4a]=    -63
          -488,         // y[4b]=    -61
          -408,         // y[4c]=    -51
          -392,         // y[4d]=    -49
          -440,         // y[4e]=    -55
          -424,         // y[4f]=    -53
           -88,         // y[50]=    -11
           -72,         // y[51]=     -9
          -120,         // y[52]=    -15
          -104,         // y[53]=    -13
           -24,         // y[54]=     -3
            -8,         // y[55]=     -1
           -56,         // y[56]=     -7
           -40,         // y[57]=     -5
          -216,         // y[58]=    -27
          -200,         // y[59]=    -25
          -248,         // y[5a]=    -31
          -232,         // y[5b]=    -29
          -152,         // y[5c]=    -19
          -136,         // y[5d]=    -17
          -184,         // y[5e]=    -23
          -168,         // y[5f]=    -21
         -1376,         // y[60]=   -172
         -1312,         // y[61]=   -164
         -1504,         // y[62]=   -188
         -1440,         // y[63]=   -180
         -1120,         // y[64]=   -140
         -1056,         // y[65]=   -132
         -1248,         // y[66]=   -156
         -1184,         // y[67]=   -148
         -1888,         // y[68]=   -236
         -1824,         // y[69]=   -228
         -2016,         // y[6a]=   -252
         -1952,         // y[6b]=   -244
         -1632,         // y[6c]=   -204
         -1568,         // y[6d]=   -196
         -1760,         // y[6e]=   -220
         -1696,         // y[6f]=   -212
          -688,         // y[70]=    -86
          -656,         // y[71]=    -82
          -752,         // y[72]=    -94
          -720,         // y[73]=    -90
          -560,         // y[74]=    -70
          -528,         // y[75]=    -66
          -624,         // y[76]=    -78
          -592,         // y[77]=    -74
          -944,         // y[78]=   -118
          -912,         // y[79]=   -114
         -1008,         // y[7a]=   -126
          -976,         // y[7b]=   -122
          -816,         // y[7c]=   -102
          -784,         // y[7d]=    -98
          -880,         // y[7e]=   -110
          -848,         // y[7f]=   -106
          5504,         // y[80]=    688
          5248,         // y[81]=    656
          6016,         // y[82]=    752
          5760,         // y[83]=    720
          4480,         // y[84]=    560
          4224,         // y[85]=    528
          4992,         // y[86]=    624
          4736,         // y[87]=    592
          7552,         // y[88]=    944
          7296,         // y[89]=    912
          8064,         // y[8a]=   1008
          7808,         // y[8b]=    976
          6528,         // y[8c]=    816
          6272,         // y[8d]=    784
          7040,         // y[8e]=    880
          6784,         // y[8f]=    848
          2752,         // y[90]=    344
          2624,         // y[91]=    328
          3008,         // y[92]=    376
          2880,         // y[93]=    360
          2240,         // y[94]=    280
          2112,         // y[95]=    264
          2496,         // y[96]=    312
          2368,         // y[97]=    296
          3776,         // y[98]=    472
          3648,         // y[99]=    456
          4032,         // y[9a]=    504
          3904,         // y[9b]=    488
          3264,         // y[9c]=    408
          3136,         // y[9d]=    392
          3520,         // y[9e]=    440
          3392,         // y[9f]=    424
         22016,         // y[a0]=   2752
         20992,         // y[a1]=   2624
         24064,         // y[a2]=   3008
         23040,         // y[a3]=   2880
         17920,         // y[a4]=   2240
         16896,         // y[a5]=   2112
         19968,         // y[a6]=   2496
         18944,         // y[a7]=   2368
         30208,         // y[a8]=   3776
         29184,         // y[a9]=   3648
         32256,         // y[aa]=   4032
         31232,         // y[ab]=   3904
         26112,         // y[ac]=   3264
         25088,         // y[ad]=   3136
         28160,         // y[ae]=   3520
         27136,         // y[af]=   3392
         11008,         // y[b0]=   1376
         10496,         // y[b1]=   1312
         12032,         // y[b2]=   1504
         11520,         // y[b3]=   1440
          8960,         // y[b4]=   1120
          8448,         // y[b5]=   1056
          9984,         // y[b6]=   1248
          9472,         // y[b7]=   1184
         15104,         // y[b8]=   1888
         14592,         // y[b9]=   1824
         16128,         // y[ba]=   2016
         15616,         // y[bb]=   1952
         13056,         // y[bc]=   1632
         12544,         // y[bd]=   1568
         14080,         // y[be]=   1760
         13568,         // y[bf]=   1696
           344,         // y[c0]=     43
           328,         // y[c1]=     41
           376,         // y[c2]=     47
           360,         // y[c3]=     45
           280,         // y[c4]=     35
           264,         // y[c5]=     33
           312,         // y[c6]=     39
           296,         // y[c7]=     37
           472,         // y[c8]=     59
           456,         // y[c9]=     57
           504,         // y[ca]=     63
           488,         // y[cb]=     61
           408,         // y[cc]=     51
           392,         // y[cd]=     49
           440,         // y[ce]=     55
           424,         // y[cf]=     53
            88,         // y[d0]=     11
            72,         // y[d1]=      9
           120,         // y[d2]=     15
           104,         // y[d3]=     13
            24,         // y[d4]=      3
             8,         // y[d5]=      1
            56,         // y[d6]=      7
            40,         // y[d7]=      5
           216,         // y[d8]=     27
           200,         // y[d9]=     25
           248,         // y[da]=     31
           232,         // y[db]=     29
           152,         // y[dc]=     19
           136,         // y[dd]=     17
           184,         // y[de]=     23
           168,         // y[df]=     21
          1376,         // y[e0]=    172
          1312,         // y[e1]=    164
          1504,         // y[e2]=    188
          1440,         // y[e3]=    180
          1120,         // y[e4]=    140
          1056,         // y[e5]=    132
          1248,         // y[e6]=    156
          1184,         // y[e7]=    148
          1888,         // y[e8]=    236
          1824,         // y[e9]=    228
          2016,         // y[ea]=    252
          1952,         // y[eb]=    244
          1632,         // y[ec]=    204
          1568,         // y[ed]=    196
          1760,         // y[ee]=    220
          1696,         // y[ef]=    212
           688,         // y[f0]=     86
           656,         // y[f1]=     82
           752,         // y[f2]=     94
           720,         // y[f3]=     90
           560,         // y[f4]=     70
           528,         // y[f5]=     66
           624,         // y[f6]=     78
           592,         // y[f7]=     74
           944,         // y[f8]=    118
           912,         // y[f9]=    114
          1008,         // y[fa]=    126
           976,         // y[fb]=    122
           816,         // y[fc]=    102
           784,         // y[fd]=     98
           880,         // y[fe]=    110
           848          // y[ff]=    106
    };

//--------------------------------------------------------------------------;
//
//  Name:
//      UlawToPcmTable
//
//
//  Description:
//      this array maps u-law characters to 16-bit PCM
//
//  Arguments:
//      the index into the array is a u-law character
//
//  Return:
//      an element of the array is a 16-bit PCM value
//
//  Notes:
//
//
//  History:
//      07/28/93    Created.
//
//
//--------------------------------------------------------------------------;
const SHORT UlawToPcmTable[256] =
    {
        -32124,         // y[00]=  -8031
        -31100,         // y[01]=  -7775
        -30076,         // y[02]=  -7519
        -29052,         // y[03]=  -7263
        -28028,         // y[04]=  -7007
        -27004,         // y[05]=  -6751
        -25980,         // y[06]=  -6495
        -24956,         // y[07]=  -6239
        -23932,         // y[08]=  -5983
        -22908,         // y[09]=  -5727
        -21884,         // y[0a]=  -5471
        -20860,         // y[0b]=  -5215
        -19836,         // y[0c]=  -4959
        -18812,         // y[0d]=  -4703
        -17788,         // y[0e]=  -4447
        -16764,         // y[0f]=  -4191
        -15996,         // y[10]=  -3999
        -15484,         // y[11]=  -3871
        -14972,         // y[12]=  -3743
        -14460,         // y[13]=  -3615
        -13948,         // y[14]=  -3487
        -13436,         // y[15]=  -3359
        -12924,         // y[16]=  -3231
        -12412,         // y[17]=  -3103
        -11900,         // y[18]=  -2975
        -11388,         // y[19]=  -2847
        -10876,         // y[1a]=  -2719
        -10364,         // y[1b]=  -2591
         -9852,         // y[1c]=  -2463
         -9340,         // y[1d]=  -2335
         -8828,         // y[1e]=  -2207
         -8316,         // y[1f]=  -2079
         -7932,         // y[20]=  -1983
         -7676,         // y[21]=  -1919
         -7420,         // y[22]=  -1855
         -7164,         // y[23]=  -1791
         -6908,         // y[24]=  -1727
         -6652,         // y[25]=  -1663
         -6396,         // y[26]=  -1599
         -6140,         // y[27]=  -1535
         -5884,         // y[28]=  -1471
         -5628,         // y[29]=  -1407
         -5372,         // y[2a]=  -1343
         -5116,         // y[2b]=  -1279
         -4860,         // y[2c]=  -1215
         -4604,         // y[2d]=  -1151
         -4348,         // y[2e]=  -1087
         -4092,         // y[2f]=  -1023
         -3900,         // y[30]=   -975
         -3772,         // y[31]=   -943
         -3644,         // y[32]=   -911
         -3516,         // y[33]=   -879
         -3388,         // y[34]=   -847
         -3260,         // y[35]=   -815
         -3132,         // y[36]=   -783
         -3004,         // y[37]=   -751
         -2876,         // y[38]=   -719
         -2748,         // y[39]=   -687
         -2620,         // y[3a]=   -655
         -2492,         // y[3b]=   -623
         -2364,         // y[3c]=   -591
         -2236,         // y[3d]=   -559
         -2108,         // y[3e]=   -527
         -1980,         // y[3f]=   -495
         -1884,         // y[40]=   -471
         -1820,         // y[41]=   -455
         -1756,         // y[42]=   -439
         -1692,         // y[43]=   -423
         -1628,         // y[44]=   -407
         -1564,         // y[45]=   -391
         -1500,         // y[46]=   -375
         -1436,         // y[47]=   -359
         -1372,         // y[48]=   -343
         -1308,         // y[49]=   -327
         -1244,         // y[4a]=   -311
         -1180,         // y[4b]=   -295
         -1116,         // y[4c]=   -279
         -1052,         // y[4d]=   -263
          -988,         // y[4e]=   -247
          -924,         // y[4f]=   -231
          -876,         // y[50]=   -219
          -844,         // y[51]=   -211
          -812,         // y[52]=   -203
          -780,         // y[53]=   -195
          -748,         // y[54]=   -187
          -716,         // y[55]=   -179
          -684,         // y[56]=   -171
          -652,         // y[57]=   -163
          -620,         // y[58]=   -155
          -588,         // y[59]=   -147
          -556,         // y[5a]=   -139
          -524,         // y[5b]=   -131
          -492,         // y[5c]=   -123
          -460,         // y[5d]=   -115
          -428,         // y[5e]=   -107
          -396,         // y[5f]=    -99
          -372,         // y[60]=    -93
          -356,         // y[61]=    -89
          -340,         // y[62]=    -85
          -324,         // y[63]=    -81
          -308,         // y[64]=    -77
          -292,         // y[65]=    -73
          -276,         // y[66]=    -69
          -260,         // y[67]=    -65
          -244,         // y[68]=    -61
          -228,         // y[69]=    -57
          -212,         // y[6a]=    -53
          -196,         // y[6b]=    -49
          -180,         // y[6c]=    -45
          -164,         // y[6d]=    -41
          -148,         // y[6e]=    -37
          -132,         // y[6f]=    -33
          -120,         // y[70]=    -30
          -112,         // y[71]=    -28
          -104,         // y[72]=    -26
           -96,         // y[73]=    -24
           -88,         // y[74]=    -22
           -80,         // y[75]=    -20
           -72,         // y[76]=    -18
           -64,         // y[77]=    -16
           -56,         // y[78]=    -14
           -48,         // y[79]=    -12
           -40,         // y[7a]=    -10
           -32,         // y[7b]=     -8
           -24,         // y[7c]=     -6
           -16,         // y[7d]=     -4
            -8,         // y[7e]=     -2
             0,         // y[7f]=      0
         32124,         // y[80]=   8031
         31100,         // y[81]=   7775
         30076,         // y[82]=   7519
         29052,         // y[83]=   7263
         28028,         // y[84]=   7007
         27004,         // y[85]=   6751
         25980,         // y[86]=   6495
         24956,         // y[87]=   6239
         23932,         // y[88]=   5983
         22908,         // y[89]=   5727
         21884,         // y[8a]=   5471
         20860,         // y[8b]=   5215
         19836,         // y[8c]=   4959
         18812,         // y[8d]=   4703
         17788,         // y[8e]=   4447
         16764,         // y[8f]=   4191
         15996,         // y[90]=   3999
         15484,         // y[91]=   3871
         14972,         // y[92]=   3743
         14460,         // y[93]=   3615
         13948,         // y[94]=   3487
         13436,         // y[95]=   3359
         12924,         // y[96]=   3231
         12412,         // y[97]=   3103
         11900,         // y[98]=   2975
         11388,         // y[99]=   2847
         10876,         // y[9a]=   2719
         10364,         // y[9b]=   2591
          9852,         // y[9c]=   2463
          9340,         // y[9d]=   2335
          8828,         // y[9e]=   2207
          8316,         // y[9f]=   2079
          7932,         // y[a0]=   1983
          7676,         // y[a1]=   1919
          7420,         // y[a2]=   1855
          7164,         // y[a3]=   1791
          6908,         // y[a4]=   1727
          6652,         // y[a5]=   1663
          6396,         // y[a6]=   1599
          6140,         // y[a7]=   1535
          5884,         // y[a8]=   1471
          5628,         // y[a9]=   1407
          5372,         // y[aa]=   1343
          5116,         // y[ab]=   1279
          4860,         // y[ac]=   1215
          4604,         // y[ad]=   1151
          4348,         // y[ae]=   1087
          4092,         // y[af]=   1023
          3900,         // y[b0]=    975
          3772,         // y[b1]=    943
          3644,         // y[b2]=    911
          3516,         // y[b3]=    879
          3388,         // y[b4]=    847
          3260,         // y[b5]=    815
          3132,         // y[b6]=    783
          3004,         // y[b7]=    751
          2876,         // y[b8]=    719
          2748,         // y[b9]=    687
          2620,         // y[ba]=    655
          2492,         // y[bb]=    623
          2364,         // y[bc]=    591
          2236,         // y[bd]=    559
          2108,         // y[be]=    527
          1980,         // y[bf]=    495
          1884,         // y[c0]=    471
          1820,         // y[c1]=    455
          1756,         // y[c2]=    439
          1692,         // y[c3]=    423
          1628,         // y[c4]=    407
          1564,         // y[c5]=    391
          1500,         // y[c6]=    375
          1436,         // y[c7]=    359
          1372,         // y[c8]=    343
          1308,         // y[c9]=    327
          1244,         // y[ca]=    311
          1180,         // y[cb]=    295
          1116,         // y[cc]=    279
          1052,         // y[cd]=    263
           988,         // y[ce]=    247
           924,         // y[cf]=    231
           876,         // y[d0]=    219
           844,         // y[d1]=    211
           812,         // y[d2]=    203
           780,         // y[d3]=    195
           748,         // y[d4]=    187
           716,         // y[d5]=    179
           684,         // y[d6]=    171
           652,         // y[d7]=    163
           620,         // y[d8]=    155
           588,         // y[d9]=    147
           556,         // y[da]=    139
           524,         // y[db]=    131
           492,         // y[dc]=    123
           460,         // y[dd]=    115
           428,         // y[de]=    107
           396,         // y[df]=     99
           372,         // y[e0]=     93
           356,         // y[e1]=     89
           340,         // y[e2]=     85
           324,         // y[e3]=     81
           308,         // y[e4]=     77
           292,         // y[e5]=     73
           276,         // y[e6]=     69
           260,         // y[e7]=     65
           244,         // y[e8]=     61
           228,         // y[e9]=     57
           212,         // y[ea]=     53
           196,         // y[eb]=     49
           180,         // y[ec]=     45
           164,         // y[ed]=     41
           148,         // y[ee]=     37
           132,         // y[ef]=     33
           120,         // y[f0]=     30
           112,         // y[f1]=     28
           104,         // y[f2]=     26
            96,         // y[f3]=     24
            88,         // y[f4]=     22
            80,         // y[f5]=     20
            72,         // y[f6]=     18
            64,         // y[f7]=     16
            56,         // y[f8]=     14
            48,         // y[f9]=     12
            40,         // y[fa]=     10
            32,         // y[fb]=      8
            24,         // y[fc]=      6
            16,         // y[fd]=      4
             8,         // y[fe]=      2
             0          // y[ff]=      0
    };







DWORD WINAPI
ConvertaLawto16PCM(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{
    LPDECOMPRESS_OBJECT   State=(LPDECOMPRESS_OBJECT)Context;

    PSHORT    RealDest=(PSHORT)Destination;

    LPBYTE    EndPoint=Source+SourceLength;


    while (Source < EndPoint) {

        *RealDest++= AdjustGain(
                         AlawToPcmTable[*Source++],
                         State->Gain
                         );

    }

    return SourceLength*2;

}


DWORD WINAPI
ConvertuLawto16PCM(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{
    LPDECOMPRESS_OBJECT   State=(LPDECOMPRESS_OBJECT)Context;

    PSHORT    RealDest=(PSHORT)Destination;

    LPBYTE    EndPoint=Source+SourceLength;


    while (Source < EndPoint) {

        *RealDest++= AdjustGain(
                         UlawToPcmTable[*Source++],
                         State->Gain
                         );

    }

    return SourceLength*2;

}






DWORD WINAPI
Convert16PCMtoaLaw(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{

    LPCOMPRESS_OBJECT   State=(LPCOMPRESS_OBJECT)Context;

    PSHORT    RealSource=(PSHORT)Source;

    LPWORD    EndPoint=RealSource+SourceLength/2;

    SHORT     wSample;

    BYTE      alaw;

    while (RealSource < EndPoint) {

        //  Get a signed 16-bit PCM sample from the src buffer
        //

        wSample = AdjustGain(*RealSource++,State->Gain);

        //
        // We'll init our A-law value per the sign of the PCM sample.  A-law
        // characters have the MSB=1 for positive PCM data.  Also, we'll
        // convert our signed 16-bit PCM value to it's absolute value and
        // then work on that to get the rest of the A-law character bits.
        //
        if (wSample < 0) {

            alaw = 0x00;
            wSample = -wSample;

            if (wSample < 0) {

               wSample = 0x7FFF;
            }

        } else {

            alaw = 0x80;

        }

        // Now we test the PCM sample amplitude and create the A-law character.
        // Study the CCITT A-law for more detail.

        if (wSample >= 2048)
            // 2048 <= wSample < 32768
            {
            if (wSample >= 8192)
                // 8192 <= wSample < 32768
                {
                if (wSample >= 16384)
                    // 16384 <= wSample < 32768
                    {
                    alaw |= 0x70 | ((wSample >> 10) & 0x0F);
                    }

                else
                    // 8192 <= wSample < 16384
                    {
                    alaw |= 0x60 | ((wSample >> 9) & 0x0F);
                    }
                }
            else
                // 2048 <= wSample < 8192
                {

                if (wSample >= 4096)
                    // 4096 <= wSample < 8192
                    {
                    alaw |= 0x50 | ((wSample >> 8) & 0x0F);
                    }

                else
                    // 2048 <= wSample < 4096
                    {
                    alaw |= 0x40 | ((wSample >> 7) & 0x0F);
                    }
                }
            }
        else
            // 0 <= wSample < 2048
            {
            if (wSample >= 512)
                // 512 <= wSample < 2048
                {

                if (wSample >= 1024)
                    // 1024 <= wSample < 2048
                    {
                    alaw |= 0x30 | ((wSample >> 6) & 0x0F);
                    }

                else
                    // 512 <= wSample < 1024
                    {
                    alaw |= 0x20 | ((wSample >> 5) & 0x0F);
                    }
                }
            else
                    // 0 <= wSample < 512
                    {
                    alaw |= 0x00 | ((wSample >> 4) & 0x1F);
                    }
            }


        *Destination++=alaw ^ 0x55;      // Invert even bits

    }

    return SourceLength/2;

}

DWORD WINAPI
Convert16PCMtouLaw(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{

    LPCOMPRESS_OBJECT   State=(LPCOMPRESS_OBJECT)Context;

    LPWORD    RealSource=(LPWORD)Source;

    LPWORD    EndPoint=RealSource+SourceLength/2;

    SHORT     wSample;

    BYTE      ulaw;

    while (RealSource < EndPoint) {

        //  Get a signed 16-bit PCM sample from the src buffer

        wSample = AdjustGain(*RealSource++,State->Gain);

        // We'll init our u-law value per the sign of the PCM sample.  u-law
        // characters have the MSB=1 for positive PCM data.  Also, we'll
        // convert our signed 16-bit PCM value to it's absolute value and
        // then work on that to get the rest of the u-law character bits.
        if (wSample < 0)
            {
            ulaw = 0x00;
            wSample = -wSample;
            if (wSample < 0) wSample = 0x7FFF;
            }
        else
            {
            ulaw = 0x80;
            }

        // For now, let's shift this 16-bit value
        //  so that it is within the range defined
        //  by CCITT u-law.
        wSample = wSample >> 2;

        // Now we test the PCM sample amplitude and create the u-law character.
        // Study the CCITT u-law for more details.
        if (wSample >= 8159)
            goto Gotulaw;
        if (wSample >= 4063)
            {
            ulaw |= 0x00 + 15-((wSample-4063)/256);
            goto Gotulaw;
            }
        if (wSample >= 2015)
            {
            ulaw |= 0x10 + 15-((wSample-2015)/128);
            goto Gotulaw;
            }
        if (wSample >= 991)
            {
            ulaw |= 0x20 + 15-((wSample-991)/64);
            goto Gotulaw;
            }
        if (wSample >= 479)
            {
            ulaw |= 0x30 + 15-((wSample-479)/32);
            goto Gotulaw;
            }
        if (wSample >= 223)
            {
            ulaw |= 0x40 + 15-((wSample-223)/16);
            goto Gotulaw;
            }
        if (wSample >= 95)
            {
            ulaw |= 0x50 + 15-((wSample-95)/8);
            goto Gotulaw;
            }
        if (wSample >= 31)
            {
            ulaw |= 0x60 + 15-((wSample-31)/4);
            goto Gotulaw;
            }
        ulaw |= 0x70 + 15-((wSample)/2);

Gotulaw:

        *Destination++=ulaw;

    }

    return SourceLength/2;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\umdmxfrm\rockwell.c ===
//---------------------------------------------------------------------------
//
//  Module:   rockwell.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Brian Lieuallen
//
//  History:   Date       Author      Comment
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1994 - 1997	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/

/*************************************************************************
 *************************************************************************
 ***                   Copyright (c) 1995-1996                         ***
 ***                 Rockwell Telecommunications                       ***
 ***               Digital Communications Division                     ***
 ***                     All rights reserved                           ***
 ***                                                                   ***
 ***              CONFIDENTIAL -- No Dissemination or                  ***
 ***             use without prior written permission                  ***
 ***                                                                   ***
 *************************************************************************
 *                                                                       *
 *    MODULE NAME:     MAIN.C                                            *
 *                                                                       *
 *    AUTHOR:          Stanislav Miller,                                 *
 *                     REDC, Moscow, Russia                              *
 *                                                                       *
 *    HISTORY:         Major Revision         Date             By        *
 *                     --------------       ----------   -------------   *
 *                     Created              06/27/1995   S.Miller        *
 *                     Completed            02/01/1996   S.Miller        *
 *                                                                       *
 *    DESCRIPTION:     This main module contains core functions          *
 *                     for Rockwells ADPCM codec algorithm.              *
 *                                                                       *
 *    NOTES:           Compiling:  Visual C++ v2.0                       *
 *                                                                       *
 *************************************************************************
 *************************************************************************/



#include "xfrmpriv.h"
#include <math.h>

//#include "Rockwell.h"

/* ----------------------- 16 Level case ----------------------------- */
const double Alp16[] = {
   0.2582, 0.5224, 0.7996, 1.099, 1.437, 1.844, 2.401};

const double Bet16[] = {
  -2.733, -2.069, -1.618, -1.256, -0.9424, -0.6568, -0.3881,
  -0.1284, 0.1284, 0.3881, 0.6568, 0.9424, 1.256, 1.618, 2.069, 2.733};

const double M16[] = {
  2.4, 2.0, 1.6, 1.2, 0.9, 0.9, 0.9, 0.9,
  0.9, 0.9, 0.9, 0.9, 1.2, 1.6, 2.0, 2.4};


const double fPow0_8[] = {      /* 0.8**i */
0.800000, 0.640000, 0.512000, 0.409600, 0.327680, 0.262144  
};

const double fMinusPow0_5[] = { /* -0.5**i */
-0.500000, -0.250000, -0.125000, -0.062500, -0.031250, -0.015625  
};


#pragma optimize("t",on)

// Description:
//    This procedure provide sign difference calculation between 'a' and 'b'
// Parameters:
//    a - double type valueb - double type value
// Return Value:
//     1.0 if signs 'a' and 'b' are the same;
//    -1.0 if signs 'a' and 'b' are different;
//
double _inline
XorSgn(
    double a,
    double b
)
{
    if (a*b >= 0.) {

       return 1;

    } else {

       return -1;
    }
}

// Description:
//    This procedure converts normalized float value to normalized
//    short int value
// Parameters:
//    a - normalized double type value
// Return Value:
//    Normalized short value, [-3276832767]
//
short _inline
SShort(
    double a
    )
{
    a *= 32768.0;

    if (a>32767.0) {

        a=32767.0;

    } else {

        if (a<-32768.0) {

            a=-32768.0;
        }
    }

    return (short)a;
}

// Description:
//    This procedure converts normalized short int value to 
//    normalized float value
// Parameters:
//    a - normalized short value, [-3276832767]
// Return Value:
//    Normalized double value
//
double
Double(
    short a
    )
{
  return ((double)a / 32768.);
}

//
//
//  encoder crap
//
//

// Description:
//    This procedure provides implementation of pre-emphasis 
//    filterthat adds gain to the higher frequency components
//    of the speech signal for encoder
// Parameters:
//    x - double value (incoming sample)
// Return Value:
//    double value (filtered sample)
//
double _inline
PreEmphasis(
    LPCOMPRESS_OBJECT  Compress,
    double x
    )
{
  double Y = x - .5*Compress->RW.X1;
  Compress->RW.X1 = x;
  return Y;
}



/* 4bits Quantizer */
// Description:
//    This procedure provides 4-bits quantization
// Parameters:
//    inp - double value (normalized input sample)
// Return Value:
//    double value (quantized sample)
double _inline
QuantStep4(
    CQDATA *QData,
    double inp
    )
{
  int i;
  double Sigma = M16[QData->CodedQout] * QData->Sigma1;
  double x = fabs(inp);

  if(Sigma > SigmaMAX16) Sigma = SigmaMAX16;
  else if(Sigma < SigmaMIN) Sigma = SigmaMIN;

  for(i=0; i<7; i++) if( x < Alp16[i]*Sigma ) break;
  QData->CodedQout = inp>=0. ? 8+i : 7-i;
  QData->Sigma1 = Sigma;

  return (QData->out = Bet16[QData->CodedQout] * Sigma);
}



// Description:
//    This procedure takes one incoming normalized float 
//    speech valueand saves encoding result to the output
//    bitstream via 'Pack' function;
// Parameters:
//    x - double value (incoming filtered sample)
// Return Value:
//    non-packed output Code Word
BYTE
encoder(
    LPCOMPRESS_OBJECT  Compress,
    double x
    )
{
    int i;
    double Xz, Xp, Xpz, d;


    //
    // This is a first step of encoding schema before quantization
    //
    for(Xz=0.,i=1; i<=6; i++) Xz += Compress->RW.q[i]*Compress->RW.b[i-1];
    for(Xp=0.,i=1; i<=2; i++) Xp += Compress->RW.y[i]*Compress->RW.a[i-1];

    Xpz = Xp+Xz;
    d = x - Xpz;

    //
    // This is a quantization step (QuantStep4, QuantStep3 or QuantStep2)
    // according to selected count bit per code word
    //
    Compress->RW.q[0] = QuantStep4(&Compress->RW.CQData,d);  // Invoking Quantization function via pointer
    Compress->RW.y[0] = Compress->RW.q[0]+Xpz;

    //
    // Updating the filters
    //
    for(i=1; i<=6; i++) Compress->RW.b[i-1] = 0.98*Compress->RW.b[i-1] + 0.006*XorSgn(Compress->RW.q[0],Compress->RW.q[i]);
    for(i=1; i<=2; i++) Compress->RW.a[i-1] = 0.98*Compress->RW.a[i-1] + 0.012*XorSgn(Compress->RW.q[0],Compress->RW.y[i]);

    //
    // shifting vectors
    //
    for(i=6; i>=1; i--) Compress->RW.q[i]=Compress->RW.q[i-1];
    for(i=2; i>=1; i--) Compress->RW.y[i]=Compress->RW.y[i-1];


    // Returning not packed code word
    //
    return (BYTE)Compress->RW.CQData.CodedQout;
}

//
//
//  decoder stuff
//
//


// Description:
//    This procedure provides implementation of de-emphasis filter
//    that adds gain to the higher frequency components of the speech
//    signal for decoder
// Parameters:
//    x - double value (decoded sample)
// Return Value:
//    double value (filtered sample)
double _inline
DeEmphasis(
    LPDECOMPRESS_OBJECT  Decompress,
    double x
)
{
  Decompress->RW.Y1 = x + .4*Decompress->RW.Y1;
  return Decompress->RW.Y1;
}


/* 4bits DeQuantizer */
// Description:
//    This procedure provides 4-bits dequantization
// Parameters:
//    inp - int value (Code Word)
// Return Value:
//    double value (dequantized sample)
//
double _inline
DeQuantStep4(
    CDQDATA    *DQData,
    int inp
    )  // oldCode == 8;
{
    double Sigma = M16[DQData->oldCode] * DQData->Sigma1;

    if (Sigma > SigmaMAX16) {

        Sigma = SigmaMAX16;

    } else {

        if (Sigma < SigmaMIN) {

            Sigma = SigmaMIN;
        }
    }

    DQData->oldCode = inp;
    DQData->Sigma1  = Sigma;

    return (DQData->out = Bet16[inp] * Sigma);
}



// Description:
//    This procedure takes one Code Word from incoming bitstream
//    and returns decoded speech sample as normalized double value
// Parameters:
//    xs - int value, Code Word
// Return Value:
//    double value (decoded speech sample)
//
double
decoderImm(
    LPDECOMPRESS_OBJECT  Decompress,
    int xs
)
{
    int i;
    double Xz, Xp, Xpz;
    double R;



    // This is a dequantization step (Adaptive Predictor)
    // (DeQuantStep4, DeQuantStep3 or DeQuantStep2)
    // according to selected count bit per code word
    //

    Decompress->RW.q0[0] = DeQuantStep4(&Decompress->RW.CDQData, xs);  // Invoking deQuantization function via pointer

    //
    // Updating the filters
    //
    for(Xz=0.,i=1; i<=6; i++) Xz += Decompress->RW.q0[i] * Decompress->RW.b0[i-1];
    for(Xp=0.,i=1; i<=2; i++) Xp += Decompress->RW.y0[i] * Decompress->RW.a0[i-1];
    Xpz = Xp+Xz;
    Decompress->RW.y0[0] = Decompress->RW.q0[0]+Xpz;

    //
    // If Postfilter selected...
    //
    if (Decompress->RW.PostFilter) {
        //
        // Postfilter 1
        //
        Decompress->RW.q1[0] = Decompress->RW.y0[0];
        for(Xz=0.,i=1; i<=6; i++) Xz += Decompress->RW.q1[i] * Decompress->RW.b1[i-1];
        for(Xp=0.,i=1; i<=2; i++) Xp += Decompress->RW.y1[i] * Decompress->RW.a1[i-1];
        Xpz = Xp+Xz;
        Decompress->RW.y1[0] = Decompress->RW.q1[0]+Xpz;

        //
        //  Postfilter 2
        //
        Decompress->RW.y2[0] = Decompress->RW.y1[0];
        for(Xz=0.,i=1; i<=6; i++) Xz += Decompress->RW.q2[i] * Decompress->RW.b2[i-1];
        for(Xp=0.,i=1; i<=2; i++) Xp += Decompress->RW.y2[i] * Decompress->RW.a2[i-1];
        Xpz = Xp+Xz;
        Decompress->RW.q2[0] = Decompress->RW.y2[0]+Xpz;

        R = Decompress->RW.q2[0];  /* saving the RESULT */

    } else {

        R = Decompress->RW.y0[0];
    }

    //
    //  Updating the filters
    //
    for (i=1; i<=6; i++) {

        Decompress->RW.b0[i-1] = 0.98*Decompress->RW.b0[i-1] + 0.006*XorSgn(Decompress->RW.q0[0], Decompress->RW.q0[i]);

        if ( Decompress->RW.PostFilter ) {

            Decompress->RW.b1[i-1] = fPow0_8[i-1]      * Decompress->RW.b0[i-1];
            Decompress->RW.b2[i-1] = fMinusPow0_5[i-1] * Decompress->RW.b0[i-1];
        }
    }

    for (i=1; i<=2; i++) {

        Decompress->RW.a0[i-1] = 0.98*Decompress->RW.a0[i-1] + 0.012*XorSgn(Decompress->RW.q0[0], Decompress->RW.y0[i]);

        if (Decompress->RW.PostFilter) {

            Decompress->RW.a1[i-1] = fPow0_8[i-1]      * Decompress->RW.a0[i-1];
            Decompress->RW.a2[i-1] = fMinusPow0_5[i-1] * Decompress->RW.a0[i-1];
        }
    }

    //
    // shifting vectors
    //
    for (i=6; i>=1; i--) {

        Decompress->RW.q0[i]=Decompress->RW.q0[i-1];

        if ( Decompress->RW.PostFilter ) {

            Decompress->RW.q1[i]=Decompress->RW.q1[i-1];
            Decompress->RW.q2[i]=Decompress->RW.q2[i-1];
        }
    }

    for (i=2; i>=1; i--) {

        Decompress->RW.y0[i]=Decompress->RW.y0[i-1];

        if ( Decompress->RW.PostFilter ) {

            Decompress->RW.y1[i]=Decompress->RW.y1[i-1];
            Decompress->RW.y2[i]=Decompress->RW.y2[i-1];
        }
    }

    //
    // returning decoded speech sample as double value
    //
    return R;
}







BYTE static
PCMto4bitADPCM(
    LPCOMPRESS_OBJECT   State,
    SHORT              InSample
    )

{

    BYTE     NewSample;

    double x  = Double(InSample);
    double Xp = PreEmphasis(State,x);

    NewSample=  encoder( State,Xp );


    return NewSample;

}

BYTE  static WINAPI
CompressPCM(
    LPCOMPRESS_OBJECT   State,
    SHORT               Sample1,
    SHORT               Sample2
    )

{
    BYTE   ReturnValue;

    ReturnValue =  PCMto4bitADPCM(State, AdjustGain(Sample1,State->Gain));

    ReturnValue |= PCMto4bitADPCM(State, AdjustGain(Sample2,State->Gain))<<4;


    return ReturnValue;


}




SHORT static
ADPCM4bittoPCM(
     LPDECOMPRESS_OBJECT  State,
     BYTE                Sample
     )

{


    double Y  = decoderImm(State,Sample);
    double Ye = DeEmphasis(State,Y);


    return (SHORT)SShort(Ye);

}



VOID  static WINAPI
DecompressADPCM(
    LPDECOMPRESS_OBJECT   State,
    BYTE               Sample,
    PSHORT                Destination
    )

{
    DWORD   ReturnValue;

    *Destination++ = AdjustGain(ADPCM4bittoPCM(State, (BYTE)(Sample & 0x0f)),State->Gain);

    *Destination++ = AdjustGain(ADPCM4bittoPCM(State, (BYTE)(Sample>>4)),State->Gain);

    return ;


}



DWORD  WINAPI
RockwellInInitNoGain(
    LPVOID  lpvObject,
    WORD   Gain
    )
{

    LPDECOMPRESS_OBJECT   State=(LPDECOMPRESS_OBJECT)lpvObject;
    DWORD   i;

    if (Gain == 0) {

        Gain=0x0100;
    }

    State->Gain=Gain;



    State->RW.CDQData.oldCode = 8;
    State->RW.CDQData.Sigma1=SigmaMIN;
    State->RW.CDQData.out= 0.;

    State->RW.PostFilter=FALSE;

    State->RW.Y1 = 0.;

    //
    // Filter Z-buffers (zero initialized) for main decoder loop
    //
    for (i=0; i<2; i++) {

        State->RW.a0[i]=0.;
        State->RW.a1[i]=0.;
        State->RW.a2[i]=0.;

    }

    for (i=0; i<6; i++) {

        State->RW.b0[i]=0.;
        State->RW.b1[i]=0.;
        State->RW.b2[i]=0.;
    }

    for (i=0; i<3; i++) {

        State->RW.y0[i]=0.;
        State->RW.y1[i]=0.;
        State->RW.y2[i]=0.;
    }

    for (i=0; i<7; i++) {

        State->RW.q0[i]=0.;
        State->RW.q1[i]=0.;
        State->RW.q2[i]=0.;
    }


    return MMSYSERR_NOERROR;
}



DWORD  WINAPI
RockwellInInit(
    LPVOID  lpvObject,
    WORD   Gain
    )
{

    LPDECOMPRESS_OBJECT   State=(LPDECOMPRESS_OBJECT)lpvObject;
    DWORD   i;

    if (Gain == 0) {

        Gain=0x0300;
    }

    State->Gain=Gain;



    State->RW.CDQData.oldCode = 8;
    State->RW.CDQData.Sigma1=SigmaMIN;
    State->RW.CDQData.out= 0.;

    State->RW.PostFilter=FALSE;

    State->RW.Y1 = 0.;

    //
    // Filter Z-buffers (zero initialized) for main decoder loop
    //
    for (i=0; i<2; i++) {

        State->RW.a0[i]=0.;
        State->RW.a1[i]=0.;
        State->RW.a2[i]=0.;

    }

    for (i=0; i<6; i++) {

        State->RW.b0[i]=0.;
        State->RW.b1[i]=0.;
        State->RW.b2[i]=0.;
    }

    for (i=0; i<3; i++) {

        State->RW.y0[i]=0.;
        State->RW.y1[i]=0.;
        State->RW.y2[i]=0.;
    }

    for (i=0; i<7; i++) {

        State->RW.q0[i]=0.;
        State->RW.q1[i]=0.;
        State->RW.q2[i]=0.;
    }


    return MMSYSERR_NOERROR;
}

VOID
WINAPI
In4Bit7200to8Bit8000GetBufferSizes(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
    )
{
    DWORD   Samples=dwBytes/2;

    *lpdwBufSizeA = 2*( ((Samples/10)*9) + ((Samples%10)*9/10) + 1 );
    *lpdwBufSizeB = (*lpdwBufSizeA ) / 4;
}

DWORD
WINAPI
In7200to8000RateConvert(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    )
{
    return 2*SRConvertUp(
                 9,
                 10,
                 (short*)lpSrc,
                 dwSrcLen/2,
                 (short*)lpDest,
                 dwDestLen/2
                 );
}

DWORD WINAPI
RockwellInDecode(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    )
{

    PSHORT   EndPoint;

    DWORD    Samples=dwSrcLen * 2;

    PSHORT   Dest=(PSHORT)lpDest;

    EndPoint=Dest+Samples;

    while (Dest < EndPoint) {

        DecompressADPCM(
            lpvObject,
            *lpSrc++,
            Dest
            );

        Dest+=2;

    }

    return Samples*2;
}

DWORD  WINAPI
RockwellOutInit(
    LPVOID  lpvObject,
    WORD    Gain
    )
{


    LPCOMPRESS_OBJECT   State=(LPCOMPRESS_OBJECT)lpvObject;

    DWORD i;

    if (Gain == 0) {

        Gain=0x0200;
    }

    State->Gain=Gain;


    State->RW.CQData.CodedQout = 8;
    State->RW.CQData.Sigma1=SigmaMIN;
    State->RW.CQData.out=0.;

    // Filter Z-buffers (zero initialized)

    State->RW.X1 = 0.;

    State->RW.a[0]=0.;
    State->RW.a[1]=0.;

    for (i=0; i<6; i++) {

        State->RW.b[i]=0.;
    }

    for (i=0; i<3; i++) {

        State->RW.y[i]=0.;
    }

    for (i=0; i<7; i++) {

        State->RW.q[i]=0.;
    }

    return MMSYSERR_NOERROR;
}

VOID
WINAPI
Out16bit8000to4bit7200GetBufferSizes(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
    )
{
    DWORD   SourceSamples=dwBytes/2;

    *lpdwBufSizeA =(((SourceSamples/10)*9)+((SourceSamples%10)*9/10))*2;

    *lpdwBufSizeB = *lpdwBufSizeA / 4;
}

DWORD
WINAPI
Out8000to7200RateConvert(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    )
{

    return 2 * SRConvertDown(
        10,
        9,
        (short*)lpSrc,
        dwSrcLen/2,
        (short*)lpDest,
        dwDestLen/2
        );

}

DWORD WINAPI
RockwellOutEncode(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    )
{


    DWORD cbDest = dwSrcLen / 4;

    PSHORT  Source=(PSHORT)lpSrc;

    DWORD   Samples=dwSrcLen/2;

    LPBYTE  EndPoint=lpDest+Samples/2;

    SHORT   Sample1;
    SHORT   Sample2;

    while (lpDest < EndPoint) {

        Sample1=*Source++;
        Sample2=*Source++;

        *lpDest++=CompressPCM(
            lpvObject,
            Sample1,
            Sample2
            );

    }



    return Samples/2;
}

DWORD  WINAPI  RockwellGetPosition
(
    LPVOID  lpvObject,
    DWORD dwBytes
)
{
    return ((dwBytes * 4) * 10) / 9;
}

DWORD  WINAPI GetRockwellInfo
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpxiInput->lpfnInit           = RockwellInInit;
    lpxiInput->lpfnGetPosition    = RockwellGetPosition;
    lpxiInput->lpfnGetBufferSizes = In4Bit7200to8Bit8000GetBufferSizes; //RockwellInGetBufferSizes;
    lpxiInput->lpfnTransformA     = In7200to8000RateConvert; //RockwellInRateConvert;
    lpxiInput->lpfnTransformB     = RockwellInDecode;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = RockwellOutInit;
    lpxiOutput->lpfnGetPosition    = RockwellGetPosition;
    lpxiOutput->lpfnGetBufferSizes = Out16bit8000to4bit7200GetBufferSizes; //RockwellOutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = Out8000to7200RateConvert; //RockwellOutRateConvert;
    lpxiOutput->lpfnTransformB     = RockwellOutEncode;

    return MMSYSERR_NOERROR;
}


DWORD  WINAPI GetRockwellInfoNoGain
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpxiInput->lpfnInit           = RockwellInInitNoGain;
    lpxiInput->lpfnGetPosition    = RockwellGetPosition;
    lpxiInput->lpfnGetBufferSizes = In4Bit7200to8Bit8000GetBufferSizes; //RockwellInGetBufferSizes;
    lpxiInput->lpfnTransformA     = In7200to8000RateConvert; //RockwellInRateConvert;
    lpxiInput->lpfnTransformB     = RockwellInDecode;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = RockwellOutInit;
    lpxiOutput->lpfnGetPosition    = RockwellGetPosition;
    lpxiOutput->lpfnGetBufferSizes = Out16bit8000to4bit7200GetBufferSizes; //RockwellOutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = Out8000to7200RateConvert; //RockwellOutRateConvert;
    lpxiOutput->lpfnTransformB     = RockwellOutEncode;

    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\umdmxfrm\init.c ===
//---------------------------------------------------------------------------
//
//  Module:   init.c
//
//  Description:
//     MSSB16 initialization routines
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Bryan A. Woodruff
//
//  History:   Date       Author      Comment
//              4/21/94   BryanW      Added this comment block.
//
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1994 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/



#pragma warning (disable:4704)

#include "xfrmpriv.h"


//
// public data
// 

HMODULE     ghModule ;              // our module handle


BOOL APIENTRY
DllMain(
    HANDLE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    switch(dwReason) {

        case DLL_PROCESS_ATTACH:


            break;

        case DLL_PROCESS_DETACH:


            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:

        default:
              break;

    }

    return TRUE;

}



//--------------------------------------------------------------------------
//  
//  int LibMain
//  
//  Description:
//      Library initialization code
//  
//  Parameters:
//      HMODULE hModule
//         Module handle
//  
//      UINT uDataSeg
//         selector of data segment
//
//      UINT uHeapSize
//         Heap size as specified in .DEF
//  
//      LPSTR lpCmdLine
//         command line passed from kernel
//  
//  Return (int):
//      1 if successful
//  
//@@BEGIN_MSINTERNAL
//  History:   Date       Author      Comment
//              5/20/93   BryanW      
//@@END_MSINTERNAL
//  
//--------------------------------------------------------------------------

int FAR PASCAL LibMain
(
    HMODULE         hModule,
    UINT            uDataSeg,
    UINT            uHeapSize,
    LPSTR           lpCmdLine
)
{

    DbgInitialize(TRUE);
	DPF (1, "LibMain()");

    //
    //  save our module handle
    //

    ghModule = hModule;


    //
    //  succeed the load...
    //
    return (1) ;

} // LibMain()






//---------------------------------------------------------------------------
//  End of File: init.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\umdmxfrm\thinkpad.c ===
//---------------------------------------------------------------------------
//
//  Module:   wavein.c
//
//  Description:
//     Wave interface for MSSB16.DRV.
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Bryan A. Woodruff
//
//  History:   Date       Author      Comment
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1994 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/

#include "xfrmpriv.h"




DWORD FAR PASCAL _loadds ThinkpadInInit
(
    LPVOID  lpvObject,
    WORD    Gain
)
{

    if (0 == Gain) {

        Gain = 0x0100; // no gain
    }


    InitDecompressor(
        (LPDECOMPRESS_OBJECT)lpvObject,
        Gain
        );


    return MMSYSERR_NOERROR;
}

VOID FAR PASCAL _loadds Thinkpad8000InGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    *lpdwBufSizeA = (dwBytes + 3) / 4;
    *lpdwBufSizeB = 0;
}


DWORD FAR PASCAL _loadds ThinkpadOutInit
(
    LPVOID  lpvObject,
    WORD    Gain
)
{
    if (0 == Gain) {

        Gain = 0x0100; // no gain
    }



    InitCompressor(
        (LPCOMPRESS_OBJECT)lpvObject,
        Gain
        );


    return MMSYSERR_NOERROR;
}

VOID FAR PASCAL _loadds Thinkpad8000OutGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    *lpdwBufSizeA = dwBytes / 4;
    *lpdwBufSizeB = 0;
}


DWORD FAR PASCAL _loadds Thinkpad7200GetPosition
(
    LPVOID  lpvObject,
    DWORD dwBytes
)
{
    return ((dwBytes * 4) * 10) / 9;
}

DWORD FAR PASCAL _loadds Thinkpad8000GetPosition
(
    LPVOID  lpvObject,
    DWORD dwBytes
)
{
    return dwBytes * 4;
}

DWORD FAR PASCAL GetThinkpad7200Info
(
    DWORD dwID,
    LPXFORM_INFO lpXformInfo,
    LPXFORM_INFO lpxiOutput
)
{
    lpXformInfo->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpXformInfo->lpfnInit           = ThinkpadInInit;
    lpXformInfo->lpfnGetPosition    = Thinkpad7200GetPosition;
    lpXformInfo->lpfnGetBufferSizes = In4Bit7200to8Bit8000GetBufferSizes; //Thinkpad7200InGetBufferSizes;
    lpXformInfo->lpfnTransformA     = In7200to8000RateConvert; //ThinkpadInRateConvert;
    lpXformInfo->lpfnTransformB     = CirrusInDecode;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = ThinkpadOutInit;
    lpxiOutput->lpfnGetPosition    = Thinkpad7200GetPosition;
    lpxiOutput->lpfnGetBufferSizes = Out16bit8000to4bit7200GetBufferSizes; //Thinkpad7200OutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = Out8000to7200RateConvert; //ThinkpadOutRateConvert;
    lpxiOutput->lpfnTransformB     = CirrusOutEncode;

    return MMSYSERR_NOERROR;
}




DWORD FAR PASCAL GetThinkpad8000Info
(
    DWORD dwID,
    LPXFORM_INFO lpXformInfo,
    LPXFORM_INFO lpxiOutput
)
{
    lpXformInfo->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpXformInfo->lpfnInit           = ThinkpadInInit;
    lpXformInfo->lpfnGetPosition    = Thinkpad8000GetPosition;
    lpXformInfo->lpfnGetBufferSizes = Thinkpad8000InGetBufferSizes;
    lpXformInfo->lpfnTransformA     = CirrusInDecode;
    lpXformInfo->lpfnTransformB     = 0;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = ThinkpadOutInit;
    lpxiOutput->lpfnGetPosition    = Thinkpad8000GetPosition;
    lpxiOutput->lpfnGetBufferSizes = Thinkpad8000OutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = CirrusOutEncode;
    lpxiOutput->lpfnTransformB     = 0;

    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\umdmxfrm\umdmxfrm.c ===
//---------------------------------------------------------------------------
//
//  Module:   umdmxfrm.c
//
//  Description:
//     Header file for global driver declarations
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//
//  History:   Date       Author      Comment
//             8/28/95    MMaclin     Created for UNIMODEM/V
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1991 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/

#include "xfrmpriv.h"

#define NULL_ID         0
#define RWADPCM_ID      1
#define CIRRUS_ID       2
#define THINKPAD7200_ID 3
#define THINKPAD8000_ID 4
#define SIERRA4800_ID   5
#define SIERRA7200_ID   6
#define UNSIGNEDPCM7200 7
#define UNSIGNEDPCM8000 8
#define RWADPCM_NOGAIN_ID 9
#define MULAW8000_ID	10
#define ALAW8000_ID		11


static DWORD FAR PASCAL  NullInit
(
    LPVOID  lpvObject,
    WORD    Gain
)
{
    return MMSYSERR_NOERROR;
}

static DWORD FAR PASCAL  NullGetPosition
(
    LPVOID  lpvObject,
    DWORD dwBytes
)
{
    return dwBytes;
}

static VOID FAR PASCAL  NullGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD dwSamples,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    *lpdwBufSizeA = 0;
    *lpdwBufSizeB = 0;
}

static DWORD FAR PASCAL GetNullInfo
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = 0;
    lpxiInput->lpfnInit           = NullInit;
    lpxiInput->lpfnGetPosition    = NullGetPosition;
    lpxiInput->lpfnGetBufferSizes = NullGetBufferSizes;
    lpxiInput->lpfnTransformA     = NULL;
    lpxiInput->lpfnTransformB     = NULL;

    lpxiOutput->wObjectSize = 0;
    lpxiOutput->lpfnInit           = NullInit;
    lpxiOutput->lpfnGetPosition    = NullGetPosition;
    lpxiOutput->lpfnGetBufferSizes = NullGetBufferSizes;
    lpxiOutput->lpfnTransformA     = NULL;
    lpxiOutput->lpfnTransformB     = NULL;

    return MMSYSERR_NOERROR;
}

DWORD FAR PASCAL  GetXformInfo
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    switch (dwID)
    {
        case NULL_ID:
            return GetNullInfo(
                dwID,
                lpxiInput,
                lpxiOutput
                );
        case RWADPCM_ID:
            return GetRockwellInfo(
                dwID,
                lpxiInput,
                lpxiOutput
                );
        case CIRRUS_ID:
            return GetCirrusInfo(
                dwID,
                lpxiInput,
                lpxiOutput
                );

        case THINKPAD7200_ID:
            return GetThinkpad7200Info(
                dwID,
                lpxiInput,
                lpxiOutput
                );
        case THINKPAD8000_ID:
            return GetThinkpad8000Info(
                dwID,
                lpxiInput,
                lpxiOutput
                );
#if 0
        case SIERRA4800_ID:
            return GetSierraInfo(
                dwID,
                lpxiInput,
                lpxiOutput
                );


        case SIERRA7200_ID:
            return GetSierraInfo7200(
                dwID,
                lpxiInput,
                lpxiOutput
                );
#endif
        case UNSIGNEDPCM7200:
            return GetUnsignedPCMInfo7200(
                dwID,
                lpxiInput,
                lpxiOutput
                );

        case UNSIGNEDPCM8000:
            return GetUnsignedPCM8000Info(
                dwID,
                lpxiInput,
                lpxiOutput
                );
        case RWADPCM_NOGAIN_ID:
            return GetRockwellInfoNoGain(
                dwID,
                lpxiInput,
                lpxiOutput
                );

        case MULAW8000_ID:
            return GetuLaw8000Info(
                dwID,
                lpxiInput,
                lpxiOutput
                );

        case ALAW8000_ID:
            return GetaLaw8000Info(
                dwID,
                lpxiInput,
                lpxiOutput
                );


        default:
            return WAVERR_BADFORMAT;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\umdmxfrm\xfrmpriv.h ===
//---------------------------------------------------------------------------
//
//  Module:   xfrmpriv.h
//
//  Description:
//     Header file for global driver declarations
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//
//  History:   Date       Author      Comment
//             8/31/95    MMacLin     Salvaged from driver.h
//
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1991 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/

#include <windows.h>

#include <mmsystem.h>
#include <mmddk.h>


#include <string.h>

#define Not_VxD

#include "debug.h"
#include "umdmxfrm.h"
#include "rwadpcm.h"


//
// BCODE is a macro to define a R/O variable in the code segment
//



// some definitions to convert between samples and bytes
#define PCM_16BIT_BYTESTOSAMPLES(dwBytes) ((dwBytes)/2)
#define PCM_16BIT_SAMPLESTOBYTES(dwSamples) ((dwSamples)*2)

typedef unsigned int FAR *ULPINT;
typedef unsigned int NEAR *UNPINT;


//
// internal strings (in init.c):
//
//

#ifdef DEBUG
    extern char STR_PROLOGUE[];
    extern char STR_CRLF[];
    extern char STR_SPACE[];
#endif


// init.c:
#include "cirrus.h"


extern HMODULE      ghModule ;           // our module handle

LRESULT FAR PASCAL DrvInit
(
    VOID
);

// drvproc.c

extern DWORD FAR PASCAL  DriverProc
(
    DWORD dwDriverID,
    HANDLE hDriver,
    WORD wMessage,
    DWORD dwParam1,
    DWORD dwParam2
);


int FAR PASCAL LibMain
(
    HMODULE         hModule,
    UINT            uDataSeg,
    UINT            uHeapSize,
    LPSTR           lpCmdLine
) ;


extern DWORD FAR PASCAL  GetXformInfo
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
);


DWORD FAR PASCAL GetRockwellInfo(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
    );


DWORD FAR PASCAL GetCirrusInfo(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
    );


DWORD FAR PASCAL GetThinkpad7200Info(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
    );


DWORD FAR PASCAL GetThinkpad8000Info(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
    );

DWORD FAR PASCAL GetSierraInfo(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
    );

DWORD FAR PASCAL GetSierraInfo7200
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
);


DWORD FAR PASCAL GetUnsignedPCMInfo7200
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
);


DWORD FAR PASCAL GetUnsignedPCM8000Info
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
);


DWORD FAR PASCAL GetRockwellInfoNoGain
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
);

DWORD FAR PASCAL GetuLaw8000Info
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
);

DWORD FAR PASCAL GetaLaw8000Info
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
);


#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") : " str

VOID WINAPI
SRConvert8000to7200(
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    );


DWORD WINAPI
SRConvert7200to8000(
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    );


DWORD WINAPI
SRConvertDown(
    LONG      NumberOfSourceSamplesInGroup,
    LONG      NumberOfDestSamplesInGroup,
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    );

DWORD WINAPI
SRConvertUp(
    LONG      NumberOfSourceSamplesInGroup,
    LONG      NumberOfDestSamplesInGroup,
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    );


DWORD WINAPI
CirrusOutEncode(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    );

DWORD WINAPI
CirrusInDecode(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    );




//---------------------------------------------------------------------------
//  End of File: xfrmpriv.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\uniplat\debug.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    openclos.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

extern DWORD  DebugFlags;

#define  DEBUG_FLAG_ERROR   (1 << 0)
#define  DEBUG_FLAG_INIT    (1 << 1)
#define  DEBUG_FLAG_TRACE   (1 << 2)

#ifdef ASSERT
#undef ASSERT
#endif // ASSERT



#if DBG

#define  D_ERROR(_z)   {if (DebugFlags & DEBUG_FLAG_ERROR) {_z}}

#define  D_INIT(_z)   {if (DebugFlags & DEBUG_FLAG_INIT) {_z}}

#define  D_TRACE(_z)  {if (DebugFlags & DEBUG_FLAG_TRACE) {_z}}

#define  D_ALWAYS(_z)  {{_z}}

#define  ASSERT(_x) { if(!(_x)){DbgPrint("UNIMDMAT: (%s) File: %s, Line: %d \n\r",#_x,__FILE__,__LINE__);DbgBreakPoint();}}

#else

#define  D_ERROR(_z)   {}

#define  D_INIT(_z)   {}

#define  D_TRACE(_z)  {}

#define  D_ALWAYS(_z)  {{_z}}

#define  ASSERT(_x) {}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\uniplat\devchang.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umdmmini.h

Abstract:



Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"

#include <tspnotif.h>
#include <slot.h>


#include <dbt.h>

typedef struct _REMOVE_BLOCK {

    LIST_ENTRY        ListEntry;
    HANDLE            NotificationHandle;
    HANDLE            HandleToWatch;
    REMOVE_CALLBACK  *CallBack;
    PVOID             CallBackContext;

} REMOVE_BLOCK, *PREMOVE_BLOCK;



DWORD
CMP_WaitNoPendingInstallEvents (
    IN DWORD dwTimeout);


LRESULT FAR PASCAL WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)

  {
    HDC       hdc;
    RECT         rect;
    PAINTSTRUCT  ps;

    switch (message)
      {

        case WM_CREATE: {

            DEV_BROADCAST_DEVICEINTERFACE  DevClass;
            HDEVNOTIFY  NotificationHandle;


            D_INIT(DbgPrint("WM_CREATE\n");)

            CopyMemory(&DevClass.dbcc_classguid,&GUID_CLASS_MODEM,sizeof(DevClass.dbcc_classguid));

            DevClass.dbcc_name[0]=L'\0';

            DevClass.dbcc_size=sizeof(DEV_BROADCAST_DEVICEINTERFACE);
            DevClass.dbcc_devicetype=DBT_DEVTYP_DEVICEINTERFACE;

            NotificationHandle=RegisterDeviceNotification(hwnd,&DevClass,DEVICE_NOTIFY_WINDOW_HANDLE);

            if (NotificationHandle == NULL) {

                D_TRACE(DbgPrint("Could not register device notification %d\n",GetLastError());)

            }

            SetWindowLongPtr(hwnd,GWLP_USERDATA,(LONG_PTR)NotificationHandle);

            return 0;
        }

        case WM_DEVICECHANGE: {

            PDEV_BROADCAST_HDR  BroadcastHeader=(PDEV_BROADCAST_HDR)lParam;
            DWORD               DeviceType;


            D_INIT(DbgPrint("DeviceChange\n");)

            if (BroadcastHeader == NULL) {

                return TRUE;
            }

            __try {

                DeviceType=BroadcastHeader->dbch_devicetype;

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                D_ERROR(DbgPrint("DeviceChange: fault accessing device type\n");)

                return TRUE;
            }


            switch ((UINT)wParam)
            {
                case DBT_CONFIGCHANGED:
                case DBT_CONFIGCHANGECANCELED:
                case DBT_QUERYCHANGECONFIG:
                case DBT_USERDEFINED:
                case DBT_DEVNODES_CHANGED:
                    // Do nothing; for these message, lParam is either NULL
                    // or not PDEV_BROADCAST_HDR
                    break;

                default:




                    if (DeviceType == DBT_DEVTYP_DEVICEINTERFACE) {

                        PDEV_BROADCAST_DEVICEINTERFACE lpdb = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;

                        switch (wParam) {

                            case DBT_DEVICEARRIVAL:

                                D_TRACE(DbgPrint("DeviceChange-Arrival\n");)

                                __try {

                                    if (IsEqualGUID(&GUID_CLASS_MODEM,&lpdb->dbcc_classguid)) {
                                        //
                                        // At this point, the modem's installation might not
                                        // be finished yet (the modem class installer has already
                                        // called SetupDiInstallDevice, but the class installer still
                                        // has some things to do after this), so we better wait here for
                                        // the installation to finish.
                                        //
                                        CMP_WaitNoPendingInstallEvents (INFINITE);

                                        D_TRACE(DbgPrint("DeviceChange-Arrival interface change %ws\n",lpdb->dbcc_name);)

                                        UnimodemNotifyTSP (TSPNOTIF_TYPE_CPL,
                                                           fTSPNOTIF_FLAG_CPL_REENUM,
                                                           0, NULL, TRUE);
                                    }

                                } __except (EXCEPTION_EXECUTE_HANDLER) {

                                    break;
                                }


                                break;

                            case DBT_DEVICEREMOVECOMPLETE:

                                __try {

                                    if (IsEqualGUID(&GUID_CLASS_MODEM,&lpdb->dbcc_classguid)) {

                                        D_TRACE(DbgPrint("DeviceChange-remove interface change %ws\n",lpdb->dbcc_name);)

                                        UnimodemNotifyTSP (TSPNOTIF_TYPE_CPL,
                                                           fTSPNOTIF_FLAG_CPL_REENUM,
                                                           0, NULL, TRUE);
                                    }

                                } __except (EXCEPTION_EXECUTE_HANDLER) {

                                    break;
                                }


                                break;

                            default:

                                break;
                        }

                    } else {

                        if (DeviceType == DBT_DEVTYP_HANDLE) {

                            PDEV_BROADCAST_HANDLE    BroadcastHandle=(PDEV_BROADCAST_HANDLE) lParam;
                            REMOVE_CALLBACK  *CallBack=NULL;
                            PVOID             CallBackContext;
                            HANDLE            DeviceHandle;

                            __try {

                                DeviceHandle=BroadcastHandle->dbch_handle;

                            } __except (EXCEPTION_EXECUTE_HANDLER) {

                                D_ERROR(DbgPrint("DeviceChange-Handle-fault access handle\n");)

                                return TRUE;
                            }



                            switch (wParam) {

                                case DBT_DEVICEARRIVAL:

                                    D_TRACE(DbgPrint("DeviceChange-Handle-Arrival\n");)

                                    break;

                                case DBT_DEVICEQUERYREMOVE:
                                case DBT_DEVICEREMOVECOMPLETE:

                                    D_TRACE(DbgPrint("DeviceChange-Handle-query remove\n");)

                                    EnterCriticalSection(
                                        &DriverControl.Lock
                                        );

                                    {
                                        PLIST_ENTRY  Link=DriverControl.MonitorListHead.Flink;

                                        while (Link != &DriverControl.MonitorListHead) {

                                            PREMOVE_BLOCK   RemoveBlock=CONTAINING_RECORD(Link,REMOVE_BLOCK,ListEntry);

                                            if (RemoveBlock->HandleToWatch == DeviceHandle) {
                                                //
                                                //  found the handle it is for
                                                //
                                                D_TRACE(DbgPrint("DeviceChange-Handle-query remove- found block for handle\n");)

                                                CallBack=RemoveBlock->CallBack;
                                                CallBackContext=RemoveBlock->CallBackContext;

                                                break;
                                            }

                                            Link=Link->Flink;
                                        }
                                    }

                                    LeaveCriticalSection(
                                        &DriverControl.Lock
                                        );

                                    if (CallBack != NULL) {

                                        (*CallBack)(CallBackContext);
                                        Sleep(2000);
                                    }


                                    break;

                                case DBT_DEVICEQUERYREMOVEFAILED:

                                    D_TRACE(DbgPrint("DeviceChange-Handle-query remove failed\n");)

                                    break;

                                case DBT_DEVICEREMOVEPENDING:

                                    D_TRACE(DbgPrint("DeviceChange-Handle-remove pending\n");)

                                    break;


/*                                case DBT_DEVICEREMOVECOMPLETE:

                                    D_TRACE(DbgPrint("DeviceChange-Handle-remove complete\n");)

                                    break;
                                    */

                                default:

                                    break;

                            }
                        }
                    }
            }
            return TRUE;
        }

    case WM_POWERBROADCAST: {

        switch(wParam) {

            case PBT_APMSUSPEND:

                D_TRACE(DbgPrint("Power: SUSPEND, calls=%d\n",DriverControl.ActiveCalls);)

                if (DriverControl.ActiveCallsEvent != NULL) {

                    WaitForSingleObject(DriverControl.ActiveCallsEvent,15*1000);
                }

                D_TRACE(DbgPrint("Power: SUSPEND: after wait, calls=%d\n",DriverControl.ActiveCalls);)

                break;

            default:

                break;
        }

        return TRUE;
    }

	case WM_PAINT:

        hdc=BeginPaint(hwnd,&ps);
        GetClientRect (hwnd,&rect);

	    EndPaint(hwnd,&ps);
        return 0;

    case WM_CLOSE: {

        HDEVNOTIFY  NotificationHandle;

        D_INIT(DbgPrint("WM_CLOSE\n");)

        NotificationHandle=(HDEVNOTIFY)GetWindowLongPtr(hwnd,GWLP_USERDATA);

        if (NotificationHandle != NULL) {

            UnregisterDeviceNotification(NotificationHandle);
        }


        DestroyWindow(hwnd);
        return 0;
    }


	case WM_DESTROY:


        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProc(hwnd,message, wParam, lParam);
  }


TCHAR   szAppName[]=TEXT("ModemDeviceChange");
TCHAR   szClassName[]=TEXT("MdmDevChg");


LONG_PTR WINAPI
DllWinMain(
    HWND      ParentWindow,
    HINSTANCE hInstance,
    LPSTR     lpszCmdParam,
    int       nCmdShow
    )

{

    HWND      hwnd;
    MSG       msg;
    WNDCLASS  wndclass;
    HANDLE    MutexHandle;

    D_INIT(DbgPrint("DllWinMain\n");)

    wndclass.style        =  CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc  =  WndProc;
    wndclass.cbClsExtra   =  0;
    wndclass.cbWndExtra   =  0;
    wndclass.hInstance    =  hInstance;
    wndclass.hIcon        =  LoadIcon (NULL, IDI_APPLICATION);
    wndclass.hCursor      =  LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground=  GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName =  NULL;
    wndclass.lpszClassName=  szClassName;

    RegisterClass(&wndclass);



    hwnd = CreateWindow (szClassName,
                         szAppName,
                         WS_OVERLAPPEDWINDOW,
                         CW_USEDEFAULT,
                         CW_USEDEFAULT,
                         CW_USEDEFAULT,
                         CW_USEDEFAULT,
                         NULL,
                         NULL,
                         hInstance,
                         NULL);

    DriverControl.MonitorWindowHandle=hwnd;

    SetEvent(DriverControl.ThreadStartEvent);

    if (hwnd != NULL) {

        while(TRUE)
        {
            DWORD dwResult;
            MSG mMessage;

            while(PeekMessage(&msg,NULL,0,0,PM_REMOVE))
            {
               TranslateMessage(&msg);
               DispatchMessage(&msg);
            }

            dwResult = MsgWaitForMultipleObjects(1, 
                    &DriverControl.ThreadFinishEvent, 
                    FALSE, INFINITE, QS_ALLINPUT);

            // The event was signalled therefore we quit
            
            if (dwResult == 0)
            {
                
                D_INIT(DbgPrint("DllWinMain: resetting event\n");)

                ResetEvent(DriverControl.ThreadFinishEvent);

                return 1;
            }
        }
    	
    }

    return 0;
}



VOID
MonitorWorkerThread(
    PVOID            Context
    )

{


    D_INIT(DbgPrint("UmMonitorThread:  starting\n");)

    DllWinMain(
        NULL,
        DriverControl.ModuleHandle,
        NULL,
        0
        );



    D_INIT(DbgPrint("UmMonitorThread:  Exitting\n");)

    ExitThread(0);

}


BOOL
StartMonitorThread(
    VOID
    )

{

    BOOL    bResult=TRUE;
    DWORD   ThreadId;

    EnterCriticalSection(
        &DriverControl.Lock
        );

    DriverControl.MonitorReferenceCount++;

    if (DriverControl.MonitorReferenceCount == 1) {
        //
        //  first one
        //
        DriverControl.ThreadStartEvent=CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL
            );

        if (DriverControl.ThreadStartEvent != NULL) {
            //
            //  got start event
            //
            DriverControl.MonitorThreadHandle=CreateThread(
                NULL,                                  // attributes
                0,                                     // stack size
                (LPTHREAD_START_ROUTINE)MonitorWorkerThread,
                NULL,
                0,                                     // createion flag
                &ThreadId
                );

            if (DriverControl.MonitorThreadHandle != NULL) {
                //
                //  wait for the thread to start
                //
                WaitForSingleObject(
                    DriverControl.ThreadStartEvent,
                    INFINITE
                    );

            } else {
                //
                //  could not create thread
                //
                bResult=FALSE;

                DriverControl.MonitorReferenceCount--;

            }

            CloseHandle(DriverControl.ThreadStartEvent);

        } else {
            //
            //  could not create event
            //
            bResult=FALSE;

            DriverControl.MonitorReferenceCount--;

        }
    }

    LeaveCriticalSection(
        &DriverControl.Lock
        );


    return bResult;

}

VOID
StopMonitorThread(
    VOID
    )

{


    EnterCriticalSection(
        &DriverControl.Lock
        );

    D_INIT(DbgPrint("StopMonitorThread count %d thread handle %d\n",DriverControl.MonitorReferenceCount,DriverControl.MonitorThreadHandle);)

    DriverControl.MonitorReferenceCount--;

    if (DriverControl.MonitorReferenceCount == 0) {

        if (DriverControl.MonitorThreadHandle != NULL) {

            BOOL    bResult;

            HDEVNOTIFY NotificationHandle;

            /*
            do {

                bResult=PostMessage(
                    DriverControl.MonitorWindowHandle,
                    WM_CLOSE,
                    0,
                    0
                    );

                if (!bResult) {
                    //
                    //  post message failed, Great. Probably out of memory
                    //  Sleep for a while and try again
                    //
                    Sleep(100);
                    }


            } while (!bResult);
            */


            NotificationHandle = (HDEVNOTIFY)
                GetWindowLongPtr(DriverControl.MonitorWindowHandle,
                        GWLP_USERDATA);

            if (NotificationHandle != NULL)
            {
                UnregisterDeviceNotification(NotificationHandle);
            }


            DestroyWindow(DriverControl.MonitorWindowHandle);

            SetEvent(DriverControl.ThreadFinishEvent);

            WaitForSingleObject(
                DriverControl.MonitorThreadHandle,
                INFINITE
                );

            CloseHandle(
                DriverControl.MonitorThreadHandle
                );

            ResetEvent(DriverControl.ThreadFinishEvent);

            DriverControl.MonitorWindowHandle=NULL;
            DriverControl.MonitorThreadHandle=NULL;

        }
    }

    LeaveCriticalSection(
        &DriverControl.Lock
        );


    return;

}



PVOID
MonitorHandle(
    HANDLE    FileHandle,
    REMOVE_CALLBACK  *CallBack,
    PVOID     Context
    )

{
    BOOL                  bResult;
    DEV_BROADCAST_HANDLE  DevBroadcastHandle;
    HDEVNOTIFY            NotificationHandle;
    PREMOVE_BLOCK         RemoveBlock;

    RemoveBlock=ALLOCATE_MEMORY(sizeof(REMOVE_BLOCK));

    if (RemoveBlock == NULL) {

        return NULL;
    }

    RemoveBlock->HandleToWatch=FileHandle;
    RemoveBlock->CallBack=CallBack;
    RemoveBlock->CallBackContext=Context;

    bResult=StartMonitorThread();

    if (!bResult) {

        FREE_MEMORY(RemoveBlock);

        return NULL;
    }




    DevBroadcastHandle.dbch_size=sizeof(DEV_BROADCAST_HANDLE);
    DevBroadcastHandle.dbch_devicetype=DBT_DEVTYP_HANDLE;
    DevBroadcastHandle.dbch_handle=FileHandle;


    EnterCriticalSection(
        &DriverControl.Lock
        );



    RemoveBlock->NotificationHandle=RegisterDeviceNotification(
        DriverControl.MonitorWindowHandle,
        &DevBroadcastHandle,
        DEVICE_NOTIFY_WINDOW_HANDLE
        );

    if (RemoveBlock->NotificationHandle == NULL) {

        D_TRACE(DbgPrint("Could not register device notification %d\n",GetLastError());)

    } else {

        InsertHeadList(
            &DriverControl.MonitorListHead,
            &RemoveBlock->ListEntry
            );


    }

    LeaveCriticalSection(
        &DriverControl.Lock
        );


    if (RemoveBlock->NotificationHandle == NULL) {
        //
        //  Failed
        //
        StopMonitorThread();

        FREE_MEMORY(RemoveBlock);

        return NULL;
    }

    return RemoveBlock;
}

VOID
StopMonitoringHandle(
    PVOID    Context
    )

{

    PREMOVE_BLOCK    RemoveBlock=(PREMOVE_BLOCK)Context;

    EnterCriticalSection(
        &DriverControl.Lock
        );

    RemoveEntryList(&RemoveBlock->ListEntry);

    LeaveCriticalSection(
        &DriverControl.Lock
        );

    UnregisterDeviceNotification(RemoveBlock->NotificationHandle);

    FREE_MEMORY(RemoveBlock);

    StopMonitorThread();

    return;
}


VOID
CallBeginning(
    VOID
    )

{

    EnterCriticalSection(
        &DriverControl.Lock
        );

    DriverControl.ActiveCalls++;

    D_TRACE(DbgPrint("CallBeginning: calls=%d",DriverControl.ActiveCalls);)

    if (DriverControl.ActiveCallsEvent != NULL) {

        ResetEvent(DriverControl.ActiveCallsEvent);
    }

    LeaveCriticalSection(
        &DriverControl.Lock
        );



    return;
}

VOID
CallEnding(
    VOID
    )

{

    EnterCriticalSection(
        &DriverControl.Lock
        );

    DriverControl.ActiveCalls--;

    D_TRACE(DbgPrint("CallEnding: calls=%d",DriverControl.ActiveCalls);)

    if (DriverControl.ActiveCalls == 0) {

        if (DriverControl.ActiveCallsEvent != NULL) {

            SetEvent(DriverControl.ActiveCallsEvent);
        }
    }

    LeaveCriticalSection(
        &DriverControl.Lock
        );



    return;
}



VOID
ResetCallCount(
    VOID
    )

{

    EnterCriticalSection(
        &DriverControl.Lock
        );


    DriverControl.ActiveCalls=0;

    if (DriverControl.ActiveCallsEvent != NULL) {

        SetEvent(DriverControl.ActiveCallsEvent);
    }

    LeaveCriticalSection(
        &DriverControl.Lock
        );


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\uniplat\init.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umdmmini.h

Abstract:

    Nt 5.0 unimodem miniport interface


    The miniport driver is guarenteed that only one action command will
    be austanding at one time. If an action command is called, no more
    commands will be issued until the miniport indicates that it has
    complete processing of the current command.

    UmAbortCurrentCommand() may be called while a command is currently executing
    to infor the miniport that the TSP would like it to complete the current command
    so that it may issue some other command. The miniport may complete the as soon
    as is apropreate.

    The Overlapped callback and Timer callbacks are not synchronized by the TSP
    and may be called at anytime. It is the responsibily of the mini dirver to
    protect its data structures from re-entrancy issues.


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"

#include <tspnotif.h>
#include <slot.h>


#include <dbt.h>

#include <objbase.h>


DWORD  DebugFlags=0;//DEBUG_FLAG_INIT | DEBUG_FLAG_TRACE;




DRIVER_CONTROL   DriverControl;


BOOL APIENTRY
DllMain(
    HANDLE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    switch(dwReason) {

        case DLL_PROCESS_ATTACH:

            __try {

                InitializeCriticalSection(
                    &DriverControl.Lock
                    );

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                return FALSE;
            }


            DriverControl.ActiveCalls=0;
            DriverControl.ActiveCallsEvent=CreateEvent(
                NULL,
                TRUE,
                TRUE,
                NULL
                );

            DriverControl.ThreadFinishEvent=CreateEvent(
                    NULL,
                    TRUE,
                    FALSE,
                    NULL);

            ResetEvent(DriverControl.ThreadFinishEvent);

#if DBG
            {
                CONST static TCHAR  UnimodemRegPath[]=REGSTR_PATH_SETUP TEXT("\\Unimodem");

                LONG    lResult;
                HKEY    hKey;
                DWORD   Type;
                DWORD   Size;

                lResult=RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    UnimodemRegPath,
                    0,
                    KEY_READ,
                    &hKey
                    );


                if (lResult == ERROR_SUCCESS) {

                    Size = sizeof(DebugFlags);

                    RegQueryValueEx(
                        hKey,
                        TEXT("DebugFlags"),
                        NULL,
                        &Type,
                        (LPBYTE)&DebugFlags,
                        &Size
                        );

                    RegCloseKey(hKey);
                }
            }


#endif

            D_INIT(DbgPrint("ProcessAttach\n");)

            DisableThreadLibraryCalls(hDll);
            //
            //  initial global data
            //

            DriverControl.Signature=DRIVER_CONTROL_SIG;

            DriverControl.ReferenceCount=0;

            DriverControl.ModuleHandle=hDll;

            InitializeListHead(&DriverControl.MonitorListHead);

            DEBUG_MEMORY_PROCESS_ATTACH("UNIPLAT");

            break;

        case DLL_PROCESS_DETACH:

            D_INIT(DbgPrint("ProcessDeattach\n");)

            ASSERT(DriverControl.ReferenceCount == 0);
            //
            //  clean up
            //

            if (DriverControl.ActiveCallsEvent!= NULL) {

                CloseHandle(DriverControl.ActiveCallsEvent);
                DriverControl.ActiveCallsEvent=NULL;
            }

            if (DriverControl.ThreadFinishEvent!=NULL)
            {
                CloseHandle(DriverControl.ThreadFinishEvent);
                DriverControl.ThreadFinishEvent=NULL;
            }

            DeleteCriticalSection(
                &DriverControl.Lock
                );

            DEBUG_MEMORY_PROCESS_DETACH();

            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:

        default:
              break;

    }

    return TRUE;

}


VOID
UmWorkerThread(
    PDRIVER_CONTROL   DriverControl
    )

{

    BOOL           bResult;
    DWORD          BytesTransfered;
    DWORD          CompletionKey;
    LPOVERLAPPED   OverLapped;
    DWORD          WaitResult=WAIT_IO_COMPLETION;

    PUM_OVER_STRUCT UmOverlapped;

    D_INIT(DbgPrint("UmWorkThread:  starting\n");)

    while (WaitResult != WAIT_OBJECT_0) {

        WaitResult=WaitForSingleObjectEx(
            DriverControl->ThreadStopEvent,
            INFINITE,
            TRUE
            );


    }

    D_INIT(DbgPrint("UmWorkThread:  Exitting\n");)

    ExitThread(0);

}



HANDLE WINAPI
UmPlatformInitialize(
    VOID
    )
/*++

Routine Description:

    This routine is called to initialize the modem driver.
    It maybe called multiple times. After the first call a reference count will simply
    be incremented. UmDeinitializeModemDriver() must be call and equal number of times.

Arguments:

    None

Return Value:

    returns a handle to Driver instance which is passed to UmOpenModem()
    or NULL for failure



--*/

{

    HANDLE    ReturnValue=&DriverControl;

    EnterCriticalSection(
        &DriverControl.Lock
        );

    DriverControl.ReferenceCount++;

    if ( DriverControl.ReferenceCount == 1) {
        //
        // First call, do init stuff
        //
        D_INIT(DbgPrint("UmPlatFormInitialize\n");)

//        InitializeTimerThread();

        DriverControl.ThreadStopEvent=CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL
            );

        if (DriverControl.ThreadStopEvent != NULL) {

            DWORD   ThreadId;

            DriverControl.ThreadHandle=CreateThread(
                NULL,                                  // attributes
                0,                                     // stack size
                (LPTHREAD_START_ROUTINE)UmWorkerThread,
                &DriverControl,
                0,                                     // createion flag
                &ThreadId
                );

            if (DriverControl.ThreadHandle != NULL) {

                //
                //  bump it up a little
                //
                SetThreadPriority(
                    DriverControl.ThreadHandle,
                    THREAD_PRIORITY_ABOVE_NORMAL
                    );

                ReturnValue=&DriverControl;

            } else {

                DriverControl.ReferenceCount--;

                ReturnValue=NULL;

            }

        } else {

            DriverControl.ReferenceCount--;

            ReturnValue=NULL;

        }

    }


    LeaveCriticalSection(
        &DriverControl.Lock
        );


    return ReturnValue;

}





VOID WINAPI
UmPlatformDeinitialize(
    HANDLE    DriverInstanceHandle
    )
/*++

Routine Description:

    This routine is called to de-initialize the modem driver.

    Must be called the same number of time as UmInitializeModemDriver()

Arguments:

    DriverInstanceHandle - Handle returned by UmInitialmodemDriver

Return Value:

    None


--*/

{



    EnterCriticalSection(
        &DriverControl.Lock
        );

    ASSERT(DriverControl.ReferenceCount != 0);

    DriverControl.ReferenceCount--;

    if ( DriverControl.ReferenceCount == 0) {
        //
        // Last reference, free stuff
        //

        SetEvent(DriverControl.ThreadStopEvent);

        WaitForSingleObject(
            DriverControl.ThreadHandle,
            INFINITE
            );

        CloseHandle(
            DriverControl.ThreadHandle
            );

        CloseHandle(DriverControl.ThreadStopEvent);
    }

    LeaveCriticalSection(
        &DriverControl.Lock
        );



    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\uniplat\internal.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umdmmini.h

Abstract:

    Nt 5.0 unimodem miniport interface


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#define UNICODE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <windowsx.h>
#include <regstr.h>
#include <tapi.h>
#include <tspi.h>

#include <umdmmini.h>

#include <mcx.h>

#include <devioctl.h>

#include <initguid.h>
#include <guiddef.h>

#include <ntddmodm.h>
#include <ntddser.h>

#include "debug.h"

#include <uniplat.h>

#include <debugmem.h>



#define  DRIVER_CONTROL_SIG  (0x43444d55)  //UMDC

typedef struct _DRIVER_CONTROL {

    DWORD                  Signature;

    CRITICAL_SECTION       Lock;

    DWORD                  ReferenceCount;

    HANDLE                 ThreadHandle;

    HANDLE                 ThreadStopEvent;

    HANDLE                 ModuleHandle;

    //
    //  monitor thread values
    //
    HANDLE                 MonitorThreadHandle;
    HWND                   MonitorWindowHandle;
    HANDLE                 ThreadStartEvent;
    ULONG                  MonitorReferenceCount;
    LIST_ENTRY             MonitorListHead;
    HANDLE                 ThreadFinishEvent;


    //
    //                     Call monitoring for power management
    //
    DWORD                  ActiveCalls;
    HANDLE                 ActiveCallsEvent;


} DRIVER_CONTROL, *PDRIVER_CONTROL;




LONG WINAPI
StartModemDriver(
    PDRIVER_CONTROL  DriverControl
    );

LONG WINAPI
StopModemDriver(
    PDRIVER_CONTROL  DriverControl
    );




extern DRIVER_CONTROL   DriverControl;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\uniplat\func.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    func.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"



VOID
WINAPI
UnimodemBasepIoCompletion(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    )

/*++

Routine Description:

    This procedure is called to complete ReadFileEx and WriteFileEx
    asynchronous I/O. Its primary function is to extract the
    appropriate information from the passed IoStatusBlock and call the
    users completion routine.

    The users completion routine is called as:

        Routine Description:

            When an outstanding I/O completes with a callback, this
            function is called.  This function is only called while the
            thread is in an alertable wait (SleepEx,
            WaitForSingleObjectEx, or WaitForMultipleObjectsEx with the
            bAlertable flag set to TRUE).  Returning from this function
            allows another pendiong I/O completion callback to be
            processed.  If this is the case, this callback is entered
            before the termination of the thread's wait with a return
            code of WAIT_IO_COMPLETION.

            Note that each time your completion routine is called, the
            system uses some of your stack.  If you code your completion
            logic to do additional ReadFileEx's and WriteFileEx's within
            your completion routine, AND you do alertable waits in your
            completion routine, you may grow your stack without ever
            trimming it back.

        Arguments:

            dwErrorCode - Supplies the I/O completion status for the
                related I/O.  A value of 0 indicates that the I/O was
                successful.  Note that end of file is indicated by a
                non-zero dwErrorCode value of ERROR_HANDLE_EOF.

            dwNumberOfBytesTransfered - Supplies the number of bytes
                transfered during the associated I/O.  If an error
                occured, a value of 0 is supplied.

            lpOverlapped - Supplies the address of the OVERLAPPED
                structure used to initiate the associated I/O.  The
                hEvent field of this structure is not used by the system
                and may be used by the application to provide additional
                I/O context.  Once a completion routine is called, the
                system will not use the OVERLAPPED structure.  The
                completion routine is free to deallocate the overlapped
                structure.

Arguments:

    ApcContext - Supplies the users completion routine. The format of
        this routine is an LPOVERLAPPED_COMPLETION_ROUTINE.

    IoStatusBlock - Supplies the address of the IoStatusBlock that
        contains the I/O completion status. The IoStatusBlock is
        contained within the OVERLAPPED structure.

    Reserved - Not used; reserved for future use.

Return Value:

    None.

--*/

{

    LPOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine;
    DWORD dwErrorCode;
    DWORD dwNumberOfBytesTransfered;
    LPOVERLAPPED lpOverlapped;

    dwErrorCode = 0;

    if ( NT_ERROR(IoStatusBlock->Status) ) {
        dwErrorCode = RtlNtStatusToDosError(IoStatusBlock->Status);
        dwNumberOfBytesTransfered = 0;
        }
    else {
        dwErrorCode = 0;
        dwNumberOfBytesTransfered = (DWORD)IoStatusBlock->Information;
        }

    CompletionRoutine = (LPOVERLAPPED_COMPLETION_ROUTINE)ApcContext;
    lpOverlapped = (LPOVERLAPPED)CONTAINING_RECORD(IoStatusBlock,OVERLAPPED,Internal);

    (CompletionRoutine)(dwErrorCode,dwNumberOfBytesTransfered,lpOverlapped);

    Reserved;
}




BOOL WINAPI
UnimodemDeviceIoControlEx(
    HANDLE       hFile,             // handle to device of interest
    DWORD        dwIoControlCode,     // control code of operation to perform
    LPVOID       lpInBuffer,          // pointer to buffer to supply input data
    DWORD        nInBufferSize,       // size of input buffer
    LPVOID       lpOutBuffer,         // pointer to buffer to receive output data
    DWORD        nOutBufferSize,      // size of output buffer
    LPOVERLAPPED lpOverlapped,        // pointer to overlapped structure for asynchronous operation
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

{

    NTSTATUS Status;

    if (ARGUMENT_PRESENT(lpOverlapped)) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        Status = NtDeviceIoControlFile(
                     hFile,
                     NULL,
                     UnimodemBasepIoCompletion,
                     (PVOID)lpCompletionRoutine,
                     (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                     dwIoControlCode,
                     lpInBuffer,
                     nInBufferSize,
                     lpOutBuffer,
                     nOutBufferSize
                     );

        if ( NT_ERROR(Status) ) {
//            BaseSetLastNTError(Status);
            return FALSE;

        } else {

            return TRUE;
        }



    } else {

        return FALSE;
    }

}


BOOL
UnimodemReadFileEx(
    HANDLE    FileHandle,
    PVOID     Buffer,
    DWORD     BytesToRead,
    LPOVERLAPPED  Overlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

{

    return ReadFileEx(
               FileHandle,
               Buffer,
               BytesToRead,
               Overlapped,
               lpCompletionRoutine
               );

}


BOOL WINAPI
UnimodemWriteFileEx(
    HANDLE    FileHandle,
    PVOID     Buffer,
    DWORD     BytesToWrite,
    LPOVERLAPPED  Overlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

{

    return WriteFileEx(
               FileHandle,
               Buffer,
               BytesToWrite,
               Overlapped,
               lpCompletionRoutine
               );

}



BOOL WINAPI
UnimodemWaitCommEventEx(
    HANDLE     FileHandle,
    LPDWORD    lpEventMask,
    LPOVERLAPPED  Overlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

{

    return UnimodemDeviceIoControlEx(
        FileHandle,
        IOCTL_SERIAL_WAIT_ON_MASK,
        NULL,
        0,
        lpEventMask,
        sizeof(DWORD),
        Overlapped,
        lpCompletionRoutine
        );

}


VOID
AsyncProcessingHandler(
    ULONG_PTR              dwParam
    )

{
    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)dwParam;
    LPOVERLAPPED_COMPLETION_ROUTINE  Handler;



    Handler=(LPOVERLAPPED_COMPLETION_ROUTINE)UmOverlapped->PrivateCompleteionHandler;

    UmOverlapped->PrivateCompleteionHandler=NULL;

    (*Handler)(
        0,
        0,
        &UmOverlapped->Overlapped
        );

    return;

}

BOOL WINAPI
UnimodemQueueUserAPC(
    LPOVERLAPPED  Overlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )


{

    BOOL               bResult;

    PUM_OVER_STRUCT UmOverlapped=(PUM_OVER_STRUCT)Overlapped;


    UmOverlapped->PrivateCompleteionHandler=lpCompletionRoutine;


    bResult=QueueUserAPC(
        AsyncProcessingHandler,
        UmOverlapped->OverlappedPool,
        (ULONG_PTR)UmOverlapped
        );


    return bResult;

}





HANDLE WINAPI
CreateOverStructPool(
    HANDLE      PlatformHandle,
    DWORD       PoolSize
    )

{

    return DriverControl.ThreadHandle;

}


VOID WINAPI
DestroyOverStructPool(
    HANDLE      PoolHandle
    )

{

    return;

}



PUM_OVER_STRUCT WINAPI
AllocateOverStructEx(
    HANDLE      PoolHandle,
    DWORD       dwExtraBytes
    )

{
    PUM_OVER_STRUCT UmOverlapped;

    UmOverlapped=ALLOCATE_MEMORY(sizeof(UM_OVER_STRUCT)+dwExtraBytes);

    if (UmOverlapped != NULL) {

        UmOverlapped->OverlappedPool=PoolHandle;
    }

    return UmOverlapped;

}


VOID WINAPI
FreeOverStruct(
    PUM_OVER_STRUCT UmOverlapped
    )

{
#if DBG
    FillMemory(UmOverlapped,sizeof(UM_OVER_STRUCT),0x99);
#endif
    FREE_MEMORY(UmOverlapped);

    return;

}


VOID WINAPI
ReinitOverStruct(
    PUM_OVER_STRUCT UmOverlapped
    )

{

    HANDLE    PoolHandle=UmOverlapped->OverlappedPool;

    ZeroMemory(
        UmOverlapped,
        sizeof(UM_OVER_STRUCT)
        );

    UmOverlapped->OverlappedPool=PoolHandle;

    return;

}






LONG WINAPI
SyncDeviceIoControl(
    HANDLE    FileHandle,
    DWORD     IoctlCode,
    LPVOID    InputBuffer,
    DWORD     InputBufferLength,
    LPVOID    OutputBuffer,
    DWORD     OutputBufferLength,
    LPDWORD   BytesTransfered
    )


/*++

Routine Description:


Arguments:


Return Value:



--*/

{
    BOOL        bResult;
    LONG        lResult=ERROR_SUCCESS;
    OVERLAPPED  Overlapped;

    Overlapped.hEvent=CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL
        );

    if (Overlapped.hEvent == NULL) {

        return GetLastError();
    }

    bResult=DeviceIoControl(
        FileHandle,
        IoctlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength,
        NULL,
        &Overlapped
        );


    if (!bResult && GetLastError() != ERROR_IO_PENDING) {

        CloseHandle(Overlapped.hEvent);

        return GetLastError();
    }

    bResult=GetOverlappedResult(
        FileHandle,
        &Overlapped,
        BytesTransfered,
        TRUE
        );

    if (!bResult) {

        lResult=GetLastError();
    }

    CloseHandle(Overlapped.hEvent);

    return lResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\uniplat\system.c ===
#include "internal.h"

#define MY_BUFSIZE 32 // arbitrary. Use dynamic allocation

BOOL WINAPI WinntIsWorkstation ()
{
 HKEY hKey;
 TCHAR szProductType[MY_BUFSIZE];
 DWORD dwBufLen=MY_BUFSIZE;
 LONG bRet = FALSE;

    if (ERROR_SUCCESS ==
        RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
                       0,
                       KEY_QUERY_VALUE,
                       &hKey))
    {
        if (ERROR_SUCCESS ==
            RegQueryValueEx (hKey,
                             TEXT("ProductType"),
                             NULL,
                             NULL,
                             (LPBYTE)szProductType,
                             &dwBufLen))
        {
            if (CompareString(LOCALE_INVARIANT,NORM_IGNORECASE,szProductType,-1,TEXT("WINNT"),-1) == 2)
            {
                bRet = TRUE;
            }
        }
        RegCloseKey(hKey);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\uniplat\slot.c ===
//****************************************************************************
//
//  Module:     UNIMDM
//  File:       SLOT.C
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//  3/25/96     JosephJ             Created
//
//
//  Description: Implements the unimodem TSP notification mechanism:
//				 The lower level (notifXXXX) APIs
//
//****************************************************************************

#include "internal.h"

#include <slot.h>
#include <tspnotif.h>
#include <aclapi.h>
#include <objbase.h>

#define T(_str) TEXT(_str)

#ifdef CONSOLE
#define ASSERT(_c) \
	((_c) ? 0: DPRINTF2("Assertion failed in %s:%d\n", __FILE__, __LINE__))
#define DPRINTF(_fmt) 					printf(_fmt)
#define DPRINTF1(_fmt,_arg) 			printf(_fmt,_arg)
#define DPRINTF2(_fmt,_arg,_arg2) 		printf(_fmt,_arg,_arg2)
#define DPRINTF3(_fmt,_arg,_arg2,_arg3) printf(_fmt,_arg,_arg2,_arg3)
#endif // CONSOLE

#define fNOTIF_STATE_DEINIT 0
#define fNOTIF_STATE_INIT_SERVER 1
#define fNOTIF_STATE_INIT_CLIENT 2

#define IS_SERVER(_pnc) ((_pnc)->dwState==fNOTIF_STATE_INIT_SERVER)
#define IS_CLIENT(_pnc) ((_pnc)->dwState==fNOTIF_STATE_INIT_CLIENT)


// {9426020A-6D00-4a96-872D-EFBEEBFD7833}
static const GUID EventNamePrefix =
    { 0x9426020a, 0x6d00, 0x4a96, { 0x87, 0x2d, 0xef, 0xbe, 0xeb, 0xfd, 0x78, 0x33 } };

const  WCHAR   *EventNamePrefixString=L"{9426020A-6D00-4a96-872D-EFBEEBFD7833}";


// The following help define the fully-qualified mailslot and semaphore names.
#define dwNOTIFSTATE_SIG (0x53CB31A0L)
#define FULLNAME_TEMPLATE	T("\\\\.\\mailslot\\%08lx\\%s")

// #define NOTIFICATION_TIMEOUT    10000   // 10 sesonds
#define NOTIFICATION_TIMEOUT    60000   // 60 sesonds

// Keeps the state of a notification (either client or server).
// It is cast to a DWORD to form the handle returned by notifCreate()
typedef struct
{
	DWORD dwSig; // should be dwNOTIFSTATE_SIG when inited
    HANDLE hEvent;

	HANDLE hSlot;
	DWORD dwState;
	DWORD dwcbMax;
    CRITICAL_SECTION critSect;  // to protect pNotif
} NOTIFICATION_CHANNEL, *PNOTIFICATION_CHANNEL;


#define fTSPNOTIF_FLAGS_SET_EVENT  (1 << 0)

#pragma warning (disable : 4200)
typedef struct
{
	DWORD  dwSig;       // MUST be dwNFRAME_SIG
	DWORD  dwSize;      // Entire size of this structure
	DWORD  dwType;      // One of the TSPNOTIF_TYPE_ constants
	DWORD  dwFlags;     // Zero or more  fTSPNOTIF_FLAGS_ constants

                        // Event set by the TSP to let us know it's
                        //   done processing our notification
    GUID   EventName;
    BOOL   SignalEvent;

    PNOTIFICATION_CHANNEL  NotificationChannel;

    BYTE   notifData[];
} NOTIFICATION_HEADDER, *PNOTIFICATION_HEADDER;
#pragma warning (default : 4200)

HANDLE
CreateEventWithSecurity(
    LPTSTR                     EventName,
    PSID_IDENTIFIER_AUTHORITY  Sid,
    BYTE                       Rid,
    DWORD                      AccessRights
    );


PNOTIFICATION_CHANNEL inotif_getchannel (HNOTIFCHANNEL hc);

//****************************************************************************
// Function: Creates a notification channel -- called by the server.
//
// History:
//  3/25/98	EmanP   Created
//****************************************************************************/
HNOTIFCHANNEL notifCreateChannel (
	LPCTSTR lptszName,          // Name to associate with this object
	DWORD dwMaxSize,            // Max size of frames written/read
	DWORD dwMaxPending)         // Max number of notification frames allowed
                                // to be pending.
{
 PNOTIFICATION_CHANNEL pnc = NULL;
 HNOTIFCHANNEL hn = 0;
 DWORD dwErr = 0;
 TCHAR c, *pc;
 TCHAR rgtchTmp[MAX_NOTIFICATION_NAME_SIZE+23];
 SECURITY_ATTRIBUTES  sa;
 PSECURITY_DESCRIPTOR pSD = NULL;
 PSID pEveryoneSID = NULL;
 PACL pACL = NULL;
 EXPLICIT_ACCESS ea;
 SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;

	// Format of semaphore name is --.-mailslot-sig-name
	// Example: "--.-mailslot-8cb45651-unimodem"
	// To create the equivalent mailslot, we run through and change
	// all '-' to '\'s (if the name containts '-', they will get converted --
	// big deal.)
	if ((lstrlen(lptszName)+23)>(sizeof(rgtchTmp)/sizeof(TCHAR))) // 13(prefix)+ 9(sig-) +1(null)
	{
		dwErr = ERROR_INVALID_PARAMETER;
		goto end;
	}

	pnc = ALLOCATE_MEMORY( sizeof(*pnc));
	if (!pnc)
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto end;
    }

    // Create security descriptor and 
    // initialize the security attributes;
    // this is neeeded because this code runs in
    // a service (tapisrv), and other processes will
    // not have access (by default).

	pSD = ALLOCATE_MEMORY( SECURITY_DESCRIPTOR_MIN_LENGTH);

	if (!pSD ||
        !InitializeSecurityDescriptor (pSD, SECURITY_DESCRIPTOR_REVISION))
    {
		dwErr = GetLastError();
        goto end;
    }

	// Set owner for the descriptor
	//
	if (!SetSecurityDescriptorOwner (pSD, NULL, FALSE))
	{
		dwErr = GetLastError();
		goto end;
	}

	// Set group for the descriptor
	//
	if (!SetSecurityDescriptorGroup (pSD, NULL, FALSE))
	{
		dwErr = GetLastError();
		goto end;
	}

	// Create a well-known SID for the Everyone group
	//
	if (!AllocateAndInitializeSid( &SIDAuthWorld, 1,
					SECURITY_WORLD_RID,
					0, 0, 0, 0, 0, 0, 0,
					&pEveryoneSID) )
	{
		dwErr = GetLastError();
		goto end;
	}

	// Initialize an EXPLICIT_ACCESS structure for an ACE
	//
	ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
	ea.grfAccessPermissions = SPECIFIC_RIGHTS_ALL | SYNCHRONIZE | READ_CONTROL;
	ea.grfAccessMode = SET_ACCESS;
	ea.grfInheritance = NO_INHERITANCE;
	ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
	ea.Trustee.ptstrName = (LPTSTR) pEveryoneSID;

	if (SetEntriesInAcl(1, &ea, NULL, &pACL) != ERROR_SUCCESS)
	{
		dwErr = GetLastError();
		goto end;
	}

	if (!SetSecurityDescriptorDacl (pSD, TRUE, pACL, FALSE))
	{
		dwErr = GetLastError();
		goto end;
	}

    sa.nLength = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = TRUE;


	wsprintf (rgtchTmp,
              FULLNAME_TEMPLATE,
			  (unsigned long) dwNOTIFSTATE_SIG,
			  lptszName);

	// CreateMailSlot  -- specify size, zero-delay
	pnc->hSlot = CreateMailslot (rgtchTmp, dwMaxSize, 0, &sa);
	if (!pnc->hSlot)
	{
		dwErr = GetLastError();
		goto end;
	}

	// Create event name
	for (pc = rgtchTmp; c=*pc; pc++)
    {
        if (T('\\') == c)
        {
            *pc = T('-');
        }
    }

	// Create event
	pnc->hEvent = CreateEvent (&sa, FALSE, FALSE, rgtchTmp);
	if (!pnc->hEvent)
    {
        dwErr = GetLastError ();
		CloseHandle (pnc->hSlot);
        pnc->hSlot = NULL;
        goto end;
    }

	// set state and maxsize
	pnc->dwState    = fNOTIF_STATE_INIT_SERVER;
	pnc->dwcbMax    = dwMaxSize;
	pnc->dwSig      = dwNOTIFSTATE_SIG;

	hn = (HNOTIFCHANNEL)pnc;

end:
	if (pEveryoneSID)
	{
		FreeSid(pEveryoneSID);
	}
	if (pACL)
	{
		LocalFree(pACL);
	}
	if (pSD) 
    {
        FREE_MEMORY(pSD);
    }

	if (0 == hn)
	{
		if (pnc)
        {
            FREE_MEMORY(pnc);
        }
		SetLastError(dwErr);
	}

	return hn;
}


//****************************************************************************
// Function: Openes a notification channel -- called by the client.
//
// History:
//  3/25/98	EmanP   Created
//****************************************************************************/
HNOTIFCHANNEL notifOpenChannel (
	LPCTSTR lptszName)   // Name to associate with this object
{
 PNOTIFICATION_CHANNEL pnc = NULL;
 HNOTIFCHANNEL hn = 0;
 DWORD dwErr = 0;
 TCHAR c, *pc;
 TCHAR rgtchTmp[MAX_NOTIFICATION_NAME_SIZE+23];

	// Format of semaphore name is --.-mailslot-sig-name
	// Example: "--.-mailslot-8cb45651-unimodem"
	// To create the equivalent mailslot, we run through and change
	// all '-' to '\'s (if the name containts '-', they will get converted --
	// big deal.)
	if ((lstrlen(lptszName)+23)>(sizeof(rgtchTmp)/sizeof(TCHAR))) // 13(prefix)+ 9(sig-) +1(null)
	{
		dwErr = ERROR_INVALID_PARAMETER;
		goto end;
	}

	pnc = ALLOCATE_MEMORY( sizeof(*pnc));
	if (!pnc)
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto end;
    }

	wsprintf (rgtchTmp,
              FULLNAME_TEMPLATE,
			  (unsigned long) dwNOTIFSTATE_SIG,
			  lptszName);

	// Open mailslot ...
	pnc->hSlot = CreateFile (rgtchTmp,
                             GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

	if (INVALID_HANDLE_VALUE == pnc->hSlot)
	{
        dwErr = GetLastError ();
		goto end;
	}

	// Create event name -- convert '\' to '-';
	for (pc = rgtchTmp; c=*pc; pc++)
    {
        if (T('\\') == c)
        {
            *pc = T('-');
        }
    }

	// OpenEvent
    pnc->hEvent = OpenEvent (EVENT_MODIFY_STATE, FALSE, rgtchTmp);
	if (!pnc->hEvent)
    {
		dwErr=GetLastError();
		CloseHandle (pnc->hSlot);
        pnc->hSlot = NULL;
 		goto end;
	}

	// set state and maxsize
	pnc->dwState    = fNOTIF_STATE_INIT_CLIENT;
	pnc->dwcbMax    = 0; // Apparently you can't get the max size of the mailslot.
	pnc->dwSig      = dwNOTIFSTATE_SIG;

	hn = (HNOTIFCHANNEL)pnc;

end:
	if (!hn)
	{
		if (pnc)
        {
            FREE_MEMORY(pnc);
        }
		SetLastError(dwErr);
	}

	return hn;
}


#ifdef UNICODE
HNOTIFCHANNEL notifCreateChannelA (
    LPCSTR lpszName,			// Name to associate with this object
    DWORD dwMaxSize,			// Max size of frames written/read
    DWORD dwMaxPending)         // Max number of notification frames allowed
                                // to be pending.  (Ignored if (!fServer))
{
 WCHAR wszName[128];

  // Do the conversion and call modemui.dll if it succeeds.
  if (MultiByteToWideChar (CP_ACP,
                           MB_PRECOMPOSED,
                           lpszName,
                           -1,
                           wszName,
                           sizeof(wszName)/sizeof(*wszName)))
  {
    return notifCreateChannelW (wszName,
                                dwMaxSize,
                                dwMaxPending);
  }
  else
  {
    return 0;
  }
}

HNOTIFCHANNEL notifOpenChannelA (
    LPCSTR lpszName)        // Name to associate with this object
{
 WCHAR wszName[128];

  // Do the conversion and call modemui.dll if it succeeds.
  if (MultiByteToWideChar (CP_ACP,
                           MB_PRECOMPOSED,
                           lpszName,
                           -1,
                           wszName,
                           sizeof(wszName)/sizeof(*wszName)))
  {
    return notifOpenChannelW (wszName);
  }
  else
  {
    return 0;
  }
}

#undef notifCreateChannel
#undef notifOpenChannel

HNOTIFCHANNEL notifCreateChannel (
	LPCTSTR lptszName,			// Name to associate with this object
	DWORD dwMaxSize,			// Max size of frames written/read
	DWORD dwMaxPending)         // Max number of notification frames allowed
                                // to be pending.  (Ignored if (!fServer))
{
    return notifCreateChannelW (lptszName,
                                dwMaxSize,
                                dwMaxPending);
}

HNOTIFCHANNEL notifOpenChannel (
	LPCTSTR lptszName)      // Name to associate with this object
{
    return notifOpenChannelW (lptszName);
}

#else // !UNICODE
    #error "non-Unicoded version Unimplemented"
#endif // !UNICODE

//****************************************************************************
// Function: Closes a notification channel
//
// History:
//  3/25/98 EmanP   Created
//****************************************************************************/
void notifCloseChannel (HNOTIFCHANNEL hChannel)
{
 PNOTIFICATION_CHANNEL pnc = inotif_getchannel (hChannel);

	if (pnc)
	{
        CloseHandle (pnc->hEvent);
		CloseHandle (pnc->hSlot);
		FREE_MEMORY(pnc);
	}
}


//****************************************************************************
// Function: Creates a new notification frame
//
// History:
//  3/25/98 EmanP   Created
//****************************************************************************/
HNOTIFFRAME
notifGetNewFrame (
    HNOTIFCHANNEL hChannel,         // Handle to notification channel
    DWORD  dwNotificationType,      // Type of this notification
    DWORD  dwNotificationFlags,     // Notification flags
    DWORD  dwBufferSize,            // How many bytes for the notification data
    PVOID *ppFrameBuffer)           // where to put the address of the data
{
    PNOTIFICATION_CHANNEL pnc;
    PNOTIFICATION_HEADDER pNotif;

    *ppFrameBuffer = NULL;

    pnc = inotif_getchannel (hChannel);

    if (NULL == pnc) {

        SetLastError (ERROR_INVALID_HANDLE);
        return NULL;
    }


    dwBufferSize += sizeof(NOTIFICATION_HEADDER);
    pNotif = ALLOCATE_MEMORY( dwBufferSize);
    if (NULL == pNotif) {

        SetLastError (ERROR_OUTOFMEMORY);
        return NULL;
    }

    pNotif->SignalEvent = FALSE;
    pNotif->dwSig       = dwNFRAME_SIG;
    pNotif->dwSize      = dwBufferSize;
    pNotif->dwType      = dwNotificationType;
    pNotif->dwFlags     = dwNotificationFlags;
    pNotif->NotificationChannel=pnc;

    if (sizeof(NOTIFICATION_HEADDER) < dwBufferSize) {

        *ppFrameBuffer = (PVOID)&pNotif->notifData;
    }

    return pNotif;
}



//****************************************************************************
// Function: Sends a notification frame.
//
// History:
//  3/25/98 EmanP   Created
//****************************************************************************/
BOOL
notifSendFrame (
    HNOTIFFRAME             hFrame,
    BOOL          bBlocking
    )
{
    PNOTIFICATION_HEADDER   pNotif=hFrame;
    PNOTIFICATION_CHANNEL pnc=pNotif->NotificationChannel;
    HANDLE hEvent = NULL;
    DWORD dwWritten, dwErr;
    BOOL bRet;


    if (bBlocking) {

        TCHAR    EventName[MAX_PATH];

        lstrcpy(EventName,EventNamePrefixString);
        lstrcat(EventName,TEXT("#"));

        CoCreateGuid(
            &pNotif->EventName
            );

        StringFromGUID2(
            &pNotif->EventName,
            &EventName[lstrlen(EventName)],
            MAX_PATH-(lstrlen(EventName)+1)
            );


        hEvent = CreateEvent(NULL, TRUE, FALSE, EventName);

        if (NULL == hEvent ) {

            FREE_MEMORY(pNotif);

            return FALSE;
        }

        pNotif->SignalEvent=TRUE;

    }

    bRet = WriteFile (pnc->hSlot,
                      pNotif,
                      pNotif->dwSize,
                      &dwWritten,
                      NULL);
    dwErr = GetLastError ();    // save it in case we failed

    FREE_MEMORY(pNotif);

    if (bRet)
    {
        bRet = SetEvent (pnc->hEvent);
        if (bRet && bBlocking)

        {
#ifdef DBG
            if (WaitForSingleObject (hEvent, NOTIFICATION_TIMEOUT) == WAIT_TIMEOUT)
            {
                DbgPrint("UNIPLAT: Timeout in uniplat!SendFrame(hEvent, NOTIFICATION_TIMEOUT)\n");
            }
#endif

        }
    }
    else
    {
        // restore the last error here
        SetLastError (dwErr);
    }

    if (NULL != hEvent)
    {
        CloseHandle (hEvent);
    }

    return bRet;
}



//****************************************************************************
// Function: monitors the channel in alertable mode.
//
// History:
//  3/25/96 EmanP   Created
//****************************************************************************/

#define MAX_FAILED_NOTIFICATIONS 5

DWORD notifMonitorChannel (
    HNOTIFCHANNEL hChannel,
    PNOTIFICATION_HANDLER pHandler,
    DWORD dwSize,
    PVOID pParam)
{
 PNOTIFICATION_CHANNEL pnc;
 DWORD dwMessageSize, dwRead, dwRet = NO_ERROR, dwFail = 0;
 BOOL bGoOn = TRUE;
 PNOTIFICATION_HEADDER pNotif;

    pnc = inotif_getchannel (hChannel);
    if (NULL == pnc)
    {
        return  ERROR_INVALID_HANDLE;
    }

    while (bGoOn &&
           MAX_FAILED_NOTIFICATIONS > dwFail)
    {
        // Let's put the thread in an alertable state,
        // while waiting for notifications.
        if (WAIT_OBJECT_0 == WaitForSingleObjectEx (pnc->hEvent, INFINITE, TRUE))
        {
            dwFail++;
            // we have some mail slot messages;
            // try to get and proces them.
            while (bGoOn)
            {
                // first, try to get info about the message(s).
                if (!GetMailslotInfo (pnc->hSlot, NULL, &dwMessageSize, NULL, NULL))
                {
                    // Could not get the mailslot info;
                    // get out or the inner loop.
                    break;
                }
                if (MAILSLOT_NO_MESSAGE == dwMessageSize)
                {
                    // We're done retrieving messages;
                    // get out.
                    break;
                }

                // let's allocate memory for the notification
                pNotif = ALLOCATE_MEMORY( dwMessageSize);
                if (NULL == pNotif)
                {
                    // couldn't allocate memory to read the message;
                    // get out, and maybe next time we'll be more lucky.
                    break;
                }

                // now let's read the notification
                // and validate it
                if (!ReadFile (pnc->hSlot, pNotif, dwMessageSize, &dwRead, NULL))
                {
                    // some error reading the mailslot;
                    // get out, and mayble next time we'll be more lucky
                    break;
                }

                dwFail = 0;         // Successful read, so reinitialize
                                    // the failure counter

                if (dwMessageSize == dwRead &&
                    dwNFRAME_SIG  == pNotif->dwSig &&
                    dwMessageSize == pNotif->dwSize)
                {
                    // we have a valid notification;
                    // time to inform our client.
                    bGoOn = pHandler (pNotif->dwType,
                                      pNotif->dwFlags,
                                      pNotif->dwSize - sizeof (NOTIFICATION_HEADDER),
                                      pNotif->notifData);

                    // now, let's check if someone isn't
                    // waiting for us to finish.
                    // if (pNotif->dwFlags & fTSPNOTIF_FLAGS_SET_EVENT)
                    if (pNotif->SignalEvent)
                    {
                        WCHAR    EventName[MAX_PATH];

                        HANDLE hProcess, hEvent;

                        lstrcpy(EventName,EventNamePrefixString);
                        lstrcat(EventName,TEXT("#"));

                        StringFromGUID2(
                            &pNotif->EventName,
                            &EventName[lstrlen(EventName)],
                            MAX_PATH-(lstrlen(EventName)+1)
                            );

                        hEvent=OpenEvent(
                            EVENT_MODIFY_STATE,
                            FALSE,
                            EventName
                            );

                        if (hEvent != NULL) {

                            SetEvent(hEvent);

                            CloseHandle(hEvent);
                        }
                    }
                }

                // At this point, we're done with
                // the notification - free it.
                FREE_MEMORY(pNotif);
                pNotif = NULL;

                // Now, let's give APC's a chance
                //
                if (WAIT_IO_COMPLETION == SleepEx (0, TRUE)) {
                    //
                    //  an apc completed, call the handler
                    //
                    // we returned because of some APC that
                    // was queued for this thread.
                    bGoOn = pHandler (TSPNOTIF_TYPE_CHANNEL,
                                      fTSPNOTIF_FLAG_CHANNEL_APC,
                                      dwSize,
                                      pParam);

                }
            }
        }
        else
        {
            // we returned because of some APC that
            // was queued for this thread.
            bGoOn = pHandler (TSPNOTIF_TYPE_CHANNEL,
                              fTSPNOTIF_FLAG_CHANNEL_APC,
                              dwSize,
                              pParam);
        }
    }

    if (MAX_FAILED_NOTIFICATIONS == dwFail)
    {
        dwRet = ERROR_GEN_FAILURE;
    }

    return dwRet;
}



//****************************************************************************
// Function: (internal) validates and converts a handle to a ptr to channel.
//
// History:
//  3/25/96	JosephJ	Created
//****************************************************************************/
PNOTIFICATION_CHANNEL inotif_getchannel (HNOTIFCHANNEL hc)
{
	if (hc)
	{
	 PNOTIFICATION_CHANNEL pnc = (PNOTIFICATION_CHANNEL)hc;
		if (dwNOTIFSTATE_SIG != pnc->dwSig)
		{
			ASSERT(FALSE);
			return NULL;
		}
		return pnc;
	}
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\uniplat\timer.c ===
//****************************************************************************
//
//  Module:     Unimdm
//  File:       timer.c
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//
//
//  Description:
//
//****************************************************************************

#include "internal.h"

#define USE_APC 1

//#include "timer.h"

typedef struct _UNIMODEM_TIMER {

    TIMER_CALLBACK           *CallbackProc;
    HANDLE                    Context1;
    HANDLE                    Context2;

    HANDLE                    TimerHandle;

} UNIMODEM_TIMER, *PUNIMODEM_TIMER;




VOID WINAPI
TimerApcRoutine(
    PUNIMODEM_TIMER    ThisTimer,
    DWORD              LowTime,
    DWORD              HighTime
    );







HANDLE WINAPI
CreateUnimodemTimer(
    PVOID        PoolHandle
    )

{

    PUNIMODEM_TIMER  TimerObject;

    TimerObject=ALLOCATE_MEMORY(sizeof(UNIMODEM_TIMER));

    if (TimerObject == NULL) {

        return NULL;
    }

    TimerObject->TimerHandle=CreateWaitableTimer(
        NULL,
        TRUE,
        NULL
        );

    if (TimerObject->TimerHandle == NULL) {

       FREE_MEMORY(TimerObject);

       return NULL;
    }


    TimerObject->CallbackProc=NULL;
    TimerObject->Context1=NULL;
    TimerObject->Context2=NULL;


    return (HANDLE)TimerObject;

}

VOID WINAPI
FreeUnimodemTimer(
    HANDLE                TimerHandle
    )

{
    PUNIMODEM_TIMER   TimerObject=(PUNIMODEM_TIMER) TimerHandle;

    ASSERT(TimerObject->CallbackProc == NULL);

    CloseHandle(TimerObject->TimerHandle);

    FREE_MEMORY(TimerObject);

    return;
}


VOID WINAPI
TimerApcRoutine(
    PUNIMODEM_TIMER    TimerObject,
    DWORD              LowTime,
    DWORD              HighTime
    )

{
    TIMER_CALLBACK      *CallbackProc;
    HANDLE              Context1;
    HANDLE              Context2;

    CallbackProc=TimerObject->CallbackProc;
    Context1=TimerObject->Context1;
    Context2=TimerObject->Context2;

    TimerObject->CallbackProc=NULL;


//    D_TRACE(McxDpf(888,"TimerThreadProc: Timer expired %08lx, time=%d",TimerObject,GetTickCount());)

    (*CallbackProc)(
        Context1,
        Context2
        );

    return;

}


VOID WINAPI
SetUnimodemTimer(
    HANDLE              TimerHandle,
    DWORD               Duration,
    TIMER_CALLBACK      CallbackFunc,
    HANDLE              Context1,
    HANDLE              Context2
    )

{

    PUNIMODEM_TIMER  TimerObject=(PUNIMODEM_TIMER) TimerHandle;

    LONGLONG       DueTime=Int32x32To64(Duration,-10000);

//    D_TRACE(McxDpf(888,"SetUnimodemTimer: %08lx, time=%d, %d",TimerHandle,GetTickCount(),Duration);)

    ASSERT(TimerObject->CallbackProc == NULL);

    TimerObject->CallbackProc=CallbackFunc;
    TimerObject->Context1=Context1;
    TimerObject->Context2=Context2;


    SetWaitableTimer(
        TimerObject->TimerHandle,
        (LARGE_INTEGER*)&DueTime,
        0,
        TimerApcRoutine,
        TimerObject,
        FALSE
        );

    return;

}


BOOL WINAPI
CancelUnimodemTimer(
    HANDLE                TimerHandle
    )

{

    PUNIMODEM_TIMER   TimerObject=(PUNIMODEM_TIMER) TimerHandle;

#if DBG
    TimerObject->CallbackProc=NULL;
#endif

    CancelWaitableTimer(
        TimerObject->TimerHandle
        );

    return TRUE;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\w95migr\common.h ===
#include <windows.h>
#include <regstr.h>
#include <objbase.h>
#include <cfgmgr32.h>
#include <setupapi.h>

#include <string.h>
#include <wtypes.h>
#include <malloc.h>

#include <bustype.h>

#include "log.h"

#define MAX_CLASS_NAME_LEN   32
#define MAX_PORTS 64
#define MAX_PORT_NAME_LENGTH 256

extern LPGUID g_pguidModem;
extern HINSTANCE g_hDll;

typedef struct
{
    CHAR szPortname[MAX_PORT_NAME_LENGTH];
    DWORD dwBaseAddress;
} Ports_t;

typedef struct
{
    DWORD dwPortCount;
    Ports_t PortAddress[MAX_PORTS];
} Ports;

VOID EnumeratePorts(Ports *p);
int port_findname(Ports *p, DWORD dwBaseAddress, CHAR *name);
int port_findaddress(Ports *p, DWORD *dwBaseAddress, CHAR *name);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\w95migr\dllmain.c ===
#define WIN9x
#include <common.h>
#include <initguid.h>

DEFINE_GUID(GUID_DEVCLASS_MODEM,
 0x4d36e96dL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );

LPGUID g_pguidModem     = (LPGUID)&GUID_DEVCLASS_MODEM;
HINSTANCE g_hDll = NULL;

BOOL
APIENTRY
DllMain(
	HINSTANCE hDll,
	DWORD dwReason,
	LPVOID lpReserved
	)
{
    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hDll);
            g_hDll = hDll;
            break;

        case DLL_PROCESS_DETACH:

            CLOSE_LOG

            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\uniplat\tspnotif.c ===
//****************************************************************************
//
//  Module:     UNIMDM
//  File:       TSPNOTIF.C
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//  6/03/97     JosephJ             Created (extracted from ..\..\cpl\util.c)
//
//
//  Description: Implements UnimodemNotifyTSP
//
//****************************************************************************

#include "internal.h"
#include <slot.h>
#include <tspnotif.h>

// Functions: Notify the TSP -- general version.
//
// Return:    TRUE if successful
//            FALSE if failure (including if the tsp is not active)
//            GetLastError() returns the win32 failure code.
//  History:
//            3/24/96 JosephJ Created (copied from ..\new\slot\client.c)
//****************************************************************************

BOOL WINAPI UnimodemNotifyTSP (
    DWORD dwType,
    DWORD dwFlags,
    DWORD dwSize,
    PVOID pData,
    BOOL  bBlocking)
{
    BOOL fRet=FALSE;
    HNOTIFCHANNEL hChannel;
    PVOID pTemp;
    HNOTIFFRAME   hFrame;

    hChannel = notifOpenChannel (SLOTNAME_UNIMODEM_NOTIFY_TSP);

    if (hChannel)
    {
        hFrame = notifGetNewFrame (hChannel, dwType, dwFlags, dwSize, &pTemp);

        if (hFrame != NULL) {

            if ((NULL != pData) && (0 != dwSize)) {

                CopyMemory (pTemp, pData, dwSize);
            }

            fRet = notifSendFrame (hFrame, bBlocking);
        }

        notifCloseChannel (hChannel);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\w95migr\commport.c ===
#include "common.h"

GUID    SerialGuid = {0x4d36e978, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b,
    0xe1, 0x03, 0x18};

VOID
EnumeratePorts(Ports *p)
{
    HDEVINFO            hDevInfoSet;
    INT                 DevCount;
    SP_DEVINFO_DATA     DevInfoData;
    CONFIGRET           CmReturnCode, CmReturnCode2;
    LONG                RegReturnCode;
    LOG_CONF            LogConf;

    hDevInfoSet = INVALID_HANDLE_VALUE;
    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    p->dwPortCount = 0;

    do
    {
        //  Get a handle to the device information set for the port class

        hDevInfoSet = SetupDiGetClassDevs(&SerialGuid, NULL, NULL, DIGCF_PRESENT| DIGCF_PROFILE);

        if (hDevInfoSet == INVALID_HANDLE_VALUE)
        {
            LOG("modemigr: SetDiGetClassDevs failed: %x\n", GetLastError());
            break;
        }

        //  Run through each device in this class.

        for (DevCount = 0; /* NOTHING */; DevCount++)
        {
            LOG_CONF logConfig;
            RES_DES resDes;
            CONFIGRET cr;
            IO_RESOURCE ioResource;
            BOOL success;
            DWORD dwBase;
            HKEY hDeviceReg;
            DWORD dwPortNameSize;
            LONG lResult;

            if (!SetupDiEnumDeviceInfo(hDevInfoSet, DevCount, &DevInfoData))
            {
                //  No more devices.
                break;
            }

            hDeviceReg = SetupDiOpenDevRegKey(hDevInfoSet,
                    &DevInfoData,
                    DICS_FLAG_GLOBAL,
                    0,
                    DIREG_DEV,
                    KEY_ALL_ACCESS);

            if (hDeviceReg != INVALID_HANDLE_VALUE)
            {

                if (CM_Get_First_Log_Conf(&logConfig,DevInfoData.DevInst,
                            BOOT_LOG_CONF) == CR_SUCCESS)
                {
                    if (CM_Get_Next_Res_Des(&resDes,logConfig,ResType_IO,
                                NULL,0) == CR_SUCCESS)
                    {
                        cr = CM_Get_Res_Des_Data(resDes,&ioResource,
                                sizeof(IO_RESOURCE),0);

                        CM_Free_Res_Des_Handle(resDes);

                        if (cr == CR_SUCCESS)
                        {
                            dwPortNameSize = MAX_PORT_NAME_LENGTH;

                            lResult = RegQueryValueEx(hDeviceReg,
                                    TEXT("Portname"),
                                    0,
                                    0,
                                    p->PortAddress[p->dwPortCount].szPortname,
                                    &dwPortNameSize);

                            if (lResult == ERROR_SUCCESS)
                            {
                                p->PortAddress[p->dwPortCount].dwBaseAddress = (DWORD)ioResource.IO_Header.IOD_Alloc_Base;
                                (p->dwPortCount)++;
                            }
                        }
                    }
                }

                RegCloseKey(hDeviceReg);
            }


        } // for (DevCount...)

        break;

    }
    while (FALSE);

    if (hDevInfoSet != INVALID_HANDLE_VALUE)
    {
        if (!SetupDiDestroyDeviceInfoList(hDevInfoSet))
        {
            LOG("modemmigr: SetupDiDestroyDeviceInfoList failed: %x\n",
                        GetLastError());
        }
    }
}


// Find com port name given an address

int port_findname(Ports *p, DWORD dwBaseAddress, CHAR *name)
{
    DWORD i;

    name[0] = '\0';

    for(i=0;i<p->dwPortCount;i++)
    {
        if (p->PortAddress[i].dwBaseAddress
                == dwBaseAddress)
        {
            strcpy(name,p->PortAddress[i].szPortname);
            return 1;
        }
    }

    return 0;
}


// Find com port address given a name

int port_findaddress(Ports *p, DWORD *dwBaseAddress, CHAR *name)
{
    DWORD i;

    *dwBaseAddress = 0;

    for(i=0;i<p->dwPortCount;i++)
    {
        if (!strcmp(name,p->PortAddress[i].szPortname))
        {
            *dwBaseAddress = p->PortAddress[i].dwBaseAddress;
            return 1;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\w95migr\makefile.inc ===
$(O)\msg.mc: $(BASE_INC_PATH)\vendinfo.mc
    copy $** $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\w95migr\log.c ===
#include "common.h"

#ifdef DO_LOG

HANDLE g_hLogFile = INVALID_HANDLE_VALUE;
WCHAR g_szLogFileName[16];
WCHAR szBuffer[1024];
WCHAR g_szLogFileFullName[MAX_PATH];
BOOL bUnicode;

void StartLogA (LPCSTR szPath)
{
    bUnicode = FALSE;

    lstrcpyA ((LPSTR)g_szLogFileName, "\\Log9x.txt");
    lstrcpyA ((LPSTR)g_szLogFileFullName, szPath);
    lstrcatA ((LPSTR)g_szLogFileFullName, (LPSTR)g_szLogFileName);

    g_hLogFile = CreateFileA ((LPSTR)g_szLogFileFullName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        SetFilePointer (g_hLogFile, 0, NULL, FILE_END);
    }
}


void StartLogW (LPCWSTR szPath)
{
    bUnicode = TRUE;

    lstrcpyW (g_szLogFileName, L"\\LogNT.txt");
    lstrcpyW (g_szLogFileFullName, szPath);
    lstrcatW (g_szLogFileFullName, g_szLogFileName);

    g_hLogFile = CreateFileW (g_szLogFileFullName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        SetFilePointer (g_hLogFile, 0, NULL, FILE_END);
    }
}


void logA (LPSTR Format, ...)
{
 va_list arglist;
 DWORD dwWritten;

    va_start(arglist, Format);
    dwWritten = wvsprintfA ((LPSTR)szBuffer, Format, arglist);
    WriteFile (g_hLogFile, szBuffer, dwWritten, &dwWritten, NULL);
#ifdef DEBUG
    OutputDebugStringA ((LPSTR)szBuffer);
#endif //DEBUG
}



void logW (LPWSTR Format, ...)
{
 va_list arglist;
 DWORD dwWritten;

    va_start(arglist, Format);
    dwWritten = sizeof(WCHAR) * wvsprintfW (szBuffer, Format, arglist);
    WriteFile (g_hLogFile, szBuffer, dwWritten, &dwWritten, NULL);
#ifdef DEBUG
    OutputDebugStringW (szBuffer);
#endif //DEBUG
}


void CloseLogA ()
{
 char szDirectory[MAX_PATH];
 int iLength;

    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        CloseHandle (g_hLogFile);

        iLength = GetWindowsDirectoryA (szDirectory, sizeof (szDirectory));
        if (3 > iLength)
        {
            // Most likely there's some error
            // and iLength is 0;
            // the smallest path would be something
            // like  C:\;
            return;
        }
        if (3 < iLength)
        {
            // this means that the path
            // will not end in a \, so
            // let's add it.
            szDirectory[iLength++] = '\\';
        }
        lstrcpyA (szDirectory+iLength, "MDMUPGLG");

        if (CreateDirectory (szDirectory, NULL) ||
            ERROR_ALREADY_EXISTS == GetLastError ())
        {
            iLength += 8;
        }

        lstrcpyA(szDirectory+iLength, (LPSTR)g_szLogFileName);
        CopyFileA ((LPSTR)g_szLogFileFullName, szDirectory, FALSE);
    }
}


void CloseLogW ()
{
 WCHAR szDirectory[MAX_PATH];
 int iLength;

    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        CloseHandle (g_hLogFile);

        iLength = GetWindowsDirectoryW (szDirectory, sizeof (szDirectory) / sizeof(WCHAR));
        if (3 > iLength)
        {
            // Most likely there's some error
            // and iLength is 0;
            // the smallest path would be something
            // like  C:\;
            return;
        }
        if (3 < iLength)
        {
            // this means that the path
            // will not end in a \, so
            // let's add it.
            szDirectory[iLength++] = '\\';
        }
        lstrcpyW (szDirectory+iLength, L"MDMUPGLG");

        if (CreateDirectoryW (szDirectory, NULL) ||
            ERROR_ALREADY_EXISTS == GetLastError ())
        {
            iLength += 8;
        }

        lstrcpyW (szDirectory+iLength, g_szLogFileName);
        CopyFileW (g_szLogFileFullName, szDirectory, FALSE);
    }
}

#endif DO_LOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\w95migr\log.h ===
#if DBG > 0 && !defined(DEBUG)
#define DEBUG
#endif

#ifdef DEBUG
#define DO_LOG
#else
//#undef DO_LOG
#define DO_LOG
#endif //DEBUG

#ifdef DO_LOG
extern HANDLE g_hLogFile;
extern BOOL   bUnicode;

void StartLogA (LPCSTR szPath);
void StartLogW (LPCWSTR szPath);
void logA (LPSTR Format, ...);
void logW (LPWSTR Format, ...);
void CloseLogA ();
void CloseLogW ();

#define DECLARE(a,b) a b
#define SET(a) a =
#define ERR(a,b,c) \
    if (a != b) \
    c


#define CLOSE_LOG          \
    if (FALSE == bUnicode) \
    {                      \
        CloseLogA ();      \
    }                      \
    else                   \
    {                      \
        CloseLogW ();      \
    }


#ifdef WIN9x
#define LOG         logA
#define START_LOG   StartLogA
#define ELSE_LOG(x) \
    else            \
    {               \
        logA x;     \
    }

#else //NT
#define LOG         logA
#define START_LOG   StartLogW
#define ELSE_LOG(x) \
    else            \
    {               \
        logA x;     \
    }

#endif WIN9x

#else  //not DO_LOG
#pragma warning (disable:4002)

#define DECLARE(a,b)
#define SET(a)
#define ERR(a,b,c)
#define ELSE_LOG(x)
#define CLOSE_LOG
#define MSGBEEP(x)
#define MSG(x)
#define LOG()
#define START_LOG
#endif //DO_LOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\w95migr\nt5.c ===
#define UNICODE
#include "common.h"
#include <setupapi.h>
#include <cfgmgr32.h>
#include <unimodem.h>

#include <objbase.h>
#include <initguid.h>
#include <devguid.h>

#include "modem.h"


//#define NUM_DEFAULT_PROVIDERS           (sizeof(ProviderList)/sizeof(ProviderList[0]))

#define DEFAULT_CALL_SETUP_FAIL_TIMEOUT     60          // seconds


WCHAR g_pszWorkingDir[MAX_PATH];

void MigrateTapiProviders (void);
static void ProcessModems (HDEVINFO, PMODEM, DWORD);
void InstallModems (HDEVINFO, PMODEM, DWORD);
void InstallModem (HDEVINFO, PMODEM);
DWORD PassOne (HDEVINFO, PMODEM, DWORD);
DWORD PassTwo (HDEVINFO, PMODEM, DWORD);
DWORD PassThree (HDEVINFO, PMODEM, DWORD);
static void ProcessModem (HDEVINFO, PSP_DEVINFO_DATA, PMODEM);
DWORD GetBusType (HDEVINFO, PSP_DEVINFO_DATA);

Ports g_ntports;

typedef void (*PCOUNTRYRUNONCE)();

LONG
CALLBACK
InitializeNT (
    IN LPCWSTR WorkingDirectory,
    IN LPCWSTR SourceDirectory,
       LPVOID  Reserved)
{
 int iLen;

    START_LOG(WorkingDirectory);
    LOG("InitializeNT\r\n");

    ZeroMemory (g_pszWorkingDir, sizeof(g_pszWorkingDir));
    lstrcpyW (g_pszWorkingDir, WorkingDirectory);
    iLen = lstrlen (g_pszWorkingDir);
    if (L'\\' != g_pszWorkingDir[iLen-1])
    {
        g_pszWorkingDir[iLen] = L'\\';
    }

    return ERROR_SUCCESS;
}



LONG
CALLBACK
MigrateUserNT (
    IN HINF    UnattendInfHandle,
    IN HKEY    UserRegHandle,
    IN LPCWSTR UserName,
       LPVOID  Reserved)
{
    LOG("MigrateUserNT\r\n");
    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateSystemNT (
    IN HINF    UnattendInfHandle,
       LPVOID  Reserved)
{
 HDEVINFO hdi;
 HANDLE   hFile;
 HANDLE   hMapping;
 WCHAR    szFile[MAX_PATH];
 PMODEM   pModem;
 DWORD    dwSize;
 TCHAR    szLib[MAX_PATH];
 PCOUNTRYRUNONCE pCountry;
 HINSTANCE hInst = NULL;

    LOG("Entering MigrateSystemNT\r\n");

    // Get Ports

    ZeroMemory(&g_ntports,sizeof(g_ntports));
    EnumeratePorts(&g_ntports);

    MigrateTapiProviders ();

    hdi = SetupDiGetClassDevs (g_pguidModem, NULL, NULL, DIGCF_PRESENT);
    if (INVALID_HANDLE_VALUE != hdi)
    {
        lstrcpyW (szFile, g_pszWorkingDir);
        lstrcatW (szFile, L"MM");
        hFile = CreateFileW (szFile,
                             GENERIC_READ | GENERIC_WRITE,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);
        if (INVALID_HANDLE_VALUE != hFile)
        {
            dwSize = GetFileSize (hFile, NULL);
            if (0xFFFFFFFF != dwSize)
            {
                LOG(" File size: %d, MODEM size: %d, Nr of entries: %d, odd bytes: %d\r\n",
                    dwSize, sizeof (MODEM), dwSize/sizeof(MODEM), dwSize%sizeof(MODEM));
                hMapping = CreateFileMapping (hFile,
                                              NULL,
                                              PAGE_READWRITE,
                                              0, 0,
                                              NULL);
                if (NULL != hMapping)
                {
                    pModem = (PMODEM)MapViewOfFileEx (hMapping,
                                                      FILE_MAP_ALL_ACCESS,
                                                      0, 0, 0,
                                                      NULL);
                    if (NULL != pModem)
                    {
                        ProcessModems (hdi, pModem, dwSize / sizeof (MODEM));
                        UnmapViewOfFile (pModem);
                    }
                    ELSE_LOG(("  MapViewOfFileEx failed: %#lx\r\n", GetLastError ()));

                    CloseHandle (hMapping);
                }
                ELSE_LOG(("  CreateFileMapping failed: %#lx\r\n", GetLastError ()));

                CloseHandle (hFile);

            }
            ELSE_LOG(("  GetFileSize failed: %#lx\r\n", GetLastError ()));
        }
        ELSE_LOG(("  CreateFile (%s) failed: %#lx\r\n", szFile, GetLastError ()));
        SetupDiDestroyDeviceInfoList (hdi);
    }
    ELSE_LOG(("  SetupDiGetClassDevs failed: %#lx\r\n", GetLastError ()));

    LOG("Exiting MigrateSystemNT\r\n");

    GetSystemDirectory(szLib,sizeof(szLib) / sizeof(TCHAR));
    lstrcat(szLib,TEXT("\\modemui.dll"));
    hInst = LoadLibrary(szLib);
    if (hInst != NULL)
    {
        pCountry = (PCOUNTRYRUNONCE)GetProcAddress(hInst,"CountryRunOnce");
        if (pCountry != NULL)
        {
            pCountry();
        }

        FreeLibrary(hInst);
    }

    return ERROR_SUCCESS;
}


void
ProcessModems (
    IN HDEVINFO hdi,
    IN PMODEM   pModem,
    IN DWORD    dwCount)
{
 DWORD dwRemaining = dwCount;

    LOG("Entering ProcessModems\r\n");

    InstallModems (hdi, pModem, dwCount);

    if (0 < dwRemaining)
    {
        dwRemaining = PassOne (hdi, pModem, dwCount);
    }

    if (0 < dwRemaining)
    {
        dwRemaining = PassTwo (hdi, pModem, dwCount);
    }

    if (0 < dwRemaining)
    {
        dwRemaining = PassThree (hdi, pModem, dwCount);
    }

    LOG("Exiting ProcessModems\r\n");
}


void InstallModems (HDEVINFO hdi, PMODEM pModem, DWORD dwCount)
{
 DWORD i;
     DWORD dwBaseAddress;
     CHAR port[MAX_PORT_NAME_LENGTH];

    for (i = 0; i < dwCount; i++, pModem++)
    {
        if (pModem->dwMask & FLAG_INSTALL)
        {
            if (pModem->dwBaseAddress != 0)
            {
                if (port_findname(&g_ntports, pModem->dwBaseAddress, port))
                {
                    lstrcpyA(pModem->szPort,port);
                }
            }

            InstallModem (hdi, pModem);
        }
    }
}


void ProcessModem (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pDevInfoData,
    IN PMODEM pModem)
{
 HKEY hkeyDrv;
 REGDEVCAPS regDevCaps;
 REGDEVSETTINGS regDevSettings;
 DWORD cbData;
 DECLARE(DWORD,dwRet);

    LOG("Entering ProcessModem\r\n");

    pModem->dwMask |= FLAG_PROCESSED;

    hkeyDrv = SetupDiOpenDevRegKey (hdi, pDevInfoData,
        DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ | KEY_WRITE);
    if (INVALID_HANDLE_VALUE != hkeyDrv)
    {
        SET(dwRet)
        RegSetValueExA (hkeyDrv, "UserInit", 0, REG_SZ, (LPBYTE)pModem->szUserInit,
                        lstrlenA (pModem->szUserInit)+1);
        ERR(dwRet, ERROR_SUCCESS, (LOG(" ResSetValue (UserInit) failed: %#lx\r\n", dwRet)));

        if (0 != pModem->bLogging)
        {
         char szPath[MAX_PATH];
         int iLength;

            // Set the path of the modem log
            iLength = GetWindowsDirectoryA (szPath, MAX_PATH);
            if (3 > iLength)
            {
                pModem->bLogging = 0;
                goto _SkipLoggingPath;
            }
            if (3 < iLength)
            {
                // this means that the path
                // will not end in a \, so
                // let's add it.
                szPath[iLength++] = '\\';
            }
            lstrcpyA (szPath+iLength, "ModemLog_");
            iLength += 9;
            if (!SetupDiGetDeviceRegistryPropertyA (hdi, pDevInfoData, SPDRP_FRIENDLYNAME,
                  NULL, (PBYTE)(szPath+iLength), sizeof(szPath)-iLength-1, NULL))
            {
                pModem->bLogging = 0;
                goto _SkipLoggingPath;
            }
            lstrcatA (szPath,".txt");
            SET(dwRet)
            RegSetValueExA (hkeyDrv, "LoggingPath", 0, REG_SZ,
                            (LPBYTE)szPath, lstrlenA (szPath)+1);
            ERR(dwRet, ERROR_SUCCESS, (LOG(" ResSetValue (LoggingPath) failed: %#lx\r\n", dwRet)));
        }

    _SkipLoggingPath:
        SET(dwRet)
        RegSetValueExA (hkeyDrv, "Logging", 0, REG_BINARY, (LPBYTE)&pModem->bLogging, sizeof(char));
        ERR(dwRet, ERROR_SUCCESS, (LOG(" ResSetValue (Logging) failed: %#lx\r\n", dwRet)));

        SET(dwRet)
        RegSetValueExW (hkeyDrv, L"DCB", 0, REG_BINARY,
                        (LPBYTE)&pModem->dcb, sizeof (pModem->dcb));
        ERR(dwRet, ERROR_SUCCESS, (LOG(" ResSetValue (DCB) failed: %#lx\r\n", dwRet)));

		// Get the new regDevCaps and regDevSettings so we can migrate intelligently
        cbData = sizeof (regDevCaps);
        dwRet = RegQueryValueExA (hkeyDrv,"Properties",NULL,NULL,(PBYTE)&regDevCaps,&cbData);
        if (ERROR_SUCCESS == dwRet)
        {
			cbData = sizeof (regDevSettings);
			dwRet = RegQueryValueExA (hkeyDrv,"Default",NULL,NULL,(PBYTE)&regDevSettings,&cbData);
			if (ERROR_SUCCESS == dwRet)
			{
				DWORD dwMigrateMask;

				// dwCallSetupFailTimer
				if (!(regDevCaps.dwCallSetupFailTimer && pModem->Properties.dwCallSetupFailTimer))
				{
					pModem->devSettings.dwCallSetupFailTimer = 	regDevSettings.dwCallSetupFailTimer;
				}

				// dwInactivityTimeout
				if (!(regDevCaps.dwInactivityTimeout && pModem->Properties.dwInactivityTimeout))
				{
					pModem->devSettings.dwInactivityTimeout = 	regDevSettings.dwInactivityTimeout;
				}

				// dwSpeakerVolume
				if (!(regDevCaps.dwSpeakerVolume & pModem->devSettings.dwSpeakerVolume))
				{
					pModem->devSettings.dwSpeakerVolume =   regDevSettings.dwSpeakerVolume;
				}

				// dwSpeakerMode
				if (!(regDevCaps.dwSpeakerMode & pModem->devSettings.dwSpeakerMode))
				{
					pModem->devSettings.dwSpeakerMode =   regDevSettings.dwSpeakerMode;
				}

				// dwPreferredModemOptions
				dwMigrateMask = regDevCaps.dwModemOptions & pModem->Properties.dwModemOptions;
				
				pModem->devSettings.dwPreferredModemOptions =
					(regDevSettings.dwPreferredModemOptions & ~dwMigrateMask) |
					(pModem->devSettings.dwPreferredModemOptions & dwMigrateMask);
			}
			ELSE_LOG(("  RegQueryValueExA (Default) failed: %#lx\r\n", dwRet));
        }
		ELSE_LOG(("  RegQueryValueExA (Properties) failed: %#lx\r\n", dwRet));

        SET(dwRet)
        RegSetValueExW (hkeyDrv, L"Default", 0, REG_BINARY,
                        (LPBYTE)&pModem->devSettings, sizeof (pModem->devSettings));
        ERR(dwRet, ERROR_SUCCESS, (LOG(" ResSetValue (Default) failed: %#lx\r\n", dwRet)));

        RegCloseKey (hkeyDrv);
    }
    ELSE_LOG(("  SetupDiOpenDevRegKey (DIREG_DRV) failed: %#lx\r\n", GetLastError ()));

    SetupDiDeleteDeviceInfo (hdi, pDevInfoData);

    LOG("Exiting ProcessModem\r\n");
}


DWORD PassOne (HDEVINFO hdi, PMODEM pModem, DWORD dwCount)
{
 DWORD iIndex;
 SP_DEVINFO_DATA  devInfoData = {sizeof (devInfoData), 0};
 DWORD i, cbData;
 char szHardwareID[REGSTR_MAX_VALUE_LENGTH];
 char szPort[REGSTR_MAX_VALUE_LENGTH];
 HKEY hKeyDrv;
 PMODEM pMdmTmp;
 DWORD dwRemaining = dwCount;
 DWORD dwBusType, dwRet;

    // PASS 1: we're looking at the bus type,
    // hardware ID and port name
    LOG("Enumerating installed modems - Pass 1:\r\n");
    for (iIndex = 0;
         SetupDiEnumDeviceInfo (hdi, iIndex, &devInfoData);
         iIndex++)
    {
        // First, get the bus type
        dwBusType = GetBusType (hdi, &devInfoData);

        // Then, get the hardware ID
        if (!SetupDiGetDeviceRegistryPropertyA (hdi, &devInfoData, SPDRP_HARDWAREID,
                NULL, (PBYTE)szHardwareID, sizeof (szHardwareID), NULL))
        {
            LOG("  SetupDiGetDeviceRegistryProperty(SPDRP_HARDWAREID) failed: %#lx\r\n", GetLastError ());
            // If we couldn't get the hardware ID,
            // there's nothing to do with this modem.
            continue;
        }

        // Third, open the driver key and get the port name.
        if (BUS_TYPE_ROOT    == dwBusType ||
            BUS_TYPE_SERENUM == dwBusType)
        {
            hKeyDrv = SetupDiOpenDevRegKey (hdi, &devInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
            if (INVALID_HANDLE_VALUE == hKeyDrv)
            {
                LOG("  SetupDiOpenDevRegKey failed: %#lx\r\n", GetLastError ());
                // If we couldn't open the driver key,
                // there's nothing to do with this modem.
                continue;
            }

            cbData = sizeof (szPort);
            szPort[0] = 0;
            dwRet = RegQueryValueExA (hKeyDrv,"AttachedTo",NULL,NULL,(PBYTE)szPort,&cbData);
            RegCloseKey (hKeyDrv);

            if (ERROR_SUCCESS != dwRet)
            {
                // We could not get the port
                LOG("  Could not read the port name: %#lx.\r\n", dwRet);
                continue;
            }
        }

        // Now, we have all the info needed to identify
        // the modem in phase 1.
        for (i = 0, pMdmTmp = pModem;
             i < dwCount;
             i++, pMdmTmp++)
        {
            if ( (0 == (pMdmTmp->dwMask & FLAG_PROCESSED))             &&   // Modem record has not been processed yet
                 (dwBusType == pMdmTmp->dwBusType)                     &&   // Same bus type
                 (0 == lstrcmpA (szHardwareID, pMdmTmp->szHardwareID)) &&   // Same hardware ID
                 ( (0 == (pMdmTmp->dwMask & MASK_PORT))     ||              // Same port
                   (0 == lstrcmpA (szPort, pMdmTmp->szPort))  ) )
            {
                ProcessModem (hdi, &devInfoData, pMdmTmp);
                dwRemaining--;
                iIndex--;   // Process modem will remove the current
                            // devinfo data from the set.
                break;
            }
        }
    }
    LOG("  SetupDiEnumDeviceInfo failed (%#lx) for index %d\r\n", GetLastError (), iIndex);

    return dwRemaining;
}


DWORD PassTwo (HDEVINFO hdi, PMODEM pModem, DWORD dwCount)
{
 DWORD iIndex;
 SP_DEVINFO_DATA  devInfoData = {sizeof (devInfoData), 0};
 DWORD i;
 char szHardwareID[REGSTR_MAX_VALUE_LENGTH];
 PMODEM pMdmTmp;
 DWORD dwRemaining = dwCount;
 DWORD dwBusType;

    // PASS 2: we're looking at the bus type
    // and hardware ID only
    LOG("Enumerating installed modems - Pass 2:\r\n");
    for (iIndex = 0;
         SetupDiEnumDeviceInfo (hdi, iIndex, &devInfoData);
         iIndex++)
    {
        // First, get the bus type
        dwBusType = GetBusType (hdi, &devInfoData);

        // Then, get the hardware ID
        if (!SetupDiGetDeviceRegistryPropertyA (hdi, &devInfoData, SPDRP_HARDWAREID,
                NULL, (PBYTE)szHardwareID, sizeof (szHardwareID), NULL))
        {
            LOG("  SetupDiGetDeviceRegistryProperty(SPDRP_HARDWAREID) failed: %#lx\r\n", GetLastError ());
            // If we couldn't get the hardware ID,
            // there's nothing to do with this modem.
            continue;
        }

        // Now, we have all the info needed to identify
        // the modem in phase 2.
        for (i = 0, pMdmTmp = pModem;
             i < dwCount;
             i++, pMdmTmp++)
        {
            if ( (0 == (pMdmTmp->dwMask & FLAG_PROCESSED))             &&   // Modem record has not been processed yet
                 (dwBusType == pMdmTmp->dwBusType)                     &&   // Same bus type
                 (0 == lstrcmpA (szHardwareID, pMdmTmp->szHardwareID)) )    // Same hardware ID
            {
                ProcessModem (hdi, &devInfoData, pMdmTmp);
                dwRemaining--;
                iIndex--;   // Process modem will remove the current
                            // devinfo data from the set.
                break;
            }
        }
    }
    LOG("  SetupDiEnumDeviceInfo failed (%#lx) for index %d\r\n", GetLastError (), iIndex);

    return dwRemaining;
}


DWORD PassThree (HDEVINFO hdi, PMODEM pModem, DWORD dwCount)
{
 DWORD iIndex;
 SP_DEVINFO_DATA  devInfoData = {sizeof (devInfoData), 0};
 DWORD i, cbData;
 REGDEVCAPS regDevCaps;
 HKEY hKeyDrv;
 PMODEM pMdmTmp;
 DWORD dwRemaining = dwCount;
 DWORD dwBusType, dwRet;

    // PASS 3: we're looking at the bus type,
    // and REGDEVCAPS
    LOG("Enumerating installed modems - Pass 1:\r\n");
    for (iIndex = 0;
         SetupDiEnumDeviceInfo (hdi, iIndex, &devInfoData);
         iIndex++)
    {
        // First, get the bus type
        dwBusType = GetBusType (hdi, &devInfoData);

        // Then, open the driver key and get the REGDEVCAPS.
        hKeyDrv = SetupDiOpenDevRegKey (hdi, &devInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
        if (INVALID_HANDLE_VALUE == hKeyDrv)
        {
            LOG("  SetupDiOpenDevRegKey failed: %#lx\r\n", GetLastError ());
            // If we couldn't open the driver key,
            // there's nothing to do with this modem.
            continue;
        }

        cbData = sizeof (regDevCaps);
        dwRet = RegQueryValueExA (hKeyDrv,"Properties",NULL,NULL,(PBYTE)&regDevCaps,&cbData);
        RegCloseKey (hKeyDrv);
        if (ERROR_SUCCESS != dwRet)
        {
            // We could not get the port
            LOG("  Could not read the REGDEVCAPS.\r\n");
            continue;
        }

        // Now, we have all the info needed to identify
        // the modem in phase 3.
        for (i = 0, pMdmTmp = pModem;
             i < dwCount;
             i++, pMdmTmp++)
        {
            if ( (0 == (pMdmTmp->dwMask & FLAG_PROCESSED))             &&   // Modem record has not been processed yet
                 (dwBusType == pMdmTmp->dwBusType)                     &&   // Same bus type
                 (0 == memcmp (&regDevCaps, &pMdmTmp->Properties, sizeof(REGDEVCAPS))) )    // Same REGDEVCAPS
            {
                ProcessModem (hdi, &devInfoData, pMdmTmp);
                dwRemaining--;
                iIndex--;   // Process modem will remove the current
                            // devinfo data from the set.
                break;
            }
        }
    }
    LOG("  SetupDiEnumDeviceInfo failed (%#lx) for index %d\r\n", GetLastError (), iIndex);

    return dwRemaining;
}


void InstallModem (HDEVINFO hDI, PMODEM pModem)
{
 SP_DEVINFO_DATA        devInfo = {sizeof(SP_DEVINFO_DATA),0};
 SP_DEVINSTALL_PARAMS   devInstParams = {sizeof(SP_DEVINSTALL_PARAMS), 0};
 SP_DRVINFO_DATA        drvDataEnum = {sizeof(SP_DRVINFO_DATA),0};
 SP_DRVINSTALL_PARAMS   drvParams = {sizeof(SP_DRVINSTALL_PARAMS),0};
 DWORD                  dwIndex = 0;
 UM_INSTALL_WIZARD      miw = {sizeof(UM_INSTALL_WIZARD), 0};
 SP_INSTALLWIZARD_DATA  iwd;
 BOOL                   bRet;

    LOG("Entering InstallModem\r\n");

    // First, create a Device Info Element
    if (!SetupDiCreateDeviceInfoW (hDI, L"MODEM", (LPGUID)&GUID_DEVCLASS_MODEM,
                                   NULL, NULL, DICD_GENERATE_ID, &devInfo))
    {
        LOG("SetupDiCreateDeviceInfo failed (%#lx).\r\n", GetLastError ());
        goto _Ret;
    }

    // Now, set the hardware ID property;
    // this is used by setup API to look for the
    // correct driver for the modem
    LOG("SetupDiSetDeviceRegistryProperty (%s)\n",pModem->szHardwareID);
    if (!SetupDiSetDeviceRegistryPropertyA (hDI, &devInfo, SPDRP_HARDWAREID,
                                            (PBYTE)pModem->szHardwareID,
                                            (lstrlenA(pModem->szHardwareID)+2)))
    {
        LOG("SetupDiSetDeviceRegistryProperty failed (%#lx).\r\n", GetLastError ());
        goto _ErrRet;
    }

    // Tell Setup to only look for drivers
    // for our class
    if (!SetupDiGetDeviceInstallParams (hDI, &devInfo, &devInstParams))
    {
        LOG("SetupDiGetDeviceInstallParams failed (%#lx).\r\n", GetLastError ());
        goto _ErrRet;
    }
    devInstParams.FlagsEx |= DI_FLAGSEX_USECLASSFORCOMPAT;
    devInstParams.Flags   |= DI_QUIETINSTALL;

    if (!SetupDiSetDeviceInstallParams (hDI, &devInfo, &devInstParams))
    {
        LOG("SetupDiSetDeviceInstallParams failed (%#lx).\r\n", GetLastError ());
        goto _ErrRet;
    }

    // Now, build the driver list
    if (!SetupDiBuildDriverInfoList (hDI, &devInfo, SPDIT_COMPATDRIVER))
    {
        LOG("SetupDiBuildDriverInfoList failed (%#lx).\r\n", GetLastError ());
        goto _ErrRet;
    }

    // Now, the driver list is built,
    // select the rank0 driver
    while (bRet =
           SetupDiEnumDriverInfo (hDI, &devInfo, SPDIT_COMPATDRIVER, dwIndex++, &drvDataEnum))
    {
        if (SetupDiGetDriverInstallParams (hDI, &devInfo, &drvDataEnum, &drvParams) &&
            0 == drvParams.Rank)
        {
            // Set the first Rank0 driver as the selected driver
            bRet = SetupDiSetSelectedDriver(hDI, &devInfo, &drvDataEnum);
            break;
        }
    }

    if (!bRet)
    {
        LOG("Could not select a driver!\r\n");
        goto _ErrRet;
    }

    // We selected the proper driver;
    // This to set up the installwizard structures
    miw.InstallParams.Flags = MIPF_DRIVER_SELECTED;
    if (0 ==
        MultiByteToWideChar (CP_ACP, 0, pModem->szPort, -1, miw.InstallParams.szPort, UM_MAX_BUF_SHORT))
    {
        LOG("MultiByteToWideChar failed (%#lx).\r\n", GetLastError ());
        goto _ErrRet;
    }

    ZeroMemory(&iwd, sizeof(iwd));
    iwd.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    iwd.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
    iwd.hwndWizardDlg = NULL;
    iwd.PrivateData = (LPARAM)&miw;

   if (SetupDiSetClassInstallParams (hDI, &devInfo, (PSP_CLASSINSTALL_HEADER)&iwd, sizeof(iwd)))
   {
      // Call the class installer to invoke the installation
      // wizard.
      if (SetupDiCallClassInstaller (DIF_INSTALLWIZARD, hDI, &devInfo))
      {
         // Success.  The wizard was invoked and finished.
         // Now cleanup.
         SetupDiCallClassInstaller (DIF_DESTROYWIZARDDATA, hDI, &devInfo);
         goto _Ret;
      }
      ELSE_LOG(("SetupDiCallClassInstaller failed (%#lx).\r\n", GetLastError ()));
   }
   ELSE_LOG(("SetupDiSetClassInstallParams failed (%#lx).\r\n", GetLastError ()));

_ErrRet:

    SetupDiDeleteDeviceInfo (hDI, &devInfo);

_Ret:
    LOG("Exiting InstallModem\r\n");
}


static HANDLE OpenProvidersFile (void)
{
 HANDLE hFile;
 WCHAR  szFile[MAX_PATH] = L"";

    lstrcpy (szFile, g_pszWorkingDir);
    lstrcat (szFile, L"TP");

    hFile = CreateFile (szFile,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

#ifdef DO_LOG
    if (INVALID_HANDLE_VALUE == hFile)
    {
        LOG(" Could not open %s: %#lx\r\n", szFile, GetLastError());
    }
#endif //DO_LOG

    return hFile;
}

void
MigrateTapiProviders (void)
{
 HANDLE hFile;
 DWORD dwNumProviders = 0;
 DWORD dwNextProviderID = 1;
 HKEY  hKeyProviders = INVALID_HANDLE_VALUE;
 DWORD cbData;
 char  szProviderFileName[24];  // Enough to hold "ProviderFileNameXXXXX\0"
 char  szProviderID[16];        // Enough to hold "ProviderIDxxxxx\0"
 char  *pProviderFileNameNumber, *pProviderIDNumber;
 TAPI_SERVICE_PROVIDER Provider;

    LOG("Entering MigrateTapiProviders\r\n");

    // First, try to open the Tapi file.
    hFile = OpenProvidersFile ();
    if (INVALID_HANDLE_VALUE == hFile)
    {
        goto _Return;
    }

    // Next, open the Providers key.
    if (ERROR_SUCCESS !=
        RegOpenKeyExA (HKEY_LOCAL_MACHINE, REGKEY_PROVIDERS, 0,
                       KEY_ALL_ACCESS, &hKeyProviders))
    {

        LOG("RegOpenKeyEx (providers...) failed!\r\n");
        goto _Return;
    }

    // Now, read the number of providers, and the next provider ID
    cbData = sizeof (dwNumProviders);
    if (ERROR_SUCCESS !=
        RegQueryValueExA (hKeyProviders, REGVAL_NUMPROVIDERS, NULL, NULL, (PVOID)&dwNumProviders, &cbData))
    {
        goto _Return;
    }
    LOG("There are %d providers\r\n", dwNumProviders);
    cbData = sizeof (dwNextProviderID);
    if (ERROR_SUCCESS !=
        RegQueryValueExA (hKeyProviders, REGVAL_NEXTPROVIDERID, NULL, NULL, (PVOID)&dwNextProviderID, &cbData))
    {
        goto _Return;
    }
    LOG("NextProviderID: %d\r\n", dwNextProviderID);

    // Initialize value names and pointers
    lstrcpyA (szProviderFileName, REGVAL_PROVIDERFILENAME);
    lstrcpyA (szProviderID, REGVAL_PROVIDERID);
    pProviderFileNameNumber = szProviderFileName + lstrlenA (szProviderFileName);
    pProviderIDNumber = szProviderID + lstrlenA (szProviderID);


    // Now, add all the providers again. We do this because the
    // IDs were REG_BINARY on win98 and have to be REG_DWORD on NT5.
    while (TRUE)
    {
        if (0 == ReadFile (hFile, (PVOID)&Provider, sizeof(Provider), &cbData, NULL) ||
            sizeof(Provider) != cbData)
        {
            // Some error reading the file or
            // (more likely), end of file.
            break;
        }
        LOG("Read %s, %d\r\n", Provider.szProviderName, Provider.dwProviderID);

        // We have a 32 bit provider from win98 - install it.
        wsprintfA (pProviderFileNameNumber, "%d", dwNumProviders);
        lstrcpyA (pProviderIDNumber, pProviderFileNameNumber);
        if (ERROR_SUCCESS ==
            RegSetValueExA (hKeyProviders, szProviderFileName, 0, REG_SZ,
                            (PBYTE)Provider.szProviderName,
                            lstrlenA(Provider.szProviderName)+1))
        {
            if (ERROR_SUCCESS ==
                RegSetValueExA (hKeyProviders, szProviderID, 0, REG_DWORD,
                               (PBYTE)&Provider.dwProviderID,
                               sizeof(Provider.dwProviderID)))
            {
                dwNumProviders++;
                if (Provider.dwProviderID >= dwNextProviderID)
                {
                    dwNextProviderID = Provider.dwProviderID+1;
                }
            }
            else
            {
                RegDeleteValueA (hKeyProviders, szProviderFileName);
            }
        }
    }

    // Finally, update NumProviders and NextProviderID.
    RegSetValueExA (hKeyProviders, REGVAL_NUMPROVIDERS, 0, REG_DWORD,
                    (PBYTE)&dwNumProviders, sizeof(dwNumProviders));
    RegSetValueExA (hKeyProviders, REGVAL_NEXTPROVIDERID, 0, REG_DWORD,
                    (PBYTE)&dwNextProviderID, sizeof(dwNextProviderID));

_Return:
    if (INVALID_HANDLE_VALUE != hKeyProviders)
    {
        RegCloseKey (hKeyProviders);
    }

    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle (hFile);
    }

    LOG("Exiting MigrateTapiProviders\r\n");
}



#include <initguid.h>
#include <wdmguid.h>

DWORD GetBusType (
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData)
{
 DWORD dwRet = BUS_TYPE_OTHER;
 ULONG ulStatus, ulProblem = 0;

    if (CR_SUCCESS == CM_Get_DevInst_Status (&ulStatus, &ulProblem, pdevData->DevInst, 0) &&
        (ulStatus & DN_ROOT_ENUMERATED))
    {
        dwRet = BUS_TYPE_ROOT;
    }
    else
    {
     GUID guid;
        // either CM_Get_DevInst_Status failed, which means that the device
        // is plug & play and not present (i.e. plugged out),
        // or the device is not root-enumerated;
        // either way, it's a plug & play device.

        // If the next call fails, it means that the device is
        // BIOS / firmware enumerated; this is OK - we just return BUT_TYPE_OTHER
        if (SetupDiGetDeviceRegistryProperty (hdi, pdevData, SPDRP_BUSTYPEGUID, NULL,
                                              (PBYTE)&guid, sizeof(guid), NULL))
        {
         int i;
         struct
         {
             GUID const *pguid;
             DWORD dwBusType;
         } BusTypes[] = {{&GUID_BUS_TYPE_SERENUM, BUS_TYPE_SERENUM},
                         {&GUID_BUS_TYPE_PCMCIA, BUS_TYPE_PCMCIA},
                         {&GUID_BUS_TYPE_ISAPNP, BUS_TYPE_ISAPNP}};

            for (i = 0;
                 i < sizeof (BusTypes) / sizeof (BusTypes[0]);
                 i ++)
            {
                if (IsEqualGUID (BusTypes[i].pguid, &guid))
                {
                    dwRet = BusTypes[i].dwBusType;
                    break;
                }
            }
        }
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\w95migr\modem.h ===
#include <modemp.h>

#define MAX_DIST_RINGS  6
#define MAX_CODE_BUF    8

#define PROVIDER_FILE_NAME_LEN          14  // Provider's file name has the DOS
                                            // form (8.3)

typedef struct
{
    DWORD dwPattern;
    DWORD dwMediaType;
} DIST_RING, FAR * PDIST_RING;

typedef struct
{
    DWORD   cbSize;
    DWORD   dwFlags;

    DIST_RING   DistRing[MAX_DIST_RINGS];

    char    szActivationCode[MAX_CODE_BUF];
    char    szDeactivationCode[MAX_CODE_BUF];
} VOICEFEATURES;

typedef struct _MODEM
{
    //Global information
    DWORD dwMask;

    // Modem Identification
    DWORD dwBusType;        // Bus type (e.g. serenum, root)
    char szHardwareID[REGSTR_MAX_VALUE_LENGTH];
    char szPort[REGSTR_MAX_VALUE_LENGTH];   // Only for root devices
    REGDEVCAPS Properties;  // Modem's capabilities

    // Modem properties
    REGDEVSETTINGS devSettings;
    DCB  dcb;
    char szUserInit[REGSTR_MAX_VALUE_LENGTH];
    char bLogging;
    char Filler[3];

    DWORD dwBaseAddress;
} MODEM, *PMODEM;


typedef struct _TAPI_SERVICE_PROVIDER
{
    DWORD   dwProviderID;
    char    szProviderName[PROVIDER_FILE_NAME_LEN];
}TAPI_SERVICE_PROVIDER, *PTAPI_SERVICE_PROVIDER;


/*
    These are mandatory, no need
    for flags

#define MASK_BUS_TYPE       0x001
#define MASK_HARDWARE_ID    0x002
#define MASK_FRIENDLY_NAME  0x004
#define MASK_DEV_CAPS       0x008
#define MASK_DEV_SETTINGS   0x010
#define MASK_DCB            0x020
*/
#define MASK_PORT           0x001
#define MASK_USER_INIT      0x002
#define MASK_LOGGING        0x004


#define FLAG_INSTALL        0x10000000
#define FLAG_PROCESSED      0x80000000


#define REGKEY_PROVIDERS        "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers"
#define REGVAL_PROVIDERFILENAME "ProviderFileName"
#define REGVAL_PROVIDERID       "ProviderID"
#define TSP3216l                "TSP3216l.TSP"

#define REGVAL_NUMPROVIDERS             "NumProviders"
#define REGVAL_NEXTPROVIDERID           "NextProviderID"
#define REGVAL_PROVIDERFILENAME         "ProviderFileName"
#define REGVAL_PROVIDERID               "ProviderID"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\w95migr\win95.c ===
#define WIN9x
#include "common.h"
#include "modem.h"
#include "msg.h"
#include <miglib.h>


#define MAX_REG_PATH     256
#define MAX_EXE_BUFFER  2048

#define BUS_TYPE_MODEMWAVE 0x80000000

#define PROVIDER_FILE_NAME_LEN          14  // Provider's file name has the DOS
                                            // form (8.3)

#define NULL_MODEM  "PNPC031"

typedef struct
{
    char CompanyName[256];
    char SupportNumber[256];
    char SupportUrl[256];
    char InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO;

typedef struct
{
    HKEY  hRegKey;
    HKEY  hkClass;
    char  szRegSubkey[MAX_REG_PATH];
    DWORD dwBusType;
    HANDLE h_File;
    MODEM modem;
} REG_DEVICE, *PREG_DEVICE;

typedef void (*PROCESS_MODEM)(PREG_DEVICE, DWORD);


VENDORINFO VendorInfo = {"", "", "", ""};

char g_pszProductID[]="Microsoft Unimodem";
char g_pszWorkingDir[MAX_PATH];
char g_pszSourceDir[MAX_PATH];
char g_pszUnattendFile[MAX_PATH];
char g_szExeBuffer[MAX_EXE_BUFFER];

int iNumModems = 0;

DWORD PnPIDTableCreate ();
void PnPIDTableDestroy (DWORD);
void EnumNextLevel(PREG_DEVICE, int, PROCESS_MODEM, DWORD);
static void ProcessModem (PREG_DEVICE, DWORD);
void WalkRegistry (PROCESS_MODEM, DWORD);
int  GetNumberOfModems (void);
void UpdateAnswerFileAndMigrateInf (
    char *szHardwareID,
    char *szCompatibleIDs,
    HKEY hKeyDrv,
    char *szEnumPath,
    DWORD dwPnPIDTable);
void DoTapiProviders (void);

Ports g_ports;



LONG
CALLBACK
QueryVersion (
    OUT LPCSTR *ppszProductID,
    OUT LPUINT  pDllVerion,
    OUT LPINT  *ppCodePageArray,
    OUT LPCSTR *ppszzExeNamesBuf,
    OUT PVENDORINFO *ppVendorInfo)
{
 OSVERSIONINFO Version;
 HMODULE hModule;

    hModule = GetModuleHandleA ("migrate.dll");
    if (NULL == hModule)
    {
        return GetLastError ();
    }

    FormatMessageA (FORMAT_MESSAGE_FROM_HMODULE,
                    hModule,
                    MSG_VI_COMPANY_NAME, 0,
                    VendorInfo.CompanyName, 256,
                    NULL);
    FormatMessageA (FORMAT_MESSAGE_FROM_HMODULE,
                    hModule,
                    MSG_VI_SUPPORT_NUMBER, 0,
                    VendorInfo.SupportNumber, 256,
                    NULL);
    FormatMessageA (FORMAT_MESSAGE_FROM_HMODULE,
                    hModule,
                    MSG_VI_SUPPORT_URL, 0,
                    VendorInfo.SupportUrl, 256,
                    NULL);
    FormatMessageA (FORMAT_MESSAGE_FROM_HMODULE,
                    hModule,
                    MSG_VI_INSTRUCTIONS, 0,
                    VendorInfo.InstructionsToUser, 1024,
                    NULL);

    *ppszProductID = g_pszProductID;
    *pDllVerion = 1;
    *ppCodePageArray = NULL;
    *ppszzExeNamesBuf = g_szExeBuffer;
    *ppVendorInfo = &VendorInfo;

    return ERROR_SUCCESS;
}



LONG
CALLBACK
Initialize9x (
    IN LPCSTR pszWorkingDirectory,
    IN LPCSTR pszSourceDirectory,
       LPVOID pvReserved)
{
 LONG lRet;
 DWORD dwWritten;
 int iLen;

    // Find com ports

    ZeroMemory(&g_ports, sizeof(g_ports));
    EnumeratePorts(&g_ports);

    ZeroMemory (g_pszWorkingDir, sizeof(g_pszWorkingDir));
    lstrcpyA (g_pszWorkingDir, pszWorkingDirectory);
    iLen = lstrlenA (g_pszWorkingDir);
    if ('\\' != g_pszWorkingDir[iLen-1])
    {
        g_pszWorkingDir[iLen] = '\\';
    }

    ZeroMemory (g_pszSourceDir, sizeof(g_pszSourceDir));
    lstrcpyA (g_pszSourceDir, pszSourceDirectory);
    iLen = lstrlenA (g_pszSourceDir);
    if ('\\' != g_pszSourceDir[iLen-1])
    {
        g_pszSourceDir[iLen] = '\\';
    }

    START_LOG(pszWorkingDirectory);
    LOG ("Initialize9x\r\n");
    LOG (" WorkingDirectory: %s\r\n", pszWorkingDirectory);
    LOG (" SourceDirectory: %s\r\n", pszSourceDirectory);

    iNumModems = GetNumberOfModems ();
    LOG(" Initialize9x found %d modems.\r\n", iNumModems);

    LOG("Exit Initialize9x\r\n");
    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateUser9x (
    IN HWND     ParentWnd,
    IN LPCSTR   UnattendFile,
    IN HKEY     UserRegKey,
    IN LPCSTR   UserName,
    LPVOID      Reserved)
{
    //
    // All our settings are system-wide
    //
    LOG("MigrateUser9x\r\n");
    return ERROR_NOT_INSTALLED;
}



LONG
CALLBACK
MigrateSystem9x (
    IN HWND     ParentWnd,
    IN LPCSTR   UnattendFile,
    LPVOID      Reserved)
{
 DWORD PnPIDTable;

    LOG("MigrateSystem9x\r\n");

    lstrcpyA (g_pszUnattendFile, UnattendFile);
    LOG("UnattendFile: %s.\r\n", UnattendFile);

    DoTapiProviders ();

    if (0 < iNumModems)
    {
        PnPIDTable = PnPIDTableCreate ();
        WalkRegistry (ProcessModem, PnPIDTable);
        PnPIDTableDestroy (PnPIDTable);
    }

    return ERROR_SUCCESS;
}



void EnumNextLevel (
    PREG_DEVICE pRegDevice,
    int         Level,
    PROCESS_MODEM pProcessModem,
    DWORD       dwParam)
{
 HKEY            hk = INVALID_HANDLE_VALUE;
 DWORD           rr;
 int             i;
 ULONG           cbData, StrLen;

    LOG("Enter EnumNextLevel - level is %d\r\n", Level);
    LOG("    %s\r\n", pRegDevice->szRegSubkey);
    if (0 == Level)
    {
        pProcessModem (pRegDevice, dwParam);
    }
    else
    {
        if (2 == Level)
        {
         char *p = pRegDevice->szRegSubkey + 5; // past ENUM\
            // Here we should get the info about the bus
            if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, p, -1, "MODEMWAVE", -1) == 2)
            {
                pRegDevice->dwBusType = BUS_TYPE_MODEMWAVE;
            }
            else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, p, -1, "ROOT", -1) == 2)
            {
                pRegDevice->dwBusType = BUS_TYPE_ROOT;
            }
            else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, p, -1, "ISAPNP", -1) == 2)
            {
                pRegDevice->dwBusType = BUS_TYPE_ISAPNP;
            }
            else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, p, -1, "PCMCIA", -1) == 2)
            {
                pRegDevice->dwBusType = BUS_TYPE_PCMCIA;
            }
            else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, p, -1, "SERENUM", -1) == 2)
            {
                pRegDevice->dwBusType = BUS_TYPE_SERENUM;
            }
            else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, p, -1, "LPTENUM", -1) == 2)
            {
                pRegDevice->dwBusType = BUS_TYPE_LPTENUM;
            }
            else
            {
                pRegDevice->dwBusType = BUS_TYPE_OTHER;
            }
        }

        StrLen = lstrlenA (pRegDevice->szRegSubkey);
        rr = RegOpenKeyExA (pRegDevice->hRegKey,
                            pRegDevice->szRegSubkey,
                            0, KEY_ALL_ACCESS, &hk);
        for (i = 0; rr == ERROR_SUCCESS; i++)
        {
            pRegDevice->szRegSubkey[StrLen] = '\\';
            cbData = sizeof(pRegDevice->szRegSubkey) - StrLen - 1;
            rr = RegEnumKeyA (hk, i, (LPSTR)&(pRegDevice->szRegSubkey[StrLen+1]),
                              cbData);
            if (rr == ERROR_SUCCESS)
            {
                EnumNextLevel(pRegDevice, Level-1, pProcessModem, dwParam);
            }
        }

        if (INVALID_HANDLE_VALUE != hk)
        {
            RegCloseKey(hk);
        }

        pRegDevice->szRegSubkey[StrLen] = '\0';
    }
    LOG("    %s\r\n", pRegDevice->szRegSubkey);
    LOG("Exiting EnumNextLevel %d\r\n", Level);
}


void ProcessModem (PREG_DEVICE pDevice, DWORD dwPnPIDTable)
{
 HKEY  hk, hkDrv = INVALID_HANDLE_VALUE;
 char  szBuffer[REGSTR_MAX_VALUE_LENGTH];
 ULONG cbData;
 DWORD dwRet, dwWritten;
 BOOL  bVirtualDevNode = FALSE;
 HKEY  hkParentDevNode;
 char  szParentDevNode[REGSTR_MAX_VALUE_LENGTH];
 char  szTemp[1024];

    LOG("Entering ProcessModem\r\n");
    if (BUS_TYPE_MODEMWAVE == pDevice->dwBusType)
    {
        // If this is a modemwave device, all we need to do
        // is tell setup it needn't worry about it - we do this
        // by writing in migrate.inf that we handled this device.
        // We pass NULL for the first two parameters, so that the
        // next call doesn't also update unattend.txt.
        UpdateAnswerFileAndMigrateInf (NULL, NULL, NULL, pDevice->szRegSubkey, 0);
        return;
    }

    if (ERROR_SUCCESS ==
            (dwRet = RegOpenKeyExA (pDevice->hRegKey,
                                    pDevice->szRegSubkey,
                                    0, KEY_ALL_ACCESS, &hk)))
    {
        cbData = sizeof(szBuffer);
        if (ERROR_SUCCESS ==
                (dwRet = RegQueryValueExA (hk, "Class", NULL, NULL, szBuffer, &cbData)))
        {
            if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szBuffer, -1, "Modem", -1) == 2)
            {
             DWORD dwType;
             char *p;

                LOG("Found a modem.\r\n");
                // We found a modem.
                // First, clear the the modem structure
                ZeroMemory (&pDevice->modem, sizeof (pDevice->modem));

                // Now let's store the info we'll use to
                // identify the modem on NT side.

                // First, the bus type
                pDevice->modem.dwBusType = pDevice->dwBusType;

                // Log the friendly name
                cbData = sizeof(pDevice->modem.szHardwareID);
                if (ERROR_SUCCESS == (
                    SET(dwRet)
                    RegQueryValueExA (hk, "FriendlyName", NULL, NULL,
                            pDevice->modem.szHardwareID, &cbData)))
                {
                    LOG("  FriendlyName: %s.\r\n", pDevice->modem.szHardwareID);
                }
                ERR(dwRet, ERROR_SUCCESS, (LOG("  RegQueryValueEx(FriendlyName) failed: %#lx\r\n", dwRet)));

                // Second, get the hardware ID.

				// Check to see if this is a CCPORT child device by looking for a
				// ParentDevNode key. If so, we will need to get the HardwareID from 
				// this parent devnode.

				cbData = sizeof(szBuffer);
				if (ERROR_SUCCESS ==
					(dwRet = RegQueryValueExA (hk, "ParentDevNode", NULL, NULL,
											   szBuffer, &cbData)))
				{
					LOG("  This is a ccport virtual DevNode.\r\n");

					lstrcpyA(szParentDevNode, "Enum\\");
					lstrcatA(szParentDevNode, szBuffer);

                    LOG("  ParentDevNode: %s.\r\n", szParentDevNode);

					if (ERROR_SUCCESS ==
							(dwRet = RegOpenKeyExA (HKEY_LOCAL_MACHINE,
													szParentDevNode,
													0, KEY_ALL_ACCESS, &hkParentDevNode)))
					{
						bVirtualDevNode = TRUE;
					}
					else
					{
						LOG("  RegOpenKeyEx(szParentDevNode) failed: %#lx\r\n", dwRet);
						goto _End;
					}
				}

				cbData = sizeof(pDevice->modem.szHardwareID);
				ZeroMemory (pDevice->modem.szHardwareID, cbData);

				if (bVirtualDevNode)
				{
					if (ERROR_SUCCESS != (
						SET(dwRet)
						RegQueryValueExA (hkParentDevNode, "HardwareID", NULL, NULL,
        								  pDevice->modem.szHardwareID, &cbData)))
					{
						LOG("  RegQueryValueEx(hkParentDevNode, szHardwareID) failed: %#lx\r\n", dwRet);
						goto _End;
					}
				}
				else
				{
					if (ERROR_SUCCESS != (
						SET(dwRet)
						RegQueryValueExA (hk, "HardwareID", NULL, NULL,
        								  pDevice->modem.szHardwareID, &cbData)))
					{
						LOG("  RegQueryValueEx(hk, szHardwareID) failed: %#lx\r\n", dwRet);
						goto _End;
					}
				}

                LOG("  Hardware ID: %s.\r\n", pDevice->modem.szHardwareID);
                // Now convert the ID from a string (with multiple IDs
                // separated by comma) to a multi_strings
                for (p = pDevice->modem.szHardwareID;
                     0 != *p;
                     p++)
                {
                    if (',' == *p)
                    {
                        *p = 0;
                    }
                }

                // If this is "Communications cable ..."
                // then mark this one for installation on NT5
                // (as it will not be picked up by PnP).
                /* if (0 == lstrcmpiA (pDevice->modem.szHardwareID, NULL_MODEM))
                {
                    pDevice->modem.dwMask |= FLAG_INSTALL;
                }
 */

                // If this is a legacy modem then mark this one for
                // installation as whistler no longer supports
                // legacy detection.

                if (lstrlen(pDevice->modem.szHardwareID) >= 8)
                {
                    lstrcpyA(szTemp,pDevice->modem.szHardwareID);
                    szTemp[8] = '\0';
                    if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szTemp, -1, "UNIMODEM", -1) == 2)
                    {
                        LOG("  Found a legacy modem\n");

                        // Change to unknown modem

                        cbData = sizeof(pDevice->modem.szHardwareID);
                        ZeroMemory(pDevice->modem.szHardwareID, cbData);
                        lstrcpy(pDevice->modem.szHardwareID,"MDMUNK");

                        // Find port address

                        pDevice->modem.dwBaseAddress = 0;
                        if (!port_findaddress(&g_ports,&(pDevice->modem.dwBaseAddress),pDevice->modem.szPort))
                        {
                            LOG("Can't find address");
                        }

                        pDevice->modem.dwMask |= FLAG_INSTALL;
                    }
                }

                // At this point, we need to open the
                // driver key.
                cbData = sizeof(szBuffer);
                if (ERROR_SUCCESS != (
                    SET(dwRet)
                    RegQueryValueExA (hk, "Driver", NULL, &dwType, szBuffer, &cbData)))
                {
                    LOG("  RegQueryValueEx(Driver) failed: %#lx\r\n", dwRet);
                    goto _End;
                }

				LOG("  Driver: %s.\r\n", szBuffer);

                if (ERROR_SUCCESS != (
                    SET(dwRet)
                    RegOpenKeyExA (pDevice->hkClass, szBuffer,
                                   0, KEY_ALL_ACCESS, &hkDrv)))
                {
                    LOG("  Could not open driver's key (%s): %#lx\r\n", szBuffer, dwRet);
                    goto _End;
                }

                // Get the port name (if we have one)
                pDevice->modem.szPort[0] = '\0';
	            cbData = sizeof(pDevice->modem.szPort);

				if (bVirtualDevNode)
				{
					if (ERROR_SUCCESS == (
						SET(dwRet)
						RegQueryValueExA (hk, "AttachedTo", NULL, NULL,
        						pDevice->modem.szPort, &cbData)))
					{
						pDevice->modem.dwMask |= MASK_PORT;
					}
				}
				else
				{
					if (ERROR_SUCCESS == (
						SET(dwRet)
						RegQueryValueExA (hkDrv, "AttachedTo", NULL, NULL,
        						pDevice->modem.szPort, &cbData)))
					{
						pDevice->modem.dwMask |= MASK_PORT;
					}
				}
                ERR(dwRet, ERROR_SUCCESS, (LOG("  RegQueryValueEx(AttachedTo) failed: %#lx\r\n", dwRet)));

                // Finally, we can get the REGDEVCAPS.
	            cbData = sizeof(pDevice->modem.Properties);
		        if (ERROR_SUCCESS != (
                    SET(dwRet)
                    RegQueryValueExA (hkDrv, "Properties", NULL, NULL,
        	                          (PBYTE)&pDevice->modem.Properties, &cbData)))
                {
                    LOG("  RegQueryValueEx(Default) failed: %#lx\r\n", dwRet);
                    goto _Exit;
                }


                // At this point, we have all the information
                // needed to identify the modem on NT5.
                // So let's get the modem's settings;
                // First, the REGDEVSETTINGS
	            cbData = sizeof(pDevice->modem.devSettings);
		        if (ERROR_SUCCESS != (
                    SET(dwRet)
                    RegQueryValueExA (hkDrv, "Default", NULL, NULL,
        	                          (PBYTE)&pDevice->modem.devSettings, &cbData)))
                {
                    // Without the Defaults, there's no point in
                    // saving this modem.
                    LOG("  RegQueryValueEx(Default) failed: %#lx\r\n", dwRet);
                    goto _Exit;
                }

                // Next, let's get the DCB
	            cbData = sizeof(pDevice->modem.dcb);
		        if (ERROR_SUCCESS != (
                    SET(dwRet)
                    RegQueryValueExA (hkDrv, "DCB", NULL, NULL,
        	                          (PBYTE)&pDevice->modem.dcb, &cbData)))
                {
                    LOG("  RegQueryValueEx(DCB) failed: %#lx\r\n", dwRet);
                    goto _Exit;
                }


                // Now we have all the info that's
                // mandatory. Let's look at the optional
                // fields.

                // Get the user init string
                pDevice->modem.szUserInit[0] = '\0';
	            cbData = sizeof(pDevice->modem.szUserInit);
                if (ERROR_SUCCESS == (
                    SET(dwRet)
		            RegQueryValueExA (hkDrv, "UserInit", NULL, NULL,
        	                pDevice->modem.szUserInit, &cbData)))
                {
                    pDevice->modem.dwMask |= MASK_USER_INIT;
                }
                ERR(dwRet, ERROR_SUCCESS, (LOG("  RegQueryValueEx(UserInit) failed: %#lx\r\n", dwRet)));

                // Next, get the logging value
                pDevice->modem.bLogging = 0;
	            cbData = sizeof(pDevice->modem.bLogging);
                SET(dwRet)
		        RegQueryValueExA (hkDrv, "Logging", NULL, NULL,
        	            &pDevice->modem.bLogging, &cbData);
                ERR(dwRet, ERROR_SUCCESS, (LOG("  RegQueryValueEx(Logging) failed: %#lx\r\n", dwRet)));

                LOG("  %s, %s, %#lx, %d\r\n",
                    pDevice->modem.szHardwareID,
                    pDevice->modem.szUserInit,
                    pDevice->modem.dwMask,
                    (DWORD)pDevice->modem.bLogging);

                WriteFile (pDevice->h_File,
                           &pDevice->modem,
                           sizeof(pDevice->modem),
                           &dwWritten, NULL);

            _Exit:
                // Here we have the hardware id and the
                // driver key;
	            cbData = sizeof(szBuffer);
                ZeroMemory (szBuffer, cbData);

				if (bVirtualDevNode)
				{
					if (ERROR_SUCCESS != (
						SET(dwRet)
						RegQueryValueExA (hkParentDevNode, "CompatibleIDs", NULL, NULL, szBuffer, &cbData)))
					{
						LOG("  RegQueryValueEx(CompatibleIDs) failed: %#lx\r\n", dwRet);
					}
				}
				else
				{
					if (ERROR_SUCCESS != (
						SET(dwRet)
						RegQueryValueExA (hk, "CompatibleIDs", NULL, NULL, szBuffer, &cbData)))
					{
						LOG("  RegQueryValueEx(CompatibleIDs) failed: %#lx\r\n", dwRet);
					}
				}

                LOG("  Compatible IDs: %s.\r\n", szBuffer);
                // Now convert the ID from a string (with multiple IDs
                // separated by comma) to a multi_strings
                for (p = szBuffer; 0 != *p; p++)
                {
                    if (',' == *p)
                    {
                        *p = 0;
                    }
                }
                UpdateAnswerFileAndMigrateInf (pDevice->modem.szHardwareID,
                                               szBuffer,
                                               hkDrv,
                                               pDevice->szRegSubkey,
                                               dwPnPIDTable);
                RegCloseKey (hkDrv);
            }
            ELSE_LOG(("  Class not modem.\r\n"));

        _End:
            RegCloseKey(hk);

			if (bVirtualDevNode) RegCloseKey(hkParentDevNode);
        }
        ELSE_LOG(("  Could not read class: %#lx\r\n", dwRet));
    }
    ELSE_LOG(("  Could not open key %s: %#lx\r\n", pDevice->szRegSubkey, dwRet));
    LOG("Exiting ProcessModem\r\n.");
}


void WalkRegistry (PROCESS_MODEM pProcessModem, DWORD dwParam)
{
 REG_DEVICE regDevice = {HKEY_LOCAL_MACHINE,
                         INVALID_HANDLE_VALUE,
                         "Enum",
                         {0}};
 char szFile[MAX_PATH] = "";

    LOG ("WalkRegistry\r\n");

    if (ERROR_SUCCESS ==
            RegOpenKeyExA (HKEY_LOCAL_MACHINE,
                           "System\\CurrentControlSet\\Services\\Class",
                           0, KEY_ALL_ACCESS,
                           &regDevice.hkClass))
    {
        LOG(" Opened the class key successfully\r\n");
        lstrcpyA (szFile, g_pszWorkingDir);
        lstrcatA (szFile, "MM");

        regDevice.h_File = CreateFileA (szFile,
                                        GENERIC_READ | GENERIC_WRITE,
                                        0,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);

        if (INVALID_HANDLE_VALUE != regDevice.h_File)
        {
            LOG(" Created the migration file successfully\r\n");
            EnumNextLevel (&regDevice, 3, pProcessModem, dwParam);
            RegCloseKey (regDevice.hkClass);
            CloseHandle (regDevice.h_File);
        }
        ELSE_LOG((" Could not create migration file: %#lx\r\n", GetLastError()));
    }

    LOG("Exit WalkRegistry\r\n");
}


int  GetNumberOfModems (void)
{
 int iRet = 0;
 HKEY hKey;

    if (ERROR_SUCCESS ==
        RegOpenKeyExA (HKEY_LOCAL_MACHINE,
                       "System\\CurrentControlSet\\Services\\Class\\Modem",
                       0,
                       KEY_ENUMERATE_SUB_KEYS,
                       &hKey))
    {
        if (ERROR_SUCCESS !=
            RegQueryInfoKey (hKey,
                             NULL, NULL, NULL,
                             &iRet,
                             NULL, NULL, NULL, NULL, NULL, NULL, NULL))
        {
            LOG ("  Could not get the number of subkeys: %#lx\r\n", GetLastError());
        }

        RegCloseKey (hKey);
    }
    ELSE_LOG((" Could not open System\\CurrentControlSet\\Services\\Class\\Modem: %#lx\r\n", GetLastError()));

    return iRet;
}



void UpdateAnswerFileAndMigrateInf (
    char *szHardwareID,
    char *szCompatibleIDs,
    HKEY  hKeyDrv,
    char *szEnumPath,
    DWORD dwPnPIDTable)
{
 char szDirectory[MAX_PATH];
 char szInf[MAX_PATH];
 WIN32_FIND_DATA FindData;
 int iLengthDir, iLengthInf;
 HANDLE hFindFile;
 char *p;
 BOOL bRet;

    bRet = FALSE;

    // Only update the answer file if we have
    // a hardware ID
    if (NULL != szHardwareID &&
        0 != *szHardwareID)
    {
        // First, get the PortDriver;
        // if we can't read it, assume this is *NOT*
        // a controller-less modems, so go ahead and
        // copy the files (this will probably be a
        // legacy modem).
        iLengthDir = sizeof (szDirectory);
	    if (ERROR_SUCCESS ==
            RegQueryValueExA (hKeyDrv, "PortDriver", NULL, NULL,
        	                  (PBYTE)szDirectory, &iLengthDir))
        {
            if ((CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szDirectory, -1, "serial.vxd", -1) != 2) &&
                (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szDirectory, -1, "wdmmdmld.vxd", -1) != 2))
            {
                // Looks like this modem is not controlled
                // by the system serial driver, so don't do
                // anything.
                return;
            }
        }

        // Is this modem supported in NT5?
        if (0 != dwPnPIDTable)
	{
		LOG("checking for hardware ids\n");
		for (p = szHardwareID; 0 != *p; p += lstrlenA(p)+1)
		{
			if ((bRet = IsPnpIdSupportedByNt (dwPnPIDTable, p)))
			{
				LOG(bRet?"PnPID (%s) was found.\r\n":"Modem %s not supported.\r\n", p);
				break;
			}
			// LOG(bRet?"PnPID %s was found.\r\n":"Modem %s not supported.\r\n", bRet?p:szHardwareID);
			LOG(bRet?"PnPID (%s) was found.\r\n":"Modem %s not supported.\r\n", p);
		}
		if (!bRet)
		{
			LOG("checking for compat ids\n");
			for (p = szCompatibleIDs; 0 != *p; p += lstrlenA(p)+1)
			{
				if ((bRet = IsPnpIdSupportedByNt (dwPnPIDTable, p)))
				{
					LOG(bRet?"PnPID %s was found.\r\n":"Modem %s not supported.\r\n", p);
					break;
				}
				// LOG(bRet?"PnPID %s was found.\r\n":"Modem %s not supported.\r\n", bRet?p:szHardwareID);
				LOG(bRet?"PnPID %s was found.\r\n":"Modem %s not supported.\r\n", p);
			}
		}
	}
        ELSE_LOG(("PnPIDTable is NULL\r\n"));

        if (!bRet)
        {
            // Get the INF name.
            iLengthInf = sizeof (szInf);
	        if (ERROR_SUCCESS !=
                RegQueryValueExA (hKeyDrv, "InfPath", NULL, NULL,
        	                      (PBYTE)szInf, &iLengthInf))
            {
                // If we couldn't read the InfPath,
                // there's nothing we can do.
                return;
            }

            // So now, start looking for the INF.
            iLengthDir = GetWindowsDirectoryA (szDirectory, sizeof (szDirectory));
            if (3 > iLengthDir)
            {
                // Most likely there's some error
                // and iLength is 0;
                // the smallest path would be something
                // like  C:\;
                return;
            }
            if (3 < iLengthDir)
            {
                // this means that the path
                // will not end in a \, so
                // let's add it.
                szDirectory[iLengthDir++] = '\\';
            }

            // Now, append INF and the inf name
            if (sizeof(szDirectory) < iLengthDir + iLengthInf + 5)
            {
                // Not enough memory, just bail.
                return;
            }
            lstrcpyA (szDirectory+iLengthDir, "INF\\");
            iLengthDir += 4;
            lstrcpyA (szDirectory+iLengthDir, szInf);

            // Let's find the INF
            ZeroMemory (&FindData, sizeof(FindData));
            hFindFile = FindFirstFile (szDirectory, &FindData);
            if (INVALID_HANDLE_VALUE == hFindFile)
            {
                LOG("UpdateAnswerFile: could not find %s.\r\n", szDirectory);
                // We didn't find the file in the INF directory;
                // let's try INF\OTHER.
                if (sizeof(szDirectory) < iLengthDir + iLengthInf + 7)
                {
                    // Not enough memory, just bail.
                    return;
                }
                lstrcpyA (szDirectory+iLengthDir, "OTHER\\");
                iLengthDir += 6;
                lstrcpyA (szDirectory+iLengthDir, szInf);

                ZeroMemory (&FindData, sizeof(FindData));
                hFindFile = FindFirstFile (szDirectory, &FindData);

                if (INVALID_HANDLE_VALUE == hFindFile)
                {
                    LOG("UpdateAnswerFile: could not find %s.\r\n", szDirectory);
                    // couldn't find the INF file,
                    // so there's nothing to do.
                    return;
                }
                ELSE_LOG(("UpdateAnswerFile: found %s.\r\n", szDirectory));
            }
            ELSE_LOG(("UpdateAnswerFile: found %s.\r\n", szDirectory));

            FindClose (hFindFile);  // Don't need the handle any more.

            // If we get here, we have the path to an INF, somewhere under WINDOWS\INF.
            // We need to copy the file to the working dir.
            wsprintfA (szInf, "%s%s", g_pszWorkingDir, szDirectory+iLengthDir);
            LOG ("UpdateAnswerFile: copying %s to %s.\r\n", szDirectory, szInf);
            SET(bRet)
            CopyFile (szDirectory, szInf, TRUE);
            ERR(bRet, TRUE, (LOG("UpdateAnswerFile: CopyFile failed: %#lx\r\n", GetLastError ())));
            // At this point, we have a list of IDs (szHardwareID, separated by comma),
            // and the path to the INF for them.
            for (p = szHardwareID; 0 != *p; p += lstrlenA(p)+1)
            {
                LOG("UpdateAnswerFile: WritePrivateProfileString (%s=%s).\r\n", p, szInf);
                SET(bRet)
                WritePrivateProfileStringA ("DeviceDrivers",
                                            p,
                                            szInf,
                                            g_pszUnattendFile);
                ERR(bRet, TRUE, (LOG("UpdateAnswerFile: WritePrivateProfileString failed: %#lx\r\n", GetLastError ())));
            }
        }
    }

    // Now we can update migrate.inf
    wsprintfA (szDirectory, "%smigrate.inf", g_pszWorkingDir);
    wsprintfA (szInf, "HKLM\\%s", szEnumPath);
    LOG("UpdateAnswerFile: WritePrivateProfileString (%s=Registry) to %s.\r\n", szInf, szDirectory);
    SET(bRet)
    WritePrivateProfileStringA ("Handled",
                                szInf,
                                "Registry",
                                szDirectory);
    ERR(bRet, TRUE, (LOG("UpdateAnswerFile: WritePrivateProfileString failed: %#lx\r\n", GetLastError ())));
}


BOOL ReadString (HANDLE hFile, char *szBuffer, DWORD dwSize)
{
 BOOL bRet = FALSE;
 WORD wData;
 DWORD cbRead;

    if (ReadFile (hFile, &wData, sizeof(wData), &cbRead, NULL) &&
        sizeof(wData) == cbRead                                &&
        wData < dwSize)
    {
        if (0 < wData &&
            ReadFile (hFile, szBuffer, wData, &cbRead, NULL) &&
            wData == cbRead)
        {
            *(szBuffer+wData) = 0;
            bRet = TRUE;
        }
    }
    return bRet;
}


DWORD PnPIDTableCreate ()
{
 char szBuffer[MAX_PATH];
 char szSetup[]="\\setup\\";
 char szHwcomp[]="hwcomp.dat";
 char *p;
 DWORD dwTemp;

    InitializeMigLib ();

    // First, check for hwcomp.dat in %windir%\setup
    dwTemp = GetWindowsDirectoryA (szBuffer, sizeof(szBuffer)-sizeof(szSetup)-sizeof(szHwcomp));
    if (0 < dwTemp)
    {
     WIN32_FIND_DATAA findData;
     HANDLE hFindFile;

        p = szBuffer+dwTemp;
        lstrcpyA (p, szSetup);
        p += sizeof(szSetup)-1;
        lstrcpyA (p, szHwcomp);
        hFindFile = FindFirstFileA (szBuffer, &findData);
        if (INVALID_HANDLE_VALUE != hFindFile)
        {
            // We found hwcomp.dat in %windir%\setup.
            // Use it.
            FindClose (hFindFile);
            goto _OpenAndLoadHwCompDat;
        }
    }

    // Didn't find hwcomp.dat in %windir%\setup.
    // Use the one on the sources.
    lstrcpyA (szBuffer, g_pszSourceDir);
    lstrcatA (szBuffer, szHwcomp);

_OpenAndLoadHwCompDat:
    LOG("Trying to open %s.\r\n", szBuffer);
    dwTemp = OpenAndLoadHwCompDat (szBuffer);
    if (0 == dwTemp)
    {
        LOG("OpenAndLoadHwCompDat failed!\r\n");
    }

    return dwTemp;
}


void PnPIDTableDestroy (DWORD dwPnPIDTable)
{
    if (0 != dwPnPIDTable)
    {
        CloseHwCompDat (dwPnPIDTable);
    }
    TerminateMigLib ();
}


static HANDLE OpenProvidersFile (void)
{
 HANDLE hFile;
 char szFile[MAX_PATH] = "";

    lstrcpyA (szFile, g_pszWorkingDir);
    lstrcatA (szFile, "TP");

    hFile = CreateFileA (szFile,
                         GENERIC_READ | GENERIC_WRITE,
                         0,
                         NULL,
                         CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                         NULL);

#ifdef DO_LOG
    if (INVALID_HANDLE_VALUE == hFile)
    {
        LOG(" Could not create %s: %#lx\r\n", szFile, GetLastError());
    }
    else
    {
        LOG(" Created %s\r\n", szFile);
    }
#endif //DO_LOG

    return hFile;
}

void DoTapiProviders (void)
{
 HANDLE hFile;
 HKEY   hKeyProviders;
 DWORD  cbData;
 DWORD  dwProviderNr;
 DWORD  dwProviderID;
 char  szProviderFileName[24];  // Enough to hold "ProviderFileNameXXXXX\0"
 char  szProviderID[16];        // Enough to hold "ProviderIDxxxxx\0"
 char  szFileName[PROVIDER_FILE_NAME_LEN];
 char  *pProviderFileNameNumber, *pProviderIDNumber;
 TAPI_SERVICE_PROVIDER Provider;

 char szDirectory[MAX_PATH];
 DECLARE(BOOL,bRet);

    LOG("Entering DoTapiProviders\r\n");

    if (ERROR_SUCCESS !=
        RegCreateKeyExA (HKEY_LOCAL_MACHINE, REGKEY_PROVIDERS, 0, NULL, REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS, NULL, &hKeyProviders, &cbData))
    {
        goto _WriteInf;
    }

    hFile = OpenProvidersFile ();
    if (INVALID_HANDLE_VALUE == hFile)
    {
        RegCloseKey (hKeyProviders);
        goto _WriteInf;
    }

    // Initialize value names and pointers
    lstrcpyA (szProviderFileName, REGVAL_PROVIDERFILENAME);
    lstrcpyA (szProviderID, REGVAL_PROVIDERID);
    pProviderFileNameNumber = szProviderFileName + lstrlenA (szProviderFileName);
    pProviderIDNumber = szProviderID + lstrlenA (szProviderID);

    for (dwProviderNr = 0; TRUE; dwProviderNr++)
    {
        wsprintfA (pProviderFileNameNumber, "%d", dwProviderNr);
        lstrcpyA (pProviderIDNumber, pProviderFileNameNumber);

        cbData = sizeof (szFileName);
        if (ERROR_SUCCESS !=
            RegQueryValueExA (hKeyProviders, szProviderFileName, NULL, NULL, (PBYTE)szFileName, &cbData))
        {
            break;
        }

        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szFileName, -1, TSP3216l, -1) == 2)
        {
            continue;
        }

        cbData = sizeof (dwProviderID);
        if (ERROR_SUCCESS !=
            RegQueryValueEx (hKeyProviders, szProviderID, NULL, NULL, (PBYTE)&dwProviderID, &cbData))
        {
            // This is not one of the default providers, and we
            // couldn't read it's provider ID. We must skip it.
            continue;
        }

        // We have a provider that was installed by the user on the previous NT installation.
        Provider.dwProviderID = dwProviderID;
        lstrcpyA (Provider.szProviderName, szFileName);
        LOG("Writing %s, %d\r\n", Provider.szProviderName, Provider.dwProviderID);
        WriteFile (hFile, (PVOID)&Provider, sizeof(Provider), &cbData, NULL);
    }

    RegCloseKey (hKeyProviders);
    CloseHandle (hFile);

_WriteInf:
    wsprintfA (szDirectory, "%smigrate.inf", g_pszWorkingDir);
    LOG("DoTapiStuff: WritePrivateProfileString (HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Provider4096=Registry) to %s.\r\n", szDirectory);
    SET(bRet)
    WritePrivateProfileStringA ("Handled",
                                "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Provider4096",
                                "Registry",
                                szDirectory);
    ERR(bRet, TRUE, (LOG("DoTapiStuff: WritePrivateProfileString failed: %#lx\r\n", GetLastError ())));

    LOG("DoTapiStuff: WritePrivateProfileString (HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers=Registry) to %s.\r\n", szDirectory);
    SET(bRet)
    WritePrivateProfileStringA ("Handled",
                                "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers",
                                "Registry",
                                szDirectory);
    ERR(bRet, TRUE, (LOG("DoTapiStuff: WritePrivateProfileString failed: %#lx\r\n", GetLastError ())));

    LOG("Exiting DoTapiProviders.\r\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\connify.h ===
#ifndef _CONNIFY_INCLUDED
#define _CONNIFY_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

DWORD
MprConnectNotifyInit(
    VOID
    );

DWORD
MprAddConnectNotify(
    LPNOTIFYINFO        lpNotifyInfo,
    LPNOTIFYADD         lpAddInfo
    );

DWORD
MprCancelConnectNotify(
    LPNOTIFYINFO        lpNotifyInfo,
    LPNOTIFYCANCEL      lpCancelInfo
    );

PVOID
MprAllocConnectContext(
    VOID
    );

VOID
MprFreeConnectContext(
    PVOID   ConnectContext
    );

#ifdef __cplusplus
}
#endif

#endif // _CONNIFY_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\connperf.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    connperf.cxx

Abstract:

    Contains the entry points for the WinNet Resource Info API supported
    by the Multi-Provider Router.  The following functions are in this file:

        MultinetGetConnectionPerformanceW

Author:

    Anirudh Sahni (anirudhs) 22-Jan-1996

Environment:

    User Mode -Win32

Notes:


Revision History:

    22-Jan-1996     anirudhs
        Created

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/
//
// INCLUDES
//
#include "precomp.hxx"


//===================================================================
// CGetConnection
//
// This class retrieves the remote name and provider responsible for
// a redirected device.
// CODEWORK:  This can/should replace MprGetConnection if we can be
// sure that the error picking logic is equivalent.  Code needs to be
// added to handle remembered connections.
//===================================================================

class CGetConnection : public CRoutedOperation
{
public:
                    CGetConnection(
                        LPWSTR          lpLocalName,    // IN
                        LPWSTR          lpRemoteName,   // OUT
                        LPDWORD         lpBufferSize,   // IN OUT
                        LPWSTR          lpProviderName  // IN OPTIONAL
                        ) :
                            CRoutedOperation(DBGPARM("GetConnection")
                                             PROVIDERFUNC(GetConnection)),
                            _lpLocalName    (lpLocalName),
                            _lpRemoteName   (lpRemoteName),
                            _lpBufferSize   (lpBufferSize),
                            _lpProviderName (lpProviderName)
                        { }

    PROVIDER *      LastProvider() const  // expose the base class' method
                        { return (CRoutedOperation::LastProvider()); }

private:

    LPWSTR          _lpLocalName;
    LPWSTR          _lpRemoteName;
    LPDWORD         _lpBufferSize;
    LPWSTR          _lpProviderName;

    DECLARE_CROUTED
};


DWORD
CGetConnection::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    if (MprDeviceType(_lpLocalName) != REDIR_DEVICE)
    {
        return WN_BAD_LOCALNAME;
    }

    //
    // Let the base class validate the provider name, if one was supplied
    //
    *ppProviderName = _lpProviderName;
    *ppLocalName    = _lpLocalName;

    return WN_SUCCESS;
}


DWORD
CGetConnection::TestProvider(
    const PROVIDER * pProvider
    )
{
    ASSERT_INITIALIZED(NETWORK);

    return pProvider->GetConnection(_lpLocalName, _lpRemoteName, _lpBufferSize);
}



//===================================================================
// MultinetGetConnectionPerformanceW
//===================================================================

class CGetConnectionPerformance : public CRoutedOperation
{
public:
                    CGetConnectionPerformance(
                        LPNETRESOURCEW          lpNetResource,
                        LPNETCONNECTINFOSTRUCT  lpNetConnectInfo
                        ) :
                            CRoutedOperation(DBGPARM("GetConnectionPerformance")
                                             PROVIDERFUNC(GetConnectionPerformance)),
                            _lpNetResource   (lpNetResource),
                            _lpNetConnectInfo(lpNetConnectInfo)
                        { }

private:

    LPNETRESOURCEW          _lpNetResource;
    LPNETCONNECTINFOSTRUCT  _lpNetConnectInfo;

    LPWSTR          _pRemoteName;
    WCHAR           _wszBuffer[MAX_PATH+1];

    DECLARE_CROUTED
};


DWORD
CGetConnectionPerformance::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    if (!(ARGUMENT_PRESENT(_lpNetResource) &&
          ARGUMENT_PRESENT(_lpNetConnectInfo)))
    {
        return WN_BAD_POINTER;
    }

    if (_lpNetConnectInfo->cbStructure < sizeof(NETCONNECTINFOSTRUCT))
    {
        return WN_BAD_VALUE;
    }

    //
    // Zero out the output structure, except for the first field.
    //
    memset((&_lpNetConnectInfo->cbStructure) + 1,
           0,
           sizeof(*_lpNetConnectInfo) - sizeof(_lpNetConnectInfo->cbStructure));

    if (IS_EMPTY_STRING(_lpNetResource->lpLocalName))
    {
        //
        // No local name is specified, so a remote name should be specified.
        //
        _pRemoteName = _lpNetResource->lpRemoteName;
        if (IS_EMPTY_STRING(_pRemoteName))
        {
            return WN_BAD_NETNAME;
        }

        // Let the base class validate the provider name, if specified.
        *ppProviderName = _lpNetResource->lpProvider;
    }
    else
    {
        //
        // A local name is specified.  Try to identify the remote name,
        // and, as a side effect, the provider that made the connection.
        //
        DWORD cchBuffer = LENGTH(_wszBuffer);
        CGetConnection GetConn(_lpNetResource->lpLocalName,
                               _wszBuffer,
                               &cchBuffer,
                               _lpNetResource->lpProvider);
        DWORD status = GetConn.Perform(FALSE);

        if (status != WN_SUCCESS)
        {
            ASSERT(status != WN_MORE_DATA);
            return status;
        }

        _pRemoteName = _wszBuffer;

        // A somewhat roundabout way of telling the base class the real provider
        *ppProviderName = GetConn.LastProvider()->Resource.lpProvider;
    }

    // Have the base class cache the remote name (again).  Note that
    // the local name, if present, was checked by CGetConnection
    *ppRemoteName = _pRemoteName;
    *ppLocalName  = NULL;

    return WN_SUCCESS;
}


DWORD
CGetConnectionPerformance::TestProvider(
    const PROVIDER * pProvider
    )
{
    ASSERT_INITIALIZED(NETWORK);

    //
    // CODEWORK -- We should try to resolve the local name here
    //             per connection and if it succeeds, then call
    //             the provider's GetConnectionPerformance.  We
    //             could then remove the use of CGetConnection
    //             from ValidateRoutedParameters.
    //
    return (pProvider->GetConnectionPerformance(
                            _pRemoteName,
                            _lpNetConnectInfo));
}


DWORD
MultinetGetConnectionPerformanceW(
    LPNETRESOURCEW          lpNetResource,
    LPNETCONNECTINFOSTRUCT  lpNetConnectInfo
    )
/*++

Routine Description:

    This API returns information about the expected performance of a
    connection used to access a network resource.

Arguments:

    lpNetResource -

    lpNetConnectInfo -

Return Value:

    WN_SUCCESS - Indicates the operation was successful.

    Other errors -

--*/
{
    CGetConnectionPerformance GetConnPerf(lpNetResource, lpNetConnectInfo);

    return (GetConnPerf.Perform(TRUE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\connify.cxx ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    connify.cxx

Abstract:

    Contains code used to notify all DLLs interested in notifiable MPR
    Events.  Currently only connection information results in
    notification.

Author:

    Dan Lafferty (danl)     14-Dec-1993

Environment:

    User Mode -Win32

Revision History:

    14-Dec-1993     danl
        created

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include "connify.h"    // MprAddConnectNotify


//===================
// TYPEDEFs
//===================
typedef struct _NOTIFYEE {
    PF_AddConnectNotify         PF_AddConnectNotify;
    PF_CancelConnectNotify      PF_CancelConnectNotify;
    HINSTANCE                   DllHandle;
}NOTIFYEE, *LPNOTIFYEE;

//===================
// DEFINES
//===================
#define NOTIFYEE_ROOT   TEXT("system\\CurrentControlSet\\Control\\NetworkProvider\\Notifyees")


//===================
// GLOBALs
//===================
//
// A pointer to an array of NOTIFYEE structures.
// These are only modified by MprConnectNotifyInif.
// The MprInitCritSec is obtained prior to calling
// MprConnectNotifyInit.
//
    LPNOTIFYEE  NotifyList = NULL;
    DWORD       GlobalNumNotifyees = 0;



DWORD
MprConnectNotifyInit(
    VOID
    )

/*++

Routine Description:

    This function does the following:
    1)  Look in the registry to determine which DLLs want to be notified of
        Connection Events.
    2)  Load the Notifiee DLLs.
    3)  Obtain the entry points for the notify functions.
    4)  Create a list of all the Notifiee Information.

Arguments:

    NONE

Return Value:

    WN_SUCCESS


--*/
{
    HKEY    notifyeeRootKey;
    DWORD   status;
    DWORD   numSubKeys;
    DWORD   cchMaxSubKey;
    DWORD   numValues;
    DWORD   cchMaxValueName;
    DWORD   type;
    DWORD   bufSize;
    TCHAR   dllPath[MAX_PATH];
    TCHAR   buffer[MAX_PATH];
    LPTSTR  expandedPath=NULL;
    DWORD   nameSize;
    HINSTANCE   hLib=NULL;
    DWORD   i;
    DWORD   numReqd;
    LPNOTIFYEE  NotifyEntry;

    //
    // Read the Registry Information for Notifiees.
    // If the key doesn't exist, then there is no one to notify.
    //
    if (!MprOpenKey (
            HKEY_LOCAL_MACHINE,     // hKey
            NOTIFYEE_ROOT,          // lpSubKey
            &notifyeeRootKey,       // Newly Opened Key Handle
            DA_READ)) {             // Desired Access

        MPR_LOG0(CNOTIFY,"MprConnectInfoInit: NOTIFYEE_ROOT doesen't exist\n");
        return(WN_SUCCESS);
    }

    //
    // GetKeyInfo (find out how many values)
    //

    if (!MprGetKeyInfo (
                notifyeeRootKey,
                NULL,
                &numSubKeys,
                &cchMaxSubKey,
                &numValues,
                &cchMaxValueName)) {

        RegCloseKey( notifyeeRootKey );
        MPR_LOG0(CNOTIFY,"MprConnectInfoInit: Couldn't get key info\n");
        return(WN_SUCCESS);
    }
    MPR_LOG1(CNOTIFY,"MprConnectInfoInit: GlobalNumNotifyees = %d\n",numValues);

    //
    // Allocate space for that many notifyees.
    //
    if (numValues == 0) {
        RegCloseKey( notifyeeRootKey );
        return(WN_SUCCESS);
    }

    NotifyList = (LPNOTIFYEE) LocalAlloc(LPTR,numValues * sizeof(NOTIFYEE));
    if (NotifyList == NULL) {
        RegCloseKey( notifyeeRootKey );
        return(GetLastError());
    }

    NotifyEntry = NotifyList;
    //
    // Load the Notifyees and get their entry points.
    //
    for (i=0; i<numValues; i++) {
        bufSize  = MAX_PATH * sizeof (TCHAR);
        nameSize = MAX_PATH;
        expandedPath = NULL;

        status = RegEnumValue(
                    notifyeeRootKey,
                    i,
                    buffer,
                    &nameSize,
                    NULL,
                    &type,
                    (LPBYTE)dllPath,
                    &bufSize);

        if (status != NO_ERROR) {
            MPR_LOG0(CNOTIFY,"MprConnectInfoInit: RegEnumValue failure\n");
        }
        else {
            switch (type) {
            case REG_EXPAND_SZ:
                numReqd = ExpandEnvironmentStrings(dllPath,buffer,MAX_PATH);
                if (numReqd > MAX_PATH) {
                    expandedPath = (LPTSTR) LocalAlloc(LMEM_FIXED,numReqd*sizeof(TCHAR) );
                    if (expandedPath == NULL) {
                        //
                        // We can't expand the string, so we skip this notifyee
                        // and go onto the next.
                        //
                        status = GetLastError();
                        break;  // Leave the switch and cleanup this notifyee
                    }
                    numReqd = ExpandEnvironmentStrings(dllPath,expandedPath,numReqd);
                    if (numReqd > MAX_PATH) {
                        MPR_LOG0(CNOTIFY,"MprConnectNotifyInit: Couldn't Expand Path\n");
                        status = ERROR_BAD_LENGTH;
                        break;  // Leave the switch and cleanup this notifyee
                    }
                }
                else {
                    expandedPath = buffer;
                }

                // Fall thru to the REG_SZ case....

            case REG_SZ:
                if (expandedPath == NULL) {
                    expandedPath = dllPath;
                }
                //
                // Load the DLL
                //
                hLib =  LoadLibraryEx(expandedPath,
                                      NULL,
                                      LOAD_WITH_ALTERED_SEARCH_PATH);
                if (hLib == NULL) {
                    status = GetLastError();
                    MPR_LOG2(CNOTIFY,"MprConnectInfoInit:LoadLibraryEx for %ws failed %d\n",
                        expandedPath, status);

                    break;  // Leave the switch and cleanup this notifyee
                }

                //
                // Get the Entry Points from the DLL.
                //
                NotifyEntry->PF_AddConnectNotify =
                    (PF_AddConnectNotify)GetProcAddress(hLib,"AddConnectNotify");
                NotifyEntry->PF_CancelConnectNotify =
                    (PF_CancelConnectNotify)GetProcAddress(hLib,"CancelConnectNotify");

                //
                // If and Only If both functions are supported, then increment
                // the NotifyList.
                //
                if ((NotifyEntry->PF_AddConnectNotify != NULL) &&
                    (NotifyEntry->PF_CancelConnectNotify != NULL)) {
                    NotifyEntry->DllHandle = hLib;
                    NotifyEntry++;
                    GlobalNumNotifyees++;
                    MPR_LOG1(CNOTIFY,"MprConnectInfoInit: Item added to "
                    "notify list %d\n",GlobalNumNotifyees);
                }
                else {
                    FreeLibrary (hLib);
                    hLib = NULL;
                }
                break;

            default:
                break;
            }
        }

        //
        // Cleanup resources for this notifyee
        //
        if ((expandedPath != NULL)      &&
            (expandedPath != dllPath)   &&
            (expandedPath != buffer)) {
            LocalFree(expandedPath);
        }

    }  // End for(Each Notifyee)

    if (GlobalNumNotifyees == 0) {
        if (NotifyList != NULL) {
            LocalFree(NotifyList);
            NotifyList = NULL;
        }
    }

    RegCloseKey(notifyeeRootKey);
    return(WN_SUCCESS);
}

VOID
MprCleanupNotifyInfo(
    VOID
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD   i;

    ASSERT_INITIALIZED(NOTIFIEE);

    for (i=0; i<GlobalNumNotifyees; i++ ) {
        FreeLibrary(NotifyList[i].DllHandle);
    }
    LocalFree(NotifyList);
    return;
}


PVOID
MprAllocConnectContext(
    VOID
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    ASSERT_INITIALIZED(NOTIFIEE);

    if (GlobalNumNotifyees == 0) {
        return(NULL);
    }
    MPR_LOG1(CNOTIFY,"In MprAllocConnectContext.  Allocating for %d notifyees\n",
        GlobalNumNotifyees);

    return(PVOID)(LocalAlloc(LPTR,sizeof(PVOID) * GlobalNumNotifyees));
}


VOID
MprFreeConnectContext(
    PVOID   ConnectContext
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    MPR_LOG0(CNOTIFY,"In MprFreeConnectContext\n");
    LocalFree(ConnectContext);
}


DWORD
MprAddConnectNotify(
    LPNOTIFYINFO        lpNotifyInfo,
    LPNOTIFYADD         lpAddInfo
    )

/*++

Routine Description:

    This function calls all the Notifyees if an add connection event.

Arguments:

    lpNotifyInfo -
    lpAddInfo -

Return Value:

    If any of the notifyees returns WN_CANCEL, the notification is immediately
    aborted and the WN_CANCEL is returned from the caller.
    Aside from that error, if WN_RETRY is returned from any notifyee, then
    WN_RETRY is returned to the caller.  Otherwise, the last error is returned.
    If all notifyees return WN_SUCCESS, then the last error will be WN_SUCCESS.

--*/
{
    DWORD   i;
    DWORD   status;
    DWORD   lastError=WN_SUCCESS;
    BOOL    retryFlag=FALSE;
    DWORD   numNotifyees = GlobalNumNotifyees;
    PVOID   *ContextInfo;
    LPNOTIFYEE  NotifyEntry=NotifyList;

    MPR_LOG0(CNOTIFY,"In MprAddConnectNotify\n");

    ASSERT_INITIALIZED(NOTIFIEE);

    //
    // Save away the pointer to the array of context information.
    //
    ContextInfo = (PVOID *) lpNotifyInfo->lpContext;

    for (i=0; i<numNotifyees; i++,NotifyEntry++ )
    {
        if (lpNotifyInfo->dwNotifyStatus == NOTIFY_POST)
        {
            if (ContextInfo && ContextInfo[i] != NULL)
            {
                lpNotifyInfo->lpContext = ContextInfo[i];
            }
            else
            {
                //
                // Don't notify if it is a POST notification, and there
                // is no context saved.  Here we go directly to the next
                // notifyee (or out of the for loop).
                //
                continue;
            }
        }

        status = NotifyEntry->PF_AddConnectNotify(lpNotifyInfo,lpAddInfo);

        switch (status) {
        case WN_SUCCESS:
            MPR_LOG0(CNOTIFY,"AddConnectNotify SUCCESS\n");

            if (ContextInfo != NULL)
            {
                ContextInfo[i] = lpNotifyInfo->lpContext;
            }

            break;

        case WN_CANCEL:
            MPR_LOG0(CNOTIFY,"AddConnectNotify WN_CANCEL\n");
            //
            // CANCEL shouldn't be returned from NOTIFY_POST calls.
            //
            if (lpNotifyInfo->dwNotifyStatus == NOTIFY_PRE) {
                //
                // If we got the cancel for the first notifyee, then we can
                // stop here.
                //
                if (i == 0) {
                    lpNotifyInfo->lpContext = ContextInfo;
                    return(status);
                }
                //
                // If we have already successfully called some notifyees, then we
                // must now post notify them of the cancel.
                //
                numNotifyees = i;
                lpNotifyInfo->dwNotifyStatus = NOTIFY_POST;
                i = 0xffffffff;
            }
            break;

        case WN_RETRY:
            MPR_LOG0(CNOTIFY,"AddConnectNotify WN_RETRY\n");
            //
            // RETRY is only valid if the operation failed and
            // this is a post notification.
            //
            if ((lpNotifyInfo->dwOperationStatus != WN_SUCCESS) &&
                (lpNotifyInfo->dwNotifyStatus == NOTIFY_POST)) {

                retryFlag = TRUE;

                if (ContextInfo != NULL)
                {
                    ContextInfo[i] = lpNotifyInfo->lpContext;
                }

                //
                // If we need to retry, then we must now pre-notify those
                // notifyees that we have already post-notified.  We don't
                // want to post-notify any more notifyees.
                //

                if (i > 0) {
                    numNotifyees = i;
                    lpNotifyInfo->dwNotifyStatus = NOTIFY_PRE;
                    i = 0xffffffff;
                }
            }
            break;

        default:
            MPR_LOG1(CNOTIFY,"AddConnectNotify returned an error %d\n",status);
            lastError = status;
            break;
        }
    }
    //
    // Restore the pointer to the array of context information.
    //
    lpNotifyInfo->lpContext = ContextInfo;

    //
    // No matter if other error occured, if one of the notifyees wants
    // a retry, we will return retry.
    //
    if (retryFlag == TRUE) {
        return(WN_RETRY);
    }
    return(lastError);
}

DWORD
MprCancelConnectNotify(
    LPNOTIFYINFO        lpNotifyInfo,
    LPNOTIFYCANCEL      lpCancelInfo
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD   i;
    DWORD   status;
    DWORD   lastError=WN_SUCCESS;
    BOOL    retryFlag=FALSE;
    DWORD   numNotifyees = GlobalNumNotifyees;
    PVOID   *ContextInfo;
    LPNOTIFYEE  NotifyEntry=NotifyList;

    MPR_LOG0(CNOTIFY,"In MprCancelConnectNotify\n");

    ASSERT_INITIALIZED(NOTIFIEE);

    //
    // Save away the pointer to the array of context information.
    //
    ContextInfo = (PVOID *) lpNotifyInfo->lpContext;

    for (i=0; i<numNotifyees; i++,NotifyEntry++)
    {
        if (lpNotifyInfo->dwNotifyStatus == NOTIFY_POST)
        {
            if (ContextInfo && ContextInfo[i] != NULL)
            {
                lpNotifyInfo->lpContext = ContextInfo[i];
            }
            else
            {
                //
                // Don't notify if it is a POST notification, and there
                // is no context saved.  Here we go directly to the next
                // notifyee (or out of the for loop).
                //
                continue;
            }
        }

        status = NotifyEntry->PF_CancelConnectNotify(lpNotifyInfo,lpCancelInfo);

        switch (status) {
        case WN_SUCCESS:
            MPR_LOG0(CNOTIFY,"CancelConnectNotify SUCCESS\n");

            if (ContextInfo != NULL)
            {
                ContextInfo[i] = lpNotifyInfo->lpContext;
            }

            break;

        case WN_CANCEL:
            MPR_LOG0(CNOTIFY,"CancelConnectNotify WN_CANCEL\n");
            //
            // It is assumed that CANCEL won't be returned from
            // NOTIFY_POST calls.
            //
            // If we got the cancel for the first notifyee, then we can
            // stop here.
            //
            if (i == 0) {
                lpNotifyInfo->lpContext = ContextInfo;
                return(status);
            }
            //
            // If we have already successfully called some notifyees, then we
            // must now post notify them of the cancel.
            //
            numNotifyees = i;
            lpNotifyInfo->dwNotifyStatus = NOTIFY_POST;
            i = 0xffffffff;
            break;

        case WN_RETRY:
            MPR_LOG0(CNOTIFY,"CancelConnectNotify WN_RETRY\n");
            retryFlag = TRUE;

            if (ContextInfo != NULL)
            {
                ContextInfo[i] = lpNotifyInfo->lpContext;
            }

            break;

        default:
            MPR_LOG1(CNOTIFY,"CancelConnectNotify returned an error %d\n",status);
            lastError = status;
            break;
        }
    }

    //
    // Restore the pointer to the array of context information.
    //
    lpNotifyInfo->lpContext = ContextInfo;

    //
    // No matter if other error occured, if one of the notifyees wants
    // a retry, we will return retry.
    //
    if (retryFlag == TRUE) {
        return(WN_RETRY);
    }
    return(lastError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\connect.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    connect.cxx

Abstract:

    Contains the entry points for the Winnet Connection API supported by the
    Multi-Provider Router.
    Contains:
        WNetAddConnectionW
        WNetAddConnection2W
        WNetAddConnection3W
        WNetUseConnectionW
        WNetCancelConnection2W
        WNetCancelConnectionW
        WNetGetConnectionW
        WNetSetConnectionW
        WNetRestoreConnectionW
        WNetRestoreConnection2W
        DoRestoreConnection
        MprRestoreThisConnection
        MprCreateConnectionArray
        MprSortConnectionArray
        MprRefcountConnectionArray
        MprAddPrintersToConnArray
        MprForgetPrintConnection
        MprFreeConnectionArray
        MprNotifyErrors
        MprNotifyShell
        MprCancelConnection2

Author:

    Dan Lafferty (danl)     09-Oct-1991

Environment:

    User Mode -Win32

Notes:

Revision History:

    09-Oct-1991     danl
        created
    03-Jan-1992     terryk
        Changed WNetRestoreConnections WNetRestoreConnection
    13-Jan-1992     Johnl
        Added MPR.H to include file list
    31-Jan-1992     Johnl
        Added fForgetConnection to WNetCancelConnectionW
    01-Apr-1992     Johnl
        Changed CONNECTION_REMEMBER to CONNECT_UPDATE_PROFILE, updated
        WNetCancelConnection2 to match spec
    22-Jul-1992     danl
        WNetAddConnection2:  If attempting to connect to a drive that is
        already remembered in the registry, we will allow the connect as
        long as the remote name for the connection is the same as the
        one that is remembered.  If the remote names are not the same
        return ERROR_DEVICE_ALREADY_REMEMBERED.
    26-Aug-1992     danl
        WNetAddConnectionW:  Put Try & except around STRLEN(lpLocalName).
    04-Sept-1992    danl
        Re-Write MprRestoreThisConnection.
    08-Sept-1992    danl
        WNetCancelConnect2W:  If no providers claim responsibility for
        the cancel, and if the connect info is in the registry, then
        remove it, and return SUCCESS.
    09-Sept-1992    danl
        WNetCancelConnect2W: If the provider returns WN_BAD_LOCALNAME,
        WN_NO_NETWORK, or WN_BAD_NETNAME, then return WN_NOT_CONNECTED.
    22-Sept-1992    danl
        WNetRestoreConnection: For WN_CANCEL case, set continue Flag to false.
        We don't want to ask for password again if they already said CANCEL.
    02-Nov-1992     danl
        Fail with NO_NETWORK if there are no providers.
    24-Nov-1992     Yi-HsinS
        Added checking in the registry to see whether we need to
        restore connection or not. ( support of RAS )
    16-Nov-1993     Danl
        AddConnect2:  If provider returns ERROR_INVALID_LEVEL or
        ERROR_INVALID_PARAMETER, continue trying other providers.
    19-Apr-1994     Danl
        DoRestoreConnection:  Fix timeout logic where we would ignore the
        provider-supplied timeout if the timeout was smaller than the default.
        Now, if all the providers know their timeouts, the larger of those
        timeouts is used.  Even if smaller than the default.
        AddConnection3:  Fixed Prototype to be more like AddConnection2.
    19-May-1994     Danl
        AddConnection3:  Changed comments for dwType probe to match the code.
        Also re-arrange the code here to make it more efficient.
    07-Feb-1995     AnirudhS
        MprGetConnection:  Fixed so that, like AddConnection and
        CancelConnection, it doesn't stop routing on errors.
    10-Feb-1995     AnirudhS
        WNetAddConnection3:  If provider returns WN_ALREADY_CONNECTED, stop
        trying other providers.
    08-May-1995     AnirudhS
        Add WNetUseConnection and make WNetAddConnection3 call through to it.
    12-Jun-1995     AnirudhS
        Send WM_DEVICECHANGE message to notify shell of connections.
    13-Jun-1995     AnirudhS
        Add WNetSetConnection.
    07-Jul-1995     AnirudhS
        Tidy up auto-picking logic in WNetUseConnection and CAutoPickedDevice.
    12-Jul-1995     AnirudhS
        Rename WNetRestoreConnection to WNetRestoreConnectionW to match
        winnetwk.w.
    14-Sep-1995     AnirudhS
        WNetGetConnection: Optimize for non-network drives by not calling
        the providers.  This enables the shell to open the "My Computer"
        folder much quicker.
    18-Oct-1995     AnirudhS
        WNetUseConnection: When saving the connection to the registry, if a
        username is not supplied, get it from the provider, so that the
        right username will be used at the next logon.
    15-Jan-1996     AnirudhS
        WNetRestoreConnection, etc.: Restore the connections in a deferred
        state if the remembered user name is the default user.
    08-Mar-1996     AnirudhS
        WNetRestoreConnection, etc.: Use the provider type in preference to
        the provider name when saving and restoring connections, so that
        floating profiles work in a multi-language environment.  See
        comments at MprReadConnectionInfo for details.
    20-Mar-1996     Anirudhs
        Add WNetGetConnection3.
    25-Mar-1996     AnirudhS
        WNetRestoreConnection, etc.: Don't display the "restoring connections"
        dialog if all connections are deferred.  Don't defer connections if
        a registry flag says not to.
    11-Apr-1996     AnirudhS
        WNetUseConnection: Convert to CRoutedOperation base class.
        Return WN_NO_MORE_DEVICES instead of WN_NO_MORE_ENTRIES.
    04-Jun-1996     AnirudhS
        WNetRestoreConnection: Don't defer connections if logged on locally.
        This is a temporary fix for bug 36827 for NT 4.0.
    07-Jun-1996     AnirudhS
        MprNotifyShell: Don't call BroadcastSystemMessage here.  Instead use
        a simple scheme to have a trusted system component broadcast on our
        behalf.  This fixes a deadlock that caused 20-second delays that were
        visible to the user.
    28-Jun-1996     AnirudhS
        Don't defer a connection if a password was explicitly supplied when
        the connection was made.
    08-Feb-1997     AnirudhS
        QFE 55011: Add WN_CONNECTED_OTHER_PASSWORD so the MPR knows if the
        provider prompted the user for an explicit password.
    21-Feb-1997     AnirudhS
        Add DEFER_UNKNOWN so MPR automatically discovers whether to defer a
        connection at future logons.
    03-Mar-1998     jschwart
        Fix bugs caused by moving WNetRestoreConnection from userinit.exe
        into winlogon.exe:  Add impersonation code to WNetRestoreConnection
        so a reconnection is attempted in the user's context.  Add code to
        close registry key handles that were leaked inWNetRestoreConnection,
        MprRestoreThisConnection, and CreateConnectionArray.
    05-May-1999     jschwart
        Make provider addition/removal dynamic
    04-Mar-2000     dsheldon
        Added WNetRestoreConnection2W with a flags field that allows us to
        reduce the amount of user interaction required to reconnect drives,
        and allow the shell to handle errors after logon instead.

--*/

//
// INCLUDES
//

#include "precomp.hxx"
extern "C" {
#include <ntlsa.h>      // LsaGetUserName
#include <winsvcp.h>    // SC_BSM_EVENT_NAME
}
#include <wincred.h>

#include <shellapi.h>
#include <shlapip.h>

#include <tstr.h>       // WCSSIZE, STRLEN
#include "connify.h"    // MprAddConnectNotify
#include "mprui.h"      // ShowReconnectDialog, etc.
#include <apperr.h>


//
// DATA STRUCTURES
//

typedef struct _CONNECTION_INFO
{
    BOOL                  ContinueFlag;
    DWORD                 ProviderIndex;
    DWORD                 ProviderWait;
    DWORD                 ProviderFlags;
    DWORD                 DeferFlags;     // flags read from registry
    DWORD                 Status;
    LPTSTR                UserName;
    BOOL                  Defer;          // our computed decision on whether to defer
    NETRESOURCEW          NetResource;
    HKEY                  RegKey;         // handle to the key with the connection info
    HINSTANCE             hProviderDll;   // Variables to keep provider DLLs loaded
    PF_NPGetCaps          pfGetCaps;
    PF_NPAddConnection3   pfAddConnection3;
    PF_NPAddConnection    pfAddConnection;
    PF_NPCancelConnection pfCancelConnection;
    DWORD                 dwConnectCaps;
}
CONNECTION_INFO, *LPCONNECTION_INFO;


//
// EXTERNAL GLOBALS
//

    extern  DWORD       GlobalNumActiveProviders;
    extern  BOOL        g_LUIDDeviceMapsEnabled;

//
// Defines
//

#define INVALID_WINDOW_HANDLE    ((HWND) INVALID_HANDLE_VALUE)


//
// Local Function Prototypes
//

VOID
DoRestoreConnection(
    PARAMETERS *        Params
    );

DWORD
MprRestoreThisConnection(
    HWND                hWnd,
    PARAMETERS *        Params,
    LPCONNECTION_INFO   ConnectInfo,
    DWORD               dwFlags
    );

DWORD
MprCreateConnectionArray(
    LPDWORD             lpNumConnections,
    LPCTSTR             lpDevice,
    LPDWORD             lpRegMaxWait,
    LPCONNECTION_INFO   *ConnectArray
    );

VOID
MprSortConnectionArray(
    LPCONNECTION_INFO lpcConnectArray,
    DWORD             dwNumSubKeys
    );

VOID
MprRefcountConnectionArray(
    LPCONNECTION_INFO lpcConnectArray,
    DWORD             dwNumSubkeys
    );

DWORD
MprAddPrintersToConnArray(
    LPDWORD             lpNumConnections,
    LPCONNECTION_INFO   *ConnectArray
    );

VOID
MprFreeConnectionArray(
    LPCONNECTION_INFO   ConnectArray,
    DWORD               NumConnections
    );

BOOL
MprUserNameMatch (
    IN  PUNICODE_STRING DomainName,
    IN  PUNICODE_STRING UserName,
    IN  LPCWSTR         RememberedName,
    IN  BOOL            fMustMatchCompletely
    );

DWORD
MprNotifyErrors(
    HWND                hWnd,
    LPCONNECTION_INFO   ConnectArray,
    DWORD               NumConnections,
    DWORD               dwFlags
    );

VOID
MprNotifyShell(
    IN LPCWSTR          pwszDevice
    );

DWORD
MprCancelConnection2 (
    IN  LPCWSTR  lpName,
    IN  DWORD    dwFlags,
    IN  BOOL     fForce,
    IN  BOOL     fCheckProviders
    );

BOOL
MprBroadcastDriveChange(
    IN LPCWSTR          pwszDevice,
    IN BOOL             DeleteAction
    );

DWORD
WNetAddConnectionW (
    IN  LPCWSTR  lpRemoteName,
    IN  LPCWSTR  lpPassword,
    IN  LPCWSTR  lpLocalName
    )

/*++

Routine Description:

    This function allows the caller to redirect (connect) a local device
    to a network resource.  The connection is remembered.

Arguments:

    lpRemoteName -  Specifies the network resource to connect to.

    lpPassword - Specifies the password to be used in making the connection.
        The NULL value may be passed in to indicate use of the 'default'
        password.  An empty string may be used to indicate no password.

    lpLocalName - This should contain the name of a local device to be
        redirected, such as "F:" or "LPT1:"  The string is treated in a
        case insensitive manner, and may be the empty string in which case
        a connection to the network resource is made without making a
        decision.

Return Value:



--*/

{
    DWORD           status = WN_SUCCESS;
    NETRESOURCEW    netResource;
    DWORD           numchars;

    //
    // load up the net resource structure
    //

    netResource.dwScope = 0;
    netResource.dwUsage = 0;
    netResource.lpRemoteName = (LPWSTR) lpRemoteName;
    netResource.lpLocalName = (LPWSTR) lpLocalName;
    netResource.lpProvider = NULL;
    netResource.lpComment = NULL;


    __try {
        numchars = STRLEN(lpLocalName);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetAddConnectionW:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }
    if (status != WN_SUCCESS) {
        SetLastError(status);
        return status;
    }

    if (numchars == 0) {
        netResource.dwType = RESOURCETYPE_ANY;
    }
    else if (numchars > 2) {
        netResource.dwType = RESOURCETYPE_PRINT;
    }
    else {
        netResource.dwType = RESOURCETYPE_DISK;
    }

    //
    // Call WNetUseConnection so it can do all the work.
    //

    return(WNetUseConnectionW (
                NULL,               // hwndOwner
                &netResource,       // lpNetResource
                lpPassword,         // lpPassword
                NULL,               // lpUserID
                CONNECT_UPDATE_PROFILE, // dwFlags
                NULL,               // lpAccessName
                NULL,               // lpBufferSize
                NULL));             // lpResult

}

DWORD
WNetAddConnection2W (
    IN  LPNETRESOURCEW   lpNetResource,
    IN  LPCWSTR          lpPassword,
    IN  LPCWSTR          lpUserName,
    IN  DWORD            dwFlags
    )

/*++

Routine Description:

    This function allows the caller to redirect (connect) a local device
    to a network resource.  It is similar to WNetAddConnection, except
    that it takes a pointer to a NETRESOURCE structure to describe the
    network resource to connect to.  It also takes the additional parameters
    lpUserName, and dwFlags.

Arguments:

    lpNetResource - This is a pointer to a network resource structure that
        specifies the network resource to connect to.  The following
        fields must be set when making a connection, the others are ignored.
            lpRemoteName
            lpLocalName
            lpProvider
            dwType

    lpPassword - Specifies the password to be used in making the connection.
        The NULL value may be passed in to indicate use of the 'default'
        password.  An empty string may be used to indicate no password.

    lpUserName- This specifies the username used to make the connection.
        If NULL, the default username (currently logged on user) will be
        applied.  This is used when the user wishes to connect to a
        resource, but has a different user name or account assigned to him
        for that resource.

    dwFlags - This is a bitmask which may have any of the following bits set:
        CONNECT_UPDATE_PROFILE

Return Value:



--*/
{
    //
    // Call WNetUseConnection so it can do all the work.
    // It is called with a NULL HWND.
    //

    return(WNetUseConnectionW (
                NULL,               // hwndOwner
                lpNetResource,      // lpNetResource
                lpPassword,         // lpPassword
                lpUserName,         // lpUserID
                dwFlags,            // dwFlags
                NULL,               // lpAccessName
                NULL,               // lpBufferSize
                NULL));             // lpResult

}

DWORD
WNetAddConnection3W (
    IN  HWND            hwndOwner,
    IN  LPNETRESOURCEW  lpNetResource,
    IN  LPCWSTR         lpPassword,
    IN  LPCWSTR         lpUserName,
    IN  DWORD           dwFlags
    )

/*++

Routine Description:

    This function allows the caller to redirect (connect) a local device
    to a network resource.  It is similar to WNetAddConnection2, except
    that it takes the additional parameter hwndOwner.

Arguments:

    hwndOwner - A handle to a window which should be the owner for any
        messages or dialogs that the network provider might display.

    lpNetResource - This is a pointer to a network resource structure that
        specifies the network resource to connect to.  The following
        fields must be set when making a connection, the others are ignored.
            lpRemoteName
            lpLocalName
            lpProvider
            dwType

    lpPassword - Specifies the password to be used in making the connection.
        The NULL value may be passed in to indicate use of the 'default'
        password.  An empty string may be used to indicate no password.

    lpUserName- This specifies the username used to make the connection.
        If NULL, the default username (currently logged on user) will be
        applied.  This is used when the user wishes to connect to a
        resource, but has a different user name or account assigned to him
        for that resource.

    dwFlags - This is a bitmask which may have any of the following bits set:
        CONNECT_UPDATE_PROFILE

Return Value:


--*/
{
    //
    // Call WNetUseConnection so it can do all the work.
    // It is called with no buffer for the access name and result flags.
    //

    return(WNetUseConnectionW (
                hwndOwner,          // hwndOwner
                lpNetResource,      // lpNetResource
                lpPassword,         // lpPassword
                lpUserName,         // lpUserID
                dwFlags,            // dwFlags
                NULL,               // lpAccessName
                NULL,               // lpBufferSize
                NULL));             // lpResult
}


/*************************************************************************

    NAME:       CAutoPickedDevice

    SYNOPSIS:   This class is meant for use by the WNetUseConnection
        function.  It iterates through all possible local device names
        and finds an unused device name to be redirected.  For efficiency,
        it does this only once in the lifetime of the object, viz. the
        first time the PickDevice() method is called.  On subsequent calls
        it returns the result of the first call.

        The results of the PickDevice() call are saved in member variables,
        rather than being copied to the caller's buffer, because we don't
        know whether to return them to the caller until later.

    INTERFACE:

    CAVEATS:  The Init method must be called before the PickDevice method.

    NOTES:

    HISTORY:
        AnirudhS  24-May-1995  Created

**************************************************************************/

class CAutoPickedDevice
{
private:
    DWORD       _bPicked;       // whether already attempted to pick a device
    DWORD       _dwError;       // result of attempt to pick a device

    DWORD       _dwDeviceType;  // saved parameter from Init()
    DWORD       _cchBufferSize; // saved parameter from Init()

    DWORD       _cchReqBufferSize;  // saved results of PickDevice()
    WCHAR       _wszPickedName[ max(sizeof("A:"), sizeof("LPT99:")) ];

public:

    DWORD   Init(
                IN  LPWSTR  lpAccessName,
                IN  LPDWORD lpcchBufferSize,
                IN  LPCWSTR pwszLocalName,
                IN  LPCWSTR pwszRemoteName,
                IN  DWORD   dwDeviceType,
                IN  DWORD   dwFlags
                );

    DWORD   PickDevice();

    DWORD   dwError()
            {   return _dwError;    }

    DWORD   cchReqBufferSize()
            {   return _cchReqBufferSize;    }

    LPWSTR  wszPickedName()
            {   return _wszPickedName;  }
} ;


/*************************************************************************

    NAME:       CAutoPickedDevice::Init

    SYNOPSIS:   This function validates the parameters related to access
        names and auto-picking of local device names, and saves away some
        of them to be used in PickDevice().
        Depending on the severity of the errors it finds, it does one of
        the following:
        - cause an access violation
        - return an error
        - return success, but save away an error to be returned from
          PickDevice()
        - return success, and save away WN_SUCCESS so that PickDevice()
          will try to pick a device

**************************************************************************/

DWORD CAutoPickedDevice::Init(
    IN      LPWSTR  lpAccessName,
    IN      LPDWORD lpcchBufferSize,
    IN      LPCWSTR pwszLocalName,
    IN      LPCWSTR pwszRemoteName,
    IN      DWORD   dwDeviceType,
    IN      DWORD   dwFlags
    )
{
    _bPicked = FALSE;
    _dwError = WN_SUCCESS;

    //
    // If out pointers are supplied, make sure they're writeable
    // (even if we don't use them)
    //
    if (ARGUMENT_PRESENT(lpcchBufferSize))
    {
        _cchBufferSize = *(volatile DWORD *)lpcchBufferSize;    // Probe
        *(volatile DWORD *)lpcchBufferSize = _cchBufferSize;    // Probe
    }
    else
    {
        _cchBufferSize = 0;
    }


    if (ARGUMENT_PRESENT(lpAccessName))
    {
        //
        // If an AccessName buffer is supplied, the size parameter must
        // be present and non-zero, else return right away
        //
        if (_cchBufferSize == 0)
        {
            return WN_BAD_VALUE;    // Win95 compatibility
        }

        if (IsBadWritePtr(lpAccessName, _cchBufferSize * sizeof(WCHAR)))
        {
            return WN_BAD_POINTER;
        }

        _cchReqBufferSize = 0;

        //
        // If an access name is requested, and a local name is
        // specified, then we know that the access name will be the
        // specified local name, so we can validate the buffer
        // length up front
        //
        if (! IS_EMPTY_STRING(pwszLocalName))
        {
            _cchReqBufferSize = wcslen(pwszLocalName)+1;
        }

        //
        // If an access name is requested, and no local name is
        // specified, and we aren't asked to auto-pick a local
        // device, then the access name is likely to be the specified
        // remote name, so we validate the buffer length up front
        //
        else if ((dwFlags & CONNECT_REDIRECT) == 0)
        {
            _cchReqBufferSize = wcslen(pwszRemoteName)+1;
        }

        if (_cchBufferSize < _cchReqBufferSize) {
            *lpcchBufferSize = _cchReqBufferSize;
            return WN_MORE_DATA;
        }

        //
        // Save other parameters for use in PickDevice()
        //
        _dwDeviceType = dwDeviceType;

        //
        // (If we auto-pick a local device, the buffer length will
        // be validated later, when we auto-pick)
        //
    }
    else
    {
        //
        // We won't be able to autopick, because no access name buffer
        // is supplied.  But don't return the error until we're asked
        // to autopick.
        //
        _bPicked = TRUE;
        _dwError = WN_BAD_POINTER;
    }

    return WN_SUCCESS;
}



/*************************************************************************

    NAME:       CAutoPickedDevice::PickDevice

**************************************************************************/

DWORD CAutoPickedDevice::PickDevice()
{
    //
    // If we've been called before then return the error we returned
    // last time
    //
    if (_bPicked)
    {
        return _dwError;
    }

    _bPicked = TRUE;


    //
    // Validate the access name buffer size depending on the device type
    //
    if (_dwDeviceType == RESOURCETYPE_DISK)
    {
        _cchReqBufferSize = sizeof( "A:" );
    }
    else if (_dwDeviceType == RESOURCETYPE_PRINT)
    {
        _cchReqBufferSize = sizeof( "LPT1" );
    }
    else  // RESOURCETYPE_ANY -- can't autopick
    {
        _dwError = WN_BAD_VALUE;
        return _dwError;
    }

    if ( _cchBufferSize < _cchReqBufferSize )
    {
        _dwError = WN_MORE_DATA;
        return _dwError;
    }

    if (_dwDeviceType == RESOURCETYPE_DISK)
    {
        DWORD  dwDrives = GetLogicalDrives();
        DWORD  dwAvail  = (1 << ('Z' - 'A'));
        WCHAR  i;

        //
        // Try each drive from z: to c: and see if it's been used.
        // Check in reverse order to reduce the risk of conflicts
        // between remote and local drive letters (e.g., if hardware
        // is added after a drive is mapped).
        //
        for (i = L'Z'; i >= L'C'; i--, dwDrives <<= 1)
        {
            if (!(dwDrives & dwAvail))
            {
                //
                // This drive is available
                //
                _wszPickedName[0] = i;
                _wszPickedName[1] = L':';
                _wszPickedName[2] = L'\0';

                _dwError = WN_SUCCESS;
                return _dwError;
            }
        }
    }
    else  // (_dwDeviceType == RESOURCETYPE_PRINT)
    {
        WCHAR wszDeviceList[128];
        DWORD cch;

        //
        // Try each device from LPT1 to LPT99 and see if it's been used
        //
        wcscpy(_wszPickedName, L"LPT");
        for (ULONG i = 1; i <= 99; i++)
        {
            wsprintf(&_wszPickedName[sizeof("LPT")-1], L"%lu", i);

            cch = QueryDosDevice(_wszPickedName,
                                 wszDeviceList,
                                 sizeof(wszDeviceList)/sizeof(WCHAR));

            if ((cch == 0) && (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
            {
                //
                // QueryDosDevice failed -- this device is free
                //
                _dwError = WN_SUCCESS;
                return _dwError;
            }
        }
    }

    //
    // No unused devices found
    //
    _dwError = WN_NO_MORE_DEVICES;
    return _dwError;
}



//===================================================================
// WNetUseConnectionW
//===================================================================

class CUseConnection : public CRoutedOperation
{
public:
                    CUseConnection(
                        HWND            hwndOwner,
                        LPNETRESOURCEW  lpNetResource,
                        LPCWSTR         lpPassword,
                        LPCWSTR         lpUserName,
                        DWORD           dwFlags,
                        LPWSTR          lpAccessName,
                        LPDWORD         lpBufferSize,
                        LPDWORD         lpResult
                        ) :
                            CRoutedOperation(
                                DBGPARM("UseConnection")
                                NULL,
                                ROUTE_AGGRESSIVE
                                ),
                            _hwndOwner    (hwndOwner    ),
                            _lpNetResource(lpNetResource),
                            _lpPassword   (lpPassword   ),
                            _lpUserName   (lpUserName   ),
                            _dwFlags      (dwFlags      ),
                            _lpAccessName (lpAccessName ),
                            _lpBufferSize (lpBufferSize ),
                            _lpResult     (lpResult     )
                        {
                            _ExplicitPassword = (_lpPassword != NULL);
                            _UsedDefaultCreds = FALSE;
                        }

protected:

    DWORD           GetResult();    // overrides CRoutedOperation implementation

private:
        DWORD           TestProviderWorker(                           \
                            const PROVIDER *pProvider           \
                            );

    HWND            _hwndOwner;
    LPNETRESOURCEW  _lpNetResource;
    LPCWSTR         _lpPassword;
    LPCWSTR         _lpUserName;
    DWORD           _dwFlags;
    LPWSTR          _lpAccessName;
    LPDWORD         _lpBufferSize;
    LPDWORD         _lpResult;

    BOOL              _ExplicitPassword;
    BOOL              _UsedDefaultCreds;
    CAutoPickedDevice _AutoPickedDevice;
    NETRESOURCEW      _ProviderNetResource;
    DWORD             _dwProviderFlags;

    DECLARE_CROUTED
};


DWORD
CUseConnection::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    DWORD status;

    //
    // lpRemoteName must be non-empty and readable.
    //
    if (wcslen(_lpNetResource->lpRemoteName) == 0)  // Probe
    {
        return WN_BAD_NETNAME;
    }

    if (! IS_EMPTY_STRING(_lpNetResource->lpLocalName))
    {
        //
        // If a lpLocalName is supplied, it must be a redirectable device
        // name.
        //
        if (MprDeviceType(_lpNetResource->lpLocalName) != REDIR_DEVICE)
        {
            return WN_BAD_LOCALNAME;
        }
    }

    //
    // If a result pointer is supplied, make sure it's writeable
    //
    if (ARGUMENT_PRESENT(_lpResult))
    {
        *_lpResult = 0;
    }

    if ((_lpNetResource->dwType != RESOURCETYPE_DISK)  &&
        (_lpNetResource->dwType != RESOURCETYPE_PRINT) &&
        (_lpNetResource->dwType != RESOURCETYPE_ANY))
    {
        return WN_BAD_VALUE;
    }

    if (_dwFlags &
            ~(CONNECT_TEMPORARY |
              CONNECT_INTERACTIVE |
              CONNECT_COMMANDLINE |
              CONNECT_CMD_SAVECRED |
              CONNECT_PROMPT |
              CONNECT_UPDATE_PROFILE |
              CONNECT_UPDATE_RECENT |
              CONNECT_REDIRECT |
              CONNECT_CURRENT_MEDIA))
    {
        return WN_BAD_VALUE;
    }

    //
    // Win95 compatibility: Ignore CONNECT_PROMPT if CONNECT_INTERACTIVE
    // isn't set
    //
    if (!(_dwFlags & CONNECT_INTERACTIVE))
    {
        _dwFlags &= ~CONNECT_PROMPT;

        //
        // Ditch the other prompting bits just to prevent later confusion
        //

        _dwFlags &= ~(CONNECT_COMMANDLINE|CONNECT_CMD_SAVECRED);
    }


    //
    // Validate parameters related to auto-picking of local device names.
    // Some errors are returned immediately; others are returned only
    // when we actually need to auto-pick a device.
    //
    status = _AutoPickedDevice.Init(
                    _lpAccessName,
                    _lpBufferSize,
                    _lpNetResource->lpLocalName,
                    _lpNetResource->lpRemoteName,
                    _lpNetResource->dwType,
                    _dwFlags
                    );
    if (status != WN_SUCCESS)
    {
        return status;
    }

    //
    // Set parameters used by base class.  Set the local name to NULL
    // to prevent the check for "localness" in the base class.
    //
    *ppProviderName = _lpNetResource->lpProvider;
    *ppRemoteName   = _lpNetResource->lpRemoteName;
    *ppLocalName    = NULL;

    return WN_SUCCESS;
}


DWORD
CUseConnection::TestProviderWorker(
    const PROVIDER * pProvider
    )
{
    DWORD status;

    ASSERT_INITIALIZED(NETWORK);

    if (pProvider->AddConnection3 == NULL &&
        pProvider->AddConnection == NULL)
    {
        return WN_NOT_SUPPORTED;
    }

    //
    // We will retry this provider, with an autopicked local name,
    // at most once
    //
    for (BOOL fRetried = FALSE; ; fRetried = TRUE)
    {
        //
        // Call the provider's appropriate entry point
        //

        //
        // If, in the future, there are cases when the lpRemoteName
        // is some alias understood by the provider but not by the
        // NT name space, we'll need to add a NPAddConnection4 which
        // allows the provider to return an access name.
        //
        if (pProvider->AddConnection3 != NULL)
        {
            //**************************************
            // Actual call to Provider.
            //**************************************
            status = pProvider->AddConnection3(
                        _hwndOwner,                 // hwndOwner
                        &_ProviderNetResource,      // lpNetResource
                        (LPWSTR)_lpPassword,        // lpPassword
                        (LPWSTR)_lpUserName,        // lpUserName
                        _dwProviderFlags & pProvider->ConnectFlagCaps ); // dwFlags

            if (status == WN_CONNECTED_OTHER_PASSWORD)
            {
                //
                // The user had to be prompted for a password, so don't
                // defer the connection when restoring it at the next logon.
                //
                ASSERT(_dwProviderFlags & CONNECT_INTERACTIVE);
                _ExplicitPassword = TRUE;
                status = WN_SUCCESS;
            }
            else if (status == WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
            {
                //
                // The provider successfully used the default credentials
                // for this connection.
                //
                _UsedDefaultCreds = TRUE;
                status = WN_SUCCESS;
            }
        }
        else // (pProvider->AddConnection != NULL)
        {
            //**************************************
            // Actual call to Provider.
            //**************************************
            status = pProvider->AddConnection(
                        &_ProviderNetResource,      // lpNetResource
                        (LPWSTR)_lpPassword,        // lpPassword
                        (LPWSTR)_lpUserName);       // lpUserName

            ASSERT(status != WN_CONNECTED_OTHER_PASSWORD);
        }

        // The provider mustn't return this error, or it will mess us
        // up later
        ASSERT(status != WN_MORE_DATA);

        if (fRetried)
        {
            if (status != WN_SUCCESS)
            {
                // Restore the null local name
                _ProviderNetResource.lpLocalName = NULL;
            }

            break;
        }

        //
        // If this provider can't handle a NULL local name,
        // and we've been allowed to auto-pick a local name,
        // and we successfully auto-pick a local name,
        // try again with the auto-picked local name
        //
        // Note that status is updated iff we've been allowed
        // to auto-pick
        //
        if (status == WN_BAD_LOCALNAME &&
            _ProviderNetResource.lpLocalName == NULL &&
            _lpAccessName != NULL &&
            (status = _AutoPickedDevice.PickDevice()) == WN_SUCCESS)
        {
            _ProviderNetResource.lpLocalName =
                    _AutoPickedDevice.wszPickedName();
            MPR_LOG2(ROUTE, "CUseConnection: retrying %ws with device %ws ...\n",
                     pProvider->Resource.lpProvider,
                     _ProviderNetResource.lpLocalName);
        }
        else
        {
            //
            // Don't retry
            //
            break;
        }
    } // end retry loop for this provider

    return status;
}


BOOL
InitCredUI(
    IN  PWSTR pszRemoteName,
    OUT PWSTR pszServer,
    IN  ULONG ulServerLength
    )
{
    // Make sure the first 2 characters are path separators:

    if ((pszRemoteName == NULL) ||
        (pszRemoteName[0] != L'\\') ||
        (pszRemoteName[1] != L'\\'))
    {
        SetLastError(WN_BAD_NETNAME);
        return FALSE;
    }


    PWSTR pszStart = pszRemoteName + 2;
    PWSTR pszEnd = NULL;

    // send only the server name, the string up to the first slash
    pszEnd = wcschr(pszStart, L'\\');

    if (pszEnd == NULL)
    {
        pszEnd = pszStart + wcslen(pszStart);
    }

    DWORD_PTR dwLength = (DWORD_PTR)(pszEnd - pszStart);

    if ((dwLength == 0) || (dwLength >= ulServerLength))
    {
        // The server is either an empty string or more than the maximum
        // number of characters we support:

        SetLastError(WN_BAD_NETNAME);
        return FALSE;
    }

    wcsncpy(pszServer, pszStart, dwLength);
    pszServer[dwLength] = L'\0';
    return TRUE;
}


VOID
DisplayFailureReason(
    DWORD Status,
    LPCWSTR Path
    )

/*++

Routine Description:

    This routine displays the reason for the authentication failure.
    The complete path name is displayed.

    We could modify credui to display this, but credui doesn't have the full path name.

Arguments:

    Status - Status of the failure

    Path - Full path name of the failed authentication.

Return Value:

    None.

--*/
{
    DWORD MessageId;
    LPWSTR InsertionStrings[2];

    HMODULE lpSource = NULL;
    DWORD MessageLength = 0;
    LPWSTR Buffer = NULL;
    BOOL MessageFormatted = FALSE;

    //
    // Pick the message based in the failure status
    //

    MessageId = ( Status == ERROR_LOGON_FAILURE) ? APE_UseBadPassOrUser : APE_UseBadPass;
    InsertionStrings[0] = (LPWSTR) Path;


    //
    // Load the message library and format the message from it
    //

    lpSource = LoadLibraryEx(MESSAGE_FILENAME,
                             NULL,
                             LOAD_LIBRARY_AS_DATAFILE);

    if ( lpSource ) {

        //
        // Format the message
        //

        MessageLength = FormatMessageW( FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                            FORMAT_MESSAGE_FROM_HMODULE,
                                        lpSource,
                                        MessageId,
                                        0,       // LanguageId defaulted
                                        (LPWSTR) &Buffer,
                                        1024,   // Limit the buffer size
                                        (va_list *) InsertionStrings);

        if ( MessageLength ) {
            MessageFormatted = TRUE;
        }
    }


    //
    // If it failed, print a generic message
    //

    if ( !MessageFormatted ) {
        WCHAR NumberString[18];

        //
        // get the message number in Unicode
        //
        _ultow(MessageId, NumberString, 16);

        //
        // setup insert strings
        //
        InsertionStrings[0] = NumberString;
        InsertionStrings[1] = MESSAGE_FILENAME;

        //
        // Use the system messge file.
        //

        MessageLength = FormatMessageW( FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                            FORMAT_MESSAGE_FROM_SYSTEM,
                                        NULL,
                                        ERROR_MR_MID_NOT_FOUND,
                                        0,       // LanguageId defaulted
                                        (LPWSTR) &Buffer,
                                        1024,
                                        (va_list *) InsertionStrings);

    }


    //
    // Avoid double newlines
    //

    if ( MessageLength >= 2) {

        if ( Buffer[MessageLength - 1] == L'\n' &&
             Buffer[MessageLength - 2] == L'\r') {

            //
            // "\r\n" shows up as two newlines when using the CRT and piping
            // output to a file.  Make it just one newline.
            //

            Buffer[MessageLength - 1] = L'\0';
            Buffer[MessageLength - 2] = L'\n';
            MessageLength --;
        }
    }


    //
    // Output the message to stdout
    //

    if ( MessageLength > 0 ) {
        HANDLE StdoutHandle = GetStdHandle( STD_OUTPUT_HANDLE );

        if ( StdoutHandle != INVALID_HANDLE_VALUE ) {
            DWORD CharsWritten;

            if ( !WriteConsoleW( StdoutHandle,
                                 Buffer,
                                 MessageLength,
                                 &CharsWritten,
                                 NULL )) {

                //
                // Convert to ANSI before doing the write file
                //


                if ( NO_ERROR == OutputStringToAnsiInPlace( Buffer ) ) {
                    CharsWritten = strlen( (LPSTR) Buffer );

                    WriteFile( StdoutHandle,
                               Buffer,
                               CharsWritten,
                               &CharsWritten,
                               NULL );

                }

            }

            //
            // Append a newline for formatting reasons
            //

            Buffer[0] = '\n';
            WriteFile( StdoutHandle,
                       Buffer,
                       1,
                       &CharsWritten,
                       NULL );
        }
    }


    //
    // Clean up before exitting
    //

    if ( lpSource != NULL ) {
        FreeLibrary( lpSource );
    }

    if ( Buffer != NULL ) {
        LocalFree( Buffer );
    }

}

DWORD
CUseConnection::TestProvider(
    const PROVIDER * pProvider
    )
{
    DWORD dwErr;
    DWORD LocalProviderFlags;
    BOOL DoCommandLinePrompting = FALSE;

    //
    // If the caller asked for CONNECT_COMMANDLINE,
    //  and the provider doesn't support it,
    //  this routine should take over responsibility for doing it.
    //

    LocalProviderFlags = _dwProviderFlags;

    if ( (_dwProviderFlags & CONNECT_COMMANDLINE) != 0 &&
         (pProvider->ConnectFlagCaps & CONNECT_COMMANDLINE) == 0 ) {

        DoCommandLinePrompting = TRUE;

        //
        // Don't let the provider do GUI prompting.
        //

        _dwProviderFlags &= ~(CONNECT_INTERACTIVE | CONNECT_PROMPT | CONNECT_COMMANDLINE | CONNECT_CMD_SAVECRED);
    }



    //
    // Try the connection once
    //  (Unless we're asked not to before prompting.)
    //

    if ( !DoCommandLinePrompting || (LocalProviderFlags & CONNECT_PROMPT) == 0 ) {
        dwErr = TestProviderWorker( pProvider );
    } else {
        dwErr = ERROR_LOGON_FAILURE;
    }

    //
    // If this routine is handling command line prompting,
    //  and the connection failed for authentication reasons,
    //  prompt for credentials here.
    //
    // Ignore COMMENT_COMMANDLINE_SAVECRED since we don't know what authentication mechanism
    //  the provider uses.
    //

    if ( DoCommandLinePrompting && CREDUI_IS_AUTHENTICATION_ERROR(dwErr) )
    {
        WCHAR szPassword[CREDUI_MAX_PASSWORD_LENGTH + 1];    // if the user needs to enter one
        WCHAR szUserName[CREDUI_MAX_USERNAME_LENGTH + 1];

        WCHAR szServer[CRED_MAX_DOMAIN_TARGET_NAME_LENGTH + 1];

        //
        // Display the reason for the failure with the full path name
        //

        DisplayFailureReason( dwErr, _ProviderNetResource.lpRemoteName );

        //
        // Default the user name to the one provided by the caller.
        //

        szUserName[0] = L'\0';
        if ( _lpUserName != NULL ) {
            if (wcslen(_lpUserName) > CREDUI_MAX_USERNAME_LENGTH) {
                return WN_BAD_USER;
            }
            wcscpy(szUserName, _lpUserName);
        }

        //
        // Prepare to use the credential manager user interface:
        //


        if (!InitCredUI(_ProviderNetResource.lpRemoteName,
                        szServer,
                        CRED_MAX_DOMAIN_TARGET_NAME_LENGTH))
        {
            dwErr = GetLastError();
        }
        else
        {
            DWORD dwCredErr;
            DWORD dwAuthErr;
            LPWSTR pszNewPassword;
            DWORD dwCredUIFlags = 0;

            //
            // Remember the original failure reason
            //
            dwAuthErr = dwErr;


            //
            // Set the appropriate flag to set the behavior of the common UI.
            //

            // Ask to not save the credential
            dwCredUIFlags |= CREDUI_FLAGS_DO_NOT_PERSIST |
                             CREDUI_FLAGS_GENERIC_CREDENTIALS;

            // We don't (yet) know how to handle certificates
            dwCredUIFlags |= CREDUI_FLAGS_EXCLUDE_CERTIFICATES;

            // Ensure that the username syntax is correct (Not in MPR)
            // dwCredUIFlags |= CREDUI_FLAGS_VALIDATE_USERNAME;

            dwCredErr = CredUICmdLinePromptForCredentials(
                                            szServer,
                                            NULL,
                                            dwAuthErr,
                                            szUserName,
                                            CREDUI_MAX_USERNAME_LENGTH,
                                            szPassword,
                                            CREDUI_MAX_PASSWORD_LENGTH,
                                            NULL,   // Creds not saved
                                            dwCredUIFlags);


            if (dwCredErr == ERROR_CANCELLED) {
                dwErr = WN_CANCEL;

            } else if ( dwCredErr == ERROR_SUCCESS ) {
                LPCWSTR OldPassword;

                //
                // Use the returned username and password
                //

                _lpUserName = szUserName;
                OldPassword = _lpPassword;
                _lpPassword = szPassword;

                //
                // Try the connection one more time
                //

                dwErr = TestProviderWorker( pProvider );

                if ( dwErr == NO_ERROR )
                {
                    //
                    // If typed password is different than the one passed in,
                    //  this is now an explicit password.
                    //

                    if ( OldPassword == NULL ||
                         wcscmp(OldPassword, _lpPassword) != 0 )
                    {
                        _ExplicitPassword = TRUE;
                    }
                }
            }

            //
            // clear any password from memory
            //
            ZeroMemory(szPassword, sizeof(szPassword)) ;
        }
    }

    //
    // Restore the flag to their initial value
    //
    _dwProviderFlags = LocalProviderFlags;

    return dwErr;
}


DWORD
CUseConnection::GetResult()
{
    DWORD status;

    //
    // If we're given a local name,
    // check the current list of remembered drives in the registry
    // to determine if the localName is already connected.
    //
    if (! IS_EMPTY_STRING(_lpNetResource->lpLocalName))
    {
        //
        // If the local drive is already in the registry, and it is
        // for a different connection than that specified in the
        // lpNetResource, then indicate an error because the device
        // is already remembered.
        //
        LPWSTR  remoteName;
        if (MprFindDriveInRegistry(_lpNetResource->lpLocalName, &remoteName))
        {
            if (remoteName != NULL)
            {
                if (STRICMP(_lpNetResource->lpRemoteName, remoteName)!=0)
                {
                    LocalFree(remoteName);
                    return WN_DEVICE_ALREADY_REMEMBERED;
                }
                LocalFree(remoteName);
            }
        }
    }

    //
    // We modify some parameters before passing them to the provider
    //
    _ProviderNetResource = *_lpNetResource;
    if (IS_EMPTY_STRING(_ProviderNetResource.lpLocalName))
    {
        _ProviderNetResource.lpLocalName = NULL;
    }
    _dwProviderFlags = _dwFlags & WNNC_CF_MAXIMUM;

    //
    // If we're not given a local name, but are explicitly asked to
    // redirect a device, we must autopick one
    //
    if ((_dwFlags & CONNECT_REDIRECT) &&
        (_ProviderNetResource.lpLocalName == NULL) )
    {
        status = _AutoPickedDevice.PickDevice();

        if (status != WN_SUCCESS)
        {
            return status;
        }

        _ProviderNetResource.lpLocalName = _AutoPickedDevice.wszPickedName();
    }

    INIT_IF_NECESSARY(NOTIFIEE_LEVEL,status);

    //
    // Notify all interested parties that a connection is being made.
    // (All providers are required to support deviceless connections, so
    // we shouldn't get a case where a notifyee might reject a connection
    // on the grounds that it has no local name, even though we would have
    // auto-picked a local name later)
    //
    NOTIFYADD           NotifyAdd;
    NOTIFYINFO          NotifyInfo;

    NotifyInfo.dwNotifyStatus   = NOTIFY_PRE;
    NotifyInfo.dwOperationStatus= 0L;
    NotifyInfo.lpContext        = MprAllocConnectContext();
    NotifyAdd.hwndOwner   = _hwndOwner;
    NotifyAdd.NetResource = *_lpNetResource;
    NotifyAdd.dwAddFlags  = _dwFlags;

    __try
    {
        status = MprAddConnectNotify(&NotifyInfo, &NotifyAdd);
    }
    __except(MPR_EXCEPTION_FILTER)
    {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG(ERROR,"WNetUseConnectionW: ConnectNotify, Unexpected "
            "Exception %#lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS)
    {
        return status;
    }


    do  // Notification loop
    {
        //
        // Let the base class try all providers and figure out the best error
        // CRoutedOperation::GetResult calls INIT_IF_NECESSARY
        //
        status = CRoutedOperation::GetResult();

        //
        // Notify all interested parties of the status of the connection.
        //
        NotifyInfo.dwNotifyStatus    = NOTIFY_POST;
        NotifyInfo.dwOperationStatus = status;
    }
    while (MprAddConnectNotify(&NotifyInfo, &NotifyAdd) == WN_RETRY);

    MprFreeConnectContext(NotifyInfo.lpContext);

    //
    // Write info to the informational parameters
    // (lpAccessName, lpBufferSize, lpResult)
    //

    if (status == WN_MORE_DATA)
    {
        //
        // This error must have come from CAutoPickedDevice::PickDevice,
        // indicating that the access name buffer is too small
        // (unless it came from a buggy provider)
        //
        ASSERT(_AutoPickedDevice.dwError() == WN_MORE_DATA);
        if (ARGUMENT_PRESENT(_lpBufferSize))
        {
            *_lpBufferSize = _AutoPickedDevice.cchReqBufferSize();
        }
    }
    else if (status == WN_SUCCESS &&
             ARGUMENT_PRESENT(_lpAccessName))
    {
        LPWSTR pwszAccessName = _ProviderNetResource.lpLocalName;
        if (pwszAccessName == NULL)
        {
            pwszAccessName = _ProviderNetResource.lpRemoteName;
        }

        if (*_lpBufferSize < wcslen(pwszAccessName)+1)
        {
            //
            // We validated most of the cases up front, so the only way
            // this could happen is if we auto-picked and got a local
            // name that was longer than the remote name.
            //
            ASSERT(0);
            *_lpBufferSize = wcslen(pwszAccessName)+1;
            status = WN_MORE_DATA;
        }
        else
        {
            wcscpy(_lpAccessName, pwszAccessName);
            if (ARGUMENT_PRESENT(_lpResult) &&
                _ProviderNetResource.lpLocalName != NULL)
            {
                *_lpResult = CONNECT_LOCALDRIVE;
            }
        }
    }


    if (status == WN_SUCCESS)
    {
        ASSERT_INITIALIZED(NETWORK);

        //
        // If the connection was added successfully, then write the connection
        // information to the registry to make it persistent.
        // Note: Failure to write to the registry is ignored.
        //
        if ((_dwFlags & CONNECT_UPDATE_PROFILE) &&
            !IS_EMPTY_STRING(_ProviderNetResource.lpLocalName))
        {
            BYTE ProviderFlags = 0;

            //
            // Get the username for the connection if the provider didn't report
            // that default creds were used:
            //
            //    1.  If the username is explicitly given, store the
            //        username returned by the provider
            //
            //    2.  Otherwise, compare the username given by the
            //        provider with the default username.  If they're
            //        different, store it.  If they're the same, don't
            //
            //    3.  If we can't get a username for whatever reason,
            //        use the username in _lpUserName (which will be
            //        NULL if no name was explicitly given)
            //

            if (LastProvider()->GetUser != NULL)
            {
                WCHAR wszUser[MAX_PATH + 1];

                __try
                {
                    DWORD cbBuffer = LENGTH(wszUser);
                    DWORD status2 = LastProvider()->GetUser(
                                            _ProviderNetResource.lpLocalName,
                                            wszUser,
                                            &cbBuffer);

                    ASSERT(status2 != WN_MORE_DATA);

                    if (status2 == WN_SUCCESS)
                    {
                        //
                        // Step 1 -- is the username explicitly given?
                        //
                        if (ARGUMENT_PRESENT(_lpUserName))
                        {
                            MPR_LOG1(TRACE,
                                     "Explicit username being saved -- %ws\n",
                                     wszUser);
                            _lpUserName = wszUser;
                        }
                        else
                        {
                            //
                            // Step 2 -- is the user the default user?
                            //
                            PUNICODE_STRING UserName;
                            PUNICODE_STRING DomainName;
                            NTSTATUS ntStatus = LsaGetUserName(&UserName, &DomainName);

                            if (NT_SUCCESS(ntStatus))
                            {
                                if (MprUserNameMatch(DomainName, UserName, wszUser, TRUE))
                                {
                                    MPR_LOG1(TRACE,
                                             "User %ws is default user -- not saving username\n",
                                             wszUser);
                                    _lpUserName = NULL;
                                }
                                else
                                {
                                    MPR_LOG1(TRACE,
                                             "User %ws is not default user -- saving username\n",
                                             wszUser);
                                    _lpUserName = wszUser;
                                }
                            }
                        }
                    }
                    else if (status2 == WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
                    {
                        //
                        // WN_CONNECTED_OTHER_PASSWORD_DEFAULT will be returned
                        // when user X mapped a drive as user Y and the credentials
                        // for user Y were stored in CredMan when the connection
                        // was made.  Treat this as the default username so we don't
                        // explicitly write user Y's username into the registry
                        // (since CredMan will be unable to reestablish the connection
                        // automatically in that case).
                        //

                        _lpUserName = NULL;
                    }
                }
                __except (MPR_EXCEPTION_FILTER)
                {
                    MPR_LOG(ERROR,
                            "WNetUseConnectionW: exception %#lx from NPGetUser\n",
                            GetExceptionCode());
                }
            }

            //
            // Get an 8-bit datum that the provider may want saved along
            // with the connection.  This will be passed back to the provider
            // in NPAddConnection3 when the connection is restored.
            // (Actually this is a hack for the NTLM provider to remember
            // whether a connection is a DFS connection or a regular LM
            // connection.)
            //
            if (LastProvider()->GetReconnectFlags != NULL)
            {
                // This is an internal entry point so we don't bother with
                // try-except
                DWORD status2 = LastProvider()->GetReconnectFlags(
                                            _ProviderNetResource.lpLocalName,
                                            &ProviderFlags
                                            );
                if (status2 != WN_SUCCESS)
                {
                    ProviderFlags = 0;
                }

                MPR_LOG3(RESTORE, "%ws wants flags %#x saved for %ws\n",
                            LastProvider()->Resource.lpProvider,
                            ProviderFlags,
                            _ProviderNetResource.lpLocalName);
            }

            I_MprSaveConn(
                    HKEY_CURRENT_USER,
                    LastProvider()->Resource.lpProvider,
                    LastProvider()->Type,
                    _lpUserName,
                    _ProviderNetResource.lpLocalName,
                    _ProviderNetResource.lpRemoteName,
                    _ProviderNetResource.dwType,
                    ProviderFlags,
                    _ExplicitPassword ? DEFER_EXPLICIT_PASSWORD : ( _UsedDefaultCreds ? DEFER_DEFAULT_CRED : 0 )
                    );
        }

        //
        // Notify the shell of the connection.
        // (This will be replaced by real Plug'n'Play)
        //
        if( (g_LUIDDeviceMapsEnabled == TRUE) &&
            (_ProviderNetResource.lpLocalName != NULL) )
        {
            // Use LUID broadcast mechanism
            MprBroadcastDriveChange(
                _ProviderNetResource.lpLocalName,
                FALSE );    // not a Delete Message
        }
        else
        {
            MprNotifyShell(_ProviderNetResource.lpLocalName);
        }
    }

    return status;
}


DWORD
WNetUseConnectionW (
    IN  HWND            hwndOwner,
    IN  LPNETRESOURCEW  lpNetResource,
    IN  LPCWSTR         lpPassword,
    IN  LPCWSTR         lpUserName,
    IN  DWORD           dwFlags,
    OUT LPWSTR          lpAccessName OPTIONAL,
    IN OUT LPDWORD      lpBufferSize OPTIONAL,
    OUT LPDWORD         lpResult OPTIONAL
    )

/*++

Routine Description:

    This function allows the caller to redirect (connect) a local device
    to a network resource.  It is similar to WNetAddConnection3, except
    that it has the ability to auto-pick a local device to redirect.
    It also returns additional information about the connection in the
    lpResult parameter.

    This API is used by the shell to make links to:
    - Objects on networks that require a local device redirection
    - Objects served by applications that require a local device redirection
      (i.e. can't handle UNC paths)

    This API must redirect a local device in any of the following conditions:
    - The API is given a local device name to redirect
    - The API is asked to redirect a local device, by the CONNECT_REDIRECT
      flag
    - The network provider requires a redirection
    In the last 2 cases, if a local device name isn't given, the API must
    auto-pick a local device name.

Arguments:

    hwndOwner - A handle to a window which should be the owner for any
        messages or dialogs that the network provider might display.

    lpNetResource - This is a pointer to a network resource structure that
        specifies the network resource to connect to.  The following
        fields must be set when making a connection, the others are ignored.
            lpRemoteName
            lpLocalName
            lpProvider
            dwType

    lpPassword - Specifies the password to be used in making the connection.
        The NULL value may be passed in to indicate use of the 'default'
        password.  An empty string may be used to indicate no password.

    lpUserName- This specifies the username used to make the connection.
        If NULL, the default username (currently logged on user) will be
        applied.  This is used when the user wishes to connect to a
        resource, but has a different user name or account assigned to him
        for that resource.

    dwFlags - This is a bitmask which may have any of the following bits set:
        CONNECT_UPDATE_PROFILE

    lpAccessName - Points to a buffer to receive the name that can be used
        to make system requests on the connection. This conversion is useful
        when lpRemoteName is understood by the provider but not by the
        system's name space, and when this API autopicks a local device.
        If lpLocalName specifies a local device, then this buffer is optional,
        and if specified will have the local device name copied into it.
        Otherwise, if the network requires a local device redirection, or
        CONNECT_REDIRECT is set, then this buffer is required and the
        redirected local device is returned here. Otherwise, the name copied
        into the buffer is that of a remote resource, and if specified, this
        buffer must be at least as large as the string pointed to by
        lpRemoteName.

    lpBufferSize - Specifies the size, in characters, of the lpAccessName
        buffer.  If the API returns WN_MORE_DATA the required size will be
        returned here.

    lpResult - Pointer to a DWORD in which is returned additional information
        about the connection.  Currently has the following bit values:
        CONNECT_LOCALDRIVE - If set, the connection was made using a local
            device redirection. If lpAccessName points to a buffer then the
            local device name is copied to the buffer.

Return Value:

--*/
{
    CUseConnection UseConnection(hwndOwner, lpNetResource, lpPassword,
                                 lpUserName, dwFlags, lpAccessName,
                                 lpBufferSize, lpResult);

    return (UseConnection.Perform(TRUE));
}


//===================================================================
// WNetCancelConnection2W
//===================================================================

class CCancelConnection2 : public CRoutedOperation
{
public:
                    CCancelConnection2(
                        LPCWSTR      lpName,
                        DWORD        dwFlags,
                        BOOL         fForce
                        ) :
                            CRoutedOperation(DBGPARM("CancelConnection2")
                                             PROVIDERFUNC(CancelConnection)),
                            _lpName (lpName),
                            _dwFlags(dwFlags),
                            _fForce (fForce)
                        { }

protected:

    DWORD           GetResult();    // overrides CRoutedOperation implementation

private:

    LPCWSTR         _lpName;
    DWORD           _dwFlags;
    BOOL            _fForce;

    DECLARE_CROUTED
};


DWORD
CCancelConnection2::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    if (((_dwFlags != 0) && (_dwFlags != CONNECT_UPDATE_PROFILE)) ||
        wcslen(_lpName) == 0) // probe lpName
    {
        return WN_BAD_VALUE;
    }

    //
    // Use the specified remote name as a hint to pick the provider, but not
    // if it's a local device name
    //
    if (MprDeviceType(_lpName) != REDIR_DEVICE)
    {
        *ppRemoteName = _lpName;
    }

    *ppLocalName = _lpName;

    return WN_SUCCESS;
}


DWORD
CCancelConnection2::TestProvider(
    const PROVIDER * pProvider
    )
{
    ASSERT_INITIALIZED(NETWORK);

    return (pProvider->CancelConnection((LPWSTR)_lpName, _fForce));
}


DWORD
CCancelConnection2::GetResult()
{
    DWORD status;

    NOTIFYCANCEL    NotifyCancel;
    NOTIFYINFO      NotifyInfo;

    INIT_IF_NECESSARY(NOTIFIEE_LEVEL, status);

    //
    // Notify all interested parties that a connection is being cancelled
    //
    NotifyInfo.dwNotifyStatus   = NOTIFY_PRE;
    NotifyInfo.dwOperationStatus= 0L;
    NotifyInfo.lpContext        = MprAllocConnectContext();
    NotifyCancel.lpName     = (LPWSTR)_lpName;
    NotifyCancel.lpProvider = NULL;
    NotifyCancel.dwFlags    = _dwFlags;
    NotifyCancel.fForce     = _fForce;

    __try
    {
        status = MprCancelConnectNotify(&NotifyInfo, &NotifyCancel);
    }
    __except(MPR_EXCEPTION_FILTER)
    {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG(ERROR,"WNetCancelConnection2W: ConnectNotify, Unexpected "
            "Exception %#lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS)
    {
        return status;
    }

    do  // Notification loop
    {
        //
        // Let the base class try all providers and figure out the best error
        // CRoutedOperation::GetResult calls INIT_IF_NECESSARY
        //
        status = CRoutedOperation::GetResult();

        //
        // Map these errors to a friendlier one for this API
        //
        if (status == WN_BAD_NETNAME ||
            status == ERROR_BAD_NETPATH ||
            status == WN_BAD_LOCALNAME ||
            status == WN_NO_NETWORK ||
            status == WN_NO_NET_OR_BAD_PATH)
        {
            MPR_LOG2(ROUTE, "CCancelConnection2: remapping %ld to %ld\n",
                        status, WN_NOT_CONNECTED);
            status = WN_NOT_CONNECTED;
        }

        //
        // Notify all interested parties of the status of the connection.
        //
        NotifyInfo.dwNotifyStatus    = NOTIFY_POST;
        NotifyInfo.dwOperationStatus = status;  // Is this the right status??
        if (status == WN_SUCCESS)
        {
            NotifyCancel.lpProvider = LastProvider()->Resource.lpProvider;
        }
    }
    while (MprCancelConnectNotify(&NotifyInfo, &NotifyCancel) == WN_RETRY);

    MprFreeConnectContext(NotifyInfo.lpContext);

    //
    // Regardless of whether the connection was cancelled successfully,
    // we still want to remove any connection information from the
    // registry if told to do so (dwFlags has CONNECT_UPDATE_PROFILE set).
    //
    if (_dwFlags & CONNECT_UPDATE_PROFILE)
    {
        if (MprDeviceType((LPWSTR)_lpName) == REDIR_DEVICE)
        {
            if (MprFindDriveInRegistry((LPWSTR)_lpName,NULL))
            {
                //
                // If the connection was found in the registry, we want to
                // forget it and if no providers claimed responsibility,
                // return success.
                //
                MprForgetRedirConnection((LPWSTR)_lpName);
                if (status == WN_NOT_CONNECTED)
                {
                    status = WN_SUCCESS;
                }
            }
        }
    }

    if (status == WN_SUCCESS)
    {
        //
        // Notify the shell of the disconnection.
        //
        if( (g_LUIDDeviceMapsEnabled == TRUE) && (_lpName != NULL) )
        {
            // Use LUID broadcast mechanism
            MprBroadcastDriveChange(
                _lpName,
                TRUE );   // a Delete Message
        }
        else
        {
            MprNotifyShell(_lpName);
        }
    }

    return status;
}


DWORD
WNetCancelConnection2W (
    IN  LPCWSTR  lpName,
    IN  DWORD    dwFlags,
    IN  BOOL     fForce
    )

/*++

Routine Description:

    This function breaks an existing network connection.  The persistance
    of the connection is determined by the dwFlags parameter.

Arguments:

    lpName - The name of either the redirected local device, or the remote
        network resource to disconnect from.  In the former case, only the
        redirection specified is broken.  In the latter case, all
        connections to the remote network resource are broken.

    dwFlags - This is a bitmask which may have any of the following bits set:
        CONNECT_UPDATE_PROFILE

    fForce - Used to indicate if the disconnect should be done forcefully
        in the event of open files or jobs on the connection.  If FALSE is
        specified, the call will fail if there are open files or jobs.


Return Value:

    WN_SUCCESS - The call was successful.  Otherwise, GetLastError should be
        called for extended error information.  Extended error codes include
        the following:

    WN_NOT_CONNECTED - lpName is not a redirected device. or not currently
        connected to lpName.

    WN_OPEN_FILES - There are open files and fForce was FALSE.

    WN_EXTENDED_ERROR - A network specific error occured.  WNetGetLastError
        should be called to obtain a description of the error.

--*/
{
    //
    // Check the providers
    //
    return MprCancelConnection2(lpName, dwFlags, fForce, TRUE);
}


DWORD
MprCancelConnection2 (
    IN  LPCWSTR  lpName,
    IN  DWORD    dwFlags,
    IN  BOOL     fForce,
    IN  BOOL     fCheckProviders
    )
/*++

Routine Description:

    Wrapper to use the CCancelConnection2 class -- needed because otherwise,
    WNetRestoreConnectionW could call WNetCancelConnection2W, causing a
    deadlock on the provider lock.

Arguments:


Return Value:

--*/
{
    CCancelConnection2 CancelConnection2(lpName, dwFlags, fForce);

    return (CancelConnection2.Perform(fCheckProviders));
}


DWORD
WNetCancelConnectionW (
    IN  LPCWSTR  lpName,
    IN  BOOL    fForce
    )

/*++

Routine Description:

    This function breaks an existing network connection.  The connection is
    always made non-persistent.

    Note that this is a stub routine that calls WNetCancelConnection2W and
    is only provided for Win3.1 compatibility.

Arguments:

    Parameters are the same as WNetCancelConnection2W

Return Value:

    Same as WNetCancelConnection2W


--*/
{
    return MprCancelConnection2( lpName, CONNECT_UPDATE_PROFILE, fForce, TRUE ) ;
}

DWORD
WNetGetConnectionW (
    IN      LPCWSTR  lpLocalName,
    OUT     LPWSTR   lpRemoteName,
    IN OUT  LPDWORD  lpBufferSize
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    MprCheckProviders();

    CProviderSharedLock    PLock;

    return MprGetConnection( lpLocalName, lpRemoteName, lpBufferSize, NULL ) ;
}


DWORD
MprGetConnection (
    IN      LPCWSTR  lpLocalName,
    OUT     LPTSTR   lpRemoteName,
    IN OUT  LPDWORD  lpBufferSize,
    OUT     LPDWORD  lpProviderIndex OPTIONAL
    )

/*++

Routine Description:

    Retrieves the remote name associated with a device name and optionally
    the provider index.

    Behaviour is exactly the same as WNetGetConnectionW.

Arguments:



Return Value:



--*/
{
    DWORD       status = WN_SUCCESS;
    LPDWORD     indexArray;
    DWORD       localArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders;
    LPPROVIDER  provider;
    DWORD       statusFlag = 0; // used to indicate major error types
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       i;
    DWORD       dwFirstError = WN_SUCCESS;
    DWORD       dwFirstSignificantError = WN_SUCCESS;

    //
    // Validate the LocalName
    //
    __try {
        if (MprDeviceType((LPWSTR) lpLocalName) != REDIR_DEVICE) {
            status = WN_BAD_LOCALNAME;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetGetConnection:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS) {
        SetLastError(status);
        return status;
    }

    //
    // Optimization: If the local name is a drive, load the providers
    // only if it's a remote drive.
    //
    if (lpLocalName[1] == L':')
    {
        WCHAR wszRootPath[] = L" :\\";
        UINT  uDriveType;

        wszRootPath[0] = lpLocalName[0];
        uDriveType = GetDriveType(wszRootPath);

        if (uDriveType == DRIVE_REMOVABLE ||
            uDriveType == DRIVE_FIXED     ||
            uDriveType == DRIVE_CDROM     ||
            uDriveType == DRIVE_RAMDISK)
        {
            status = WN_NOT_CONNECTED;
            SetLastError(status);
            return status;
        }
        else if (uDriveType != DRIVE_REMOTE) {

            //
            // It's not a remote drive, but it's not one in hardware
            // (either DRIVE_UNKNOWN or DRIVE_NO_ROOT_DIR).  Since it
            // might have a name associated with it in the registry
            // (e.g., remembered connections), we have to load the
            // providers and check if necessary (done in
            // MprReadConnectionInformation)
            //
            status = WN_NOT_CONNECTED;
            goto CheckRemembered;
        }
    }

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    //
    // Find the list of providers to call for this request.
    //
    indexArray = localArray;

    status = MprFindCallOrder(
                NULL,
                &indexArray,
                &numProviders,
                NETWORK_TYPE);

    if (status != WN_SUCCESS) {
        SetLastError(status);
        return status;
    }

    //
    // Loop through the list of providers until one answers the request,
    // or the list is exhausted.
    //

    for (i=0; i<numProviders; i++) {

        //
        // Call the appropriate providers API entry point
        //
        provider = GlobalProviderInfo + indexArray[i];

        if (provider->GetConnection != NULL) {

            fcnSupported = TRUE;

            __try {
                //**************************************
                // Actual call to Provider.
                //**************************************
                status = provider->GetConnection(
                            (LPWSTR) lpLocalName,
                            lpRemoteName,
                            lpBufferSize);
            }

            __except(MPR_EXCEPTION_FILTER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetGetConnection:Unexpected Exception 0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }

            ////////////////////////////////////////////////////////////
            //                                                        //
            //   The following code attempts to give the user the     //
            //   most sensible error message. We have 3 clasess of    //
            //   errors. On first class we stop routing. On second    //
            //   continue but ignore that error (not significant      //
            //   because the provider didnt think it was his). On     //
            //   the last the provider returned an interesting (or    //
            //   significant) error. We still route, but remember     //
            //   it so it takes precedence over the non significant   //
            //   ones.                                                //
            //                                                        //
            ////////////////////////////////////////////////////////////

            //
            // Remember the first error, if it hasn't already been set
            //
            if (dwFirstError == WN_SUCCESS)
                dwFirstError = status ;

            //
            // If the provider returns one of these errors, stop routing.
            //
            if ((status == WN_BAD_POINTER) ||
                (status == WN_MORE_DATA) ||
                (status == WN_SUCCESS))
            {
                //
                // we either succeeded or have problems that means we
                // should not continue (eg. bad input causing exception).
                // and we make sure this is the error reported.
                //
                dwFirstError = status ;
                dwFirstSignificantError = status ;
                statusFlag = 0;
                if ( lpProviderIndex != NULL ) {
                    *lpProviderIndex = indexArray[i];
                }
                break;
            }

            //
            // If the provider returns one of these errors, continue
            // trying other providers, but do not remember as a
            // significant error, because the provider is probably not
            // interested. StatusFlag is use to detect the case where
            // a provider is not started.
            //
            else if (status == WN_NO_NETWORK)
            {
                statusFlag |= NO_NET;
            }
            else if ((status == WN_NOT_CONNECTED) ||
                     (status == WN_BAD_LOCALNAME))
            {
                //
                // WN_NOT_CONNECTED means that lpLocalName is not a
                // redirected device for this provider.
                //
                statusFlag |= BAD_NAME;
            }

            //
            // If a provider returns one of these errors, we continue
            // trying, but remember the error as a significant one. We
            // report it to the user if it is the first. We do this so
            // that if the first provider returns NotConnected and last
            // returns BadPassword, we report the Password Error.
            //
            else
            {
                //
                // All other errors are considered more significant
                // than the ones above
                //
                if (!dwFirstSignificantError && status)
                    dwFirstSignificantError = status ;

                statusFlag = OTHER_ERRS;
            }
        }
    }

    //
    // If we failed, set final error, in order of importance.
    // Significant errors take precedence.  Otherwise we always
    // report the first error.
    //

    if (status != WN_SUCCESS)
    {
        status = (dwFirstSignificantError != WN_SUCCESS) ?
                    dwFirstSignificantError :
                    dwFirstError ;
    }

    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (indexArray != localArray) {
        LocalFree(indexArray);
    }

    //
    // Handle special errors.
    //
    if (statusFlag == (NO_NET | BAD_NAME)) {
        //
        // Check to see if there was a mix of special errors that occured.
        // If so, pass back the combined error message.  Otherwise, let the
        // last error returned get passed back.
        //
        status = WN_NO_NET_OR_BAD_PATH;
    }

CheckRemembered:

    //
    // Handle normal errors passed back from the provider
    //
    if (status != WN_SUCCESS) {

        if (status == WN_NOT_CONNECTED) {
            //
            // If not connected, but there is an entry for the LocalName
            // in the registry, then return the remote name that was stored
            // with it.
            //
            if (MprGetRemoteName(
                    (LPWSTR) lpLocalName,
                    lpBufferSize,
                    lpRemoteName,
                    &status)) {

                if (status == WN_SUCCESS) {
                    status = WN_CONNECTION_CLOSED;
                }

            }
        }
        SetLastError(status);
    }

    return status;
}

DWORD
WNetGetConnection2W (
    IN      LPWSTR   lpLocalName,
    OUT     LPVOID   lpBuffer,
    IN OUT  LPDWORD  lpBufferSize
    )

/*++

Routine Description:

    Just like WNetGetConnectionW except this one returns the provider name
    that the device is attached through

Arguments:

    lpBuffer will contain a WNET_CONNECTIONINFO structure
    lpBufferSize is the number of bytes required for the buffer

Return Value:



--*/
{
    DWORD  status = WN_SUCCESS ;
    DWORD  iProvider = 0 ;
    DWORD  nBytesNeeded = 0 ;
    DWORD  cchBuff = 0 ;
    DWORD  nTotalSize = *lpBufferSize ;
    LPTSTR lpRemoteName= (LPTSTR) ((BYTE*) lpBuffer +
                         sizeof(WNET_CONNECTIONINFO)) ;
    WNET_CONNECTIONINFO * pconninfo = (WNET_CONNECTIONINFO *) lpBuffer ;

    //
    // If they didn't pass in a big enough buffer for even the structure,
    // then make the size zero (so the buffer isn't accessed at all) and
    // let the API figure out the buffer size
    //

    if ( *lpBufferSize < sizeof( WNET_CONNECTIONINFO) ) {
         *lpBufferSize = 0 ;
         cchBuff = 0 ;
    }
    else {
         //
         //  MprGetConnection is expecting character counts, so convert
         //  after offsetting into the structure (places remote name directly
         //  in the structure).
         //
         cchBuff = (*lpBufferSize - sizeof(WNET_CONNECTIONINFO))/sizeof(TCHAR) ;
    }

    MprCheckProviders();

    CProviderSharedLock    PLock;

    status = MprGetConnection(
                lpLocalName,
                lpRemoteName,
                &cchBuff,
                &iProvider);

    if ( status == WN_SUCCESS ||
         status == WN_CONNECTION_CLOSED ||
         status == WN_MORE_DATA  ) {
         //
         //  Now we need to determine the buffer requirements for the
         //  structure and provider name
         //
         //  (Note that if MprGetConnection returns WN_CONNECTION_CLOSED, it
         //  does not touch the value of iProvider.  So iProvider will retain
         //  its somewhat arbitrary initial value of 0, meaning the first
         //  provider in the array.)
         //

         LPTSTR lpProvider = GlobalProviderInfo[iProvider].Resource.lpProvider;

         //
         //  Calculate the required buffer size.
         //

         nBytesNeeded = sizeof( WNET_CONNECTIONINFO ) +
                        (STRLEN( lpProvider) + 1) * sizeof(TCHAR);

         if ( status == WN_MORE_DATA )
         {
             nBytesNeeded +=  cchBuff * sizeof(TCHAR);
         }
         else
         {
             nBytesNeeded +=  (STRLEN( lpRemoteName) + 1) * sizeof(TCHAR);
         }

         if ( nTotalSize < nBytesNeeded ) {
             status = WN_MORE_DATA;
             *lpBufferSize = nBytesNeeded;
             return status;
         }

         //
         //  Place the provider name in the buffer and initialize the
         //  structure to point to the strings.
         //
         pconninfo->lpRemoteName = lpRemoteName ;
         pconninfo->lpProvider = STRCPY( (LPTSTR)
                                ((BYTE*) lpBuffer + sizeof(WNET_CONNECTIONINFO) +
                                (STRLEN( lpRemoteName ) + 1) * sizeof(TCHAR)),
                                lpProvider);
    }

    return status;
}


//===================================================================
// WNetGetConnection3W
//===================================================================

class CGetConnection3 : public CRoutedOperation
{
public:
                    CGetConnection3(
                        LPCWSTR  lpLocalName,
                        LPCWSTR  lpProviderName,
                        DWORD    dwLevel,
                        LPVOID   lpBuffer,
                        LPDWORD  lpBufferSize
                        ) :
                            DBGPARM(CRoutedOperation("GetConnection3"))
                            _lpLocalName   (lpLocalName   ),
                            _lpProviderName(lpProviderName),
                            _dwLevel       (dwLevel       ),
                            _lpBuffer      (lpBuffer      ),
                            _lpBufferSize  (lpBufferSize  )
                        { }

private:

    LPCWSTR         _lpLocalName;
    LPCWSTR         _lpProviderName;
    DWORD           _dwLevel;
    LPVOID          _lpBuffer;
    LPDWORD         _lpBufferSize;

    DECLARE_CROUTED
};


DWORD
CGetConnection3::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    if (_dwLevel != WNGC_INFOLEVEL_DISCONNECTED)
    {
        return WN_BAD_LEVEL;
    }

    if (MprDeviceType(_lpLocalName) != REDIR_DEVICE)
    {
        return WN_BAD_LOCALNAME;
    }

    if (IS_BAD_BYTE_BUFFER(_lpBuffer, _lpBufferSize))
    {
        return WN_BAD_POINTER;
    }

    //
    // Set parameters used by base class.  Note that we set *ppLocalName
    // to NULL to prevent the base class from checking it for "localness"
    // since this is a private API called by the shell for network drives
    // only.  If we ever want to check the local name, the line below will
    // have to be changed to:
    //
    //     *ppLocalName    = _lpLocalName;
    //
    *ppProviderName = _lpProviderName;
    *ppLocalName    = NULL;

    return WN_SUCCESS;
}


DWORD
CGetConnection3::TestProvider(
    const PROVIDER * pProvider
    )
{
    ASSERT_INITIALIZED(NETWORK);

    if (pProvider->GetConnection3 != NULL)
    {
        return ( pProvider->GetConnection3(
                                _lpLocalName,
                                _dwLevel,
                                _lpBuffer,
                                _lpBufferSize) );
    }
    else if (pProvider->GetConnection == NULL)
    {
        return WN_NOT_SUPPORTED;
    }
    else
    {
        // Just verify that the provider owns the connection, and if so,
        // assume that it's not disconnected
        WCHAR wszRemoteName[40];
        DWORD nLength = LENGTH(wszRemoteName);
        DWORD status = pProvider->GetConnection(
                                        (LPWSTR)_lpLocalName,
                                        wszRemoteName,
                                        &nLength);
        if (status == WN_SUCCESS || status == WN_MORE_DATA)
        {
            // The provider owns the connection
            if (*_lpBufferSize < sizeof(WNGC_CONNECTION_STATE))
            {
                *_lpBufferSize = sizeof(WNGC_CONNECTION_STATE);
                status = WN_MORE_DATA;
            }
            else
            {
                ((LPWNGC_CONNECTION_STATE)_lpBuffer)->dwState =
                    WNGC_CONNECTED;
                status = WN_SUCCESS;
            }
        }

        return status;
    }
}


DWORD APIENTRY
WNetGetConnection3W(
    IN  LPCWSTR  lpLocalName,
    IN  LPCWSTR  lpProviderName OPTIONAL,
    IN  DWORD    dwLevel,
    OUT LPVOID   lpBuffer,
    IN OUT LPDWORD lpBufferSize
    )
/*++

Routine Description:

    This function returns miscellaneous information about a network
    connection, as specified by the info level parameter.

Arguments:

    lpLocalName - The name of a redirected local device for which
        information is required.

    lpProviderName - The name of the provider responsible for the connection,
        if known.

    dwLevel - Level of information required.  Supported levels are:

        1 - Determine whether the connection is currently disconnected.

    lpBuffer - Buffer in which to return the information if the call is
        successful.  The format of the information returned is as follows,
        depending on dwLevel:

        Level 1 - A DWORD is returned whose value is one of the following:
            WNGETCON_CONNECTED
            WNGETCON_DISCONNECTED

    lpBufferSize - On input, size of the buffer in bytes.  If the buffer
        is too small, the required size will be written here.
        For level 1 the required size is sizeof(DWORD).

Return Value:

    WN_SUCCESS - successful.
    WN_MORE_DATA - buffer is too small.
    WN_BAD_LOCALNAME - lpLocalName is not a valid device name.
    WN_BAD_PROVIDER - lpProviderName is not a recognized provider name.
    WN_NOT_CONNECTED - the device specified by lpLocalName is not redirected.
    WN_CONNECTION_CLOSED - the device specified by lpLocalName is not
        redirected, but is a remembered (unavailable) connection.

--*/
{
    CGetConnection3 GetConnection3(lpLocalName,
                                   lpProviderName,
                                   dwLevel,
                                   lpBuffer,
                                   lpBufferSize);

    DWORD status = GetConnection3.Perform(TRUE);

    if (status == WN_NOT_CONNECTED &&
        MprFindDriveInRegistry((LPWSTR)lpLocalName,NULL))
    {
        status = WN_CONNECTION_CLOSED;
    }

    return status;
}


DWORD
WNetRestoreConnectionW(
    IN  HWND    hWnd,
    IN  LPCWSTR lpDevice
    )
{
    return WNetRestoreConnection2W(hWnd, lpDevice, 0, NULL);
}


DWORD
WNetRestoreConnection2W(
    IN  HWND    hWnd,
    IN  LPCWSTR lpDevice,
    IN  DWORD   dwFlags,
    OUT BOOL*   pfReconnectFailed
    )
/*++

Routine Description:

    This function create another thread which does the connection.
    In the main thread it create a dialog window to monitor the  state of
    the connection.

Arguments:

    hwnd - This is a window handle that may be used as owner of any
        dialog brought up by MPR (eg. password prompt).

    lpDevice - This may be NULL or may contain a device name such as
        "x:". If NULL, all remembered connections are restored.  Otherwise,
        the remembered connection for the specified device, if any are
        restored.

    dwFlags - WNRC_NOUI specifies that no UI should be shown. Connections that
              fail to restore will be reattempted at next logon.

Return Value:
--*/
{
    DWORD               status               = WN_SUCCESS;
    DWORD               print_connect_status = WN_SUCCESS;
    DWORD               numSubKeys;
    DWORD               RegMaxWait = 0;
    HANDLE              hThread              = NULL;
    HANDLE              ThreadID;
    LPCONNECTION_INFO   ConnectArray;
    PARAMETERS         *lpParams             = NULL;
    BOOL                DontDefer            = FALSE;
    LONG                fDoCleanup           = FALSE;

    if (pfReconnectFailed)
    {
        *pfReconnectFailed = FALSE;
    }

    //
    // Check the registry to see if we need to restore connections or not,
    // and whether we can defer them.
    // This is done only if lpDevice is NULL (restoring all).
    // (If a particular device is specified, it is always restored undeferred.)
    //
    // Interpretation of the RestoreConnection value is:
    // 0 - don't restore connections (and ignore the DeferConnection value)
    // default - restore connections
    //
    // Interpretation of the DeferConnection value is:
    // 0 - don't defer any connections
    // default - defer every connection that can be deferred
    //
    if ( lpDevice == NULL )
    {
        HKEY   providerKeyHandle;
        DWORD  ValueType;
        DWORD  fRestoreConnection = TRUE;
        DWORD  Temp = sizeof( fRestoreConnection );

        if( MprOpenKey(  HKEY_LOCAL_MACHINE,     // hKey
                         NET_PROVIDER_KEY,       // lpSubKey
                        &providerKeyHandle,      // Newly Opened Key Handle
                         DA_READ))               // Desired Access
        {
            if ( RegQueryValueEx(
                    providerKeyHandle,
                    RESTORE_CONNECTION_VALUE,
                    NULL,
                    &ValueType,                  // not used
                    (LPBYTE) &fRestoreConnection,
                    &Temp) == NO_ERROR )
            {
                if ( !fRestoreConnection )
                {
                    MPR_LOG0(RESTORE, "Registry says NOT to restore connections\n");
                    RegCloseKey( providerKeyHandle );
                    return WN_SUCCESS;
                }
            }

            DWORD fDeferConnection;

            if (MprGetKeyDwordValue(
                    providerKeyHandle,
                    DEFER_CONNECTION_VALUE,
                    &fDeferConnection) &&
                fDeferConnection == 0 )
            {
                MPR_LOG0(RESTORE, "Registry says NOT to defer restored connections\n");
                DontDefer = TRUE;
            }

            RegCloseKey( providerKeyHandle );
        }
    }

    __try {
        if (lpDevice != NULL)
        {
            if (MprDeviceType (lpDevice) != REDIR_DEVICE)
            {
                status = WN_BAD_LOCALNAME;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG (ERROR, "WNetRestoreConnectionW:Unexpected Exception 0x%1x\n",status);
        }
        status = WN_BAD_POINTER;
    }
    if (status != WN_SUCCESS)
    {
        SetLastError(status);
        return status;
    }

    //
    // MprCreateConnectionArray may use the providers
    //

    MprCheckProviders();

    {
        CProviderSharedLock    PLock;

        //
        // Read all the connection info from the registry.
        //
        status = MprCreateConnectionArray (&numSubKeys,
                                           lpDevice,
                                           &RegMaxWait,
                                           &ConnectArray);
        if (lpDevice == NULL)
        {
            //
            // only wory about Print if restoring all
            //
            print_connect_status = MprAddPrintersToConnArray (&numSubKeys,
                                                              &ConnectArray);
        }

        //
        // if both failed, report first error. else do the best we can.
        //
        if (status != WN_SUCCESS && print_connect_status != WN_SUCCESS)
        {
            SetLastError (status);
            return status;
        }

        if (numSubKeys == 0)
        {
            return(WN_SUCCESS);
        }

        INIT_IF_NECESSARY(NETWORK_LEVEL,status);

        //
        // If there are no providers, return NO_NETWORK
        //
        if (GlobalNumActiveProviders == 0)
        {
            MprFreeConnectionArray(ConnectArray, numSubKeys);
            SetLastError(WN_NO_NETWORK);
            return(WN_NO_NETWORK);
        }

        //
        // Refcount all the provider DLLs we may use since we may
        // have to call DoProfileErrorDialog, which calls outside
        // mpr.dll and can potentially loop back, causing deadlock.
        // By refcounting here, we don't have to worry about
        // releasing/reacquiring the lock or over-refcounting the
        // provider DLLs later on.
        //

        MprRefcountConnectionArray(ConnectArray, numSubKeys);
    }

    // If lpDevice is not NULL, call MprRestoreThisConnection directly.

    if (lpDevice)
    {
        status = MprRestoreThisConnection (hWnd, NULL, &ConnectArray[0], dwFlags);
        ConnectArray[0].Status = status;
        if ((status != WN_SUCCESS) &&
            (status != WN_CANCEL) &&
            (status != WN_CONTINUE))
        {
            if (!(dwFlags & WNRC_NOUI))
            {
                DoProfileErrorDialog (hWnd,
                                      ConnectArray[0].NetResource.lpLocalName,
                                      ConnectArray[0].NetResource.lpRemoteName,
                                      ConnectArray[0].NetResource.lpProvider,
                                      ConnectArray[0].Status,
                                      FALSE, //No cancel button.
                                      NULL,
                                      NULL,
                                      NULL); // no skip future errors checkbox
            }

            if (pfReconnectFailed)
            {
                *pfReconnectFailed = TRUE;
            }
        }

        //
        // ConnectArray isn't used any more for the single-drive case
        //

        MprFreeConnectionArray(ConnectArray, numSubKeys);
    }
    else do // not a loop. error break out.
    {
        //
        // Initialize lpParams.
        //
        lpParams = (PARAMETERS *) LocalAlloc (LPTR,
                                              sizeof (PARAMETERS));
        if ((lpParams == NULL) ||
            (lpParams->hDlgCreated
                = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL ||
            (lpParams->hDlgFailed
                = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL ||
            (lpParams->hDonePassword
                = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        {
            status = GetLastError();

            if (lpParams != NULL)
            {
                if (lpParams->hDlgCreated != NULL)
                    CloseHandle(lpParams->hDlgCreated);

                if (lpParams->hDlgFailed != NULL)
                    CloseHandle(lpParams->hDlgFailed);

                if (lpParams->hDonePassword != NULL)
                    CloseHandle(lpParams->hDonePassword);
            }

            break;
        }

        lpParams->numSubKeys     = numSubKeys;
        lpParams->RegMaxWait     = RegMaxWait;
        lpParams->ConnectArray   = ConnectArray;
        lpParams->dwRestoreFlags = dwFlags;
        lpParams->fReconnectFailed = FALSE;

        //
        // Decide whether to show the "Restoring Connections" dialog.
        // In general, if a connection will be made as a user other than the
        // default logged-on user, we need to give the user a chance to enter
        // the password and have it validated, hence we need to contact the
        // server, so we should show the dialog.
        //
        BOOL NeedDialog;

        if (DontDefer)
        {
            NeedDialog = TRUE;
        }
        else
        {
            NeedDialog = FALSE;

            //
            // Get the default user and domain names to connect as
            //
            PUNICODE_STRING UserName;
            PUNICODE_STRING DomainName;
            NTSTATUS ntStatus = LsaGetUserName(&UserName, &DomainName);
            if (NT_SUCCESS(ntStatus))
            {
                MPR_LOG2(RESTORE,"Default domain name = \"%ws\", user name = \"%ws\"\n",
                         DomainName->Buffer, UserName->Buffer);
            }
            else
            {
                MPR_LOG(ERROR, "LsaGetUserName failed, %#lx\n", ntStatus);
                DomainName = NULL;
                UserName = NULL;
            }

            //
            // If the logon domain is the local machine, don't defer connections.
            // This is a NT 4.0 workaround for the most common case of bug 36827.
            // When connecting to an LM server, if the user name happens to
            // match a local user name on the target server, the server will
            // normally attempt to log on using THAT user's account; hence we
            // need to prompt for the password.  We need to do this since this
            // behavior is by design in the redirector.
            //
            WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH+1];
            DWORD nSize = LENGTH(ComputerName);
            if (DomainName == NULL ||
                GetComputerName(ComputerName, &nSize) == FALSE ||
                _wcsicmp(ComputerName, DomainName->Buffer) == 0)
            {
                MPR_LOG0(RESTORE, "Local logon, will not defer connections\n");
                NeedDialog = TRUE;
            }
            else
            {
                //
                // Prescan  the connections to determine which ones we can
                // defer and whether we need the reconnect dialog. If all
                // connections are deferred, we do not bother with the dialog.
                //
                for (DWORD i = 0; i < numSubKeys; i++)
                {
                    if (! ConnectArray[i].ContinueFlag)
                    {
                        continue;
                    }

                    //
                    // The DEFER_UNKNOWN flag means don't defer the connection
                    // on this logon, but try the default credentials and see
                    // if they work; if so, the connection can be deferred at
                    // subsequent logons.
                    //
                    // Don't defer the connection if a password was explicitly
                    // specified when the connection was made.  This covers
                    // cases in which the redir won't send the default password
                    // to the server at connect time because the server doesn't
                    // support encrypted passwords.
                    //
                    if (! (ConnectArray[i].DeferFlags & DEFER_UNKNOWN)
                         &&
                        ! (ConnectArray[i].DeferFlags & DEFER_EXPLICIT_PASSWORD)
                         &&
                        MprUserNameMatch(DomainName,
                                         UserName,
                                         ConnectArray[i].UserName,
                                         FALSE))
                    {
                        //
                        // If the user name is the default user name, we can safely
                        // replace it with a NULL.  (This is not only more optimal, but
                        // also required in order to work around a LM redir problem
                        // with the way credentials for deferred connections are stored.)
                        //
                        LocalFree(ConnectArray[i].UserName);
                        ConnectArray[i].UserName = NULL;

                        //
                        // It's OK to defer the connection iff the remembered user
                        // name matches the default user name and the provider
                        // supports deferred connections.
                        //
                        if ((ConnectArray[i].dwConnectCaps & WNNC_CON_DEFER)
                              &&
                            (ConnectArray[i].pfAddConnection3 != NULL))
                        {
                            //
                            // Defer was initialized to 0 when the array was
                            // allocated.
                            // Note that we don't defer if an lpDevice was supplied.
                            //
                            ConnectArray[i].Defer = TRUE;
                        }
                    }

                    if (! ConnectArray[i].Defer)
                    {
                        NeedDialog = TRUE;
                    }
                } // for each connection

                MprSortConnectionArray(ConnectArray, numSubKeys);
            }

            if (DomainName != NULL)
            {
                LsaFreeMemory(DomainName->Buffer);
                LsaFreeMemory(DomainName);
            }
            if (UserName != NULL)
            {
                LsaFreeMemory(UserName->Buffer);
                LsaFreeMemory(UserName);
            }
        }


        //
        // If we are:
        // USING DIALOGS WHEN RESTORING CONNECTIONS...
        //
        // This main thread will used to service a windows event loop
        // by calling ShowReconnectDialog.  Therefore, a new thread
        // must be created to actually restore the connections.  As we
        // attempt to restore each connection, a message is posted in
        // this event loop that causes it to put up a dialog that
        // describes the connection and has a "cancel" option.
        //

        if (! NeedDialog)
        {
            lpParams->hDlg = INVALID_WINDOW_HANDLE;
            // CODEWORK: We are using this INVALID_WINDOW_HANDLE to tell
            // the various routines whether there are 2 threads or not.
            // Instead we should add a new field, BOOL fSeparateThread,
            // to PARAMETERS.  This requires changing routines in mprui.dll
            // as well as mpr.dll.

            DoRestoreConnection(lpParams);
        }
        else
        {
            HANDLE hThreadToken;

            // If the main thread is impersonating, we have to copy its token to
            // the new thread that is being spawned so it runs in the correct context

            if (!OpenThreadToken (GetCurrentThread(),
                                  TOKEN_IMPERSONATE,
                                  TRUE,
                                  &hThreadToken)
                &&
                !OpenProcessToken(GetCurrentProcess(),
                                  TOKEN_IMPERSONATE,
                                  &hThreadToken))
            {
                    //
                    // Couldn't open a token on the thread or the process
                    //
                    status = GetLastError();
            }
            else
            {
                // lpParams->hDlg was initialized to 0 by LocalAlloc
                // and will be set to an HWND by ShowReconnectDialog

                hThread = CreateThread (NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE) &DoRestoreConnection,
                                        (LPVOID) lpParams,
                                        CREATE_SUSPENDED,
                                        (LPDWORD) &ThreadID);
                if (hThread == NULL)
                {
                    status = GetLastError();
                }
                else
                {
                    //
                    // Make sure the worker thread isn't killed if
                    // this thread finishes while it's wedged in a
                    // provider call (in MprRestoreThisConnection).
                    // The DLL is unloaded by DoRestoreConnection
                    //
                    lpParams->hDll = LoadLibraryEx( L"mpr.dll",
                                                    NULL,
                                                    LOAD_WITH_ALTERED_SEARCH_PATH );

                    if (lpParams->hDll == NULL) {

                        MPR_LOG1(RESTORE,
                                 "LoadLibraryEx for mpr.dll FAILED %d\n",
                                 GetLastError());

                        //
                        // This shouldn't happen since all we're
                        // doing is upping our refcount
                        //
                        ASSERT(FALSE);
                    }

                    //
                    // Assign the impersonation token to the
                    // thread and resume/start it
                    //

                    if (!SetThreadToken(&hThread, hThreadToken))
                    {
                        status = GetLastError();
                        TerminateThread(hThread, NO_ERROR);
                        CloseHandle(hThread);
                    }
                    else
                    {
                        ResumeThread(hThread);
                        CloseHandle(hThread);

                        status = ShowReconnectDialog(hWnd, lpParams);
                    }

                    if (status == WN_SUCCESS && lpParams->status != WN_CANCEL &&
                        lpParams->status != WN_SUCCESS )
                    {
                        SetLastError (lpParams->status);
                    }

                    if (lpParams->status != WN_CANCEL)
                    {
                        status = MprNotifyErrors (hWnd, ConnectArray, numSubKeys, dwFlags);
                    }
                }

                CloseHandle(hThreadToken);
            }
        }

        //
        // Only if we make it to the end of the do-while loop do the thread
        // parameters have to be cleaned up.  Since either this thread or
        // the worker thread might exit first (if the user hits Cancel and
        // the worker thread is stuck in a provider call, this thread could
        // exit first), the InterlockedExchange calls here and at the end
        // of DoRestoreConnection ensure that the last thread leaving
        // does the cleanup.
        //
        // NOTE:  This relies on the fact that the only break out of
        //        this do-while occurs when LocalAlloc for lpParams FAILS.
        //        Adding new break statements may break this logic!
        //
        //
        // Case 1:  lpParams never gets allocated -- this bit of code
        //          never gets hit since we break out of the loop above
        //          and nobody cleans up (correctly)
        //
        // Case 2:  CreateThread fails -- hThread is NULL, so this thread
        //          needs to clean up
        //
        //          (CODEWORK -- should this thread call DoRestoreConnection
        //           directly in that case?)
        //
        // Case 3:  The worker thread exits first -- it changes fDoCleanup
        //          to TRUE before it exits and this thread cleans up
        //
        // Case 4:  This thread exits first (user cancels dialog) -- this
        //          thread changes fDoCleanup to TRUE and orphans the
        //          worker thread.  When it finishes its provider call,
        //          it reads fDoCleanup and cleans up.
        //

        // Poll the worker thread's data to see if reconnect failed.
        if (pfReconnectFailed)
        {
            *pfReconnectFailed = lpParams->fReconnectFailed;
        }

        fDoCleanup = (InterlockedExchange(&lpParams->fDoCleanup, TRUE)
                       ||
                      hThread == NULL);

    } while (FALSE);

    //
    // Is this thread supposed to clean up?  Note that ConnectArray
    // was freed above for the single-drive case so we don't need
    // to worry about it here (i.e., fDoCleanup should only be TRUE
    // in the all-drive, multi-threaded case).
    //

    if (fDoCleanup)
    {
        MPR_LOG0(RESTORE, "Main thread will perform cleanup\n");

        ASSERT(lpParams != NULL);

        //
        // Free up resources in preparation to return.
        //
        if (!CloseHandle(lpParams->hDlgCreated))
            status = GetLastError();

        if (!CloseHandle(lpParams->hDlgFailed))
            status = GetLastError();

        if (!CloseHandle(lpParams->hDonePassword))
            status = GetLastError();

        LocalFree(lpParams);

        MprFreeConnectionArray(ConnectArray, numSubKeys);
    }

    // Send a notification about the new network drive(s).
    if( (g_LUIDDeviceMapsEnabled == TRUE) && (lpDevice != NULL))
    {
        // Use LUID broadcast mechanism
        MprBroadcastDriveChange(
            lpDevice,
            FALSE );    // not a Delete Message
    }
    else
    {
        MprNotifyShell(L" :");
    }

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
    }

    return status;
}


VOID
MprSortConnectionArray(
    LPCONNECTION_INFO lpcConnectArray,
    DWORD             dwNumSubKeys
    )
/*++

Routine Description:

    This function sorts the array of connections by placing the
    connections that can be deferred before those that can't

Arguments:

    lpcConnectArray -- The array of CONNECTION_INFO structures

    dwNumSubKeys -- The number of structures in the array

Notes:

    This sort is done to improve behavior at boot.  Deferred connections are
    faster and less error-prone than non-deferred connections and errors can
    cause popups that allow the user to stop reconnecting drives, which leaves
    the remaining drives in the annoying "Unavailable" state.  Note that most
    popups for drive reconnection at boot are for credentials, which is a popup
    associated only with non-deferred connection.  By reconnecting deferred
    connections first, we avoid this problem.

--*/
{
    INT   nLow     = 0;
    INT   nHigh    = dwNumSubKeys - 1;
    BOOL  fSwap;

    CONNECTION_INFO ciTemp;

    do {

        //
        // Find the first non-deferred connection
        //
        while (nLow < (INT)dwNumSubKeys
               &&
               lpcConnectArray[nLow].Defer) {

            nLow++;
        }

        //
        // Find the last deferred connection
        //
        while (nHigh >= 0
               &&
               !lpcConnectArray[nHigh].Defer) {

            nHigh--;
        }

        fSwap = (nLow < nHigh);

        //
        // Only swap if the pointers haven't crossed
        // (otherwise we'd be undoing the sorting)
        //
        if (fSwap) {

            ciTemp = lpcConnectArray[nLow];
            lpcConnectArray[nLow++]  = lpcConnectArray[nHigh];
            lpcConnectArray[nHigh--] = ciTemp;
        }
    }
    while (fSwap);

#if DBG

    MPR_LOG0(RESTORE, "Order of sorted connection array is as follows:\n");

    for (UINT i = 0; i < dwNumSubKeys; i++) {

        MPR_LOG3(RESTORE,
                 "\tLocal: %ws, \tRemote: %ws, \tDefer: %d\n",
                 lpcConnectArray[i].NetResource.lpLocalName,
                 lpcConnectArray[i].NetResource.lpRemoteName,
                 lpcConnectArray[i].Defer);
    }

#endif // DBG

}


VOID
MprRefcountConnectionArray(
    LPCONNECTION_INFO lpcConnectArray,
    DWORD             dwNumSubkeys
    )

/*++

Routine Description:

    This function sorts refcounts the provider DLLs in the array
    of connections in preparation for a call outside of mpr.dll
    (which requires releasing the provider lock to avoid the
    possibility of reentrancy and deadlock)

Arguments:

    lpcConnectArray -- The array of CONNECTION_INFO structures

    dwNumSubKeys -- The number of structures in the array

Notes:


--*/
{
    UINT       i;
    LPPROVIDER lpProvider;

    ASSERT_INITIALIZED(NETWORK);

    for (i = 0; i < dwNumSubkeys; i++)
    {
        //
        // If this hits, we're over-refcounting
        //
        ASSERT(lpcConnectArray[i].hProviderDll == NULL);

        lpProvider = &GlobalProviderInfo[lpcConnectArray[i].ProviderIndex];

        lpcConnectArray[i].hProviderDll = LoadLibraryEx(lpProvider->DllName,
                                                        NULL,
                                                        LOAD_WITH_ALTERED_SEARCH_PATH);

        if (lpcConnectArray[i].hProviderDll != NULL)
        {
            lpcConnectArray[i].pfGetCaps          = lpProvider->GetCaps;
            lpcConnectArray[i].pfAddConnection3   = lpProvider->AddConnection3;
            lpcConnectArray[i].pfAddConnection    = lpProvider->AddConnection;
            lpcConnectArray[i].pfCancelConnection = lpProvider->CancelConnection;
            lpcConnectArray[i].dwConnectCaps      = lpProvider->ConnectCaps;
        }
        else
        {
            MPR_LOG2(ERROR,
                     "MprRefcountConnectionArray: LoadLibraryEx on %ws failed %d\n",
                     lpProvider->DllName,
                     GetLastError());
        }
    }
}



DWORD
WNetSetConnectionW(
    IN  LPCWSTR lpName,
    IN  DWORD   dwProperty,
    IN  LPVOID  pvValue
    )

/*++

Routine Description:

    This function changes the characteristics of a network connection.

Arguments:

    lpName - The name of either the redirected local device or a remote
        network resource.

    dwProperty - Identifies the property to be changed.
        Current properties supported:
        NETPROPERTY_PERSISTENT - pvValue points to a DWORD.  If TRUE,
            the connection is made persistent.  If FALSE, the connection
            is made non-persistent.

    pvValue - Pointer to the property value.  Type depends on dwProperty.

Return Value:

    WN_SUCCESS - successful

    WN_BAD_LOCALNAME or WN_NOT_CONNECTED - lpName is not a redirected device

--*/
{
    DWORD status = WN_SUCCESS;

    if (!(ARGUMENT_PRESENT(lpName) &&
          ARGUMENT_PRESENT(pvValue)))
    {
        SetLastError(WN_BAD_POINTER);
        return(WN_BAD_POINTER);
    }

    // NPGetUser and some Mpr internal functions use lpName as a non-const
    // argument, so we have to make a copy
    WCHAR * lpNameCopy = (WCHAR *) LocalAlloc(LMEM_FIXED, WCSSIZE(lpName));
    if (lpNameCopy == NULL)
    {
        SetLastError(WN_OUT_OF_MEMORY);
        return(WN_OUT_OF_MEMORY);
    }
    wcscpy(lpNameCopy, lpName);

    switch (dwProperty)
    {
        case NETPROPERTY_PERSISTENT:
        {
            MprCheckProviders();

            CProviderSharedLock    PLock;

            __try
            {
                //
                // Value should be a boolean DWORD telling whether to
                // remember or forget the connection
                //
                BOOL bRemember = * ((DWORD *) pvValue);

                //
                // Verify that lpName is a redirected local device, and
                // identify the provider responsible
                //
                WCHAR wszRemoteName[MAX_PATH+1];
                DWORD cbBuffer = sizeof(wszRemoteName);
                DWORD iProvider;                    // provider index

                status = MprGetConnection(
                                    lpName,
                                    wszRemoteName,
                                    &cbBuffer,
                                    &iProvider);

                if (status == WN_CONNECTION_CLOSED)
                {
                    //
                    // It's already a remembered connection.  Nothing to do.
                    //
                    status = WN_SUCCESS;
                    __leave;
                }

                if (status != WN_SUCCESS)
                {
                    ASSERT(status != WN_MORE_DATA);
                    __leave;
                }

                if (bRemember)
                {
                    //
                    // Get the username for the connection from the provider
                    //
                    WCHAR wszUser[MAX_PATH+1];
                    cbBuffer = LENGTH(wszUser);
                    status = GlobalProviderInfo[iProvider].GetUser(
                                            lpNameCopy, wszUser, &cbBuffer);

                    if (status != WN_SUCCESS)
                    {
                        ASSERT(status != WN_MORE_DATA);
                        __leave;
                    }

                    //
                    // Get the provider flags, if any
                    //
                    ASSERT_INITIALIZED(NETWORK);

                    BYTE ProviderFlags = 0;
                    if (GlobalProviderInfo[iProvider].GetReconnectFlags != NULL)
                    {
                        // This is an internal entry point so we don't bother with
                        // try-except
                        DWORD status2 = GlobalProviderInfo[iProvider].GetReconnectFlags(
                                                    lpNameCopy,
                                                    &ProviderFlags
                                                    );
                        if (status2 != WN_SUCCESS)
                        {
                            ProviderFlags = 0;
                        }
                        MPR_LOG3(RESTORE, "%ws wants flags %#x saved for %ws\n",
                                    GlobalProviderInfo[iProvider].Resource.lpProvider,
                                    ProviderFlags,
                                    lpNameCopy);
                    }

                    //
                    // Make the connection persistent
                    //
                    status = I_MprSaveConn(
                                HKEY_CURRENT_USER,
                                GlobalProviderInfo[iProvider].Resource.lpProvider,
                                GlobalProviderInfo[iProvider].Type,
                                wszUser,
                                lpNameCopy,
                                wszRemoteName,
                                (wcslen(lpName) == 2 && lpName[1] == L':')
                                    ? RESOURCETYPE_DISK
                                    : RESOURCETYPE_PRINT,
                                ProviderFlags,
                                DEFER_UNKNOWN
                                );
                }
                else
                {
                    //
                    // Make the connection non-persistent
                    //
                    MprForgetRedirConnection(lpNameCopy);
                    status = WN_SUCCESS;
                }
            }
            __except (MPR_EXCEPTION_FILTER)
            {
                status = WN_BAD_POINTER;
            }

            break;
        }

        default:
            status = WN_BAD_VALUE;
    }

    LocalFree(lpNameCopy);

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
    }

    return status;
}



typedef LRESULT WINAPI FN_PostMessage( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam) ;
#ifdef UNICODE
  #define USER32_DLL_NAME L"user32.dll"
  #define POST_MSG_API_NAME "PostMessageW"
#else
  #define USER32_DLL_NAME "user32.dll"
  #define POST_MSG_API_NAME "PostMessageA"
#endif

static HMODULE _static_hUser32 = NULL;
static FN_PostMessage * _static_pfPostMsg = NULL;


VOID
DoRestoreConnection(
    PARAMETERS *Params
    )

/*++

Routine Description:

    This function is run as a separate thread from the main thread (which
    services a windows event loop).  It attempts to restore all connections
    that were saved in the registry for this user.

    For each connection that we try to restore, a message is posted to
    the main thread that causes it to put up a dialog box which describes
    the connection and allows the user the option of cancelling.

    If a longer timeout than the default is desired,  this function will
    look in the following location in the registry for a timeout value:

    \HKEY_LOCAL_MACHINE\system\CurrentControlSet\Control\NetworkProvider
        RestoreTimeout = REG_DWORD  ??
--*/
{
    DWORD               status = WN_SUCCESS;
    DWORD               providerIndex=0;
    DWORD               Temp;
    DWORD               numSubKeys = Params->numSubKeys;
    DWORD               MaxWait = 0;    // timeout interval
    DWORD               RegMaxWait = Params->RegMaxWait;   // timeout interval stored in registry.
    DWORD               ElapsedTime;    // interval between start and current time.
    DWORD               CurrentTime;    // Current ClockTick time
    DWORD               StartTime;
    DWORD               i;
    BOOL                UserCancelled = FALSE;
    BOOL                ContinueFlag;
    BOOL                fDisconnect = FALSE;
    LPCONNECTION_INFO   ConnectArray = Params->ConnectArray;
    HANDLE              lpHandles[2];
    DWORD               dwSleepTime = RECONNECT_SLEEP_INCREMENT ;
    DWORD               j;
    DWORD               numStillMustContinue;
    DWORD               dwValue;
    DWORD               RestoredDrivesMask = 0;
    DWORD               CurrDriveMask;
    LPWSTR              lpLocalName;
    WCHAR               DriveLetterName[3];    // "<drive letter>:<NULL>"
    HINSTANCE           hDll = Params->hDll;  // This needs to be checked
                                              // Params is freed

    //
    // Don't check providers here as this isn't a top-level WNet API.
    // No need to grab the shared lock here because the ConnectArray
    // already contains all the entrypoints we need and the provider
    // DLLs have all been refcounted.
    //

    lpHandles[0] = Params->hDlgCreated;
    lpHandles[1] = Params->hDlgFailed;

    StartTime = GetTickCount();

    if (RegMaxWait != 0)
    {
        MaxWait = RegMaxWait;
    }

    if ( _static_pfPostMsg == NULL )
    {
        MprEnterLoadLibCritSect();

        if (_static_hUser32 = LoadLibraryEx(USER32_DLL_NAME,
                                            NULL,
                                            LOAD_WITH_ALTERED_SEARCH_PATH))
        {
            _static_pfPostMsg = (FN_PostMessage *) GetProcAddress( _static_hUser32,
                                                                   POST_MSG_API_NAME );
        }

        MprLeaveLoadLibCritSect();

        if ( _static_pfPostMsg == NULL )
        {
            Params->status = GetLastError();
            goto CleanExit;
        }
    }

    if(Params->hDlg == INVALID_WINDOW_HANDLE)
    {
        dwValue = 0;
    }
    else
    {
        dwValue =  WaitForMultipleObjects (2, lpHandles, FALSE, INFINITE);
    }

    switch(dwValue)
    {
    case 1: // hDlgFailed signaled. Info dialog failed to construct.
        break;

    case 0: // hDlgCreated signaled. Info dialog constructed successfully.

        MPR_LOG0(RESTORE,"Enter Loop where we will attempt to restore connections\n");

        do
        {
            //
            // If HideErrors becomes TRUE, stop displaying error dialogs.
            //
            BOOL fHideErrors = (Params->dwRestoreFlags & WNRC_NOUI) ? TRUE : FALSE;

            //
            // Each time we go through all the connections, we need to
            // reset the continue flag to FALSE.
            //
            ContinueFlag = FALSE;

            //
            // Go through each connection information in the array.
            //
            for (i = 0; i < numSubKeys; i++) {

                // Let dialog thread print out the current connection.
                if(Params->hDlg != INVALID_WINDOW_HANDLE)
                {
                    (*_static_pfPostMsg) (Params->hDlg,
                                 SHOW_CONNECTION,
                                 (WPARAM) ConnectArray[i].NetResource.lpRemoteName,
                                 0);
                }

                //
                // Setting status to SUCCESS forces us down the success path
                // if we are not to continue adding this connection.
                //
                status = WN_SUCCESS;

                if (ConnectArray[i].ContinueFlag)
                {
                    status = MprRestoreThisConnection (NULL,
                                                       Params,
                                                       &(ConnectArray[i]),
                                                       Params->dwRestoreFlags);
                }

                switch (status)
                {
                    case WN_SUCCESS:
                        ConnectArray[i].Status = WN_SUCCESS;
                        ConnectArray[i].ContinueFlag = FALSE;

                        if( g_LUIDDeviceMapsEnabled == TRUE )
                        {
                            lpLocalName = ConnectArray[i].NetResource.lpLocalName;
                            if( lpLocalName != NULL &&
                                wcslen(lpLocalName) == 2 &&
                                lpLocalName[1] == L':' &&
                                iswalpha(lpLocalName[0]) )
                            {
                                DriveLetterName[0] = RtlUpcaseUnicodeChar( lpLocalName[0] );
                                RestoredDrivesMask |= 1<<(DriveLetterName[0] - L'A');
                            }
                        }
                        break;

                    case WN_CONTINUE:
                        break;

                    case WN_NO_NETWORK:
                    case WN_FUNCTION_BUSY:

                        //
                        // If this is the first pass through, we don't have
                        // the wait times figured out for each provider. Do that
                        // now.
                        //

                        if (ConnectArray[i].ProviderWait == 0)
                        {
                            MPR_LOG0(RESTORE,"Ask provider how long it will take "
                            "for the net to come up\n");

                            Temp = ConnectArray[i].pfGetCaps(WNNC_START);

                            MPR_LOG2(RESTORE,"GetCaps(START) for Provider %ws yields %d\n",
                                ConnectArray[i].NetResource.lpProvider,
                                Temp)

                            switch (Temp)
                            {
                            case PROVIDER_WILL_NOT_START:
                                MPR_LOG0(RESTORE,"Provider will not start\n");
                                ConnectArray[i].ContinueFlag = FALSE;
                                ConnectArray[i].Status = status;
                                break;

                            case NO_TIME_ESTIMATE:
                                MPR_LOG0(RESTORE,"Provider doesn't have time estimate\n");

                                if (RegMaxWait != 0) {
                                    ConnectArray[i].ProviderWait = RegMaxWait;
                                }
                                else {
                                    ConnectArray[i].ProviderWait = DEFAULT_WAIT_TIME;
                                }
                                if (MaxWait < ConnectArray[i].ProviderWait) {
                                    MaxWait = ConnectArray[i].ProviderWait;
                                }
                                break;

                            default:
                                MPR_LOG1(RESTORE,"Provider says it will take %d msec\n",
                                Temp);
                                if ((Temp <= MAX_ALLOWED_WAIT_TIME) && (Temp > MaxWait))
                                {
                                    MaxWait = Temp;
                                }
                                ConnectArray[i].ProviderWait = MaxWait;
                                break;
                            }
                        }

                        //
                        // If the status for this provider has just changed to
                        // WN_FUNCTION_BUSY from some other status, then calculate
                        // a timeout time by getting the provider's new timeout
                        // and adding that to the elapsed time since start.  This
                        // gives a total elapsed time until timeout - which can
                        // be compared with the current MaxWait.
                        //
                        if ((status == WN_FUNCTION_BUSY) &&
                            (ConnectArray[i].Status == WN_NO_NETWORK))
                        {
                            Temp = ConnectArray[i].pfGetCaps(WNNC_START);

                            MPR_LOG2(RESTORE,"Changed from NO_NET to BUSY\n"
                                "\tGetCaps(START) for Provider %ws yields %d\n",
                                ConnectArray[i].NetResource.lpProvider,
                                Temp);

                            switch (Temp)
                            {
                            case PROVIDER_WILL_NOT_START:
                                //
                                // This is bizzare to find the status = BUSY,
                                // but to have the Provider not starting.
                                //
                                ConnectArray[i].ContinueFlag = FALSE;
                                break;

                            case NO_TIME_ESTIMATE:
                                //
                                // No need to alter the timeout for this one.
                                //
                                break;

                            default:

                                //
                                // Make sure this new timeout information will take
                                // less than the maximum allowed time from providers.
                                //
                                if (Temp <= MAX_ALLOWED_WAIT_TIME)
                                {
                                    CurrentTime = GetTickCount();

                                    //
                                    // Determine how much time has elapsed since
                                    // we started.
                                    //
                                    ElapsedTime = CurrentTime - StartTime;

                                    //
                                    // Add the Elapsed time to the new timeout we
                                    // just received from the provider to come up
                                    // with a timeout value that can be compared
                                    // with MaxWait.
                                    //
                                    Temp += ElapsedTime;

                                    //
                                    // If the new timeout is larger that MaxWait,
                                    // then use the new timeout.
                                    //
                                    if (Temp > MaxWait)
                                    {
                                        MaxWait = Temp;
                                    }
                                }
                            } // End Switch(Temp)
                        } // End If (change state from NO_NET to BUSY)

                        //
                        // Store the status (either NO_NET or BUSY) with the
                        // connect info.
                        //

                        if (ConnectArray[i].ContinueFlag)
                        {
                            ConnectArray[i].Status = status;
                            break;
                        }

                    case WN_CANCEL:
                        ConnectArray[i].Status = status;
                    default:
                        //
                        // For any other error, call the Error Dialog
                        //

                        Params->fReconnectFailed = TRUE;

                        if (fHideErrors) {
                            fDisconnect = FALSE;
                        } else {
                            //
                            // Count the number of connections which have not
                            // been resolved.  If there is exactly one, do not
                            // give the user the option to cancel.
                            //
                            numStillMustContinue = 0;

                            for (j = 0; j < numSubKeys; j++) {
                                if (ConnectArray[j].ContinueFlag) {
                                    numStillMustContinue++;
                                }
                            }

                            MPR_LOG1(RESTORE,"DoProfileErrorDialog with "
                                        "%d connections remaining\n",
                                        numStillMustContinue);

                            //
                            // We need to bump up the refcount for mprui.dll
                            // here since we're in a separate thread and
                            // WNetRestoreConnectionsW could return with this
                            // UI still up.  If that happens and the process
                            // calls WNetClearConnections, we'll AV as soon as
                            // a message is sent to the UI window since
                            // WNetClearConnections unloads mprui.dll (this can
                            // happen in winlogon.exe).  Note that this function
                            // will load mprui.dll globally if it hasn't already
                            // been done so after the first LoadLibrary call here,
                            // we're merely playing around with the DLL refcount
                            // rather than loading/unloading DLLs every time.
                            //
                            HINSTANCE  hDll = LoadLibraryEx(L"mprui.dll",
                                                            NULL,
                                                            LOAD_WITH_ALTERED_SEARCH_PATH);

                            if (hDll == NULL)
                            {
                                MPR_LOG1(RESTORE,
                                         "WNetRestoreConnectionW: loading mprui.dll failed %d\n",
                                         GetLastError());

                                fDisconnect = FALSE;
                            }
                            else
                            {
                                DoProfileErrorDialog(
                                    Params->hDlg == INVALID_WINDOW_HANDLE ?
                                        NULL : Params->hDlg,
                                    ConnectArray[i].NetResource.lpLocalName,
                                    ConnectArray[i].NetResource.lpRemoteName,
                                    ConnectArray[i].NetResource.lpProvider,
                                    status,
                                    (Params->hDlg != INVALID_WINDOW_HANDLE) &&
                                        (numStillMustContinue > 1),
                                    &UserCancelled,
                                    &fDisconnect,
                                    &fHideErrors);

                                FreeLibrary(hDll);
                            }
                        }

                        if (fDisconnect)
                        {
                            if (ConnectArray[i].NetResource.lpLocalName)
                            {
                                status = ConnectArray[i].pfCancelConnection(
                                            ConnectArray[i].NetResource.lpLocalName,
                                            TRUE);
                            }
                            else
                            {
                                status =
                                    MprForgetPrintConnection(
                                        ConnectArray[i].NetResource.lpRemoteName) ;
                            }
                        }

                        ConnectArray[i].ContinueFlag = FALSE;
                        break;
                    } // end switch(status)

                ContinueFlag |= ConnectArray[i].ContinueFlag;

                //
                // If the User cancelled all further connection restoration
                // work, then leave this loop.
                //
                if (UserCancelled)
                {
                    status = WN_CANCEL;
                    ContinueFlag = FALSE;
                    break;
                }

            } // end For each connection.

            if (ContinueFlag)
            {
                //
                // Determine what the elapsed time from the start is.
                //
                CurrentTime = GetTickCount();
                ElapsedTime = CurrentTime - StartTime;

                //
                // If a timeout occured, then don't continue.  Otherwise, sleep for
                // a bit and loop again through all connections.
                //
                if (ElapsedTime > MaxWait)
                {
                    MPR_LOG0(RESTORE,"WNetRestoreConnectionW: Timed out while restoring\n");
                    ContinueFlag = FALSE;
                    status = WN_SUCCESS;
                }
                else
                {
                    Sleep(dwSleepTime);

                    //
                    // increase sleeptime as we loop, but cap at 4 times
                    // the increment (currently that is 4 * 3 secs = 12 secs)
                    //
                    if (dwSleepTime < (RECONNECT_SLEEP_INCREMENT * 4))
                    {
                        dwSleepTime += RECONNECT_SLEEP_INCREMENT ;
                    }
                }
            }

        } while (ContinueFlag);
        break;

    default:
        status = GetLastError();
    }

    Params->status = status;
    if(Params->hDlg != INVALID_WINDOW_HANDLE)
    {
        (*_static_pfPostMsg) (Params->hDlg, WM_QUIT, 0, 0);
    }


CleanExit:

    //
    // Is this thread supposed to clean up?
    //
    if (InterlockedExchange(&Params->fDoCleanup, TRUE))
    {
        MPR_LOG0(RESTORE, "Worker thread will perform cleanup\n");

        ASSERT(Params != NULL);

        //
        // Free up resources in preparation to return.
        //

        //
        // If LUID device maps are enabled and we restored drive letter
        // connections, then notify the shell about each restored drive
        // letter connection.
        //
        if( (g_LUIDDeviceMapsEnabled == TRUE) &&
            (RestoredDrivesMask != 0) )
        {
            CurrDriveMask = 1;
            DriveLetterName[1] = L':';
            DriveLetterName[2] = UNICODE_NULL;

            for( DriveLetterName[0] = L'A';
                 DriveLetterName[0] <= L'Z';
                 DriveLetterName[0]++, CurrDriveMask <<= 1 )
            {
                if( CurrDriveMask & RestoredDrivesMask )
                {
                    // Use the LUID broadcast mechanism
                    MprBroadcastDriveChange(
                        DriveLetterName,
                        FALSE );    // not a Delete Message
                }
            }
        }

        if (!CloseHandle(Params->hDlgCreated))
            status = GetLastError();

        if (!CloseHandle(Params->hDlgFailed))
            status = GetLastError();

        if (!CloseHandle(Params->hDonePassword))
            status = GetLastError();

        MprFreeConnectionArray(Params->ConnectArray, numSubKeys);

        LocalFree(Params);
    }

    if (hDll != NULL)
    {
        //
        // We have an HINSTANCE, so we're running in a
        // separate thread
        //

        FreeLibraryAndExitThread(hDll, 0);
    }

    return;
}



BOOL
MprUserNameMatch (
    IN  PUNICODE_STRING DomainName,
    IN  PUNICODE_STRING UserName,
    IN  LPCWSTR         RememberedName,
    IN  BOOL            fMustMatchCompletely
    )

/*++

Routine Description:

    This function tests whether the user name for a remembered connection
    matches the default user name.

Arguments:

    DomainName - default logon domain

    UserName - default logon user

    RememberedName - user name remembered for the connection

Return Value:

    TRUE if the name matches, FALSE otherwise.

--*/
{
    if (IS_EMPTY_STRING(RememberedName))
    {
        return TRUE;
    }

    if (DomainName == NULL || UserName == NULL)
    {
        // This can happen if the LsaGetUserName call fails
        return FALSE;
    }

    //
    // If the remembered name is in the form "domain\user", we must compare
    // against the full user name; otherwise, it's sufficient to compare
    // against the unqualified user name
    //
    WCHAR * pSlash = wcschr(RememberedName, L'\\');
    if (pSlash)
    {
        // Compare user name portion
        UNICODE_STRING RememberedUserName;
        RtlInitUnicodeString(&RememberedUserName, pSlash+1);
        if (! RtlEqualUnicodeString(&RememberedUserName, UserName, TRUE))
        {
            return FALSE;
        }

        // Compare domain name portion
        *pSlash = L'\0';
        UNICODE_STRING RememberedDomainName;
        RtlInitUnicodeString(&RememberedDomainName, RememberedName);
        BOOL fMatch = RtlEqualUnicodeString(&RememberedDomainName, DomainName, TRUE);
        *pSlash = L'\\';
        return fMatch;
    }
    else if (fMustMatchCompletely)
    {
        //
        // A complete match is required but there's no domain in RememberedName
        //
        return FALSE;
    }
    else
    {
        UNICODE_STRING RememberedUserName;
        RtlInitUnicodeString(&RememberedUserName, RememberedName);
        return (RtlEqualUnicodeString(&RememberedUserName, UserName, TRUE));
    }
}

DWORD
MprRestoreThisConnection(
    HWND                hWnd,
    PARAMETERS          *Params,
    LPCONNECTION_INFO   ConnectInfo,
    DWORD               dwFlags
    )

/*++

Routine Description:

    This function attempts to add a single connection specified in the
    ConnectInfo.

Arguments:

    Params -

    ConnectInfo - This is a pointer to a connection info structure which
        contains all the information necessary to restore a network
        connection.

Return Value:

    returns whatever the providers AddConnection function returns.

--*/
{
    DWORD           status;
    LPTSTR          password=NULL;
    HANDLE          lpHandle;
    BOOL            fDidCancel;
    TCHAR           passwordBuffer[PWLEN+1] = {0};
    LPWSTR          UserNameForProvider;
    BOOLEAN         BufferAllocated = FALSE;


    MPR_LOG3(RESTORE,
        "Doing MprRestoreThisConnection for %ws, username = %ws, defer = %lu...\n",
        ConnectInfo->NetResource.lpRemoteName,
        ConnectInfo->UserName,
        ConnectInfo->Defer);

    //
    // Pass the provider NULL as the user name on the first pass
    //  if the original connection used default creds.
    //

    if ( ConnectInfo->DeferFlags & DEFER_DEFAULT_CRED ) {
        UserNameForProvider = NULL;
    } else {
        UserNameForProvider = ConnectInfo->UserName;
    }

    //
    // Loop until we either have a successful connection, or
    // until the user stops attempting to give a proper
    // password.
    //
    do {

        if (Params && Params->status == WN_CANCEL)
        {
            //
            // User cancelled out on reconnections -- return
            // WN_SUCCESS to let DoRestoreConnection finish
            //
            return WN_SUCCESS;
        }

        //
        // Attempt to add the connection.
        // NOTE:  The initial password is NULL.
        //

#if DBG == 1
        DWORD ConnectTime = GetTickCount();
#endif

        //**************************************
        // Actual call to Provider
        //**************************************

        if (ConnectInfo->Defer)
        {
            ASSERT(ConnectInfo->pfAddConnection3 != NULL);

            status = ConnectInfo->pfAddConnection3(
                        NULL,                           // hwndOwner
                        &(ConnectInfo->NetResource),    // lpNetResource
                        password,                       // lpPassword
                        UserNameForProvider,            // lpUserName
                        CONNECT_DEFERRED | (ConnectInfo->ProviderFlags << 24)
                        );                              // dwFlags
        }
        else if (ConnectInfo->pfAddConnection != NULL)
        {
            status = ConnectInfo->pfAddConnection(
                        &(ConnectInfo->NetResource),    // lpNetResource
                        password,                       // lpPassword
                        UserNameForProvider );          // lpUserName
        }
        else
        {
            status = WN_NOT_SUPPORTED;
        }

#if DBG == 1
        ConnectTime = GetTickCount() - ConnectTime;
        MPR_LOG2(RESTORE, "...provider took %lu ms to return status %lu\n",
                     ConnectTime, status);
        if (ConnectInfo->Defer && ConnectTime > 100)
        {
            DbgPrint("[MPR] ------ %ws took %lu ms to restore a DEFERRED\n"
                     "             connection to %ws !\n",
                     ConnectInfo->NetResource.lpProvider, ConnectTime,
                     ConnectInfo->NetResource.lpRemoteName);
        }
#endif

        if (status == WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
        {
            //
            // Provider reconnected using default creds
            //

            status = WN_SUCCESS;
        }

        //
        // If that fails due to a bad password, then
        // loop until we either have a successful connection, or until
        // the user stops attempting to give a proper password.
        //

        if (CREDUI_IS_AUTHENTICATION_ERROR(status))
        {
            //
            // The password needs to be cleared each time around the loop,
            // so that on subsequent add connections, we go back to the
            // logon password.
            //
            password = NULL;

            //
            // If failure was due to bad password, then attempt
            // to get a new password from the user.
            //

            // Changes made by congpay because of another thread.

            if (Params == NULL)  //lpDevice != NULL, restoring ONE
            {
                if (!(dwFlags & WNRC_NOUI))
                {
                    //
                    // We need a username buffer to prompt for a username
                    //

                    if ( ConnectInfo->UserName == NULL ) {
                        ConnectInfo->UserName = (LPTSTR)LocalAlloc(LMEM_FIXED, CRED_MAX_USERNAME_LENGTH * sizeof(WCHAR));

                        if ( ConnectInfo->UserName == NULL ) {
                            status = ERROR_NOT_ENOUGH_MEMORY;
                            SetLastError (status);
                            RtlSecureZeroMemory(passwordBuffer, sizeof(passwordBuffer));
                            return status;
                        } else {
                            ConnectInfo->UserName[0] = L'\0';
                            BufferAllocated = TRUE;
                        }
                    }

                    //
                    // Prompt for a username
                    //

                    status = DoPasswordDialog(hWnd,
                                              ConnectInfo->NetResource.lpRemoteName,
                                              ConnectInfo->UserName,
                                              passwordBuffer,
                                              sizeof (passwordBuffer),
                                              &fDidCancel,
                                              status);

                    //
                    // Convert zero length username to NULL buffer
                    //

                    if ( BufferAllocated && status == NO_ERROR ) {
                        //
                        // If there is no user name (the length is 0), then set the
                        // return pointer to NULL.
                        //
                        if (STRLEN(ConnectInfo->UserName) == 0) {
                            LocalFree(ConnectInfo->UserName);
                            ConnectInfo->UserName = NULL;
                            BufferAllocated = FALSE;
                        }
                    }
                }

                if (status != WN_SUCCESS)
                {
                    SetLastError (status);
                    RtlSecureZeroMemory(passwordBuffer, sizeof(passwordBuffer));
                    return status;
                }
                else
                {
                    if (fDidCancel)
                    {
                        status = WN_CANCEL;
                    }
                    else
                    {
                        password = passwordBuffer;
                        status = WN_ACCESS_DENIED;
                    }
                }
            }
            else   // restoring all
            {
                if (!(Params->dwRestoreFlags & WNRC_NOUI))
                {
                    if (Params->status == WN_CANCEL)
                    {
                        //
                        // User cancelled out of restoring connections.  Return
                        // WN_SUCCESS to let DoRestoreConnection finish looping
                        //

                        continue;
                    }

                    if ( _static_pfPostMsg == NULL ) {

                        MprEnterLoadLibCritSect();
                        if ( _static_hUser32 = LoadLibraryEx(
                                                    USER32_DLL_NAME,
                                                    NULL,
                                                    LOAD_WITH_ALTERED_SEARCH_PATH ) ) {
                            _static_pfPostMsg = (FN_PostMessage *) GetProcAddress( _static_hUser32,
                                                               POST_MSG_API_NAME );
                        }
                        MprLeaveLoadLibCritSect();
                        if ( _static_pfPostMsg == NULL ) {
                            RtlSecureZeroMemory(passwordBuffer, sizeof(passwordBuffer));
                            return GetLastError();
                        }

                    }
                    lpHandle = Params->hDonePassword;

                    Params->pchResource = ConnectInfo->NetResource.lpRemoteName;
                    Params->pchUserName = ConnectInfo->UserName;
                    Params->dwError     = status;

                    if ((Params->hDlg == INVALID_WINDOW_HANDLE)
                         ||
                        ((*_static_pfPostMsg)
                             (Params->hDlg,
                             DO_PASSWORD_DIALOG,
                             (WPARAM) Params,
                             0) == 0))
                    {
                        //
                        // Either we're not using a credential dialog or the
                        // PostMessage call failed -- bail.
                        //
                        MPR_LOG3(ERROR,
                                 "%ws returned %d for connection to %ws -- bailing\n",
                                 ConnectInfo->NetResource.lpProvider,
                                 status,
                                 ConnectInfo->NetResource.lpRemoteName);

                        goto CredentialError;
                    }

                    WaitForSingleObject ( lpHandle, INFINITE );

                    if (Params->status == WN_SUCCESS)
                    {
                        if (Params->fDidCancel)
                        {
                            status = WN_CANCEL;
                        }
                        else
                        {
                            password = Params->passwordBuffer;
                        }
                    }
                    else
                    {
                        status = Params->status;
                    }
                }
                else
                {
                    // Caller wants no UI - don't show any
                    status = WN_CANCEL;

                    // Remember that we had a failure to reconnect
                    Params->fReconnectFailed = TRUE;
                }
            }
        }
        else if (status == WN_SUCCESS)
        {
            DWORD  dwIgnoredStatus;

            MPR_LOG1(RESTORE,"MprRestoreThisConnection: Successful "
                "restore of connection for %ws\n",
                ConnectInfo->NetResource.lpRemoteName);

            //
            // Username for the connection might have changed via the
            // password dialog -- update it.
            //

            dwIgnoredStatus = MprSetRegValue(ConnectInfo->RegKey,
                                             USER_NAME,
                                             ConnectInfo->UserName,
                                             0);

            if (dwIgnoredStatus != ERROR_SUCCESS)
            {
                MPR_LOG(ERROR,
                        "MprSetRegValue for user name failed %lu\n",
                        dwIgnoredStatus);
            }

            //
            // If the DEFER_UNKNOWN flag was set, we can clear it now.
            // If the default password worked, we know that we can defer the
            // connection in future.  If we had to prompt for a password, we
            // can't defer the connection in future.
            // Note: This may not do the right thing for share-level
            // connections where the level of access depends on the password.
            // But we'll let users fix that by manually recreating the
            // connection.
            //
            if (ConnectInfo->DeferFlags & DEFER_UNKNOWN)
            {
                if (password == NULL)
                {
                    ConnectInfo->DeferFlags &=
                        ~(DEFER_UNKNOWN | DEFER_EXPLICIT_PASSWORD);
                    MPR_LOG1(RESTORE,"MprRestoreThisConnection: WILL defer "
                        "connection for %ws in future\n",
                        ConnectInfo->NetResource.lpRemoteName);
                }
                else
                {
                    ConnectInfo->DeferFlags &= ~DEFER_UNKNOWN;
                    ConnectInfo->DeferFlags |= DEFER_EXPLICIT_PASSWORD;
                    MPR_LOG1(RESTORE,"MprRestoreThisConnection: will NOT defer "
                        "connection for %ws in future\n",
                        ConnectInfo->NetResource.lpRemoteName);
                }

                dwIgnoredStatus = MprSaveDeferFlags(ConnectInfo->RegKey,
                                                    ConnectInfo->DeferFlags);

                if (dwIgnoredStatus != ERROR_SUCCESS)
                {
                    MPR_LOG(ERROR, "MprSaveDeferFlags failed %lu\n", dwIgnoredStatus);
                }
            }
        }
        else
        {
            //
            // An unexpected error occured.  In this case,
            // we want to leave the loop.
            //

            MPR_LOG2(ERROR,
                     "MprRestoreThisConnection: AddConnection for (%ws) Error %d \n",
                     ConnectInfo->NetResource.lpProvider,
                     status);

            break;
        }

        //
        // On subsequent iterations,
        //  pass the provider the user name typed by the caller.
        //

        UserNameForProvider = ConnectInfo->UserName;

    }
    while (CREDUI_IS_AUTHENTICATION_ERROR(status));

CredentialError:

    RtlSecureZeroMemory(passwordBuffer, sizeof(passwordBuffer));
    return status;
}


DWORD
MprCreateConnectionArray(
    LPDWORD             lpNumConnections,
    LPCTSTR             lpDevice,
    LPDWORD             lpRegMaxWait,
    LPCONNECTION_INFO   *ConnectArray
    )

/*++

Routine Description:

    This function creates an array of CONNECTION_INFO structures and fills
    each element in the array with the info that is stored in the registry
    for that connection.

    NOTE:  This function allocates memory for the array.

Arguments:

    NumConnections - This is a pointer to the place where the number of
        connections is to be placed.  This indicates how many elements
        are stored in the array.

    lpDevice - If this is NULL, information on all remembered connections
        is required.  Otherwise, information for only the lpDevice connection
        is required.

    lpRegMaxWait - This is a pointer to the location where the wait time
        read from the registry is to be placed.  If this value does not
        exist in the registry, then the returned value is 0.

    ConnectArray - This is a pointer to the location where the pointer to
        the array is to be placed.

Return Value:

    An error status code is returned only if something happens that will not
    allow us to restore even one connection.


--*/
{
    DWORD       status = WN_SUCCESS;
    HKEY        connectHandle;
    HKEY        providerKeyHandle;
    DWORD       maxSubKeyLen;
    DWORD       maxValueLen;
    DWORD       ValueType;
    DWORD       Temp;
    DWORD       i;
    BOOL        AtLeastOneSuccess = FALSE;

    //
    // init return data
    //
    *lpNumConnections = 0 ;
    *ConnectArray = NULL ;

    //
    // Get a handle for the connection section of the user's registry
    // space.
    //
    if (!MprOpenKey(
            HKEY_CURRENT_USER,
            CONNECTION_KEY_NAME,
            &connectHandle,
            DA_READ)) {

        MPR_LOG(ERROR,"WNetRestoreConnection: MprOpenKey Failed\n",0);
        return(WN_CANNOT_OPEN_PROFILE);
    }

    //
    // Find out the number of connections to restore (numSubKeys) and
    // the max lengths of subkeys and values.
    //
    if(!MprGetKeyInfo(
        connectHandle,
        NULL,
        lpNumConnections,
        &maxSubKeyLen,
        NULL,
        &maxValueLen))
    {
        MPR_LOG(ERROR,"WNetRestoreConnection: MprGetKeyInfo Failed\n",0);
        *lpNumConnections = 0 ;
        RegCloseKey(connectHandle);
        return(WN_CANNOT_OPEN_PROFILE);
    }

    if (*lpNumConnections == 0) {
        RegCloseKey(connectHandle);
        return(WN_SUCCESS);
    }

    if (lpDevice != NULL) {
        *lpNumConnections = 1;
    }

    //
    // Allocate the array.
    //
    *ConnectArray = (LPCONNECTION_INFO)LocalAlloc(
                        LPTR,
                        *lpNumConnections * sizeof(CONNECTION_INFO));

    if (*ConnectArray == NULL) {
        *lpNumConnections = 0 ;
        RegCloseKey(connectHandle);
        return(GetLastError());
    }

    //
    // Level 1 initialization for the call to MprGetProviderIndex in the loop
    //
    if (!(GlobalInitLevel & FIRST_LEVEL)) {
        status = MprLevel1Init();
        if (status != WN_SUCCESS) {
           RegCloseKey(connectHandle);
           return status;
        }
    }

    for (i=0; i < *lpNumConnections; i++) {

        //
        // Read a Connection Key and accompanying information from the
        // registry.
        //
        // NOTE:  If successful, this function will allocate memory for
        //          netResource.lpRemoteName,
        //          netResource.lpProvider,
        //          netResource.lpLocalName,     and optionally....
        //          userName
        //
        if (!MprReadConnectionInfo(
                    connectHandle,
                    lpDevice,
                    i,
                    &((*ConnectArray)[i].ProviderFlags),
                    &((*ConnectArray)[i].DeferFlags),
                    &((*ConnectArray)[i].UserName),
                    &((*ConnectArray)[i].NetResource),
                    &((*ConnectArray)[i].RegKey),
                    maxSubKeyLen)) {

            //
            // The read failed even though this should be a valid index.
            //
            MPR_LOG0(ERROR,
                     "MprCreateConnectionArray: ReadConnectionInfo Failed\n");
            status = WN_CANNOT_OPEN_PROFILE;
        }
        else {

            //
            // Get the Provider Index
            //

            if (MprGetProviderIndex(
                    (*ConnectArray)[i].NetResource.lpProvider,
                    &((*ConnectArray)[i].ProviderIndex))) {

                AtLeastOneSuccess = TRUE;
                (*ConnectArray)[i].ContinueFlag = TRUE;

            }
            else {

                //
                // The provider index could not be found.  This may mean
                // that the provider information stored in the registry
                // is for a provider that is no longer in the ProviderOrder
                // list.  (The provider has been removed).  In that case,
                // we will just skip this provider.  We will leave the
                // ContinueFlag set to 0 (FALSE).
                //
                MPR_LOG0(ERROR,
                     "MprCreateConnectionArray:MprGetProviderIndex Failed\n");

                status = WN_BAD_PROVIDER;
                (*ConnectArray)[i].Status = status;
            }

        } // endif (MprReadConnectionInfo)

    } // endfor (i=0; i<numSubKeys)


    if (!AtLeastOneSuccess) {
        //
        // If we gather any connection information, return the last error
        // that occured.
        //
        MprFreeConnectionArray(*ConnectArray,*lpNumConnections);
        *ConnectArray = NULL ;
        *lpNumConnections = 0 ;
        RegCloseKey(connectHandle);
        goto CleanExit;
    }

    RegCloseKey(connectHandle);

    //
    // Read the MaxWait value that is stored in the registry.
    // If it is not there or if the value is less than our default
    // maximum value, then use the default instead.
    //

    if(!MprOpenKey(
                HKEY_LOCAL_MACHINE,     // hKey
                NET_PROVIDER_KEY,       // lpSubKey
                &providerKeyHandle,     // Newly Opened Key Handle
                DA_READ)) {             // Desired Access

        MPR_LOG(ERROR,"MprCreateConnectionArray: MprOpenKey (%ws) Error\n",
            NET_PROVIDER_KEY);

        *lpRegMaxWait = 0;
        status = WN_SUCCESS;
        goto CleanExit;
    }
    MPR_LOG(TRACE,"OpenKey %ws\n, ",NET_PROVIDER_KEY);

    Temp = sizeof(*lpRegMaxWait);

    status = RegQueryValueEx(
                providerKeyHandle,
                RESTORE_WAIT_VALUE,
                NULL,
                &ValueType,
                (LPBYTE)lpRegMaxWait,
                &Temp);

    RegCloseKey(providerKeyHandle);

    if (status != NO_ERROR) {
        *lpRegMaxWait = 0;
    }

    status = WN_SUCCESS;

CleanExit:

    return(WN_SUCCESS);

}

VOID
MprFreeConnectionArray(
    LPCONNECTION_INFO   ConnectArray,
    DWORD               NumConnections
    )

/*++

Routine Description:

    This function frees up all the elements in the connection array, and
    finally frees the array itself.


Arguments:


Return Value:

    none

--*/
{
    DWORD           status = WN_SUCCESS;
    LPNETRESOURCEW  netResource;
    DWORD           i;

    for (i=0; i<NumConnections; i++)
    {
        netResource = &(ConnectArray[i].NetResource);

        //
        // Free the allocated memory resources.
        //
        LocalFree(netResource->lpLocalName);
        LocalFree(netResource->lpRemoteName);
        LocalFree(netResource->lpProvider);
        LocalFree(ConnectArray[i].UserName);

        if (ConnectArray[i].RegKey != NULL)
        {
            RegCloseKey(ConnectArray[i].RegKey);
        }

        if (ConnectArray[i].hProviderDll != NULL)
        {
            FreeLibrary(ConnectArray[i].hProviderDll);
        }
    }

    LocalFree(ConnectArray);
    return;
}


DWORD
MprNotifyErrors(
    HWND                hWnd,
    LPCONNECTION_INFO   ConnectArray,
    DWORD               NumConnections,
    DWORD               dwFlags
    )

/*++

Routine Description:

    This function calls the error dialog for each connection that still
    has the continue flag set, and does not have a SUCCESS status.

Arguments:

    hWnd - This is a window handle that will be used as owner of the
        error dialog.

    ConnectArray - This is the array of connection information.
        At the point when this function is called, the following fields
        are meaningful:
        ContinueFlag - If set, it means that this connection has not yet
            been established.
        StatusFlag - If this is not SUCCESS, then it contains the error
            status from the last call to the provider.

        ContinueFlag    Status
        ---------------|---------------
        | FALSE        |  NotSuccess  | Provider will not start
        | FALSE        |  Success     | Connection was successfully established
        | TRUE         |  NotSuccess  | Time-out occured
        | TRUE         |  Success     | This can never occur.
        -------------------------------

    NumConnections - This is the number of entries in the array of
        connection information.

Return Value:



--*/
{
    DWORD   i;
    BOOL fDisconnect = FALSE;
    DWORD   status = WN_SUCCESS;

    //
    // If HideErrors becomes TRUE, stop displaying error dialogs
    //
    BOOL fHideErrors = (dwFlags & WNRC_NOUI) ? TRUE : FALSE;

    for (i=0; (i<NumConnections) && (!fHideErrors); i++ )
    {
        if ((ConnectArray[i].ContinueFlag)  &&
            (ConnectArray[i].Status != WN_SUCCESS)  &&
            (ConnectArray[i].Status != WN_CANCEL)   &&
            (ConnectArray[i].Status != WN_CONTINUE))
        {
            //
            // For any other error, call the Error Dialog
            //
            DoProfileErrorDialog (
                hWnd,
                ConnectArray[i].NetResource.lpLocalName,
                ConnectArray[i].NetResource.lpRemoteName,
                ConnectArray[i].NetResource.lpProvider,
                ConnectArray[i].Status,
                FALSE,      //No cancel button.
                NULL,
                &fDisconnect,
                &fHideErrors);

            if (fDisconnect)
            {
                status = ConnectArray[i].pfCancelConnection(
                             ConnectArray[i].NetResource.lpLocalName,
                             TRUE);
            }
        }
    }
    return status;
}

DWORD
MprAddPrintersToConnArray(
    LPDWORD             lpNumConnections,
    LPCONNECTION_INFO   *ConnectArray
    )

/*++

Routine Description:

    This function augments the array of CONNECTION_INFO with print connections.

    NOTE:  This function allocates memory for the array if need.

Arguments:

    NumConnections - This is a pointer to the place where the number of
        connections is to be placed.  This indicates how many elements
        are stored in the array.

    ConnectArray - This is a pointer to the location where the pointer to
        the array is to be placed.

Return Value:

    An error status code is returned only if something happens that will not
    allow us to restore even one connection.


--*/
{
    DWORD         status = WN_SUCCESS;
    HKEY          connectHandle;
    DWORD         i,j;
    DWORD         NumValueNames ;
    DWORD         MaxValueNameLength;
    DWORD         MaxValueLen ;
    LPNETRESOURCE lpNetResource ;
    LPWSTR        lpUserName = NULL ;
    LPWSTR        lpProviderName = NULL ;
    LPWSTR        lpRemoteName = NULL ;
    LPBYTE        lpBuffer = NULL ;


    //
    // Get a handle for the connection section of the user's registry
    // space.
    //
    if (!MprOpenKey(
            HKEY_CURRENT_USER,
            PRINT_CONNECTION_KEY_NAME,
            &connectHandle,
            DA_READ))
    {
        return(WN_SUCCESS);   // ignore the restored connections.
    }

    //
    // Find out the number of connections to restore and
    // the max lengths of names and values.
    //
    status = MprGetPrintKeyInfo(connectHandle,
                                &NumValueNames,
                                &MaxValueNameLength,
                                &MaxValueLen) ;

    if (status != WN_SUCCESS || NumValueNames == 0)
    {
        //
        // ignore the restored connections, or nothing to add
        //
        RegCloseKey(connectHandle);
        return(WN_SUCCESS);
    }


    //
    // Allocate the array and copy over the info if previous pointer not null.
    //
    lpBuffer = (LPBYTE) LocalAlloc(LPTR,
                                   (*lpNumConnections + NumValueNames) *
                                   sizeof(CONNECTION_INFO)) ;
    if (lpBuffer == NULL)
    {
        RegCloseKey(connectHandle);
        return(GetLastError());
    }
    if (*ConnectArray)
    {
        memcpy(lpBuffer,
               *ConnectArray,
               (*lpNumConnections * sizeof(CONNECTION_INFO))) ;
        LocalFree (*ConnectArray) ;
    }


    //
    // set j to index from previous location, update the count and pointer.
    // then loop thru all new entries, adding to the connect array.
    //
    j = *lpNumConnections ;
    *lpNumConnections += NumValueNames ;
    *ConnectArray = (CONNECTION_INFO *) lpBuffer ;

    //
    // Level 1 initialization for the call to MprGetProviderIndex in the loop
    //
    if (!(GlobalInitLevel & FIRST_LEVEL)) {
        status = MprLevel1Init();
        if (status != WN_SUCCESS) {
           RegCloseKey(connectHandle);
           return status;
        }
    }

    for (i=0; i < NumValueNames; i++, j++)
    {

        DWORD TypeCode ;
        DWORD cbRemoteName = (MaxValueNameLength + 1) * sizeof (WCHAR) ;
        DWORD cbProviderName = MaxValueLen ;

        //
        // allocate the strings for the providername, remotename
        //
        if (!(lpProviderName = (LPWSTR) LocalAlloc(0,  cbProviderName )))
        {
             status = GetLastError() ;
             goto ErrorExit ;
        }
        if (!(lpRemoteName = (LPWSTR) LocalAlloc(0,  cbRemoteName )))
        {
             status = GetLastError() ;
             goto ErrorExit ;
        }

        //
        // Init the rest. Username currently not set by system, so always NULL
        //
        lpUserName = NULL ;
        lpNetResource = &(*ConnectArray)[j].NetResource ;
        lpNetResource->lpLocalName = NULL ;
        lpNetResource->lpRemoteName = lpRemoteName ;
        lpNetResource->lpProvider = lpProviderName ;
        lpNetResource->dwType = 0 ;

        //
        // null these so we dont free twice if error exit later
        //
        lpRemoteName = NULL ;
        lpProviderName = NULL ;

        status = RegEnumValue(connectHandle,
                           i,
                           lpNetResource->lpRemoteName,
                           &cbRemoteName,
                           0,
                           &TypeCode,
                           (LPBYTE) lpNetResource->lpProvider,
                           &cbProviderName) ;

        if (status == NO_ERROR)
        {
            (*ConnectArray)[j].UserName = lpUserName ;

            //
            // Get the Provider Index
            //
            if (MprGetProviderIndex(
                    (*ConnectArray)[j].NetResource.lpProvider,
                    &((*ConnectArray)[j].ProviderIndex)))
            {
                (*ConnectArray)[j].ContinueFlag = TRUE;
            }
            else
            {
                //
                // The provider index could not be found.  This may mean
                // that the provider information stored in the registry
                // is for a provider that is no longer in the ProviderOrder
                // list.  (The provider has been removed).  In that case,
                // we will just skip this provider.  We will leave the
                // ContinueFlag set to 0 (FALSE).
                //
                status = WN_BAD_PROVIDER;
                (*ConnectArray)[j].Status = status;
            }

        }
        else
        {
            //
            // should not happen, but if it does the array is half built,
            // and cannot be used, so ErrorExit (this will clean it up).
            //
            goto ErrorExit ;
        }
    }

    RegCloseKey(connectHandle);
    return(WN_SUCCESS);

ErrorExit:

    RegCloseKey(connectHandle);

    LocalFree(lpProviderName) ;
    LocalFree(lpRemoteName) ;

    MprFreeConnectionArray(*ConnectArray,*lpNumConnections);
    *ConnectArray = NULL ;
    *lpNumConnections = 0 ;
    return status;
}



VOID
MprNotifyShell(
    IN LPCWSTR      pwszDevice
    )
/*++

Routine Description:

    This function sets an event that asks a trusted system component
    (the service controller) to discover the changed network drives and
    asynchronously broadcast a device change message on our behalf.

    CODEWORK:  Replace this entire mechanism with real plug-n-play.

Arguments:

    pwszDevice - Name of the local device (NULL for UNC connections)

Return Value:

    None

History:

    BruceFo   19-May-1995   Created, calls BSM directly
    AnirudhS  06-Jun-1996   Set event to have another component do
        the BSM on our behalf

--*/
{
    // The shell is only interested in drive redirections
    if (pwszDevice == NULL || wcslen(pwszDevice) != 2 || pwszDevice[1] != L':')
    {
        return;
    }

    // Ask for a device change message to be broadcast
    HANDLE hBSMEvent = OpenEvent(
                            EVENT_MODIFY_STATE, // desired access
                            FALSE,              // don't inherit
                            SC_BSM_EVENT_NAME   // name
                            );
    if (hBSMEvent == NULL)
    {
        MPR_LOG(ERROR, "Couldn't open event for BSM request, %lu\n",
                GetLastError());
    }
    else
    {
        if (! SetEvent(hBSMEvent))
        {
            MPR_LOG(ERROR, "Couldn't set event for BSM request, %lu\n",
                    GetLastError());
        }

        CloseHandle(hBSMEvent);
    }
}


BOOL
MprBroadcastDriveChange(
    IN LPCWSTR          pwszDevice,
    IN BOOL             DeleteMessage
    )
/*++

Routine Description:

    This function asynchronously broadcasts a device change message on
    our behalf.

Arguments:

    pwszDevice - Name of the local device (NULL for UNC connections)

    DeleteMessage - denotes where a delete/add message is needed
                   TRUE  - send a device deleted message
                   FALSE - send a device added message

Return Value:

    TRUE - Operations completed
    FALSE - Error encountered
--*/
{
    BOOL Result;
    DWORD dwFlags = DDD_LUID_BROADCAST_DRIVE;

    // The shell is only interested in drive redirections
    if (pwszDevice == NULL || wcslen(pwszDevice) != 2 || pwszDevice[1] != L':')
    {
        return( FALSE );
    }

    if( DeleteMessage == TRUE )
    {
        dwFlags |= DDD_REMOVE_DEFINITION;
    }

    Result = DefineDosDeviceW( dwFlags, pwszDevice, NULL );

    return( Result );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\makefile.inc ===
$(O)\mpr.lib : $(O)\mprp.lib

$(O)\mprp.lib: mprp.def $(LIBRARY_OBJS)
    -lib -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:mprp.def
$(LIBRARY_OBJS)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\enum.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    enum.cxx

Abstract:

    Contains the entry points for the WinNet Enum API supported by the
    Multi-Provider Router.  The following functions are in this file:

        WNetOpenEnumW
        WNetEnumResourceW
        WNetCloseEnum

        MprOpenEnumConnect
        MprOpenEnumNetwork
        MprEnumConnect
        MprEnumNetwork
        MprProviderEnum
        MprCopyResource
        MprCopyProviderEnum
        MprProviderOpen
        MprOpenRemember
        MprEnumRemembered
        MprMultiStrBuffSize


Author:

    Dan Lafferty (danl)     14-Oct-1991

Environment:

    User Mode -Win32

Notes:


Revision History:

    14-Oct-1991     danl
        created

    21-Sep-1992     KeithMo
        Handle odd-sized buffers.

    02-Nov-1992     danl
        Fail with NO_NETWORK if there are no providers.

    02-Mar-1995     anirudhs
        Add support for RESOURCE_CONTEXT.

    17-Jul-1995     anirudhs
        Add recognition (but not true support) of RESOURCE_RECENT.
        Clean up code for detecting top-level enum.

    03-Aug-1995     anirudhs
        WNetEnumResourceW: Allow a *lpcCount of 0.

    15-Sep-1995     anirudhs
        MprEnumRemembered: Fail after all resources have been enumerated.

    24-Sep-1995     anirudhs
        Add support for customization of the RESOURCE_CONTEXT enumeration
        based on policy settings.

    11-Apr-1996     anirudhs
        Use CRoutedOperation in one case of WNetOpenEnumW.

    16-Mar-1999     jschwart
        Add support for RESOURCE_SHAREABLE

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/
//
// INCLUDES
//
#include "precomp.hxx"

#include <memory.h>     // memcpy
#include <lmcons.h>     // needed for netlib.h
#include <regstr.h>     // Registry keys and value names

//
// EXTERNALS
//

    extern  DWORD       GlobalNumActiveProviders;
    extern  HMODULE     hDLL;

//
// DATA STRUCTURES
//

//
// "Manually" align headers and put pointers first in ENUM
// structures to avoid Win64 alignment faults.  Keep Key as
// the first field in the header so MPR knows where to check
// to see what type of enum it is.
//
typedef struct  _CONNECT_HEADER
{
    DWORD       Key;
    DWORD       ReturnRoot;
    DWORD       dwNumProviders;
    DWORD       dwNumActiveProviders;
}
CONNECT_HEADER, *LPCONNECT_HEADER;

typedef struct  _CONNECT_ENUM
{
    HANDLE              ProviderEnumHandle;
    HINSTANCE           hProviderDll;        // Refcount the provider DLL
    PF_NPEnumResource   pfEnumResource;
    PF_NPCloseEnum      pfCloseEnum;
    DWORD               State;

}
CONNECT_ENUM, *LPCONNECT_ENUM;

typedef struct _NETWORK_HEADER
{
    DWORD               Key;
    DWORD               dwNumProviders;
    DWORD               dwNumActiveProviders;
    DWORD               dwPad;
}
NETWORK_HEADER, *LPNETWORK_HEADER;

typedef struct _NETWORK_ENUM
{
    HINSTANCE           hProviderDll;
    LPNETRESOURCE       lpnr;
    DWORD               State;
}
NETWORK_ENUM, *LPNETWORK_ENUM;

typedef struct  _ENUM_HANDLE
{
    DWORD               Key;
    DWORD               dwPad;
    HANDLE              EnumHandle;
    HINSTANCE           hProviderDll;
    PF_NPEnumResource   pfEnumResource;
    PF_NPCloseEnum      pfCloseEnum;
}
ENUM_HANDLE, *LPENUM_HANDLE;

typedef struct _REMEMBER_HANDLE
{
    DWORD       Key;
    DWORD       dwPad;
    HKEY        ConnectKey;
    DWORD       KeyIndex;
    DWORD       ConnectionType;
}
REMEMBER_HANDLE, *LPREMEMBER_HANDLE;

//
// CONSTANTS
//
#define DONE                1
#define MORE_ENTRIES        2
#define NOT_OPENED          3
#define CONNECT_TABLE_KEY   0x6e6e4f63  // "cOnn"
#define STATE_TABLE_KEY     0x74417473  // "stAt"
#define PROVIDER_ENUM_KEY   0x764f7270  // "prOv"
#define REMEMBER_KEY        0x626D4572  // "rEmb"
#define REGSTR_PATH_NETWORK_POLICIES    \
            REGSTR_PATH_POLICIES L"\\" REGSTR_KEY_NETWORK

//
//  Macros for rounding a value up/down to a WCHAR boundary.
//  Note:  These macros assume that sizeof(WCHAR) is a power of 2.
//

#define ROUND_DOWN(x)   ((x) & ~(sizeof(WCHAR) - 1))
#define ROUND_UP(x)     (((x) + sizeof(WCHAR) - 1) & ~(sizeof(WCHAR) - 1))


//
// LOCAL FUNCTION PROTOTYPES
//

DWORD
MprCopyProviderEnum(
    IN      LPNETRESOURCEW  ProviderBuffer,
    IN OUT  LPDWORD         EntryCount,
    IN OUT  LPBYTE          *TempBufPtr,
    IN OUT  LPDWORD         BytesLeft
    );

DWORD
MprCopyResource(
    IN OUT  LPBYTE          *BufPtr,
    IN const NETRESOURCEW   *Resource,
    IN OUT  LPDWORD         BytesLeft
    );

DWORD
MprEnumNetwork(
    IN OUT  LPNETWORK_HEADER     StateTable,
    IN OUT  LPDWORD              NumEntries,
    IN OUT  LPVOID               lpBuffer,
    IN OUT  LPDWORD              lpBufferSize
    );

DWORD
MprEnumConnect(
    IN OUT  LPCONNECT_HEADER    ConnectEnumHeader,
    IN OUT  LPDWORD             NumEntries,
    IN OUT  LPVOID              lpBuffer,
    IN OUT  LPDWORD             lpBufferSize
    );

DWORD
MprOpenEnumNetwork(
    OUT LPHANDLE    lphEnum
    );

DWORD
MprOpenEnumConnect(
    IN  DWORD          dwScope,
    IN  DWORD          dwType,
    IN  DWORD          dwUsage,
    IN  LPNETRESOURCE  lpNetResource,
    OUT LPHANDLE       lphEnum
    );

DWORD
MprProviderEnum(
    IN      LPENUM_HANDLE   EnumHandlePtr,
    IN OUT  LPDWORD         lpcCount,
    IN      LPVOID          lpBuffer,
    IN OUT  LPDWORD         lpBufferSize
    );

DWORD
MprOpenRemember(
    IN  DWORD       dwType,
    OUT LPHANDLE    lphRemember
    );

DWORD
MprEnumRemembered(
    IN OUT  LPREMEMBER_HANDLE   RememberInfo,
    IN OUT  LPDWORD             NumEntries,
    IN OUT  LPBYTE              lpBuffer,
    IN OUT  LPDWORD             lpBufferSize
    );

DWORD
MprMultiStrBuffSize(
    IN      LPTSTR      lpString1,
    IN      LPTSTR      lpString2,
    IN      LPTSTR      lpString3,
    IN      LPTSTR      lpString4,
    IN      LPTSTR      lpString5
    ) ;

class CProviderOpenEnum : public CRoutedOperation
{
public:
                    CProviderOpenEnum(
                        DWORD           dwScope,
                        DWORD           dwType,
                        DWORD           dwUsage,
                        LPNETRESOURCEW  lpNetResource,
                        LPHANDLE        lphEnum
                        ) :
                            CRoutedOperation(DBGPARM("ProviderOpenEnum")
                                             PROVIDERFUNC(OpenEnum)),
                            _dwScope      (dwScope      ),
                            _dwType       (dwType       ),
                            _dwUsage      (dwUsage      ),
                            _lpNetResource(lpNetResource),
                            _lphEnum      (lphEnum      )
                        { }

protected:

    DWORD           GetResult();    // overrides CRoutedOperation implementation

private:

    DWORD           _dwScope;
    DWORD           _dwType;
    DWORD           _dwUsage;
    LPNETRESOURCEW  _lpNetResource;
    LPHANDLE        _lphEnum;

    HANDLE          _ProviderEnumHandle; // Enum handle returned by provider

    DECLARE_CROUTED
};


DWORD
WNetOpenEnumW (
    IN  DWORD           dwScope,
    IN  DWORD           dwType,
    IN  DWORD           dwUsage,
    IN  LPNETRESOURCEW  lpNetResource,
    OUT LPHANDLE        lphEnum
    )
/*++

Routine Description:

    This API is used to open an enumeration of network resources or existing
    connections.  It must be called to obtain a valid handle for enumeration.

    NOTE:
    For GlobalNet Enum, the caller must get a new handle for each level that
    is desired.  For the other scopes, the caller gets a single handle and
    with that can enumerate all resources.


Arguments:

    dwScope - Determines the scope of the enumeration.  This can be one of:
        RESOURCE_CONNECTED - All Currently connected resources.
        RESOURCE_GLOBALNET - All resources on the network.
        RESOURCE_REMEMBERED - All persistent connections.
        RESOURCE_RECENT - Same as RESOURCE_REMEMBERED (supported for Win95
            semi-compatibility)
        RESOURCE_CONTEXT - The resources associated with the user's current
            and default network context (as defined by the providers).
        RESOURCE_SHAREABLE - All shareable resources on the given server

    dwType - Used to specify the type of resources on interest.  This is a
        bitmask which may be any combination of:
            RESOURCETYPE_DISK - All disk resources
            RESOURCETYPE_PRINT - All print resources
        If this is 0. all types of resources are returned.  If a provider does
        not have the capability to distinguish between print and disk
        resources at a level, it may return all resources.

    dwUsage - Used to specify the usage of resources of interest.  This is a
        bitmask which may be any combination of:
            RESOURCEUSAGE_CONNECTABLE - all connectable resources.
            RESOURCEUSAGE_CONTAINER - all container resources.
        The bitmask may be 0 to match all.

    lpNetResource - This specifies the container to perform the enumeration.
        If it is NULL, the logical root of the network is assumed, and the
        router is responsible for obtaining the information for return.

    lphEnum - If the Open was successful, this will contain a handle that
        can be used for future calls to WNetEnumResource.

Return Value:

    WN_SUCCESS - Indicates the operation was successful.

    WN_NOT_CONTAINER - Indicates that lpNetResource does not point to a
        container.

    WN_BAD_VALUE - Invalid dwScope or dwType, or bad combination of parameters
        is specified.

    WN_NO_NETWORK - network is not present.

--*/
{
    DWORD   status = WN_SUCCESS;

    //
    // dwScope MUST be set to either GLOBALNET or CONNECTED or REMEMBERED
    // or RECENT or CONTEXT or SHAREABLE.
    // This is verified in the switch statement below.
    //

    //
    // dwType is a bit mask that can have any combination of the DISK
    // or PRINT bits set.  Or it can be the value 0.
    //
    if (dwType & ~(RESOURCETYPE_DISK | RESOURCETYPE_PRINT)) {
        status = WN_BAD_VALUE;
        goto CleanExit;
    }

    //
    // dwUsage is a bit mask that can have any combination of the CONNECTABLE
    // or CONTAINER bits set.  Or it can be the value 0.  This field is
    // ignored if dwScope is not RESOURCE_GLOBALNET.
    //
    if (dwScope == RESOURCE_GLOBALNET) {
        if (dwUsage & ~(RESOURCEUSAGE_ALL)) {
            status = WN_BAD_VALUE;
            goto CleanExit;
        }
    }

    //
    // Make sure the user passed in a valid OUT parameter
    //
    __try
    {
        PROBE_FOR_WRITE((LPDWORD)lphEnum);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS)
    {
        goto CleanExit;
    }

    //
    // Check to see if it is a top-level enum request.
    //
    if (lpNetResource == NULL
         ||
        (IS_EMPTY_STRING(lpNetResource->lpProvider) &&
         IS_EMPTY_STRING(lpNetResource->lpRemoteName))
         ||
        dwScope == RESOURCE_SHAREABLE)
    {
        //
        // lpNetResource is NULL or represents no resource or this is
        // a request for shareable resources.
        // This is a top-level enum request, therefore, the MPR must provide
        // the information.
        //
        switch(dwScope) {

        case RESOURCE_CONNECTED:
        case RESOURCE_CONTEXT:
        case RESOURCE_SHAREABLE:
        {
            MprCheckProviders();

            CProviderSharedLock    PLock;

            INIT_IF_NECESSARY(NETWORK_LEVEL,status);

            if (MprNetIsAvailable()) {
                status = MprOpenEnumConnect(dwScope,
                                            dwType,
                                            dwUsage,
                                            lpNetResource,
                                            lphEnum);
            }
            else
                status = WN_NO_NETWORK ;
            break;
        }

        case RESOURCE_GLOBALNET:
        {
            MprCheckProviders();

            CProviderSharedLock    PLock;

            INIT_IF_NECESSARY(NETWORK_LEVEL,status);

            if (MprNetIsAvailable()) {
                status = MprOpenEnumNetwork(lphEnum);
            }
            else
                status = WN_NO_NETWORK ;
            break;
        }

        case RESOURCE_REMEMBERED:
        case RESOURCE_RECENT:
            MPR_LOG(TRACE,"OpenEnum RESOURCE_REMEMBERED\n",0);
            status = MprOpenRemember(dwType, lphEnum);
            break;

        default:
            status = WN_BAD_VALUE;
            break;
        }
    }
    else {
        //
        // Request is for one of the providers.  It should be for a
        // GLOBALNET enumeration.  It is not allowed to request any
        // other type of enumeration with a pointer to a resource
        // buffer.
        //
        if (dwScope != RESOURCE_GLOBALNET) {
            status = WN_BAD_VALUE;
            goto CleanExit;
        }

        CProviderOpenEnum ProviderOpenEnum(
                        dwScope,
                        dwType,
                        dwUsage,
                        lpNetResource,
                        lphEnum);

        status = ProviderOpenEnum.Perform(TRUE);
    }

CleanExit:
    if (status != WN_SUCCESS) {
        SetLastError(status);
    }
    return(status);
}

DWORD
WNetEnumResourceW (
    IN      HANDLE  hEnum,
    IN OUT  LPDWORD lpcCount,
    OUT     LPVOID  lpBuffer,
    IN OUT  LPDWORD lpBufferSize
    )

/*++

Routine Description:

    This function is used to obtain an array of NETRESOURCE structures each
    of which describes a network resource.

Arguments:

    hEnum - This is a handle that was obtained from an WNetOpenEnum call.

    lpcCount - Specifies the number of entries requested.  -1 indicates
        as many entries as possible are requested.  If the operation is
        successful, this location will receive the number of entries
        actually read.

    lpBuffer - A pointer to the buffer to receive the enumeration result,
        which are returned as an array of NETRESOURCE entries.  The buffer
        is valid until the next call using hEnum.

    lpBufferSize - This specifies the size of the buffer passed to the function
        call.  It will contain the required buffer size if WN_MORE_DATA is
        returned.

Return Value:

    WN_SUCCESS - Indicates that the call is successful, and that the caller
        should continue to call WNetEnumResource to continue the enumeration.

    WN_NO_MORE_ENTRIES - Indicates that the enumeration completed successfully.

    The following return codes indicate an error occured and GetLastError
    may be used to obtain another copy of the error code:

    WN_MORE_DATA - Indicates that the buffer is too small for even one
        entry.

    WN_BAD_HANDLE - hEnum is not a valid handle.

    WN_NO_NETWORK - The Network is not present.  This condition is checked
        for before hEnum is tested for validity.

History:
    12-Feb-1992     Johnl   Removed requirement that buffersize must be at
                least as large as NETRESOURCEW (bug 5790)


--*/
{
    DWORD   status = WN_SUCCESS;

    //
    // Screen the parameters as best we can.
    //

    //
    // Probe the handle
    //
    __try {
        *(volatile DWORD *)hEnum;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetEnumResource:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_HANDLE;
    }

    __try {
        PROBE_FOR_WRITE(lpcCount);

        if (IS_BAD_BYTE_BUFFER(lpBuffer, lpBufferSize)) {
            status = WN_BAD_POINTER;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetEnumResource:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS) {
        goto CleanExit;
    }

    switch(*(LPDWORD)hEnum){

    case CONNECT_TABLE_KEY:
        //
        // Call on Providers to enumerate connections.
        //

        status = MprEnumConnect(
                    (LPCONNECT_HEADER)hEnum,    // key is part of structure
                    lpcCount,
                    lpBuffer,
                    lpBufferSize);
        break;

    case STATE_TABLE_KEY:
        //
        // Enumerate the top level NetResource structure maintained by
        // the router.
        //

        status = MprEnumNetwork(
                    (LPNETWORK_HEADER)hEnum,
                    lpcCount,
                    lpBuffer,
                    lpBufferSize);
        break;

    case PROVIDER_ENUM_KEY:
        //
        // Call on providers to enumerate resources on the network.
        //

        status = MprProviderEnum(
                    (LPENUM_HANDLE)hEnum,       // key is part of structure
                    lpcCount,
                    lpBuffer,
                    lpBufferSize);
        break;
    case REMEMBER_KEY:

        //
        // Enumerate the connections in the current user section of the
        // registry.
        //

        status = MprEnumRemembered(
                    (LPREMEMBER_HANDLE)hEnum,
                    lpcCount,
                    (LPBYTE)lpBuffer,
                    lpBufferSize);
        break;
    default:
        status = WN_BAD_HANDLE;
    }

CleanExit:
    if(status != WN_SUCCESS) {
        SetLastError(status);
    }
    return(status);
}


DWORD
WNetCloseEnum (
    IN HANDLE   hEnum
    )

/*++

Routine Description:

    Closes an enumeration handle that is owned by the router.
    In cases where the router is acting as a proxy for a single provider,
    an attempt is made to return any error information from this provider
    back to the user.  This makes the router as transparent as possible.

Arguments:

    hEnum - This must be a handle obtained from a call to WNetOpenEnum.

Return Value:

    WN_SUCCESS - The operation was successful.

    WN_NO_NETWORK - The Network is not present.  This condition is checked
        before hEnum is tested for validity.

    WN_BAD_HANDLE - hEnum is not a valid handle.

--*/
{
    DWORD               status = WN_SUCCESS;
    DWORD               i;

    //
    // Probe the handle
    //
    __try {
        *(volatile DWORD *)hEnum;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetCloseEnum:Unexpected Exception 0x%lx\n",status);
        }

        status = WN_BAD_HANDLE;
    }

    if (status != WN_SUCCESS) {
        SetLastError(WN_BAD_HANDLE);
        return(status);
    }

    //
    // Use hEnum as a pointer and check the DWORD value at its location.
    // If it contains a CONNECT_TABLE_KEY, we must close all handles to
    // the providers before freeing the memory for the table.
    // If it is a STATE_TABLE_KEY, we just free the memory.
    //
    switch(*(LPDWORD)hEnum){

    case CONNECT_TABLE_KEY:
    {
        LPCONNECT_HEADER    connectEnumHeader;
        LPCONNECT_ENUM      connectEnumTable;

        connectEnumHeader = (LPCONNECT_HEADER)hEnum;
        connectEnumTable  = (LPCONNECT_ENUM)(connectEnumHeader + 1);
        //
        // Close all the open provider handles
        //
        MPR_LOG(TRACE,"Closing Connection Enum Handles from Providers\n",0);

        for(i = 0; i < connectEnumHeader->dwNumProviders; i++) {

            if((connectEnumTable[i].State != NOT_OPENED) &&
               (connectEnumTable[i].pfCloseEnum != NULL))
            {
                status = connectEnumTable[i].pfCloseEnum(
                            connectEnumTable[i].ProviderEnumHandle);

                if(status != WN_SUCCESS) {
                    //
                    // Because we are closing many handles at once, the failure
                    // is noted for debug purposes only.
                    //
                    MPR_LOG(ERROR,"WNetCloseEnum:(connect-provider #%d) failed\n",i);
                    MPR_LOG(ERROR,"WNetCloseEnum: error code = %d\n",status);
                    //
                    // Error information is returned if there is only one
                    // provider.
                    //
                    if (connectEnumHeader->dwNumProviders != 1) {
                        status = WN_SUCCESS;
                    }
                }

                //
                // If this fires, the logic in MprOpenEnumConnect is wrong
                //
                ASSERT(connectEnumTable[i].hProviderDll != NULL);

                FreeLibrary(connectEnumTable[i].hProviderDll);
            }
            else
            {
                //
                // If this fires, the logic in MprOpenEnumConnect is wrong
                // and we're not releasing a refcounted provider DLL
                //
                ASSERT(connectEnumTable[i].hProviderDll == NULL);
            }
        }

        //
        // Free the Table Memory
        //
        if (LocalFree(hEnum)) {
            MPR_LOG(ERROR,"WNetCloseEnum:LocalFree(connect) failed %d\n",
            GetLastError());
        }

        if (status != WN_SUCCESS)
        {
            SetLastError(status);
        }
        return(status);
    }

    case STATE_TABLE_KEY:
    {
        LPNETWORK_HEADER    StateTableHeader;
        LPNETWORK_ENUM      StateTable;

        //
        // Free the State Table Memory.
        //
        MPR_LOG(TRACE,"Free State Table for Network Enum\n",0);

        StateTableHeader = (LPNETWORK_HEADER)hEnum;
        StateTable       = (LPNETWORK_ENUM)(StateTableHeader + 1);

        for (i = 0; i < StateTableHeader->dwNumProviders; i++)
        {
            if (StateTable[i].hProviderDll != NULL)
            {
                FreeLibrary(StateTable[i].hProviderDll);
                LocalFree(StateTable[i].lpnr);
            }
            else
            {
                //
                // If this fires, MprOpenEnumNetwork is causing a mem leak
                //
                ASSERT(StateTable[i].lpnr == NULL);
            }
        }

        if (LocalFree(hEnum)) {
            MPR_LOG(ERROR,"WNetCloseEnum:LocalFree(network) failed %d\n",
            GetLastError());
        }
        return(WN_SUCCESS);
    }

    case PROVIDER_ENUM_KEY:
    {
        LPENUM_HANDLE       enumHandle;

        //
        // Close the providers enumeration handle, and free the
        // ENUM_HANDLE structure.
        //
        MPR_LOG(TRACE,"Closing Provider Enum Handle\n",0);

        enumHandle = (LPENUM_HANDLE)hEnum;

        ASSERT(enumHandle->pfCloseEnum != NULL);
        status = (enumHandle->pfCloseEnum)(enumHandle->EnumHandle);

        ASSERT(enumHandle->hProviderDll != NULL);
        FreeLibrary(enumHandle->hProviderDll);

        if (LocalFree(enumHandle) != 0) {
            MPR_LOG(ERROR,"WNetCloseEnum:LocalFree(provider) failed %d\n",
            GetLastError());
        }

        //
        // Check the status returned from the Provider's CloseEnum
        //
        if(status != WN_SUCCESS) {

            MPR_LOG(ERROR,"WNetCloseEnum:(provider) failed %d\n",status);

            SetLastError(status);
        }

        return(status);
    }

    case REMEMBER_KEY:
    {
        LPREMEMBER_HANDLE   rememberHandle;

        rememberHandle = (LPREMEMBER_HANDLE)hEnum;

        //
        // Close the RegistryKey Handle associated with this handle.
        //
        if (rememberHandle->ConnectKey != NULL) {
            RegCloseKey(rememberHandle->ConnectKey);
        }

        //
        // Free up the memory for the handle.
        //

        if (LocalFree(rememberHandle) != 0) {
            MPR_LOG(ERROR,"WNetCloseEnum:LocalFree(remember) failed %d\n",
            GetLastError());
        }

        return(WN_SUCCESS);
    }

    default:
        SetLastError(WN_BAD_HANDLE);
        return(WN_BAD_HANDLE);
    }
}


DWORD
MprOpenEnumConnect(
    IN  DWORD          dwScope,
    IN  DWORD          dwType,
    IN  DWORD          dwUsage,
    IN  LPNETRESOURCE  lpNetResource,
    OUT LPHANDLE       lphEnum
    )

/*++

Routine Description:

    This function handles the opening of connection enumerations and context
    enumerations.  It does this by sending an OpenEnum to all Providers, and
    storing the returned handles in a table.  The handle that is returned is
    a pointer to this table.

    The first DWORD in the table is a key that will help to identify a
    correct table.  The second DWORD is a Boolean value that tells whether
    a NETRESOURCE structure representing the root of the network needs to be
    returned in the enumeration.

Arguments:

    dwScope - RESOURCE_CONNECTED, RESOURCE_CONTEXT, or RESOURCE_SHAREABLE

    dwType -

    dwUsage -

    lpNetResource -

    lphEnum - This is a pointer to a location where the handle for
        the connection enumeration is to be stored.

Return Value:

    WN_SUCCESS - The operation was successful.

    WN_OUT_OF_MEMORY - The memory allocation for the handle was unsuccessful.

--*/
{
    DWORD                    i;
    DWORD                    status;
    LPCONNECT_HEADER         connectEnumHeader;
    LPCONNECT_ENUM           connectEnumTable;
    LPPROVIDER               provider;
    BOOL                     fcnSupported = FALSE; // Is fcn supported by a provider?
    BOOL                     atLeastOne=FALSE;
    BOOL                     bDynamicEntries = TRUE; // Whether to show dynamic entries
                                                     // in the net neighborhood
    HKEY                     hkPolicies = NULL;

    ASSERT(dwScope == RESOURCE_CONNECTED
            ||
           dwScope == RESOURCE_CONTEXT
            ||
           dwScope == RESOURCE_SHAREABLE);

    ASSERT_INITIALIZED(NETWORK);

    //
    // If there are no providers, return NO_NETWORK
    //
    if (GlobalNumActiveProviders == 0) {
        return(WN_NO_NETWORK);
    }

    //
    // Allocate the handle table with enough room for a header.
    //
    connectEnumHeader = (LPCONNECT_HEADER) LocalAlloc(
                    LPTR,
                    sizeof(CONNECT_HEADER) +
                        sizeof(CONNECT_ENUM) * GlobalNumProviders
                    );

    if (connectEnumHeader == NULL) {
        MPR_LOG(ERROR,"MprOpenEnumConnect:LocalAlloc Failed %d\n",GetLastError());
        return(WN_OUT_OF_MEMORY);
    }

    //
    // Initialize the key used in the connect table.
    //
    connectEnumHeader->Key                    = CONNECT_TABLE_KEY;
    connectEnumHeader->ReturnRoot             = FALSE;
    connectEnumHeader->dwNumProviders         = GlobalNumProviders;
    connectEnumHeader->dwNumActiveProviders   = GlobalNumActiveProviders;

    connectEnumTable = (LPCONNECT_ENUM)(connectEnumHeader + 1);

    //
    // Check the policy on whether dynamic entries are to be shown in the
    // network neighborhood.  By default, they are shown.
    //
    if (dwScope == RESOURCE_CONTEXT)
    {
        if (MprOpenKey(
                HKEY_CURRENT_USER,
                REGSTR_PATH_NETWORK_POLICIES,
                &hkPolicies,
                KEY_READ))
        {
            bDynamicEntries = ! (MprGetKeyNumberValue(
                                        hkPolicies,
                                        REGSTR_VAL_NOWORKGROUPCONTENTS,
                                        FALSE));
        }
        else
        {
            hkPolicies = NULL;
        }
    }

    //
    // Initialize all state flags for providers to the NOT_OPENED state, so
    // we won't try to enumerate or close their handles unless we actually
    // got handles from them.
    // Initialize handles for the network providers by calling them with
    // OpenEnum.
    //

    for(i=0; i<GlobalNumProviders; i++) {

        connectEnumTable[i].State = NOT_OPENED;

        provider = GlobalProviderInfo + i;

        if ((provider->InitClass & NETWORK_TYPE) &&
            (provider->OpenEnum != NULL)) {

            if (dwScope == RESOURCE_CONTEXT)
            {
                DWORD dwCaps = provider->GetCaps(WNNC_ENUMERATION);

                if (dwCaps & WNNC_ENUM_GLOBAL)
                {
                    // A browsing network is present, so show root,
                    // even if network is down, and even if ENUM_CONTEXT
                    // isn't supported.
                    connectEnumHeader->ReturnRoot = TRUE;
                }

                if ((dwCaps & WNNC_ENUM_CONTEXT) == 0)
                {
                    // This provider can't show hood entries, so skip it.
                    continue;
                }
            }
            else if (dwScope == RESOURCE_SHAREABLE)
            {
                DWORD dwCaps = provider->GetCaps(WNNC_ENUMERATION);

                if ((dwCaps & WNNC_ENUM_SHAREABLE) == 0)
                {
                    // This provider can't show shareable resources, so skip it.
                    continue;
                }
            }

            fcnSupported = TRUE;

            if (bDynamicEntries)
            {
                //
                // Refcount the provider
                //
                connectEnumTable[i].hProviderDll = LoadLibraryEx(provider->DllName,
                                                                 NULL,
                                                                 LOAD_WITH_ALTERED_SEARCH_PATH);

                if (connectEnumTable[i].hProviderDll == NULL)
                {
                    status = GetLastError();

                    //
                    // This can happen under extreme low memory conditions.  The
                    // loader can sometimes return ERROR_MOD_NOT_FOUND in this case.
                    //
                    MPR_LOG2(ERROR,
                             "MprOpenEnumConnect: LoadLibraryEx on %ws FAILED %d\n",
                             provider->DllName,
                             status);

                    ASSERT(status == ERROR_NOT_ENOUGH_MEMORY || status == ERROR_MOD_NOT_FOUND);
                    continue;
                }

                connectEnumTable[i].pfEnumResource = provider->EnumResource;
                connectEnumTable[i].pfCloseEnum    = provider->CloseEnum;

                status = provider->OpenEnum(
                            dwScope,                // Scope
                            dwType,                 // Type
                            dwUsage,                // Usage
                            (dwScope == RESOURCE_SHAREABLE ? lpNetResource : NULL), // NetResource
                            &(connectEnumTable[i].ProviderEnumHandle));             // hEnum

                if (status != WN_SUCCESS) {

                    MPR_LOG(ERROR,"MprOpenEnumConnect:OpenEnum Failed %d\n",status);
                    MPR_LOG(ERROR,
                            "That was for the %ws Provider\n",
                            provider->Resource.lpProvider);

                    FreeLibrary(connectEnumTable[i].hProviderDll);

                    connectEnumTable[i].hProviderDll   = NULL;
                    connectEnumTable[i].pfEnumResource = NULL;
                    connectEnumTable[i].pfCloseEnum    = NULL;
                }
                else {
                    //
                    // At least one provider has returned a handle.
                    //
                    atLeastOne = TRUE;

                    //
                    // Set the state to MORE_ENTRIES, so we later enumerate from the
                    // handle and/or close it.
                    //
                    connectEnumTable[i].State = MORE_ENTRIES;

                    MPR_LOG(TRACE,"MprOpenEnumConnect: OpenEnum Handle = 0x%lx\n",
                        connectEnumTable[i].ProviderEnumHandle);
                }
            }
            else
            {
                // Succeed the WNetOpenEnum but leave this provider as NOT_OPENED
                atLeastOne = TRUE;
            }
        }
    }

    if (connectEnumHeader->ReturnRoot)
    {
        // Able to show the root object.  Check the policy on whether
        // to show it.
        connectEnumHeader->ReturnRoot = ! (MprGetKeyNumberValue(
                                                hkPolicies,
                                                REGSTR_VAL_NOENTIRENETWORK,
                                                FALSE));
        fcnSupported = TRUE;
        atLeastOne = TRUE;
    }

    if (hkPolicies)
    {
        RegCloseKey(hkPolicies);
    }

    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        // Note that in this case, atLeastOne will always be FALSE.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // return the handle (pointer to connectEnumTable);
    //
    *lphEnum = connectEnumHeader;

    if (atLeastOne == FALSE) {
        //
        // If none of the providers returned a handle, then return the
        // status from the last provider.
        //

        *lphEnum = NULL;
        LocalFree( connectEnumHeader);
        return(status);
    }

    return(WN_SUCCESS);

}


DWORD
MprOpenEnumNetwork(
    OUT LPHANDLE    lphEnum
    )

/*++

Routine Description:

    This function handles the opening of net resource enumerations.
    It does this by allocating a table of Provider State Flags and returning
    a handle to that table.  The state flags (or for each provider) will
    be set to MORE_ENTRIES.  Later, when enumerations take place, the state
    for each provider is changed to DONE after the buffer is successfully
    loaded with the the NETRESOURCE info for that provider.

Arguments:

    lphEnum - This is a pointer to a location where the handle for
        the network resource enumeration is to be stored.

Return Value:

    WN_SUCCESS - The operation was successful.

    WN_OUT_OF_MEMORY - The memory allocation for the handle was unsuccessful.


--*/
{
    LPNETWORK_ENUM   stateTable;
    LPNETWORK_HEADER stateTableHeader;
    DWORD            i;

    ASSERT_INITIALIZED(NETWORK);

    //
    // If there are no providers, return NO_NETWORK
    //
    if (GlobalNumActiveProviders == 0) {
        return(WN_NO_NETWORK);
    }

    //
    // Allocate the state table.
    //
    stateTableHeader = (LPNETWORK_HEADER) LocalAlloc(
                    LPTR,
                    sizeof(NETWORK_HEADER) +
                        sizeof(NETWORK_ENUM) * GlobalNumProviders
                    );

    if (stateTableHeader == NULL) {
        MPR_LOG(ERROR,"MprOpenEnumNetwork:LocalAlloc Failed %d\n",GetLastError());
        return(WN_OUT_OF_MEMORY);
    }

    stateTableHeader->Key                  = STATE_TABLE_KEY;
    stateTableHeader->dwNumProviders       = GlobalNumProviders;
    stateTableHeader->dwNumActiveProviders = GlobalNumActiveProviders;

    stateTable = (LPNETWORK_ENUM)(stateTableHeader + 1);

    //
    // Initialize state flags for all network providers to the MORE_ENTRIES state.
    //
    for(i = 0; i < GlobalNumProviders; i++) {

        if (GlobalProviderInfo[i].InitClass & NETWORK_TYPE)
        {
            if (GlobalProviderInfo[i].Handle != NULL)
            {
                stateTable[i].hProviderDll = LoadLibraryEx(GlobalProviderInfo[i].DllName,
                                                           NULL,
                                                           LOAD_WITH_ALTERED_SEARCH_PATH);

                if (stateTable[i].hProviderDll == NULL)
                {
                    DWORD status = GetLastError();

                    //
                    // This can happen under extreme low memory conditions.  The
                    // loader can sometimes return ERROR_MOD_NOT_FOUND in this case.
                    //
                    MPR_LOG1(ERROR,
                             "MprOpenEnumNetwork:  LoadLibraryEx on %ws FAILED\n",
                             GlobalProviderInfo[i].DllName);

                    ASSERT(status == ERROR_NOT_ENOUGH_MEMORY || status == ERROR_MOD_NOT_FOUND);
                }
                else
                {
                    LPBYTE  lpTempBuffer;
                    DWORD   dwSize = 0;
                    DWORD   dwStatus;

                    //
                    // Figure out how much space we'll need for the NETRESOURCE.
                    // It needs to be copied since the provider (and its resource)
                    // may go away between now and the WNetEnumResource call.
                    //
                    dwStatus = MprCopyResource(NULL,
                                               &GlobalProviderInfo[i].Resource,
                                               &dwSize);

                    ASSERT(dwStatus == WN_MORE_DATA);

                    stateTable[i].lpnr = (LPNETRESOURCE)LocalAlloc(LPTR, dwSize);

                    if (stateTable[i].lpnr == NULL)
                    {
                        MPR_LOG0(ERROR, "MprOpenEnumNetwork:  LocalAlloc FAILED\n");

                        //
                        // Rather than fail silently in this case, bail out
                        //
                        for (UINT j = 0; j <= i; j++)
                        {
                            if (stateTable[j].hProviderDll)
                            {
                                FreeLibrary(stateTable[j].hProviderDll);
                                stateTable[j].hProviderDll = NULL;
                                stateTable[j].State        = MORE_ENTRIES;
                            }

                            LocalFree(stateTable[j].lpnr);
                        }

                        LocalFree(stateTableHeader);
                        return(WN_OUT_OF_MEMORY);
                    }
                    else
                    {
                        lpTempBuffer = (LPBYTE)stateTable[i].lpnr;

                        dwStatus = MprCopyResource(&lpTempBuffer,
                                                   &GlobalProviderInfo[i].Resource,
                                                   &dwSize);

                        ASSERT(dwStatus == WN_SUCCESS);
                    }
                }
            }

            stateTable[i].State = MORE_ENTRIES;
        }
        else {
            stateTable[i].State = DONE;
        }
    }

    //
    // return the handle (pointer to stateTable);
    //
    *lphEnum = stateTableHeader;

    return(WN_SUCCESS);
}


DWORD
MprEnumConnect(
    IN OUT  LPCONNECT_HEADER    ConnectEnumHeader,
    IN OUT  LPDWORD             NumEntries,
    IN OUT  LPVOID              lpBuffer,
    IN OUT  LPDWORD             lpBufferSize
    )

/*++

Routine Description:

    This function looks in the ConnectEnumTable for the next provider that
    has MORE_ENTRIES.  It begins requesting Enum Data from that provider -
    each time copying data that is returned from the provider enum into the
    users enum buffer (lpBuffer).  This continues until we finish, or
    we reach the requested number of elements, or the user buffer is full.
    Each time we enumerate a provider to completion, that provider is
    marked as DONE.

    Note, for a context enumeration, the first NETRESOURCE returned in the
    enumeration is a constant NETRESOURCE representing the root of the
    network.  This is done to make it easy for the shell to display a
    "Rest of Network" object in a "Network Neighborhood" view.

Arguments:

    ConnectEnumHeader - This is a pointer to a CONNECT_HEADER structure
        followed by an array of CONNECT_ENUM structures.  The ReturnRoot
        member of the header tells whether the root object needs to be
        returned at the start of the enumeration.  On exit, if the root
        object has been returned, the ReturnRoot member is set to FALSE.

    NumEntries - On entry this points to the maximum number of entries
        that the user desires to receive.  On exit it points to the
        number of entries that were placed in the users buffer.

    lpBuffer - This is a pointer to the users buffer in which the
        enumeration data is to be placed.

    lpBufferSize - This is the size (in bytes) of the users buffer.  It will
        be set to the size of the required buffer size of WN_MORE_DATA is
        returned.

Return Value:

    WN_SUCCESS - This indicates that the call is returning some entries.
        However, the enumeration is not complete due to one of the following:
        1)  There was not enough buffer space.
        2)  The requested number of entries was reached.
        3)  There is no more data to enumerate - the next call will
            return WN_NO_MORE_ENTRIES.

    WN_MORE_DATA - This indicates that the buffer was not large enough
        to receive one enumeration entry.

    WN_NO_MORE_ENTRIES - This indicates that there are no more entries
        to enumerate.  No data is returned with this return code.

    WN_NO_NETWORK - If there are no providers loaded.

Note:


--*/
{

    DWORD           i;              // provider index
    DWORD           status=WN_NO_MORE_ENTRIES;
    DWORD           entriesRead=0;  // number of entries read into the buffer.
    LPBYTE          tempBufPtr;     // pointer to top of remaining free buffer space.
    LPNETRESOURCEW  providerBuffer; // buffer for data returned from provider
    DWORD           bytesLeft;      // Numer of bytes left in the buffer
    DWORD           entryCount;     // number of entries read from provider
    LPCONNECT_ENUM  ConnectEnumTable = (LPCONNECT_ENUM) (ConnectEnumHeader + 1);
                                    // Start of array

    //
    // If there are no providers, return NO_NETWORK
    //
    if (ConnectEnumHeader->dwNumActiveProviders == 0) {
        return(WN_NO_NETWORK);
    }

    bytesLeft  = ROUND_DOWN(*lpBufferSize);
    tempBufPtr = (LPBYTE) lpBuffer;

    //
    // Check to see if there are any flags in state table that indicate
    // MORE_ENTRIES.  If not, we want to return WN_NO_MORE_ENTRIES.
    //

    for(i = 0; i < ConnectEnumHeader->dwNumProviders; i++) {
        if(ConnectEnumTable[i].State == MORE_ENTRIES) {
            break;
        }
    }

    if ( (i == ConnectEnumHeader->dwNumProviders) && (! ConnectEnumHeader->ReturnRoot) ) {
        *NumEntries = 0;
        return(WN_NO_MORE_ENTRIES);
    }

    //
    // If no entries are requested, we have nothing to do
    //
    if (*NumEntries == 0) {
        return WN_SUCCESS;
    }

    //
    // Allocate a buffer for the provider to return data in.
    // The buffer size must equal the number of bytes left in the
    // user buffer.
    // (We can't have the provider write data directly to the caller's
    // buffer because NPEnumResource is not required to place strings
    // at the end of the buffer -- only at the end of the array of
    // NETRESOURCEs.)
    //
    providerBuffer = (LPNETRESOURCEW) LocalAlloc(LPTR, bytesLeft);
    if (providerBuffer == NULL) {
        MPR_LOG(ERROR,"MprEnumConnect:LocalAlloc Failed %d\n",
            GetLastError());

        *NumEntries = 0;
        return(WN_OUT_OF_MEMORY);
    }

    //
    // Copy the root-of-network resource if required.
    //
    if (ConnectEnumHeader->ReturnRoot)
    {
        NETRESOURCEW RootResource = {
                            RESOURCE_GLOBALNET,         // dwScope
                            RESOURCETYPE_ANY,           // dwType
                            RESOURCEDISPLAYTYPE_ROOT,   // dwDisplayType
                            RESOURCEUSAGE_CONTAINER,    // dwUsage
                            NULL,                       // lpLocalName
                            NULL,                       // lpRemoteName
                            g_wszEntireNetwork,         // lpComment
                            NULL                        // lpProvider
                            };


        status = MprCopyResource(&tempBufPtr, &RootResource, &bytesLeft);

        if (status == WN_SUCCESS)
        {
            entriesRead = 1;
            ConnectEnumHeader->ReturnRoot = FALSE;
        }
        else
        {
            if (status == WN_MORE_DATA)
            {
                //
                // Not even enough room for one NETRESOURCE
                //
                *lpBufferSize = bytesLeft;
            }

            goto CleanExit;
        }
    }

    //
    // Loop until we have copied from all Providers or until the
    // the maximum number of entries has been reached.
    //
    for ( ; i < ConnectEnumHeader->dwNumProviders && entriesRead < *NumEntries; i++)
    {
        if (ConnectEnumTable[i].State != MORE_ENTRIES)
        {
            //
            // Skip providers that don't have more entries
            //
            continue;
        }

        if (ConnectEnumTable[i].hProviderDll == NULL) {
            //
            // If the provider has not been initialized because it is
            // not "ACTIVE", then skip it.
            //
            ConnectEnumTable[i].State = DONE;
            status = WN_SUCCESS;
            continue;
        }

        //
        // Adjust the entry count for any entries that have been read
        // so far.
        //
        entryCount = *NumEntries - entriesRead;

        //
        // Call the provider to get the enumerated data
        //
        status = ConnectEnumTable[i].pfEnumResource(
                    ConnectEnumTable[i].ProviderEnumHandle,
                    &entryCount,
                    providerBuffer,
                    &bytesLeft );   // (note, the provider updates
                                    // bytesLeft only if it returns
                                    // WN_MORE_DATA)

        switch (status)
        {
        case WN_SUCCESS:

            MPR_LOG(TRACE,"EnumResourceHandle = 0x%lx\n",
                ConnectEnumTable[i].ProviderEnumHandle);

            status = MprCopyProviderEnum(
                        providerBuffer,
                        &entryCount,
                        &tempBufPtr,
                        &bytesLeft);

            entriesRead += entryCount;

            if (status != WN_SUCCESS) {
                //
                // An internal error occured - for some reason the
                // buffer space left in the user buffer was smaller
                // than the buffer space that the provider filled in.
                // The best we can do in this case is return what data
                // we have.  WARNING: the data that didn't make it
                // will become lost since the provider thinks it
                // enumerated successfully, but we couldn't do anything
                // with it.
                //
                MPR_LOG(ERROR,
                    "MprEnumConnect:MprCopyProviderEnum Internal Error %d\n",
                    status);

                if(entriesRead > 0) {
                    status = WN_SUCCESS;
                }
                goto CleanExit;
            }
            //
            // We successfully placed all the received data from
            // that provider into the user buffer.  In this case,
            // if we haven't reached the requested number of entries,
            // we want to loop around and ask the same provider
            // to enumerate more.  This time the provider should
            // indicate why it quit last time - either there are
            // no more entries, or we ran out of buffer space.
            //
            break;

        case WN_NO_MORE_ENTRIES:
            //
            // This Provider has completed its enumeration, mark it
            // as done and increment to the next provider.  We don't
            // want to return NO_MORE_ENTRIES status.  That should
            // only be returned by the check at beginning or end
            // of this function.
            //
            ConnectEnumTable[i].State = DONE;
            status = WN_SUCCESS;
            break;

        case WN_MORE_DATA:
            //
            // This provider has more data, but there is not enough
            // room left in the user buffer to place any more data
            // from this provider.  We don't want to go on to the
            // next provider until we're finished with this one.  So
            // if we have any entries at all to return, we send back
            // a SUCCESS status.  Otherwise, the WN_MORE_DATA status
            // is appropriate.
            //
            if(entriesRead > 0) {
                status = WN_SUCCESS;
            }
            else
            {
                //
                // If 0 entries were read, then the provider should
                // have set bytesLeft with the required buffer size
                //
                *lpBufferSize = ROUND_UP(bytesLeft);
            }
            goto CleanExit;
            break;

        default:
            //
            // We received an unexpected error from the Provider Enum
            // call.
            //
            MPR_LOG(ERROR,"MprEnumConnect:ProviderEnum Error %d\n",status);
            if(entriesRead > 0) {
                //
                // If we have received data so far, ignore this error
                // and move on to the next provider.  This provider will
                // be left in the MORE_ENTRIES state, so that on some other
                // pass - when all other providers are done, this error
                // will be returned.
                //
                status = WN_SUCCESS;
            }
            else{
                //
                // No entries have been read so far.  We can return
                // immediately with the error.
                //
                goto CleanExit;
            }

        } // end switch (status)

    } // end for (each provider)

    //
    // If we looped through all providers and they are all DONE.
    // If there were no connections, then return proper error code.
    //
    if ((entriesRead == 0) && (status == WN_SUCCESS)) {
        status = WN_NO_MORE_ENTRIES;
    }

CleanExit:
    //
    // Update the number of entries to be returned to user.
    //
    *NumEntries = entriesRead;
    LocalFree(providerBuffer);
    return(status);
}

DWORD
MprEnumNetwork(
    IN OUT  LPNETWORK_HEADER     StateTableHeader,
    IN OUT  LPDWORD              NumEntries,
    IN OUT  LPVOID               lpBuffer,
    IN OUT  LPDWORD              lpBufferSize
    )

/*++

Routine Description:

    This function Looks in the state table for the next provider that has
    MORE_ENTRIES.  It begins by copying the NETRESOURCE info for that one.
    This continues until we finish, or we reach the requested number of
    elements, or the buffer is full.  Each time we copy a complete structure,
    we mark that provider as DONE.

Arguments:

    StateTable - This is a pointer to the state table that is managed by
        the handle used in this request.  The state table is a table of
        flags used to indicate the enumeration state for a given
        provider.  These flags are in the same order as the provider
        information in the GlobalProviderInfo Array.  The state can be
        either DONE or MORE_ENTRIES.

    NumEntries - On entry this points to the maximum number of entries
        that the user desires to receive.  On exit it points to the
        number of entries that were placed in the users buffer.

    lpBuffer - This is a pointer to the users buffer in which the
        enumeration data is to be placed.

    lpBufferSize - This is the size (in bytes) of the users buffer.

Return Value:

    WN_SUCCESS - This indicates that the call is returning some entries.
        However, the enumeration is not complete due to one of the following:
        1)  There was not enough buffer space.
        2)  The requested number of entries was reached.
        3)  There is no more data to enumerate - the next call will
            return WN_NO_MORE_ENTRIES.

    WN_MORE_DATA - This indicates that the buffer was not large enough
        to receive one enumeration entry.

    WN_NO_MORE_ENTRIES - This indicates that there are no more entries
        to enumerate.  No data is returned with this return code.

Note:

    CAUTION:  "DONE" entries may appear anywhere in the statetable.
        You cannot always rely on the fact that all of the entries
        after a MORE_ENTRIES entry are also in the MORE_ENTRIES state.
        This is because a provider that would not pass back a handle
        at open time will be marked as DONE so that it gets skipped
        at Enum Time.

--*/
{
    DWORD       i;
    DWORD       status;
    DWORD       entriesRead=0;  // number of entries read into the buffer.
    LPBYTE      tempBufPtr;     // pointer to top of remaining free buffer space.
    DWORD       bytesLeft;      // num bytes left in free buffer space

    LPNETWORK_ENUM  StateTable = (LPNETWORK_ENUM)(StateTableHeader + 1);


    //
    // If there are no providers, return NO_NETWORK
    //
    if (StateTableHeader->dwNumActiveProviders == 0) {
        return(WN_NO_NETWORK);
    }

    bytesLeft  = ROUND_DOWN(*lpBufferSize);
    tempBufPtr = (LPBYTE) lpBuffer;

    //
    // Check to see if there are any flags in state table that indicate
    // MORE_ENTRIES.  If not, we want to return WN_NO_MORE_ENTRIES.
    //

    for(i = 0; i < StateTableHeader->dwNumProviders; i++) {
        if(StateTable[i].State == MORE_ENTRIES) {
            break;
        }
    }

    if ( i >= StateTableHeader->dwNumProviders ) {
        *NumEntries = 0;
        return(WN_NO_MORE_ENTRIES);
    }

    //
    // Loop until we have copied from all Providers or until the
    // the maximum number of entries has been reached.
    //
    for(; (i < StateTableHeader->dwNumProviders) && (entriesRead < *NumEntries); i++)
    {
        if (StateTable[i].State == MORE_ENTRIES) {

            if (StateTable[i].hProviderDll == NULL)
            {
                //
                // If the provider is not ACTIVE, skip it.
                //
                StateTable[i].State = DONE;
            }
            else
            {
                status = MprCopyResource(
                            &tempBufPtr,
                            StateTable[i].lpnr,
                            &bytesLeft);

                if (status == WN_SUCCESS)
                {
                    StateTable[i].State = DONE;
                    entriesRead++;
                }
                else
                {
                    //
                    // The buffer must be full - so exit.
                    // If no entries are being returned, we will indicate
                    // that the buffer was not large enough for even one entry.
                    //
                    *NumEntries = entriesRead;

                    if (entriesRead > 0) {
                        return(WN_SUCCESS);
                    }
                    else {
                        *lpBufferSize = ROUND_UP(bytesLeft);
                        return(WN_MORE_DATA);
                    }
                }
            }
        } // EndIf (state == MORE_ENTRIES)
    } // EndFor (each provider)

    //
    // Update the number of entries to be returned to user
    //
    *NumEntries = entriesRead;

    return(WN_SUCCESS);
}

DWORD
MprProviderEnum(
    IN      LPENUM_HANDLE   EnumHandlePtr,
    IN OUT  LPDWORD         lpcCount,
    IN      LPVOID          lpBuffer,
    IN OUT  LPDWORD         lpBufferSize
    )

/*++

Routine Description:

    This function calls the provider (identified by the EnumHandlePtr)
    with a WNetEnumResource request.  Aside from the EnumHandlePtr, all the
    rest of the parameters are simply passed thru to the provider.

Arguments:

    EnumHandlePtr - This is a pointer to an ENUM_HANDLE structure which
        contains a pointer to the provider structure and the handle for
        that provider's enumeration.

    lpcCount - A pointer to a value that on entry contains the requested
        number of elements to enumerate.  On exit this contains the
        actual number of elements enumerated.

    lpBuffer - A pointer to the users buffer that the enumeration data
        is to be placed into.

    lpBufferSize - The number of bytes of free space in the user's buffer.

Return Value:

    This function can return any return code that WNetEnumResource()
    can return.

--*/
{
    DWORD   status;

    ASSERT(EnumHandlePtr->pfEnumResource != NULL);

    //
    // Call the provider listed in the ENUM_HANDLE structure and ask it
    // to enumerate.
    //
    status = EnumHandlePtr->pfEnumResource(
                EnumHandlePtr->EnumHandle,
                lpcCount,
                lpBuffer,
                lpBufferSize);

    if (status == WN_SUCCESS) {
        MPR_LOG(TRACE,"EnumResourceHandle = 0x%lx\n",
            EnumHandlePtr->EnumHandle);
    }
    return(status);
}

DWORD
MprCopyResource(
    IN OUT  LPBYTE          *BufPtr,
    IN const NETRESOURCEW   *Resource,
    IN OUT  LPDWORD         BytesLeft
    )

/*++

Routine Description:

    This function copies a single NETRESOURCE structure into a buffer.
    The structure gets copied to the top of the buffer, and the strings
    that the structure references are copied to the bottom of the
    buffer.  So any remaining free buffer space is left in the middle.

    Upon successful return from this function, BufPtr will point to
    the top of this remaining free space, and BytesLeft will be updated
    to indicate how many bytes of free space are remaining.

    If there is not enough room in the buffer to copy the Resource and its
    strings, an error is returned, and BufPtr is not changed.

Arguments:

    BufPtr - This is a pointer to a location that upon entry, contains a
        pointer to the buffer that the copied data is to be placed into.
        Upon exit, this pointer location points to the next free location
        in the buffer.

    Resource - This points to the Resource Structure that is to be copied
        into the buffer.

    BytesLeft - This points to a location to where a count of the remaining
        free bytes in the buffer is stored.  This is updated on exit to
        indicate the adjusted number of free bytes left in the buffer.
        If the buffer is not large enough, and WN_MORE_DATA is returned, then
        the size of the buffer required to fit all the data is returned in
        this field.

Return Value:

    WN_SUCCESS - The operation was successful

    WN_MORE_DATA - The buffer was not large enough to contain the
        Resource structure an its accompanying strings.

Note:


History:
    02-Apr-1992    JohnL
    Changed error return code to WN_MORE_DATA, added code to set the
    required buffer size if WN_MORE_DATA is returned.


--*/

{
    LPTSTR          startOfFreeBuf;
    LPTSTR          endOfFreeBuf;
    LPNETRESOURCEW  newResource;

    //
    // The buffer must be at least large enough to hold a resource structure.
    //
    if (*BytesLeft < sizeof(NETRESOURCEW)) {
        *BytesLeft = MprMultiStrBuffSize( Resource->lpRemoteName,
                      Resource->lpLocalName,
                      Resource->lpComment,
                      Resource->lpProvider,
                      NULL ) + sizeof(NETRESOURCEW) ;
        return(WN_MORE_DATA);
    }

    //
    // Copy the Resource structure into the beginning of the buffer.
    //
    newResource = (LPNETRESOURCEW) *BufPtr;
    memcpy(newResource, Resource, sizeof(NETRESOURCEW));

    startOfFreeBuf = (LPTSTR)((PCHAR)newResource + sizeof(NETRESOURCEW));
    endOfFreeBuf = (LPTSTR)((LPBYTE)newResource + *BytesLeft);

    //
    // If a REMOTE_NAME string is to be copied, copy that and update the
    // pointer in the structure.
    //
    if (Resource->lpRemoteName != NULL) {
        //
        // If we must copy the remote name,
        //
        if (!NetpCopyStringToBuffer(
                    Resource->lpRemoteName,         // pointer to string
                    wcslen(Resource->lpRemoteName), // num chars in string
                    startOfFreeBuf,                 // start of open space
                    &endOfFreeBuf,                  // end of open space
                    &newResource->lpRemoteName)) {  // where string pointer goes

            *BytesLeft = MprMultiStrBuffSize( Resource->lpRemoteName,
                          Resource->lpLocalName,
                          Resource->lpComment,
                          Resource->lpProvider,
                          NULL ) ;
            goto ErrorMoreData ;
        }
    }
    else{
        newResource->lpRemoteName = NULL;
    }

    //
    // If a LOCAL_NAME string is to be copied, copy that and update the
    // pointer in the structure.
    //
    if( ((Resource->dwScope == RESOURCE_CONNECTED)  ||
         (Resource->dwScope == RESOURCE_REMEMBERED))
          &&
        (Resource->lpLocalName != NULL) ) {

        //
        // If we must copy the local name,
        //
        if (!NetpCopyStringToBuffer(
                    Resource->lpLocalName,         // pointer to string
                    wcslen(Resource->lpLocalName), // num chars in string
                    startOfFreeBuf,                // start of open space
                    &endOfFreeBuf,                 // end of open space
                    &newResource->lpLocalName))    // where string pointer goes
        {
            goto ErrorMoreData ;
        }
    }
    else{
        newResource->lpLocalName = NULL;
    }

    //
    // If a COMMENT string is to be copied, copy that and update the
    // pointer in the structure.
    //
    if (Resource->lpComment != NULL) {
        //
        // If we must copy the comment string,
        //
        if (!NetpCopyStringToBuffer(
                    Resource->lpComment,            // pointer to string
                    wcslen(Resource->lpComment),    // num chars in string
                    startOfFreeBuf,                 // start of open space
                    &endOfFreeBuf,                  // end of open space
                    &newResource->lpComment))       // where string pointer goes
        {
            goto ErrorMoreData ;
        }
    }
    else{
        newResource->lpComment = NULL;
    }

    //
    // If a PROVIDER string is to be copied, copy that and update the
    // pointer in the structure.
    //
    if (Resource->lpProvider != NULL) {
        //
        // If we must copy the provider name,
        //
        if (!NetpCopyStringToBuffer(
                    Resource->lpProvider,           // pointer to string
                    wcslen(Resource->lpProvider),   // num chars in string
                    startOfFreeBuf,                 // start of open space
                    &endOfFreeBuf,                  // end of open space
                    &newResource->lpProvider))      // where string pointer goes
        {
            goto ErrorMoreData ;
        }
    }
    else{
        newResource->lpProvider = NULL;
    }

    //
    // Update the returned information
    //
    *BufPtr = (LPBYTE)startOfFreeBuf;

    *BytesLeft = (DWORD) ((LPBYTE) endOfFreeBuf - (LPBYTE) startOfFreeBuf);

    return (WN_SUCCESS);

    //
    // This is reached when we couldn't fill the buffer because the given
    // buffer size is too small.  We therefore need to set the required
    // buffer size before returning.

ErrorMoreData:

    *BytesLeft = MprMultiStrBuffSize( Resource->lpRemoteName,
                      Resource->lpLocalName,
                      Resource->lpComment,
                      Resource->lpProvider,
                      NULL ) + sizeof(NETRESOURCEW) ;

    return (WN_MORE_DATA);
}


DWORD
MprCopyProviderEnum(
    IN      LPNETRESOURCEW  ProviderBuffer,
    IN OUT  LPDWORD         EntryCount,
    IN OUT  LPBYTE          *TempBufPtr,
    IN OUT  LPDWORD         BytesLeft
    )

/*++

Routine Description:

    This function moves the enumerated NETRESOURCE structures that are
    returned from a provider to a buffer that can be returned to the user.
    The buffer that is returned to the user may contain enum data from
    several providers.  Because, we don't know how strings are packed in
    the buffer that is returned from the provider, we must simply walk
    through each structure and copy the information into the user buffer
    in a format that we do know about.  Then the amount of free space
    left in the user buffer can be determined so that enum data from
    another provider can be added to it.

Arguments:

    ProviderBuffer - This is a pointer to the top of an array of NETRESOURCE
        structures that is returned from one of the providers.

    EntryCount - This points to the number of elements in the array that
        was returned from the provider.  On exit, this points to the number
        of elements that was successfully copied.  This should always be
        the same as the number of elements passed in.

    TempBufPtr - This is a pointer to the top of the free space in the user
        buffer.

    BytesLeft - Upon entry, this contains the number of free space bytes
        in the user buffer.  Upon exit, this contains the updated number
        of free space bytes in the user buffer.


Return Value:

    WN_SUCCESS - The operation was successful

    WN_OUT_OF_MEMORY - The buffer was not large enough to contain all of
        data the provider returned.  This should never happen.

Note:


--*/
{
    DWORD   i;
    DWORD   status;
    DWORD   entriesRead=0;

    //
    // Loop for each element in the array of NetResource Structures.
    //
    for(i=0; i<*EntryCount; i++,ProviderBuffer++) {

        status = MprCopyResource(
                    TempBufPtr,
                    ProviderBuffer,
                    BytesLeft);

        if (status != WN_SUCCESS) {
            MPR_LOG(ERROR,"MprCopyProviderEnum: Buffer Size Mismatch\n",0);
            //
            // The buffer must be full - this should never happen since
            // the amount of data placed in the ProviderBuffer is limited
            // by the number of bytes left in the user buffer.
            //
            ASSERT(0);
            *EntryCount = entriesRead;
            return(status);
        }
        entriesRead++;
    }
    *EntryCount = entriesRead;
    return(WN_SUCCESS);
}


//===================================================================
// CProviderOpenEnum - open an enumeration by a provider
//===================================================================

DWORD
CProviderOpenEnum::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    //
    // Let the base class validate any specified provider name.
    // Note: This must be done before setting _lpNetResource to NULL!
    //
    *ppProviderName = _lpNetResource->lpProvider;

    //
    // Check to see if a top level enumeration for the provider is requested.
    // (This is different from a top level MPR enumeration.)
    // A top level enum is signified by a net resource with either a special
    // bit set in the dwUsage field, or a provider name but no remote name.
    //
    if ((_lpNetResource->dwUsage & RESOURCEUSAGE_RESERVED) ||
        IS_EMPTY_STRING(_lpNetResource->lpRemoteName))
    {
        //
        // Top level enum.  Don't pass the net resource to the provider.
        //
        ASSERT(! IS_EMPTY_STRING(_lpNetResource->lpProvider));
        _lpNetResource = NULL;
    }
    else
    {
        //
        // Use the remote name as a hint to pick the provider order.
        //
        *ppRemoteName = _lpNetResource->lpRemoteName;
    }

    *ppLocalName = NULL;

    return WN_SUCCESS;
}


DWORD
CProviderOpenEnum::TestProvider(
    const PROVIDER * pProvider
    )
{
    ASSERT(MPR_IS_INITIALIZED(NETWORK));

    if ((pProvider->GetCaps(WNNC_ENUMERATION) & WNNC_ENUM_GLOBAL) == 0)
    {
        return WN_NOT_SUPPORTED;
    }

    return ( pProvider->OpenEnum(
                            _dwScope,
                            _dwType,
                            _dwUsage,
                            _lpNetResource,
                            &_ProviderEnumHandle) );
}


DWORD
CProviderOpenEnum::GetResult()
{
    //
    // Let the base class try the providers until one responds
    // CRoutedOperation::GetResult calls INIT_IF_NECESSARY
    //
    DWORD status = CRoutedOperation::GetResult();
    if (status != WN_SUCCESS)
    {
        return status;
    }

    MPR_LOG(TRACE,"CProviderOpenEnum: OpenEnum Handle = 0x%lx\n",
        _ProviderEnumHandle);

    //
    // Allocate memory to store the handle.
    //
    LPENUM_HANDLE enumHandleStruct =
        (ENUM_HANDLE *) LocalAlloc(LPTR, sizeof(ENUM_HANDLE));

    if (enumHandleStruct == NULL)
    {
        //
        // If we can't allocate memory to store the handle
        // away, then we must close it, and change the status
        // to indicate a memory failure.
        //
        MPR_LOG(ERROR,"CProviderOpenEnum: LocalAlloc failed %d\n",
            GetLastError());

        LastProvider()->CloseEnum(_ProviderEnumHandle);

        status = WN_OUT_OF_MEMORY;
    }
    else
    {
        //
        // Store the handle in the ENUM_HANDLE structure and
        // return the pointer to that structure as a handle
        // for the user.
        //
        enumHandleStruct->Key = PROVIDER_ENUM_KEY;

        //
        // Refcount the provider
        //
        enumHandleStruct->hProviderDll = LoadLibraryEx(LastProvider()->DllName,
                                                       NULL,
                                                       LOAD_WITH_ALTERED_SEARCH_PATH);

        if (enumHandleStruct->hProviderDll == NULL)
        {
            status = GetLastError();

            //
            // This can happen under extreme low memory conditions.  The
            // loader can sometimes return ERROR_MOD_NOT_FOUND in this case.
            //
            MPR_LOG2(ERROR,
                     "MprOpenEnumConnect: LoadLibraryEx on %ws FAILED %d\n",
                     LastProvider()->DllName,
                     status);

            ASSERT(status == ERROR_NOT_ENOUGH_MEMORY || status == ERROR_MOD_NOT_FOUND);
            LastProvider()->CloseEnum(_ProviderEnumHandle);
            LocalFree(enumHandleStruct);
        }
        else
        {
            enumHandleStruct->pfEnumResource = LastProvider()->EnumResource;
            enumHandleStruct->pfCloseEnum    = LastProvider()->CloseEnum;
            enumHandleStruct->EnumHandle     = _ProviderEnumHandle;
            *_lphEnum = enumHandleStruct;
        }
    }

    return status;
}


DWORD
MprOpenRemember(
    IN  DWORD       dwType,
    OUT LPHANDLE    lphRemember
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    LPREMEMBER_HANDLE   rememberInfo;

    rememberInfo = (REMEMBER_HANDLE *) LocalAlloc(LPTR, sizeof(REMEMBER_HANDLE));

    if (rememberInfo == NULL) {
        MPR_LOG(ERROR,"MprOpenRemember:LocalAlloc Failed %d\n",GetLastError());
        return(WN_OUT_OF_MEMORY);
    }

    rememberInfo->Key = REMEMBER_KEY;
    rememberInfo->KeyIndex = 0;
    rememberInfo->ConnectionType = dwType;

    //
    // Open the key to the connection information in the current user
    // section of the registry.
    //
    // NOTE:  If this fails, we must assume that there is no connection
    //  information stored.  This is not an error condition.
    //  In this case, we store a NULL for the handle so that we know
    //  the situation.  Each time EnumResource is called, we can try
    //  to open the key again.
    //

    if (!MprOpenKey(
            HKEY_CURRENT_USER,
            CONNECTION_KEY_NAME,
            &(rememberInfo->ConnectKey),
            DA_READ)) {

        MPR_LOG(ERROR,"MprOpenRemember: MprOpenKey Failed\n",0);
        rememberInfo->ConnectKey = NULL;
    }

    *lphRemember = (HANDLE)rememberInfo;

    return(WN_SUCCESS);

}

DWORD
MprEnumRemembered(
    IN OUT  LPREMEMBER_HANDLE   RememberInfo,
    IN OUT  LPDWORD             NumEntries,
    IN OUT  LPBYTE              lpBuffer,
    IN OUT  LPDWORD             lpBufferSize
    )

/*++

Routine Description:


Arguments:

    RememberInfo - This is a pointer to REMEMBER_HANDLE data structure
        that contains the context information for this enumeration handle.

    NumEntries - On entry this points to the maximum number of entries
        that the user desires to receive.  On exit it points to the
        number of entries that were placed in the users buffer.

    lpBuffer - This is a pointer to the users buffer in which the
        enumeration data is to be placed.

    lpBufferSize - This is the size (in bytes) of the users buffer.


Return Value:


    WN_SUCCESS - The call was successful, and some entries were returned.
        However, there are still more entries to be enumerated.

    WN_NO_MORE_ENTRIES - This function has no data to return because
        there was no further connection information in the registry.

    WN_CONNOT_OPEN_PROFILE - This function could open a key to the
        connection information, but could not get any information about
        that key.

    WN_MORE_DATA - The caller's buffer was too small for even one entry.

Note:

History:
    Changed to return "status" instead of WN_SUCCESS

--*/
{
    DWORD       status = WN_SUCCESS ;
    LPTSTR              userName;
    NETRESOURCEW        netResource;
    LPBYTE              tempBufPtr;
    DWORD               bytesLeft;
    DWORD               entriesRead = 0;
    DWORD               numSubKeys;
    DWORD               maxSubKeyLen;
    DWORD               maxValueLen;

    if ((RememberInfo->ConnectKey == NULL) && (RememberInfo->KeyIndex == 0)) {

        //
        // If we failed to open the key at Open-time, attempt to open it
        // now.  This registry key is closed when the CloseEnum function is
        // called.
        //

        if (!MprOpenKey(
                HKEY_CURRENT_USER,
                CONNECTION_KEY_NAME,
                &(RememberInfo->ConnectKey),
                DA_READ)) {

            //
            // We couldn't open the key.  So we must assume that it doesn't
            // exist because there if no connection information stored.
            //

            MPR_LOG(ERROR,"MprEnumRemembered: MprOpenKey Failed\n",0);
            RememberInfo->ConnectKey = NULL;
            return(WN_NO_MORE_ENTRIES);
        }
    }

    //
    // Find out the size of the largest key name.
    //

    if(!MprGetKeyInfo(
        RememberInfo->ConnectKey,
        NULL,
        &numSubKeys,
        &maxSubKeyLen,
        NULL,
        &maxValueLen)) {

        MPR_LOG(ERROR,"MprEnumRemembered: MprGetKeyInfo Failed\n",0);
        return(WN_CANNOT_OPEN_PROFILE);
    }

    //
    // If we've already enumerated all the subkeys, there are no more entries.
    //
    if (RememberInfo->KeyIndex >= numSubKeys) {
        return(WN_NO_MORE_ENTRIES);
    }
    tempBufPtr = lpBuffer;
    bytesLeft  = ROUND_DOWN(*lpBufferSize);
    tempBufPtr = lpBuffer;

    netResource.lpComment     = NULL;
    netResource.dwScope       = RESOURCE_REMEMBERED;
    netResource.dwUsage       = 0;
    netResource.dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;

    //
    // MprReadConnectionInfo may access the providers
    //
    MprCheckProviders();

    CProviderSharedLock    PLock;

    while(
            (RememberInfo->KeyIndex < numSubKeys) &&
            (entriesRead < *NumEntries)           &&
            (bytesLeft > sizeof(NETRESOURCE))
         )
    {
        //
        // Get the connection info from the key and stuff it into
        // a NETRESOURCE structure.
        //
        BOOL fMatch = FALSE;
        DWORD ProviderFlags; // ignored
        DWORD DeferFlags;    // ignored

        if(!MprReadConnectionInfo(
                RememberInfo->ConnectKey,
                NULL,
                RememberInfo->KeyIndex,
                &ProviderFlags,
                &DeferFlags,
                &userName,
                &netResource,
                NULL,
                maxSubKeyLen)) {

            //
            // NOTE:  The ReadConnectionInfo call could return FALSE
            // if it failed in a memory allocation.
            //
            if (entriesRead == 0) {
                status = WN_NO_MORE_ENTRIES;
            }
            else {
                status = WN_SUCCESS;
            }
            break;
        }
        else
        {
            if ((netResource.dwType == RememberInfo->ConnectionType) ||
                (RememberInfo->ConnectionType == RESOURCETYPE_ANY))  {

                fMatch = TRUE;
            }
        }

        //
        // Copy the new netResource information into the user's
        // buffer.  Each time this function is called, the tempBufPtr
        // gets updated to point to the next free space in the user's
        // buffer.
        //
        if ( fMatch )
        {
            status = MprCopyResource(
                         &tempBufPtr,
                         &netResource,
                         &bytesLeft);

            if (status != WN_SUCCESS) {

                if (entriesRead == 0) {
                    *lpBufferSize = ROUND_UP(bytesLeft);
                    status = WN_MORE_DATA;
                }
                else {
                    status = WN_SUCCESS;
                }
                break;
            }
            entriesRead++;
        }

        //
        // Free the allocated memory resources.
        //
        LocalFree(netResource.lpLocalName);
        LocalFree(netResource.lpRemoteName);
        LocalFree(netResource.lpProvider);
        if (userName != NULL) {
            LocalFree(userName);
        }

        (RememberInfo->KeyIndex)++;
    }

    *NumEntries = entriesRead;

    return(status);

}


DWORD
MprMultiStrBuffSize(
    IN      LPTSTR      lpString1,
    IN      LPTSTR      lpString2,
    IN      LPTSTR      lpString3,
    IN      LPTSTR      lpString4,
    IN      LPTSTR      lpString5
    )

/*++

Routine Description:

    This function is a worker function that simply determines the total
    storage requirements needed by the passed set of strings.  Any of the
    strings maybe NULL in which case the string will be ignored.

    The NULL terminator is added into the total memory requirements.

Arguments:

    lpString1 -> 5  - Pointers to valid strings or NULL.

Return Value:

    The count of bytes required to store the passed strings.

Note:


--*/
{
    DWORD cbRequired = 0 ;

    if ( lpString1 != NULL )
    {
        cbRequired += (wcslen( lpString1 ) + 1) * sizeof(TCHAR);
    }

    if ( lpString2 != NULL )
    {
        cbRequired += (wcslen( lpString2 ) + 1) * sizeof(TCHAR) ;
    }

    if ( lpString3 != NULL )
    {
        cbRequired += (wcslen( lpString3 ) + 1) * sizeof(TCHAR) ;
    }

    if ( lpString4 != NULL )
    {
        cbRequired += (wcslen( lpString4 ) + 1) * sizeof(TCHAR) ;
    }

    if ( lpString5 != NULL )
    {
        cbRequired += (wcslen( lpString5 ) + 1) * sizeof(TCHAR) ;
    }

    return cbRequired ;
}

BOOL
MprNetIsAvailable(
    VOID)

/*++

Routine Description:

    This function checks if the net is available by calling the GetCaps
    of each provider to make sure it is started.

Arguments:

    none

Return Value:

    TRUE is yes, FALSE otherwise

Note:


--*/
{
    DWORD       status = WN_SUCCESS;
    LPDWORD     index;
    DWORD       indexArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders, i;
    LPPROVIDER  provider;
    DWORD       dwResult ;

    //
    // Find the list of providers to call for this request.
    // If there are no active providers, MprFindCallOrder returns
    // WN_NO_NETWORK.
    //
    index = indexArray;
    status = MprFindCallOrder(
                NULL,
                &index,
                &numProviders,
                NETWORK_TYPE);
    if (status != WN_SUCCESS)
        return(FALSE);

    //
    // Loop through the list of providers, making sure at least one
    // is started
    //
    ASSERT(MPR_IS_INITIALIZED(NETWORK));

    for (i=0; i<numProviders; i++)
    {
        //
        // Call the appropriate providers API entry point
        //
        provider = GlobalProviderInfo + index[i];

        if (provider->GetCaps != NULL)
        {
            dwResult = provider->GetCaps( WNNC_START );
            if (dwResult != 0)
            {
                if (index != indexArray)
                    LocalFree(index);
                return (TRUE) ;
            }
        }
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (index != indexArray)
        LocalFree(index);

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\fmt.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    fmt.cxx

Abstract:

    Contains the entry points for the Winnet Connection API supported by the
    Multi-Provider Router.
    Contains:
        WNetFormatNetworkNameW

Author:

    Bruce Forstall (brucefo)     15-Mar-1996

Environment:

    User Mode -Win32

Notes:

Revision History:

    15-Mar-1996     brucefo
        created from old MPRUI code

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/

//
// INCLUDES
//

#include "precomp.hxx"


/*******************************************************************

    NAME:       WNetFormatNetworkNameW

    SYNOPSIS:   Private Shell API for getting the formatted network name
                Unicode version

    ENTRY:      lpProvider - Name of network provider
                lpRemoteName - Remote name to format
                lpFormattedName - Buffer to receive name
                lpnLength - size of lpFormattedName buffer
                dwFlags - Formatting flags
                dwAveCharePerLine - Avg. characters per line

    NOTES:      Since this is an unpublished API, we don't do as much
                parameter validation as we would for a published API. Also,
                since the shell calls this thousands of times to display
                things in the Network Neighborhood, we optimize for speed
                of the success case.

    HISTORY:
        Johnl   29-Dec-1992     Created
        BruceFo 19-Mar-1996     Optimized for the shell

********************************************************************/

DWORD
WNetFormatNetworkNameW(
    LPCWSTR  lpProvider,
    LPCWSTR  lpRemoteName,
    LPWSTR   lpFormattedName,
    LPDWORD  lpnLength,         // In characters!
    DWORD    dwFlags,
    DWORD    dwAveCharPerLine
    )
{
    DWORD   status = WN_SUCCESS;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    __try
    {
        LPPROVIDER provider = MprFindProviderByName(lpProvider);
        if (NULL == provider)
        {
            status = WN_BAD_PROVIDER;
        }
        else
        {
            if (NULL == provider->FormatNetworkName)
            {
                status = WN_NOT_SUPPORTED;
            }
            else
            {
                //**************************************
                // Actual call to Provider.
                //**************************************
                status = provider->FormatNetworkName(
                                    (LPWSTR) lpRemoteName,      // cast away const
                                    (LPWSTR) lpFormattedName,   // cast away const
                                    lpnLength,
                                    dwFlags,
                                    dwAveCharPerLine);
            }
        }
    }
    __except(MPR_EXCEPTION_FILTER)
    {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG(ERROR,"WNetFormatNetworkName: "
                "Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\mpransi.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mpransi.cxx

Abstract:

    Contains Ansi Entry points for the MPR api.

Author:

    Dan Lafferty (danl)     20-Dec-1991

Environment:

    User Mode -Win32

Notes:

    I may want to add a buffer size parameter to ConvertToAnsi

Revision History:

    08-Aug-1996     anirudhs
        Major revision (simplification): Converted all remaining APIs to
        the smaller, faster interpreted scheme.  Added ANSI_API_ macros.
        Eliminated helper functions used by the old scheme.  These changes
        shrink this file by about 1400 lines.
    16-Feb-1996     anirudhs
        Added InputParmsToUnicode, OutputBufferToAnsi and helper functions.
        These form a smaller, faster, interpreted scheme for writing the
        Ansi APIs.  This scheme is smaller chiefly because it eliminates
        a very large amount of code duplication present in the previous
        scheme.  This also makes the Ansi APIs less bug-prone.  It is
        faster chiefly because intermediate storage is allocated with a
        single heap allocation per API, rather than several.  Also, the
        number of passes to scan and copy data is minimized.
    06-Oct-1995     anirudhs
        MprMakeUnicodeNetRes and related functions: Removed duplicated
        code for the string fields of the net resource; added code to
        iterate over the string fields instead.  Fixed access violation
        and memory leaks.
    24-Aug-1992     danl
        For WNetGetConnection & WNetGetUser, we allocate a buffer twice
        the size of the user buffer.  The data is placed in this buffer.
        Then we check to see if the data will fit in the user buffer
        after it is translated to Ansi.  The presence of DBSC characters
        may make it not fit.  In which case, we return the required number
        of bytes. This number assumes worse-case where all characters are
        DBCS characters.
    20-Dec-1991     danl
        created

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <string.h>     // strlen


//
// CONSTANTS
//

#define MAX_STRINGS_PER_API     6

//
// The following masks are used to indicate which fields in the NetResource
// structure are used by an API.
// The values must match the NRWField and NRAField arrays.
//
#define NETRESFIELD_LOCALNAME       0x00000001
#define NETRESFIELD_REMOTENAME      0x00000002
#define NETRESFIELD_COMMENT         0x00000004
#define NETRESFIELD_PROVIDER        0x00000008

#define NUMBER_OF_NETRESFIELD   4

//
// Combinations of the NETRESFIELD_ constants, for passing to InputParmsToUnicode.
//
#define NETRES_LRP  "\xB"   // local name, remote name, provider
#define NETRES_RP   "\xA"   // remote name, provider

//
// Alignment macros
// These macros assume that sizeof(WCHAR) and sizeof(DWORD) are powers of 2
//
#define ROUND_UP_TO_WCHAR(x)    (((DWORD)(x) + sizeof(WCHAR) - 1) & ~(sizeof(WCHAR) - 1))
#define ROUND_UP_TO_DWORD(x)    (((DWORD)(x) + sizeof(DWORD) - 1) & ~(sizeof(DWORD) - 1))
#define IS_WCHAR_ALIGNED(x)     (((ULONG_PTR)(x) & (sizeof(WCHAR) - 1)) == 0)
#define IS_DWORD_ALIGNED(x)     (((ULONG_PTR)(x) & (sizeof(DWORD) - 1)) == 0)

//
// Nearly every API ends this way
//
#define SET_AND_RETURN(status)                              \
    if (status != NO_ERROR)                                 \
    {                                                       \
        SetLastError(status);                               \
    }                                                       \
                                                            \
    return status;

//
// This is the general pattern of an Ansi wrapper for an API with no
// output Ansi parameters.  There are some exceptions.
//
#define ANSI_API_WITHOUT_ANSI_OUTPUT(NUMBER_OF_PARMS,       \
                                     ANSI_PARM_ASSIGNMENT,  \
                                     INSTRUCTION_STRING,    \
                                     UNICODE_CALL)          \
                                                            \
    DWORD           status;                                 \
    LPBYTE          tempBuffer = NULL;                      \
    ANSI_PARM       AParm[NUMBER_OF_PARMS];                 \
    UNICODE_PARM    UParm[NUMBER_OF_PARMS];                 \
                                                            \
    ANSI_PARM_ASSIGNMENT                                    \
                                                            \
    status = InputParmsToUnicode(INSTRUCTION_STRING, AParm, UParm, &tempBuffer);    \
                                                            \
    if (status == WN_SUCCESS)                               \
    {                                                       \
        status = UNICODE_CALL                               \
    }                                                       \
                                                            \
    LocalFree(tempBuffer);                                  \
                                                            \
    SET_AND_RETURN(status)



//
// This is the general pattern of an Ansi wrapper for an API that
// has output Ansi parameters.  There are some exceptions.
//
#define ANSI_API_WITH_ANSI_OUTPUT(NUMBER_OF_PARMS,          \
                                  ANSI_PARM_ASSIGNMENT,     \
                                  INSTRUCTION_STRING,       \
                                  UNICODE_CALL,             \
                                  OUTPUT_CALL)              \
                                                            \
    DWORD           status;                                 \
    LPBYTE          tempBuffer = NULL;                      \
    ANSI_PARM       AParm[NUMBER_OF_PARMS];                 \
    UNICODE_PARM    UParm[NUMBER_OF_PARMS];                 \
                                                            \
    ANSI_PARM_ASSIGNMENT                                    \
                                                            \
    status = InputParmsToUnicode(INSTRUCTION_STRING, AParm, UParm, &tempBuffer);    \
                                                            \
    if (status == WN_SUCCESS)                               \
    {                                                       \
        status = UNICODE_CALL                               \
                                                            \
        if (status == WN_SUCCESS)                           \
        {                                                   \
            status = OUTPUT_CALL                            \
        }                                                   \
    }                                                       \
                                                            \
    LocalFree(tempBuffer);                                  \
                                                            \
    SET_AND_RETURN(status)



//
// STRUCTURES
//

// These unions are defined so that parameters of various types can be passed
// to the generic routine InputParmsToUnicode.
// CODEWORK: By using these unions, we have lost type safety, and this could
// cause some bugs to go undetected.  To get back type safety, ANSI_PARM and
// UNICODE_PARM could be made into "smart union" classes, with overloaded
// assignment and cast operators that, in the checked build, remember the
// type of the data that they are assigned, and assert if they are used as
// any other type of data.
// This would also make the code neater by allowing initializers like
// ANSI_PARM AParm[] = { lpName, lpUserName, lpnLength };

typedef union
{
    DWORD           dword;
    LPCSTR          lpcstr;
    LPNETRESOURCEA  lpNetResA;
    LPVOID          lpvoid;
    LPDWORD         lpdword;
} ANSI_PARM;

typedef union
{
    DWORD           dword;
    LPBYTE          lpbyte;
    LPWSTR          lpwstr;
    LPNETRESOURCEW  lpNetResW;
} UNICODE_PARM;


class ANSI_OUT_BUFFER
{
private:
    const LPBYTE    _Start; // Pointer to start of buffer
    const DWORD     _Size;  // Total number of bytes in buffer
    DWORD           _Used;  // Number of bytes used (may exceed Size)

public:

            ANSI_OUT_BUFFER(LPBYTE Start, DWORD Size) :
                _Start(Start),
                _Size (Size),
                _Used (0)
                { }

    BYTE *  Next() const
        { return _Start + _Used; }

    BOOL    Overflow() const
        { return (_Used > _Size); }

    DWORD   FreeSpace() const
        { return (Overflow() ? 0 : _Size - _Used); }

    BOOL    HasRoomFor(DWORD Request) const
        { return (_Used + Request <= _Size); }

    void    AddUsed(DWORD Request)
        { _Used += Request; }

    DWORD   GetUsage() const
        { return _Used; }
};

//
// STATIC DATA
//

//
// These arrays of members are used to iterate through the string fields
// of a net resource.
// The order must match the NETRESFIELD_ definitions.
//

LPWSTR NETRESOURCEW::* const NRWField[NUMBER_OF_NETRESFIELD] =
{
    &NETRESOURCEW::lpLocalName,
    &NETRESOURCEW::lpRemoteName,
    &NETRESOURCEW::lpComment,
    &NETRESOURCEW::lpProvider
};

LPSTR NETRESOURCEA::* const NRAField[NUMBER_OF_NETRESFIELD] =
{
    &NETRESOURCEA::lpLocalName,
    &NETRESOURCEA::lpRemoteName,
    &NETRESOURCEA::lpComment,
    &NETRESOURCEA::lpProvider
};


//
// Local Functions
//

DWORD
InputParmsToUnicode(
    IN  LPCSTR          Instructions,
    IN  const ANSI_PARM InputParms[],
    OUT UNICODE_PARM    OutputParms[],
    OUT LPBYTE *        ppBuffer
    );

DWORD
StringParmToUnicodePass1(
    IN      LPCSTR          StringParm,
    OUT     PANSI_STRING    AnsiString,
    OUT     PUNICODE_STRING UnicodeString,
    IN OUT  PULONG          BufferOffset
    );

DWORD
StringParmToUnicodePass2(
    IN OUT  PANSI_STRING    AnsiString,
    OUT     PUNICODE_STRING UnicodeString,
    IN      const BYTE *    BufferStart,
    OUT     LPWSTR *        Result
    );

DWORD
OutputBufferToAnsi(
    IN  char        BufferFormat,
    IN  LPBYTE      SourceBuffer,
    OUT LPVOID      AnsiBuffer,
    IN OUT LPDWORD  pcbBufferSize
    );

DWORD
OutputStringToAnsi(
    IN  LPCWSTR     UnicodeIn,
    IN OUT ANSI_OUT_BUFFER * Buf
    );

DWORD
OutputStringToAnsiInPlace(
    IN  LPWSTR      UnicodeIn
    );

DWORD
OutputNetResourceToAnsi(
    IN  NETRESOURCEW *  lpNetResW,
    IN OUT ANSI_OUT_BUFFER * Buf
    );



DWORD
InputParmsToUnicode(
    IN  LPCSTR          Instructions,
    IN  const ANSI_PARM InputParms[],
    OUT UNICODE_PARM    OutputParms[],
    OUT LPBYTE *        ppBuffer
    )
/*++

Routine Description:

    This function converts the caller's input parameters to Unicode.
    If necessary, it allocates one temporary buffer in which it stores
    the intermediate Unicode parameters.  This minimizes the cost of
    calls to LocalAlloc.

Arguments:

    Instructions - A string of characters, roughly one for each member
        of the InputParms array, describing the action to be taken on each
        InputParms member.  Recognized values for the characters are:

        'S' (String) - InputParms member is an LPSTR to be converted to
            Unicode.  Store a pointer to the Unicode string in the
            corresponding OutputParms member.

        'N' (NetResource) - InputParms member is a LPNETRESOURCEA to be
            converted to a NETRESOURCEW.  The next character in Instructions
            is a bitmask of the NETRESFIELD_ constants, indicating which
            fields of the NETRESOURCEA to convert.  Store a pointer to the
            NETRESOURCEW in the corresponding OutputParms member.

        'B' (Buffer) - InputParms member (say InputParms[i]) is a pointer to
            an output buffer.  InputParms[i+1] is a pointer to a DWORD
            indicating the buffer size in bytes.  Probe the buffer for write.
            Allocate an area of double the size (i.e. of size
            (*InputParms[i+1])*sizeof(WCHAR)) in the intermediate buffer.
            Store a pointer to this area of the buffer in OutputParms[i].
            Store the size of this area in OutputParms[i+1].

            If InputParms[i] is NULL, store NULL in OutputParms[i], and
            ignore InputParms[i+1].  (In other words, the buffer pointer
            is optional; the size pointer is required if the buffer pointer
            is present and ignored if the buffer pointer is absent.)

        'Bs' (Buffer beginning with structure) - Same as 'B', but the first
            N bytes of the output buffer, where N is stored in InputParms[i+2],
            are supposed to hold a fixed-size structure, not strings.
            When calculating the size of the intermediate area, double the
            size of the rest of the buffer, but not the size of the structure.
            CODEWORK: Also verify that the buffer is DWORD-aligned?

    InputParms - An array of parameters to the Ansi API, described by the
        Instructions parameter.

    OutputParms - An array of the same size as InputParms, to hold the
        converted Unicode parameters.

    ppBuffer - A pointer to the intermediate buffer allocated by this
        function will be stored here.  It must be freed by a single call
        to LocalFree, regardless of the return value from this function.

Return Value:

    WN_SUCCESS

    WN_OUT_OF_MEMORY

    WN_BAD_POINTER

History:

    16-Feb-1996     anirudhs    Created.

Notes:

    The function works by making two passes through the Instructions string.
    In the first pass the string lengths are determined and saved, and the
    required size of the temporary buffer is calculated.  In the second
    pass the parameters are actually converted to Unicode.

--*/
{
    ANSI_STRING    AnsiStrings   [MAX_STRINGS_PER_API] = {0};
    UNICODE_STRING UnicodeStrings[MAX_STRINGS_PER_API] = {0};
    ULONG          Bytes = 0;       // Size of buffer to allocate
    DWORD          status = WN_SUCCESS;

    //
    // The caller must have initialized the buffer pointer to NULL, so
    // he can free the buffer even if this function fails.
    //
    ASSERT(*ppBuffer == NULL);

    __try
    {
        //
        // For two passes through Instructions
        //
        #define FIRST_PASS  (iPass == 0)
        for (ULONG iPass = 0; iPass <= 1; iPass++)
        {
            ULONG iString = 0;          // Index into AnsiStrings and UnicodeStrings

            //
            // For each character in Instructions
            //
            const CHAR * pInstruction;  // Pointer into Instructions
            ULONG iParm;                // Index into InputParms and OutputParms
            for (pInstruction = Instructions, iParm = 0;
                 *pInstruction;
                 pInstruction++, iParm++)
            {
                MPR_LOG(ANSI, "Processing instruction '%hc'\n", *pInstruction);

                switch (*pInstruction)
                {
                case 'B':
                    //
                    // The next 2 InputParms are a buffer pointer and size.
                    // Note that this code could cause an exception.
                    //
                    if (InputParms[iParm].lpvoid == NULL)
                    {
                        // A NULL pointer stays NULL; the size pointer is ignored
                        OutputParms[iParm].lpbyte = NULL;
                    }
                    else if (FIRST_PASS)
                    {
                        // Probe the original buffer
                        if (IS_BAD_BYTE_BUFFER(InputParms[iParm].lpvoid,
                                               InputParms[iParm+1].lpdword))
                        {
                            status = WN_BAD_POINTER;
                            __leave;
                        }

                        // Reserve the intermediate buffer area
                        Bytes = ROUND_UP_TO_DWORD(Bytes);
                        OutputParms[iParm].dword = Bytes;
                        OutputParms[iParm+1].dword =
                            (*InputParms[iParm+1].lpdword) * sizeof(WCHAR);

                        // Check for an optional 's' in Instructions
                        if (*(pInstruction+1) == 's')
                        {
                            // CODEWORK: Check for DWORD alignment on RISC?
                            // if (!IS_DWORD_ALIGNED(InputParms[iParm].lpvoid))
                            //  { status = WN_BAD_POINTER; __leave; }

                            // InputParms[iParm+2].dword holds the size of the
                            // fixed-length structure that will go at the start
                            // of the buffer.  We don't want to multiply its
                            // size by sizeof(WCHAR).
                            if (OutputParms[iParm+1].dword/sizeof(WCHAR) <
                                InputParms[iParm+2].dword)
                            {
                                OutputParms[iParm+1].dword /= sizeof(WCHAR);
                            }
                            else
                            {
                                OutputParms[iParm+1].dword -=
                                    InputParms[iParm+2].dword*(sizeof(WCHAR)-1);
                            }
                        }

                        Bytes += OutputParms[iParm+1].dword;
                    }
                    else // Non-NULL pointer, second pass
                    {
                        // Convert the offset to a pointer
                        OutputParms[iParm].lpbyte =
                            *ppBuffer + OutputParms[iParm].dword;
                        ASSERT(IS_DWORD_ALIGNED(OutputParms[iParm].lpbyte));
                    }

                    iParm++;        // iParm+1 was for the buffer size

                    if (*(pInstruction+1) == 's')
                    {
                        pInstruction++;
                        iParm++;    // iParm+2 was for the fixed structure size
                    }
                    break;

                case 'S':
                    //
                    // InputParm is a string to be converted.
                    // A NULL string stays NULL.
                    //
                    if (FIRST_PASS)
                    {
                        ASSERT(iString < MAX_STRINGS_PER_API);
                        Bytes = ROUND_UP_TO_WCHAR(Bytes);
                        status = StringParmToUnicodePass1(
                                        InputParms[iParm].lpcstr,
                                        &AnsiStrings[iString],
                                        &UnicodeStrings[iString],
                                        &Bytes);
                    }
                    else
                    {
                        status = StringParmToUnicodePass2(
                                        &AnsiStrings[iString],
                                        &UnicodeStrings[iString],
                                        *ppBuffer,
                                        &OutputParms[iParm].lpwstr);
                    }

                    if (status != WN_SUCCESS)
                    {
                        __leave;
                    }

                    iString++;
                    break;

                case 'N':
                    //
                    // InputParm is a NETRESOURCEA to be converted, and the
                    // next character in Instructions tells which of its string
                    // fields are to be converted.
                    // NULL strings remain NULL; ignored fields are copied
                    // unchanged.
                    //

                    pInstruction++;

                    if (InputParms[iParm].lpNetResA == NULL)
                    {
                        // A null netresource stays null
                        OutputParms[iParm].lpNetResW = NULL;
                        break;
                    }

                    {
                        // First deal with the fixed-size part of the structure.
                        const NETRESOURCEA *pNetResA =
                                    InputParms[iParm].lpNetResA;
                        NETRESOURCEW *pNetResW;

                        if (FIRST_PASS)
                        {
                            // Reserve space for the NETRESOURCEW
                            Bytes = ROUND_UP_TO_DWORD(Bytes);
                            OutputParms[iParm].dword = Bytes;
                            Bytes += sizeof(NETRESOURCEW);
                            ASSERT(IS_WCHAR_ALIGNED(Bytes));
                        }
                        else
                        {
                            // Copy fixed-size fields and NULL pointers
                            pNetResW = (NETRESOURCEW *)
                                        (*ppBuffer + OutputParms[iParm].dword);
                            ASSERT(IS_DWORD_ALIGNED(pNetResW));
                            RtlCopyMemory(pNetResW, pNetResA, sizeof(NETRESOURCEA));

                            OutputParms[iParm].lpNetResW = pNetResW;
                        }

                        // Next add each non-null string specified in the
                        // field mask.
                        CHAR FieldMask = *pInstruction;
                        ASSERT(FieldMask != 0);

                        for (ULONG iField = 0;
                             iField < NUMBER_OF_NETRESFIELD;
                             iField++)
                        {
                            if ((FieldMask >> iField) & 1)
                            {
                                if (FIRST_PASS)
                                {
                                    ASSERT(iString < MAX_STRINGS_PER_API);
                                    status = StringParmToUnicodePass1(
                                                pNetResA->*NRAField[iField],
                                                &AnsiStrings[iString],
                                                &UnicodeStrings[iString],
                                                &Bytes);
                                }
                                else
                                {
                                    status = StringParmToUnicodePass2(
                                                &AnsiStrings[iString],
                                                &UnicodeStrings[iString],
                                                *ppBuffer,
                                                &(pNetResW->*NRWField[iField]));
                                }

                                if (status != WN_SUCCESS)
                                {
                                    __leave;
                                }

                                iString++;
                            }
                        }
                    }
                    break;

                default:
                    ASSERT(0);
                }
            }

            if (FIRST_PASS)
            {
                //
                // Actually allocate the space for the Unicode parameters
                //
                *ppBuffer = (LPBYTE) LocalAlloc(0, Bytes);
                if (*ppBuffer == NULL)
                {
                    status = GetLastError();
                    MPR_LOG2(ERROR,
                             "InputParmsToUnicode: LocalAlloc for %lu bytes failed, %lu\n",
                             Bytes, status);
                    __leave;
                }
            }
        }
    }
    __except(MPR_EXCEPTION_FILTER)
    {
#if DBG == 1
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG(ERROR,"InputParmsToUnicode: Unexpected Exception %#lx\n",status);
        }
#endif
        status = WN_BAD_POINTER;
    }

    return status;
}



DWORD
StringParmToUnicodePass1 (
    IN      LPCSTR          StringParm,
    OUT     PANSI_STRING    AnsiString,
    OUT     PUNICODE_STRING UnicodeString,
    IN OUT  PULONG          BufferOffset
    )
/*++

Routine Description:

    Helper function for InputParmsToUnicode.

--*/
{
    RtlInitAnsiString( AnsiString, StringParm );

    if (StringParm == NULL)
    {
        return WN_SUCCESS;
    }

    // Save the offset to the memory for this Unicode string, to be converted
    // to a pointer after the memory is allocated
    ULONG UnicodeLength = RtlAnsiStringToUnicodeSize( AnsiString );
    if (UnicodeLength > MAXUSHORT)
    {
        MPR_LOG(ERROR,
                "Unicode size of Ansi string parm is %lu, exceeds MAXUSHORT\n",
                UnicodeLength);
        return WN_BAD_VALUE;
    }
    UnicodeString->Buffer = (LPWSTR) UlongToPtr(*BufferOffset);
    UnicodeString->MaximumLength = (USHORT) UnicodeLength;

    *BufferOffset = ROUND_UP_TO_DWORD(*BufferOffset + UnicodeLength);

    return WN_SUCCESS;
}


DWORD
StringParmToUnicodePass2 (
    IN OUT  PANSI_STRING    AnsiString,
    OUT     PUNICODE_STRING UnicodeString,
    IN      const BYTE *    BufferStart,
    OUT     LPWSTR *        Result
    )
/*++

Routine Description:

    Helper function for InputParmsToUnicode.

--*/
{
    if (AnsiString->Buffer == NULL)
    {
        *Result = NULL;
        // NOTE: the UnicodeString is not initialized in this case
        return WN_SUCCESS;
    }

    // Convert the previously stored buffer offset into a pointer
    UnicodeString->Buffer = (LPWSTR)
        (BufferStart + (ULONG_PTR) UnicodeString->Buffer);
    ASSERT(IS_WCHAR_ALIGNED(UnicodeString->Buffer));

    // Convert the string to Unicode
    NTSTATUS ntstatus =
        RtlAnsiStringToUnicodeString(UnicodeString, AnsiString, FALSE);
    if (!NT_SUCCESS(ntstatus))
    {
        MPR_LOG(ERROR, "RtlAnsiStringToUnicodeString failed %#lx\n", ntstatus);
        return RtlNtStatusToDosError(ntstatus);
    }
    *Result = UnicodeString->Buffer;

    return WN_SUCCESS;
}



DWORD
OutputBufferToAnsi(
    IN  char        BufferFormat,
    IN  LPBYTE      SourceBuffer,
    OUT LPVOID      AnsiBuffer,
    IN OUT LPDWORD  pcbBufferSize
    )
/*++

Routine Description:

    This function converts the data in the result buffer that was returned
    from a Unicode API into Ansi and stores it in the Ansi caller's result
    buffer. If the caller's buffer isn't large enough it saves the required
    size in *pcbBufferSize and returns WN_MORE_DATA.

    Nearly all the WNet APIs that have output buffers have only a single
    field in the output buffer, so this API takes only a single character,
    rather than a string, for the buffer format.  APIs with more complicated
    output buffers should handle the complexity themselves, by directly
    calling the functions that this function calls.

Arguments:

    BufferFormat - A character indicating the format of the SourceBuffer
        field.  Recognized values are:

        'S' - SourceBuffer contains a Unicode string.  Convert it to Ansi
            and store the Ansi version in AnsiBuffer.

        'N' - SourceBuffer contains a NETRESOURCEW with its associated
            strings.  Convert it to Ansi and store the Ansi version in
            AnsiBuffer.

    SourceBuffer - The output buffer returned from a Unicode API.
        This must not be NULL.

    AnsiBuffer - The output buffer that the caller of the Ansi API supplied.
        This must not be NULL.

    pcbBufferSize - On entry, the size of AnsiBuffer in bytes.  If the
        function returns WN_MORE_DATA, the required size is stored here;
        otherwise this is unmodified.
        This must not be NULL (must be a writeable DWORD pointer).

Return Value:

    WN_SUCCESS - successful.

    WN_MORE_DATA - The buffer specified by AnsiBuffer and pcbBufferSize was
        not large enough to hold the converted data from SourceBuffer.  In
        this case the required buffer size (in bytes) is written to
        *pcbBufferSize.  The contents of AnsiBuffer are undefined (it will
        be partially filled).

History:

    16-Feb-1996     anirudhs    Created.

Notes:

--*/
{
    // Doesn't handle optional parameters for now
    ASSERT(SourceBuffer != NULL &&
           AnsiBuffer != NULL &&
           pcbBufferSize != NULL);

    ANSI_OUT_BUFFER Buf((LPBYTE) AnsiBuffer, *pcbBufferSize);
    DWORD status;

    switch (BufferFormat)
    {
    case 'S':
        status = OutputStringToAnsi((LPCWSTR) SourceBuffer, &Buf);
        break;

    case 'N':
        status = OutputNetResourceToAnsi((NETRESOURCEW *) SourceBuffer, &Buf);
        break;

    default:
        ASSERT(0);
        return ERROR_INVALID_LEVEL;
    }

    //
    // Map the results to the conventions followed by the WNet APIs
    //
    if (status == WN_SUCCESS)
    {
        if (Buf.Overflow())
        {
            *pcbBufferSize = Buf.GetUsage();
            status = WN_MORE_DATA;
        }
    }
    else
    {
        ASSERT(status != WN_MORE_DATA);
    }

    return status;
}



DWORD
OutputStringToAnsi(
    IN  LPCWSTR     UnicodeIn,
    IN OUT ANSI_OUT_BUFFER * Buf
    )
/*++

Routine Description:

    This function converts a Unicode string to Ansi and calculates the number
    of bytes required to store it.  If the caller passes a buffer that has
    enough remaining free space, it stores the Ansi data in the buffer.
    Otherwise it just increments the buffer's space usage by the number of
    bytes required.

Arguments:

    UnicodeIn - A Unicode string to be converted to Ansi.
        This must not be NULL.

    Buf - A structure whose elements are interpreted as follows:

        _Start - Start address of a buffer to contain the Ansi data.
            This buffer must be writeable, or an exception will occur.

        _Size - The total size of the buffer for the Ansi data.

        _Used - On entry, the number of bytes in the buffer that have
            already been used.  The function will begin writing data at
            _Start + _Used and will never write past the total size
            specified by _Size.  If there is not enough room left
            in the buffer it will be partially filled or unmodified.
            On a successful return, _Used is incremented by the number
            of bytes that would be required to store the converted Ansi
            data, whether or not it was actually stored in the buffer.
            (This is done because the WNet APIs need to return the
            required buffer size if the caller's buffer was too small.)

        The use of this structure simplifies the writing of routines that
        use this function and need to convert multiple fields of Unicode
        data.  Callers that need to convert only a single field can use
        OutputBufferToAnsi.

Return Value:

    WN_SUCCESS - successful.  The Ansi data was written to the buffer if
        Buf->_Used <= Buf->_Size.  Otherwise, Buf->_Used was incremented
        without completely writing the data.

    Note that WN_MORE_DATA is never returned.

History:

    16-Feb-1996     anirudhs    Created.

Notes:

--*/
{
    NTSTATUS        ntStatus;
    UNICODE_STRING  unicodeString;
    ANSI_STRING     ansiString;

    ASSERT(UnicodeIn != NULL);      // Doesn't handle optional parameters for now

    //
    // Initialize the string structures
    //
    RtlInitUnicodeString(&unicodeString, UnicodeIn);

    ansiString.Buffer = (PCHAR) Buf->Next();
    ansiString.MaximumLength = (Buf->FreeSpace() > MAXUSHORT ?
                                        MAXUSHORT :
                                        (USHORT) Buf->FreeSpace()
                               );

    //
    // Call the conversion function
    //
    ntStatus = RtlUnicodeStringToAnsiString (
                &ansiString,        // Destination
                &unicodeString,     // Source
                (BOOLEAN)FALSE);    // Don't allocate the destination

    if (NT_SUCCESS(ntStatus))
    {
        // Add on the buffer space we used
        Buf->AddUsed(ansiString.Length + 1);
        ASSERT(! Buf->Overflow());
        return WN_SUCCESS;
    }
    else if (ntStatus == STATUS_BUFFER_OVERFLOW)
    {
        // We couldn't fit the string in the buffer, but still figure out
        // how much buffer space we would have used if we could
        Buf->AddUsed(RtlUnicodeStringToAnsiSize(&unicodeString));
        ASSERT(Buf->Overflow());
        return WN_SUCCESS;
    }
    else
    {
        MPR_LOG(ERROR, "RtlUnicodeStringToAnsiString failed %#lx\n", ntStatus);
        DWORD status = RtlNtStatusToDosError(ntStatus);
        ASSERT(status != WN_MORE_DATA);
        return status;
    }
}



DWORD
OutputNetResourceToAnsi(
    IN  NETRESOURCEW *  lpNetResW,
    IN OUT ANSI_OUT_BUFFER * Buf
    )
/*++

Routine Description:

    This function converts a NETRESOURCEW and its associated Unicode strings
    to Ansi and returns the number of bytes required to store them.  If the
    caller passes a buffer that has enough remaining free space, it stores
    the Ansi data in the buffer.

Arguments:

    lpNetResW - A Unicode net resource to be converted to Ansi.
        This must not be NULL.

    Buf - same as OutputStringToAnsi.

Return Value:

    Same as OutputStringToAnsi.

History:

    16-Feb-1996     anirudhs    Created.

Notes:

--*/
{
    //
    // Copy the fixed-size part of the structure, including NULL pointers,
    // and/or add on the buffer space it would take
    //
    LPNETRESOURCEA lpNetResA = (LPNETRESOURCEA) Buf->Next();
    if (Buf->HasRoomFor(sizeof(NETRESOURCEA)))
    {
        RtlCopyMemory(lpNetResA, lpNetResW, sizeof(NETRESOURCEA));
    }
    Buf->AddUsed(sizeof(NETRESOURCEA));

    //
    // Copy each non-NULL string field,
    // and/or add on the buffer space it would take
    //
    for (DWORD iField = 0;
         iField < NUMBER_OF_NETRESFIELD;
         iField++)
    {
        if (lpNetResW->*NRWField[iField] != NULL)
        {
            // Save a pointer to the Ansi string we are about to create
            // in the Ansi net resource
            lpNetResA->*NRAField[iField] = (LPSTR) Buf->Next();

            // Convert the string
            DWORD status = OutputStringToAnsi(lpNetResW->*NRWField[iField], Buf);
            if (status != WN_SUCCESS)
            {
                ASSERT(status != WN_MORE_DATA);
                return status;
            }
        }
    }

    return WN_SUCCESS;
}



DWORD
OutputStringToAnsiInPlace(
    IN  LPWSTR      UnicodeIn
    )
/*++

Routine Description:

    This function converts a Unicode string to Ansi in place.
    This is the same as OutputStringToAnsi, optimized for in-place conversions.

Arguments:

    UnicodeIn - A Unicode string to be converted to Ansi.
        This may be NULL, in which case the function does nothing.

Return Value:

    WN_SUCCESS - successful.

    Note that WN_MORE_DATA is never returned.

History:

    08-Aug-1996     anirudhs    Created.

Notes:

--*/
{
    NTSTATUS        ntStatus;
    UNICODE_STRING  unicodeString;
    ANSI_STRING     ansiString;

    if (UnicodeIn == NULL)
    {
        return WN_SUCCESS;
    }

    //
    // Initialize the string structures
    //
    RtlInitUnicodeString(&unicodeString, UnicodeIn);

    ansiString.Buffer = (PCHAR) UnicodeIn;
    ansiString.MaximumLength = unicodeString.MaximumLength;

    //
    // Call the conversion function
    //
    ntStatus = RtlUnicodeStringToAnsiString (
                &ansiString,        // Destination
                &unicodeString,     // Source
                (BOOLEAN)FALSE);    // Don't allocate the destination

    ASSERT(ntStatus != STATUS_BUFFER_OVERFLOW);

    if (NT_SUCCESS(ntStatus))
    {
        return WN_SUCCESS;
    }
    else
    {
        MPR_LOG(ERROR, "RtlUnicodeStringToAnsiString failed %#lx\n", ntStatus);
        DWORD status = RtlNtStatusToDosError(ntStatus);
        ASSERT(status != WN_MORE_DATA);
        return status;
    }
}


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


DWORD APIENTRY
WNetGetNetworkInformationA(
    IN  LPCSTR              lpProvider,
    IN OUT LPNETINFOSTRUCT  lpNetInfoStruct
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpProvider; ,
        "S",
        WNetGetNetworkInformationW(UParm[0].lpwstr, lpNetInfoStruct);
        )
}



DWORD APIENTRY
WNetGetProviderNameA(
    IN  DWORD       dwNetType,
    OUT LPSTR       lpProviderName,
    IN OUT LPDWORD  lpBufferSize
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITH_ANSI_OUTPUT(
        2,
            AParm[0].lpvoid  = lpProviderName;
            AParm[1].lpdword = lpBufferSize; ,
        "B",
        WNetGetProviderNameW(dwNetType, UParm[0].lpwstr, lpBufferSize); ,
        OutputBufferToAnsi('S', UParm[0].lpbyte, lpProviderName, lpBufferSize);
        )
}


DWORD
WNetGetProviderTypeA(
    IN  LPCSTR          lpProvider,
    OUT LPDWORD         lpdwNetType
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpProvider; ,
        "S",
        WNetGetProviderTypeW(UParm[0].lpwstr, lpdwNetType);
        )
}



DWORD APIENTRY
WNetAddConnectionA (
     IN LPCSTR   lpRemoteName,
     IN LPCSTR   lpPassword,
     IN LPCSTR   lpLocalName
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[3];
    UNICODE_PARM    UParm[3];

    AParm[0].lpcstr     = lpRemoteName;
    AParm[1].lpcstr     = lpPassword;
    AParm[2].lpcstr     = lpLocalName;

    UParm[1].lpwstr     = NULL;

    status = InputParmsToUnicode("SSS", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        status = WNetAddConnectionW(
                        UParm[0].lpwstr,
                        UParm[1].lpwstr,
                        UParm[2].lpwstr
                        );
    }

    MprClearString(UParm[1].lpwstr);

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}

DWORD APIENTRY
WNetAddConnection2A (
     IN LPNETRESOURCEA   lpNetResource,
     IN LPCSTR           lpPassword,
     IN LPCSTR           lpUserName,
     IN DWORD            dwFlags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return (WNetUseConnectionA(
                NULL,
                lpNetResource,
                lpPassword,
                lpUserName,
                dwFlags,
                NULL,
                NULL,
                NULL
                ));
}

DWORD APIENTRY
WNetAddConnection3A (
     IN HWND             hwndOwner,
     IN LPNETRESOURCEA   lpNetResource,
     IN LPCSTR           lpPassword,
     IN LPCSTR           lpUserName,
     IN DWORD            dwFlags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return (WNetUseConnectionA(
                hwndOwner,
                lpNetResource,
                lpPassword,
                lpUserName,
                dwFlags,
                NULL,
                NULL,
                NULL
                ));
}



DWORD APIENTRY
WNetUseConnectionA(
    IN  HWND            hwndOwner,
    IN  LPNETRESOURCEA  lpNetResource,
    IN  LPCSTR          lpPassword,
    IN  LPCSTR          lpUserID,
    IN  DWORD           dwFlags,
    OUT LPSTR           lpAccessName OPTIONAL,
    IN OUT LPDWORD      lpBufferSize OPTIONAL,  // Optional only if lpAccessName absent
    OUT LPDWORD         lpResult
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[5];
    UNICODE_PARM    UParm[5];

    AParm[0].lpNetResA  = lpNetResource;
    AParm[1].lpcstr     = lpPassword;
    AParm[2].lpcstr     = lpUserID;
    AParm[3].lpvoid     = lpAccessName;
    AParm[4].lpdword    = lpBufferSize;

    UParm[1].lpwstr     = NULL;

    status = InputParmsToUnicode("N" NETRES_LRP "SSB", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        status = WNetUseConnectionW(
                        hwndOwner,
                        UParm[0].lpNetResW,
                        UParm[1].lpwstr,
                        UParm[2].lpwstr,
                        dwFlags,
                        UParm[3].lpwstr,
                        lpBufferSize,
                        lpResult
                        );

        if (status == WN_SUCCESS)
        {
            if (ARGUMENT_PRESENT(lpAccessName))
            {
                //
                // Note: At this point, we know that lpBufferSize is writeable.
                //
                status = OutputBufferToAnsi(
                            'S', UParm[3].lpbyte, lpAccessName, lpBufferSize);
            }
        }
    }

    MprClearString(UParm[1].lpwstr);

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}



DWORD APIENTRY
WNetCancelConnection2A (
    IN LPCSTR   lpName,
    IN DWORD    dwFlags,
    IN BOOL     fForce
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpName; ,
        "S",
        WNetCancelConnection2W(UParm[0].lpwstr, dwFlags, fForce);
        )
}

DWORD APIENTRY
WNetCancelConnectionA (
    IN LPCSTR   lpName,
    IN BOOL     fForce
    )

/*++

Routine Description:

    This routine is provided for Win 3.1 compatibility.

Arguments:

Return Value:

--*/
{
    return WNetCancelConnection2A( lpName, CONNECT_UPDATE_PROFILE, fForce ) ;
}

DWORD APIENTRY
WNetGetConnectionA (
    IN      LPCSTR   lpLocalName,
    OUT     LPSTR    lpRemoteName,
    IN OUT  LPDWORD  lpnLength
    )

/*++

Routine Description:

    This function returns the RemoteName that is associated with a
    LocalName (or drive letter).

Arguments:

    lpLocalName - This is a pointer to the string that contains the LocalName.

    lpRemoteName - This is a pointer to the buffer that will contain the
        RemoteName string upon exit.

    lpnLength -  This is a pointer to the size (in characters) of the buffer
        that is to be filled in with the RemoteName string.  It is assumed
        upon entry, that characters are all single byte characters.
        If the buffer is too small and WN_MORE_DATA is returned, the data
        at this location contains buffer size information - in number of
        characters (bytes).  This information indicates how large the buffer
        should be (in bytes) to obtain the remote name.  It is assumed that
        all Unicode characteres translate into DBCS characters.


Return Value:


--*/
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[3];
    UNICODE_PARM    UParm[3];

    AParm[0].lpcstr  = lpLocalName;
    AParm[1].lpvoid  = lpRemoteName;
    AParm[2].lpdword = lpnLength;

    status = InputParmsToUnicode("SB", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        status = WNetGetConnectionW(UParm[0].lpwstr, UParm[1].lpwstr, lpnLength);

        if (status == WN_SUCCESS || status == WN_CONNECTION_CLOSED)
        {
            DWORD tempStatus =
                OutputBufferToAnsi('S', UParm[1].lpbyte, lpRemoteName, lpnLength);
            if (tempStatus != WN_SUCCESS)
            {
                status = tempStatus;
            }
        }
    }

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}

DWORD APIENTRY
WNetGetConnection2A (
    IN      LPSTR    lpLocalName,
    OUT     LPVOID   lpBuffer,
    IN OUT  LPDWORD  lpnLength
    )

/*++

Routine Description:

    This function returns the RemoteName that is associated with a
    LocalName (or drive letter) and the provider name that made the
    connection.

Arguments:

    lpLocalName - This is a pointer to the string that contains the LocalName.

    lpBuffer - This is a pointer to the buffer that will contain the
    WNET_CONNECTIONINFO structure upon exit.

    lpnLength -  This is a pointer to the size (in characters) of the buffer
        that is to be filled in with the RemoteName string.  It is assumed
        upon entry, that characters are all single byte characters.
        If the buffer is too small and WN_MORE_DATA is returned, the data
        at this location contains buffer size information - in number of
        characters (bytes).  This information indicates how large the buffer
        should be (in bytes) to obtain the remote name.  It is assumed that
        all Unicode characters translate into DBCS characters.


Return Value:


--*/
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[4];
    UNICODE_PARM    UParm[4];

    AParm[0].lpcstr  = lpLocalName;
    AParm[1].lpvoid  = lpBuffer;
    AParm[2].lpdword = lpnLength;
    AParm[3].dword   = sizeof(WNET_CONNECTIONINFO);

    status = InputParmsToUnicode("SBs", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        status = WNetGetConnection2W(
                    UParm[0].lpwstr,
                    UParm[1].lpbyte,
                    &UParm[2].dword
                    );

        if (status == WN_SUCCESS || status == WN_CONNECTION_CLOSED)
        {
            ANSI_OUT_BUFFER Buf((LPBYTE) lpBuffer, *lpnLength);

            //
            // Copy the fixed-size part of the structure, including NULL pointers,
            // and/or add on the buffer space it would take
            //
            WNET_CONNECTIONINFOW * pconninfow = (WNET_CONNECTIONINFOW *) UParm[1].lpbyte;
            WNET_CONNECTIONINFOA * pconninfoa = (WNET_CONNECTIONINFOA *) Buf.Next();
            ASSERT(Buf.HasRoomFor(sizeof(WNET_CONNECTIONINFOA)));
            RtlCopyMemory(pconninfoa, pconninfow, sizeof(WNET_CONNECTIONINFOA));
            Buf.AddUsed(sizeof(WNET_CONNECTIONINFOA));

            //
            // Copy each non-NULL string field,
            // and/or add on the buffer space it would take
            //
            DWORD tempStatus = WN_SUCCESS;
            if (pconninfow->lpRemoteName != NULL)
            {
                pconninfoa->lpRemoteName = (LPSTR) Buf.Next();
                tempStatus = OutputStringToAnsi(pconninfow->lpRemoteName, &Buf);
            }

            if (tempStatus == WN_SUCCESS &&
                pconninfow->lpProvider != NULL)
            {
                pconninfoa->lpProvider = (LPSTR) Buf.Next();
                tempStatus = OutputStringToAnsi(pconninfow->lpProvider, &Buf);
            }

            //
            // Map the results to WNet API conventions
            //
            if (tempStatus != WN_SUCCESS)
            {
                status = tempStatus;
            }
            else if (Buf.Overflow())
            {
                *lpnLength = Buf.GetUsage();
                status = WN_MORE_DATA;
            }
        }
        else if (status == WN_MORE_DATA)
        {
            //
            // Adjust the required buffer size for ansi/DBCS.
            //
            // We don't know how many characters will be required so we have to
            // assume the worst case (all characters are DBCS characters).
            //
            *lpnLength = UParm[2].dword;
        }
    }

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}



DWORD APIENTRY
WNetGetConnection3A(
    IN  LPCSTR      lpLocalName,
    IN  LPCSTR      lpProviderName OPTIONAL,
    IN  DWORD       dwLevel,
    OUT LPVOID      lpBuffer,
    IN OUT LPDWORD  lpBufferSize    // in bytes
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    // For the only supported level, the output buffer is a DWORD, so no
    // conversion of the output buffer is necessary
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        2,
            AParm[0].lpcstr = lpLocalName;
            AParm[1].lpcstr = lpProviderName; ,
        "SS",
        WNetGetConnection3W(
            UParm[0].lpwstr,
            UParm[1].lpwstr,
            dwLevel,
            lpBuffer,
            lpBufferSize
            );
        )
}



DWORD
WNetGetUniversalNameA (
    IN      LPCSTR  lpLocalPath,
    IN      DWORD   dwInfoLevel,
    OUT     LPVOID  lpBuffer,
    IN OUT  LPDWORD lpBufferSize
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[4];
    UNICODE_PARM    UParm[4];

    DWORD           dwStructSize =
        (dwInfoLevel == UNIVERSAL_NAME_INFO_LEVEL) ? sizeof(UNIVERSAL_NAME_INFO) :
        (dwInfoLevel == REMOTE_NAME_INFO_LEVEL)    ? sizeof(REMOTE_NAME_INFO)    :
        0;

    AParm[0].lpcstr  = lpLocalPath;
    AParm[1].lpvoid  = lpBuffer;
    AParm[2].lpdword = lpBufferSize;
    AParm[3].dword   = dwStructSize;

    status = InputParmsToUnicode("SBs", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        status = WNetGetUniversalNameW(
                    UParm[0].lpwstr,
                    dwInfoLevel,
                    UParm[1].lpbyte,
                    &UParm[2].dword
                    );

        if (status == WN_SUCCESS || status == WN_CONNECTION_CLOSED)
        {
            DWORD tempStatus = WN_SUCCESS;
            ANSI_OUT_BUFFER Buf((LPBYTE) lpBuffer, *lpBufferSize);

            //
            // Copy the fixed-size part of the structure, including NULL pointers,
            // and/or add on the buffer space it would take
            //
            ASSERT(Buf.HasRoomFor(dwStructSize));
            RtlCopyMemory(Buf.Next(), UParm[1].lpbyte, dwStructSize);

            if (dwInfoLevel == REMOTE_NAME_INFO_LEVEL)
            {
                // -----------------------------------
                // REMOTE_NAME_INFO_LEVEL
                // -----------------------------------

                LPREMOTE_NAME_INFOW pRemoteNameInfoW =
                                    (LPREMOTE_NAME_INFOW) UParm[1].lpbyte;
                LPREMOTE_NAME_INFOA pRemoteNameInfoA =
                                    (LPREMOTE_NAME_INFOA) Buf.Next();
                Buf.AddUsed(dwStructSize);

                //
                // Convert the returned Unicode string and string size back to
                // ansi.
                //
                if (pRemoteNameInfoW->lpUniversalName != NULL)
                {
                    pRemoteNameInfoA->lpUniversalName = (LPSTR) Buf.Next();
                    tempStatus = OutputStringToAnsi(pRemoteNameInfoW->lpUniversalName, &Buf);
                }

                if (tempStatus == WN_SUCCESS && pRemoteNameInfoW->lpConnectionName != NULL)
                {
                    pRemoteNameInfoA->lpConnectionName = (LPSTR) Buf.Next();
                    tempStatus = OutputStringToAnsi(pRemoteNameInfoW->lpConnectionName, &Buf);
                }

                if (tempStatus == WN_SUCCESS && pRemoteNameInfoW->lpRemainingPath != NULL)
                {
                    pRemoteNameInfoA->lpRemainingPath = (LPSTR) Buf.Next();
                    tempStatus = OutputStringToAnsi(pRemoteNameInfoW->lpRemainingPath, &Buf);
                }
            }
            else
            {
                // -----------------------------------
                // Must be UNIVERSAL_NAME_INFO_LEVEL
                // -----------------------------------
                ASSERT(dwInfoLevel == UNIVERSAL_NAME_INFO_LEVEL);

                LPUNIVERSAL_NAME_INFOW pUniNameInfoW =
                                    (LPUNIVERSAL_NAME_INFOW) UParm[1].lpbyte;
                LPUNIVERSAL_NAME_INFOA pUniNameInfoA =
                                    (LPUNIVERSAL_NAME_INFOA) Buf.Next();
                Buf.AddUsed(dwStructSize);

                //
                // Convert the returned Unicode string and string size back to
                // ansi.
                //
                if (pUniNameInfoW->lpUniversalName != NULL)
                {
                    pUniNameInfoA->lpUniversalName = (LPSTR) Buf.Next();
                    tempStatus = OutputStringToAnsi(pUniNameInfoW->lpUniversalName, &Buf);
                }
            }

            //
            // Map the results to WNet API conventions
            //
            if (tempStatus != WN_SUCCESS)
            {
                status = tempStatus;
            }
            else if (Buf.Overflow())
            {
                *lpBufferSize = Buf.GetUsage();
                status = WN_MORE_DATA;
            }
        }
        else if (status == WN_MORE_DATA)
        {
            //
            // Adjust the required buffer size for ansi/DBCS.
            //
            // We don't know how many characters will be required so we have to
            // assume the worst case (all characters are DBCS characters).
            //
            *lpBufferSize = UParm[2].dword;
        }
    }

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}



DWORD APIENTRY
WNetSetConnectionA(
    IN  LPCSTR    lpName,
    IN  DWORD     dwProperties,
    IN OUT LPVOID pvValues
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    //
    // pvValues points to various types of structures depending on the value
    // of dwProperties.
    // Currently there is only one valid value for dwProperties, and its
    // corresponding pvValues points to a DWORD, so we don't need to worry
    // about converting pvValues to Unicode.
    //
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpName; ,
        "S",
        WNetSetConnectionW(UParm[0].lpwstr, dwProperties, pvValues);
        )
}



DWORD APIENTRY
MultinetGetConnectionPerformanceA(
    IN  LPNETRESOURCEA          lpNetResource,
    OUT LPNETCONNECTINFOSTRUCT  lpNetConnectInfoStruct
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpNetResA = lpNetResource; ,
        "N" NETRES_LRP,
        MultinetGetConnectionPerformanceW(
                        UParm[0].lpNetResW,
                        lpNetConnectInfoStruct);
        )
}



DWORD APIENTRY
WNetOpenEnumA (
    IN  DWORD           dwScope,
    IN  DWORD           dwType,
    IN  DWORD           dwUsage,
    IN  LPNETRESOURCEA  lpNetResource,
    OUT LPHANDLE        lphEnum
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpNetResA = lpNetResource; ,
        "N" NETRES_RP,
        WNetOpenEnumW(dwScope, dwType, dwUsage, UParm[0].lpNetResW, lphEnum);
        )
}

DWORD APIENTRY
WNetEnumResourceA (
    IN      HANDLE  hEnum,
    IN OUT  LPDWORD lpcCount,
    OUT     LPVOID  lpBuffer,
    IN OUT  LPDWORD lpBufferSize
    )

/*++

Routine Description:

    This function calls the unicode version of WNetEnumResource and
    then converts the strings that are returned into ansi strings.
    Since the user provided buffer is used to contain the unicode strings,
    that buffer should be allocated with the size of unicode strings
    in mind.

Arguments:


Return Value:


--*/
{
    DWORD status = WNetEnumResourceW(
                        hEnum,
                        lpcCount,
                        lpBuffer,
                        lpBufferSize);

    if (status == WN_SUCCESS)
    {
        //
        // The output buffer contains an array of NETRESOURCEWs, plus strings.
        // Convert the Unicode strings pointed to by these NETRESOURCEWs
        // to Ansi strings, in place.
        //
        LPNETRESOURCEW lpNetResW = (LPNETRESOURCEW) lpBuffer;
        for (DWORD i=0; i<*lpcCount; i++, lpNetResW++)
        {
            for (UINT iField = 0;
                 iField < NUMBER_OF_NETRESFIELD;
                 iField++)
            {
                if (lpNetResW->*NRWField[iField] != NULL)
                {
                    status = OutputStringToAnsiInPlace(
                                    lpNetResW->*NRWField[iField]);

                    if (status != WN_SUCCESS)
                    {
                        MPR_LOG0(ERROR,"WNetEnumResourceA: Couldn't convert all structs\n");
                        status = WN_SUCCESS;
                        *lpcCount = i;
                        break; // breaks out of both loops
                    }
                }
            }
        }
    }

    SET_AND_RETURN(status)
}



DWORD APIENTRY
WNetGetResourceInformationA(
    IN      LPNETRESOURCEA  lpNetResource,
    OUT     LPVOID          lpBuffer,
    IN OUT  LPDWORD         lpBufferSize,
    OUT     LPSTR *         lplpSystem
    )
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[4];
    UNICODE_PARM    UParm[4];

    AParm[0].lpNetResA  = lpNetResource;
    AParm[1].lpvoid     = lpBuffer;
    AParm[2].lpdword    = lpBufferSize;
    AParm[3].dword      = sizeof(NETRESOURCE);

    status = InputParmsToUnicode("N" NETRES_RP "Bs", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        status = WNetGetResourceInformationW(
                    UParm[0].lpNetResW,
                    UParm[1].lpbyte,
                    &UParm[2].dword,
                    (LPWSTR *) lplpSystem
                    );

        if (status == WN_SUCCESS)
        {
            ANSI_OUT_BUFFER Buf((LPBYTE) lpBuffer, *lpBufferSize);

            //
            // Convert the Unicode netresource returned to Ansi
            //
            status = OutputNetResourceToAnsi(UParm[1].lpNetResW, &Buf);

            if (status == WN_SUCCESS)
            {
                //
                // Convert the Unicode string (*lplpSystem) returned to Ansi
                //
                LPWSTR lpSystemW = * (LPWSTR *) lplpSystem;
                if (lpSystemW != NULL)
                {
                    *lplpSystem = (LPSTR) Buf.Next();
                    status = OutputStringToAnsi(lpSystemW, &Buf);
                }
            }

            //
            // Map the results to WNet API conventions
            //
            if (status == WN_SUCCESS && Buf.Overflow())
            {
                *lpBufferSize = Buf.GetUsage();
                status = WN_MORE_DATA;
            }
        }
        else if (status == WN_MORE_DATA)
        {
            //
            // Adjust the required buffer size for ansi/DBCS.
            //
            // We don't know how many characters will be required so we have to
            // assume the worst case (all characters are DBCS characters).
            //
            *lpBufferSize = UParm[2].dword;
        }
    }

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}


DWORD APIENTRY
WNetGetResourceParentA(
    IN      LPNETRESOURCEA  lpNetResource,
    OUT     LPVOID          lpBuffer,
    IN OUT  LPDWORD         lpBufferSize
    )
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[4];
    UNICODE_PARM    UParm[4];

    AParm[0].lpNetResA  = lpNetResource;
    AParm[1].lpvoid     = lpBuffer;
    AParm[2].lpdword    = lpBufferSize;
    AParm[3].dword      = sizeof(NETRESOURCE);

    status = InputParmsToUnicode("N" NETRES_RP "Bs", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        status = WNetGetResourceParentW(
                    UParm[0].lpNetResW,
                    UParm[1].lpbyte,
                    &UParm[2].dword
                    );

        if (status == WN_SUCCESS)
        {
            //
            // Convert the Unicode netresource returned to Ansi
            //
            status = OutputBufferToAnsi('N', UParm[1].lpbyte, lpBuffer, lpBufferSize);
        }
        else if (status == WN_MORE_DATA)
        {
            //
            // Adjust the required buffer size for ansi/DBCS.
            //
            // We don't know how many characters will be required so we have to
            // assume the worst case (all characters are DBCS characters).
            //
            *lpBufferSize = UParm[2].dword;
        }
    }

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}



DWORD APIENTRY
WNetGetUserA (
    IN      LPCSTR    lpName,
    OUT     LPSTR     lpUserName,
    IN OUT  LPDWORD   lpnLength
    )

/*++

Routine Description:

    This function retreives the current default user name or the username
    used to establish a network connection.

Arguments:

    lpName - Points to a null-terminated string that specifies either the
        name or the local device to return the user name for, or a network
        name that the user has made a connection to.  If the pointer is
        NULL, the name of the current user is returned.

    lpUserName - Points to a buffer to receive the null-terminated
        user name.

    lpnLength - Specifies the size (in characters) of the buffer pointed
        to by the lpUserName parameter.  If the call fails because the
        buffer is not big enough, this location is used to return the
        required buffer size.

Return Value:


--*/
{
    ANSI_API_WITH_ANSI_OUTPUT(
        3,
            AParm[0].lpcstr  = lpName;
            AParm[1].lpvoid  = lpUserName;
            AParm[2].lpdword = lpnLength; ,
        "SB",
        WNetGetUserW(UParm[0].lpwstr, UParm[1].lpwstr, lpnLength); ,
        OutputBufferToAnsi('S', UParm[1].lpbyte, lpUserName, lpnLength);
        )
}


DWORD
RestoreConnectionA0 (
    IN  HWND    hwnd,
    IN  LPSTR   lpDevice
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpDevice; ,
        "S",
        WNetRestoreConnectionW(hwnd, UParm[0].lpwstr);
        )
}


DWORD
WNetGetDirectoryTypeA (
    IN  LPSTR   lpName,
    OUT LPINT   lpType,
    IN  BOOL    bFlushCache
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpName; ,
        "S",
        WNetGetDirectoryTypeW(UParm[0].lpwstr, lpType, bFlushCache);
        )
}

DWORD
WNetDirectoryNotifyA (
    IN  HWND    hwnd,
    IN  LPSTR   lpDir,
    IN  DWORD   dwOper
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpDir; ,
        "S",
        WNetDirectoryNotifyW(hwnd, UParm[0].lpwstr, dwOper);
        )
}

DWORD APIENTRY
WNetGetLastErrorA (
    OUT LPDWORD    lpError,
    OUT LPSTR      lpErrorBuf,
    IN  DWORD      nErrorBufSize,
    OUT LPSTR      lpNameBuf,
    IN  DWORD      nNameBufSize
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DWORD           status;

    //
    // We re-use the Ansi buffers for the Unicode API.
    // There are no input Ansi parameters to convert to Unicode.
    //
    // Call the Unicode version of the function.
    // Note: The sizes for the buffers that are passed in assume that
    // the returned unicode strings will return DBCS characters.
    //
    status = WNetGetLastErrorW(
                lpError,
                (LPWSTR) lpErrorBuf,
                nErrorBufSize / sizeof(WCHAR),
                (LPWSTR) lpNameBuf,
                nNameBufSize / sizeof(WCHAR)
                );

    //
    // Convert the returned strings to Ansi, in place.
    // There should be no buffer overflow.
    //
    if (status == WN_SUCCESS)
    {
        status = OutputStringToAnsiInPlace((LPWSTR) lpErrorBuf);

        if (status == WN_SUCCESS)
        {
            status = OutputStringToAnsiInPlace((LPWSTR) lpNameBuf);
        }
    }

    SET_AND_RETURN(status)
}



VOID
WNetSetLastErrorA(
    IN DWORD   err,
    IN LPSTR   lpError,
    IN LPSTR   lpProviders
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[2];
    UNICODE_PARM    UParm[2];

    AParm[0].lpcstr = lpError;
    AParm[1].lpcstr = lpProviders;

    status = InputParmsToUnicode("SS", AParm, UParm, &tempBuffer);

    if (status != WN_SUCCESS)
    {
        UParm[0].lpwstr = NULL;
        UParm[1].lpwstr = NULL;
    }

    WNetSetLastErrorW(err, UParm[0].lpwstr, UParm[1].lpwstr);

    LocalFree(tempBuffer);

    return;
}



DWORD APIENTRY
MultinetGetErrorTextA(
    OUT LPSTR       lpErrorTextBuf OPTIONAL,
    IN OUT LPDWORD  lpnErrorBufSize OPTIONAL,
    OUT LPSTR       lpProviderNameBuf OPTIONAL,
    IN OUT LPDWORD  lpnNameBufSize OPTIONAL
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    // CODEWORK: This could be simplified by re-using the Unicode buffers,
    // like WNetGetLastErrorA.

    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[4];
    UNICODE_PARM    UParm[4];

    AParm[0].lpvoid     = lpErrorTextBuf;
    AParm[1].lpdword    = lpnErrorBufSize;
    AParm[2].lpvoid     = lpProviderNameBuf;
    AParm[3].lpdword    = lpnNameBufSize;

    status = InputParmsToUnicode("BB", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        // Remember the sizes before calling the function
        DWORD nErrorBufSize;
        DWORD nNameBufSize;
        if (ARGUMENT_PRESENT(lpErrorTextBuf))
        {
            nErrorBufSize = *lpnErrorBufSize;
        }
        if (ARGUMENT_PRESENT(lpProviderNameBuf))
        {
            nNameBufSize  = *lpnNameBufSize;
        }

        status = MultinetGetErrorTextW(
                        UParm[0].lpwstr,
                        lpnErrorBufSize,
                        UParm[2].lpwstr,
                        lpnNameBufSize
                        );

        if (status == WN_SUCCESS || status == WN_MORE_DATA)
        {
            if (ARGUMENT_PRESENT(lpErrorTextBuf) &&
                nErrorBufSize == *lpnErrorBufSize)
            {
                // The Unicode API must have written the error text buffer
                DWORD status2 = OutputBufferToAnsi(
                                      'S',
                                      UParm[0].lpbyte,
                                      lpErrorTextBuf,
                                      lpnErrorBufSize);

                if (status2 != WN_SUCCESS)
                {
                    status = status2;
                }
            }
        }

        if (status == WN_SUCCESS || status == WN_MORE_DATA)
        {
            if (ARGUMENT_PRESENT(lpProviderNameBuf) &&
                nNameBufSize  == *lpnNameBufSize)
            {
                // The Unicode API must have written the provider name buffer
                DWORD status2 = OutputBufferToAnsi(
                                      'S',
                                      UParm[2].lpbyte,
                                      lpProviderNameBuf,
                                      lpnNameBufSize);

                if (status2 != WN_SUCCESS)
                {
                    status = status2;
                }
            }
        }
    }

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}



DWORD
WNetPropertyDialogA (
    HWND  hwndParent,
    DWORD iButton,
    DWORD nPropSel,
    LPSTR lpszName,
    DWORD nType
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpszName; ,
        "S",
        WNetPropertyDialogW(hwndParent, iButton, nPropSel, UParm[0].lpwstr, nType);
        )
}


DWORD
WNetGetPropertyTextA (
    IN  DWORD iButton,
    IN  DWORD nPropSel,
    IN  LPSTR lpszName,
    OUT LPSTR lpszButtonName,
    IN  DWORD nButtonNameLen,
    IN  DWORD nType
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITH_ANSI_OUTPUT(
        3,
            AParm[0].lpcstr  = lpszName;
            AParm[1].lpvoid  = lpszButtonName;
            AParm[2].lpdword = &nButtonNameLen; ,
        "SB",
        WNetGetPropertyTextW(iButton, nPropSel, UParm[0].lpwstr,
            UParm[1].lpwstr, nButtonNameLen, nType); ,
        OutputBufferToAnsi('S', UParm[1].lpbyte, lpszButtonName, &nButtonNameLen);
        )
}



DWORD APIENTRY
WNetFormatNetworkNameA(
    IN     LPCSTR   lpProvider,
    IN     LPCSTR   lpRemoteName,
    OUT    LPSTR    lpFormattedName,
    IN OUT LPDWORD  lpnLength,         // In characters!
    IN     DWORD    dwFlags,
    IN     DWORD    dwAveCharPerLine
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITH_ANSI_OUTPUT(
        4,
            AParm[0].lpcstr  = lpProvider;
            AParm[1].lpcstr  = lpRemoteName;
            AParm[2].lpvoid  = lpFormattedName;
            AParm[3].lpdword = lpnLength; ,
        "SSB",
        WNetFormatNetworkNameW(
                    UParm[0].lpwstr,
                    UParm[1].lpwstr,
                    UParm[2].lpwstr,
                    lpnLength,
                    dwFlags,
                    dwAveCharPerLine
                    ); ,
        OutputBufferToAnsi('S', UParm[2].lpbyte, lpFormattedName, lpnLength);
        )
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\credman.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    credman.cxx

Abstract:

    WNet Credential Management API functions

Author:

    Dan Lafferty (danl) 07-Dec-1992

Environment:

    User Mode - Win32


Revision History:

    05-May-1999     jschwart
        Make provider addition/removal dynamic

    19-Apr-1994 danl
        Fix timeout logic where we would ignore the
        provider-supplied timeout if the timeout was smaller than the default.
        Now, if all the providers know their timeouts, the larger of those
        timeouts is used.  Even if smaller than the default.

    09-Jun-1993 danl
        Fixed MaxWait in MprCheckTimeout() so that now it is passed in.
        Until now, it was left uninitialized.

    07-Apr-1993 danl
        Initialize the pointer to the logon script to NULL prior to passing
        it to the provider to fill in.  We are expecting it to be NULL if
        they don't have a logon script.

    18-Jan-1993 danl
        WNetLogonNotify:  If the provider returns an error that mpr
        doesn't understand, it should discontinue calling that provider.
        This is accomplished by setting the ContinueFlag for that provider
        to FALSE.

    07-Dec-1992 danl
        Created

--*/

//
// INCLUDES
//
#include "precomp.hxx"
#include <tstr.h>       // WCSSIZE

//
// DEFINES
//

typedef struct _RETRY_INFO {
    DWORD   ProviderIndex;
    DWORD   Status;
    DWORD   ProviderWait;
    BOOL    ContinueFlag;
    LPWSTR  LogonScript;
} RETRY_INFO, *LPRETRY_INFO;

//
// LOCAL FUNCTIONS
//
DWORD
MprMakeRetryArray(
    LPCWSTR         lpPrimaryAuthenticator,
    LPDWORD         lpNumProviders,
    LPRETRY_INFO    *lpRetryArray,
    LPDWORD         lpRegMaxWait
    );

VOID
MprUpdateTimeout(
    LPRETRY_INFO    RetryArray,
    LPPROVIDER      Provider,
    DWORD           RegMaxWait,
    LPDWORD         pMaxWait,
    DWORD           StartTime,
    DWORD           CallStatus
    );

VOID
MprCheckTimeout(
    BOOL    *ContinueFlag,
    DWORD   StartTime,
    DWORD   MaxWait,
    LPDWORD lpStatus
    );


DWORD APIENTRY
WNetLogonNotify(
    LPCWSTR             lpPrimaryAuthenticator,
    PLUID               lpLogonId,
    LPCWSTR             lpAuthentInfoType,
    LPVOID              lpAuthentInfo,
    LPCWSTR             lpPreviousAuthentInfoType,  // may be NULL
    LPVOID              lpPreviousAuthentInfo,      // may be NULL
    LPWSTR              lpStationName,
    LPVOID              StationHandle,
    LPWSTR              *lpLogonScripts
    )

/*++

Description:

    This function provides notification to provider dll's that must handle
    log-on events.

    Each Credential Manager Provider is allowed to return
    a single command line string which will execute a logon script.
    WNetLogonNotify gathers these strings into a MULTI_SZ string buffer.
    (Meaning each string is NULL terminated, and the set of strings is
    NULL terminated - thus making the last string doubly NULL terminated).

    !! IMPORTANT !!
        The caller of this function is responsible for freeing the
        buffer pointed to by *lpLogonScripts.  The windows API function
        LocalFree() should be used to do this.

Arguments:

    lpPrimaryAuthenticator - This is a pointer to a string that identifies
        the primary authenticator.  The router uses this information to
        skip the credential manager identified by this string.  Since it
        is the primary, it has already handled the logon.  This string is
        obtained from the "\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\
        Services\*(keyname)\NetworkProvider\Name" registry value.

    lpLogonId - The logon ID of the session currently being logged on.

    lpAuthentInfoType - This points to a string that identifies the
        AuthentInfo structure type.

        When Microsoft is the primary authenticator, the values that may
        be expected here are the ones described for the lpAuthentInfoType
        parameter to NPLogonNotify().

    lpAuthentInfo - This points to a structure that contains the
        credentials used to successfully log the user on via the
        primary authenticator.  The structures that may be specified when
        using Micosoft's primary authenticator are:

        When Microsoft is the primary authenticator, the structures that
        may be expected here are the ones described for the lpAuthentInfo
        parameter to NPLogonNotify().

    lpPreviousAuthentInfoType - This is pointer to a string that identifies
        the PreviousAuthentInfo structure.  If this pointer is NULL, then
        no PreviousAuthentInfo is available.

        The values that may be expected here are the same as the values that
        may be expected for the lpAuthentInfoType parameter.

    lpPreviousAuthentInfo - If the user was forced to change the password
        prioir to logging on, this points to a AuthentInfo structure that
        will contain the credential information used prior to the password
        change.  If the user was not forced to change the password prior
        to logging on, then this pointer is NULL.

        The structures that may be expected here are the same as the
        structures that may be expected for the lpAuthentInfo parameter.

    lpStationName - This parameter contains the name of the station the
        user has logged onto.  This may be used to determine whether or
        not interaction with the user to obtain additional (provider-specific)
        credentials is possible.  This information will also have a bearing
        on the meaning and use of the StationHandle parameter.

        When Microsoft is the primary authenticator, the values that
        may be expected here are the ones described for the lpStationName
        parameter to NPLogonNotify().

    StationHandle - Is a 32-bit value whose meaning is dependent upon the
        name (and consequently, the type) of station being logged onto.

        When Microsoft is the primary authenticator, the values that
        may be expected here are the ones described for the lpStationHandle
        parameter to NPLogonNotify().

    lpLogonScripts - This is a pointer to a location where a pointer to
        a MULTI_SZ string may be returned.  Each null terminated
        string in the MULTI_SZ string is assumed to contain the name
        of a program to execute and parameters to pass to the program.
        The memory allocated to hold the returned string must be
        deallocatable by the calling routine.  The caller of this
        routine is responsible for freeing the memory used to house
        this string when it is no longer needed.

Return Value:


--*/
{
    DWORD           status = WN_SUCCESS;
    DWORD           numProviders;
    LPPROVIDER      provider;
    BOOL            fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD           i;
    BOOL            ContinueFlag;
    LPRETRY_INFO    RetryArray;
    DWORD           RegMaxWait=0;
    DWORD           MaxWait=0;
    DWORD           StartTime;
    DWORD           scriptSize=0;
    LPWSTR          pScript;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(CREDENTIAL_LEVEL,status);

    MPR_LOG0(TRACE,"Entered WNetLogonNotify\n");
    //
    // Now create an array of information about the providers so that we
    // can retry until timeout, or all providers are functional.
    // Note:  The Status field in each retry array element is initialized
    //        WN_NO_NETWORK.
    //
    __try {
        *lpLogonScripts = NULL;

        status = MprMakeRetryArray(
                    lpPrimaryAuthenticator,
                    &numProviders,
                    &RetryArray,
                    &RegMaxWait);
    }
    __except(MPR_EXCEPTION_FILTER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetLogonNotify:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if ((status != WN_SUCCESS) || (numProviders == 0)) {
        MPR_LOG2(TRACE,"WNetLogonNotify: Error - status=%d, numProviders=%d\n",
            status,numProviders);
        return(status);
    }

    //
    // Initialize the timer.
    //
    if (RegMaxWait != 0) {
        MaxWait = RegMaxWait;
    }
    StartTime = GetTickCount();

    //
    // Loop through the list of providers notifying each one in turn.
    // If the underlying service or driver is not available for the
    // provider such that it cannot complete this call, then we will
    // wait for it to become available.
    //

    do {

        ContinueFlag = FALSE;

        for (i=0; i<numProviders; i++) {

            //
            // Call the appropriate provider's API entry point
            //
            provider = GlobalProviderInfo + RetryArray[i].ProviderIndex;

            if ((RetryArray[i].ContinueFlag) &&
                (provider->LogonNotify != NULL))  {

                fcnSupported = TRUE;

                RetryArray[i].LogonScript = NULL;

                __try {
                    MPR_LOG(TRACE,"Calling (%ws) LogonNotify function\n",
                        provider->Resource.lpProvider);
                    status = provider->LogonNotify(
                                lpLogonId,
                                lpAuthentInfoType,
                                lpAuthentInfo,
                                lpPreviousAuthentInfoType,
                                lpPreviousAuthentInfo,
                                lpStationName,
                                StationHandle,
                                (LPWSTR *)&(RetryArray[i].LogonScript));
                }
                __except(MPR_EXCEPTION_FILTER) {
                    status = GetExceptionCode();
                    if (status != EXCEPTION_ACCESS_VIOLATION) {
                        MPR_LOG(ERROR,"WNetLogonNotify:Unexpected Exception "
                        "0x%lx\n",status);
                    }
                    status = WN_BAD_POINTER;
                }

                switch (status) {
                case WN_SUCCESS:
                    //
                    // Because this provider may have put up dialogs, and
                    // taken a long time to complete, we want to skip the
                    // timeout check and try all the providers once more.
                    // We force the index to 0 in order to assure that all
                    // providers will be tried again prior to checking for
                    // a timeout.
                    //
                    RetryArray[i].Status = WN_SUCCESS;
                    RetryArray[i].ContinueFlag = FALSE;

                    if (RetryArray[i].LogonScript != NULL)
                    {
                        //
                        // If the provider returns an empty logon script,
                        // don't add the empty string to the list as that
                        // shows up as the end of the list to the caller.
                        //

                        DWORD dwSize = WCSSIZE(RetryArray[i].LogonScript);

                        if (dwSize > sizeof(WCHAR))
                        {
                            scriptSize += dwSize;
                        }
                    }

                    ContinueFlag = FALSE;
                    i=0;
                    break;

                case WN_NO_NETWORK:
                case WN_FUNCTION_BUSY:
                    //
                    // The provider is not ready to be notified (its underlying
                    // driver or service is not running yet).  Attempt to
                    // find out how long to wait, or if it will ever start.
                    // This function will update MaxWait if the provider can
                    // give us a wait hint.
                    //
                    MprUpdateTimeout(
                        &(RetryArray[i]),
                        provider,
                        RegMaxWait,
                        &MaxWait,
                        StartTime,
                        status);
                    break;

                default:
                    RetryArray[i].Status = status;
                    RetryArray[i].ContinueFlag = FALSE;
                    break;

                } // End Switch (Get providers timeouts).

                ContinueFlag |= RetryArray[i].ContinueFlag;

            } // end check to see if function is supported.

        } // end for i<numProviders.

        //
        // Check to see if the timeout has expired.
        //
        MprCheckTimeout(&ContinueFlag, StartTime, MaxWait, &status);

    } while (ContinueFlag);

    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        MPR_LOG0(TRACE,"WNetLogonNotify: Function Not Supported\n");
        status = WN_NOT_SUPPORTED;
    }

    //
    // Handle normal errors passed back from the provider
    //
    if (status == WN_SUCCESS)
    {
        if (scriptSize != 0)
        {
            //
            // There must be some logon scripts.  Allocate memory for them.
            //
            *lpLogonScripts = (LPWSTR)LocalAlloc(
                                LMEM_FIXED,
                                scriptSize+sizeof(WCHAR));

            if (*lpLogonScripts != NULL)
            {
                //
                // Copy the logon scripts into the new buffer.
                //
                pScript = *lpLogonScripts;

                for (i = 0; i < numProviders; i++)
                {
                    if ((RetryArray[i].Status == WN_SUCCESS) &&
                        (RetryArray[i].LogonScript != NULL))
                    {
                        //
                        // If the provider returns an empty logon script,
                        // don't add the empty string to the list as that
                        // shows up as the end of the list to the caller.
                        //

                        DWORD dwSize = WCSSIZE(RetryArray[i].LogonScript);

                        if (dwSize > sizeof(WCHAR))
                        {
                            wcscpy(pScript, RetryArray[i].LogonScript);

                            //
                            // Update the pointer to point beyond the last null
                            // terminator.
                            //

                            pScript += (dwSize / sizeof(WCHAR));
                        }
                    }
                }

                //
                // Add the double NULL terminator.
                //
                *pScript = L'\0';
            }
            else
            {
                //
                // The allocation failed.  (ERROR LOG?)
                //
                MPR_LOG0(ERROR,"Logon scripts will be lost - could not "
                    "allocate memory\n");

            }
        }
    }
    else {
        SetLastError(status);
    }

    if (RetryArray != NULL) {
        LocalFree(RetryArray);
    }
    MPR_LOG1(TRACE,"Leaving WNetLogonNotify status = %d\n",status);
    return(status);
}

DWORD APIENTRY
WNetPasswordChangeNotify(
    LPCWSTR             lpPrimaryAuthenticator,
    LPCWSTR             lpAuthentInfoType,
    LPVOID              lpAuthentInfo,
    LPCWSTR             lpPreviousAuthentInfoType,
    LPVOID              lpPreviousAuthentInfo,
    LPWSTR              lpStationName,
    LPVOID              StationHandle,
    DWORD               dwChangeInfo
    )


/*++

Description:

    This function is used to notify credential managers of a password
    change for an account.

Arguments:

    lpPrimaryAuthenticator - This is a pointer to a string that identifies
        the primary authenticator.  Credential Manager does not need the
        password notification since it already handled the change.
        This string is obtained from the "\HKEY_LOCAL_MACHINE\SYSTEM\
        CurrentControlSet\Services\*(keyname)\NetworkProvider\Name" registry
        value.

    lpAuthentInfoType - This points to a string that identifies the
        AuthentInfo structure type.

        When Microsoft is the primary authenticator, the values that
        may be expected here are the ones described for the
        lpAuthentInfoType parameter to NPLogonNotify().

    lpAuthentInfo - This points to a structure that contains the
        new credentials.

        When Microsoft is the primary authenticator, the structures that
        may be expected here are the ones described for the lpAuthentInfo
        parameter to NPLogonNotify().

    lpPreviousAuthentInfoType - This points to the string that identifies
        the PreviousAuthentInfo structure type.

        The values that may be expected here are the same as the values that
        may be expected for the lpAuthentInfoType parameter.

    lpPreviousAuthentInfo - This points to an AuthentInfo structure that
        contains the previous credential information. (old password and such).

        The structures that may be expected here are the same as the
        structures that may be expected for the lpAuthentInfo parameter.

    lpStationName - This parameter contains the name of the station the
        user performed the authentication information change from.
        This may be used to determine whether or not interaction with the
        user to obtain additional (provider-specific) information is possible.
        This information will also have a bearing on the meaning and use of
        the StationHandle parameter.

        When Microsoft is the primary authenticator, the values that
        may be expected here are the ones described for the lpStationName
        parameter to NPLogonNotify().

    StationHandle - Is a 32-bit value whose meaning is dependent upon the
        name (and consequently, the type) of station being logged onto.

        When Microsoft is the primary authenticator, the values that
        may be expected here are the ones described for the lpStationHandle
        parameter to NPLogonNotify().

    dwChangeInfo - This is a set of flags that provide information about the
        change.  Currently the following possible values are defined:

            WN_VALID_LOGON_ACCOUNT - If this flag is set, then the
                password (or, more accurately, the authentication
                information) that was changed will affect future
                logons.  Some authentication information changes
                will only affect connections made in untrusted
                domains.  These are accounts that the user cannot
                use to logon to this machine anyway.  In these
                cases, this flag will not be set.


Return Value:


Note:


--*/
{
    DWORD       status = WN_SUCCESS;
    LPDWORD     indexArray;
    DWORD       localArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders;
    LPPROVIDER  provider;
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       i,j;
    DWORD       primaryIndex;
    BOOL        oneSuccess=FALSE;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(CREDENTIAL_LEVEL,status);

    //
    // Find the list of providers to call for this request.
    //
    indexArray = localArray;

    //
    // If there are no active providers, MprFindCallOrder returns
    // WN_NO_NETWORK.
    //
    status = MprFindCallOrder(
                NULL,
                &indexArray,
                &numProviders,
                CREDENTIAL_TYPE);

    if (status != WN_SUCCESS) {
        return(status);
    }

    __try {
        //
        // Remove the primary authenticator from the list.
        //
        if (MprGetProviderIndex((LPTSTR)lpPrimaryAuthenticator,&primaryIndex)) {

            for (i=0; i<numProviders ;i++ ) {
                if (indexArray[i] == primaryIndex) {
                    numProviders--;
                    j=i;
                    i++;
                    for (; j<numProviders; i++,j++) {
                        indexArray[j] = indexArray[i];
                    }
                    break;
                }
            }
        }
    }
    __except(MPR_EXCEPTION_FILTER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetChangePassword:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    //
    // If there are no credential managers aside from the primary, the
    // return with success.
    //
    if (numProviders == 0) {
        if (indexArray != localArray) {
            LocalFree(indexArray);
        }
        return(WN_SUCCESS);
    }

    //
    // Loop through the list of providers notifying each one.
    //

    for (i=0; i<numProviders; i++) {

        //
        // Call the appropriate provider's API entry point
        //
        provider = GlobalProviderInfo + indexArray[i];

        if (provider->PasswordChangeNotify != NULL)  {

            fcnSupported = TRUE;

            __try {
                MPR_LOG(TRACE,"Calling (%ws) ChangePasswordNotify function\n",
                    provider->Resource.lpProvider);

                status = provider->PasswordChangeNotify(
                            lpAuthentInfoType,
                            lpAuthentInfo,
                            lpPreviousAuthentInfoType,
                            lpPreviousAuthentInfo,
                            lpStationName,
                            StationHandle,
                            dwChangeInfo);
            }
            __except(MPR_EXCEPTION_FILTER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetChangePassword:Unexpected Exception 0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }
            if (status == WN_SUCCESS) {
                //
                // If the call was successful, then we indicate that at least
                // one of the calls was successful.
                //
                oneSuccess = TRUE;
            }
        }
    }

    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (indexArray != localArray) {
        LocalFree(indexArray);
    }

    //
    // Handle normal errors passed back from the provider
    //
    if (oneSuccess == TRUE) {
        status = WN_SUCCESS;
    }
    else {
        SetLastError(status);
    }

    return(status);
}
#ifdef REMOVE

DWORD APIENTRY
WNetLogoffNotify(
    HWND                hwndOwner,
    LPCWSTR             lpPrimaryAuthenticator,
    PLUID               lpLogonId,
    WN_OPERATION_TYPE   OperationType
    )

/*++

Description:

    This function provides log-off notification to credential managers.

Arguments:

    hwndOwner - Identifies the owner window.

    lpPrimaryAuthenticator - This is a pointer to a string that identifies
        the primary authenticator.  Credential Manager does not need the
        password notification since it already handled the change.

    lpLogonId - The logon ID of the session currently being logged on.

    OperationType - The type of operation.  This indicates whether the
        function call is from an interactive program (winlogon), or a
        background program (service controller).  User dialogs should not
        be displayed if the call was from a background process.


Return Value:

    WN_SUCCESS - This is returned if we are able to successfully notify at
        least one of the providers which has registered an entry point for
        the Logoff event.

    WN_NO_NETWORK - This is returned if there are no providers, or if
        there is only one provider, but its supporting service/driver is
        not available.

    WN_BAD_POINTER - This is returned if one of the pointer parameters
        is bad and causes an exception.

    WN_NOT_SUPPORTED - This is returned if none of the active providers
        support this function.

    system errors such as ERROR_OUT_OF_MEMORY are also reported.


Note:


--*/
{
    DWORD       status = WN_SUCCESS;
    LPDWORD     indexArray;
    DWORD       localArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders;
    LPPROVIDER  provider;
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       i,j;
    DWORD       primaryIndex;
    BOOL        oneSuccess=FALSE;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(CREDENTIAL_LEVEL,status);

    //
    // Find the list of providers to call for this request.
    //
    indexArray = localArray;

    //
    // If there are no active providers, MprFindCallOrder returns
    // WN_NO_NETWORK.
    //
    status = MprFindCallOrder(
                NULL,
                &indexArray,
                &numProviders,
                CREDENTIAL_TYPE);

    if (status != WN_SUCCESS) {
        return(status);
    }

    try {
        //
        // Remove the primary authenticator from the list.
        //
        if (MprGetProviderIndex((LPTSTR)lpPrimaryAuthenticator,&primaryIndex)) {

            for (i=0; i<numProviders ;i++ ) {
                if (indexArray[i] == primaryIndex) {
                    numProviders--;
                    j=i;
                    i++;
                    for (; j<numProviders; i++,j++) {
                        indexArray[j] = indexArray[i];
                    }
                    break;
                }
            }
        }
    }
    except(MPR_EXCEPTION_FILTER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetChangePassword:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    //
    // If there are no credential managers aside from the primary, the
    // return with success.
    //
    if (numProviders == 0) {
        if (indexArray != localArray) {
            LocalFree(indexArray);
        }
        return(WN_SUCCESS);
    }

    //
    // Loop through the list of providers notifying each one.
    //

    for (i=0; i<numProviders; i++) {

        //
        // Call the appropriate provider's API entry point
        //
        provider = GlobalProviderInfo + indexArray[i];

        if ((provider->InitClass & CREDENTIAL_TYPE) &&
            (provider->LogoffNotify != NULL))         {

            fcnSupported = TRUE;

            try {
                status = provider->LogoffNotify(
                            hwndOwner,
                            lpLogonId,
                            OperationType);
            }
            except(MPR_EXCEPTION_FILTER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetLogoffNotify:Unexpected Exception 0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }
            if (status == WN_SUCCESS) {
                //
                // If the call was successful, then we indicate that at least
                // one of the calls was successful.
                //
                oneSuccess = TRUE;
            }
        }
    }

    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (indexArray != localArray) {
        LocalFree(indexArray);
    }

    //
    // Handle normal errors passed back from the provider
    //
    if (oneSuccess == TRUE) {
        status = WN_SUCCESS;
    }
    else {
        SetLastError(status);
    }

    return(status);
}
#endif // REMOVE

DWORD
MprMakeRetryArray(
    LPCWSTR         lpPrimaryAuthenticator,
    LPDWORD         lpNumProviders,
    LPRETRY_INFO    *lpRetryArray,
    LPDWORD         lpRegMaxWait
    )

/*++

Routine Description:

    This function returns with an array of RETRY_INFO structures.  There is
    one array element for each credential manager provider that is NOT
    the current primary authenticator.  The structures contain such information
    as the provider index in the global array of provider information, a
    location for the provider's timeout value, status and continue flag.

    This function will also attempt to obtain the WaitTimeout from the
    registry if it exists.

    IMPORTANT!
        This function allocates memory for lpRetryArray.  The caller is
        expected to free this memory with LocalFree().  If an error is
        returned, or if the data at lpNumProviders is 0, then memory is
        not allocated.

Arguments:

    lpPrimaryAuthenticator - This is a pointer to a string that identifies
        the primary authenticator.  The router uses this information to
        skip the credential manager identified by this string.  Since it
        is the primary, it has already handled the logon.

    lpNumProviders - This is a pointer to a location where the number of
        providers in the lpRetryArray are stored.

    lpRetryArray - This is an array of RETRY_INFO structures.  There is one
        element in the array for each Credential Manager provider that is
        not the current PrimaryAuthenticator.  The status in the array is
        initialized to WN_NO_NETWORK.

    lpRegMaxWait - This is a pointer to the location to where the Maximum
        Wait Timeout from the registry is to be placed.  If there is no
        MaxWait value in the registry, zero is returned.


Return Value:

    WN_SUCCESS is returned if we successfully created an array of
    RetryInfo structures, or if there are no credential manager providers.
    If we are unable to allocate memory for the RetryInfo structures,
    then the failure from LocalAlloc is returned.

--*/
{
    DWORD           status;
    DWORD           i,j;
    HKEY            providerKeyHandle;
    DWORD           primaryIndex;
    DWORD           ValueType;
    DWORD           Temp;
    DWORD           numProviders;
    LPDWORD         indexArray;
    DWORD           localArray[DEFAULT_MAX_PROVIDERS];

    ASSERT(MPRProviderLock.Have());

    //
    // Find the list of providers to call for this request.
    //
    indexArray = localArray;

    //
    // If there are no active providers, or none of the active providers are
    // in this InitClass MprFindCallOrder returns WN_NO_NETWORK.
    //
    status = MprFindCallOrder(
                NULL,
                &indexArray,
                &numProviders,
                CREDENTIAL_TYPE);

    if ((status != WN_SUCCESS) || (numProviders == 0)) {
        //
        // If there aren't any credential managers, then just return.
        //
        MPR_LOG0(TRACE,"MprMakeRetryArray: There aren't any Credential Managers\n");
        *lpNumProviders = 0;
        return(WN_SUCCESS);
    }

    *lpNumProviders = numProviders;

    //
    // Remove the primary authenticator from the list.
    //
    if (MprGetProviderIndex((LPTSTR)lpPrimaryAuthenticator,&primaryIndex)) {

        for (i=0; i<numProviders ;i++ ) {
            if (indexArray[i] == primaryIndex) {
                numProviders--;
                j=i;
                i++;
                for (; j<numProviders; i++,j++) {
                    indexArray[j] = indexArray[i];
                }
                break;
            }
        }
        //
        // If there are no credential managers aside from the primary, the
        // return with success.
        //
        *lpNumProviders = numProviders;
        if (numProviders == 0) {
            if (indexArray != localArray) {
                LocalFree(indexArray);
            }
            MPR_LOG0(TRACE,"MprMakeRetryArray: There aren't any "
                "Credential Managers aside from the Primary\n");
            return(WN_SUCCESS);
        }
    }

    //
    // At this point the indexArray only contains indices for Credential
    // Manager providers that are not the primary authenticator.
    //
    //
    // Now create an array of information about the providers so that we
    // can retry until timeout, or all providers are functional.  This
    // memory is expected to be initialized to  zero when allocated.
    //

    *lpRetryArray = (LPRETRY_INFO)LocalAlloc(LPTR, sizeof(RETRY_INFO) * numProviders);
    if (*lpRetryArray == NULL) {
        return(GetLastError());
    }
    for (i=0; i<numProviders; i++) {
        (*lpRetryArray)[i].Status = WN_NO_NETWORK;
        (*lpRetryArray)[i].ProviderIndex = indexArray[i];
        (*lpRetryArray)[i].ContinueFlag = TRUE;
    }

    if (indexArray != localArray) {
        LocalFree(indexArray);
    }

    //
    // Read the MaxWait value that is stored in the registry.
    // If it is not there or if the value is less than our default
    // maximum value, then use the default instead.
    //

    if(!MprOpenKey(
                HKEY_LOCAL_MACHINE,     // hKey
                NET_PROVIDER_KEY,       // lpSubKey
                &providerKeyHandle,     // Newly Opened Key Handle
                DA_READ)) {             // Desired Access

        MPR_LOG(ERROR,"MprCreateConnectionArray: MprOpenKey (%ws) Error\n",
            NET_PROVIDER_KEY);

        *lpRegMaxWait = 0;
        return(WN_SUCCESS);
    }
    MPR_LOG(TRACE,"OpenKey %ws\n",NET_PROVIDER_KEY);

    Temp = sizeof(*lpRegMaxWait);

    status = RegQueryValueEx(
                providerKeyHandle,
                RESTORE_WAIT_VALUE,
                NULL,
                &ValueType,
                (LPBYTE)lpRegMaxWait,
                &Temp);

    if (status != NO_ERROR) {
        *lpRegMaxWait = 0;
    }

    RegCloseKey(providerKeyHandle);

    return(WN_SUCCESS);
}

VOID
MprUpdateTimeout(
    LPRETRY_INFO    RetryInfo,
    LPPROVIDER      Provider,
    DWORD           RegMaxWait,
    LPDWORD         pMaxWait,
    DWORD           StartTime,
    DWORD           CallStatus
    )
/*++

Routine Description:

    This function attempts to get timeout information from the provider.
    If the provider will never start, the ContinueFlag in the RetryInfo is
    set to FALSE.  If the provider tells us how long we should wait, then
    MaxWait is updated if that time is longer than the current MaxWait.

Arguments:

    RetryInfo - This is a pointer to a structure that contains retry
        information for a particular provider.

    Provider - This is a pointer to a structure that contains dll
        entry points for a particular provider.

    RegMaxWait - This is the default timeout.  It is either the hard-coded
        timeout, or the timeout in the registry.

    pMaxWait - This is a pointer to a value that is the maximum amount of
        time that the router will wait for the provider to be ready to receive
        the function call.

    StartTime - This is the clock tick time that we started the operation with.

    CallStatus - This is the status from the most recent function call to the
        provider.

Return Value:

    none

--*/
{
    DWORD           ElapsedTime;
    DWORD           CurrentTime;
    DWORD           providerStatus;
    PF_NPGetCaps    pGetCaps;

    MPR_LOG0(TRACE,"Entering MprUpdateTimeout\n");

    ASSERT(MPRProviderLock.Have());

    //
    // First try the credential manager's GetCaps function.
    // if it doesn't exist, then use the network provider's
    // function.
    //
    pGetCaps = Provider->GetAuthentCaps;
    if (pGetCaps == NULL) {
        pGetCaps = Provider->GetCaps;
    }

    //
    // If this is the first pass through, we don't have the
    // wait times figured out for each provider.  Do that
    // now.
    //
    if (RetryInfo->ProviderWait == 0) {

        MPR_LOG1(TRACE,"Call GetCaps to get (%ws)provider start timeout\n",
                Provider->Resource.lpProvider);

        if (pGetCaps != NULL) {

            providerStatus = pGetCaps(WNNC_START);

            switch (providerStatus) {
            case PROVIDER_WILL_NOT_START:
                MPR_LOG0(TRACE,"Provider will not start\n");
                RetryInfo->ContinueFlag = FALSE;
                RetryInfo->Status = CallStatus;
                break;
            case NO_TIME_ESTIMATE:
                MPR_LOG0(TRACE,"No Time estimate for Provider start\n");
                if (RegMaxWait != 0) {
                    RetryInfo->ProviderWait = RegMaxWait;
                }
                else {
                    RetryInfo->ProviderWait = DEFAULT_WAIT_TIME;
                }
                if (*pMaxWait < RetryInfo->ProviderWait) {
                    *pMaxWait = RetryInfo->ProviderWait;
                }
                break;
            default:

                MPR_LOG1(TRACE,"Time estimate for Provider start = %d\n",
                    providerStatus);
                //
                // In this case, the providerStatus is actually
                // the amount of time we should wait for this
                // provider.  We set MaxWait to the longest of
                // the times specified by the providers.
                //
                if ((providerStatus <= MAX_ALLOWED_WAIT_TIME) &&
                    (providerStatus > *pMaxWait)) {
                        *pMaxWait = providerStatus;
                }
                RetryInfo->ProviderWait = *pMaxWait;
                break;
            }
        }
        else {
            MPR_LOG0(TRACE,"There is no GetCaps function.  So we cannot "
                "obtain the provider start timeout\n");
            RetryInfo->ContinueFlag = FALSE;
            RetryInfo->Status = CallStatus;
        }
    }
    //
    // If the status for this provider has just changed to
    // WN_FUNCTION_BUSY from some other status, then calculate
    // a timeout time by getting the provider's new timeout
    // and adding that to the elapsed time since start.  This
    // gives a total elapsed time until timeout - which can
    // be compared with the current MaxWait.
    //
    if ((CallStatus == WN_FUNCTION_BUSY) &&
        (RetryInfo->Status == WN_NO_NETWORK)) {

        MPR_LOG1(TRACE,"Provider status just changed to FUNCTION_BUSY "
            "from some other status - Call GetCaps to get (%ws)provider "
            " start timeout\n",
            Provider->Resource.lpProvider);

        if (pGetCaps != NULL) {
            providerStatus = pGetCaps(WNNC_START);
            switch (providerStatus) {
            case PROVIDER_WILL_NOT_START:
                MPR_LOG0(TRACE,"Provider will not start - bizzare case\n");
                //
                // This is bizzare to find the status = BUSY,
                // and then have the Provider not starting.
                //
                RetryInfo->ContinueFlag = FALSE;
                break;
            case NO_TIME_ESTIMATE:
                MPR_LOG0(TRACE,"No Time estimate for Provider start\n");
                //
                // No need to alter the timeout for this one.
                //
                break;
            default:
                MPR_LOG1(TRACE,"Time estimate for Provider start = %d\n",
                    providerStatus);
                //
                // Make sure this new timeout information will take
                // less than the maximum allowed time for
                // providers.
                //
                if (providerStatus <= MAX_ALLOWED_WAIT_TIME) {
                    CurrentTime = GetTickCount();
                    //
                    // Determine how much time has elapsed since
                    // we started.
                    //
                    ElapsedTime = CurrentTime - StartTime;

                    //
                    // Add the Elapsed time to the new timeout
                    // we just received from the provider to come
                    // up with a timeout value that can be
                    // compared with MaxWait.
                    //
                    providerStatus += ElapsedTime;

                    //
                    // If the new timeout is larger than MaxWait,
                    // then use the new timeout.
                    //
                    if (providerStatus > *pMaxWait) {
                        *pMaxWait = providerStatus;
                    }
                } // EndIf (Make sure time out is < max allowed).
                break;

            } // End Switch (changed status).
        }

    } // End If (change state from NO_NET to BUSY)

    //
    // Store the status (either NO_NET or BUSY) with the
    // retry info.
    //
    RetryInfo->Status = CallStatus;

    MPR_LOG0(TRACE,"Leaving MprUpdateTimeout\n");
    return;
}

VOID
MprCheckTimeout(
    BOOL    *ContinueFlag,
    DWORD   StartTime,
    DWORD   MaxWait,
    LPDWORD lpStatus
    )

/*++

Routine Description:

    This function checks to see if a timeout occured.

Arguments:

    ContinueFlag - This is a pointer to the location of the continue flag.
        This is set to FALSE if a timeout occured.

    StartTime - This is the tick count at the beginning of the operation.

    lpStatus - This is a pointer to the current status for the operation.
        This is updated only if a timeout occurs.

Return Value:

    none

--*/
{
    DWORD   CurrentTime;
    DWORD   ElapsedTime;

    MPR_LOG0(TRACE,"Entering MprCheckTimeout\n");
    if (*ContinueFlag) {
        //
        // Determine what the elapsed time from the start is.
        //
        CurrentTime = GetTickCount();
        ElapsedTime = CurrentTime - StartTime;

        //
        // If a timeout occured, then don't continue.  Otherwise, sleep
        // for a bit and loop again through all providers.
        //
        if (ElapsedTime > MaxWait) {
            MPR_LOG0(TRACE,"WNetLogonNotify:Timed out while waiting "
                "for Credential Managers\n");
            *ContinueFlag = FALSE;
            *lpStatus = ERROR_SERVICE_REQUEST_TIMEOUT;
        }
        else {
            Sleep(2000);
        }
    }
    MPR_LOG0(TRACE,"Leaving MprCheckTimeout\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\lasterr.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lasterr.c

Abstract:

    Contains the entry point for
        WNetGetLastErrorW
        WNetSetLastErrorW
        MultinetGetErrorTextW

    Also contains the following support routines:
        MprAllocErrorRecord
        MprFreeErrorRecord
        MprFindErrorRecord

Author:

    Dan Lafferty (danl) 17-Oct-1991

Environment:

    User Mode - Win32

Revision History:

    09-Aug-1996 anirudhs
        Fixed bug in MprFindErrorRecord.  Replaced MprFreeErrorRecord with
        MprFreeAllErrorRecords (see mprinit.cxx).  Moved some definitions
        from mprdata.h here.

    20-Jun-1995 anirudhs
        Added MultinetGetErrorTextW.  Removed CurrentThreadId parameter to
        MprFindErrorRecord.  Some other cleanups.

    11-Aug-1993 danl
        WNetGetLastErrorW: Got rid of TCHAR stuff and committed to UNICODE.
        Also, consistently use number of characters rather than number
        of bytes.

    08-Jun-1993 danl
        Now we handle the case where WNetSetLastError is called with a
        threadId that we don't know about.   This happens in the case where
        a sub-thread does a LoadLibrary on MPR.DLL.  We only get
        notification of the one thread attaching.  Yet other threads within
        that process may call the WinNet functions.

    17-Oct-1991 danl
        Created

--*/
//
// INCLUDES
//

#include "precomp.hxx"
#include "mprres.h"       // IDS_XERR_UNKNOWN

//=======================
// Data Structures
//=======================

typedef struct _ERROR_RECORD {
    struct  _ERROR_RECORD   *Prev;
    struct  _ERROR_RECORD   *Next;
    DWORD                   ThreadId;
    DWORD                   ErrorCode;
    LPTSTR                  ErrorText;      // This is an allocated buffer
    LPTSTR                  ProviderName;   // This is an allocated buffer
} ERROR_RECORD, *LPERROR_RECORD;


//=======================
// MACROS/DEFINES
//=======================

#define FIND_END_OF_LIST(record)    while(record->Next != NULL) {   \
                                        record=record->Next;        \
                                    }

#define REMOVE_FROM_LIST(record)    record->Prev->Next = record->Next;      \
                                    if (record->Next != NULL) {             \
                                        record->Next->Prev = record->Prev;  \
                                    }

#define ADD_TO_LIST(record, newRec) FIND_END_OF_LIST(record)    \
                                    record->Next = newRec;      \
                                    newRec->Prev = record;      \
                                    newRec->Next = NULL;

//
// The string (in English) is 44 characters long (+1 for the NULL)
//
#define UNKNOWN_ERROR_LENGTH    80


//=======================
// GLOBALS
//=======================

extern HMODULE  hDLL;    // DLL instance handle

//
// Local Functions
//

LPERROR_RECORD
MprAllocErrorRecord(
    VOID);

LPERROR_RECORD
MprFindErrorRecord(
    VOID);


//
// Global Data Structures
//

ERROR_RECORD        MprErrorRecList;    // Initialized to zeros by loader
CRITICAL_SECTION    MprErrorRecCritSec; // Initialized in mprinit.cxx



DWORD
WNetGetLastErrorW(
    OUT     LPDWORD lpError,
    OUT     LPWSTR  lpErrorBuf,
    IN      DWORD   nErrorBufLen,
    OUT     LPWSTR  lpNameBuf,
    IN      DWORD   nNameBufLen
    )

/*++

Routine Description:

    This function allows users to obtain the error code and accompanying
    text when they receive a WN_EXTENDED_ERROR in response to a WNet API
    function call.

Arguments:

    lpError - This is a pointer to the location that will receive the
        error code.

    lpErrorBuf - This points to a buffer that will receive the null
        terminated string describing the error.

    nErrorBufLen - This value that indicates the size (in characters) of
        lpErrorBuf.
        If the buffer is too small to receive an error string, the
        string will simply be truncated.  (it is still guaranteed to be
        null terminated).  A buffer of at least 256 bytes is recommended.

    lpNameBuf - This points to a buffer that will receive the name of
        the provider that raised the error.

    nNameBufLen - This value indicates the size (in characters) of lpNameBuf.
        If the buffer is too small to receive an error string, the
        string will simply be truncated.  (it is still guaranteed to be
        null terminated).

Return Value:

    WN_SUCCESS - if the call was successful.

    WN_BAD_POINTER - One or more of the passed in pointers is bad.

    WN_DEVICE_ERROR - This indicates that the threadID for the current
        thread could not be found in that table anywhere.  This should
        never happen.

--*/
{
    LPERROR_RECORD  errorRecord;
    DWORD           nameStringLen;
    DWORD           textStringLen;
    DWORD           status = WN_SUCCESS;

    //
    // Screen the parameters as best we can.
    //
    __try {
        //
        // If output buffers are provided, Probe them.
        //

        *lpError = WN_SUCCESS;

        if (IsBadWritePtr(lpErrorBuf, nErrorBufLen * sizeof(WCHAR)) ||
            IsBadWritePtr(lpNameBuf,  nNameBufLen  * sizeof(WCHAR)))
        {
            status = WN_BAD_POINTER;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetGetLastError:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS) {
        return(status);
    }

    //
    // Get the current thread's error record.
    //
    errorRecord = MprFindErrorRecord();

    if (errorRecord != NULL) {
        //
        // The record was found in the linked list.
        // See if there is a buffer to put data into.
        //
        if (nErrorBufLen > 0) {
            //
            // Check to see if there is error text to return.
            // If not, indicate a 0 length string.
            //
            if(errorRecord->ErrorText == NULL) {
                *lpErrorBuf = L'\0';
            }
            else {
                //
                // If the error text won't fit into the user buffer, fill it
                // as best we can, and NULL terminate it.
                //
                textStringLen = wcslen(errorRecord->ErrorText);

                if(nErrorBufLen < textStringLen + 1) {
                    textStringLen = nErrorBufLen - 1;
                }

                //
                // textStringLen now contains the number of characters we
                // will copy without the NULL terminator.
                //
                wcsncpy(lpErrorBuf, errorRecord->ErrorText, textStringLen);
                *(lpErrorBuf + textStringLen) = L'\0';
            }
        }

        //
        // If there is a Name Buffer to put the provider into, then...
        //
        if (nNameBufLen > 0) {
            //
            // See if the Provider Name will fit in the user buffer.
            //
            nameStringLen = errorRecord->ProviderName ?
                 (wcslen(errorRecord->ProviderName) + 1) :
                 1 ;

            //
            // If the user buffer is smaller than the required size,
            // set up to copy the smaller of the two.
            //
            if(nNameBufLen < nameStringLen + 1) {
                nameStringLen = nNameBufLen - 1;
            }

            if (errorRecord->ProviderName) {
                wcsncpy(lpNameBuf, errorRecord->ProviderName, nameStringLen);
                *(lpNameBuf + nameStringLen) = L'\0';
            }
            else {
                *lpNameBuf = L'\0';
            }
        }
        *lpError = errorRecord->ErrorCode;

        return(WN_SUCCESS);
    }
    else {

        //
        // If we get here, a record for the current thread could not be found.
        //
        *lpError = WN_SUCCESS;
        if (nErrorBufLen > 0) {
            *lpErrorBuf = L'\0';
        }
        if (nNameBufLen > 0) {
            *lpNameBuf  = L'\0';
        }
        return(WN_SUCCESS);
    }
}


VOID
WNetSetLastErrorW(
    IN  DWORD   err,
    IN  LPWSTR  lpError,
    IN  LPWSTR  lpProvider
    )

/*++

Routine Description:

    This function is used by Network Providers to set extended errors.
    It saves away the error information in a "per thread" data structure.
    This function also calls SetLastError with the WN_EXTENDED_ERROR.

Arguments:

    err - The error that occured.  This may be a Windows defined error,
        in which case LpError is ignored.  or it may be ERROR_EXTENDED_ERROR
        to indicate that the provider has a network specific error to report.

    lpError - String describing a network specific error.

    lpProvider - String naming the network provider raising the error.

Return Value:

    none


--*/
{
    DWORD           status = WN_SUCCESS;
    LPERROR_RECORD  errorRecord;

    //
    // Set the extended error status that tells the user they need to
    // call WNetGetLastError to obtain further information.
    //
    SetLastError(WN_EXTENDED_ERROR);

    //
    // Get the Error Record for the current thread.
    //
    errorRecord = MprFindErrorRecord();

    //
    // if there isn't a record for the current thread, then add it.
    //
    if (errorRecord == NULL)
    {
        errorRecord = MprAllocErrorRecord();

        if (errorRecord == NULL)
        {
            MPR_LOG0(ERROR,"WNetSetLastError:Could not allocate Error Record\n");
            return;
        }
    }

    //
    // Update the error code in the error record.  At the same time,
    // free up any old strings since they are now obsolete, and init
    // the pointer to NULL.  Also set the ProviderName pointer in the
    // ErrorRecord to point to the provider's name.
    //

    errorRecord->ErrorCode = err;

    LocalFree(errorRecord->ProviderName);
    errorRecord->ProviderName = NULL;

    LocalFree(errorRecord->ErrorText);
    errorRecord->ErrorText = NULL;

    //
    // Allocate memory for the provider name.
    //
    __try {
        errorRecord->ProviderName = (WCHAR *) LocalAlloc(LPTR,
                                                         (wcslen(lpProvider) + 1) * sizeof(WCHAR));
    }
    __except (MPR_EXCEPTION_FILTER) {
        //
        // We have a problem with lpProvider.
        //
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetSetLastError:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS) {
        return;
    }

    if (errorRecord->ProviderName == NULL) {
        //
        // Unable to allocate memory for the Provider Name for the error
        // record.
        //
        MPR_LOG(ERROR,
            "WNetSetLastError:Unable to allocate mem for ProviderName\n",0);
        return;
    }

    //
    // Copy the string to the newly allocated buffer.
    //
    wcscpy(errorRecord->ProviderName, lpProvider);

    //
    //  Allocate memory for the storage of the error text.
    //
    __try {
        errorRecord->ErrorText = (WCHAR *) LocalAlloc(LPTR,
                                                      (wcslen(lpError) + 1) * sizeof(WCHAR));
    }
    __except (MPR_EXCEPTION_FILTER) {
        //
        // We have a problem with lpError.
        //
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetSetLastError:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }
    if (status != WN_SUCCESS) {
        errorRecord->ErrorText = NULL;
    }

    if (errorRecord->ErrorText == NULL) {

        //
        // If we were unsuccessful in allocating for the ErrorText, then
        // abort.  The ErrorText Pointer has already been set to null.
        //
        MPR_LOG(ERROR,"WNetSetLastError:Unable to Alloc for ErrorText %d\n",
            GetLastError());

        return;
    }

    //
    // Copy the error text into the newly allocated buffer.
    //
    wcscpy(errorRecord->ErrorText, lpError);
    return;
}

LPERROR_RECORD
MprFindErrorRecord(
    VOID)

/*++

Routine Description:

    Looks through the linked list of ErrorRecords in search of one for
    the current thread.

Arguments:

    none

Return Value:

    Returns LPERROR_RECORD if an error record was found.  Otherwise, it
    returns NULL.

--*/
{
    LPERROR_RECORD  errorRecord;
    DWORD           CurrentThreadId = GetCurrentThreadId();

    EnterCriticalSection(&MprErrorRecCritSec);
    for (errorRecord = MprErrorRecList.Next;
         errorRecord != NULL;
         errorRecord = errorRecord->Next)
    {
        if (errorRecord->ThreadId == CurrentThreadId)
        {
            break;
        }
    }
    LeaveCriticalSection(&MprErrorRecCritSec);
    return(errorRecord);
}


LPERROR_RECORD
MprAllocErrorRecord(
    VOID)

/*++

Routine Description:

    This function allocates and initializes an Error Record for the
    current thread.  Then it places the error record in the global
    MprErrorRecList.
    Even if the thread exits, the record is not freed until the DLL unloads.
    This is OK because this function is called only if a provider calls
    WNetSetLastError, which is rare.

Arguments:

    none

Return Value:

    TRUE - The operation completed successfully

    FALSE - An error occured in the allocation.

Note:


--*/
{
    LPERROR_RECORD  record;
    LPERROR_RECORD  errorRecord;

    //
    //  Allocate memory for the storage of the error message
    //  and add the record to the linked list.
    //
    errorRecord = (LPERROR_RECORD)LocalAlloc(LPTR,sizeof (ERROR_RECORD));

    if (errorRecord == NULL) {
        MPR_LOG1(ERROR,"MprAllocErrorRecord:LocalAlloc Failed %d\n",
        GetLastError());
        return NULL;
    }

    //
    // Initialize the error record
    //
    errorRecord->ThreadId = GetCurrentThreadId();
    errorRecord->ErrorCode = WN_SUCCESS;
    errorRecord->ErrorText = NULL;

    //
    // Add the record to the linked list.
    //
    EnterCriticalSection(&MprErrorRecCritSec);

    record = &MprErrorRecList;
    ADD_TO_LIST(record, errorRecord);

    LeaveCriticalSection(&MprErrorRecCritSec);

    return errorRecord;
}


VOID
MprFreeAllErrorRecords(
    VOID)

/*++

Routine Description:

    This function is called when the DLL is unloading due to a FreeLibrary
    call.  It frees all the error records (for all threads) that have been
    created since the DLL was loaded.  If there is a pointer to a text string
    in a record, the buffer for that string is freed also.

Arguments:


Return Value:


Note:


--*/
{
    LPERROR_RECORD nextRecord;

    EnterCriticalSection(&MprErrorRecCritSec);

    for (LPERROR_RECORD record = MprErrorRecList.Next;
         record != NULL;
         record = nextRecord)
    {
        MPR_LOG1(TRACE,"MprFreeErrorRecord: Freeing Record for thread 0x%x\n",
            record->ThreadId);

        LocalFree(record->ErrorText);
        LocalFree(record->ProviderName);

        nextRecord = record->Next;

        LocalFree(record);
    }

    MprErrorRecList.Next = NULL;

    LeaveCriticalSection(&MprErrorRecCritSec);
}


DWORD
MultinetGetErrorTextW(
    OUT     LPWSTR  lpErrorTextBuf OPTIONAL,
    IN OUT  LPDWORD lpnErrorBufSize,
    OUT     LPWSTR  lpProviderNameBuf OPTIONAL,
    IN OUT  LPDWORD lpnNameBufSize
    )

/*++

Routine Description:

    This is an internal interface between the shell and the MPR.  It
    combines the work of calling GetLastError and WNetGetLastError into
    one call.  It returns the text for the last error that occurred in
    a WNet API in the current thread.  The error text could have been
    customized by the provider calling WNetSetLastError.

Arguments:

    lpErrorTextBuf - Pointer to buffer that will receive a null-terminated
        string describing the error.  May be NULL if not required.

    lpnErrorBufSize - On entry, indicates the size (in characters) of
        lpErrorTextBuf.  A buffer of at least 256 bytes is recommended.
        If the buffer is too small for the error string, the string will
        simply be truncated (it is still guaranteed to be null terminated).
        May be NULL if lpErrorTextBuf is NULL.

    lpProviderNameBuf - This points to a buffer that will receive the name
        of the provider that raised the error, if it is known.  May be NULL
        if not required.

    lpnNameBufSize - This value indicates the size (in characters) of
        lpProviderNameBuf.  If the buffer is too small for the provider
        name, the name will simply be truncated (it is still guaranteed to
        be null terminated).  May be NULL if lpProviderNameBuf is NULL.

Return Value:

    WN_SUCCESS - if the call was successful.

    WN_BAD_POINTER - One or more of the passed in pointers is bad.

    Other errors from WNetGetLastErrorW or FormatMessageW.

Differences from Win 95:

    The provider name is returned as an empty string except in cases when
    the error was set by calling WNetSetLastError.

    Win 95 implements the feature that the caller can call other Win32 APIs
    before calling this API without losing the last error from the last
    WNet API.  This is not implemented here.  The caller must preserve the
    last error by calling GetLastError after the WNet API and SetLastError
    before MultinetGetErrorText.

    Win 95 gives providers the ability to customize error strings for
    standard Win32 error codes by calling NPSSetCustomText.  We do not.

--*/
{
    DWORD status = WN_SUCCESS;
    DWORD nErrorBufSize = 0;
    DWORD nNameBufSize = 0;

    //
    // Probe output buffers, and initialize to empty strings
    //

    if (ARGUMENT_PRESENT(lpErrorTextBuf))
    {
        if (IS_BAD_WCHAR_BUFFER(lpErrorTextBuf, lpnErrorBufSize))
        {
            status = WN_BAD_POINTER;
        }
        else
        {
            nErrorBufSize = *lpnErrorBufSize;
            if (nErrorBufSize > 0)
            {
                lpErrorTextBuf[0] = L'\0';
            }
        }
    }

    if (ARGUMENT_PRESENT(lpProviderNameBuf))
    {
        if (IS_BAD_WCHAR_BUFFER(lpProviderNameBuf, lpnNameBufSize))
        {
            status = WN_BAD_POINTER;
        }
        else
        {
            nNameBufSize = *lpnNameBufSize;
            if (nNameBufSize > 0)
            {
                lpProviderNameBuf[0] = L'\0';
            }
        }
    }

    if (status != WN_SUCCESS)
    {
        return status;
    }


    //
    // Get the last error that occurred in this thread
    //
    DWORD   LastError = GetLastError(); // last error in this thread
    DWORD   ErrorCode = LastError;      // message id to retrieve
    LPWSTR  ErrorText = NULL;           // error text to return
    LPWSTR  ProviderName = NULL;        // provider name to return
    BOOL    bFreeErrorText = FALSE;     // whether to call LocalFree

    //
    // If it's an extended error, look in this thread's error record for
    // the actual error code and strings
    //
    if (LastError == WN_EXTENDED_ERROR)
    {
        LPERROR_RECORD errorRecord = MprFindErrorRecord();

        if (errorRecord)
        {
            ErrorCode = errorRecord->ErrorCode;
            ErrorText = errorRecord->ErrorText;
            ProviderName = errorRecord->ProviderName;
        }
        else
        {
            // No error record found.
            // Either someone called SetLastError(WN_EXTENDED_ERROR) without
            // calling WNetSetErrorText, or an error record couldn't be
            // allocated because of lack of memory.
            // We'll return the standard message for WN_EXTENDED_ERROR.
            MPR_LOG0(ERROR,"MultinetGetErrorTextW:Couldn't retrieve extended error\n");
        }
    }

    WCHAR   Buffer[UNKNOWN_ERROR_LENGTH] = L"";

    //
    // Compute the final error text
    //
    if (ARGUMENT_PRESENT(lpErrorTextBuf))
    {
        //
        // If it wasn't an extended error, or we didn't get a custom error
        // string from WNetGetLastError, load the standard message for the
        // error code.
        //
        if (ErrorText == NULL)
        {
            if (FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM |        // get msg from system
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let system alloc buffer
                    FORMAT_MESSAGE_IGNORE_INSERTS,      // no parms in msg
                    NULL,               // no source module or buffer
                    ErrorCode,          // message id
                    0,                  // use default language id
                    (LPWSTR) &ErrorText,// pointer to buffer for message
                    nErrorBufSize,      // min num of chars to allocate
                    NULL                // message parameters (none)
                    ))
            {
                bFreeErrorText = TRUE;  // ErrorText was allocated by the system
            }
            else
            {
                //
                // Couldn't get a message from the system, so use a catch-all
                //
                int cch = LoadString(hDLL,
                                     IDS_XERR_UNKNOWN,
                                     Buffer,
                                     LENGTH(Buffer));

                //
                // If this fails, up the value of UNKNOWN_ERROR_LENGTH
                //
                ASSERT(cch > 0 && cch < LENGTH(Buffer));

                ErrorText = Buffer;
            }
        }

        ASSERT (ErrorText != NULL);

        //
        // Decide whether to copy the error text to the caller's buffer
        //
        DWORD ReqLen = wcslen(ErrorText) + 1 ;
        if (ReqLen > nErrorBufSize)
        {
            *lpnErrorBufSize = ReqLen;
            status = WN_MORE_DATA;
        }
    }

    //
    // Compute final provider name, decide whether to copy to caller's buffer
    //
    if (ARGUMENT_PRESENT(lpProviderNameBuf))
    {
        if (ProviderName == NULL)
        {
            ProviderName = L"";
        }

        DWORD ReqLen = wcslen(ProviderName) + 1;
        if (ReqLen > nNameBufSize)
        {
            *lpnNameBufSize = ReqLen;
            status = WN_MORE_DATA;
        }
    }

    //
    // Copy strings
    //
    if (status == WN_SUCCESS)
    {
        if (ARGUMENT_PRESENT(lpErrorTextBuf))
        {
            wcscpy(lpErrorTextBuf, ErrorText);
        }

        if (ARGUMENT_PRESENT(lpProviderNameBuf))
        {
            wcscpy(lpProviderNameBuf, ProviderName);
        }
    }

    //
    // Free buffer allocated by FormatMessage
    //
    if (bFreeErrorText)
    {
        LocalFree(ErrorText);
    }

    //
    // FormatMessage, LocalFree, or other APIs we may have called from this API,
    // could have changed the last error, so restore it now.
    //
    SetLastError(LastError);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\mprdata.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mprdata.h

Abstract:

    Contains data structures and function prototypes that are internal to
    MPR.

Author:

    Dan Lafferty (danl)     07-Sept-1991

Environment:

    User Mode -Win32

Revision History:

    05-May-1999     jschwart
        Make provider addition/removal dynamic

    01-Mar-1994     Danl
        Created a separate location for the Credential Managers GetCaps()
        function.  This way if a provider has both a credential manager
        dll and a network dll, we will be able to direct calls to the
        correct GetCaps() function.

    07-Jan-1993     Danl
        Add NPLogonNotify and NPPasswordChangeNotify and AuthentDllName
        to PROVIDER structure.  Also added CREDENTIAL_TYPE InitClass.

    04-Aug-1992     chuckc
        added MprEnterLoadLibCritSect, MprLeaveLoadLibCritSect.

    07-Sept-1991    danl
        created

--*/

//
// Includes
//


//=======================
// Data Structures
//=======================
typedef struct _PROVIDER {
    NETRESOURCE             Resource;
    DWORD                   Type;           // WNNC_NET_MSNet, WNNC_NET_LanMan, WNNC_NET_NetWare
    HMODULE                 Handle;         // Handle to the provider DLL.
    LPTSTR                  DllName;        // set to NULL after loaded.
    HMODULE                 AuthentHandle;  // Handle to authenticator DLL.
    LPTSTR                  AuthentDllName; // Authenticator Dll.
    DWORD                   InitClass;      // Network or Authentication provider.
    DWORD                   ConnectCaps;    // Cached result of GetCaps(WNNC_CONNECTION)
    DWORD                   ConnectFlagCaps;// Cached result of GetCaps(WNNC_CONNECTION_FLAGS)
    PF_NPAddConnection      AddConnection;
    PF_NPAddConnection3     AddConnection3;
    PF_NPGetReconnectFlags  GetReconnectFlags;
    PF_NPCancelConnection   CancelConnection;
    PF_NPGetConnection      GetConnection;
    PF_NPGetConnection3     GetConnection3;
    PF_NPGetUser            GetUser;
    PF_NPOpenEnum           OpenEnum;
    PF_NPEnumResource       EnumResource;
    PF_NPCloseEnum          CloseEnum;
    PF_NPGetCaps            GetCaps;
    PF_NPGetDirectoryType   GetDirectoryType;
    PF_NPDirectoryNotify    DirectoryNotify;
    PF_NPPropertyDialog     PropertyDialog;
    PF_NPGetPropertyText    GetPropertyText;
    PF_NPSearchDialog       SearchDialog;
    PF_NPFormatNetworkName  FormatNetworkName;
    PF_NPLogonNotify            LogonNotify;
    PF_NPPasswordChangeNotify   PasswordChangeNotify;
    PF_NPGetCaps            GetAuthentCaps;
    PF_NPFMXGetPermCaps     FMXGetPermCaps;
    PF_NPFMXEditPerm        FMXEditPerm;
    PF_NPFMXGetPermHelp     FMXGetPermHelp;
    PF_NPGetUniversalName   GetUniversalName;
    PF_NPGetResourceParent  GetResourceParent;
    PF_NPGetResourceInformation     GetResourceInformation;
    PF_NPGetConnectionPerformance   GetConnectionPerformance;
}PROVIDER, *LPPROVIDER;


//=======================
// MACROS
//=======================

#define IS_EMPTY_STRING(pch) ( !pch || !*(pch) )

#define LENGTH(array)   (sizeof(array)/sizeof((array)[0]))

#define INIT_IF_NECESSARY(level,status)     ASSERT(MPRProviderLock.Have());     \
                                            if(!(GlobalInitLevel & level)) {    \
                                                status = MprLevel2Init(level);  \
                                                if (status != WN_SUCCESS) {     \
                                                    SetLastError(status);       \
                                                    return(status);             \
                                                }                               \
                                            }

#define MPR_IS_INITIALIZED(level)       (GlobalInitLevel & level ## _LEVEL)

#define ASSERT_INITIALIZED(level)       ASSERT(MPR_IS_INITIALIZED(level) && \
                                               MPRProviderLock.Have());

#define MPR_EXCEPTION_FILTER            (GetExceptionCode() == STATUS_POSSIBLE_DEADLOCK ? \
                                             EXCEPTION_CONTINUE_SEARCH : EXCEPTION_EXECUTE_HANDLER)

//=======================
// INLINE FUNCTIONS
//=======================

inline void
PROBE_FOR_WRITE(
    LPDWORD pdw
    )
// WARNING: This function can throw an exception.  It must be called from
// within a try-except block.
{
    *(volatile DWORD *)pdw = *(volatile DWORD *)pdw;
}

inline BOOL
IS_BAD_BYTE_BUFFER(
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize    // in bytes
    )
// WARNING: This function can throw an exception.  It must be called from
// within a try-except block.
{
    PROBE_FOR_WRITE(lpBufferSize);
    return IsBadWritePtr(lpBuffer, *lpBufferSize);
}

inline BOOL
IS_BAD_WCHAR_BUFFER(
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize    // in Unicode characters
    )
// WARNING: This function can throw an exception.  It must be called from
// within a try-except block.
{
    PROBE_FOR_WRITE(lpBufferSize);
    return IsBadWritePtr(lpBuffer, *lpBufferSize * sizeof(WCHAR));
}

//=======================
// CONSTANTS
//=======================
#define DEFAULT_MAX_PROVIDERS   25

// Bit masks for remembering error codes
#define BAD_NAME        0x00000001
#define NO_NET          0x00000002
#define NOT_CONNECTED   0x00000004
#define NOT_CONTAINER   0x00000008
#define NO_DEVICES      0x00000010
#define OTHER_ERRS      0xFFFFFFFF

#define REDIR_DEVICE    0x00000001
#define REMOTE_NAME     0x00000002
#define LOCAL_NAME      REDIR_DEVICE

#define DA_READ         0x00000001
#define DA_WRITE        0x00000002
#define DA_DELETE       0x00000004

//
// Timeout values for restoring connections and notifying
// Credential Managers.
//
#define DEFAULT_WAIT_TIME       60000   // Default timeout if providers don't
                                        // specify.

#define MAX_ALLOWED_WAIT_TIME   300000  // Max timeout a provider can specify

#define RECONNECT_SLEEP_INCREMENT 3000  // number of seconds to sleep

#define PROVIDER_WILL_NOT_START 0x00000000 // The provider will not be starting
#define NO_TIME_ESTIMATE        0xffffffff // The provider cannot predict the
                                           // amount of time it will take to
                                           // start.

#define NET_PROVIDER_KEY         TEXT("system\\CurrentControlSet\\Control\\NetworkProvider")
#define RESTORE_WAIT_VALUE       TEXT("RestoreTimeout")
#define RESTORE_CONNECTION_VALUE TEXT("RestoreConnection")
#define DEFER_CONNECTION_VALUE   TEXT("DeferConnection")


//
// GlobalInitLevels & InitClasses
//
// NOTE:  The WN_???_CLASS values are bit masks.
//
//  GlobalInitLevel
#define FIRST_LEVEL             0x00000001
#define NETWORK_LEVEL           0x00000002
#define CREDENTIAL_LEVEL        0x00000004
#define NOTIFIEE_LEVEL          0x00000008
//
//
//  InitClasses
#define NETWORK_TYPE        WN_NETWORK_CLASS
#define CREDENTIAL_TYPE     (WN_CREDENTIAL_CLASS | WN_PRIMARY_AUTHENT_CLASS)


// The path in the registry for user's persistent connections is found in
// the following key:
//
//      "\HKEY_CURRENT_USER\Network"
//
//  Subkeys of the network section listed by local drive names.  These
//  keys contain the following values:
//      RemotePath, Type, ProviderName, UserName
//
//              d:  RemotePath = \\cyclops\scratch
//                  Type = RESOURCE_TYPE_DISK
//                  ProviderName = LanMan
//                  UserName = Ernie

#define CONNECTION_KEY_NAME           TEXT("Network")

#define REMOTE_PATH_NAME              TEXT("RemotePath")
#define USER_NAME                     TEXT("UserName")
#define PROVIDER_NAME                 TEXT("ProviderName")
#define PROVIDER_TYPE                 TEXT("ProviderType")
#define PROVIDER_FLAGS                TEXT("ProviderFlags")
#define DEFER_FLAGS                   TEXT("DeferFlags")
#define CONNECTION_TYPE               TEXT("ConnectionType")

#define PRINT_CONNECTION_KEY_NAME     TEXT("Printers\\RestoredConnections")

//=======================
// Global data
//=======================
extern LPPROVIDER       GlobalProviderInfo;   // pArray of PROVIDER Structures
extern DWORD            GlobalNumProviders;
extern DWORD            MprDebugLevel;
extern HANDLE           MprLoadLibSemaphore;  // used to protect DLL handles
extern volatile DWORD   GlobalInitLevel;
extern CRITICAL_SECTION MprErrorRecCritSec;
extern WCHAR            g_wszEntireNetwork[40];

//==========================
// Functions from support.c
//==========================


VOID
MprDeleteIndexArray(
    VOID
    );

DWORD
MprFindCallOrder(
    IN  LPTSTR      NameInfo,
    OUT LPDWORD     *IndexArrayPtr,
    OUT LPDWORD     IndexArrayCount,
    IN  DWORD       InitClass
    );

DWORD
MprDeviceType(
    IN  LPCTSTR DeviceName
    );

BOOL
MprGetProviderIndex(
    IN  LPCTSTR ProviderName,
    OUT LPDWORD IndexPtr
    );

LPPROVIDER
MprFindProviderByName(
    IN  LPCWSTR ProviderName
    );

LPPROVIDER
MprFindProviderByType(
    IN  DWORD   ProviderType
    );

DWORD
MprFindProviderForPath(
    IN  LPWSTR  lpPathName,
    OUT LPDWORD lpProviderIndex
    );

VOID
MprInitIndexArray(
    LPDWORD     IndexArray,
    DWORD       NumEntries
    );

VOID
MprEndCallOrder(
    VOID
    );

VOID
MprFreeAllErrorRecords(
    VOID
    );

BOOL
MprNetIsAvailable(
    VOID) ;

//=========================
// Functions from mprreg.c
//=========================

BOOL
MprOpenKey(
    HKEY        hKey,
    LPTSTR      lpSubKey,
    PHKEY       phKeyHandle,
    DWORD       desiredAccess
    );

BOOL
MprGetKeyValue(
    HKEY    KeyHandle,
    LPTSTR  ValueName,
    LPTSTR  *ValueString
    );

BOOL
MprGetKeyDwordValue(
    IN  HKEY    KeyHandle,
    IN  LPCWSTR ValueName,
    OUT DWORD * Value
    );

LONG
MprGetKeyNumberValue(
    IN  HKEY    KeyHandle,
    IN  LPCWSTR ValueName,
    IN  LONG    Default
    );

DWORD
MprEnumKey(
    IN  HKEY    KeyHandle,
    IN  DWORD   SubKeyIndex,
    OUT LPTSTR  *SubKeyName,
    IN  DWORD   MaxSubKeyNameLen
    );

BOOL
MprGetKeyInfo(
    IN  HKEY    KeyHandle,
    OUT LPDWORD TitleIndex OPTIONAL,
    OUT LPDWORD NumSubKeys,
    OUT LPDWORD MaxSubKeyLen,
    OUT LPDWORD NumValues OPTIONAL,
    OUT LPDWORD MaxValueLen
    );

DWORD MprGetPrintKeyInfo(HKEY    KeyHandle,
                         LPDWORD NumValueNames,
                         LPDWORD MaxValueNameLength,
                         LPDWORD MaxValueLen) ;

BOOL
MprFindDriveInRegistry (
    IN  LPCTSTR DriveName,
    OUT LPTSTR  *RemoteName
    );

DWORD
MprSaveDeferFlags(
    IN HKEY     RegKey,
    IN DWORD    DeferFlags
    );

DWORD
MprSetRegValue(
    IN  HKEY    KeyHandle,
    IN  LPTSTR  ValueName,
    IN  LPCTSTR ValueString,
    IN  DWORD   LongValue
    );

DWORD
MprCreateRegKey(
    IN  HKEY    BaseKeyHandle,
    IN  LPCTSTR KeyName,
    OUT PHKEY   KeyHandlePtr
    );

BOOL
MprReadConnectionInfo(
    IN  HKEY            KeyHandle,
    IN  LPCTSTR         DriveName,
    IN  DWORD           Index,
    OUT LPDWORD         ProviderFlags,
    OUT LPDWORD         DeferFlags,
    OUT LPTSTR          *UserNamePtr,
    OUT LPNETRESOURCEW  NetResource,
    OUT HKEY            *SubKeyHandleOut,
    IN  DWORD           MaxSubKeyLen
    );

VOID
MprForgetRedirConnection(
    IN LPCTSTR  lpName
    );

DWORD
MprForgetPrintConnection(
    IN LPTSTR   lpName
    );

BOOL
MprGetRemoteName(
    IN      LPTSTR  lpLocalName,
    IN OUT  LPDWORD lpBufferSize,
    OUT     LPTSTR  lpRemoteName,
    OUT     LPDWORD lpStatus
    ) ;

//=========================
// Functions from strbuf.c
//=========================

BOOL
NetpCopyStringToBuffer (
    IN LPWSTR String OPTIONAL,
    IN DWORD CharacterCount,
    IN LPWSTR FixedDataEnd,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    );

//=========================
// Other functions
//=========================

VOID
MprCheckProviders(
    VOID
    );

DWORD
MprLevel1Init(
    VOID
    );

DWORD
MprLevel2Init(
    DWORD   InitClass
    );

DWORD
MprEnterLoadLibCritSect (
    VOID
    ) ;

DWORD
MprLeaveLoadLibCritSect (
    VOID
    ) ;

VOID
MprClearString (
    LPWSTR  lpString
    ) ;

DWORD
MprGetConnection (
    IN      LPCWSTR lpLocalName,
    OUT     LPWSTR  lpRemoteName,
    IN OUT  LPDWORD lpBufferSize,
    OUT     LPDWORD lpProviderIndex OPTIONAL
    ) ;

DWORD
OutputStringToAnsiInPlace(
    IN  LPWSTR      UnicodeIn
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\mprbase.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mprbase.cxx

Abstract:

    Contains implementations of base classes that supply common code for
    Multi-Provider Router operations.
    Contains:
        CMprOperation::Perform
        CRoutedOperation::ValidateParameters
        CRoutedOperation::GetResult

Author:

    Anirudh Sahni (anirudhs)     11-Oct-1995

Environment:

    User Mode -Win32

Notes:

Revision History:

    11-Oct-1995     AnirudhS
        Created.

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/

//
// Includes
//

#include "precomp.hxx"
#include <malloc.h>     // _alloca

//
// External Globals and Statics
//
extern  DWORD       GlobalNumActiveProviders;

CRoutedOperation::CPathCache CRoutedOperation::_PathCache;

//
// Defines
//


//
// Local Function Prototypes
//



//+-------------------------------------------------------------------------
//
//  Function:   CMprOperation::Perform
//
//  Purpose:    See header file
//
//  History:    11-Oct-95 AnirudhS  Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CMprOperation::Perform()
{
    DWORD status = WN_SUCCESS;

    __try
    {
        //
        // Ask the derived class to validate the API parameters
        //
        status = ValidateParameters();
    }
    __except (MPR_EXCEPTION_FILTER)
    {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG2(ERROR,"CMprOperation(%s): Unexpected exception %#lx\n",_OpName,status);
        }

        status = WN_BAD_POINTER;
    }

    if (status == WN_SUCCESS)
    {
        //
        // Ask the derived class to perform the operation
        //
        status = GetResult();
    }

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
    }

    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::Perform
//
//  Purpose:    See header file
//
//  History:    27-May-99 jschwart  Created.
//
//  Notes:      Since the CMprOperation should have no knowledge of
//              providers, deal with provider-related locking/checking
//              in the CRoutedOperation class, which is meant for
//              APIs that use the providers.
//
//--------------------------------------------------------------------------

DWORD CRoutedOperation::Perform(BOOL fCheckProviders)
{
    //
    // If an API that uses this class creates another instance of the class
    // (e.g., CGetConnectionPerformance uses CGetConnection), there needs
    // to be a way to prevent the second call from trying to acquire the
    // exclusive lock while the original call holds the shared lock.
    //
    if (fCheckProviders)
    {
        MprCheckProviders();
    }

    CProviderSharedLock    PLock;

    return CMprOperation::Perform();
}


//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::ValidateParameters
//
//  Purpose:    See header file
//
//  History:    11-Oct-95 AnirudhS  Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRoutedOperation::ValidateParameters()
{
    //
    // Ask the derived class to validate the API parameters.
    // Also, if the API caller passed in a specific NP name, the derived
    // class should pass it back here, to be validated here.  The provider
    // is looked up and stored in _pSpecifiedProvider.
    // If the API caller passed in a remote name that can be used as a
    // hint for routing, the derived class should pass it back here.  A
    // pointer to it is stored in _RemoteName and used later, in GetResult(),
    // to help pick an efficient provider routing order.
    //
    LPCWSTR pwszProviderName = NULL;
    LPCWSTR pwszRemoteName   = NULL;
    LPCWSTR pwszLocalName    = NULL;

    ASSERT(MPRProviderLock.Have());

    DWORD status = ValidateRoutedParameters(&pwszProviderName,
                                            &pwszRemoteName,
                                            &pwszLocalName);

    if (status == WN_SUCCESS)
    {
        //
        // Optimization: Store away the drive type.  In GetResult(),
        // we need only call the providers if the local name is
        // a remote drive.  _uDriveType is initialized to DRIVE_REMOTE
        //

        if (! IS_EMPTY_STRING(pwszLocalName) && pwszLocalName[1] == L':')
        {
            WCHAR wszRootPath[] = L" :\\";

            wszRootPath[0] = pwszLocalName[0];
            _uDriveType = GetDriveType(wszRootPath);
        }

        // This probes pwszRemoteName as well as saving its length
        RtlInitUnicodeString(&_RemoteName, pwszRemoteName);

        if (! IS_EMPTY_STRING(pwszProviderName))
        {
            //
            // Level 1 init for MprFindProviderByName
            //
            if (!(GlobalInitLevel & FIRST_LEVEL)) {
                status = MprLevel1Init();
                if (status != WN_SUCCESS) {
                   return status;
                }
            }

            _pSpecifiedProvider = MprFindProviderByName(pwszProviderName);
            if (_pSpecifiedProvider == NULL)
            {
                return WN_BAD_PROVIDER;
            }
        }
    }

    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::GetResult
//
//  Purpose:    See header file
//
//  History:    11-Oct-95 AnirudhS  Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRoutedOperation::GetResult()
{
    DWORD       status = WN_SUCCESS;
    LPPROVIDER *ProviderArray;

    //
    // Only call the providers if it's a remote drive
    //

    if (_uDriveType != DRIVE_REMOTE)
    {
        return WN_NOT_CONNECTED;
    }

    INIT_IF_NECESSARY(NETWORK_LEVEL, status);

    //
    // If there are no providers, return NO_NETWORK
    //
    if (GlobalNumActiveProviders == 0)
    {
        return WN_NO_NETWORK;
    }

    // Array of pointers into the GlobalProviderInfo array.
    DWORD       numProviders;

    __try
    {
        ProviderArray = (LPPROVIDER *) _alloca(GlobalNumProviders * sizeof(LPPROVIDER));
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = WN_OUT_OF_MEMORY;
    }

    if (status != WN_SUCCESS)
    {
        return status;
    }

    //
    // Find the list of providers to call for this request.
    //
    if (_pSpecifiedProvider != NULL)
    {
        //
        // The caller requested a particular Provider
        //
        ProviderArray[0] = _pSpecifiedProvider;
        numProviders = 1;
    }
    else
    {
        //
        // A Provider name was not specified.  Therefore, we must
        // create an ordered list and pick the best one.
        //
        status = FindCallOrder(
                        &_RemoteName,
                        ProviderArray,
                        &numProviders,
                        NETWORK_TYPE
                        );
        if (status != WN_SUCCESS)
        {
            return status;
        }
    }

    //
    // Loop through the list of providers until one answers the request,
    // or the list is exhausted.
    //
    DWORD statusFlag = 0;               // Mask of combined error returns
    DWORD FirstNetPathError = WN_SUCCESS;     // First NO_NET or BAD_NAME error
    DWORD FirstSignificantError = WN_SUCCESS; // First "other" error, used in
                                              // aggressive routing only

    status = WN_NOT_SUPPORTED;          // Returned if no providers respond

    for (DWORD i=0; i<numProviders; i++)
    {
        _LastProvider = ProviderArray[i];

        if (_pProviderFunction != NULL &&
            _LastProvider->*_pProviderFunction == NULL)
        {
            //
            // The provider doesn't supply the required entry point.
            //
            status = WN_NOT_SUPPORTED;
        }
        else
        {
            //
            // Ask the derived class to try the provider.
            //
            __try
            {
                MPR_LOG2(ROUTE, "%s: trying %ws ...\n",
                         OpName(), _LastProvider->Resource.lpProvider);
                status = TestProvider(_LastProvider);
                MPR_LOG(ROUTE, "... provider returned %lu\n", status);
            }
            __except (MPR_EXCEPTION_FILTER)
            {
                status = GetExceptionCode();
                MPR_LOG(ROUTE, "... provider threw EXCEPTION %#lx\n", status);
                if (status != EXCEPTION_ACCESS_VIOLATION)
                {
                    MPR_LOG3(ERROR,
                            "%s: Unexpected Exception %#lx "
                                "calling %ws provider\n",
                            OpName(), status,
                            _LastProvider->Resource.lpProvider);
                }
                status = WN_BAD_POINTER;
            }
        }

        //
        // Decide whether to stop trying other providers and return the
        // error immediately, or continue trying other providers.
        // There are two algorithms for routing to providers, called
        // "lazy routing" and "aggressive routing".  In lazy routing,
        // we always stop routing, unless the error was an insignificant
        // one (such as WN_BAD_NETNAME) indicating that the call may be
        // meant for some other provider.  In aggressive routing, we
        // always continue routing, except on a few special errors (such
        // as WN_SUCCESS).
        //
        switch (status)
        {

        //////////////////////////////////////////////////////////////
        // Always stop routing on these errors, even if routing     //
        // aggressively                                             //
        //////////////////////////////////////////////////////////////

        case WN_SUCCESS:
        case WN_MORE_DATA:
            //
            // The provider successfully operated on this path, so add it
            // to the cache...
            //
            _PathCache.AddEntry(&_RemoteName, _LastProvider);
            //
            // ... and fall through
            //
        case WN_BAD_POINTER:
        case WN_ALREADY_CONNECTED:
        case WN_CANCEL:
            goto CleanExit;


        //////////////////////////////////////////////////////////////
        // Always continue routing on these errors                  //
        // Classify them so that if we later decide to return one   //
        // of them to the caller, we pick the most sensible one     //
        //////////////////////////////////////////////////////////////

        case WN_NOT_SUPPORTED:
            //
            // Ignore the error
            //
            break;

        case WN_NO_MORE_DEVICES:
            statusFlag |= NO_DEVICES;
            break;

        case WN_NOT_CONNECTED:
            statusFlag |= NOT_CONNECTED;
            break;

        case WN_NOT_CONTAINER:
            statusFlag |= NOT_CONTAINER;
            break;

        case WN_NO_NETWORK:
        case WN_FUNCTION_BUSY:
        case WN_NO_NET_OR_BAD_PATH:
        case WN_NOT_LOGGED_ON:
            statusFlag |= NO_NET;
            if (FirstNetPathError == WN_SUCCESS)
            {
                FirstNetPathError = status;
            }
            break;

        case WN_BAD_NETNAME:
        case ERROR_BAD_NETPATH:
        case WN_BAD_LOCALNAME:
        case WN_BAD_VALUE:
        case WN_BAD_LEVEL:
        case ERROR_REM_NOT_LIST:
            statusFlag |= BAD_NAME;
            if (FirstNetPathError == WN_SUCCESS)
            {
                FirstNetPathError = status;
            }
            break;


        //////////////////////////////////////////////////////////////
        // On other errors, stop routing if lazy, continue if       //
        // aggressive                                               //
        //////////////////////////////////////////////////////////////

        default:
            if (_AggressiveRouting)
            {
                // Remember the first one of these errors.  It will take
                // precedence over other errors.
                if (FirstSignificantError == WN_SUCCESS)
                {
                    FirstSignificantError = status;
                }
                break;

                // Note that if multiple providers return WN_EXTENDED_ERROR,
                // we'll return the error reported by the last one rather
                // than the first.
            }
            else
            {
                // Return this error immediately
                goto CleanExit;
            }
        } // switch
    } // for all providers

    //
    // If a specific provider was tried then return the error from that provider.
    // Otherwise, concoct the best return code from the errors returned.
    //
    if (numProviders > 1)
    {
        if (FirstSignificantError != WN_SUCCESS)
        {
            status = FirstSignificantError;
        }
        else if (statusFlag & NO_DEVICES)
        {
            status = WN_NO_MORE_DEVICES;
        }
        else if (statusFlag & NOT_CONNECTED)
        {
            status = WN_NOT_CONNECTED;
        }
        else if (statusFlag & NOT_CONTAINER)
        {
            status = WN_NOT_CONTAINER;
        }
        else if (statusFlag & (NO_NET | BAD_NAME))
        {
            if ((statusFlag & (NO_NET | BAD_NAME)) == (NO_NET | BAD_NAME))
            {
                //
                // Mix of special errors occured.
                // Pass back the combined error message.
                //
                status = WN_NO_NET_OR_BAD_PATH;
            }
            else
            {
                status = FirstNetPathError;
            }
        }
        else
        {
            ASSERT(status == WN_NOT_SUPPORTED);
        }
    }

CleanExit:

    MPR_LOG2(ROUTE, "CRoutedOperation(%s): returning %lu\n\n", OpName(), status);

    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::CPathCache::Construct
//
//  Purpose:    Constructor, called explicitly to avoid dependence on CRT
//
//  History:    09-Apr-96 AnirudhS  Created.
//
//--------------------------------------------------------------------------

void CRoutedOperation::CPathCache::Construct()
{
    InitializeCriticalSection(&_Lock);
    RtlZeroMemory(_RecentPaths, sizeof(_RecentPaths));
    InitializeListHead(&_ListHead);
    _NumFree = PATH_CACHE_SIZE;
}


//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::CPathCache::Destroy
//
//  Purpose:    Destructor, called explicitly to avoid dependence on CRT
//
//  History:    09-Apr-96 AnirudhS  Created.
//
//--------------------------------------------------------------------------

void CRoutedOperation::CPathCache::Destroy()
{
    //
    // This is really needed only if the DLL is being unloaded because of
    // a FreeLibrary call, not if the process is exiting
    //
    for (DWORD i = _NumFree; i < PATH_CACHE_SIZE; i++)
    {
        LocalFree(_RecentPaths[i].Path.Buffer);
    }
    DeleteCriticalSection(&_Lock);
}


//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::CPathCache::AddEntry
//
//  Purpose:    Add an entry to the cache
//
//  History:    09-Apr-96 AnirudhS  Created.
//
//--------------------------------------------------------------------------

void CRoutedOperation::CPathCache::AddEntry(
    const UNICODE_STRING * Path,
    LPPROVIDER      Provider
    )
{
    if (Path->Length == 0 || Path->Length >= (MAX_PATH*sizeof(WCHAR)))
    {
        //
        // Don't add empty or too-long paths to the cache
        //
        return;
    }

    ASSERT(Path->MaximumLength == Path->Length + sizeof(UNICODE_NULL));

    EnterCriticalSection(&_Lock);

    CacheEntry *pEntry = NULL;  // Entry to write

    //
    // See if there's a matching path string in the cache already
    //
    for (PLIST_ENTRY pLinks = _ListHead.Flink;
         pLinks != &_ListHead;
         pLinks = pLinks->Flink)
    {
        pEntry = CONTAINING_RECORD(pLinks, CacheEntry, Links);

        if (RtlEqualUnicodeString(&pEntry->Path, (PUNICODE_STRING) Path, TRUE))
        {
            break;
        }

        pEntry = NULL;
    }

    if (pEntry == NULL)
    {
        //
        // No matching entry.
        // If there's a free entry in the array, use it.
        // Otherwise overwrite the last entry in the list.
        //
        if (_NumFree > 0)
        {
            _NumFree--;
            pEntry = &_RecentPaths[_NumFree];

            //
            // Add this new entry to the list.
            //
            InsertHeadList(&_ListHead, &pEntry->Links);
        }
        else
        {
            ASSERT(!IsListEmpty(&_ListHead));
            pEntry = CONTAINING_RECORD(_ListHead.Blink, CacheEntry, Links);
        }

        //
        // Copy the path string into the cache.  Re-use the string buffer,
        // unless it's too small.
        //
        if (pEntry->Path.MaximumLength < Path->MaximumLength)
        {
            //
            // Re-allocate the string buffer.  Allocate twice as much space
            // as needed, but never more than MAX_PATH Unicode characters.
            // Note, here we know that MaximumLength <= MAX_PATH characters.
            //
            HLOCAL NewBuffer = LocalAlloc(
                        0,
                        min(Path->MaximumLength * 2, MAX_PATH * sizeof(WCHAR))
                        );
            if (NewBuffer == NULL)
            {
                //
                // Couldn't allocate.  Don't add to the cache.
                // (If it was unused, this cache entry is lost forever.
                // CODEWORK try to recover it in this case?)
                //
                goto CleanExit;
            }

            LocalFree(pEntry->Path.Buffer);
            pEntry->Path.Buffer = (PWSTR) NewBuffer;
            pEntry->Path.MaximumLength = (USHORT)LocalSize(NewBuffer);
        }

        RtlCopyUnicodeString(&pEntry->Path, (PUNICODE_STRING) Path);
    }

    //
    // Remember the provider in the cache.  (This overwrites any previously
    // remembered provider for the path.)
    //
    pEntry->Provider = Provider;
    MPR_LOG2(ROUTE, "cache: cached %ws for %ws\n", Provider->Resource.lpProvider, Path->Buffer);

    //
    // Move this entry to the front of the list, if it isn't there already.
    //
    if (_ListHead.Flink != &pEntry->Links)
    {
        RemoveEntryList(&pEntry->Links);
        InsertHeadList(&_ListHead, &pEntry->Links);
    }

CleanExit:

    LeaveCriticalSection(&_Lock);
}


//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::CPathCache::FindEntry
//
//  Purpose:    Search for an entry in the cache
//
//  History:    09-Apr-96 AnirudhS  Created.
//
//--------------------------------------------------------------------------

LPPROVIDER CRoutedOperation::CPathCache::FindEntry(
    const UNICODE_STRING * Path
    )
{
    if (Path->Length == 0)
    {
        return NULL;
    }

    ASSERT(Path->MaximumLength == Path->Length + sizeof(UNICODE_NULL));

    EnterCriticalSection(&_Lock);

    //
    // Search forward in the list for a matching path string
    //
    LPPROVIDER Provider = NULL;
    for (PLIST_ENTRY pLinks = _ListHead.Flink;
         pLinks != &_ListHead;
         pLinks = pLinks->Flink)
    {
        CacheEntry *pEntry = CONTAINING_RECORD(pLinks, CacheEntry, Links);

        if (RtlEqualUnicodeString(&pEntry->Path, (PUNICODE_STRING) Path, TRUE))
        {
            Provider = pEntry->Provider;

            //
            // Move this entry to the front of the list, if it isn't there already.
            //
            if (_ListHead.Flink != &pEntry->Links)
            {
                RemoveEntryList(&pEntry->Links);
                InsertHeadList(&_ListHead, &pEntry->Links);
            }

            break;
        }
    }

    LeaveCriticalSection(&_Lock);

    MPR_LOG2(ROUTE, "cache: found %ws for %ws\n",
                    (Provider ? Provider->Resource.lpProvider : L"no cached provider"),
                    Path->Buffer);

    return Provider;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\mprdbg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mprdbg.h

Abstract:

    Contains definitions used in debugging the messenger service.

Author:

    Dan Lafferty    (danl)  07-Oct-1991

Environment:

    User Mode -Win32

Revision History:

    22-Jul-1992     Danl
        Added different debug macros based on the number of parameters.
        Make the macros resolve to nothing when DBG is not defined.

    24-May-1999     jschwart
        Have debug macros print out process number

--*/

#ifndef _MPRDBG_INCLUDED
#define _MPRDBG_INCLUDED

//
// Information levels used in switch statements.
//
#define LEVEL_0     0L
#define LEVEL_1     1L
#define LEVEL_2     2L

//
// Debug macros and constants.
//
#if DBG

#define DEBUG_STATE 1
#define STATIC

#else

#define DEBUG_STATE 0
#define STATIC static

#endif

extern DWORD    MprDebugLevel;

//
// The following allow debug print syntax to look like:
//
//   MPR_LOG(TRACE, "An error occured %x\n",status)
//

#if DBG

//
// debugging macros.
//
#define MPR_LOG0(level,string)                  \
    if( MprDebugLevel & (DEBUG_ ## level)){     \
        (VOID) DbgPrint("[MPR] %lx: " string, GetCurrentProcessId()); \
    }
#define MPR_LOG1(level,string,var)              \
    if( MprDebugLevel & (DEBUG_ ## level)){     \
        (VOID) DbgPrint("[MPR] %lx: " string,GetCurrentProcessId(),var); \
    }
#define MPR_LOG2(level,string,var1,var2)        \
    if( MprDebugLevel & (DEBUG_ ## level)){     \
        (VOID) DbgPrint("[MPR] %lx: " string,GetCurrentProcessId(),var1,var2); \
    }
#define MPR_LOG3(level,string,var1,var2,var3)   \
    if( MprDebugLevel & (DEBUG_ ## level)){     \
        (VOID) DbgPrint("[MPR] %lx: " string,GetCurrentProcessId(),var1,var2,var3); \
    }
#define MPR_LOG(level,string,var)               \
    if( MprDebugLevel & (DEBUG_ ## level)){     \
        (VOID) DbgPrint("[MPR] %lx: " string,GetCurrentProcessId(),var);   \
    }

#else  // DBG

#define MPR_LOG0(level,string)
#define MPR_LOG1(level,string,var)
#define MPR_LOG2(level,string,var1,var2)
#define MPR_LOG3(level,string,var1,var2,var3)
#define MPR_LOG(level,string,var)

#endif // DBG



#define DEBUG_NONE      0x00000000
#define DEBUG_ERROR     0x00000001
#define DEBUG_TRACE     0x00000002      // Miscellaneous trace info
#define DEBUG_LOCKS     0x00000004      // Multi-thread data locks
#define DEBUG_PS        0x00000008      // Thread and Process information
#define DEBUG_RESTORE   0x00000010      // Restore Connection information
#define DEBUG_CNOTIFY   0x00000020      // Connection Notify information
#define DEBUG_ANSI      0x00000040      // Ansi API thunks
#define DEBUG_ROUTE     0x00000080      // Routing of calls among providers

#define DEBUG_ALL       0xffffffff

#endif // _MPRDBG_INCLUDED

//
// Function Prototypes
//

VOID
PrintKeyInfo(
    HKEY  key);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\mprinit.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MPRINIT.CXX

Abstract:

    Contains the DLL initialization routine for the Mutiple-Provider
    Router.  The following are names of functions in this file:

        MprDllInit
        MprCheckProviders
        MprLevel1Init
        MprLevel2Init
        MprProcessDetach
        GetProviderCapabilities
        MprFreeGlobalProviderInfo
        MprMakeServiceKeyName
        MprGetOrderedList
        MprGetNumProviders
        MprExtractProviderInfo

    The router distinguishes between Providers and ActiveProviders.  It
    maintains global information about GlobalNumProviders and
    GlobalNumActiveProviders.  The two counts can be distinguished in the
    following ways:

    GlobalNumProviders - This determines the size of the provider database
        that mpr maintains.  This count reflects the number of providers for
        which we were able to obtain registry information.  A provider is
        added to the list if we are able to obtain its name and the
        name of its dll routine.

    GlobalNumActiveProviders - A provider becomes active when we are able
        to successfully load the dll, and obtain at least one entry point
        for it.


Author:

    Dan Lafferty (danl) 6-Oct-1991

Environment:

    User Mode - Win32

Notes:


Revision History:

    05-May-1999     jschwart
        Make provider addition/removal dynamic

    09-Aug-1996     AnirudhS
        Disabled thread library calls, since they cause extra paging and
        are 100% useless.  Fixed memory leak of error records on DLL unload.

    02-Mar-1995     AnirudhS
        Add test for WNNC_ENUM_CONTEXT capability.

    09-Aug-1994     Danl
        Only do PROCESS_DETACH cleanup work if the PROCESS_DETACH occurs
        because of a FreeLibrary.

    01-Mar-1994     Danl
        Created a seperate location for the Credential Managers GetCaps()
        function.  This way if a provider has both a credential manager
        dll and a network dll, we will be able to direct calls to the
        correct GetCaps() function.

    08-Apr-1993     Danl
        MprLevel1Init:  Created a tempOrderedString which will be used
        for incrementing through the buffer.  This way we can Free
        orderedString because it still points to the beginning of the buffer.

    24-Nov-1992     Danl
        Modified many things to allow for initialization to occur on
        first call rather than at DLL initialization time.  Also coded
        for the future possibility of Authentication Providers.

    02-Nov-1992     Danl
        Allow MPR to continue operation even if there are no providers, or
        if the network is not installed and provider info is not available
        in the registry.  Removed MprHack.

    31-Aug-1992     Danl
        Removed use of the list of active providers.  Now all providers
        in the Provider Order list are loaded at init time.

    06-Oct-1991     Danl
        Created

--*/

//
// Includes
//
#include "precomp.hxx"
#include <debugfmt.h>   // FORMAT_LPTSTR
#include "mprres.h"     // IDS_NETROOT
#include "connify.h"    // MprConnectNotifyInit()


//
// Local Function Prototypes
//

BOOL
MprProcessAttach(
    HANDLE DllHandle
    );

BOOL
MprProcessDetach(
    DWORD  dwInitLevel
    );

BOOL
GetProviderCapabilities(
    LPPROVIDER  Provider
    );

VOID
MprFreeGlobalProviderInfo(VOID);

BOOL
MprGetOrderedList(
    HKEY    ControlRootKey,
    LPTSTR  *OrderString
    );

DWORD
MprMakeServiceKeyName(
    IN OUT  LPTSTR  *OrderedNamePtr,
    OUT     LPTSTR  *NameBufferPtr,
    OUT     LPTSTR  *NamePtr
    );

DWORD
MprGetNumProviders(
    LPTSTR  OrderedString
    );

BOOL
MprExtractProviderInfo(
    HKEY        ProviderInfoKey,
    LPPROVIDER  Provider
    );

BOOL
MprInitializeProviderGlobals(
    VOID
    );

BOOL
MprGetLUIDDeviceMapsEnabled(
    PBOOL pResult
    );

//
// Constants
//
#define TEMP_SIZE       256

//
// Some registry path names
//
#define PROVIDER_KEY_NAME   TEXT("control\\NetworkProvider\\active")
#define PROVIDER_ORDER_KEY  TEXT("control\\NetworkProvider\\HwOrder")
#define SERVICES_KEY_NAME   TEXT("services\\")
#define SYSTEM_CONTROL_ROOT TEXT("system\\CurrentControlSet")
#define PROVIDER_PATH       TEXT("\\NetworkProvider")
#define VALUE_PATHNAME      TEXT("ProviderPath")
#define AUTHENT_PATHNAME    TEXT("AuthentProviderPath")
#define VALUE_CLASS         TEXT("Class")

//
// Defines for the DLL's init state
//
#define  MPR_PROVIDERLOCK_CREATED       0x00000001
#define  MPR_INITCRITSEC_CREATED        0x00000002
#define  MPR_ERRORCRITSEC_CREATED       0x00000004
#define  MPR_CACHE_CONSTRUCTED          0x00000008


//
// Global Data Structures
//

    LPPROVIDER          GlobalProviderInfo=NULL;   // A pointer to array of PROVIDER Structures
    DWORD               GlobalNumProviders=0;
    DWORD               GlobalNumActiveProviders=0;
    CRITICAL_SECTION    MprInitCritSec;
    HMODULE             hDLL;
    HANDLE              g_hProvidersChanged;       // Event set on provider addition/deletion
    HKEY                g_hProviderKey;            // Registry key of the provider list

    WCHAR               g_wszEntireNetwork[40];    // "Entire Network" string for top-level enum
    BOOL                g_LUIDDeviceMapsEnabled=FALSE; // LUID device map enabled/disabled

    //
    // GlobalInitLevel is a set of bit flags used to indicate how much
    // initialization work has been done.
    //
    volatile DWORD      GlobalInitLevel = 0;

    DWORD               MprDebugLevel;


extern "C"
BOOL
MprDllInit(
    IN  HINSTANCE   DllHandle,
    IN  DWORD       Reason,
    IN  PCONTEXT    pContext OPTIONAL
    )

/*++

Routine Description:

    This routine reads the registry to determine what network providers are
    available.  It then loads and initializes the Network Providers.  After
    this, a call is made to each of the providers to get a list of
    Capabilities (via WNetGetCaps).

Arguments:

    DllHandle - A handle for the DLL?

    Reason - The reason for which this routine is being called.  This might
        be one of the following:
            DLL_PROCESS_ATTACH
            DLL_THREAD_ATTACH
            DLL_THREAD_DETACH
            DLL_PROCESS_DETACH

    pContext - Pointer to a context structure


Return Value:


Note:


--*/
{
    //
    // We need to keep track of how far initialization went since
    // we may get called with DLL_PROCESS_DETACH if init fails and
    // don't want to clean up uninitialized data
    //
    static DWORD s_dwInitLevel;

    NTSTATUS Status;

    if (Reason == DLL_PROCESS_ATTACH) {

#if DBG == 1
        //
        // Read the debug message level from the registry
        //
        HKEY   MprKey;
        if (MprOpenKey(HKEY_LOCAL_MACHINE,
                   L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Mpr",
                   &MprKey,
                   0))
        {
            MprDebugLevel = (DWORD) MprGetKeyNumberValue(MprKey, L"DebugLevel", 0);

            RegCloseKey(MprKey);
        }
#endif

        //
        // create semaphore used to protect global data (DLL handles and
        // function pointers.
        //
        if ((MprLoadLibSemaphore = CreateSemaphore( NULL,1,1,NULL )) == NULL)
        {
            MPR_LOG1(ERROR,
                     "MprDllInit: CreateSemaphore FAILED %d\n",
                     GetLastError());

            return FALSE ;
        }

        if (!MprInitializeProviderGlobals())
        {
            return FALSE;
        }

        s_dwInitLevel |= MPR_PROVIDERLOCK_CREATED;

        MPR_LOG2(PS,"Process %#lx (%ws) attached to the DLL\n",
                    GetCurrentProcessId(), GetCommandLineW());

        //
        // Save the DLL handle, to be used in LoadString
        //
        hDLL = DllHandle;

        //
        // Create the critical section to synchronize access to global
        // data when doing init on first call.
        //

        Status = RtlInitializeCriticalSection(&MprInitCritSec);

        if (!NT_SUCCESS(Status))
        {
            return FALSE;
        }

        s_dwInitLevel |= MPR_INITCRITSEC_CREATED;

        //
        // Initialize critical section that protects the Linked list of
        // Error Records.
        //
        //
        Status = RtlInitializeCriticalSection(&MprErrorRecCritSec);

        if (!NT_SUCCESS(Status))
        {
            return FALSE;
        }

        s_dwInitLevel |= MPR_ERRORCRITSEC_CREATED;

        CRoutedOperation::ConstructCache();
        s_dwInitLevel |= MPR_CACHE_CONSTRUCTED;

        DisableThreadLibraryCalls(DllHandle);
    }
    else if (Reason == DLL_PROCESS_DETACH) {

        //
        // Only do cleanup if detach was due to a FreeLibrary() call.
        // In this case pContext will be NULL.  Otherwise, this gets called
        // because the process is terminating.  We will let the process
        // cleanup code clean up everything.
        //
        if (pContext == NULL) {
            //
            // close handle for semaphore
            //
            CloseHandle(MprLoadLibSemaphore) ;
            MprLoadLibSemaphore = NULL ;

            MPR_LOG(PS,"Process %#lx detached from the DLL\n",GetCurrentProcessId());
            MPR_LOG(TRACE,"******************* CLEAN-UP  ********************\n",0);

            MprProcessDetach(s_dwInitLevel);

            if (s_dwInitLevel & MPR_CACHE_CONSTRUCTED)
            {
                CRoutedOperation::DestroyCache();
            }

            MPR_LOG(TRACE,"***************** CLEAN_UP END  ******************\n",0);
        }
    }
    else if (Reason == DLL_THREAD_ATTACH) {
        // This should never happen
        MPR_LOG2(PS,"Thread %#lx.%#lx attached to the DLL\n",
                    GetCurrentProcessId(), GetCurrentThreadId());
    }
    else if (Reason == DLL_THREAD_DETACH) {
        // This should never happen
        MPR_LOG2(PS,"Thread %#lx.%#lx detached from the DLL\n",
                    GetCurrentProcessId(), GetCurrentThreadId());
    }
    return(TRUE);

}


BOOL
MprInitializeProviderGlobals(
    VOID
    )
{
    g_hProvidersChanged = CreateEvent(NULL,    // Default security
                                      TRUE,    // Manual reset
                                      FALSE,   // Starts out unsignaled
                                      NULL);   // No name

    if (g_hProvidersChanged == NULL)
    {
        MPR_LOG1(ERROR,
                 "MprInitializeProviderGlobals: CreateEvent FAILED %d\n",
                 GetLastError());

        return FALSE;
    }

    //
    // NOTE:  Key handle must be global since RegNotifyChangeKeyValue
    //        fires when the handle is closed (done in MprProcessDetach)
    //
    if (!MprOpenKey(HKEY_LOCAL_MACHINE,
                    SYSTEM_CONTROL_ROOT L"\\" PROVIDER_ORDER_KEY,
                    &g_hProviderKey,
                    0))
    {
        MPR_LOG1(ERROR,
                 "MprInitializeProviderGlobals: MprOpenKey FAILED %d\n",
                 GetLastError());

        CloseHandle(g_hProvidersChanged);
        return FALSE;
    }

    if (RegNotifyChangeKeyValue(g_hProviderKey,              // Key
                                FALSE,                       // Don't watch subtree
                                REG_NOTIFY_CHANGE_LAST_SET,  // Watch for value changes
                                g_hProvidersChanged,         // Event to signal
                                TRUE)                        // Asynchronous

            != ERROR_SUCCESS)
    {
        //
        // If this call fails, we won't notice provider additions/deletions
        //
        MPR_LOG1(ERROR,
                 "MprInitializeProviderGlobals: RegNotifyChangeKeyValue FAILED %d\n",
                 GetLastError());
    }

    //
    // Check if LUID device maps are Enabled
    //
    MprGetLUIDDeviceMapsEnabled( &g_LUIDDeviceMapsEnabled );

    //
    // Create the lock that restricts access to the provider array
    //

    if (!MPRProviderLock.Initialize("P", "Provider"))
    {
        MPR_LOG0(ERROR,
                 "MprInitializeProviderGlobals: MPRProviderLock.Initialize FAILED\n");

        RegCloseKey(g_hProviderKey);
        CloseHandle(g_hProvidersChanged);
        return FALSE;
    }

    return TRUE;
}


VOID
MprCheckProviders(
    VOID
    )
{
    ASSERT(!MPRProviderLock.Have());

    if (WaitForSingleObject(g_hProvidersChanged, 0) == WAIT_OBJECT_0)
    {
        //
        // The providers have changed -- grab the exclusive lock and
        // check again to avoid a race condition.  Note that there
        // is no need to acquire the MprInitCritsec since an API must
        // always acquire the critsec (via INIT_IF_NECESSARY) AFTER it
        // acquires the shared provider lock.
        //
        CProviderExclusiveLock    PLock;

        if (WaitForSingleObject(g_hProvidersChanged, 0) == WAIT_OBJECT_0)
        {
            //
            // Still set -- this is the first thread here.  Free up the provider
            // info and reset the init level so the next INIT_IF_NECESSARY call
            // will reinitialize the providers as necessary.
            //
            MPR_LOG0(TRACE,
                     "MprCheckProviders: Provider list changed -- reinitializing\n");

            MprDeleteIndexArray();
            MprFreeGlobalProviderInfo();

            GlobalInitLevel = 0;

            //
            // Flush the provider cache
            //
            CRoutedOperation::DestroyCache();
            CRoutedOperation::ConstructCache();

            ResetEvent(g_hProvidersChanged);

            if (RegNotifyChangeKeyValue(g_hProviderKey,              // Key
                                        FALSE,                       // Don't watch subtree
                                        REG_NOTIFY_CHANGE_LAST_SET,  // Watch for value changes
                                        g_hProvidersChanged,         // Event to signal
                                        TRUE)                        // Asynchronous

                    != ERROR_SUCCESS)
            {
                //
                // If this call fails we won't notice provider additions/deletions
                //
                MPR_LOG1(ERROR,
                         "MprCheckProviders: RegNotifyChangeKeyValue FAILED %d\n",
                         GetLastError());
            }
        }
    }
}


DWORD
MprLevel1Init(
    VOID
    )

/*++

Routine Description:

    This function looks into the registry to find the names of the providers
    and their associated DLLs.  A Global table of provider information is
    then allocated (GlobalProviderInfo).  This table is an array of provider
    information structures.  The number of elements in the array is stored
    in GlobalNumProviders.

    If the provider is in the registry ORDERED list, then it is assumed that
    complete provider information is stored in the "services" section of
    the registry for that provider.  This provider information includes such
    things as the pathname for the provider dll, and the provider type.
    The information is stored in the provider structure for use by the
    MprLevel2Init routine.

Arguments:


Return Value:



Note:


--*/
{
    DWORD       status;
    LPPROVIDER  provider;
    DWORD       i;
    HKEY        controlRootKey;
    HKEY        providerInfoKey;
    LPTSTR      orderedString = NULL;
    LPTSTR      tempOrderedString;
    LPTSTR      nameBuffer = NULL;          // system\LanmanRedirector\NetworkProvider
    LPTSTR      providerIdString = NULL;    // points to provider id in nameBuffer
    BOOL        oneInitialized = FALSE;


    EnterCriticalSection(&MprInitCritSec);
    MPR_LOG(TRACE,"******************* LEVEL 1 INIT ********************\n",0);
    //
    // If this level of initialization is already complete, then return.
    //
    if (GlobalInitLevel & FIRST_LEVEL) {
        LeaveCriticalSection(&MprInitCritSec);
        return(WN_SUCCESS);
    }

    //
    // This function had better be called first and only once
    //
    ASSERT(GlobalInitLevel == 0);

    //
    // Get a handle to the "current" services part of the registry
    //

    if(!MprOpenKey(
                HKEY_LOCAL_MACHINE,     // hKey
                SYSTEM_CONTROL_ROOT,    // lpSubKey
                &controlRootKey,        // Newly Opened Key Handle
                DA_READ)) {             // Desired Access

        MPR_LOG(ERROR,"MprLevel1Init: MprOpenKey (System) Error\n",0);
        LeaveCriticalSection(&MprInitCritSec);
        return(WN_NO_NETWORK);
    }
    MPR_LOG2(TRACE,"OpenKey %ws,0x%lx\n ",SYSTEM_CONTROL_ROOT,controlRootKey);

    //
    // Obtain the ordered list information.
    // (the orderedString buffer is allocated here)
    //
    // If this fails, we assume that there are no providers.
    //

    if (!MprGetOrderedList(controlRootKey, &orderedString)) {
        MPR_LOG(ERROR,"Could not get the ordered list of providers\n",0);
        RegCloseKey(controlRootKey);
        LeaveCriticalSection(&MprInitCritSec);
        return(WN_NO_NETWORK);
    }

    MPR_LOG1(TRACE,"ProviderOrderString = %ws\n",orderedString);

    GlobalNumProviders = MprGetNumProviders(orderedString);


    //
    // Allocate the database in which to store Provider Information.
    // This is to be an array of PROVIDER structures.  Memory is set
    // to zero so that all the provider entry points will be initialized to
    // zero.
    //

    GlobalProviderInfo = (LPPROVIDER) LocalAlloc(
                            LPTR,
                            sizeof(PROVIDER) * GlobalNumProviders);

    if (GlobalProviderInfo == NULL) {
        status = GetLastError();
        MPR_LOG(ERROR,"MprLevel1Init: provider array LocalAlloc Failed %d\n",
            status);
        LocalFree(orderedString);
        GlobalNumProviders = 0;
        RegCloseKey(controlRootKey);
        LeaveCriticalSection(&MprInitCritSec);
        return(status);
    }

    provider = GlobalProviderInfo;

    tempOrderedString = orderedString;

    for(i=0; i<GlobalNumProviders; i++,provider++) {

        //
        // Build the Service key name for the next Service/Driver.
        // NOTE:  This function allocates a nameBuffer.
        //
        status = MprMakeServiceKeyName(
                &tempOrderedString,
                &nameBuffer,
                &providerIdString );

        if (status != WN_SUCCESS) {
            goto SkipProvider;
        }

        //
        // Create the path name to the provider information in the
        // service's tree.
        //

        wcscat(nameBuffer, PROVIDER_PATH);

        //
        // Open the provider portion of that service/driver's
        // node in the service tree.
        //

        if (!MprOpenKey( controlRootKey, nameBuffer, &providerInfoKey, DA_READ)){
            LocalFree(nameBuffer);
            goto SkipProvider;
        }

        MPR_LOG1(TRACE,"\n\t----%ws----\n",providerIdString);
        MPR_LOG3(TRACE,"\tOpenKey %ws,\n\t%ws\n,\t0x%lx\n",
            SYSTEM_CONTROL_ROOT,
            nameBuffer,
            providerInfoKey);


        //
        // Free the memory that was allocated for the name buffer.
        //

        LocalFree (nameBuffer);

        //
        // Get the data for the provider from the registry at the
        // location referenced by providerInfoKey.
        //

        if (!MprExtractProviderInfo(providerInfoKey, provider)) {

            MPR_LOG(TRACE,"CloseKey 0x%lx\n", providerInfoKey);
            RegCloseKey(providerInfoKey);
            goto SkipProvider;
        }

        //
        // Close the ProviderInfoKey.
        //

        MPR_LOG(TRACE,"CloseKey 0x%lx\n", providerInfoKey);
        RegCloseKey(providerInfoKey);

        //
        // We have information for at least one provider.
        //
        oneInitialized = TRUE;

SkipProvider:
        ;    // The complier needs to find something to go to.

    } // End For NumProviders

    MPR_LOG(TRACE,"CloseKey 0x%lx\n", controlRootKey);
    RegCloseKey(controlRootKey);

    if (orderedString != NULL) {
        LocalFree(orderedString);
    }

    GlobalInitLevel = FIRST_LEVEL;
    LeaveCriticalSection(&MprInitCritSec);

    if (oneInitialized == FALSE) {
        return(WN_NO_NETWORK);
    }
    return(WN_SUCCESS);
}

DWORD
MprLevel2Init(
    DWORD   InitLevel
    )
/*++

Routine Description:

    This routine initializes all providers of the class described by
    the InitLevel parameter.  We loop though all providers that meet
    this description, and load the dll and find the dll's function entry
    points.  If we were successful in getting this information for the
    provider, it will be added to our "active" list by having its provider
    index placed in the GlobalIndexArray (via MprInitIndexArray).


    NOTE:
    This routine can potentially be called once for each type of
    initialization that is supported.  For instance, it may be called for
    authentication initialization, and then called later for network
    initialization.
    Each time this routine is called, a new indexArray is created.
    After this array is filled in, it is merged with any existing
    indexArray left over from previous calls.  The merge is performed
    by MprInitIndexArray.  Locks on this array must be held in order to
    update it.

Arguments:

    InitLevel - This indicates the level of initialization.  This can be
        a NETWORK_LEVEL or CREDENTIAL_LEVEL initialization, or both.

Return Value:

    WN_SUCCESS - This is returned if we are able to obtain some entry point
        information for at least one provider.

    Otherwise, an appropriate error is returned.


--*/
{
    DWORD       status = WN_SUCCESS;
    LPPROVIDER  provider;
    DWORD       i;
    LPDWORD     indexArray = NULL;
    DWORD       numActive = 0;
    DWORD       InitClass = 0;

    //
    // Before we can do a level2 initialization, we must first check to
    // see if level 1 has been completed.
    //
    if (!(GlobalInitLevel & FIRST_LEVEL)) {
        status = MprLevel1Init();
        if (status != WN_SUCCESS) {
            return(status);
        }
    }

    EnterCriticalSection(&MprInitCritSec);
    MPR_LOG(TRACE,"******************* LEVEL 2 INIT ********************\n",0);

    //
    // If this level of initialization is already complete, then return.
    //
    if (GlobalInitLevel & InitLevel) {
        LeaveCriticalSection(&MprInitCritSec);
        return(WN_SUCCESS);
    }

    //
    // Translate InitLevel into an InitClass so it can be compared with the
    // provider class.
    //
    if (InitLevel & NETWORK_LEVEL)
    {
        InitClass |= NETWORK_TYPE;

        //
        // Load the "Entire Network" string (used by WNetEnumResource
        // for RESOURCE_CONNECTED).  Note that WNetEnumResource requires
        // only NETWORK_LEVEL initialization, so it's OK to load it
        // here and only here.
        //
        if (g_wszEntireNetwork[0] == L'\0')
        {
            int cch = LoadString(hDLL,
                                 IDS_NETROOT,
                                 g_wszEntireNetwork,
                                 LENGTH(g_wszEntireNetwork));
            ASSERT(cch > 0 && cch < LENGTH(g_wszEntireNetwork));
        }
    }
    if (InitLevel & CREDENTIAL_LEVEL)
    {
        InitClass |= CREDENTIAL_TYPE;
    }
    if (InitLevel & NOTIFIEE_LEVEL)
    {
        status = MprConnectNotifyInit();

        GlobalInitLevel |= InitLevel;
        LeaveCriticalSection(&MprInitCritSec);
        return(status);
    }

    provider = GlobalProviderInfo;

    //
    // Allocate storage for the ordered list of indices.  This storage is
    // freed by MprInitIndexArray.
    //
    indexArray = (LPDWORD) LocalAlloc(LPTR, sizeof(DWORD) * GlobalNumProviders);
    if (indexArray == NULL) {
        MPR_LOG(ERROR,"MprProcessAttach: indexArray LocalAlloc Failed %d\n",
            GetLastError());

        LeaveCriticalSection(&MprInitCritSec);
        return(GetLastError());
    }

    for(i=0; i<GlobalNumProviders; i++,provider++) {

        //
        // If this provider matches the init type for which we are
        // initializing, then load the library and get the entry points.
        // Then add the provider array index to the index array.
        //
        if (provider->InitClass & InitClass) {

            //
            // Load the DLL and free the memory for its name.
            //
            if (provider->AuthentDllName != NULL) {
                MPR_LOG1(TRACE,"MprLevel2Init: Loading %ws\n",provider->AuthentDllName);
                provider->AuthentHandle = LoadLibraryEx(
                                                provider->AuthentDllName,
                                                NULL,
                                                LOAD_WITH_ALTERED_SEARCH_PATH);
                if (provider->AuthentHandle == NULL) {
                    MPR_LOG(ERROR,"MprLevel2Init: LoadLibraryEx Failed %d\n",
                    GetLastError());
                }
                LocalFree(provider->AuthentDllName);
                provider->AuthentDllName = NULL;
            }
            if (provider->DllName != NULL) {
                MPR_LOG1(TRACE,"MprLevel2Init: Loading %ws\n",provider->DllName);
                provider->Handle = LoadLibraryEx(
                                            provider->DllName,
                                            NULL,
                                            LOAD_WITH_ALTERED_SEARCH_PATH);
                if (provider->Handle == NULL) {
                    MPR_LOG(ERROR,"MprLevel2Init: LoadLibraryEx Failed %d\n",
                    GetLastError());
                }

                //
                // Keep around the DLL name since we need to do another
                // LoadLibraryEx to refcount the DLL in WNetOpenEnum
                //
            }
            if ((provider->Handle != NULL) || (provider->AuthentHandle != NULL)) {
                MPR_LOG0(TRACE,"MprLevel2Init: LoadLibraryEx success\n");

                //
                // Obtain the various entry points for the library.
                // This is done based on the capabilities that are listed for the
                // provider.
                //

                if (GetProviderCapabilities(provider)) {
                    //
                    // Only providers for which we are able to successfully
                    // get the entry points are added to the active array.
                    //
                    // Since this provider information is now initialized, the
                    // provider is considered ACTIVE.  Put the index to the
                    // provider in the index array.
                    //

                    MPR_LOG1(TRACE,"MprLevel2Init: Successfully got "
                    "capabilities for %ws\n",provider->Resource.lpProvider);

                    indexArray[numActive] = i;
                    numActive++;
                }
            }
        } // End If InitLevel match
    } // End For NumProviders

    //
    // Store the information in this indexArray in the GlobalIndexArray.
    //

    MprInitIndexArray(indexArray, numActive);

    GlobalInitLevel |= InitLevel;
    LeaveCriticalSection(&MprInitCritSec);

    MPR_LOG(TRACE,"******************* END LEVEL 2 INIT ********************\n",0);
    return(WN_SUCCESS);
}


BOOL
MprProcessDetach(
    DWORD  dwInitLevel
    )

/*++

Routine Description:

    This function cleans up resources for a process when it detaches
    from the dll.

Arguments:

    none

Return Value:

    none

Note:


--*/
{
    MprDeleteIndexArray();
    MprFreeGlobalProviderInfo();
    GlobalNumProviders = 0;
    GlobalProviderInfo = NULL;

    if (dwInitLevel & MPR_INITCRITSEC_CREATED)
    {
        DeleteCriticalSection(&MprInitCritSec);
    }

    if (dwInitLevel & MPR_PROVIDERLOCK_CREATED)
    {
        RegCloseKey(g_hProviderKey);
        CloseHandle(g_hProvidersChanged);
        MPRProviderLock.Delete();
    }

    if (dwInitLevel & MPR_ERRORCRITSEC_CREATED)
    {
        MprFreeAllErrorRecords();
        DeleteCriticalSection(&MprErrorRecCritSec);
    }

    return(TRUE);
}



BOOL
GetProviderCapabilities(
    LPPROVIDER  Provider
    )

/*++

Routine Description:

    This function obtains the provider's capabilities and then gets the
    procedure entry point for all supported API.

Arguments:

    Provider - A pointer to a PROVIDER structure which will contain all
        information that must be maintained for a given provider.

Return Value:

    TRUE - If at least one capability is found for this provider.

    FALSE - If no capabilities are found for the provider.

History:

    Johnl   17-Jan-1992     Added Property dialog support

--*/

//
// The following macro is designed to work within the function
// GetProviderCapabilities().
//
#define GET_ADDRESS(apiName) Provider-> ## apiName = (PF_NP ## apiName) GetProcAddress(     \
                                                      Provider->Handle,      \
                                                      "NP"#apiName);         \
            if (Provider-> ## apiName == NULL) {                             \
                MPR_LOG(ERROR,                                               \
                    "GetProviderCapabilities: Can't get NP"#apiName " Address %d\n",\
                    GetLastError());                                         \
            }                                                                \
            else {                                                           \
                status = TRUE;                                               \
            }

#define GET_AUTH_ADDRESS(apiName) Provider-> ## apiName = (PF_NP ## apiName) GetProcAddress(  \
                                                      Provider->AuthentHandle, \
                                                      "NP"#apiName);           \
            if (Provider-> ## apiName == NULL) {                               \
                MPR_LOG(ERROR,                                                 \
                    "GetProviderCapabilities: Can't get NP"#apiName " Address %d\n",\
                    GetLastError());                                         \
            }                                                                \
            else {                                                           \
                status = TRUE;                                               \
            }

{
    DWORD   bitMask;
    BOOLEAN status=FALSE;


    GET_ADDRESS(GetCaps);
    if (status) {

        //
        // Get the Network Type
        //
        // CODEWORK:  Read the type from the registry when possible -- this
        // will allow us to avoid doing a Level 2 init in all the cases where
        // only the provider type is needed (e.g., MprFindProviderByType).
        //
        Provider->Type = Provider->GetCaps(WNNC_NET_TYPE);

        //
        // Reject providers that don't supply their type
        //
        if (Provider->Type == 0)
        {
            MPR_LOG(ERROR, "%ws provider reported a net type of 0\n",
                           Provider->Resource.lpProvider);
            ASSERT(!"Network provider didn't report its network type");
            return FALSE;
        }

        //
        // Does it support WNetGetUser?
        //
        bitMask = Provider->GetCaps(WNNC_USER);
        if (bitMask & WNNC_USR_GETUSER) {
            GET_ADDRESS(GetUser);
        }

        //
        // Connection Api Supported
        //
        bitMask = Provider->GetCaps(WNNC_CONNECTION);
        Provider->ConnectCaps = bitMask;

        if (bitMask & WNNC_CON_ADDCONNECTION) {
            GET_ADDRESS(AddConnection);
        }

        if (bitMask & WNNC_CON_ADDCONNECTION3) {
            DWORD   bitMask2;

            GET_ADDRESS(AddConnection3);
            GET_ADDRESS(GetReconnectFlags); // optional entry point

            //
            // Connection Api flags Supported
            //
            bitMask2 = Provider->GetCaps(WNNC_CONNECTION_FLAGS);

            if (bitMask2 == 0) {
                bitMask2 = WNNC_CF_DEFAULT;
            }
            bitMask2 &= WNNC_CF_MAXIMUM;

            Provider->ConnectFlagCaps = bitMask2;
        }

        if (bitMask & WNNC_CON_CANCELCONNECTION) {
            GET_ADDRESS(CancelConnection);
        }

        if (bitMask & WNNC_CON_GETCONNECTIONS) {
            GET_ADDRESS(GetConnection);
            GET_ADDRESS(GetConnection3);
            GET_ADDRESS(GetUniversalName);
        }

        if (bitMask & WNNC_CON_GETPERFORMANCE) {
            GET_ADDRESS(GetConnectionPerformance);
        }

        //
        // Enumeration Api Supported
        //
        bitMask = Provider->GetCaps(WNNC_ENUMERATION);

        if ((bitMask & WNNC_ENUM_GLOBAL) ||
            (bitMask & WNNC_ENUM_LOCAL) ||
            (bitMask & WNNC_ENUM_CONTEXT)) {
            GET_ADDRESS(OpenEnum);
            GET_ADDRESS(EnumResource);
            GET_ADDRESS(CloseEnum);
        }

        //
        // Admin Api Supported
        //
        bitMask = Provider->GetCaps(WNNC_ADMIN);

        if (bitMask & WNNC_ADM_GETDIRECTORYTYPE) {
            GET_ADDRESS(GetDirectoryType);
        }

        if (bitMask & WNNC_ADM_DIRECTORYNOTIFY) {
            GET_ADDRESS(DirectoryNotify);
        }

        //
        // Dialog API Support
        //
        bitMask = Provider->GetCaps(WNNC_DIALOG);

        if (bitMask & WNNC_DLG_PROPERTYDIALOG) {
            GET_ADDRESS(GetPropertyText);
            GET_ADDRESS(PropertyDialog);
        }

        if (bitMask & WNNC_DLG_SEARCHDIALOG) {
            GET_ADDRESS(SearchDialog);
        }

        if (bitMask & WNNC_DLG_FORMATNETWORKNAME) {
            GET_ADDRESS(FormatNetworkName);
        }

        if (bitMask & WNNC_DLG_PERMISSIONEDITOR) {
            GET_ADDRESS(FMXGetPermCaps);
            GET_ADDRESS(FMXEditPerm);
            GET_ADDRESS(FMXGetPermHelp);
        }

        if (bitMask & WNNC_DLG_GETRESOURCEPARENT) {
            GET_ADDRESS(GetResourceParent);
        }

        if (bitMask & WNNC_DLG_GETRESOURCEINFORMATION) {
            GET_ADDRESS(GetResourceInformation);
        }

    }
    else {
        if (Provider->GetAuthentCaps == NULL) {
            Provider->GetAuthentCaps = (PF_NPGetCaps)GetProcAddress(
                                        Provider->AuthentHandle,
                                        "NPGetCaps");
            if (Provider->GetAuthentCaps == NULL) {
                MPR_LOG(ERROR,
                    "GetProviderCapabilities: Can't get NPGetCaps %d\n",
                    GetLastError());
            }
            else {
                status = TRUE;
            }
        }

        //
        // If we couldn't get an address for GetCaps from either the
        // network provider dll or the authentication provider dll, then
        // we should return an error.  The rule is, this must be supported
        // by one of the providers.
        //
        if (status == FALSE) {
            return(FALSE);
        }
    }
    //
    // Get Authentication Provider entry points
    //
    if (Provider->InitClass & CREDENTIAL_TYPE) {
        if (Provider->AuthentHandle == NULL) {
            MPR_LOG0(TRACE,"GetProvCaps: CM provider in same DLL\n");
            GET_ADDRESS(LogonNotify);
            GET_ADDRESS(PasswordChangeNotify);
        }
        else {
            MPR_LOG0(TRACE,"GetProvCaps: CM provider in seperate DLL\n");
            GET_AUTH_ADDRESS(LogonNotify);
            GET_AUTH_ADDRESS(PasswordChangeNotify);

            if (Provider->GetAuthentCaps == NULL) {
                Provider->GetAuthentCaps = (PF_NPGetCaps)GetProcAddress(
                                            Provider->AuthentHandle,
                                            "NPGetCaps");
                if (Provider->GetAuthentCaps == NULL) {
                    MPR_LOG(ERROR,
                        "GetProviderCapabilities: Can't get NPGetCaps %d\n",
                        GetLastError());
                }
                else {
                    status = TRUE;
                }
            }
        }
    }

    return(status);
}



VOID
MprFreeGlobalProviderInfo(
    VOID
    )
/*++

Routine Description:

    This function walks through the array of provider structures, and
    frees up all the valid pointers to the provider name. Then if frees
    the GlobalProviderInfo array.

Arguments:

    none.

Return Value:

    none.

--*/
{
    LPPROVIDER  provider;
    DWORD       i;

    if (GlobalProviderInfo == NULL)
    {
        return;
    }

    provider = GlobalProviderInfo;

    //
    // Free all the valid pointers to the provider's name.
    //
    for(i = 0; i < GlobalNumProviders; i++, provider++)
    {
        MPR_LOG(TRACE, "Freeing Name for provider %d\n",i);

        if (provider->Handle != NULL)
        {
            MPR_LOG1(TRACE,
                     "Freeing Library for "FORMAT_LPTSTR" \n",
                     provider->Resource.lpProvider);

            FreeLibrary(provider->Handle);
        }

        LocalFree(provider->DllName);

        if (provider->AuthentHandle != NULL)
        {
            MPR_LOG1(TRACE,
                     "Freeing authentication library for "FORMAT_LPTSTR" \n",
                     provider->Resource.lpProvider);

            FreeLibrary(provider->AuthentHandle);
        }

        //
        // Should have been freed when the DLL was loaded
        //
        ASSERT(provider->AuthentDllName == NULL);

        LocalFree(provider->Resource.lpRemoteName);
    }

    //
    // Free the top level data structure and reinit the globals
    //
    MPR_LOG(TRACE, "Freeing GlobalProviderInfo\n",0);
    LocalFree(GlobalProviderInfo);

    GlobalProviderInfo       = NULL;
    GlobalNumProviders       = 0;
    GlobalNumActiveProviders = 0;
}

DWORD
MprMakeServiceKeyName(
    IN OUT  LPTSTR  *OrderedNamePtr,
    OUT     LPTSTR  *NameBufferPtr,
    OUT     LPTSTR  *NamePtr
    )

/*++

Routine Description:

    This function gets the name of the provider device driver key within
    the registry tree.  A buffer is allocated that is large enough for
    that name as well as the name of the key where the provider information
    is stored.

        For example, the following buffer is allocated and filled with
        only the path prefix followed by the LanmanRedirector name.

            NameBuffer = [services\LanmanRedirector                ]

        The buffer is sized so that it can be filled in later with the
        following information.

            NameBuffer = [services\LanmanRedirector\NetworkProvider]

        The Driver name is needed for comparison with the ordered list names.

Arguments:

    OrderedNamePtr - On entry this points to a location where there is a
        pointer to the the next name in the ordered list of providers.
        These names are seperated by commas.  The last entry is followed by
        a trailing NUL.
        On exit a pointer to the next name in the list is stored here.  If
        it is the last name, the pointer is NULL.

    NameBufferPtr - This is a pointer to a location where the pointer to the
        name buffer is to be placed.

    NamePtr - This is a a location where the pointer to the provider
        name is placed.  In the above example, this pointer would point
        to the beginnning of the LanmanRedirector portion of the string.

Return Value:

    TRUE - We successfully obtained the driver name.

    FALSE - We were unsuccessful in obtaining the driver name.

Note:


--*/

{
    LPTSTR  pNext;
    DWORD   bufferSize;     // number of BYTES in buffer
    DWORD   nameLength;     // number of CHARACTERS in string

    //
    // The OrderedNamePtr should always be valid.  If not there is a software
    // error in this code.
    //
    if (*OrderedNamePtr == NULL) {
        MPR_LOG(ERROR,"GetDriverName: The ordered Name Ptr was NULL.\n",0);
        return(WN_NO_NETWORK);
    }

    pNext = *OrderedNamePtr;

    //
    // Find the next NULL or COMMA.
    //
    while ( (*pNext != TEXT('\0')) &&
            (*pNext != TEXT(','))  ){
        pNext++;
    }

    //
    // Allocate a buffer for the name to be stored in
    //

    bufferSize = (DWORD)((LPBYTE)pNext - (LPBYTE)(*OrderedNamePtr));
    nameLength = bufferSize / sizeof(TCHAR);

    bufferSize = bufferSize + sizeof(PROVIDER_PATH) + sizeof(SERVICES_KEY_NAME);

    *NameBufferPtr = (LPTSTR) LocalAlloc(LPTR, bufferSize);
    if (*NameBufferPtr == NULL) {
        MPR_LOG(ERROR,"MprMakeServiceKeyName:LocalAllocFailed %d\n",GetLastError());
        return(GetLastError());
    }

    //
    // Copy the path prefix "services\\" followed by the name
    // into the buffer and terminate with a NULL character.
    //

    wcscpy(*NameBufferPtr, SERVICES_KEY_NAME);
    *NamePtr = (LPTSTR)(*NameBufferPtr + (wcslen(*NameBufferPtr)));

    wcsncat(*NameBufferPtr, *OrderedNamePtr, nameLength);
    *((*NamePtr) + nameLength) = TEXT('\0');



    if (*pNext == TEXT('\0')) {
        *OrderedNamePtr = NULL;
    }
    else {
        *OrderedNamePtr = pNext + 1;
    }

    return (WN_SUCCESS);
}


BOOL
MprGetOrderedList(
    HKEY    ControlRootKey,
    LPTSTR  *OrderString
    )

/*++

Routine Description:

    This function returns a pointer to a string that contains the
    ordered list of providers.  This ordered list is to be used when
    we go through the list of providers with a trial-and-error method
    when servicing a WINNET API call.

    ALLOCATES STORAGE:  This function allocates the buffer for the
    OrderString.

Arguments:

    OrderString - This is a pointer to a location where the pointer to
        the order string is to be placed.

Return Value:

    TRUE - The ordered list was found, and the string was returned.

    FALSE - A failure occured when attempting to find the ordered list.

--*/
{

    HKEY        orderKey;

    *OrderString = NULL;

    //
    // Get a handle to the key for the ordered provider information.
    //

    if(!MprOpenKey(
                ControlRootKey,         // hKey
                PROVIDER_ORDER_KEY,     // lpSubKey
                &orderKey,              // Newly Opened Key Handle
                DA_READ)) {             // Desired Access

        MPR_LOG(ERROR,"MprGetOrderedList: MprOpenKey (ActiveProviders) Error\n",0);
        return(FALSE);
    }


    //
    // Get the provider order string from the registry.
    //
    if (!MprGetKeyValue(orderKey, TEXT("ProviderOrder"), OrderString)) {

        MPR_LOG(ERROR,"MprGetOrderedList: MprGetKeyValue Error.\n", 0);

        RegCloseKey(orderKey);
        return(FALSE);
    }

    RegCloseKey(orderKey);

    return(TRUE);
}

DWORD
MprGetNumProviders(
    LPTSTR  OrderedString
    )

/*++

Routine Description:

    This routine finds the number of provider names in the string of
    ordered provider names.

Arguments:

    OrderedString - This is a pointer to a NUL terminated string of
        ordered provider names.  Names are seperated by commas.

Return Value:



--*/
{
    DWORD   count = 0;
    LPTSTR  pBegin;

    pBegin = OrderedString;

    while (*OrderedString != TEXT('\0')) {

        //
        // If a seperator has been found, and if there are characters
        // between it and the last seperator (or the beginning), then
        // increment the count.
        //
        if (*OrderedString == TEXT(',')) {
            if((OrderedString - pBegin) > 0) {
                count++;
            }
            pBegin = OrderedString + 1;
        }
        OrderedString++;
    }

    //
    // The last name is expected to be followed by a NUL rather than a
    // comma.
    //
    if ((OrderedString - pBegin) > 0) {
        count++;
    }
    return(count);
}

BOOL
MprExtractProviderInfo(
    HKEY        ProviderInfoKey,
    LPPROVIDER  Provider
    )

/*++

Routine Description:

    This function extracts information from the ProviderInfoKey location
    in the registry and stores it in the Provider data structure.

Arguments:

    ProviderInfoKey - This is a registry key handle for the location in
        the registry where we expect to obtain all the necessary
        information about a provider.

    Provider - This is a pointer to a provider structure that is to be
        filled in with the information from the registry.

Return Value:

    TRUE - The operation was completely successful.

    FALSE - The operation failed.

Note:


--*/
{

    LPTSTR      providerName = NULL;
    LPTSTR      fileName = NULL;
    DWORD       ValueType;
    DWORD       Class;
    DWORD       classSize = sizeof(DWORD);
    DWORD       status;

    MPR_LOG(TRACE,"In MprExtractProviderInfo....\n",0);

    //
    // Get Provider Name
    //

    if(!MprGetKeyValue(ProviderInfoKey, TEXT("name"), &providerName) ||
       providerName[0] == L'\0') {
        MPR_LOG0(ERROR,"MprExtractProviderInfo: Couldn't get provider name\n");
        return(FALSE);
    }


    //
    // Initialize all the fields in the resource structure.
    // NOTE: The reserved field in dwUsage is set to indicate this is
    // a top level structure.
    //
    Provider->Resource.lpProvider   = providerName;
    Provider->Resource.lpRemoteName = providerName;
    Provider->Resource.dwScope      = RESOURCE_GLOBALNET;
    Provider->Resource.dwType       = 0;
    Provider->Resource.dwDisplayType= RESOURCEDISPLAYTYPE_NETWORK;
    Provider->Resource.dwUsage      = RESOURCEUSAGE_CONTAINER | RESOURCEUSAGE_RESERVED;
    Provider->Resource.lpComment    = NULL;

    //
    // Get the Provider Class.  If there isn't a Class value in the
    // registry, assume it is a NetworkClass only.
    //

    status = RegQueryValueEx(
                ProviderInfoKey,    // hKey
                VALUE_CLASS,        // lpValueName
                NULL,               // lpTitleIndex
                &ValueType,         // lpType
                (LPBYTE)&Class,     // lpData
                &classSize);        // lpcbData

    if (status != NO_ERROR) {
        //
        // If we get an error we assume it is because there is no key - thus
        // indicating that this provider is a network provider only.
        //
        MPR_LOG0(TRACE,"Couldn't find Authenticator Class value "
            "- assume it is Network-type only\n");
        Class = WN_NETWORK_CLASS;
    }
    Provider->InitClass = Class;
    MPR_LOG1(TRACE,"MprExtractProviderInfo: Provider InitClass = %d\n",Class);



    //
    // Get the name of the provider's DLL routine
    //

    if(!MprGetKeyValue(ProviderInfoKey,VALUE_PATHNAME,&fileName)){
        MPR_LOG(ERROR,
            "MprExtractProviderInfo: Failed to get the Dll path from registry\n",0);

        //
        // If this is a network class provider, it MUST have a provider
        // dll.  Otherwise, we return a failure.
        //
        if (Class & WN_NETWORK_CLASS) {
            return(FALSE);
        }
        else {
            fileName = NULL;
        }
    }
    Provider->DllName = fileName;


    //
    // If this is a CREDENTIAL_CLASS or PRIMARY_AUTHENT_CLASS provider
    // then try to get the dll name for the authentication provider.
    //

    if (Class & (WN_CREDENTIAL_CLASS | WN_PRIMARY_AUTHENT_CLASS)) {
        //
        // Get the name of the provider's Credential Management DLL routine
        //
        if(!MprGetKeyValue(ProviderInfoKey,AUTHENT_PATHNAME,&fileName)){
            //
            // If we can't get a name for the Authentication Provider's DLL,
            // then we will assume the network provider dll exports the
            // Credential Management functions.
            //
            MPR_LOG0(ERROR,
                "MprExtractProviderInfo: Failed to get the Authenticator "
                "Dll path from registry\n");
            //
            // If we don't have a provider dll name, or an authent provider
            // dll name, then this is an error condition.
            //
            if (Provider->DllName == NULL) {
                return(FALSE);
            }
        }
        else {
            Provider->AuthentDllName = fileName;
        }
    }
    return(TRUE);
}


BOOL
MprGetLUIDDeviceMapsEnabled(
    PBOOL pResult
    )

/*++

Routine Description:

    This function calls NtQueryInformationProcess() to determine if
    LUID device maps are enabled


Arguments:

    pResult - returns the result of "Is LUID device maps are enabled?"
              TRUE - LUID device maps are enabled
              FALSE - LUID device maps are disabled

Return Value:

    TRUE - This is returned if we are able to determine if LUID device
                 maps are enabled/disabled.

    FALSE - Encountered an error

--*/

{

    NTSTATUS  Status;
    ULONG     LUIDDeviceMapsEnabled;
    BOOL      Result;

    if( pResult == NULL ) {
        return (FALSE);
    }

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if( !NT_SUCCESS(Status) ) {
        MPR_LOG(ERROR,"MprGetLUIDDeviceMapsEnabled: NtQueryInformationProcess (g_LUIDDeviceMapsEnabled) Error\n",0);
        return( FALSE );
    }
    else{
        Result = (LUIDDeviceMapsEnabled != 0);
    }

    *pResult = Result;

    return( TRUE );
}

extern "C" int __cdecl
_purecall(
    VOID
    )
{
   // Make it build... (the compiler will initialize all pure virtual
   // function pointers to point to this...  If we hit this function,
   // there's a really big problem.)
   RtlRaiseStatus(STATUS_NOT_IMPLEMENTED);
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\mprprop.cxx ===
/**********************************************************************/
/**           Microsoft Windows/NT                                   **/
/**        Copyright(c) Microsoft Corp., 1992                        **/
/**********************************************************************/

/*
    MPRProp.cxx

    This file contains the implementation for the

    WNetGetPropertyTextW
    WNetPropertyDialogW




    FILE HISTORY:

    05-May-1999     jschwart
        Make provider addition/removal dynamic

    27-May-1994 danl
        WNetGetPropertyTextW & WNetPropertyDialogW:  If no provider
        claims the connection in question, then we try all providers.
        The actual rule is that we need to pass it to the lanman
        provider anyway (so it can check for a share).  But to play
        completely fair, we'll pass it to everyone.

    Johnl   07-Jan-1991 Boilerplated from Danl's code

*/


#include "precomp.hxx"


DWORD
WNetGetPropertyTextW (
    DWORD  iButton,
    DWORD  nPropSel,
    LPTSTR lpszName,
    LPTSTR lpszButtonName,
    DWORD  nButtonNameLength,
    DWORD  nType
    )
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD       status=WN_SUCCESS;
    LPPROVIDER  provider;
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       providerIndex;
    LPDWORD     index;
    DWORD       indexArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders;
    DWORD       statusFlag = 0; // used to indicate major error types
    DWORD       i;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    index = indexArray;

    //
    // Find the Provider Index associated with the drive letter in
    // the pathname (lpszName).
    // NOTE:  This function handles exceptions.
    //
    status = MprFindProviderForPath(lpszName, &providerIndex);
    if (status != WN_SUCCESS) {
        MPR_LOG1(ERROR,"WNetGetPropertyText: Couldn't find provider for this "
            "path.  Error = %d\n",status);

        //
        // Find the list of providers to call for this request.
        // Since no provider claimed this path, then
        // we need to at least try the lanman provider.
        // Actually we'll give them all a chance.
        //

        status = MprFindCallOrder(
                    NULL,
                    &index,
                    &numProviders,
                    NETWORK_TYPE);

        if (status != WN_SUCCESS) {
            return(status);
        }
    }
    else {
        numProviders = 1;
        index[0] = providerIndex;
    }

    //
    // Loop through the list of providers until one answers the request,
    // or the list is exhausted.
    //
    for (i=0; i<numProviders; i++) {
        //
        // Call the appropriate provider's API entry point
        //
        provider = GlobalProviderInfo + index[i];

        if (provider->GetPropertyText != NULL) {

            fcnSupported = TRUE;

            __try {
                status = provider->GetPropertyText(
                        iButton,
                        nPropSel,
                        lpszName,
                        lpszButtonName,
                        nButtonNameLength,
                        nType
                        );
            }
            __except(MPR_EXCEPTION_FILTER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetGetPropertyText:Unexpected Exception "
                    "0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }

            if (status == WN_NO_NETWORK) {
                statusFlag |= NO_NET;
            }
            else if ((status == WN_NOT_CONNECTED)  ||
                     (status == WN_BAD_LOCALNAME)){

                statusFlag |= BAD_NAME;
            }
            else {
                //
                // If it wasn't one of those errors, then the provider
                // must have accepted responsiblity for the request.
                // so we exit and process the results.  Note that the
                // statusFlag is cleared because we want to ignore other
                // error information that we gathered up until now.
                //
                statusFlag = 0;
                break;
            }
        } // End if this provider supports GetPropertyText.
    }
    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (index != indexArray) {
        LocalFree(index);
    }

    //
    // Handle special errors.
    //
    if (statusFlag == (NO_NET | BAD_NAME)) {
        //
        // Check to see if there was a mix of special errors that occured.
        // If so, pass back the combined error message.  Otherwise, let the
        // last error returned get passed back.
        //
        status = WN_NO_NET_OR_BAD_PATH;
    }

    if (status != WN_SUCCESS){
        SetLastError(status);
    }

    //
    // Handle normal errors passed back from the provider
    //
    return(status);
}

DWORD
WNetPropertyDialogW (
    HWND  hwndParent,
    DWORD iButton,
    DWORD nPropSel,
    LPTSTR lpszName,
    DWORD nType
    )
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD       status=WN_SUCCESS;
    LPPROVIDER  provider;
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       providerIndex;
    LPDWORD     index;
    DWORD       indexArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders;
    DWORD       statusFlag = 0; // used to indicate major error types
    DWORD       i;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    index = indexArray;

    //
    // Find the Provider Index associated with the drive letter in
    // the pathname (lpszName).
    // NOTE:  This function handles exceptions.
    //
    status = MprFindProviderForPath(lpszName, &providerIndex);
    if (status != WN_SUCCESS) {
        MPR_LOG1(ERROR,"WNetPropertyDialog: Couldn't find provider for this "
            "path.  Error = %d\n",status);

        //
        // Find the list of providers to call for this request.
        // Since no provider claimed this path, then
        // we need to at least try the lanman provider.
        // Actually we'll give them all a chance.
        //
        status = MprFindCallOrder(
                    NULL,
                    &index,
                    &numProviders,
                    NETWORK_TYPE);

        if (status != WN_SUCCESS) {
            return(status);
        }
    }
    else {
        numProviders = 1;
        index[0] = providerIndex;
    }

    //
    // Loop through the list of providers until one answers the request,
    // or the list is exhausted.
    //
    for (i=0; i<numProviders; i++) {
        //
        // Call the appropriate provider's API entry point
        //
        provider = GlobalProviderInfo + index[i];

        if (provider->PropertyDialog != NULL) {

            fcnSupported = TRUE;

            __try {
                status = provider->PropertyDialog(
                         hwndParent,
                         iButton,
                         nPropSel,
                         lpszName,
                         nType
                          );
            }
            __except(MPR_EXCEPTION_FILTER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetPropertyDialog:Unexpected Exception "
                    "0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }
            if (status == WN_NO_NETWORK) {
                statusFlag |= NO_NET;
            }
            else if ((status == WN_NOT_CONNECTED)  ||
                     (status == WN_BAD_LOCALNAME)){

                statusFlag |= BAD_NAME;
            }
            else {
                //
                // If it wasn't one of those errors, then the provider
                // must have accepted responsiblity for the request.
                // so we exit and process the results.  Note that the
                // statusFlag is cleared because we want to ignore other
                // error information that we gathered up until now.
                //
                statusFlag = 0;
                break;
            }
        } // End if this provider supports PropertyDialog
    }

    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (index != indexArray) {
        LocalFree(index);
    }

    //
    // Handle special errors.
    //
    if (statusFlag == (NO_NET | BAD_NAME)) {
        //
        // Check to see if there was a mix of special errors that occured.
        // If so, pass back the combined error message.  Otherwise, let the
        // last error returned get passed back.
        //
        status = WN_NO_NET_OR_BAD_PATH;
    }

    //
    // Handle normal errors passed back from the provider
    //
    if (status != WN_SUCCESS){
        SetLastError(status);
    }

    return(status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\mprres.h ===
//
// Resource IDs for MPR.DLL
//

//
// This is the name of the root-of-network object that shows up in the
// network neighborhood.
//
#define IDS_NETROOT     70


//
// Last-ditch error text if MultinetGetErrorText can't get the message
// (text taken from Win9x's XERR_UNKNOWN)
//
#define IDS_XERR_UNKNOWN    75
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\mprreg.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MPRREG.CXX

Abstract:

    Contains functions used by MPR to manipulate the registry.
        MprOpenKey
        MprGetKeyValue
        MprEnumKey
        MprGetKeyInfo
        MprFindDriveInRegistry
        I_MprSaveConn
        MprSaveDeferFlags
        MprSetRegValue
        MprCreateRegKey
        MprReadConnectionInfo
        MprForgetRedirConnection
        MprGetRemoteName


    QUESTIONS:
    1)  Do I need to call RegFlushKey after creating a new key?

Author:

    Dan Lafferty (danl) 12-Dec-1991

Environment:

    User Mode - Win32


Revision History:

    21-Feb-1997     AnirudhS
        Change MprRememberConnection to I_MprSaveConn and MprSaveDeferFlags
        for use by setup and by DEFER_UNKNOWN.

    12-Jun-1996     AnirudhS
        Got rid of the REMOVE_COLON/RESTORE_COLON scheme for converting
        device names to registry key names, since it caused writes to
        read-only input parameters.

    08-Mar-1996     AnirudhS
        Save the provider type, not the provider name, for persistent
        connections.  Fix old heap corruption bugs that show up when the
        user profile contains incomplete info.

    16-Jun-1995     AnirudhS
        Returned DWORDs rather than BOOLs from some functions; changed some
        formal parameters from LPWSTR to LPCWSTR.

    24-Nov-1992     Danl
        Fixed compiler warnings by always using HKEY rather than HANDLE.

    03-Sept-1992    Danl
        MprGetRemoteName:  Changed ERROR_BUFFER_OVERFLOW to WN_MORE_DATA.

    12-Dec-1991     danl
        Created

--*/

//
// Includes
//
#include "precomp.hxx"
#include <malloc.h>     // _alloca
#include <debugfmt.h>   // FORMAT_LPTSTR
#include <wincred.h>    // CRED_MAX_USERNAME_LENGTH


//
// Macros
//

//
// STACK_ALLOC
//
// Allocates space on the stack for a copy of an input string.  The result
// could be NULL if the string is too long to be copied on the stack.
//
#define STACK_ALLOC(str)  ((LPWSTR) _alloca((wcslen(str)+1)*sizeof(WCHAR)))



VOID
RemoveColon(
    LPWSTR  pszCopy,
    LPCWSTR pszSource
    )
/*++

Routine Description:

    This function makes a copy of a string and searches through the copy
    for a colon.  If a colon is found, it is replaced by a '\0'.

Arguments:

    pszCopy - Pointer to the space for the copy.

    pszSource - Pointer to the source string.

Return Value:

    None.

--*/
{
    wcscpy(pszCopy, pszSource);
    WCHAR * pColon = wcschr(pszCopy, L':');
    if (pColon != NULL)
    {
        *pColon = L'\0';
    }
}



BOOL
MprOpenKey(
    IN  HKEY    hKey,
    IN  LPTSTR  lpSubKey,
    OUT PHKEY   phKeyHandle,
    IN  DWORD   desiredAccess
    )

/*++

Routine Description:

    This function opens a handle to a key inside the registry.  The major
    handle and the path to the subkey are required as input.

Arguments:

    hKey - This is one of the well-known root key handles for the portion
        of the registry of interest.

    lpSubKey - A pointer a string containing the path to the subkey.

    phKeyHandle - A pointer to the location where the handle to the subkey
        is to be placed.

    desiredAccess - Desired Access (Either KEY_READ or KEY_WRITE or both).

Return Value:

    TRUE - The operation was successful

    FALSE - The operation was not successful.


--*/
{

    DWORD   status;
    REGSAM  samDesired = KEY_READ;
    HKEY HKCU ;

    if(desiredAccess & DA_WRITE) {
        samDesired = KEY_READ | KEY_WRITE;
    }
    else if (desiredAccess & DA_DELETE) {
        samDesired = DELETE;
    }

    HKCU = NULL ;

    if ( hKey == HKEY_CURRENT_USER ) {
        status = RegOpenCurrentUser(
                        MAXIMUM_ALLOWED,
                        &HKCU );

        if ( status != 0 )
        {
            return FALSE ;
        }

        hKey = HKCU ;
    }

    status = RegOpenKeyEx(
            hKey,                   // hKey
            lpSubKey,               // lpSubKey
            0L,                     // ulOptions (reserved)
            samDesired,             // desired access security mask
            phKeyHandle);           // Newly Opened Key Handle

    if ( HKCU )
    {
        RegCloseKey( HKCU );
    }

    if (status != NO_ERROR) {
        MPR_LOG3(ERROR,"MprOpenKey: RegOpenKeyEx(%#lx \"%ws\") failed %d\n",
                      hKey, lpSubKey, status);
        return (FALSE);
    }
    return(TRUE);
}

BOOL
MprGetKeyValue(
    IN  HKEY    KeyHandle,
    IN  LPTSTR  ValueName,
    OUT LPTSTR  *ValueString
    )

/*++

Routine Description:

    This function takes a key handle and a value name, and returns a value
    string that is associated with that name.

    NOTE:  The pointer to the ValueString is allocated by this function.

Arguments:

    KeyHandle - This is a handle for the registry key that contains the value.

    ValueName - A pointer to a string that identifies the value being
        obtained.

    ValueString - A pointer to a location that upon exit will contain the
        pointer to the returned value.

Return Value:

    TRUE - Success

    FALSE - A fatal error occured.

--*/
{
    DWORD       status;
    DWORD       maxValueLen;
    TCHAR       Temp[1];
    LPTSTR      TempValue;
    DWORD       ValueType;
    DWORD       NumRequired;
    DWORD       CharsReturned;

    //
    // Find the buffer size requirement for the value.
    //
    status = RegQueryValueEx(
                KeyHandle,          // hKey
                ValueName,          // lpValueName
                NULL,               // lpTitleIndex
                &ValueType,         // lpType
                NULL,               // lpData
                &maxValueLen);      // lpcbData

    if (status != NO_ERROR) {
        MPR_LOG2(ERROR,"MprGetKeyValue:RegQueryValueEx(\"%ws\") failed %d\n",
                        ValueName, status);
        *ValueString = NULL;
        return(FALSE);
    }

    //
    // Allocate buffer to receive the value string.
    //
    maxValueLen += sizeof(TCHAR);

    TempValue = (LPTSTR) LocalAlloc(LMEM_FIXED, maxValueLen);

    if(TempValue == NULL) {
        MPR_LOG(ERROR,"MprGetKeyValue:LocalAlloc failed\n", 0);
        *ValueString = NULL;
        return(FALSE);
    }

    //
    // Read the value.
    //
    status = RegQueryValueEx(
                KeyHandle,          // hKey
                ValueName,          // lpValueName
                NULL,               // lpTitleIndex
                &ValueType,         // lpType
                (LPBYTE)TempValue,  // lpData
                &maxValueLen);      // lpcbData

    if (status != NO_ERROR) {
        MPR_LOG2(ERROR,"MprGetKeyValue:RegQueryValueEx(\"%ws\") failed %d\n",
                        ValueName, status);
        LocalFree(TempValue);
        *ValueString = NULL;
        return(FALSE);
    }

    //
    // Make sure the value is null-terminated.  Strings obtained from
    // the registry may or may not be null-terminated.
    //
    TempValue [ maxValueLen / sizeof(TCHAR) ] = 0;

    //========================================================
    //
    // If the value is of REG_EXPAND_SZ type, then expand it.
    //
    //========================================================

    if (ValueType != REG_EXPAND_SZ) {
        *ValueString = TempValue;
        return(TRUE);
    }

    //
    // If the ValueType is REG_EXPAND_SZ, then we must call the
    // function to expand environment variables.
    //
    MPR_LOG(TRACE,"MprGetKeyValue: Must expand the string for "
        FORMAT_LPTSTR "\n", ValueName);

    //
    // Make the first call just to get the number of characters that
    // will be returned.
    //
    NumRequired = ExpandEnvironmentStrings (TempValue,Temp, 1);

    if (NumRequired > 1) {

        *ValueString = (LPTSTR) LocalAlloc(LPTR, (NumRequired+1)*sizeof(TCHAR));

        if (*ValueString == NULL) {

            MPR_LOG(ERROR, "MprGetKeyValue: LocalAlloc of numChar= "
                FORMAT_DWORD " failed \n",NumRequired );

            (void) LocalFree(TempValue);
            return(FALSE);
        }

        CharsReturned = ExpandEnvironmentStrings (
                            TempValue,
                            *ValueString,
                            NumRequired);

        (void) LocalFree(TempValue);

        if (CharsReturned > NumRequired || CharsReturned == 0) {
            MPR_LOG(ERROR, "MprGetKeyValue: ExpandEnvironmentStrings "
                " failed for " FORMAT_LPTSTR " \n", ValueName);

            (void) LocalFree(*ValueString);
            *ValueString = NULL;
            return(FALSE);
        }

        //
        // Now insert the NUL terminator.
        //
        (*ValueString)[CharsReturned] = 0;
    }
    else {
        //
        // This call should have failed because of our ridiculously small
        // buffer size.
        //

        MPR_LOG(ERROR, "MprGetKeyValue: ExpandEnvironmentStrings "
            " Should have failed because we gave it a BufferSize=1\n",0);

        //
        // This could happen if the string was a single character long and
        // didn't really have any environment values to expand.  In this
        // case, we return the TempValue buffer pointer.
        //
        *ValueString = TempValue;
    }

    return(TRUE);

}


BOOL
MprGetKeyDwordValue(
    IN  HKEY    KeyHandle,
    IN  LPCWSTR ValueName,
    OUT DWORD * Value
    )

/*++

Routine Description:

    This function takes a key handle and a value name, and returns a DWORD
    value that is associated with that name.

Arguments:

    KeyHandle - This is a handle for the registry key that contains the value.

    ValueName - A pointer to a string that identifies the value being
        obtained.  If this value does not have REG_DWORD type the function
        returns FALSE.

    Value - A pointer to a location that upon exit will contain the returned
        DWORD value.

Return Value:

    TRUE - Success

    FALSE - A fatal error occured.

--*/
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType;
    DWORD status = RegQueryValueEx(
                        KeyHandle,
                        ValueName,
                        0,      // reserved
                        &dwType,   // type
                        (LPBYTE) Value,
                        &dwSize);

    if (status)
    {
        MPR_LOG2(ERROR,"MprGetKeyDwordValue: RegQueryValueEx(\"%ws\") failed %ld\n",
                        ValueName, status);
        return FALSE;
    }
    else if (dwType != REG_DWORD || dwSize != sizeof(DWORD))
    {
        MPR_LOG3(ERROR,"MprGetKeyDwordValue: RegQueryValueEx(\"%ws\") returned "
                       "type %ld, size %ld\n", ValueName, dwType, dwSize);
        return FALSE;
    }

    return TRUE;
}


LONG
MprGetKeyNumberValue(
    IN  HKEY    KeyHandle,
    IN  LPCWSTR ValueName,
    IN  LONG    Default
    )

/*++

Routine Description:

    This function takes a key handle and a value name, and returns a numeric
    value that is associated with that name.  If an error occurs while
    retrieving the value, the specified Default value is returned.

    For compatibility, the behavior of this function is exactly the same as
    Win95's RegEntry::GetNumber function.  The value is assumed to be a 4-byte
    type, such as REG_BINARY or REG_DWORD.  If this is not the case, the
    function does exactly the same as Win95.

Arguments:

    KeyHandle - This is a handle for the registry key that contains the value.

    ValueName - A pointer to a string that identifies the value being
        obtained.

    Default - Value to return if one could not be obtained from the registry.

Return Value:

    Value retrieved from the registry, or default if an error occurs.

--*/
{
    LONG    dwNumber;
    DWORD   dwSize = sizeof(dwNumber);

    DWORD error = RegQueryValueEx(
                        KeyHandle,
                        ValueName,
                        0,      // reserved
                        NULL,   // type
                        (LPBYTE) &dwNumber,
                        &dwSize);

    if (error)
        dwNumber = Default;

    return dwNumber;
}


BOOL
MprGetKeyStringValue(
    IN  HKEY    KeyHandle,
    IN  LPCWSTR ValueName,
    IN  DWORD   cchMaxValueLength,
    OUT LPWSTR  *Value
    )

/*++

Routine Description:

    This function takes a key handle, a value name, and a max size and allocates/returns
    a string value that is associated with that name.

Arguments:

    KeyHandle - This is a handle for the registry key that contains the value.

    ValueName - A pointer to a string that identifies the value being
        obtained.  If this value does not have REG_SZ type the function
        returns FALSE.

    cchMaxValueLength - Size of the OUT buffer to allocate, in characters.

    Value - A pointer to a location that upon exit will contain the returned
        LPWSTR value.

Return Value:

    TRUE - Success

    FALSE - A fatal error occured.

--*/
{
    DWORD status;
    DWORD dwType;
    DWORD dwSize = (cchMaxValueLength + 1) * sizeof(WCHAR);

    *Value = (LPWSTR) LocalAlloc(LMEM_ZEROINIT, dwSize);

    if (*Value == NULL)
    {
        return FALSE;
    }

    status = RegQueryValueEx(KeyHandle,
                             ValueName,
                             0,      // reserved
                             &dwType,   // type
                             (LPBYTE) *Value,
                             &dwSize);

    if (status || (dwSize % 2) != 0)
    {
        LocalFree(*Value);
        *Value = NULL;
        return FALSE;
    }

    if (dwType != REG_SZ)
    {
        //
        // Legacy -- MPR writes out a NULL username as a DWORD 0x0.  Make sure
        // these values are NULL-terminated
        //

        (*Value)[cchMaxValueLength] = L'\0';
        return TRUE;
    }

    return TRUE;
}


DWORD
MprEnumKey(
    IN  HKEY    KeyHandle,
    IN  DWORD   SubKeyIndex,
    OUT LPTSTR  *SubKeyName,
    IN  DWORD   MaxSubKeyNameLen
    )

/*++

Routine Description:

    This function obtains a single name of a subkey from the registry.
    A key handle for the primary key is passed in.  Subkeys are enumerated
    one-per-call with the passed in index indicating where we are in the
    enumeration.

    NOTE:  This function allocates memory for the returned SubKeyName.

Arguments:

    KeyHandle - Handle to the key whose sub keys are to be enumerated.

    SubKeyIndex - Indicates the number (index) of the sub key to be returned.

    SubKeyName - A pointer to the location where the pointer to the
        subkey name string is to be placed.

    MaxSubKeyNameLen - This is the length of the largest subkey.  This value
        was obtained from calling MprGetKeyInfo.  The length is in number
        of characters and does not include the NULL terminator.

Return Value:

    WN_SUCCESS - The operation was successful.

    STATUS_NO_MORE_SUBKEYS - The SubKeyIndex value was larger than the
        number of subkeys.

    error returned from LocalAlloc


--*/
{
    DWORD       status;
    FILETIME    lastWriteTime;
    DWORD       bufferSize;

    //
    // Allocate buffer to receive the SubKey Name.
    //
    // NOTE: Space is allocated for an extra character because in the case
    //  of a drive name, we need to add the trailing colon.
    //
    bufferSize = (MaxSubKeyNameLen + 2) * sizeof(TCHAR);
    *SubKeyName = (LPTSTR) LocalAlloc(LMEM_FIXED, bufferSize);

    if(*SubKeyName == NULL) {
        MPR_LOG(ERROR,"MprEnumKey:LocalAlloc failed %d\n", GetLastError());
        return(WN_OUT_OF_MEMORY);
    }

    //
    // Get the Subkey name at that index.
    //
    status = RegEnumKeyEx(
                KeyHandle,          // hKey
                SubKeyIndex,        // dwIndex
                *SubKeyName,        // lpName
                &bufferSize,        // lpcbName
                NULL,               // lpTitleIndex
                NULL,               // lpClass
                NULL,               // lpcbClass
                &lastWriteTime);    // lpftLastWriteTime

    if (status != NO_ERROR) {
        MPR_LOG(ERROR,"MprEnumKey:RegEnumKeyEx failed %d\n",status);
        LocalFree(*SubKeyName);
        return(status);
    }
    return(WN_SUCCESS);
}

BOOL
MprGetKeyInfo(
    IN  HKEY    KeyHandle,
    OUT LPDWORD TitleIndex    OPTIONAL,
    OUT LPDWORD NumSubKeys,
    OUT LPDWORD MaxSubKeyLen,
    OUT LPDWORD NumValues     OPTIONAL,
    OUT LPDWORD MaxValueLen
    )

/*++

Routine Description:



Arguments:

    KeyHandle - Handle to the key for which we are to obtain information.

    NumSubKeys - This is a pointer to a location where the number
        of sub keys is to be placed.

    MaxSubKeyLen - This is a pointer to a location where the length of
        the longest subkey name is to be placed.

    NumValues - This is a pointer to a location where the number of
        key values is to be placed. This pointer is optional and can be
        NULL.

    MaxValueLen - This is a pointer to a location where the length of
        the longest data value is to be placed.


Return Value:

    TRUE - The operation was successful.

    FALSE - A failure occured.  The returned values are not to be believed.

--*/

{
    DWORD       status;
    DWORD       maxClassLength;
    DWORD       numValueNames;
    DWORD       maxValueNameLength;
    DWORD       securityDescLength;
    FILETIME    lastWriteTime;

    //
    // Get the Key Information
    //

    status = RegQueryInfoKey(
                KeyHandle,
                NULL,                   // Class
                NULL,                   // size of class buffer (in bytes)
                NULL,                   // DWORD to receive title index
                NumSubKeys,             // number of subkeys
                MaxSubKeyLen,           // length(chars-no null) of longest subkey name
                &maxClassLength,        // length of longest subkey class string
                &numValueNames,         // number of valueNames for this key
                &maxValueNameLength,    // length of longest ValueName
                MaxValueLen,            // length of longest value's data field
                &securityDescLength,    // lpcbSecurityDescriptor
                &lastWriteTime);        // the last time the key was modified

    if (status != 0)
    {
        MPR_LOG(ERROR,"MprGetKeyInfo: RegQueryInfoKey Error %d\n",status);
        return(FALSE);
    }

    if (NumValues != NULL) {
        *NumValues = numValueNames;
    }

    //
    // Support for title index has been removed from the Registry API.
    //
    if (TitleIndex != NULL) {
        *TitleIndex = 0;
    }

    return(TRUE);
}

BOOL
MprFindDriveInRegistry (
    IN     LPCTSTR  DriveName,
    IN OUT LPTSTR   *pRemoteName
    )

/*++

Routine Description:

    This function determines whether a particular re-directed drive
    name resides in the network connection section of the current user's
    registry path.  If the drive is already "remembered" in this section,
    this function returns TRUE.

Arguments:

    DriveName - A pointer to a string containing the name of the redirected
        drive.

    pRemoteName - If the DriveName is found in the registry, and if this
        is non-null, the remote name for the connection is read, and a
        pointer to the string is stored in this pointer location.
        If the remote name cannot be read from the registry, a NULL
        pointer is returned in this location.


Return Value:

    TRUE  - The redirected drive is "remembered in the registry".
    FALSE - The redirected drive is not saved in the registry.

--*/
{
    BOOL    bStatus = TRUE;
    HKEY    connectKey = NULL;
    HKEY    subKey = NULL;

    LPWSTR  KeyName = STACK_ALLOC(DriveName);
    if (KeyName == NULL) {
        return FALSE;
    }
    RemoveColon(KeyName, DriveName);

    //
    // Get a handle for the connection section of the user's registry
    // space.
    //
    if (!MprOpenKey(
            HKEY_CURRENT_USER,
            CONNECTION_KEY_NAME,
            &connectKey,
            DA_READ)) {

        MPR_LOG(ERROR,"MprFindDriveInRegistry: MprOpenKey Failed\n",0);
        return (FALSE);
    }

    if (!MprOpenKey(
            connectKey,
            KeyName,
            &subKey,
            DA_READ)) {

        MPR_LOG(TRACE,"MprFindDriveInRegistry: Drive %s Not Found\n",DriveName);
        bStatus = FALSE;
    }
    else {
        //
        // The drive was found in the registry, if the caller wants to have
        // the RemoteName, then get it.
        //
        if (pRemoteName != NULL) {

            //
            // Get the RemoteName (memory is allocated by this function)
            //

            if(!MprGetKeyValue(
                    subKey,
                    REMOTE_PATH_NAME,
                    pRemoteName)) {

                MPR_LOG(TRACE,"MprFindDriveInRegistry: Could not read "
                    "Remote path for Drive %ws \n",DriveName);
                pRemoteName = NULL;
            }
        }
    }

    if ( subKey )
        RegCloseKey(subKey);
    if ( connectKey )
        RegCloseKey(connectKey);

    return(bStatus);
}


DWORD
I_MprSaveConn(
    IN HKEY             HiveRoot,
    IN LPCWSTR          ProviderName,
    IN DWORD            ProviderType,
    IN LPCWSTR          UserName,
    IN LPCWSTR          LocalName,
    IN LPCWSTR          RemoteName,
    IN DWORD            ConnectionType,
    IN BYTE             ProviderFlags,
    IN DWORD            DeferFlags
    )
/*++

Routine Description:

    Writes the information about a connection to the network connection
    section of a user's registry path.

    NOTE:  If connection information is already stored in the registry for
    this drive, the current information will be overwritten with the new
    information.

Arguments:

    HiveRoot - A handle to the root of the user hive in which this
        information should be written, such as HKEY_CURRENT_USER.

    ProviderName - The provider that completed the connection.

    ProviderType - The provider type, if known.  If not known, zero should
        be passed, and a type will not be written to the registry.  (This
        is used by setup when upgrading from Win95 to NT.)

    UserName - The name of the user on whose behalf the connection was made.

    LocalName - The name of the local device that is redirected, with or
        without a trailing colon, such as "J" or "J:" or "LPT1".

    RemoteName - The network path to which the connection was made.

    ConnectionType - either RESOURCETYPE_DISK or RESOURCETYPE_PRINT.

    ProviderFlags - A byte of data to be saved along with the connection,
        and passed back to the provider when the connection is restored.

    DeferFlags - A DWORD to be saved in the connection's "Defer" value.  If
        this is zero, the value is not stored.
        The meaning of the bits of this DWORD are as follows:
        DEFER_EXPLICIT_PASSWORD - a password was explicitly specified when
        the connection was made.
        DEFER_UNKNOWN - it is not known whether a password was explicitly
        specified when the connection was made.
        DEFER_DEFAULT_CRED - The provider believes that default creds were
            used when the connection was made.

Return Value:

    ERROR_SUCCESS - If the operation was successful.

    Other Win32 errors - If the operation failed in any way.  If a failure
        occurs, the information is not stored in the registry.

--*/
{
    HKEY    connectKey;
    HKEY    localDevHandle;
    LPCTSTR pUserName;
    DWORD   status, IgnoredStatus;

    //
    // Remove the colon on the name since the registry doesn't like
    // this in a key name.
    //
    LPWSTR KeyName = STACK_ALLOC(LocalName);
    if (KeyName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RemoveColon(KeyName, LocalName);

    //
    // Get a handle for the connection section of the user's registry
    // space.
    //
    if ((status = MprCreateRegKey(
            HiveRoot,
            CONNECTION_KEY_NAME,
            &connectKey)) != ERROR_SUCCESS) {

        MPR_LOG(ERROR,"I_MprSaveConn: \\HKEY_CURRENT_USER\\network "
                      "could not be opened or created, error %ld\n", status);
        return(status);
    }

    //
    // Get (or create) the handle for the local name (without colon).
    //
    if ((status = MprCreateRegKey(
            connectKey,
            KeyName,
            &localDevHandle)) != ERROR_SUCCESS) {

        MPR_LOG(ERROR,"I_MprSaveConn: MprCreateRegKey Failed, "
                      "error %ld\n", status);
        RegCloseKey(connectKey);
        return(status);
    }


    //
    // Now that the key is created, store away the appropriate values.
    //

    MPR_LOG(TRACE,"RememberConnection: Setting RemotePath\n",0);

    if((status = MprSetRegValue(
            localDevHandle,
            REMOTE_PATH_NAME,
            RemoteName,
            0)) != ERROR_SUCCESS) {

        MPR_LOG(ERROR,
            "I_MprSaveConn: MprSetRegValueFailed %lu - RemotePath\n",status);
        goto CleanExit;
    }

    MPR_LOG(TRACE,"RememberConnection: Setting User\n",0);

    pUserName = UserName;
    if (UserName == NULL) {
        pUserName = TEXT("");
    }
    if((status = MprSetRegValue(
            localDevHandle,
            USER_NAME,
            pUserName,
            0)) != ERROR_SUCCESS) {

        goto CleanExit;
    }

    MPR_LOG(TRACE,"RememberConnection: Setting ProviderName\n",0);
    if((status = MprSetRegValue(
            localDevHandle,
            PROVIDER_NAME,
            ProviderName,
            0)) != ERROR_SUCCESS) {

        goto CleanExit;
    }

    if (ProviderType != 0)
    {
        MPR_LOG(TRACE,"RememberConnection: Setting ProviderType\n",0);
        if((status = MprSetRegValue(
                localDevHandle,
                PROVIDER_TYPE,
                NULL,
                ProviderType)) != ERROR_SUCCESS) {

            goto CleanExit;
        }
    }
    // else RegDeleteValue -- not done because ProviderType is 0 only
    // during upgrade, while writing to a fresh user hive

    MPR_LOG(TRACE,"RememberConnection: Setting ConnectionType\n",0);
    if((status = MprSetRegValue(
            localDevHandle,
            CONNECTION_TYPE,
            NULL,
            ConnectionType)) != ERROR_SUCCESS) {

        goto CleanExit;
    }

    if (ProviderFlags != 0)
    {
        MPR_LOG(TRACE,"RememberConnection: Setting ProviderFlags\n",0);
        if((status = MprSetRegValue(
                localDevHandle,
                PROVIDER_FLAGS,
                NULL,
                ProviderFlags)) != ERROR_SUCCESS) {

            goto CleanExit;
        }
    }

    // We can't roll this back if something fails after it, so we
    // must do this last
    if ((status = MprSaveDeferFlags(localDevHandle, DeferFlags))
        != ERROR_SUCCESS) {

        goto CleanExit;
    }

    //
    // Flush the new key, and then close the handle to it.
    //

    MPR_LOG(TRACE,"RememberConnection: Flushing Registry Key\n",0);

    IgnoredStatus = RegFlushKey(localDevHandle);
    if (IgnoredStatus != NO_ERROR) {
        MPR_LOG(ERROR,"RememberConnection: Flushing Registry Key Failed %ld\n",
        IgnoredStatus);
    }

CleanExit:
    RegCloseKey(localDevHandle);
    if (status != ERROR_SUCCESS) {
        IgnoredStatus = RegDeleteKey(connectKey, KeyName);
        if (IgnoredStatus != NO_ERROR) {
            MPR_LOG(ERROR, "RememberConnection: RegDeleteKey Failed %d\n", IgnoredStatus);
        }
    }
    RegCloseKey(connectKey);
    return(status);

}


DWORD
MprSaveDeferFlags(
    IN HKEY     RegKey,
    IN DWORD    DeferFlags
    )
{
    DWORD status;

    if (DeferFlags == 0)
    {
        MPR_LOG0(TRACE,"Removing DeferFlags\n");
        status = RegDeleteValue(RegKey, DEFER_FLAGS);
        if (status == ERROR_FILE_NOT_FOUND)
        {
            status = ERROR_SUCCESS;
        }
    }
    else
    {
        MPR_LOG(TRACE,"Setting DeferFlags %#lx\n",DeferFlags);
        status = MprSetRegValue(
                    RegKey,
                    DEFER_FLAGS,
                    NULL,
                    DeferFlags);
    }

    return status;
}


DWORD
MprSetRegValue(
    IN  HKEY    KeyHandle,
    IN  LPTSTR  ValueName,
    IN  LPCTSTR ValueString,
    IN  DWORD   LongValue
    )

/*++

Routine Description:

    Stores a single ValueName and associated data in the registry for
    the key identified by the KeyHandle.  The data associated with the
    value can either be a string or a 32-bit LONG.  If the ValueString
    argument contains a pointer to a value, then the LongValue argument
    is ignored.

Arguments:

    KeyHandle - Handle of the key for which the value entry is to be set.

    ValueName - Pointer to a string that contains the name of the value
        being set.

    ValueString - Pointer to a string that is to become the data stored
        at that value name.  If this argument is not present, then the
        LongValue argument is the data stored at the value name.  If this
        argument is present, then LongValue is ignored.

    LongValue - A LONG sized data value that is to be stored at the
        value name.

Return Value:

    Win32 error from RegSetValueEx (0 = success)

--*/
{
    DWORD   status;
    const BYTE * valueData;
    DWORD   valueSize;
    DWORD   valueType;

    if( ARGUMENT_PRESENT(ValueString)) {
        valueData = (const BYTE *)ValueString;
        valueSize = (wcslen(ValueString) + 1) * sizeof(WCHAR);
        valueType = REG_SZ;
    }
    else {
        valueData = (const BYTE *)&LongValue;
        valueSize = sizeof(DWORD);
        valueType = REG_DWORD;
    }
    status = RegSetValueEx(
                KeyHandle,      // hKey
                ValueName,      // lpValueName
                0,              // dwValueTitle (OPTIONAL)
                valueType,      // dwType
                valueData,      // lpData
                valueSize);     // cbData

    if(status != NO_ERROR) {
        MPR_LOG3(ERROR,"MprSetRegValue: RegSetValueEx(%#lx \"%ws\") Failed %ld\n",
                      KeyHandle, ValueName, status);
    }
    return(status);
}


DWORD
MprCreateRegKey(
    IN  HKEY    BaseKeyHandle,
    IN  LPCTSTR KeyName,
    OUT PHKEY   KeyHandlePtr
    )

/*++

Routine Description:

    Creates a key in the registry at the location described by KeyName.

Arguments:

    BaseKeyHandle - This is a handle for the base (parent) key - where the
        subkey is to be created.

    KeyName - This is a pointer to a string that describes the path to the
        key that is to be created.

    KeyHandle - This is a pointer to a location where the the handle for the
        newly created key is to be placed.

Return Value:

    Win32 error from RegCreateKeyEx (0 = success)

Note:


--*/
{
    DWORD       status;
    DWORD       disposition;


    //
    // Create the new key.
    //
    status = RegCreateKeyEx(
                BaseKeyHandle,          // hKey
                KeyName,                // lpSubKey
                0L,                     // dwTitleIndex
                TEXT("GenericClass"),   // lpClass
                0,                      // ulOptions
                KEY_WRITE,              // samDesired (desired access)
                NULL,                   // lpSecurityAttrubutes (Security Descriptor)
                KeyHandlePtr,           // phkResult
                &disposition);          // lpulDisposition

    if (status != NO_ERROR) {
        MPR_LOG3(ERROR,"MprCreateRegKey: RegCreateKeyEx(%#lx, \"%ws\") failed %d\n",
                    BaseKeyHandle, KeyName, status);
    }
    else {
        MPR_LOG(TRACE,"MprCreateRegKey: Disposition = 0x%x\n",disposition);
    }
    return(status);
}



BOOL
MprReadConnectionInfo(
    IN  HKEY            KeyHandle,
    IN  LPCTSTR         DriveName,
    IN  DWORD           Index,
    OUT LPDWORD         ProviderFlags,
    OUT LPDWORD         DeferFlags,
    OUT LPTSTR          *UserNamePtr,
    OUT LPNETRESOURCEW  NetResource,
    OUT HKEY            *SubKeyHandleOut,
    IN  DWORD           MaxSubKeyLen
    )

/*++

Routine Description:

    This function reads the data associated with a connection key.
    Buffers are allocated to store:

        UserName, RemoteName, LocalName, Provider

    Pointers to those buffers are returned.

    Also the connection type is read and stored in the NetResource structure.

    If the provider type is found in the registry, and a matching provider
    type is found in the GlobalProviderInfo array, the provider name is not
    read from the registry.  Instead it is read from the GlobalProviderInfo
    array.

    If the provider name is read from the registry and a matching provider
    name is found in the GlobalProviderInfo array, the provider type is
    written to the registry.

Arguments:

    KeyHandle - This is an already opened handle to the key whose
        sub-keys are to be enumerated.

    DriveName - This is the local name of the drive (eg. "f:") for which
        the connection information is to be obtained.  If DriveName is
        NULL, then the Index is used to enumerate the keyname.  Then
        that keyname is used.

    Index - This is the index that identifies the subkey for which we
        would like to receive information.

    ProviderFlags - This is a pointer to a location where the ProviderFlags
        value stored with the connection will be placed.  If this value
        cannot be retrieved, 0 will be placed here.

    DeferFlags - This is a pointer to a location where the DeferFlags
        value stored with the connection will be placed.  If this value
        cannot be retrieved, 0 will be placed here.

    UserNamePtr - This is a pointer to a location where the pointer to the
        UserName string is to be placed.  If there is no user name, a
        NULL pointer will be returned.

    NetResource - This is a pointer to a NETRESOURCE structure where
        information such as lpRemoteName, lpLocalName, lpProvider, and Type
        are to be placed.

    SubKeyHandleOut - This is a pointer to a location where the handle to
        the subkey that holds information about this connection will be
        placed.  This may be NULL.  If it is not NULL the caller must close
        the handle.

Return Value:



Note:


--*/
{
    DWORD           status = NO_ERROR;
    LPTSTR          driveName = NULL;
    HKEY            subKeyHandle = NULL;
    DWORD           cbData;
    DWORD           ProviderType = 0;
    LPPROVIDER      Provider;

    //
    // Initialize the Pointers that are to be updated.
    //
    *UserNamePtr = NULL;
    NetResource->lpLocalName = NULL;
    NetResource->lpRemoteName = NULL;
    NetResource->lpProvider = NULL;
    NetResource->dwType = 0L;

    //
    // If we don't have a DriveName, then get one by enumerating the
    // next key name.
    //

    if (DriveName == NULL) {
        //
        // Get the name of a subkey of the network connection key.
        // (memory is allocated by this function).
        //
        status = MprEnumKey(KeyHandle, Index, &driveName, MaxSubKeyLen);
        if (status != WN_SUCCESS) {
            return(FALSE);
        }
    }
    else {
        //
        // We have a drive name, alloc new space and copy it to that
        // location.
        //
        driveName = (LPTSTR) LocalAlloc(LMEM_FIXED, (wcslen(DriveName) + 1) * sizeof(WCHAR));
        if (driveName == NULL) {
            MPR_LOG(ERROR, "MprReadConnectionInfo: Local Alloc Failed %d\n",
                GetLastError());
            return(FALSE);
        }

        RemoveColon(driveName, DriveName);
    }

    MPR_LOG1(TRACE,"MprReadConnectionInfo: LocalName = %ws\n",driveName);

    //
    // Open the sub-key
    //
    if (!MprOpenKey(
            KeyHandle,
            driveName,
            &subKeyHandle,
            DA_WRITE)){

        status = WN_BAD_PROFILE;
        MPR_LOG1(TRACE,"MprReadConnectionInfo: Could not open %ws Key\n",driveName);
        goto CleanExit;
    }

    //
    // Add the trailing colon to the driveName.
    //
    cbData = wcslen(driveName);
    driveName[cbData]   = TEXT(':');
    driveName[cbData+1] = TEXT('\0');

    //
    // Store the drive name in the return structure.
    //
    NetResource->lpLocalName = driveName;

    //
    // Get the RemoteName (memory is allocated by this function)
    //

    if(!MprGetKeyValue(
            subKeyHandle,
            REMOTE_PATH_NAME,
            &(NetResource->lpRemoteName))) {

        status = WN_BAD_PROFILE;
        MPR_LOG0(TRACE,"MprReadConnectionInfo: Could not get RemoteName\n");
        goto CleanExit;
    }

    //
    // Get the UserName (memory is allocated by this function)
    //

    if(!MprGetKeyStringValue(
            subKeyHandle,
            USER_NAME,
            CRED_MAX_USERNAME_LENGTH,
            UserNamePtr))
    {
        status = WN_BAD_PROFILE;
        MPR_LOG0(TRACE,"MprReadConnectionInfo: Could not get UserName\n");
        goto CleanExit;
    }
    else
    {
        //
        // If there is no user name (the length is 0), then set the
        // return pointer to NULL.
        //
        if (wcslen(*UserNamePtr) == 0) {
            LocalFree(*UserNamePtr);
            *UserNamePtr = NULL;
        }
    }

    //
    // Get the Provider Type and load the providers if necessary.  Both
    // MprGetConnection and a remembered enumeration can make it to this
    // point in this state and we don't want to do a Level 2
    // initialization every time one of those functions is called simply
    // because this case _might_ be hit.  For example, calling
    // MprGetConnection on an unconnected drive letter may or may not
    // have a name associated with it in the registry.  If so, there's
    // no need to load the providers to get information from them.  This
    // is equivalent to INIT_IF_NECESSARY(NETWORK_LEVEL,status)
    //
    if (MprGetKeyDwordValue(
            subKeyHandle,
            PROVIDER_TYPE,
            &ProviderType)
        &&
        (MprLevel2Init(NETWORK_LEVEL) == WN_SUCCESS)
        &&
        ((Provider = MprFindProviderByType(ProviderType)) != NULL))
    {
        MPR_LOG(RESTORE,"MprReadConnectionInfo: Found recognized provider type %#lx\n",
                        ProviderType);
        //
        // Got a recognized provider type from the registry.
        // If we have a name for this provider in memory, use it, rather than
        // reading the name from the registry.
        // (memory is allocated for the name)
        //
        if (Provider->Resource.lpProvider != NULL)
        {
            NetResource->lpProvider =
                    (LPWSTR) LocalAlloc(0, (wcslen(Provider->Resource.lpProvider) + 1) * sizeof(WCHAR));

            if (NetResource->lpProvider == NULL)
            {
                status = WN_BAD_PROFILE;
                MPR_LOG(RESTORE,"MprReadConnectionInfo: LocalAlloc failed %ld\n",
                              GetLastError());
                goto CleanExit;
            }

            wcscpy(NetResource->lpProvider, Provider->Resource.lpProvider);
        }
    }

    //
    // If we haven't got a provider name yet, try to read it from the registry.
    // (Memory is allocated by this function.)
    // This could legitimately happen in 2 cases:
    // (1) We are reading a profile that was created by a Windows NT 3.51 or
    // earlier machine and has not yet been converted to a 4.0 or later
    // profile.  Windows NT versions 3.51 and earlier wrote only the provider
    // name to the registry, not the type.
    // (2) We are reading a floating profile that was written by another
    // machine which has a network provider installed that isn't installed on
    // this machine.  Or, a network provider was de-installed from this
    // machine.
    //
    if (NetResource->lpProvider == NULL)
    {
        if(!MprGetKeyValue(
                subKeyHandle,
                PROVIDER_NAME,
                &(NetResource->lpProvider)))
        {
            status = WN_BAD_PROFILE;
            MPR_LOG0(RESTORE,"MprReadConnectionInfo: Could not get ProviderName\n");
            goto CleanExit;
        }

        //
        // Got a provider name from the registry.
        // If we didn't read a provider type from the registry, but we
        // recognize the provider name, write the type now for future use.
        // (This would occur in case (1) above.)
        // Failure to write the type is ignored.
        // (Pathological cases in which we get an unrecognized type but a
        // recognized name are left untouched.)
        // Since it's possible to get to this point without having the
        // providers loaded, we'll init if necessary here (see reasoning
        // above). This is equivalent to INIT_IF_NECESSARY(NETWORK_LEVEL,status)
        //
        status = MprLevel2Init(NETWORK_LEVEL);

        if (status != WN_SUCCESS) {
            goto CleanExit;
        }

        Provider = MprFindProviderByName(NetResource->lpProvider);
        if (Provider != NULL && Provider->Type != 0 && ProviderType == 0)
        {
            MPR_LOG2(RESTORE,"MprReadConnectionInfo: Setting ProviderType %#lx for %ws\n",
                            Provider->Type, driveName);

            status = MprSetRegValue(
                            subKeyHandle,
                            PROVIDER_TYPE,
                            NULL,
                            Provider->Type);

            if (status != ERROR_SUCCESS)
            {
                MPR_LOG(RESTORE,"MprReadConnectionInfo: Couldn't set ProviderType, %ld\n",
                                status);
            }
        }
    }


    //
    // Get the ProviderFlags (failure is ignored)
    //
    cbData = sizeof(DWORD);

    status = RegQueryValueEx(
                subKeyHandle,                   // hKey
                PROVIDER_FLAGS,                 // lpValueName
                NULL,                           // lpTitleIndex
                NULL,                           // lpType
                (LPBYTE)ProviderFlags,          // lpData
                &cbData);                       // lpcbData

    if (status == NO_ERROR) {
        MPR_LOG2(RESTORE,"MprReadConnectionInfo: Got ProviderFlags %#lx for %ws\n",
                 *ProviderFlags, driveName);
    }
    else {
        *ProviderFlags = 0;
    }


    //
    // Get the DeferFlags (failure is ignored)
    //
    if (MprGetKeyDwordValue(
            subKeyHandle,
            DEFER_FLAGS,
            DeferFlags
            ))
    {
        MPR_LOG2(RESTORE,"MprReadConnectionInfo: Got DeferFlags %#lx for %ws\n",
                 *DeferFlags, driveName);
    }
    else
    {
        *DeferFlags = 0;
    }


    //
    // Get the Connection Type
    //
    cbData = sizeof(DWORD);

    status = RegQueryValueEx(
                subKeyHandle,                   // hKey
                CONNECTION_TYPE,                // lpValueName
                NULL,                           // lpTitleIndex
                NULL,                           // lpType
                (LPBYTE)&(NetResource->dwType), // lpData
                &cbData);                       // lpcbData

    if (status != NO_ERROR) {
        MPR_LOG1(ERROR,"MprReadConnectionInfo:RegQueryValueEx failed %d\n",
            status);

        MPR_LOG0(TRACE,"MprReadConnectionInfo: Could not get ConnectionType\n");
        status = WN_BAD_PROFILE;
    }


CleanExit:
    if (status != NO_ERROR) {
        LocalFree(driveName);
        LocalFree(NetResource->lpRemoteName);
        LocalFree(*UserNamePtr);
        LocalFree(NetResource->lpProvider);
        NetResource->lpLocalName = NULL;
        NetResource->lpRemoteName = NULL;
        NetResource->lpProvider = NULL;
        *UserNamePtr = NULL;
        if (subKeyHandle != NULL) {
            RegCloseKey(subKeyHandle);
        }
        return(FALSE);
    }
    else {
        if (SubKeyHandleOut == NULL) {
            RegCloseKey(subKeyHandle);
        }
        else {
            *SubKeyHandleOut = subKeyHandle;
        }
        return(TRUE);
    }
}



VOID
MprForgetRedirConnection(
    IN LPCTSTR  lpName
    )

/*++

Routine Description:

    This function removes a key for the specified redirected device from
    the current users portion of the registry.

Arguments:

    lpName - This is a pointer to a redirected device name.

Return Value:


Note:


--*/
{
    DWORD   status;
    HKEY    connectKey;

    MPR_LOG(TRACE,"In MprForgetConnection for %s\n", lpName);

    LPWSTR KeyName = STACK_ALLOC(lpName);
    if (KeyName == NULL) {
        return;
    }
    RemoveColon(KeyName, lpName);

    //
    // Get a handle for the connection section of the user's registry
    // space.
    //
    if (!MprOpenKey(
            HKEY_CURRENT_USER,
            CONNECTION_KEY_NAME,
            &connectKey,
            DA_READ)) {

        MPR_LOG(ERROR,"WNetForgetRedirCon: MprOpenKey #1 Failed\n",0);
        return;
    }

    status = RegDeleteKey(connectKey, KeyName);

    if (status != NO_ERROR) {
        MPR_LOG(ERROR, "WNetForgetRedirCon: NtDeleteKey Failed %d\n", status);
    }

    //
    // Flush the connect key, and then close the handle to it.
    //

    MPR_LOG(TRACE,"ForgetRedirConnection: Flushing Connection Key\n",0);

    status = RegFlushKey(connectKey);
    if (status != NO_ERROR) {
        MPR_LOG(ERROR,"RememberConnection: Flushing Connection Key Failed %ld\n",
        status);
    }

    RegCloseKey(connectKey);

    return;
}
BOOL
MprGetRemoteName(
    IN      LPTSTR  lpLocalName,
    IN OUT  LPDWORD lpBufferSize,
    OUT     LPTSTR  lpRemoteName,
    OUT     LPDWORD lpStatus
    )
/*++

Routine Description:

    This fuction Looks in the CURRENT_USER portion of the registry for
    connection information related to the lpLocalName passed in.

Arguments:

    lpLocalName - Pointer to a string containing the name of the device to
        look up.

    lpBufferSize - Pointer to a the size information for the buffer.
        On input, this contains the size of the buffer passed in.
        if lpStatus contain WN_MORE_DATA, this will contain the
        buffer size required to obtain the full string.

    lpRemoteName - Pointer to a buffer where the remote name string is
        to be placed.

    lpStatus - Pointer to a location where the proper return code is to
        be placed in the case where the connection information exists.

Return Value:

    TRUE - If the connection information exists.

    FALSE - If the connection information does not exist.  When FALSE is
        returned, none of output parameters are valid.

--*/
{
    HKEY            connectKey;
    DWORD           numSubKeys;
    DWORD           maxSubKeyLen;
    DWORD           maxValueLen;
    DWORD           status;
    DWORD           ProviderFlags;
    DWORD           DeferFlags;
    NETRESOURCEW    netResource;
    LPTSTR          userName;


    //
    // Get a handle for the connection section of the user's registry
    // space.
    //
    if (!MprOpenKey(
            HKEY_CURRENT_USER,
            CONNECTION_KEY_NAME,
            &connectKey,
            DA_READ)) {

        MPR_LOG(ERROR,"WNetGetConnection: MprOpenKey Failed\n",0);
        return(FALSE);
    }

    if(!MprGetKeyInfo(
        connectKey,
        NULL,
        &numSubKeys,
        &maxSubKeyLen,
        NULL,
        &maxValueLen)) {

        MPR_LOG(ERROR,"WNetGetConnection: MprGetKeyInfo Failed\n",0);
        RegCloseKey(connectKey);
        return(FALSE);
    }

    //
    // Read the connection information.
    // NOTE:  This function allocates buffers for UserName and the
    //        following strings in the net resource structure:
    //          lpRemoteName,
    //          lpLocalName,
    //          lpProvider
    //
    if (MprReadConnectionInfo(
            connectKey,
            lpLocalName,
            0,
            &ProviderFlags,
            &DeferFlags,
            &userName,
            &netResource,
            NULL,
            maxSubKeyLen)) {

        //
        // The read succeeded.  Therefore we have connection information.
        //

        if (*lpBufferSize >= (wcslen(netResource.lpRemoteName) + 1) * sizeof(WCHAR)) {

            __try {
                wcscpy(lpRemoteName, netResource.lpRemoteName);
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetGetConnection:Unexpected Exception 0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }
            if (status != WN_BAD_POINTER) {

                //
                // We successfully copied the remote name to the users
                // buffer without an error.
                //
                status = WN_SUCCESS;
            }
        }
        else {
            *lpBufferSize = (wcslen(netResource.lpRemoteName) + 1) * sizeof(WCHAR);
            status = WN_MORE_DATA;
        }

        //
        // Free up the resources allocated by MprReadConnectionInfo.
        //

        LocalFree(userName);
        LocalFree(netResource.lpLocalName);
        LocalFree(netResource.lpRemoteName);
        LocalFree(netResource.lpProvider);

        *lpStatus = status;
        RegCloseKey(connectKey);
        return(TRUE);
    }
    else {
        //
        // The read did not succeed.
        //
        RegCloseKey(connectKey);
        return(FALSE);
    }
}

DWORD
MprGetPrintKeyInfo(
    HKEY    KeyHandle,
    LPDWORD NumValueNames,
    LPDWORD MaxValueNameLength,
    LPDWORD MaxValueLen)

/*++

Routine Description:

    This function reads the data associated with a print reconnection key.

Arguments:

    KeyHandle - This is an already opened handle to the key whose
        info is rto be queried.

    NumValueNames - Used to return the number of values

    MaxValueNameLength - Used to return the max value name length

    MaxValueLen - Used to return the max value data length

Return Value:

    0 if success. Win32 error otherwise.


Note:

--*/
{
    DWORD       err;
    DWORD       maxClassLength;
    DWORD       securityDescLength;
    DWORD       NumSubKeys ;
    DWORD       MaxSubKeyLen ;
    FILETIME    lastWriteTime;

    //
    // Get the Key Information
    //

    err = RegQueryInfoKey(
              KeyHandle,
              NULL,                   // Class
              NULL,                   // size of class buffer (in bytes)
              NULL,                   // DWORD to receive title index
              &NumSubKeys,            // number of subkeys
              &MaxSubKeyLen,          // length of longest subkey name
              &maxClassLength,        // length of longest subkey class string
              NumValueNames,          // number of valueNames for this key
              MaxValueNameLength,     // length of longest ValueName
              MaxValueLen,            // length of longest value's data field
              &securityDescLength,    // lpcbSecurityDescriptor
              &lastWriteTime);        // the last time the key was modified

    return(err);
}

DWORD
MprForgetPrintConnection(
    IN LPTSTR   lpName
    )

/*++

Routine Description:

    This function removes a rememembered print reconnection value.

Arguments:

    lpName - name of path to forget

Return Value:

    0 if success. Win32 error otherwise.


Note:

--*/
{
    HKEY  hKey ;
    DWORD err ;

    if (!MprOpenKey(
            HKEY_CURRENT_USER,
            PRINT_CONNECTION_KEY_NAME,
            &hKey,
            DA_WRITE))
    {
        return (GetLastError()) ;
    }

    err = RegDeleteValue(hKey,
                         lpName) ;

    RegCloseKey(hKey) ;
    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\mprlock.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mprlock.cxx

Abstract:

    Contains code for the MPR provider database manager.  This file
    contains the following classes:
        CMPRProviderLock

Author:

    Jonathan Schwartz (jschwart)    19-May-1999

Environment:

    User Mode -Win32

Revision History:

    19-May-1999     jschwart
        Created, converted from \nt\private\windows\screg\sc\server\lock.cxx.

--*/

//
// INCLUDES
//

#include "precomp.hxx"

//
// Macros
//
#define LOCK_LOG(string)    MPR_LOG3(LOCKS, " %s" string " level = %ld\n", \
                                        _ShortName, _Name, CurrentLevel())

//
// Globals
//
CProviderLock    MPRProviderLock;


/*************************************************************************/
/* CCountingResource methods                                             */
/*************************************************************************/

#if DBG
void
CCountingResource::GetShared()
{
    LOCK_LOG(" Asking for %s lock shared...");
    ASSERT(!HaveExclusive());
    RtlAcquireResourceShared(&_Lock, TRUE);
    SetCurrentLevel(CurrentLevel() + 1);
    LOCK_LOG("+Acquired %s lock shared,");
}

void
CCountingResource::GetExclusive()
{
    LOCK_LOG(" Asking for %s lock exclusive...");
    ASSERT(!Have() || HaveExclusive());
    RtlAcquireResourceExclusive(&_Lock, TRUE);
    SetCurrentLevel(CurrentLevel() - 1);
    LOCK_LOG("+Acquired %s lock exclusive,");
}

void
CCountingResource::Release()
{
    LOCK_LOG("-Releasing %s lock...");
    ASSERT(Have());
    RtlReleaseResource( &_Lock );
    if (CurrentLevel() > 0)
    {
        SetCurrentLevel(CurrentLevel() - 1);
    }
    else
    {
        SetCurrentLevel(CurrentLevel() + 1);
    }
    LOCK_LOG(" Released %s lock,");
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\mprui.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mprui.h

Abstract:

    Prototypes and manifests to support mprui.cxx.

Author:

    ChuckC    28-Jul-1992

Environment:

    User Mode -Win32

Notes:

Revision History:

    28-Jul-1992     Chuckc  Created

--*/

DWORD
DoPasswordDialog(
    HWND          hwndOwner,
    TCHAR *       pchResource,
    TCHAR *       pchUserName,
    TCHAR *       pchPasswordReturnBuffer,
    ULONG         cbPasswordReturnBuffer, // bytes!
    BOOL *        pfDidCancel,
    DWORD         dwError
    );

DWORD
DoProfileErrorDialog(
    HWND          hwndOwner,
    const TCHAR * pchDevice,
    const TCHAR * pchResource,
    const TCHAR * pchProvider,
    DWORD         dwError,
    BOOL          fAllowCancel,
    BOOL *        pfDidCancel,
    BOOL *        pfDisconnect,
    BOOL *        pfHideErrors
    );

DWORD
ShowReconnectDialog(
    HWND          hwndParent,
    PARAMETERS *  Params
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\mprui.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mprui.cxx

Abstract:

    Contains the entry points for the UI pieces that live in a
    separate DLL. The entry points are made available here, but
    will not load the MPRUI.DLL until it is needed.

    Contains:

Author:

    Chuck Y Chan (chuckc)   20-Jul-1992

Environment:

    User Mode -Win32

Notes:

Revision History:

    20-Jul-1992     chuckc  created

    25-Oct-1992     CongpaY     added ShowReconnectDialog

    30-Nov-1992     Yi-HsinS    added WNetSupportGlobalEnum

    12-May-1993     Danl
        WNetClearConnections: Added code to free MPRUI.DLL after calling
        the MPRUI function to clear connections.  REASON:
        This code path is called by winlogon.  It causes mprui.dll
        to get loaded.  Mprui references MPR.DLL.  Because MPRUI.DLL was never
        getting freed, winlogon could never free MPR.DLL.

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/

#include "precomp.hxx"


/*
 * global functions
 */

BOOL MprGetProviderIndexFromDriveName(LPWSTR lpDriveName, LPDWORD lpnIndex );


/*******************************************************************

    NAME:   WNetConnectionDialog1A

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    chuckc      29-Jul-1992    Created
    brucefo 18-May-1995 Created

********************************************************************/

DWORD
WNetConnectionDialog1A(
    LPCONNECTDLGSTRUCTA lpConnDlgStruct
    )
{
    return MPRUI_WNetConnectionDialog1A(lpConnDlgStruct);
}


/*******************************************************************

    NAME:   WNetConnectionDialog1W

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    chuckc      29-Jul-1992    Created
    brucefo 18-May-1995 Created

********************************************************************/

DWORD
WNetConnectionDialog1W(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    )
{
    return MPRUI_WNetConnectionDialog1W(lpConnDlgStruct);
}


/*******************************************************************

    NAME:   WNetDisconnectDialog1A

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    chuckc      29-Jul-1992    Created
    brucefo 18-May-1995 Created

********************************************************************/

DWORD
WNetDisconnectDialog1A(
    LPDISCDLGSTRUCTA lpDiscDlgStruct
    )
{
    return MPRUI_WNetDisconnectDialog1A(lpDiscDlgStruct);
}


/*******************************************************************

    NAME:   WNetDisconnectDialog1W

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    chuckc      29-Jul-1992    Created
    brucefo 18-May-1995 Created

********************************************************************/

DWORD
WNetDisconnectDialog1W(
    LPDISCDLGSTRUCTW lpDiscDlgStruct
    )
{
    return MPRUI_WNetDisconnectDialog1W(lpDiscDlgStruct);
}


/*******************************************************************

    NAME:   WNetConnectionDialog

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    chuckc  29-Jul-1992    Created

********************************************************************/

DWORD
WNetConnectionDialog(
    HWND  hwnd,
    DWORD dwType
    )
{
    return MPRUI_WNetConnectionDialog(hwnd, dwType);
}


/*******************************************************************

    NAME:   WNetConnectionDialog2

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    chuckc   29-Jul-1992    Created
    JSchwart 11-Mar-2001    Readded for winfile.exe support

********************************************************************/

DWORD
WNetConnectionDialog2(
    HWND   hwnd,
    DWORD  dwType,
    LPWSTR lpHelpFile,
    DWORD  nHelpContext
    )
{
    return WNetConnectionDialog(hwnd, dwType);
}


/*******************************************************************

    NAME:   WNetDisconnectDialog

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    chuckc  29-Jul-1992    Created

********************************************************************/

DWORD
WNetDisconnectDialog(
    HWND  hwnd,
    DWORD dwType
    )
{
    return MPRUI_WNetDisconnectDialog(hwnd, dwType);
}


/*******************************************************************

    NAME:   WNetConnectionDialog2

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    chuckc   29-Jul-1992    Created
    JSchwart 11-Mar-2001    Readded for winfile.exe support

********************************************************************/

DWORD
WNetDisconnectDialog2(
    HWND   hwnd,
    DWORD  dwType,
    LPWSTR lpHelpFile,
    DWORD  nHelpContext
    )
{
    return WNetDisconnectDialog(hwnd, dwType);
}


/*******************************************************************

    NAME:   WNetClearConnections

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    chuckc  29-Jul-1992    Created

********************************************************************/

DWORD
WNetClearConnections(
    HWND hWndParent
    )
{
    return MPRUI_WNetClearConnections(hWndParent);
}


/*******************************************************************

    NAME:   DoPasswordDialog

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    chuckc  29-Jul-1992    Created

********************************************************************/

DWORD
DoPasswordDialog(
    HWND          hwndOwner,
    LPWSTR        pchResource,
    LPWSTR        pchUserName,
    LPWSTR        pchPasswordReturnBuffer,
    ULONG         cbPasswordReturnBuffer, // bytes!
    BOOL *        pfDidCancel,
    DWORD         dwError
    )
{
    return MPRUI_DoPasswordDialog(hwndOwner,
                                  pchResource,
                                  pchUserName,
                                  pchPasswordReturnBuffer,
                                  cbPasswordReturnBuffer,
                                  pfDidCancel,
                                  dwError);
}


/*******************************************************************

    NAME:   DoProfileErrorDialog

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    chuckc  29-Jul-1992    Created

********************************************************************/

DWORD
DoProfileErrorDialog(
    HWND          hwndOwner,
    const TCHAR * pchDevice,
    const TCHAR * pchResource,
    const TCHAR * pchProvider,
    DWORD         dwError,
    BOOL          fAllowCancel,
    BOOL *        pfDidCancel,
    BOOL *        pfDisconnect,
    BOOL *        pfHideErrors
    )
{
    return MPRUI_DoProfileErrorDialog(hwndOwner,
                                      pchDevice,
                                      pchResource,
                                      pchProvider,
                                      dwError,
                                      fAllowCancel,
                                      pfDidCancel,
                                      pfDisconnect,
                                      pfHideErrors);
}


/*******************************************************************

    NAME:   ShowReconnectDialog

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    congpay 25-Oct-1992    Created

********************************************************************/

DWORD
ShowReconnectDialog(
    HWND          hwndParent,
    PARAMETERS    *Params
    )
{
    return MPRUI_ShowReconnectDialog(hwndParent, Params);
}


/*******************************************************************

    NAME:   WNetGetSearchDialog

    SYNOPSIS:   gets the pointer to NPSearchDialog() from named provider

    ENTRY:  Assumes the provider table in router has been setup,
        which is always the case after DLL init.

        lpProvider - name of provider to query

    EXIT:

    NOTES:

    HISTORY:
    chuckc  19-Mar-1992    Created

********************************************************************/

FARPROC WNetGetSearchDialog(LPWSTR lpProvider)
{
    ULONG   index ;
    BOOL    fOK ;
    DWORD   status;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    //
    // INIT_IF_NECESSARY
    //
    if (!(GlobalInitLevel & NETWORK_LEVEL)) {
        status = MprLevel2Init(NETWORK_LEVEL);
        if (status != WN_SUCCESS) {
            return(NULL);
        }
    }

    if (lpProvider == NULL)
        return NULL ;

    fOK =  MprGetProviderIndex(lpProvider, &index) ;

    if  (!fOK)
       return(NULL) ;

    return((FARPROC)GlobalProviderInfo[index].SearchDialog) ;
}

/*******************************************************************

    NAME:   WNetSupportGlobalEnum

    SYNOPSIS:   Check if the provider supports global enumeration

    ENTRY:  Assumes the provider table in router has been setup,
        which is always the case after DLL init.

        lpProvider - name of provider to query

    EXIT:

    NOTES:

    HISTORY:
    Yi-HsinS    30-Nov-1992    Created

********************************************************************/

BOOL WNetSupportGlobalEnum( LPWSTR lpProvider )
{
    MprCheckProviders();

    CProviderSharedLock    PLock;

    //
    // INIT_IF_NECESSARY
    //
    DWORD   status;
    if (!(GlobalInitLevel & NETWORK_LEVEL)) {
        status = MprLevel2Init(NETWORK_LEVEL);
        if (status != WN_SUCCESS) {
            return(FALSE);
        }
    }

    if ( lpProvider != NULL )
    {
        ULONG index;

        if (  MprGetProviderIndex( lpProvider, &index )
           && ( GlobalProviderInfo[index].GetCaps(WNNC_ENUMERATION)
                & WNNC_ENUM_GLOBAL )
           )
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*******************************************************************

    NAME:   WNetFMXGetPermCaps

    SYNOPSIS:  Gets the permission capabilites from the provider
               supporting the given drive.

    ENTRY:  Assumes the provider table in router has been setup,
        which is always the case after DLL init.

        lpDriveName - Name of drive

    EXIT:
        Returns a bitmask representing the permission capabilities
        of the provider.

    NOTES:

    HISTORY:
        YiHsinS  11-Apr-1994    Created

********************************************************************/

DWORD WNetFMXGetPermCaps( LPWSTR lpDriveName )
{
    ULONG   index ;
    BOOL    fOK ;
    DWORD   status;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    //
    // INIT_IF_NECESSARY
    //
    if (!(GlobalInitLevel & NETWORK_LEVEL))
    {
        status = MprLevel2Init(NETWORK_LEVEL);
        if (status != WN_SUCCESS)
            return 0;
    }

    if ( lpDriveName != NULL)
    {
        fOK = MprGetProviderIndexFromDriveName( lpDriveName, &index);

        if (  fOK
           && ( GlobalProviderInfo[index].FMXGetPermCaps != NULL )
           )
        {
            return( GlobalProviderInfo[index].FMXGetPermCaps( lpDriveName));
        }
    }

    return 0;
}

/*******************************************************************

    NAME:   WNetFMXEditPerm

    SYNOPSIS: Asks the provider supporting the given drive to pop up
              its own permission editor.

    ENTRY:  Assumes the provider table in router has been setup,
        which is always the case after DLL init.

        lpDriveName - Name of drive
        hwndFMX - Handle of the FMX window in File Manager
        nDialogType - Specify the type of permission dialog to bring up.
                      It can be one of the following values:
                          WNPERM_DLG_PERM
                          WNPERM_DLG_AUDIT
                          WNPERM_DLG_OWNER

    EXIT:
        Returns WN_SUCCESS or any error that occurred

    NOTES:

    HISTORY:
        YiHsinS  11-Apr-1994    Created

********************************************************************/

DWORD WNetFMXEditPerm( LPWSTR lpDriveName, HWND hwndFMX, DWORD nDialogType )
{
    ULONG   index ;
    BOOL    fOK ;
    DWORD   status = WN_SUCCESS;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    //
    // INIT_IF_NECESSARY
    //
    if (!(GlobalInitLevel & NETWORK_LEVEL))
    {
        status = MprLevel2Init(NETWORK_LEVEL);
        if (status != WN_SUCCESS)
            return status;
    }

    //
    // Check input parameters
    //
    if (  ( lpDriveName == NULL)
       || ( hwndFMX == NULL )
       || ( nDialogType != WNPERM_DLG_PERM
          && nDialogType != WNPERM_DLG_AUDIT
          && nDialogType != WNPERM_DLG_OWNER )
       )
    {
        status = WN_BAD_VALUE;
    }
    else
    {
        fOK = MprGetProviderIndexFromDriveName( lpDriveName, &index) ;

        if ( !fOK )
        {
            status = WN_NO_NET_OR_BAD_PATH;
        }
        else
        {
            if ( GlobalProviderInfo[index].FMXEditPerm == NULL )
                status = WN_NOT_SUPPORTED;

            else
                status = GlobalProviderInfo[index].FMXEditPerm( lpDriveName,
                                                                hwndFMX,
                                                                nDialogType );
        }
    }

    if ( status != WN_SUCCESS )
        SetLastError( status );

    return status;
}

/*******************************************************************

    NAME:   WNetFMXGetPermHelp

    SYNOPSIS: Requests the provider supporting the given drive for
              the help file name and help context for the menu item
              with the given type of permission dialog.
              i.e. the help when F1 is pressed when a menu item is
              selected.


    ENTRY:  Assumes the provider table in router has been setup,
        which is always the case after DLL init.

        lpDriveName - Name of drive
        nDialogType - Specify the type of help requested.
                      It can be one of the following values:
                          WNPERM_DLG_PERM
                          WNPERM_DLG_AUDIT
                          WNPERM_DLG_OWNER
        fDirectory - TRUE if the selected item is a directory, FALSE otherwise
        lpFileNameBuffer - Pointer to buffer that will receive the
                      help file name
        lpBufferSize   - Specify the size of lpBuffer
        lpnHelpContext - Points to a DWORD that will receive the help context

    EXIT:
        Returns WN_SUCCESS or any error that occurred

    NOTES:

    HISTORY:
        YiHsinS  11-Apr-1994    Created

********************************************************************/

DWORD WNetFMXGetPermHelp( LPWSTR  lpDriveName,
                          DWORD   nDialogType,
                          BOOL    fDirectory,
                          LPVOID  lpFileNameBuffer,
                          LPDWORD lpBufferSize,
                          LPDWORD lpnHelpContext )
{
    ULONG   index ;
    BOOL    fOK ;
    DWORD   status = WN_SUCCESS;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    //
    // INIT_IF_NECESSARY
    //
    if (!(GlobalInitLevel & NETWORK_LEVEL))
    {
        status = MprLevel2Init(NETWORK_LEVEL);
        if (status != WN_SUCCESS)
            return status;
    }

    //
    // Check input parameters
    //
    if (  ( lpDriveName == NULL)
       || ( nDialogType != WNPERM_DLG_PERM
          && nDialogType != WNPERM_DLG_AUDIT
          && nDialogType != WNPERM_DLG_OWNER )
       )
    {
        status = WN_BAD_VALUE;
    }
    else
    {
        fOK = MprGetProviderIndexFromDriveName( lpDriveName, &index) ;

        if ( !fOK )
        {
            status = WN_NO_NET_OR_BAD_PATH;
        }
        else
        {
            if ( GlobalProviderInfo[index].FMXGetPermHelp == NULL )
                status = WN_NOT_SUPPORTED;
            else
                status = GlobalProviderInfo[index].FMXGetPermHelp(
                                                       lpDriveName,
                                                       nDialogType,
                                                       fDirectory,
                                                       lpFileNameBuffer,
                                                       lpBufferSize,
                                                       lpnHelpContext );
        }
    }

    if ( status != WN_SUCCESS )
        SetLastError( status );

    return status;
}

/*******************************************************************

    NAME:  MprGetProviderIndexFromDriveName

    SYNOPSIS:  Gets the index of the provider in the provider array
               supporting the drive name connection.

    ENTRY:
        lpDriveName - Name of the drive
        lpnIndex    - Points to a DWORD that will receive the index

    EXIT:
        TRUE if we successfully retrieved the index, FALSE otherwise.

    NOTES:

    HISTORY:
        YiHsinS  11-Apr-1994    Created

********************************************************************/

BOOL MprGetProviderIndexFromDriveName(LPWSTR lpDriveName, LPDWORD lpnIndex )
{
    DWORD  status;
    WCHAR  szRemoteName[MAX_PATH];
    DWORD  nBufferSize = sizeof(szRemoteName);

    status = MprGetConnection( lpDriveName,
                               szRemoteName,
                               &nBufferSize,
                               lpnIndex );

    //
    // *lpnIndex will be correct if status is WN_SUCCESS or WN_MORE_DATA
    // and we don't really need the remote name. Hence, we don't need to
    // call MprGetConnection again with a bigger buffer if WN_MORE_DATA
    // is returned.
    //

    return ( status == WN_SUCCESS || status == WN_MORE_DATA );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\mprtest.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mprtest.cxx

Abstract:

    Test routine for MPR entry Points.

Author:

    Dan Lafferty (danl)     17-Dec-1991

Environment:

    User Mode -Win32

Revision History:

    17-Dec-1991     danl
        created
--*/

#include "precomp.hxx"
extern "C" {
#include <ntmsv1_0.h>
}
#include <stdlib.h>     // atoi
#include <stdio.h>      // printf
#include <conio.h>      // getch
#include <string.h>     // strcmp
#include <tstr.h>       // Unicode

#include <debugfmt.h>   // FORMAT_LPTSTR

//
// Defines
//

#define ERR_BUF_SIZE    260
#define NAME_BUF_SIZE   260

//
// Local Functions
//
BOOL
ProcessArgs(
    DWORD   argc,
    LPTSTR  argv[]
    );

VOID
RecursiveEnum(
    DWORD           RecursionLevel,
    DWORD           ResourceUsage,
    LPNETRESOURCE   EnumNetResource
    );

BOOL
ConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPSTR   AnsiIn
    );

BOOL
GetStringFromFile(
    LPDWORD     LoopCount,
    LPSTR       buffer
    );

BOOL
MakeArgsUnicode (
    DWORD           argc,
    PCHAR           argv[]
    );

VOID
TestAddConnect2(
    LPTSTR  RemoteName,
    LPTSTR  RedirName);

VOID
TestAddConnect3(
    LPTSTR  RemoteName,
    LPTSTR  RedirName);

VOID
TestGetConnect(
    LPTSTR  lpDeviceName,
    DWORD   bufferSize);

VOID
TestGetUniversal(
    LPTSTR  lpDeviceName,
    DWORD   level,
    DWORD   bufferSize);

VOID
TestGetUser(
    LPTSTR  lpDevice,
    DWORD   bufferSize);

VOID
TestEnumConnect(
    DWORD  scope,
    DWORD  type);

VOID
TestEnumNet(VOID);

VOID
TestSetError(VOID);

VOID
TestMultiError(VOID);

VOID
TestDirStuff(VOID);

VOID
TestRestoreConnect(
    LPTSTR  lpDrive);

VOID
TestLotsOfStuff(VOID);


VOID
DisplayExtendedError(VOID);

VOID
DisplayMultiError(VOID);


VOID
DisplayResourceArray(
    LPNETRESOURCE   NetResource,
    DWORD           NumElements
    );

VOID
DisplayResource(
    LPNETRESOURCE   NetResource
    );

VOID
TestClearConnect(
    VOID
    );

VOID
Usage(VOID);

VOID
InvalidParms(VOID);

LONG
wtol(
    IN LPWSTR string
    );

VOID
TestLogonNotify(
    LPTSTR  argv[],
    DWORD   argc
    );

VOID
TestChangePassword(
    LPTSTR  argv[],
    DWORD   argc
    );


VOID __cdecl
main (
    VOID
    )

/*++

Routine Description:

    Allows manual testing of the MPR API.

        mprtest



Arguments:



Return Value:



--*/
{
    UCHAR   i;
    DWORD   j;
    LPTSTR  *argv;
    CHAR    buffer[255];
    LPSTR   argvA[20];
    DWORD   argc=0;
    BOOL    KeepGoing;
    DWORD   LoopCount = 0;

    do {
        //
        // Get input from the user
        //
        buffer[0] = 90-2;

        if (LoopCount != 0) {
            GetStringFromFile(&LoopCount, buffer);
            printf("%s\n",buffer+2);
        }
        else {
            printf("\nwaiting for instructions... \n");
            cgets(buffer);
        }
        if (buffer[1] > 0) {
            //
            // put the string in argv/argc format.
            //
            buffer[1]+=2;       // make this an end offset
            argc=0;
            for (i=2,j=0; i<buffer[1]; i++,j++) {
                argc++;
                argvA[j] = &(buffer[i]);
                while ((buffer[i] != ' ') && (buffer[i] != '\0')) {
                    i++;
                }
                buffer[i] = '\0';
            }

            //
            // Make the arguments unicode if necessary.
            //
#ifdef UNICODE

            if (!MakeArgsUnicode(argc, argvA)) {
                return;
            }

#endif
            argv = (LPTSTR *)argvA;

            if (STRICMP (argv[0], TEXT("Loop")) == 0) {
                if (argc == 1) {
                    LoopCount=1;
                }
                else {
#ifdef UNICODE
                    LoopCount = wtol(argv[1]);
#else
                    LoopCount = atol(argv[1]);
#endif
                }
                KeepGoing  = TRUE;
            }
            else if (STRICMP (argv[0], TEXT("done")) == 0) {
                LoopCount=0;
                KeepGoing  = TRUE;
            }
            else {
                KeepGoing = ProcessArgs(argc, argv);
            }
#ifdef UNICODE
            //
            // Free up the unicode strings if there are any
            //
            for(j=0; j<argc; j++) {
                LocalFree(argv[j]);
            }
#endif
        }
    } while (KeepGoing);

    return;
}

BOOL
ProcessArgs(
    DWORD   argc,
    LPTSTR  argv[]
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD   status;
    LPTSTR  remoteName;
    LPTSTR  redirName;
    DWORD   i;
    DWORD   type;


    //
    // Check Arguments
    //
    if (*argv[0] == TEXT('\0')) {
        printf("ERROR: no function was requested!\n");
        Usage();
        return(TRUE);
    }

    //
    // Make the arguments unicode if necessary.
    //
    //**************
    // AddConnect1
    //**************
    if (STRICMP (argv[0], TEXT("AddConnect1")) == 0) {
        //
        // If the connection information was passed in, use it.  Otherwise,
        // use the default.
        //
        if (argc == 3) {
            remoteName = argv[2];
            redirName = argv[1];
        }
        else {
            remoteName = TEXT("\\\\popcorn\\public");
            redirName = TEXT("f:");
        }

        //
        // Add the Connection.
        //
        status = WNetAddConnection(
                    remoteName,
                    NULL,
                    redirName);

        if ( status != WN_SUCCESS) {
            printf("WNetAddConnection failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
        }
        else {
            printf("WNetAddConnection Success\n");
        }
    }

    //**************
    // AddConnect2
    //**************
    else if (STRICMP (argv[0], TEXT("AddConnect2")) == 0) {
        //
        // If the connection information was passed in, use it.  Otherwise,
        // use the default.
        //
        if (argc == 3) {
            remoteName = argv[2];
            redirName = argv[1];
        }
        else {
            remoteName = TEXT("\\\\popcorn\\public");
            redirName = TEXT("f:");
        }

        //
        // Call the test program
        //
        TestAddConnect2(remoteName, redirName);
        printf("Call it again without a redirected drive letter\n");
        TestAddConnect2(remoteName, NULL);
    }

    //**************
    // AddConnect3
    //**************
    else if (STRICMP (argv[0], TEXT("AddConnect3")) == 0) {
        //
        // If the connection information was passed in, use it.  Otherwise,
        // use the default.
        //
        if (argc == 3) {
            remoteName = argv[2];
            redirName = argv[1];
        }
        else {
            remoteName = TEXT("\\\\popcorn\\public");
            redirName = TEXT("f:");
        }

        //
        // Call the test program
        //
        TestAddConnect3(remoteName, redirName);
        printf("Call it again without a redirected drive letter\n");
        TestAddConnect3(remoteName, NULL);
    }

    //**************
    // CancelConnect
    //**************
    else if (STRICMP (argv[0], TEXT("CancelConnect")) == 0) {
        BOOL    rememberFlag = FALSE;
        BOOL    ForceFlag = FALSE;

        //
        // See if the redirected name was passed in.
        //
        if (argc >= 2) {
            redirName = argv[1];
        }
        else {
            redirName = TEXT("f:");
        }
        for (i=2; argc>i; i++) {
            if (STRICMP (argv[i], TEXT("r")) ==0) {
                rememberFlag = TRUE;
            }
            if (STRICMP (argv[i], TEXT("f")) ==0) {
                ForceFlag = TRUE;
            }
        }

        if (rememberFlag) {
            status = WNetCancelConnection(redirName, ForceFlag);
        }
        else {
            status = WNetCancelConnection2(redirName, 0, ForceFlag);
        }

        if ( status != WN_SUCCESS) {
            printf("WNetCancelConnection failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
        }
        else {
            printf("WNetCancelConnection Success\n");
        }
    }

    //**************
    // GetConnect
    //**************
    else if (STRICMP (argv[0], TEXT("GetConnect")) == 0) {

        LPTSTR  deviceName = NULL;
        DWORD   bufSize = NAME_BUF_SIZE;

        if (argc >= 2) {
            deviceName = argv[1];
        }
        if (argc >= 3) {
            bufSize = ATOL(argv[2]);
        }

        TestGetConnect( deviceName, bufSize);
    }

    //******************
    // GetUniversalName
    //******************
    else if (STRICMP (argv[0], TEXT("GetUniversalName")) == 0) {

        LPTSTR  deviceName = NULL;
        DWORD   bufSize = NAME_BUF_SIZE;
        DWORD   infoLevel = UNIVERSAL_NAME_INFO_LEVEL;

        if (argc >= 2) {
            deviceName = argv[1];
        }
        if (argc >= 3) {
            infoLevel = ATOL(argv[2]);
        }
        if (argc >= 4) {
            bufSize = ATOL(argv[3]);
        }

        TestGetUniversal( deviceName, infoLevel, bufSize);
    }

    //**************
    // GetUser
    //**************
    else if (STRICMP (argv[0], TEXT("GetUser")) == 0) {

        LPTSTR  deviceName = NULL;
        DWORD   bufSize = NAME_BUF_SIZE;

        i=1;
        while (argc > (i)) {

            if (STRICMP(argv[i], TEXT("bufSize=")) == 0) {
                bufSize = ATOL(argv[i+1]);
                i++;
            }
            if (STRICMP(argv[i], TEXT("device=")) == 0) {
                deviceName = argv[i+1];
                i++;
            }
            i++;
        }

        TestGetUser(deviceName,bufSize);

    }

    //**************
    // Enum
    //**************
    else if (STRICMP (argv[0], TEXT("EnumConnect")) == 0 ||
             STRICMP (argv[0], TEXT("EnumContext")) == 0) {

        DWORD scope = STRICMP (argv[0], TEXT("EnumConnect")) ?
                            RESOURCE_CONTEXT : RESOURCE_CONNECTED;
        type = RESOURCETYPE_ANY;

        for (i=1; i<argc; i++) {
            if (STRICMP(argv[i], TEXT("r")) == 0) {
                scope = RESOURCE_REMEMBERED;
            }
            else if (STRICMP(argv[i], TEXT("ANY")) == 0) {
                type = RESOURCETYPE_ANY;
            }
            else if (STRICMP(argv[i], TEXT("DISK")) == 0) {
                type = RESOURCETYPE_DISK;
            }
            else if (STRICMP(argv[i], TEXT("PRINT")) == 0) {
                type = RESOURCETYPE_PRINT;
            }
            else {
                printf("Bad argument\n");
                Usage();
                return(TRUE);
            }
        }
        TestEnumConnect(scope, type);

    }
    else if (STRICMP (argv[0], TEXT("EnumNet")) == 0) {
        RecursiveEnum(0, 0, NULL);
        //TestEnumNet();
    }
    //**************
    // SetLastError
    //**************
    else if (STRICMP (argv[0], TEXT("SetError")) == 0) {
        TestSetError();
    }

    //*********************
    // MultinetGetErrorText
    //*********************
    else if (STRICMP (argv[0], TEXT("MultiError")) == 0) {
        TestMultiError();
    }

    //************************************
    // GetDirectoryType & DirectoryNotify
    //************************************
    else if (STRICMP (argv[0], TEXT("DirApi")) == 0) {
        TestDirStuff();
    }

    //****************
    // RestoreConnect
    //****************
    else if (STRICMP (argv[0], TEXT("RestoreConnect")) == 0) {

        if (argc == 2) {
            TestRestoreConnect(argv[1]);
        }
        else {
            TestRestoreConnect(NULL);
        }
    }
    //****************
    // ClearConnect
    //****************
    else if (STRICMP (argv[0], TEXT("ClearConnect")) == 0) {

        TestClearConnect();
    }
    //****************
    // LogonNotify
    //****************
    else if (STRICMP (argv[0], TEXT("LogonNotify")) == 0) {

        TestLogonNotify(&argv[1],argc-1);
    }
    //****************
    // LogonNotify
    //****************
    else if (STRICMP (argv[0], TEXT("ChangePassword")) == 0) {

        TestChangePassword(&argv[1],argc-1);
    }
    //************************************
    // ALL
    //************************************
    else if (STRICMP (argv[0], TEXT("all")) == 0) {
        TestLotsOfStuff();
    }

    //****************
    // InvalidParms
    //****************
    else if (STRICMP (argv[0], TEXT("InvalidParms")) == 0) {
        InvalidParms();
    }

    //****************
    // Exit Program
    //****************
    else if (STRICMP (argv[0], TEXT("Exit")) == 0) {
        return(FALSE);
    }


    else {
        printf("Bad argument\n");
        Usage();
    }

    return(TRUE);
}

VOID
TestAddConnect2(
    LPTSTR   RemoteName,
    LPTSTR   RedirName)
{
    LPNETRESOURCE   netResource;
    DWORD           status;
    DWORD           numchars = 0;

    netResource = (LPNETRESOURCE) LocalAlloc(LPTR, sizeof(NETRESOURCE));

    if (netResource == NULL) {
        printf("TestAddConnect2:LocalAlloc Failed %d\n",GetLastError);
        return;
    }

    netResource->lpRemoteName = RemoteName;
    netResource->lpLocalName  = RedirName;

    if (RedirName != NULL) {
        numchars = STRLEN(RedirName);
    }

    if (numchars == 0) {
        netResource->dwType = RESOURCETYPE_ANY;
    }
    else if (numchars > 2) {
        netResource->dwType = RESOURCETYPE_PRINT;
    }
    else {
        netResource->dwType = RESOURCETYPE_DISK;
    }

    status = WNetAddConnection2(
                netResource,
                NULL,
                NULL,
                0L);

    if ( status != WN_SUCCESS) {
        printf("WNetAddConnection2 failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
    }
    else {
        printf("WNetAddConnection2 Success\n");
    }
    LocalFree(netResource);
    return;
}

VOID
TestAddConnect3(
    LPTSTR   RemoteName,
    LPTSTR   RedirName)
{
    LPNETRESOURCE   netResource;
    DWORD           status;
    DWORD           numchars = 0;

    netResource = (LPNETRESOURCE) LocalAlloc(LPTR, sizeof(NETRESOURCE));

    if (netResource == NULL) {
        printf("TestAddConnect3:LocalAlloc Failed %d\n",GetLastError);
        return;
    }

    netResource->lpRemoteName = RemoteName;
    netResource->lpLocalName  = RedirName;

    if (RedirName != NULL) {
        numchars = STRLEN(RedirName);
    }

    if (numchars == 0) {
        netResource->dwType = RESOURCETYPE_ANY;
    }
    else if (numchars > 2) {
        netResource->dwType = RESOURCETYPE_PRINT;
    }
    else {
        netResource->dwType = RESOURCETYPE_DISK;
    }

    status = WNetAddConnection3(
                (HWND)0x33113322,
                netResource,
                NULL,
                NULL,
                0L);

    if ( status != WN_SUCCESS) {
        printf("WNetAddConnection3 failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
    }
    else {
        printf("WNetAddConnection3 Success\n");
    }
    LocalFree(netResource);
    return;
}

VOID
TestGetConnect(
    LPTSTR   lpDeviceName,
    DWORD    bufferSize)
{
    LPTSTR  remoteName = NULL;
    DWORD   status;
    TCHAR   defaultDevice[]=TEXT("f:");
    LPTSTR  lpDevice;


    if (lpDeviceName == NULL) {
        lpDevice = defaultDevice;
    }
    else {
        lpDevice = lpDeviceName;
    }
    remoteName = (LPTSTR)LocalAlloc(LMEM_FIXED, bufferSize);
    if (remoteName == NULL) {
        printf("TestGetConnect: Couldn't allocate memory\n");
        return;
    }

    //
    // 1st Time
    //
    status = WNetGetConnection(
                lpDevice,
                remoteName,
                &bufferSize);

    if (( status != WN_SUCCESS) && (status != ERROR_CONNECTION_UNAVAIL)) {
        printf("WNetGetConnection failed %d\n",status);
        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        //
        // If insufficient buffer, display needed size.
        //
        if (status == WN_MORE_DATA) {
            printf("Insufficient buffer size.  Need %d bytes\n",bufferSize);
        }
    }
    else {
        if (status == ERROR_CONNECTION_UNAVAIL) {
            printf("Not Currently Connected, but it is remembered\n");
        }
        else {
            printf("WNetGetConnection Success\n");
        }
        printf(""FORMAT_LPTSTR" is connected to "FORMAT_LPTSTR"\n",lpDevice,remoteName);
    }

    //
    // 2nd Time
    //
    if (remoteName != NULL) {
        LocalFree(remoteName);
    }
    printf("Allocating a new buffer of %d bytes\n",bufferSize);
    remoteName = (LPTSTR)LocalAlloc(LMEM_FIXED, bufferSize);
    if (remoteName == NULL) {
        printf("TestGetConnect: Couldn't allocate memory(2nd time)\n");
        return;
    }

    status = WNetGetConnection(
                lpDevice,
                remoteName,
                &bufferSize);

    if (( status != WN_SUCCESS) && (status != ERROR_CONNECTION_UNAVAIL)) {
        printf("WNetGetConnection failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        //
        // If insufficient buffer, display needed size.
        //
        if (status == WN_MORE_DATA) {
            printf("Insufficient buffer size.  Need %d bytes\n",bufferSize);
        }
    }
    else {
        if (status == ERROR_CONNECTION_UNAVAIL) {
            printf("Not Currently Connected, but it is remembered\n");
        }
        else {
            printf("WNetGetConnection Success\n");
        }
        printf(""FORMAT_LPTSTR" is connected to "FORMAT_LPTSTR"\n",lpDevice,remoteName);
    }
    if (remoteName != NULL) {
        LocalFree(remoteName);
    }
    return;
}

VOID
TestGetUniversal(
    LPTSTR  lpDeviceName,
    DWORD   level,
    DWORD   bufferSize)
{
    LPBYTE  buffer = NULL;
    DWORD   status;
    TCHAR   defaultDevice[]=TEXT("");
    LPTSTR  lpDevice;
    LPTSTR  pNothing = TEXT("<nothing>");

    LPUNIVERSAL_NAME_INFO   pUniversalInfo = NULL;
    LPREMOTE_NAME_INFO      pRemoteInfo = NULL;


    if (lpDeviceName == NULL) {
        lpDevice = defaultDevice;
    }
    else {
        lpDevice = lpDeviceName;
    }

    buffer = (LPBYTE)LocalAlloc(LMEM_FIXED, bufferSize);
    if (buffer == NULL) {
        printf("TestGetConnect: Couldn't allocate memory\n");
        return;
    }

    //----------------
    // 1st Time
    //----------------
    status = WNetGetUniversalName(
                lpDevice,
                level,
                buffer,
                &bufferSize);

    if (( status != WN_SUCCESS) && (status != ERROR_CONNECTION_UNAVAIL)) {
        printf("WNetGetUniversalName failed %d\n",status);
        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        //
        // If insufficient buffer, display needed size.
        //
        if (status == WN_MORE_DATA) {
            printf("Insufficient buffer size.  Need %d bytes\n",bufferSize);
        }
    }
    else {
        if (status == ERROR_CONNECTION_UNAVAIL) {
            printf("Not Currently Connected, but it is remembered\n");
        }
        else {
            printf("WNetGetUniversalName Success\n");
        }
        switch (level) {
        case UNIVERSAL_NAME_INFO_LEVEL:

            pUniversalInfo = (LPUNIVERSAL_NAME_INFO)buffer;
            printf(""FORMAT_LPTSTR" is connected to "FORMAT_LPTSTR"\n",
                lpDevice,pUniversalInfo->lpUniversalName);

            break;
        case REMOTE_NAME_INFO_LEVEL:

            pRemoteInfo = (LPREMOTE_NAME_INFO)buffer;

            if (pRemoteInfo->lpUniversalName == NULL) {
                pRemoteInfo->lpUniversalName = pNothing;
            }

            printf(""FORMAT_LPTSTR" is connected to: \n"
                "  UniversalName  = "FORMAT_LPTSTR"\n"
                "  ConnectionName = "FORMAT_LPTSTR"\n"
                "  RemainingPath  = "FORMAT_LPTSTR"\n\n",
                lpDevice,
                pRemoteInfo->lpUniversalName,
                pRemoteInfo->lpConnectionName,
                pRemoteInfo->lpRemainingPath);

            break;

        default:
            printf("PROBLEM:   Invalid Level didn't produce an error\n");
        }
    }

    //---------------
    // 2nd Time
    //---------------
    if (buffer != NULL) {
        LocalFree(buffer);
    }
    printf("Allocating a new buffer of %d bytes\n",bufferSize);
    buffer = (LPBYTE)LocalAlloc(LMEM_FIXED, bufferSize);
    if (buffer == NULL) {
        printf("TestGetConnect: Couldn't allocate memory(2nd time)\n");
        return;
    }

    status = WNetGetUniversalName(
                lpDevice,
                level,
                buffer,
                &bufferSize);

    if (( status != WN_SUCCESS) && (status != ERROR_CONNECTION_UNAVAIL)) {
        printf("WNetGetUniversalName failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        //
        // If insufficient buffer, display needed size.
        //
        if (status == WN_MORE_DATA) {
            printf("Insufficient buffer size.  Need %d bytes\n",bufferSize);
        }
    }
    else {
        if (status == ERROR_CONNECTION_UNAVAIL) {
            printf("Not Currently Connected, but it is remembered\n");
        }
        else {
            printf("WNetGetUniversalName Success\n");
        }
        switch (level) {
        case UNIVERSAL_NAME_INFO_LEVEL:

            pUniversalInfo = (LPUNIVERSAL_NAME_INFO)buffer;
            printf(""FORMAT_LPTSTR" is connected to "FORMAT_LPTSTR"\n",
                lpDevice,pUniversalInfo->lpUniversalName);

            break;
        case REMOTE_NAME_INFO_LEVEL:

            pRemoteInfo = (LPREMOTE_NAME_INFO)buffer;

            if (pRemoteInfo->lpUniversalName == NULL) {
                pRemoteInfo->lpUniversalName = pNothing;
            }

            printf(""FORMAT_LPTSTR" is connected to: \n"
                "  UniversalName  = "FORMAT_LPTSTR"\n"
                "  ConnectionName = "FORMAT_LPTSTR"\n"
                "  RemainingPath  = "FORMAT_LPTSTR"\n\n",
                lpDevice,
                pRemoteInfo->lpUniversalName,
                pRemoteInfo->lpConnectionName,
                pRemoteInfo->lpRemainingPath);

            break;

        default:
            printf("PROBLEM:   Invalid Level didn't produce an error\n");
        }
    }
    if (buffer != NULL) {
        LocalFree(buffer);
    }
    return;
}

VOID
TestGetUser(
    LPTSTR   lpDevice,
    DWORD    cBuffer)
{
    DWORD   status;
    LPTSTR  userName = NULL;
    DWORD   saveBufSize;

    userName = (LPTSTR)LocalAlloc(LMEM_FIXED, cBuffer);
    if (userName == NULL) {
        printf("TestGetUser: Couldn't allocate memory\n");
        return;
    }
    saveBufSize = cBuffer;

    //
    // Get the currently logged on user
    //
    status = WNetGetUser (NULL, userName, &cBuffer);

    if ( status != WN_SUCCESS) {
        printf("WNetGetUser failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        //
        // If insufficient buffer, display needed size.
        //
        if (status == WN_MORE_DATA) {
            printf("Insufficient buffer size.  Need %d bytes\n",cBuffer);
        }
    }
    else {
        printf("WNetGetUser Success\n");
        printf("CurrentUser = "FORMAT_LPTSTR"\n", userName);
    }

    //
    // If there is a local device given, get the user for that.
    //

    if (lpDevice != NULL){

        cBuffer = saveBufSize;
        status = WNetGetUser (lpDevice, userName, &cBuffer);
        if ( status != WN_SUCCESS) {
            printf("WNetGetUser failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
            //
            // If insufficient buffer, display needed size.
            //
            if (status == WN_MORE_DATA) {
                printf("Insufficient buffer size.  Need %d bytes\n",cBuffer);
            }
        }
        else {
            printf("WNetGetUser Success\n");
            printf("User for "FORMAT_LPTSTR" is "FORMAT_LPTSTR"\n", lpDevice, userName);
        }
    }
    if (userName != NULL) {
        LocalFree(userName);
    }

    return;
}

VOID
TestEnumConnect(
    DWORD   dwScope,
    DWORD   type)
{
    DWORD           status;
    HANDLE          enumHandle;
    LPNETRESOURCE   netResource;
    DWORD           numElements;
    DWORD           bufferSize;

    //
    // Attempt to allow for 10 connections
    //
    bufferSize = (10*sizeof(NETRESOURCE))+1024;

    netResource = (LPNETRESOURCE) LocalAlloc(LPTR, bufferSize);

    if (netResource == NULL) {
        printf("TestEnum:LocalAlloc Failed %d\n",GetLastError);
        return;
    }

    //-----------------------------------
    // Get a handle for a top level enum
    //-----------------------------------
    status = WNetOpenEnum(
                dwScope,
                type,
                0,
                NULL,
                &enumHandle);

    if ( status != WN_SUCCESS) {
        printf("WNetOpenEnum failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        goto CleanExit;
    }
    else {
        printf("WNetOpenEnum Success\n");
    }

    //-----------------------------------
    // Enumerate the resources
    //-----------------------------------
    do
    {
        numElements = 0xffffffff;

        status = WNetEnumResource(
                        enumHandle,
                        &numElements,
                        netResource,
                        &bufferSize);

        if ( status == WN_SUCCESS )
        {
            CHAR    response;

            printf("WNetEnumResource Success - resources follow\n");
            DisplayResourceArray(netResource, numElements);

            printf("Get more resources? ");
            response = getch();
            response = toupper(response);
            if (response == 'N')
            {
                break;
            }
            printf("\r");
        }
        else if ( status == WN_NO_MORE_ENTRIES)
        {
            printf("WNetEnumResource Success - no more resources to display\n");
        }
        else
        {
            printf("WNetEnumResource failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR)
            {
                DisplayExtendedError();
            }
        }
    } while ( status == WN_SUCCESS );

    //------------------------------------------
    // Close the EnumHandle & print the results
    //------------------------------------------
    status = WNetCloseEnum(enumHandle);
    if (status != WN_SUCCESS) {
        printf("WNetCloseEnum failed %d\n",status);
        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        goto CleanExit;

    }


CleanExit:
    LocalFree(netResource);
    return;
}

VOID
TestEnumNet(VOID)
{
    DWORD           status;
    HANDLE          enumHandle;
    LPNETRESOURCE   netResource;
    DWORD           numElements;
    DWORD           bufferSize;
    DWORD           saveBufSize;
    DWORD           i;
    DWORD           numProviders=5;
    HANDLE          providerArray[5];

    //
    // Attempt to allow for 10 resource structures
    //
    saveBufSize = bufferSize = (10*sizeof(NETRESOURCE))+1024;

    netResource = (LPNETRESOURCE) LocalAlloc(LPTR, bufferSize);

    if (netResource == NULL) {
        printf("TestEnum:LocalAlloc Failed %d\n",GetLastError);
        return;
    }

    //-----------------------------------
    // Get a handle for a top level enum
    //-----------------------------------
    status = WNetOpenEnum(
                RESOURCE_GLOBALNET,
                RESOURCETYPE_ANY,
                0,
                NULL,
                &enumHandle);

    if ( status != WN_SUCCESS) {
        printf("WNetOpenEnum failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        goto CleanExit;
    }
    else {
        printf("WNetOpenEnum Success!\n");
    }

    //-----------------------------------
    // Enumerate the top level
    //-----------------------------------

    numElements = 0xffffffff;

    printf("\n*------------- TOP LEVEL ENUM ------------*\n");
    status = WNetEnumResource(
                    enumHandle,
                    &numElements,
                    netResource,
                    &bufferSize);

    if ( status != WN_SUCCESS) {
        printf("WNetEnumResource failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        WNetCloseEnum(enumHandle);
        goto CleanExit;
    }
    else {
        //
        // Success! Display the returned array
        // and close the top-level handle.
        //
        printf("WNetEnumResource Success\n");
        DisplayResourceArray(netResource, numElements);
        WNetCloseEnum(enumHandle);
    }

    //-------------------------------------------
    // Open a handle to the next level container
    //            *** DOMAINS ***
    //-------------------------------------------
    if (numElements < numProviders) {
        numProviders = numElements;
    }
    for (i=0; i<numProviders; i++ ) {


        status = WNetOpenEnum(
                    RESOURCE_GLOBALNET,
                    RESOURCETYPE_ANY,
                    RESOURCEUSAGE_CONTAINER,
                    netResource,
                    &enumHandle);

        if ( status != WN_SUCCESS) {
            printf("WNetOpenEnum 2 failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
            goto CleanExit;
        }
        else {
            printf("WNetOpenEnum 2 Success\n");
            providerArray[i]= enumHandle;
        }
    }

    //-----------------------------------------------------------------
    // Enumerate the next level
    //     *** DOMAINS ***
    //
    // providerArray contains handles for
    // all the providers.
    //
    //-----------------------------------------------------------------
    printf("\n*------------- 2nd LEVEL ENUM (Domains) ------------*\n");


    for (i=0; i<numProviders; i++) {

        numElements = 0xffffffff;

        bufferSize = saveBufSize;
        status = WNetEnumResource(
                        providerArray[i],
                        &numElements,
                        netResource,
                        &bufferSize);

        if ( status != WN_SUCCESS) {
            printf("WNetEnumResource 2 failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
            for (i=0; i<numProviders; i++ ) {
                WNetCloseEnum(providerArray[i]);
            }
            goto CleanExit;
        }
        else {
            //
            // Success! Display the returned array
            // and close the handle.
            //
            printf("*** WNetEnumResource 2 Success for provider %D ***\n",i);
            DisplayResourceArray(netResource, numElements);
            WNetCloseEnum(providerArray[i]);
        }
    }

    //-------------------------------------------
    // Open a handle to the next level container
    //            *** SERVERS ***
    //-------------------------------------------

    status = WNetOpenEnum(
                RESOURCE_GLOBALNET,
                RESOURCETYPE_ANY,
                RESOURCEUSAGE_CONTAINER,
                netResource,
                &enumHandle);

    if ( status != WN_SUCCESS) {
        printf("WNetOpenEnum 3 failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        goto CleanExit;
    }
    else {
        printf("WNetOpenEnum 3 Success\n");
    }

    //-----------------------------------
    // Enumerate the next level
    //     *** SERVERS ***
    //-----------------------------------
    numElements = 0xffffffff;

    printf("\n*------------- 3rd LEVEL ENUM (Servers) ------------*\n");
    status = WNetEnumResource(
                    enumHandle,
                    &numElements,
                    netResource,
                    &bufferSize);

    if ( status == WN_NO_MORE_ENTRIES) {
        //
        // Success! Display the returned array
        // and close the handle.
        //
        printf("WNetEnumResource 3 Success - no more data to display\n");
    }
    else if (status == WN_SUCCESS) {
        if (numElements != 0) {
            printf("WNetEnumResource 3 Success - but MORE DATA\n");
            DisplayResourceArray(netResource, numElements);
        }
        else
        {
            printf("WNetEnumResource 3 Success, and MORE DATA indicated --"
                    " but no data returned??\n");
        }
    }
    else {
        printf("WNetEnumResource 3 failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
    }

    WNetCloseEnum(enumHandle);

CleanExit:
    LocalFree(netResource);
    return;
}

VOID
TestSetError(VOID)
{

    //
    // Store and Get the 1st Error
    //
    printf("Setting Error WN_BAD_NETNAME.  Code = %d\n", WN_BAD_NETNAME);
    WNetSetLastError( WN_BAD_NETNAME, TEXT("WN_BAD_NETNAME"), TEXT("Dan's Provider"));
    DisplayExtendedError();

    //
    // Store and Get the 2nd Error
    //
    printf("Setting Error WN_NO_NETWORK.  Code = %d\n", WN_NO_NETWORK);
    WNetSetLastError( WN_NO_NETWORK, TEXT("WN_NO_NETWORK"), TEXT("Dan's Provider"));
    DisplayExtendedError();

    return;
}

VOID
TestMultiError(VOID)
{

    //
    // Store and Get the 1st Error
    //
    printf("Setting Error WN_BAD_NETNAME.  Code = %d\n", WN_BAD_NETNAME);
    WNetSetLastError( WN_BAD_NETNAME, TEXT("WN_BAD_NETNAME"), TEXT("Dan's Provider"));
    DisplayMultiError();

    //
    // Store and Get the 2nd Error
    //
    printf("Setting Error WN_NO_NETWORK.  Code = %d\n", WN_NO_NETWORK);
    WNetSetLastError( WN_NO_NETWORK, TEXT("WN_NO_NETWORK"), TEXT("Dan's Provider"));
    DisplayMultiError();

    //
    // Store and Get a non-WNet Error, with no text or provider
    //
    printf("Setting Error ERROR_SHARING_VIOLATION, no text or provider.  Code = %d\n", ERROR_SHARING_VIOLATION);
    WNetSetLastError( ERROR_SHARING_VIOLATION, NULL, NULL);
    DisplayMultiError();

    //
    // Store and Get an unknown Error, with no text
    //
    printf("Setting arbitrary error with no text.  Code = %d\n", 654321);
    WNetSetLastError( 654321, NULL, TEXT("Dan's Provider"));
    DisplayMultiError();

    return;
}

VOID
TestDirStuff(VOID)
{
    DWORD   status;
    INT     type;

    //
    // Test GetDirectoryType
    //
    status = WNetGetDirectoryType((LPTSTR)TEXT("f:\\"), (LPINT)&type, TRUE);

    if ( status != WN_SUCCESS) {
        printf("WNetGetDirectoryType failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
    }
    else {
        //
        // Success!
        //
        printf("WNetGetDirctoryType Success type = %d \n",type);
    }


    //
    // Test DirectoryNotify
    //
    status = WNetDirectoryNotify(0,TEXT("f:\\"), 2);

    if ( status != WN_SUCCESS) {
        printf("WNetDirectoryNotify failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
    }
    else {
        //
        // Success!
        //
        printf("WNetDirectoryNotify Success \n");
    }

    return;
}

VOID
TestRestoreConnect(
    LPTSTR   lpDrive
    )
{
    DWORD   status;

#ifdef UNICODE
    status = WNetRestoreConnection(
                (HWND)0,
                lpDrive);
#else
    status = RestoreConnectionA0 (
                (HWND)0,
                lpDrive);
#endif

    if (status == NO_ERROR) {
        printf("WNetRestoreConnection success\n");
    }
    else {
        printf("WNetRestoreConnection failure %d\n",status);
    }
}

VOID
TestClearConnect(
    VOID
    )
{
    DWORD   status;


    status = WNetClearConnections(
                (HWND)0);

    if (status == NO_ERROR) {
        printf("WNetClearConnection success\n");
    }
    else {
        printf("WNetClearConnection failure %d\n",status);
    }
}

VOID
TestLotsOfStuff(VOID)
{
    DWORD   status;
    BOOL    KeepGoing=TRUE;

    do {


        printf("\n*** RUNNING TestAddConnect2 for g:\n");
        TestAddConnect2(TEXT("\\\\popcorn\\public"), TEXT("g:"));
        printf("\n*** RUNNING TestAddConnect2 for t:\n");
        TestAddConnect2(TEXT("\\\\products3\\release"), TEXT("t:"));
        printf("\n*** RUNNING TestAddConnect2 for k:\n");
        TestAddConnect2(TEXT("\\\\kernel\\razzle2"),   TEXT("k:"));

        printf("\n*** TESTING AddConnect1 for NP2 on z:\n");
        status = WNetAddConnection(TEXT("!Rastaman"),NULL,TEXT("z:"));
        if (status != WN_SUCCESS) {
            printf("AddConnect1 for NP2 failed %d"
            "- Do we have a 2nd provider?\n",status);
        }
        else {
            printf("AddConnect1 success\n");
        }

        printf("\n*** RUNNING TestGetConnect\n");
        TestGetConnect(TEXT("g:"),NAME_BUF_SIZE);
        printf("\n*** RUNNING TestSetError\n");
        TestSetError();
        printf("\n*** RUNNING TestMultiError\n");
        TestMultiError();
        printf("\n*** RUNNING TestGetUser\n");
        TestGetUser(NULL,NAME_BUF_SIZE);
        printf("\n*** RUNNING TestEnumConnect (non-remembered)\n");
        TestEnumConnect(RESOURCE_CONNECTED,RESOURCETYPE_DISK);

        printf("\n*** RUNNING TestEnumConnect (remembered)\n");
        TestEnumConnect(RESOURCE_REMEMBERED,RESOURCETYPE_DISK);

        printf("\n*** RUNNING TestEnumConnect (context)\n");
        TestEnumConnect(RESOURCE_CONTEXT,RESOURCETYPE_DISK);


        printf("\n*** ATTEMPT to Cancel connection to t:\n");
        status = WNetCancelConnection(TEXT("t:"),FALSE);

        if ( status != WN_SUCCESS) {
            printf("WNetCancelConnection failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
        }
        else {
            printf("WNetCancelConnection Success\n");
        }

        printf("\n*** ATTEMPT to Cancel connection to g:\n");
        WNetCancelConnection(TEXT("g:"),FALSE);
        if ( status != WN_SUCCESS) {
            printf("WNetCancelConnection failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
        }
        else {
            printf("WNetCancelConnection Success\n");
        }

        printf("\n*** ATTEMPT to Cancel connection to k:\n");
        WNetCancelConnection(TEXT("k:"),FALSE);
        if ( status != WN_SUCCESS) {
            printf("WNetCancelConnection failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
        }
        else {
            printf("WNetCancelConnection Success\n");
        }

        printf("\n*** ATTEMPT to Cancel connection to z:\n");
        WNetCancelConnection(TEXT("z:"),TRUE);
        if ( status != WN_SUCCESS) {
            printf("WNetCancelConnection failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
        }
        else {
            printf("WNetCancelConnection Success\n");
        }

        printf("\n*** RUNNING TestEnumNet\n");
        TestEnumNet();

        printf("     - Do it again?  (type 'n' to stop)\n");

        if (getch() == 'n') {
            KeepGoing = FALSE;
        }
    } while (KeepGoing);
    return;

}

VOID
DisplayExtendedError(VOID)
{
    TCHAR   errorBuf[ERR_BUF_SIZE];
    TCHAR   nameBuf[NAME_BUF_SIZE];
    DWORD   errorCode;
    DWORD   status;
    DWORD   smallErrorSize;
    DWORD   smallNameSize;

    status = WNetGetLastError(
                &errorCode,
                errorBuf,
                ERR_BUF_SIZE,
                nameBuf,
                NAME_BUF_SIZE);

    if(status != WN_SUCCESS) {
        printf("WNetGetLastError failed %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION:  (from GetLastError)\n");
    printf("   Code:        %d\n",errorCode);
    printf("   Description: "FORMAT_LPTSTR"\n",errorBuf);
    printf("   Provider:    "FORMAT_LPTSTR"\n\n",nameBuf);

    //---------------------------------------------------------
    // Now try it with a buffer that's one character too small.
    //---------------------------------------------------------
    printf("Try it with buffer that is one char too small\n");

    smallErrorSize = STRLEN(errorBuf);
    smallNameSize  = STRLEN(nameBuf);
    status = WNetGetLastError(
                &errorCode,
                errorBuf,
                smallErrorSize,
                nameBuf,
                smallNameSize);

    if(status != WN_SUCCESS) {
        printf("WNetGetLastError failed %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION (truncated):  (from GetLastError)\n");
    printf("   Code:        %d\n",errorCode);
    printf("   Description: "FORMAT_LPTSTR"\n",errorBuf);
    printf("   Provider:    "FORMAT_LPTSTR"\n\n",nameBuf);

    //---------------------------------------------------------
    // Now try it with a zero length buffer.
    //---------------------------------------------------------
    printf("Try it with zero length buffers\n");
    smallErrorSize = 0;
    smallNameSize  = 0;
    status = WNetGetLastError(
                &errorCode,
                errorBuf,
                smallErrorSize,
                nameBuf,
                smallNameSize);

    if(status != WN_SUCCESS) {
        printf("WNetGetLastError failed %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION (zero length):  (from GetLastError)\n");
    printf("   Code:        %d\n",errorCode);
    printf("   Description: "FORMAT_LPTSTR"\n",errorBuf);
    printf("   Provider:    "FORMAT_LPTSTR"\n\n",nameBuf);
    //---------------------------------------------------------
    // Now try it with invalid buffer.
    //---------------------------------------------------------
    printf("Try it with invalid buffers\n");
    smallErrorSize = 0;
    smallNameSize  = 0;
    status = WNetGetLastError(
                &errorCode,
                (LPTSTR)0xffffeeee,
                0,
                (LPTSTR)0xffffeeee,
                0);

    if(status != WN_SUCCESS) {
        printf("WNetGetLastError failed %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION (NO BUFFER):  (from GetLastError)\n");
    printf("   Code:        %d\n",errorCode);
    printf("   Description: "FORMAT_LPTSTR"\n",errorBuf);
    printf("   Provider:    "FORMAT_LPTSTR"\n\n",nameBuf);
    //---------------------------------------------------------
    // Now try it with invalid buffer & lie about size.
    //---------------------------------------------------------
    printf("Try it with invalid buffers\n");
    smallErrorSize = 0;
    smallNameSize  = 0;
    status = WNetGetLastError(
                &errorCode,
                (LPTSTR)0xffffeeee,
                2000,
                (LPTSTR)0xffffeeee,
                2000);

    if(status != WN_SUCCESS) {
        printf("WNetGetLastError failed %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION (NO BUFFER):  (from GetLastError)\n");
    printf("   Code:        %d\n",errorCode);
    printf("   Description: "FORMAT_LPTSTR"\n",errorBuf);
    printf("   Provider:    "FORMAT_LPTSTR"\n\n",nameBuf);
    return;
}

VOID
DisplayMultiError(VOID)
{
    TCHAR   errorBuf[ERR_BUF_SIZE];
    TCHAR   nameBuf[NAME_BUF_SIZE];
    DWORD   status;
    DWORD   smallErrorSize;
    DWORD   smallNameSize;
    DWORD   ErrorSize = ERR_BUF_SIZE;
    DWORD   NameSize = NAME_BUF_SIZE;

    status = MultinetGetErrorText(
                errorBuf,
                &ErrorSize,
                nameBuf,
                &NameSize);

    if(status != WN_SUCCESS) {
        printf("MultinetGetErrorText failed %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION:  (from MultinetGetErrorText)\n");
    printf("   Description: "FORMAT_LPTSTR"\n",errorBuf);
    printf("   Provider:    "FORMAT_LPTSTR"\n\n",nameBuf);

    //---------------------------------------------------------
    // Now try it with a buffer that's one character too small.
    //---------------------------------------------------------
    printf("Try it with buffer that is one char too small\n");

    smallErrorSize = STRLEN(errorBuf);
    smallNameSize  = STRLEN(nameBuf);
    status = MultinetGetErrorText(
                errorBuf,
                &smallErrorSize,
                nameBuf,
                &smallNameSize);

    if(status != WN_MORE_DATA) {
        printf("MultinetGetErrorText FAILED %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION (truncated):  (from MultinetGetErrorText)\n");
    printf("   Error size:  %d\n", smallErrorSize);
    printf("   Name  size:  %d\n", smallNameSize);

    //---------------------------------------------------------
    // Now try it with a zero length buffer.
    //---------------------------------------------------------
    printf("Try it with zero length buffers\n");
    smallErrorSize = 0;
    smallNameSize  = 0;
    status = MultinetGetErrorText(
                errorBuf,
                &smallErrorSize,
                nameBuf,
                &smallNameSize);

    if(status != WN_MORE_DATA) {
        printf("MultinetGetErrorText FAILED %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION (zero length):  (from MultinetGetErrorText)\n");
    printf("   Error size:  %d\n", smallErrorSize);
    printf("   Name  size:  %d\n", smallNameSize);
    //---------------------------------------------------------
    // Now try it with invalid buffer.
    //---------------------------------------------------------
    printf("Try it with invalid buffers\n");
    smallErrorSize = 0;
    smallNameSize  = 0;
    status = MultinetGetErrorText(
                (LPTSTR)0xffffeeee,
                &smallErrorSize,
                (LPTSTR)0xffffeeee,
                0);

    if(status != WN_BAD_POINTER) {
        printf("MultinetGetErrorText failed %d\n",status);
        return;
    }
    printf("Worked OK, returned WN_BAD_POINTER\n");
    //---------------------------------------------------------
    // Now try it with invalid buffer & lie about size.
    //---------------------------------------------------------
    printf("Try it with invalid buffers\n");
    smallErrorSize = 2000;
    smallNameSize  = 2000;
    status = MultinetGetErrorText(
                (LPTSTR)0xffffeeee,
                &smallErrorSize,
                (LPTSTR)0xffffeeee,
                &smallNameSize);

    if(status != WN_BAD_POINTER) {
        printf("MultinetGetErrorText failed %d\n",status);
        return;
    }
    printf("Worked OK, returned WN_BAD_POINTER\n");
    return;
}

VOID
DisplayResourceArray(
    LPNETRESOURCE   NetResource,
    DWORD           NumElements
    )
{
    DWORD   i;

    for (i=0; i<NumElements ;i++ ) {
        DisplayResource(&(NetResource[i]));
    }
    return;
}

VOID
DisplayResource(
    LPNETRESOURCE   NetResource
    )
{
    printf( "*** RESOURCE ***\n");
    printf( "Scope\t0x%x\n", NetResource->dwScope);
    printf( "Type\t0x%x\n",  NetResource->dwType);
    printf( "Usage\t0x%x\n", NetResource->dwUsage);

    printf( "LocalName\t"FORMAT_LPTSTR"\n",  NetResource->lpLocalName);
    printf( "RemoteName\t"FORMAT_LPTSTR"\n", NetResource->lpRemoteName);
    printf( "Comment\t"FORMAT_LPTSTR"\n",    NetResource->lpComment);
    printf( "Provider\t"FORMAT_LPTSTR"\n\n", NetResource->lpProvider);
}

BOOL
MakeArgsUnicode (
    DWORD           argc,
    PCHAR           argv[]
    )


/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD   i;

    //
    // ScConvertToUnicode allocates storage for each string.
    // We will rely on process termination to free the memory.
    //
    for(i=0; i<argc; i++) {

        if(!ConvertToUnicode( (LPWSTR *)&(argv[i]), argv[i])) {
            printf("Couldn't convert argv[%d] to unicode\n",i);
            return(FALSE);
        }


    }
    return(TRUE);
}

BOOL
ConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPSTR   AnsiIn
    )

/*++

Routine Description:

    This function translates an AnsiString into a Unicode string.
    A new string buffer is created by this function.  If the call to
    this function is successful, the caller must take responsibility for
    the unicode string buffer that was allocated by this function.
    The allocated buffer should be free'd with a call to LocalFree.

    NOTE:  This function allocates memory for the Unicode String.

Arguments:

    AnsiIn - This is a pointer to an ansi string that is to be converted.

    UnicodeOut - This is a pointer to a location where the pointer to the
        unicode string is to be placed.

Return Value:

    TRUE - The conversion was successful.

    FALSE - The conversion was unsuccessful.  In this case a buffer for
        the unicode string was not allocated.

--*/
{

    NTSTATUS        ntStatus;
    DWORD           bufSize;
    UNICODE_STRING  unicodeString;
    ANSI_STRING     ansiString;

    //
    // Allocate a buffer for the unicode string.
    //

    bufSize = (strlen(AnsiIn)+1) * sizeof(WCHAR);

    *UnicodeOut = (LPWSTR) LocalAlloc(LPTR, bufSize);

    if (*UnicodeOut == NULL) {
        printf("ScConvertToUnicode:LocalAlloc Failure %ld\n",GetLastError());
        return(FALSE);
    }

    //
    // Initialize the string structures
    //
    RtlInitAnsiString( &ansiString, AnsiIn);

    unicodeString.Buffer = *UnicodeOut;
    unicodeString.MaximumLength = (USHORT)bufSize;
    unicodeString.Length = 0;

    //
    // Call the conversion function.
    //
    ntStatus = RtlAnsiStringToUnicodeString (
                &unicodeString,     // Destination
                &ansiString,        // Source
                FALSE);             // Allocate the destination

    if (!NT_SUCCESS(ntStatus)) {

        printf("ScConvertToUnicode:RtlAnsiStringToUnicodeString Failure %lx\n",
        ntStatus);

        return(FALSE);
    }

    //
    // Fill in the pointer location with the unicode string buffer pointer.
    //
    *UnicodeOut = unicodeString.Buffer;

    return(TRUE);

}

VOID
InvalidParms(
    VOID
    )

/*++

Routine Description:

    Tests Invalid parameters sent to Winnet API.

Arguments:



Return Value:



--*/
{
    DWORD           status;
    DWORD           dwFlags;
    LPNETRESOURCE   netResource;
    HANDLE          enumHandle;
    DWORD           dwType;
    DWORD           dwScope;
    DWORD           dwUsage;
    NETRESOURCE     NetResource;

    netResource = (LPNETRESOURCE) LocalAlloc(LPTR, sizeof(NETRESOURCE));

    if (netResource == NULL) {
        printf("InvalidParms:LocalAlloc Failed %d\n",GetLastError);
        return;
    }

    netResource->lpRemoteName = TEXT("\\popcorn\\public");
    netResource->lpLocalName  = TEXT("p:");
    netResource->dwType = RESOURCETYPE_DISK;

    //==============================================
    // WNetAddConnect2 - set dwFlags to something other than 0 or
    // CONNECT_UPDATE_PROFILE.
    //==============================================
    dwFlags = CONNECT_UPDATE_PROFILE + 1;
    status = WNetAddConnection2(netResource,NULL,NULL,dwFlags);
    if (status == WN_BAD_VALUE) {
        printf("InvalidParms Test #1 success\n");
    }
    else {
        printf("InvalidParms Test #1 failed\n");
    }

    //==============================================
    // WNetAddConnect2 - dwType = RESOURCETYPE_ANY.
    //                   dwFlags != CONNECT_UPDATE_PROFILE.
    //==============================================

    netResource->dwType = RESOURCETYPE_DISK;
    dwFlags = CONNECT_UPDATE_PROFILE+1;
    status = WNetAddConnection2(netResource,NULL,NULL,dwFlags);

    if (status == WN_BAD_VALUE) {
        printf("InvalidParms Test #2 success\n");
    }
    else {
        printf("InvalidParms Test #2 failed\n");
    }


    //==============================================
    // WNetAddConnect2 - dwType = RESOURCETYPE_DISK.
    //                   dwFlags = 0
    //==============================================

    netResource->dwType = RESOURCETYPE_DISK;
    dwFlags = 0;
    status = WNetAddConnection2(netResource,NULL,NULL,dwFlags);

    if (status != WN_BAD_VALUE) {
        printf("InvalidParms Test #3 success\n");
    }
    else {
        printf("InvalidParms Test #3 failed\n");
    }


    //==============================================
    // WNetAddConnect2 - lpRemoteName = NULL
    //==============================================

    netResource->dwType = RESOURCETYPE_DISK;
    dwFlags = 0;
    netResource->lpRemoteName = NULL;
    status = WNetAddConnection2(netResource,NULL,NULL,dwFlags);

    if (status == WN_BAD_NETNAME) {
        printf("InvalidParms Test #4 success\n");
    }
    else {
        printf("InvalidParms Test #4 failed\n");
    }


    //======================================================================
    // WNetOpenEnum - dwScope = RESOURCE_CONNECTED | RESOURCE_GLOBALNET
    //======================================================================

    dwScope = RESOURCE_CONNECTED | RESOURCE_GLOBALNET | RESOURCE_REMEMBERED+1;
    dwType = RESOURCETYPE_ANY;

    status = WNetOpenEnum(
                dwScope,
                dwType,
                0,
                NULL,
                &enumHandle);


    if (status == WN_BAD_VALUE) {
        printf("InvalidParms Test #5 success\n");
    }
    else {
        printf("InvalidParms Test #5 failed\n");
    }


    //======================================================================
    // WNetOpenEnum - dwType = RESOURCETYPE_DISK | RESOURCETYPE_PRINT |
    //                         RESOURCETYPE_ANY + 1;
    //======================================================================

    dwScope = RESOURCE_CONNECTED;
    dwType = (RESOURCETYPE_DISK | RESOURCETYPE_PRINT | RESOURCETYPE_ANY)+1;

    status = WNetOpenEnum(
                dwScope,
                dwType,
                0,
                NULL,
                &enumHandle);


    if (status == WN_BAD_VALUE) {
        printf("InvalidParms Test #6 success\n");
    }
    else {
        printf("InvalidParms Test #6 failed\n");
    }


    //======================================================================
    // WNetOpenEnum - dwUsage = RESOURCEUSAGE_CONNECTABLE |
    //                          RESOURCEUSAGE_CONTAINER + 1
    //======================================================================

    dwScope = RESOURCE_GLOBALNET;
    dwType  = RESOURCETYPE_DISK;
    dwUsage = (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER) + 1;

    status = WNetOpenEnum(
                dwScope,
                dwType,
                dwUsage,
                NULL,
                &enumHandle);


    if (status == WN_BAD_VALUE) {
        printf("InvalidParms Test #7 success\n");
    }
    else {
        printf("InvalidParms Test #7 failed\n");
    }

    //======================================================================
    // WNetOpenEnum - NetResource Structure is filled with 0.
    //======================================================================

    memset(&NetResource, 0,sizeof(NetResource));
    dwScope = RESOURCE_GLOBALNET;
    dwType  = RESOURCETYPE_ANY;
    dwUsage = 0;

    status = WNetOpenEnum(
                dwScope,
                dwType,
                dwUsage,
                NULL,
                &enumHandle);


    if (status == WN_SUCCESS) {
        printf("InvalidParms Test #8 success\n");
        WNetCloseEnum(enumHandle);
    }
    else {
        printf("InvalidParms Test #8 failed\n");
    }

    //======================================================================
    // WNetCancelConnection2 - dwFlags != CONNECT_UPDATE_PROFILE | 0.
    //======================================================================

    status = WNetCancelConnection2(TEXT("p:"), CONNECT_UPDATE_PROFILE + 1, FALSE);
    if (status == WN_BAD_VALUE) {
        printf("InvalidParms Test #9 success\n");
    }
    else {
        printf("InvalidParms Test #9 failed\n");
    }
    printf("InvalidParms Test Complete\n");

    LocalFree(netResource);
    return;
}

VOID
RecursiveEnum(
    DWORD           RecursionLevel,
    DWORD           ResourceUsage,
    LPNETRESOURCE   EnumNetResource
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD           status;
    HANDLE          enumHandle;
    LPNETRESOURCE   netResource=NULL;
    DWORD           numElements;
    DWORD           bufferSize;
    DWORD           saveBufferSize;
    DWORD           i;
    DWORD           usage;
    CHAR            response;

    //-------------------------------------------
    // Open a handle to the next level container
    //-------------------------------------------

    status = WNetOpenEnum(
                RESOURCE_GLOBALNET,
                RESOURCETYPE_ANY,
                ResourceUsage,
                EnumNetResource,
                &enumHandle);

    if ( status != WN_SUCCESS) {
        printf("WNetOpenEnum %d failed %d\n",RecursionLevel,status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        return;
    }
    else {
        printf("WNetOpenEnum %d Success\n",RecursionLevel);
    }

    //-------------------------------------
    // Allocate memory for the enumeration
    //-------------------------------------
    //
    // Attempt to allow for 10 resource structures
    //
    bufferSize = (10*sizeof(NETRESOURCE))+2048;

    netResource = (LPNETRESOURCE) LocalAlloc(LPTR, bufferSize);

    if (netResource == NULL) {
        printf("TestEnum:LocalAlloc Failed %d\n",GetLastError);
        return;
    }
    saveBufferSize = bufferSize;

    //-----------------------------------
    // Enumerate the next level
    //-----------------------------------
    numElements = 0xffffffff;
    status = WNetEnumResource(
                    enumHandle,
                    &numElements,
                    netResource,
                    &bufferSize);

    if ((status == WN_NO_MORE_ENTRIES) ||
        (status == WN_SUCCESS) ) {
        if (numElements != 0) {
            //
            // Success! Display the returned array
            // and close the handle.
            //
            if (status == WN_SUCCESS){
                printf("WNetEnumResource %d Success - but MORE DATA\n",
                RecursionLevel);
            }
            else {
                printf("WNetEnumResource %d Success\n",RecursionLevel);
            }

            usage = RESOURCEUSAGE_CONTAINER;

            switch(RecursionLevel) {
            case 0:
                printf("\n*------------- NETWORK PROVIDERS  ------------*\n");
                break;
            case 1:
                printf("\n*------------- DOMAINS FOR "FORMAT_LPTSTR" PROVIDER  ------------*\n",
                EnumNetResource->lpRemoteName);
                break;
            case 2:
                printf("\n*------------- SERVERS ON "FORMAT_LPTSTR" DOMAIN  ------------*\n",
                EnumNetResource->lpRemoteName);
                break;
            case 3:
                printf("\n*------------- SHARES ON "FORMAT_LPTSTR" SERVER  ------------*\n",
                EnumNetResource->lpRemoteName);
                usage = RESOURCEUSAGE_CONNECTABLE;
                break;
            default:
                break;
            }

            printf("continue? ");
            response = getch();
            response = toupper(response);
            if (response == 'N') {
                WNetCloseEnum(enumHandle);
                return;
            }
            if (response == 'Q') {
                ExitProcess(0);
            }
            printf("\r");

            DisplayResourceArray(netResource, numElements);
            for (i=0;i<numElements ;i++ ) {
                RecursiveEnum(
                    RecursionLevel+1,
                    usage,
                    &(netResource[i]));
            }
        }
        else {
            printf("No entries to enumerate for "FORMAT_LPTSTR" rc=%d\n",
            EnumNetResource->lpRemoteName,status);
        }
    }
    else if (status == WN_MORE_DATA) {
        printf("The buffer (%d bytes) was too small for one entry, need %d bytes\n",
        saveBufferSize, bufferSize);

    }
    else {
        printf("WNetEnumResource %d failed %d\n",RecursionLevel,status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
    }

    WNetCloseEnum(enumHandle);
    if (netResource != NULL) {
        LocalFree(netResource);
    }
}

VOID
TestLogonNotify(
    LPTSTR  argv[],
    DWORD   argc
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD                       status;
    MSV1_0_INTERACTIVE_LOGON    NewLogon;
    MSV1_0_INTERACTIVE_LOGON    OldLogon;
    LUID                        LogonId;
    LPWSTR                      LogonScripts;
    LPWSTR                      pScript;


    NewLogon.MessageType = MsV1_0InteractiveLogon;

    RtlInitUnicodeString(&(NewLogon.LogonDomainName),L"Domain");
    RtlInitUnicodeString(&(NewLogon.UserName),L"SAMMY");
    RtlInitUnicodeString(&(NewLogon.Password),L"SECRET");

    OldLogon.MessageType = MsV1_0InteractiveLogon;

    RtlInitUnicodeString(&(OldLogon.LogonDomainName),L"Domain");
    RtlInitUnicodeString(&(OldLogon.UserName),L"SAMMY");
    RtlInitUnicodeString(&(OldLogon.Password),L"NEWSECRET");

    LogonId.HighPart = 5;
    LogonId.LowPart = 53;

    status = WNetLogonNotify(
                L"Windows NT Network Provider",
                &LogonId,
                L"MSV1_0:Interactive",
                &NewLogon,
                L"MSV1_0:Interactive",
                &OldLogon,
                L"Dan's Station",
                (LPVOID)L"POINTER",
                &LogonScripts);

    if (status == NO_ERROR) {
        printf("WNetLogonNotify Success\n");

        if (LogonScripts != NULL) {
            pScript = LogonScripts;

            do {
                printf("LogonScripts: %ws\n",pScript);
                pScript += (wcslen(pScript) + 1);
            }
            while (*pScript != L'\0');

            LocalFree(LogonScripts);
        }
    }
    else {
        printf("WNetLogonNotify Failure %d\n",status);
    }

    return;
}

VOID
TestChangePassword(
    LPTSTR  argv[],
    DWORD   argc
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD                       status;
    MSV1_0_INTERACTIVE_LOGON    NewLogon;
    MSV1_0_INTERACTIVE_LOGON    OldLogon;


    NewLogon.MessageType = MsV1_0InteractiveLogon;

    RtlInitUnicodeString(&(NewLogon.LogonDomainName),L"Domain");
    RtlInitUnicodeString(&(NewLogon.UserName),L"SAMMY");
    RtlInitUnicodeString(&(NewLogon.Password),L"SECRET");

    OldLogon.MessageType = MsV1_0InteractiveLogon;

    RtlInitUnicodeString(&(OldLogon.LogonDomainName),L"Domain");
    RtlInitUnicodeString(&(OldLogon.UserName),L"SAMMY");
    RtlInitUnicodeString(&(OldLogon.Password),L"NEWSECRET");

    status = WNetPasswordChangeNotify(
                L"Windows Nt Network Provider",
                L"MSV1_0:Interactive",
                &NewLogon,
                L"MSV1_0:Interactive",
                &OldLogon,
                L"Dan's Station",
                (LPVOID)L"POINTER",
                44);

    if (status == NO_ERROR) {
        printf("WNetPasswordChangeNotify Success\n");

    }
    else {
        printf("WNetPasswordChangeNotify Failure %d\n",status);
    }

    return;
}

BOOL
GetStringFromFile(
    LPDWORD     lpLoopCount,
    LPSTR       buffer
    )

/*++

Routine Description:

    The following behaviour is desired, however, I don't have time to
    write it right now:

    This function reads the next line of instructions from a file called
    "mprtest.txt".  When it reaches the end of the file, it begins again
    at the beginning of the file.  The first line in the file indicates how
    many times to pass through the file.  (Loop count).  When the last pass
    occurs, the instruction "done" is passed back in the buffer.



Arguments:


Return Value:


--*/
{
    if (*lpLoopCount == 0) {
        strcpy(buffer+2, "done");
        buffer[1]=strlen(buffer+2);
    }
    else {
        if (*lpLoopCount & 1) {
            buffer[1]=28;
            strcpy(buffer+2, "AddConnect1 x: \\\\danl1\\roote");
            buffer[1]=strlen(buffer+2);
        }
        else {
            strcpy(buffer+2, "CancelConnect x: r");
            buffer[1]=strlen(buffer+2);
        }
        (*lpLoopCount)--;
    }
    return(TRUE);
}

LONG
wtol(
    IN LPWSTR string
    )
{
    LONG value = 0;

    while((*string != L'\0')  &&
            (*string >= L'0') &&
            ( *string <= L'9')) {
        value = value * 10 + (*string - L'0');
        string++;
    }

    return(value);
}

VOID
Usage(VOID)
{

    printf("USAGE:\n");
    printf("<server> <function>\n");

    printf("SYNTAX EXAMPLES    \n");

    printf("AddConnect1 <drive> <remote name>  - "
            "these are remembered\n");
    printf("AddConnect2 <drive> <remote name>  - "
            "these are not remembered\n");
    printf("CancelConnect <drive> <r>\n");
    printf("GetConnect <connection> <buffer size>\n");
    printf("GetUniversalName <connection> <info level> <buffer size>\n");
    printf("GetUser <device= ?> <bufsize= ?>\n");
    printf("EnumConnect <type= ANY|DISK|PRINT> <r> \n");
    printf("EnumContext <type= ANY|DISK|PRINT> \n");
    printf("RestoreConnect <drive> \n");
    printf("EnumNet\n");
    printf("SetError\n");
    printf("MultiError\n");
    printf("DirApi\n");
    printf("ClearConnect\n");
    printf("LogonNotify\n");
    printf("ChangePassword\n");
    printf("ALL\n");
    printf("InvalidParms\n");
    printf("Loop <number>   -  Add and cancel n connections \n");
    printf("Exit\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\netinfo.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    netinfo.cxx

Abstract:

    Contains entry points for Winnet API supported by the
    Multi-Provider Router.
    Contains:
        WNetGetNetworkInformationW
        WNetGetProviderNameW

Author:

    Anirudh Sahni  (anirudhs)  08-Jun-1995

Environment:

    User Mode -Win32

Notes:

Revision History:

    08-Jun-1995     anirudhs
        Created

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <tstr.h>       // WCSSIZE

//
// EXTERNAL GLOBALS
//

//
// Defines
//


//
// Local Function Prototypes
//


DWORD
WNetGetNetworkInformationW(
    IN  LPCWSTR         lpProvider,
    OUT LPNETINFOSTRUCT lpNetInfoStruct
    )

/*++

Routine Description:

    This function returns extended information about a named network provider.

Arguments:

    lpProvider - Pointer to the name of the provider for which information is
        required.

    lpNetInfoStruct - Pointer to a structure that describes the behavior of
        the network.

Return Value:

    WN_SUCCESS - Call is successful.

    WN_BAD_PROVIDER - lpProvider does not match any active network provider.

    WN_BAD_VALUE - lpProvider->cbStructure does not contain a valid structure
        size.

Notes:

    Win 95's implementation of this API will accept a structure smaller than
    a NETINFOSTRUCT, and will fill in as many elements of the structure as
    will fit.  This strange feature is not documented and is not used in
    the shell, so we don't do it here.  It may be useful for future versions
    of this API that add fields to the NETINFOSTRUCT.

--*/

{
    DWORD       status = WN_SUCCESS;
    LPPROVIDER  Provider;

    if (!(ARGUMENT_PRESENT(lpProvider) &&
          ARGUMENT_PRESENT(lpNetInfoStruct)))
    {
        SetLastError(WN_BAD_POINTER);
        return WN_BAD_POINTER;
    }

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    __try
    {
        //
        // Validate the parameters that we can.
        //

        if (lpNetInfoStruct->cbStructure < sizeof(NETINFOSTRUCT))
        {
            status = WN_BAD_VALUE;
            __leave;
        }

        if (IsBadWritePtr(lpNetInfoStruct, lpNetInfoStruct->cbStructure))
        {
            status = WN_BAD_POINTER;
            __leave;
        }

        //
        // Look up the provider by name
        //
        DWORD i;
        if (!MprGetProviderIndex(lpProvider, &i))
        {
            status = WN_BAD_PROVIDER;
            __leave;
        }

        Provider = & GlobalProviderInfo[i];
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG(ERROR,
                    "WNetGetNetworkInformationW: Unexpected Exception %#lx\n",
                    status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
        return status;
    }

    //
    // Fill in the fields of the structure
    //

    lpNetInfoStruct->cbStructure = sizeof(NETINFOSTRUCT);

    lpNetInfoStruct->dwProviderVersion = Provider->GetCaps(WNNC_DRIVER_VERSION);

    switch (Provider->GetCaps(WNNC_START))
    {
        case 0x0:
            lpNetInfoStruct->dwStatus = WN_NO_NETWORK;
            break;

        case 0x1:
            lpNetInfoStruct->dwStatus = WN_SUCCESS;
            break;

        default:
            lpNetInfoStruct->dwStatus = WN_FUNCTION_BUSY;
            break;
    }

    // We don't support this field.  The shell doesn't use it.
    // Win 95 gets it by looking at registry entries created by the
    // provider.  If the registry entries don't exist it leaves the
    // dwCharacteristics field as 0, which means that the provider
    // doesn't require redirection of a local drive to make a connection.
    lpNetInfoStruct->dwCharacteristics = 0;

    lpNetInfoStruct->dwHandle = (ULONG_PTR) Provider->Handle;

    // Note, this is a WORD field, not a DWORD.
    // Why does Win 95 omit the LOWORD anyway?
    lpNetInfoStruct->wNetType = HIWORD(Provider->Type);

    // We don't support these 2 fields.  The shell doesn't use them.
    // Win 95 gets them by calling NPValidLocalDevices.  If this entry
    // point doesn't exist it looks in the registry.  If the registry
    // value doesn't exist it uses NPP_ALLVALID which is defined as
    // 0xffffffff.
    lpNetInfoStruct->dwPrinters = 0xffffffff;

    lpNetInfoStruct->dwDrives = 0xffffffff;

    return WN_SUCCESS;
}


DWORD
WNetGetProviderNameW(
    IN      DWORD   dwNetType,
    OUT     LPWSTR  lpProviderName,
    IN OUT  LPDWORD lpBufferSize
    )

/*++

Routine Description:

    This function returns the provider name for a specified type of network.

Arguments:

    dwNetType - The network type unique to the network.  Only the high word
        of the network type is used; the subtype in the low word is ignored.
        If two networks claim the same type, the first one loaded is returned.

    lpProviderName - Pointer to a buffer in which to return the provider name.

    lpBufferSize - On entry, size of the lpProviderName buffer in characters.
        On exit, iff the return code is WN_MORE_DATA, set to the required size
        to hold the provider name.

Return Value:

    WN_SUCCESS - Call is successful.

    WN_MORE_DATA - The buffer is too small to hold the provider name.

    WN_NO_NETWORK - lpProvider does not match any active network provider.

--*/

{
    DWORD   status = WN_SUCCESS;

    __try
    {
        //
        // Validate the parameters that we can.
        //
        if (IS_BAD_WCHAR_BUFFER(lpProviderName, lpBufferSize))
        {
            status = WN_BAD_POINTER;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG(ERROR,
                    "WNetGetProviderNameW: Unexpected Exception %#lx\n",
                    status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
        return status;
    }

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    //
    // Loop through the list of providers to find one with the specified
    // net type.
    //
    LPPROVIDER provider = MprFindProviderByType(dwNetType);

    if (provider == NULL)
    {
        status = WN_NO_NETWORK;
    }
    else
    {
        //
        // Copy the provider name to the caller's buffer
        //
        DWORD dwReqSize = wcslen(provider->Resource.lpProvider) + 1;
        if (*lpBufferSize < dwReqSize)
        {
            status = WN_MORE_DATA;
            *lpBufferSize = dwReqSize;
        }
        else
        {
            status = WN_SUCCESS;
            wcscpy(lpProviderName, provider->Resource.lpProvider);
        }
    }

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
    }

    return status;
}



DWORD
WNetGetProviderTypeW(
    IN  LPCWSTR         lpProvider,
    OUT LPDWORD         lpdwNetType
    )

/*++

Routine Description:

    This function returns the network type for a named network provider.

Arguments:

    lpProvider - Pointer to the name of the provider for which information is
        required.

    lpdwNetType - Pointer to a network type value that is filled in.

Return Value:

    WN_SUCCESS - Call is successful.

    WN_BAD_PROVIDER - lpProvider does not match any active network provider.

    WN_BAD_POINTER - an illegal argument was passed in.

Notes:

    Since this is an internal, private API used only by the shell, we do
    minimal parameter validation, to make it as fast as possible.

--*/

{
    DWORD       status = WN_SUCCESS;

    if (!(ARGUMENT_PRESENT(lpProvider) &&
          ARGUMENT_PRESENT(lpdwNetType)))
    {
        SetLastError(WN_BAD_POINTER);
        return WN_BAD_POINTER;
    }

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    //
    // Look up the provider by name
    //
    LPPROVIDER provider = MprFindProviderByName(lpProvider);
    if (NULL == provider)
    {
        SetLastError(WN_BAD_PROVIDER);
        return WN_BAD_PROVIDER;
    }

    *lpdwNetType = provider->Type;
    return WN_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\strbuf.cxx ===
#include "precomp.hxx"
#include <wchar.h>      // wcsncpy


BOOL
NetpCopyStringToBuffer (
    IN LPWSTR String OPTIONAL,
    IN DWORD CharacterCount,
    IN LPWSTR FixedDataEnd,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    )

/*++

Routine Description:

    This routine puts a single variable-length string into an output buffer.
    The string is not written if it would overwrite the last fixed structure
    in the buffer.

    The code is swiped from svcsupp.c written by DavidTr.

    Sample usage:

            LPBYTE FixedDataEnd = OutputBuffer + sizeof(WKSTA_INFO_202);
            LPTSTR EndOfVariableData = OutputBuffer + OutputBufferSize;

            //
            // Copy user name
            //

            NetpCopyStringToBuffer(
                UserInfo->UserName.Buffer;
                UserInfo->UserName.Length;
                FixedDataEnd,
                &EndOfVariableData,
                &WkstaInfo->wki202_username
                );

Arguments:

    String - Supplies a pointer to the source string to copy into the
        output buffer.  If String is null then a pointer to a zero terminator
        is inserted into output buffer.

    CharacterCount - Supplies the length of String, not including zero
        terminator.  (This in units of characters - not bytes).

    FixedDataEnd - Supplies a pointer to just after the end of the last
        fixed structure in the buffer.

    EndOfVariableData - Supplies an address to a pointer to just after the
        last position in the output buffer that variable data can occupy.
        Returns a pointer to the string written in the output buffer.

    VariableDataPointer - Supplies a pointer to the place in the fixed
        portion of the output buffer where a pointer to the variable data
        should be written.

Return Value:

    Returns TRUE if string fits into output buffer, FALSE otherwise.

--*/
{

//  The following line has been removed.  Since we are manipulating
//  either LPSTR or LPWSTR, the pointer arithmetic automatically deals with
//  either bytes or words.  It is therefore only proper to deal in terms
//  of characters needed.  Not Bytes needed.  Therefore, the symbol has
//  been changed from BytesNeeded to CharsNeeded.
//
//    DWORD BytesNeeded = (CharacterCount + 1) * sizeof(WCHAR);
//
//
    DWORD CharsNeeded = (CharacterCount + 1);


#ifdef remove
    DbgPrint("NetpStringToBuffer: String at " FORMAT_POINTER
                ", CharacterCount=" FORMAT_DWORD
                ",\n  FixedDataEnd at " FORMAT_POINTER
                ", *EndOfVariableData at " FORMAT_POINTER
                ",\n  VariableDataPointer at " FORMAT_POINTER
                ", CharsNeeded=" FORMAT_DWORD ".\n",
                String, CharacterCount, FixedDataEnd, *EndOfVariableData,
                VariableDataPointer, CharsNeeded);
#endif
    //
    // Determine if string will fit, allowing for a zero terminator.  If no,
    // just set the pointer to NULL.
    //

    if ((*EndOfVariableData - CharsNeeded) >= FixedDataEnd) {

        //
        // It fits.  Move EndOfVariableData pointer up to the location where
        // we will write the string.
        //

        *EndOfVariableData -= CharsNeeded;

        //
        // Copy the string to the buffer if it is not null.
        //

        if (CharacterCount > 0 && String != NULL) {

            wcsncpy(*EndOfVariableData, String, CharacterCount);
        }

        //
        // Set the zero terminator.
        //

        *(*EndOfVariableData + CharacterCount) = (WCHAR) '\0';

        //
        // Set up the pointer in the fixed data portion to point to where the
        // string is written.
        //

        *VariableDataPointer = *EndOfVariableData;

        return TRUE;

    }
    else {

        //
        // It doesn't fit.  Set the offset to NULL.
        //

        *VariableDataPointer = NULL;

        return FALSE;
    }
} // NetpCopyStringToBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\resinfo.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    resinfo.cxx

Abstract:

    Contains the entry points for the WinNet Resource Info API supported
    by the Multi-Provider Router.  The following functions are in this file:

        WNetGetResourceInformationW
        WNetGetResourceParentW

Author:

    Anirudh Sahni (anirudhs) 27-Apr-1995

Environment:

    User Mode -Win32

Notes:


Revision History:

    27-Apr-1995     anirudhs
        Created
    16-Oct-1995     anirudhs
        Converted to use MPR base classes
    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/
//
// INCLUDES
//
#include "precomp.hxx"


//===================================================================
// WNetGetResourceInformationW
//===================================================================

class CGetResourceInformation : public CRoutedOperation
{
public:
                    CGetResourceInformation(
                        LPNETRESOURCEW  lpNetResource,
                        LPVOID          lpBuffer,
                        LPDWORD         lpBufferSize,
                        LPWSTR         *lplpSystem
                        ) :
                            CRoutedOperation(DBGPARM("GetResourceInformation")
                                             PROVIDERFUNC(GetResourceInformation)),
                            _lpNetResource(lpNetResource),
                            _lpBuffer     (lpBuffer),
                            _lpBufferSize (lpBufferSize),
                            _lplpSystem   (lplpSystem)
                        { }

private:

    LPNETRESOURCEW  _lpNetResource;
    LPVOID          _lpBuffer;
    LPDWORD         _lpBufferSize;
    LPWSTR *        _lplpSystem;

    DECLARE_CROUTED
};


DWORD
CGetResourceInformation::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    if (!(ARGUMENT_PRESENT(_lpNetResource) &&
          ARGUMENT_PRESENT(_lpBufferSize) &&
          ARGUMENT_PRESENT(_lplpSystem)))
    {
        return WN_BAD_POINTER;
    }

    if (_lpNetResource->lpRemoteName == NULL)
    {
        return WN_BAD_NETNAME;
    }

    //
    // If there is an output buffer, probe it.
    //
    if (IS_BAD_BYTE_BUFFER(_lpBuffer, _lpBufferSize))
    {
        return WN_BAD_POINTER;
    }

    *_lplpSystem = NULL;

    //
    // Set parameters used by base class.
    //
    *ppProviderName = _lpNetResource->lpProvider;
    *ppRemoteName   = _lpNetResource->lpRemoteName;
    *ppLocalName    = NULL;

    return WN_SUCCESS;
}


DWORD
CGetResourceInformation::TestProvider(
    const PROVIDER * pProvider
    )
{
    ASSERT_INITIALIZED(NETWORK);

    return ( pProvider->GetResourceInformation(
                            _lpNetResource,
                            _lpBuffer,
                            _lpBufferSize,
                            _lplpSystem) );
}


DWORD
WNetGetResourceInformationW(
    LPNETRESOURCEW  lpNetResource,
    LPVOID          lpBuffer,
    LPDWORD         lpBufferSize,
    LPWSTR         *lplpSystem
    )
/*++

Routine Description:

    This API is used to find enumeration information for a resource (whose
    name is typically typed in by the user).

Arguments:

    lpNetResource -

    lpBuffer -

    lpBufferSize -

    lplpSystem -

Return Value:

    WN_SUCCESS - Indicates the operation was successful.

    Other errors -

--*/
{
    CGetResourceInformation GetResInfo(lpNetResource,
                                       lpBuffer,
                                       lpBufferSize,
                                       lplpSystem);

    return (GetResInfo.Perform(TRUE));
}


//===================================================================
// WNetGetResourceParentW
//===================================================================

class CGetResourceParent : public CRoutedOperation
{
public:
                    CGetResourceParent(
                        LPNETRESOURCEW  lpNetResource,
                        LPVOID          lpBuffer,
                        LPDWORD         lpBufferSize
                        ) :
                            CRoutedOperation(DBGPARM("GetResourceParent")
                                             PROVIDERFUNC(GetResourceParent)),
                            _lpNetResource(lpNetResource),
                            _lpBuffer     (lpBuffer),
                            _lpBufferSize (lpBufferSize)
                        { }

private:

    LPNETRESOURCEW  _lpNetResource;
    LPVOID          _lpBuffer;
    LPDWORD         _lpBufferSize;

    DECLARE_CROUTED
};


DWORD
CGetResourceParent::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    if (!(ARGUMENT_PRESENT(_lpNetResource) &&
          ARGUMENT_PRESENT(_lpBufferSize)))
    {
        return WN_BAD_POINTER;
    }

    if (_lpNetResource->lpRemoteName == NULL)
    {
        return WN_BAD_NETNAME;
    }

    //
    // Unlike Win95, we require a provider name.  This allows our providers
    // to make several simplifying assumptions.
    //
    if (IS_EMPTY_STRING(_lpNetResource->lpProvider))
    {
        return WN_BAD_PROVIDER;
    }

    //
    // If there is an output buffer, probe it.
    //
    if (IS_BAD_BYTE_BUFFER(_lpBuffer, _lpBufferSize))
    {
        return WN_BAD_POINTER;
    }

    //
    // Set parameters used by base class.
    //
    *ppProviderName = _lpNetResource->lpProvider;
    *ppRemoteName   = _lpNetResource->lpRemoteName;
    *ppLocalName    = NULL;

    return WN_SUCCESS;
}


DWORD
CGetResourceParent::TestProvider(
    const PROVIDER * pProvider
    )
{
    ASSERT_INITIALIZED(NETWORK);

    return ( pProvider->GetResourceParent(
                            _lpNetResource,
                            _lpBuffer,
                            _lpBufferSize) );
}


DWORD
WNetGetResourceParentW(
    LPNETRESOURCEW  lpNetResource,
    LPVOID          lpBuffer,
    LPDWORD         lpBufferSize
    )
/*++

Routine Description:

    This API is used to find enumeration information for a resource (whose
    name is typically typed in by the user).

Arguments:

    lpNetResource -

    lpBuffer -

    lpBufferSize -

Return Value:

    WN_SUCCESS - Indicates the operation was successful.

    Other errors -

--*/
{
    CGetResourceParent GetResParent(lpNetResource, lpBuffer, lpBufferSize);

    return (GetResParent.Perform(TRUE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\idl\winsimp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Pradeep Bahl 	Apr-1992 

Revision History:


--*/



#include <windef.h>
#ifdef MIDL_PASS
#define va_list char		//required so that I can include winsbase.h
				//in winsintf.h (to get def of SYSTEMTIME
#ifdef UNICODE
#define LPTSTR [string] wchar_t*
#else
#define LPTSTR [string] LPTSTR
#endif
#define LPSTR [string] LPSTR
#define RPC_BOOL DWORD
#else
#include <stdarg.h>		//for definition of va_list
#endif
#include <winsintf.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\support.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    support.cxx

Abstract:

    Contains functions that are used by all MPR API.
        MprFindCallOrder
        MprInitIndexArray
        MprDeleteIndexArray
        MprDeviceType
        MprGetProviderIndex
        MprFindProviderByName
        MprFindProviderByType
        MprEnterLoadLibCritSect
        MprLeaveLoadLibCritSect
        MprGetUserName

Author:

    Dan Lafferty (danl)     09-Oct-1991

Environment:

    User Mode -Win32

Notes:



Revision History:

    05-May-1999     jschwart
        Make provider addition/removal dynamic

    15-Jan-1996     anirudhs
        Add MprGetUserName.

    22-Jan-1993     danl
        FindCallOrder:  This code was going through the global array of
        providers, rather than looking at only "Active" providers.  It should
        have been using the GlobalIndexArray which is an array of the indices
        for the "Active" providers only.

    02-Nov-1992     danl
        Fail with NO_NETWORK if there are no providers.

    09-Oct-1991     danl
        created

--*/

//
// INCLUDES
//
#include "precomp.hxx"
#include <string.h>     // memcmp
#include <debugfmt.h>   // FORMAT_LPTSTR
#include <lmcons.h>     // NET_API_FUNCTION
#include <lmerr.h>      // NET_API_STATUS

//
// EXTERNALS
//
    extern DWORD        GlobalNumActiveProviders;
    extern CRITICAL_SECTION MprInitCritSec;



#define DEFAULT_ERROR_BUF_SIZE  1024

//
// MprLoadLibSemaphore global var is used to protect the DLL
// handle and Entry point addresses for delayed loading of MPRUI.DLL.
// It is initialized at process attach time.
//
HANDLE MprLoadLibSemaphore = NULL ;

//
// This is where the pointer to the array of provider indices is stored.
//
/* static */ LPDWORD   GlobalIndexArray;



DWORD
MprFindCallOrder(
    IN     LPTSTR      NameInfo,
    IN OUT LPDWORD     *IndexArrayPtr,
    OUT    LPDWORD     IndexArrayCount,
    IN     DWORD       InitClass
    )

/*++

Routine Description:

    This function determines the proper order in which to call the
    various providers.

    This order is based on the ordered list that is stored in the
    registry.

    Because the provider structures are kept in an array, the indices can
    be used to index into that array.

    IMPORTANT! : Memory may be allocated for this array, so it
    is the responsibility of the caller to free the memory when it is
    finished.


Arguments:

    NameInfo - This is a pointer to a string that is most likely to
        contain the name of the network resource being addressed.  If a
        NULL pointer, or a pointer to a NULL string is passed in, this
        information will be ignored. (Note: Currently this information is
        not used).

    IndexArrayPtr - This is a pointer to a location where the pointer to
        the array of indices resides.  On entry, the pointer in this
        location points to an array allocated by the caller.  This array
        is expected to be DEFAULT_MAX_PROVIDERS long.  If a larger array
        is required, this function will allocate space for it and
        replace this pointer with the new one.

    IndexArrayCount - This is a pointer to a location where the number of
        elements in the returned array is to be placed.

    InitClass - This indicates what type of providers we want listed in the
        array.  The choices are either CREDENTIAL_TYPE or NETWORK_TYPE
        providers.

Return Value:

     WN_SUCCESS - If the operation was successful.

     WN_OUT_OF_MEMORY - If this function was unable to allocate memory for
        the return buffer.

     WN_NO_NETWORK - If there are no providers available, or none of the
        providers support this InitClass.

--*/
{

    DWORD   i,j;

    UNREFERENCED_PARAMETER(NameInfo);
    //
    // If there are no Providers, then return WN_NO_NETWORK
    //
    ASSERT(MPR_IS_INITIALIZED(NETWORK) || MPR_IS_INITIALIZED(CREDENTIAL));
    ASSERT(MPRProviderLock.Have());

    if (GlobalNumActiveProviders == 0) {
        return(WN_NO_NETWORK);
    }

    //
    // We cannot interact with active provider information unless we
    // have obtained synchronized access.  Otherwise we would risk
    // trying to read data while it is being modified.
    //
    EnterCriticalSection(&MprInitCritSec);

    if (GlobalNumActiveProviders > DEFAULT_MAX_PROVIDERS) {
        *IndexArrayPtr = (LPDWORD) LocalAlloc(LPTR,
                            GlobalNumProviders*sizeof(DWORD));

        if (*IndexArrayPtr == NULL) {
           MPR_LOG1(ERROR,"FindCallOrder: LocalAlloc Failed %d\n",GetLastError());

           LeaveCriticalSection(&MprInitCritSec);
           return (WN_OUT_OF_MEMORY);
        }
    }

    //
    // Fill in the array with the order that was obtained from the ordered
    // list at initialization time.  (Stored in GlobalIndexArray).
    //


    MPR_LOG0(TRACE,"CallOrder - \n");

    for( i=j=0; i<GlobalNumActiveProviders; i++) {

        if (GlobalProviderInfo[GlobalIndexArray[i]].InitClass & InitClass) {
            (*IndexArrayPtr)[j] = GlobalIndexArray[i];
            j++;
        }

        MPR_LOG1(TRACE,"\tprovider index: %d  \n",GlobalIndexArray[i]);
    }

    MPR_LOG0(TRACE,"\n");

    LeaveCriticalSection(&MprInitCritSec);
    if (j == 0) {
        return(WN_NO_NETWORK);
    }
    *IndexArrayCount = j;


    return(WN_SUCCESS);
}



//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::FindCallOrder (static)
//
//  Purpose:    This function determines the proper order in which to call the
//              various providers.
//              This order is based on the ordered list that is stored in the
//              registry.
//
//  Arguments:
//
//      NameInfo - This is a pointer to a string that is most likely to
//          contain the name of the network resource being addressed.  If a
//          NULL pointer, or a pointer to a NULL string is passed in, this
//          information will be ignored.
//
//      ProviderArray - This is a pointer to an array of LPPROVIDERs.
//          This array is expected to be GlobalNumProviders long.
//
//      ProviderArrayCount - This is a pointer to a location where the number of
//          elements in the returned array is to be placed.
//
//      InitClass - This indicates what type of providers we want listed in the
//          array.  The choices are either CREDENTIAL_TYPE or NETWORK_TYPE
//          providers.
//
//  Return Value:
//
//       WN_SUCCESS - If the operation was successful.
//
//       WN_NO_NETWORK - If there are no providers available, or none of the
//          providers support this InitClass.
//
//
//  History:    08-Apr-96 AnirudhS  Created from MprFindCallOrder
//
//  Notes:      CODEWORK This should replace MprFindCallOrder.
//
//--------------------------------------------------------------------------

DWORD CRoutedOperation::FindCallOrder(
    IN     const UNICODE_STRING * NameInfo,
    OUT    LPPROVIDER  ProviderArray[],
    OUT    LPDWORD     ProviderArrayCount,
    IN     DWORD       InitClass
    )
{
    //
    // If there are no Providers, then return WN_NO_NETWORK
    //
    ASSERT(MPR_IS_INITIALIZED(NETWORK) || MPR_IS_INITIALIZED(CREDENTIAL));
    ASSERT(MPRProviderLock.Have());

    if (GlobalNumActiveProviders == 0)
    {
        return WN_NO_NETWORK;
    }

    //
    // We cannot interact with active provider information unless we
    // have obtained synchronized access.  Otherwise we would risk
    // trying to read data while it is being modified.
    //
    EnterCriticalSection(&MprInitCritSec);

    //
    // If a provider previously responded for the specified path, put it
    // first in the array.
    //
    DWORD j = 0;    // index into ProviderArray
    LPPROVIDER CachedProvider = _PathCache.FindEntry(NameInfo);
    if (CachedProvider != NULL && (CachedProvider->InitClass & InitClass))
    {
        ProviderArray[j] = CachedProvider;
        j++;
    }

    //
    // Fill in the array with the order that was obtained from the ordered
    // list at initialization time.  (Stored in GlobalIndexArray).
    //
    for (DWORD i=0; i<GlobalNumActiveProviders; i++)
    {
        LPPROVIDER Provider = &GlobalProviderInfo[GlobalIndexArray[i]];
        if ((Provider->InitClass & InitClass) &&
            Provider != CachedProvider)
        {
            ProviderArray[j] = Provider;
            j++;
        }
    }

    LeaveCriticalSection(&MprInitCritSec);

    if (j == 0)
    {
        return WN_NO_NETWORK;
    }

    *ProviderArrayCount = j;

    return WN_SUCCESS;
}


VOID
MprInitIndexArray(
    LPDWORD     IndexArray,
    DWORD       NumEntries
    )

/*++

Routine Description:

    This function stores data from the passed in IndexArray in a global
    IndexArray.  If a global index array already exists when this function
    is called, then the two arrays need to be merged.  This function also
    updates the GlobalNumActiveProviders.

    NOTE:  The array of provider structures is always created in the
    order specified by the ordered provider list.  Therefore, it is reasonable
    to merge these lists by putting the array of indices in increasing order.

    It is expected that the MprInitCritSec lock is held prior to entering
    this function.

    This function will free the memory pointed to by IndexArray, if it is
    no longer needed.


Arguments:

    IndexArray - This is a pointer to an array of DWORDs which are indices
        to the various providers.  The buffer for this array is always
        large enough to hold indices for all providers; active, or inactive.

    NumEntries - This contains the number of entries in the IndexArray.


Return Value:

    none

--*/
{
    DWORD       newNumEntries=0;
    DWORD       dest,s1,s2;         // index for Destination, Source1, and Source2.
    DWORD       tempBuffer[16];
    LPDWORD     tempArray;


    if (NumEntries == 0) {
        return;
    }

    if (GlobalIndexArray == NULL) {
        GlobalNumActiveProviders = NumEntries;
        GlobalIndexArray = IndexArray;
    }
    else {

        //
        // An list already exists.  Therefore we need to create a new
        // list of ordered indices.
        //

        //
        // Copy the GlobalIndexArray data into a temporary buffer.  We
        // will try to use a buffer on the stack.  If that isn't large
        // enough, we will try to allocate a buffer.
        //
        tempArray = tempBuffer;
        if (GlobalNumProviders > 16) {
            tempArray = (LPDWORD)LocalAlloc(LPTR, GlobalNumProviders);
            if (tempArray == NULL) {
                MPR_LOG1(ERROR,"MprInitIndexArray: LocalAlloc failed %d\n",GetLastError());
                LocalFree(IndexArray);
                return;
            }
        }
        memcpy(tempArray, GlobalIndexArray, GlobalNumActiveProviders*sizeof(DWORD));


        //
        // Now copy an ordered list of indices into the GlobalIndexArray.
        // We assume that the two seperate lists are already ordered in
        // ascending order.  Therefore, we compare elements in both lists
        // one at a time - incrementing the index only for the array
        // containing the element that we move to the GlobalIndexArray.
        //
        dest=s1=s2=0;

        while ((s1 < GlobalNumActiveProviders) &&
               (s2 < NumEntries)) {

            if (tempArray[s1] < IndexArray[s2]) {
                GlobalIndexArray[dest] = tempArray[s1++];
            }
            else if (tempArray[s1] > IndexArray[s2]) {
                GlobalIndexArray[dest] = IndexArray[s2++];
            }
            else {
                GlobalIndexArray[dest] = IndexArray[s2];
                s1++;
                s2++;
            }
            dest++;
        }

        //
        // One of the arrays has reached its limit.  Therefore, the elements
        // from the remaining array must be moved.
        //
        if (s1 < GlobalNumActiveProviders) {
            do {
                GlobalIndexArray[dest++] = tempArray[s1++];
            } while (s1 < GlobalNumActiveProviders);
        }
        else if (s2 < NumEntries) {
            do  {
                GlobalIndexArray[dest++] = IndexArray[s2++];
            } while (s2 < NumEntries);
        }


        GlobalNumActiveProviders = dest;

        //
        // If we had to allocate a temporary buffer, then free it here.
        //
        if (tempArray != tempBuffer) {
            LocalFree(tempArray);
        }
        LocalFree(IndexArray);
    }

    return;
}

VOID
MprDeleteIndexArray(
    VOID
    )

/*++

Routine Description:

    This function frees up global resources used in the support routines.

Arguments:

    none

Return Value:

    none

--*/
{
    LocalFree(GlobalIndexArray);
    GlobalIndexArray = NULL;
    return;
}



DWORD
MprDeviceType(
    IN  LPCTSTR DeviceName
    )

/*++

Routine Description:

    This function determines if the device name is for a redirected device
    (port or drive), or if it is a name of a remote share point.

Arguments:

    DeviceName - This is the name that is passed in.  It is either the
        name of a redirected device (ie. c: lpt2: lpt3:) or it is
        the name of a share point (\\cyclops\scratch).

Return Value:

    REDIR_DEVICE - The name is for a redirected device

    REMOTE_NAME - The name is that of a remote connection.

--*/
{
    if (memcmp(DeviceName, TEXT("\\\\"), 2*sizeof(TCHAR)) == 0) {
        return(REMOTE_NAME);
    }

    if ((wcslen(DeviceName) == 2)       &&
        (DeviceName[1] == TEXT(':')))   {

        if ((TEXT('a') <= DeviceName[0]) && (DeviceName[0] <= TEXT('z'))) {
            return(REDIR_DEVICE);
        }
        else if ((TEXT('A') <= DeviceName[0]) && (DeviceName[0] <= TEXT('Z'))) {
            return(REDIR_DEVICE);
        }

    }
    else if (wcslen(DeviceName) > 3) {

        if (_wcsnicmp(DeviceName, TEXT("LPT"), 3) == 0) {
            return(REDIR_DEVICE);
        }
        if (_wcsnicmp(DeviceName, TEXT("COM"), 3) == 0) {
            return(REDIR_DEVICE);
        }
    }

    return(REMOTE_NAME);
}



BOOL
MprGetProviderIndex(
    IN  LPCTSTR ProviderName,
    OUT LPDWORD IndexPtr
    )

/*++

Routine Description:

    This function looks in the provider database for a Provider name that
    will match the name passed in.  When it is found, the index to that
    provider is stored in the location pointed to by IndexPtr.

Arguments:

    ProviderName - This is a pointer to a string that contains the
        name which identifies a provider.

    IndexPtr - This is a pointer to a location where the index for the
        provider information is to be placed.

Return Value:

    TRUE - The operation was successful.

    FALSE - A failure occured.  IndexPtr is not updated.

--*/
{
    LPPROVIDER  lpProvider;
    DWORD       i;

    ASSERT_INITIALIZED(FIRST);

    //
    // Point to the top of the array of provider structures.
    //
    lpProvider = GlobalProviderInfo;

    //
    // Loop through each provider in the database until the list is
    // exhausted, or until a match with the provider name is found.
    //
    for(i=0; i<GlobalNumProviders; i++,lpProvider++) {

        if (lpProvider->Resource.lpProvider != NULL) {
            if(_wcsicmp(lpProvider->Resource.lpProvider, ProviderName) == 0) {
                //
                // A match is found, return the pointer to the provider
                // structure.
                //
                *IndexPtr = i;
                return(TRUE);
            }
        }
    }
    //
    // The list of provider structures was exhausted and no provider match
    // was found.  Return a NULL pointer.
    //
    return(FALSE);
}

LPPROVIDER
MprFindProviderByName(
    IN  LPCWSTR ProviderName
    )

/*++

Routine Description:

    This function searches the provider database for the first provider
    whose provider name matches the name passed in, and returns a pointer
    to the provider structure.

Arguments:

    ProviderName - The provider name to look for.

Return Value:

    Pointer to the provider structure if a match was found, NULL if not.

--*/
{
    ASSERT(ProviderName != NULL);
    ASSERT_INITIALIZED(FIRST);

    for (LPPROVIDER lpProvider = GlobalProviderInfo;
         lpProvider < GlobalProviderInfo + GlobalNumProviders;
         lpProvider++)
    {
        if (lpProvider->Resource.lpProvider != NULL &&
            _wcsicmp(lpProvider->Resource.lpProvider, ProviderName) == 0)
        {
            return lpProvider;
        }
    }

    return NULL;
}


LPPROVIDER
MprFindProviderByType(
    IN  DWORD   ProviderType
    )

/*++

Routine Description:

    This function searches the provider database for the first provider
    whose provider type matches the type passed in, and returns a pointer
    to the provider structure.

Arguments:

    ProviderType - The network type to look for.  Only the HIWORD is used;
        the LOWORD is ignored.

Return Value:

    Pointer to the provider structure if a match was found, NULL if not.

--*/
{
    ASSERT(MPR_IS_INITIALIZED(NETWORK) || MPR_IS_INITIALIZED(CREDENTIAL));
    ASSERT(MPRProviderLock.Have());

    for (LPPROVIDER lpProvider = GlobalProviderInfo;
         lpProvider < GlobalProviderInfo + GlobalNumProviders;
         lpProvider++)
    {
        //
        // if (HIWORD(lpProvider->Type) == HIWORD(ProviderType))
        //
        if (((lpProvider->Type ^ ProviderType) & 0xFFFF0000) == 0 &&
            (lpProvider->InitClass & NETWORK_TYPE) != 0)
        {
            return lpProvider;
        }
    }

    return NULL;
}


DWORD
MprEnterLoadLibCritSect (
    VOID
    )
/*++

Routine Description:

    This function enters the critical section defined by
    MprLoadLibrarySemaphore.

Arguments:

    none

Return Value:

    0 - The operation was successful.

    error code otherwise.

--*/

#define LOADLIBRARY_TIMEOUT 10000L
{
    switch( WaitForSingleObject( MprLoadLibSemaphore, LOADLIBRARY_TIMEOUT ))
    {
    case 0:
    return 0 ;

    case WAIT_TIMEOUT:
    return WN_FUNCTION_BUSY ;

    case 0xFFFFFFFF:
    return (GetLastError()) ;

    default:
    return WN_WINDOWS_ERROR ;
    }
}

DWORD
MprLeaveLoadLibCritSect (
    VOID
    )
/*++

Routine Description:

    This function leaves the critical section defined by
    MprLoadLibrarySemaphore.

Arguments:

    none

Return Value:

    0 - The operation was successful.

    error code otherwise.

--*/
{
    if (!ReleaseSemaphore( MprLoadLibSemaphore, 1, NULL ))
        return (GetLastError()) ;

    return 0 ;
}

VOID
MprClearString (
    LPWSTR  lpString
    )
/*++

Routine Description:

    This function clears the string by setting it to all zero.

Arguments:

    lpString - string to NULL out

Return Value:

    none

--*/
{
    DWORD dwLen ;

    if (lpString)
    {
        dwLen = wcslen(lpString) ;
        memset(lpString, 0, dwLen * sizeof(WCHAR)) ;
    }
}

DWORD
MprFindProviderForPath(
    IN  LPWSTR  lpPathName,
    OUT LPDWORD lpProviderIndex
    )

/*++

Routine Description:

    This function attempts to find the provider index for the provider that is
    responsible for the pathname that is passed in.  Only the drive letter is
    examined.  Then MprGetConnection is called to find the provider for that
    drive.

Arguments:

    lpPathName - This is a pointer to the pathname string.  It is expected to
        be of the format <drive:><path>.  (ie.  f:\nt\system32>.

    lpProviderIndex - This is a pointer to the location where the provider index
        is to be returned.  If an error is returned, this index is garbage.


Return Value:

    WN_SUCCESS - If the operation is successful.  In this case the provider
        index will always be correct.

    otherwise - An error occured, the provider index will not be correct.

--*/
{
    DWORD       status=WN_SUCCESS;
    WCHAR       lpDriveName[3];
    WCHAR       lpRemoteName[MAX_PATH];
    DWORD       bufSize = MAX_PATH * sizeof(WCHAR);

    //
    // Get the drive letter out of the lpDriveName.
    //
    __try {
        if (lpPathName[1] != L':') {
            return(WN_BAD_VALUE);
        }
        lpDriveName[0] = lpPathName[0];
        lpDriveName[1] = lpPathName[1];
        lpDriveName[2] = L'\0';

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetGetPropertyText:Unexpected Exception "
            "0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }
    if (status != WN_SUCCESS) {
        return(status);
    }

    //
    // Find out which provider owns the drive by calling MprGetConnection.
    //
    status = MprGetConnection(
                lpDriveName,
                lpRemoteName,
                &bufSize,
                lpProviderIndex);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\uniname.cxx ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    UNINAME.CXX

Abstract:



Author:

    Dan Lafferty (danl)     24-Apr-1994

Environment:

    User Mode -Win32

Revision History:

    24-Apr-1994     danl
        Created

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <tstr.h>       // STRLEN

//
// PROTOTYPES
//
DWORD
MprTranslateRemoteName(
    LPREMOTE_NAME_INFOW pRemoteNameInfo,
    LPDWORD             lpBufferSize,
    LPWSTR              pRemoteName,
    LPCWSTR             pRemainingPath
    );


DWORD
WNetGetUniversalNameW (
    IN      LPCTSTR  lpLocalPath,
    IN      DWORD   dwInfoLevel,
    OUT     LPVOID  lpBuffer,
    IN OUT  LPDWORD lpBufferSize
    )

/*++

Routine Description:


Arguments:

    lpLocalPath - This is a pointer to the string that contains the local path.
        This is a path that contains a drive-letter prefixed path string.
        "X:" is a valid local path.  "X:\nt\system32" is a valid local path.
        "\\popcorn\public\nt" is not a valid local path.

    dwInfoLevel - This DWORD indicates what information is to be stored in
        the return buffer.  Currently the following levels are supported:
        INFOLEVEL_UNIVERSAL_NAME
        INFOLEVEL_REMOTE_NAME

    lpBuffer - This is a pointer to the buffer where the requested information
        is to be placed.

    lpBufferSize - This is a pointer to the size of the buffer in bytes.
        If the buffer is not large enough, then the required buffer size
        Will be placed in this location upon return with WN_MORE_DATA.

Return Value:


--*/
{
    DWORD       status = WN_SUCCESS;
    LPDWORD     indexArray;
    DWORD       localArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders;
    LPPROVIDER  provider;
    DWORD       statusFlag = 0; // used to indicate major error types
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       i;
    WCHAR       pDriveLetter[4];
    LPWSTR      pRemoteName = (LPWSTR)((LPBYTE)lpBuffer + sizeof(REMOTE_NAME_INFOW));

    //
    // Validate the drive portion of the local path. Make sure its a valid
    // device.
    //
    __try {
        pDriveLetter[0] = lpLocalPath[0];
        pDriveLetter[1] = lpLocalPath[1];
        pDriveLetter[2] = L'\0';
        if (MprDeviceType(pDriveLetter) != REDIR_DEVICE) {
            status = WN_BAD_LOCALNAME;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetGetUniversalNameW:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS) {
        SetLastError(status);
        return(status);
    }

    if ((dwInfoLevel != UNIVERSAL_NAME_INFO_LEVEL) &&
        (dwInfoLevel != REMOTE_NAME_INFO_LEVEL)) {
        SetLastError(ERROR_INVALID_LEVEL);
        return(ERROR_INVALID_LEVEL);
    }

    MprCheckProviders();

    CProviderSharedLock    PLock;

    //
    // Check to see if this is a remote drive to begin with. If not, we can
    // fail it quickly.
    //
    pDriveLetter[2] = L'\\';
    pDriveLetter[3] = L'\0';

    if (GetDriveType(pDriveLetter) != DRIVE_REMOTE) {
        status = WN_NOT_CONNECTED;
    }

    pDriveLetter[2] = L'\0';

    if (status == WN_SUCCESS) {

        INIT_IF_NECESSARY(NETWORK_LEVEL,status);

        //
        // Find the list of providers to call for this request.
        //
        indexArray = localArray;

        status = MprFindCallOrder(
                    NULL,
                    &indexArray,
                    &numProviders,
                    NETWORK_TYPE);

        if (status != WN_SUCCESS) {
            SetLastError(status);
            return(status);
        }

        //
        // Loop through the list of providers until one answers the request,
        // or the list is exhausted.
        //
        for (i=0; i<numProviders; i++) {

            //
            // Call the appropriate providers API entry point
            // If the provider doesn't support GetUniversalName
            // then see if that provider owns the connection by
            // calling GetConnection.
            //
            provider = GlobalProviderInfo + indexArray[i];

            if (provider->GetUniversalName != NULL) {

                //--------------------------------------
                // Call Provider with GetUniversalName
                //--------------------------------------

                fcnSupported = TRUE;

                __try {

                    status = provider->GetUniversalName(
                                lpLocalPath,
                                dwInfoLevel,
                                lpBuffer,
                                lpBufferSize);
                }

                __except(MPR_EXCEPTION_FILTER) {
                    status = GetExceptionCode();
                    if (status != EXCEPTION_ACCESS_VIOLATION) {
                        MPR_LOG(ERROR,"WNetGetUniversalNameW:Unexpected Exception 0x%lx\n",status);
                    }
                    status = WN_BAD_POINTER;
                }
            }

            //
            // Try GetConnection for a Remote name.  Note that we
            // don't do this for a Universal name since providers
            // are not required to support it (i.e., the name in
            // the registry might not be universal).
            //
            else if ((dwInfoLevel == REMOTE_NAME_INFO_LEVEL) &&
                     (provider->GetConnection != NULL)) {

                //--------------------------------------
                // Call Provider with GetConnection
                //--------------------------------------
                DWORD buflen = 0;

                __try {

                    if (*lpBufferSize > sizeof(REMOTE_NAME_INFOW)) {
                        //
                        // Remember, GetConnection is looking for the size of the
                        // buffer in characters - not bytes.
                        //
                        buflen = ((*lpBufferSize) - sizeof(REMOTE_NAME_INFOW))/sizeof(WCHAR);
                    }

                    status = provider->GetConnection(
                                pDriveLetter,
                                pRemoteName,
                                &buflen
                                );

                    if (status == WN_SUCCESS) {

                        //
                        // We got the RemoteName.  See if there's enough room
                        // in the buffer for the portion of the local path that
                        // follows the drive letter and colon.  If there's
                        // enough room, then store the remaining path in the
                        // buffer and fill in the structure.
                        //
                        status = MprTranslateRemoteName(
                                    (LPREMOTE_NAME_INFOW)lpBuffer,
                                    lpBufferSize,
                                    pRemoteName,
                                    &(lpLocalPath[2]));

                        fcnSupported = TRUE;

                    }
                    else if (status == WN_MORE_DATA) {
                        //
                        // The buflen we get back from GetConnection will account
                        // for the RemoteName portion, but not the remaining path
                        // portion.  So we have to add that to the size calculation.
                        //
                        *lpBufferSize = sizeof(REMOTE_NAME_INFOW) +
                                        (WCSSIZE(&(lpLocalPath[2])))    +
                                        (buflen * sizeof(WCHAR));

                        fcnSupported = TRUE;
                    }
                }

                __except(MPR_EXCEPTION_FILTER) {
                    status = GetExceptionCode();
                    if (status != EXCEPTION_ACCESS_VIOLATION) {
                        MPR_LOG(ERROR,"WNetGetUniversalNameW:Unexpected Exception 0x%lx\n",status);
                    }
                    status = WN_BAD_POINTER;
                }
            }
            else {
                //----------------------------------
                // NEITHER FUNCTION IS SUPPORTED!
                // Go to the next provider.
                //----------------------------------
                continue;
            }

            if (status == WN_NO_NETWORK) {
                statusFlag |= NO_NET;
            }
            else if ((status == WN_NOT_CONNECTED)  ||
                     (status == WN_BAD_LOCALNAME)){
                //
                // WN_NOT_CONNECTED means that lpLocalPath is not a
                // redirected device for this provider.
                //
                statusFlag |= BAD_NAME;
            }
            else {
                //
                // If it wasn't one of those errors, then the provider
                // must have accepted responsiblity for the request.
                // so we exit and process the results.  Note that the
                // statusFlag is cleared because we want to ignore other
                // error information that we gathered up until now.
                //
                statusFlag = 0;
                break;
            }

        } // End for each provider.

        if (fcnSupported == FALSE) {
            //
            // No providers in the list support the API function.  Therefore,
            // we assume that no networks are installed.
            //
            status = WN_NOT_SUPPORTED;
        }

        //
        // If memory was allocated by MprFindCallOrder, free it.
        //
        if (indexArray != localArray) {
            LocalFree(indexArray);
        }

        //
        // Handle special errors.
        //
        if (statusFlag == (NO_NET | BAD_NAME)) {
            //
            // Check to see if there was a mix of special errors that occured.
            // If so, pass back the combined error message.  Otherwise, let the
            // last error returned get passed back.
            //
            status = WN_NO_NET_OR_BAD_PATH;
        }
    }

    //
    // Handle normal errors passed back from the provider
    //
    // NOTE: INIT_IF_NECESSARY may not have been executed by this point.
    // Use caution when modifying code below.  For example, this affects
    // the behavior of MprGetRemoteName.
    //
    if (status != WN_SUCCESS)
    {
        if (status == WN_NOT_CONNECTED
             &&
            dwInfoLevel == REMOTE_NAME_INFO_LEVEL)
        {
            DWORD bufSize = 0;

            //
            // If not connected, but there is an entry for the LocalName
            // in the registry, then return the remote name that was stored
            // with it.  Note that we don't do this for a Universal name
            // since providers are not required to support it (i.e., the
            // name in the registry might not be universal).
            //

            if (*lpBufferSize > sizeof(REMOTE_NAME_INFOW))
            {
                bufSize = *lpBufferSize - sizeof(REMOTE_NAME_INFOW);
            }

            if (MprGetRemoteName(
                    pDriveLetter,
                    &bufSize,
                    pRemoteName,
                    &status)) {

                if (status == WN_SUCCESS)
                {
                    status = MprTranslateRemoteName(
                                (LPREMOTE_NAME_INFOW)lpBuffer,
                                lpBufferSize,
                                pRemoteName,
                                &(lpLocalPath[2]));

                    if (status == WN_SUCCESS)
                    {
                        status = WN_CONNECTION_CLOSED;
                    }
                }
                else if (status == WN_MORE_DATA)
                {
                    //
                    // The buflen we get back from MprGetRemoteName will account
                    // for the RemoteName portion, but not the remaining path
                    // portion.  So we have to add that to the size calculation
                    // (which is what MprTranslateRemoteName does as well).
                    //

                    *lpBufferSize = sizeof(REMOTE_NAME_INFOW) +
                                        WCSSIZE(&(lpLocalPath[2])) +
                                        bufSize * sizeof(WCHAR);
                }
            }
        }

        SetLastError(status);
    }

    return(status);
}


DWORD
MprTranslateRemoteName(
    LPREMOTE_NAME_INFOW pRemoteNameInfo,
    LPDWORD             lpBufferSize,
    LPWSTR              pRemoteName,
    LPCWSTR             pRemainingPath
    )

/*++

Routine Description:

    This function adds the remaining path string to the buffer and places
    the pointer to it into the structure.


Arguments:

    pRemoteNameInfo - Pointer to a buffer which will contain the
        REMOTE_NAME_INFO structure followed by the strings pointed
        to in the structure.

    lpBufferSize - Pointer to a DWORD that indicates the size of the
        pRemoteNameInfo buffer.

    pRemoteName - Pointer to the location in the pRemoteNameInfo buffer
        where the remote name string can be placed.

    pRemainingPath - Pointer to the remaining path string.


Return Value:

    WN_MORE_DATA - If the buffer was not large enough to hold all the data.
        When this is returned, the required buffer size is stored at the
        location pointed to by lpBufferSize.

    WN_SUCCESS - If the operation was completely successful.

Note:


--*/
{
    DWORD               bufSize = *lpBufferSize - sizeof(REMOTE_NAME_INFOW);
    DWORD               remoteNameLen;
    DWORD               remainingPathLen;
    DWORD               sizeRequired;

    //
    // We got the RemoteName.  See if there's enough room
    // in the buffer for the portion of the local path that
    // follows the drive letter and colon.  If there's
    // enough room, then store the remaining path in the
    // buffer and fill in the structure.
    //
    remoteNameLen = wcslen(pRemoteName);
    remainingPathLen = wcslen(pRemainingPath);

    sizeRequired = sizeof(REMOTE_NAME_INFOW) +
                   ((remoteNameLen + remainingPathLen + 2) *
                   sizeof(WCHAR));

    if (*lpBufferSize < sizeRequired) {
        *lpBufferSize = sizeRequired;
        return(WN_MORE_DATA);
    }
    else {
        pRemoteNameInfo->lpUniversalName  = NULL;
        pRemoteNameInfo->lpConnectionName = pRemoteName;
        pRemoteNameInfo->lpRemainingPath  = pRemoteName+remoteNameLen+sizeof(WCHAR);
        wcscpy(pRemoteNameInfo->lpRemainingPath, pRemainingPath);
    }
    return(WN_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\winnet\userdir.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    userdir.cxx

Abstract:

    This file contains the API entry points for the following functions:

        WNetGetUserW
        WNetGetDirectoryTypeW
        WNetDirectoryNotifyW
        WNetGetHomeDirectoryW

Author:

    Dan Lafferty (danl) 17-Oct-1991

Environment:

    User Mode - Win32

Revision History:

    05-May-1999     jschwart
        Make provider addition/removal dynamic

    12-Jul-1995 anirudhs
        Add WNetGetHomeDirectory.

    17-Jun-1994 danl
        WNetGetDirectoryTypeW:  Cache the drive letter and provider index
        to make file manager faster.

    27-May-1994 danl
        WNetGetDirectoryTypeW & WNetDirectoryNotifyW:  If no provider
        claims the connection in question, then we try all providers.
        The actual rule is that we need to pass it to the lanman
        provider anyway (so it can check for a share).  But to play
        completely fair, we'll pass it to everyone.

    28-Aug-1992 danl
        When GetUsername returns the name, it didn't handle the case where
        the buffer was too small.  (This may have been a bug in GetUserName).
        Now this code copies it into a temp buffer (MAX_PATH) and determines
        the size.

    03-Aug-1992 danl
        WNetGetUser now calls GetUsername when the device name parameter
        is NULL.

    17-Oct-1991 danl
        Created


--*/
//
// INCLUDES
//

#include "precomp.hxx"

//
// DEFINES
//



DWORD
WNetGetUserW (
    IN      LPCWSTR  lpName,
    OUT     LPWSTR   lpUserName,
    IN OUT  LPDWORD  lpBufferSize
    )

/*++

Routine Description:

    Returns the user name that is associated with making a particular
    connection.  If no connection is specified, the current username
    for the process is returned.

Arguments:

    lpName - This is a pointer to a device name string.  If NULL, the
        username for the current user of this process is returned.

    lpUserName - This is a pointer to the buffer that will receive the
        username string.

    lpBufferSize - This is the size (in characters) of the buffer that
        will receive the username.

Return Value:


Note:


--*/
{
    DWORD       status = WN_SUCCESS;
    DWORD       indexArray[DEFAULT_MAX_PROVIDERS];
    LPDWORD     index = indexArray;
    DWORD       numProviders;
    DWORD       statusFlag = 0;       // used to indicate major error types
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       i;
    WCHAR       pDriveLetter[4];
    UINT        uDriveType;
    DWORD       providerIndex;    // ignored

    //
    // If the device or network name is NULL then we 
    // will return the name of the current user.
    //
    __try
    {
        if (IS_EMPTY_STRING(lpName)) {

            //
            // GetUserName modifies *lpBufferSize on success -- we don't
            //
            DWORD dwTempSize = *lpBufferSize;

            lpName = NULL;

            if (!GetUserName(lpUserName, &dwTempSize))
            {
                status = GetLastError();
                MPR_LOG(ERROR,"WNetGetUserW: GetUserName Failed %d\n",status);
                if (status == ERROR_INSUFFICIENT_BUFFER)
                {
                    *lpBufferSize = dwTempSize;
                    status = WN_MORE_DATA;
                }
            }
        }
        else {

            //
            // As long as we're already in a try-except block,
            // try setting up the check to see if lpName is
            // a local drive.
            //
            pDriveLetter[0] = lpName[0];
            pDriveLetter[1] = lpName[1];
        }
    }
    __except(MPR_EXCEPTION_FILTER) {

        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetGetUser:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (lpName == NULL || status != WN_SUCCESS) {
        goto CleanExit;
    }

    pDriveLetter[2] = L'\\';
    pDriveLetter[3] = L'\0';

    uDriveType = GetDriveType(pDriveLetter);

    //
    // Eliminate all cases of drives that aren't connected to
    // a network resource.  Note that network provider names
    // and UNC shares return DRIVE_NO_ROOT_DIR, so we need to
    // make sure it's a valid drive name in that case.
    //
    if (uDriveType == DRIVE_REMOVABLE ||
        uDriveType == DRIVE_FIXED     ||
        uDriveType == DRIVE_CDROM     ||
        uDriveType == DRIVE_RAMDISK   ||
        (uDriveType == DRIVE_NO_ROOT_DIR && pDriveLetter[1] == L':'))

    {
        status = WN_NOT_CONNECTED;
        goto CleanExit;
    }

    {
        MprCheckProviders();

        CProviderSharedLock    PLock;

        //
        // If the device or network name is the name of a network
        // provider, then we will return the name of the current user.
        // Only a Level 1 init is needed for MprGetProviderIndex
        //
        if (!(GlobalInitLevel & FIRST_LEVEL)) {
            status = MprLevel1Init();
            if (status != WN_SUCCESS) {
                return(status);
            }
        }

        if (MprGetProviderIndex(lpName, &providerIndex))
        {
            lpName = NULL;

            if (!GetUserName(lpUserName, lpBufferSize))
            {
                status = GetLastError();
                MPR_LOG(ERROR,"WNetGetUserW: GetUserName Failed %d\n",status);
                if (status == ERROR_INSUFFICIENT_BUFFER)
                {
                    status = WN_MORE_DATA;
                }
            }
        }

        if (lpName == NULL || status != WN_SUCCESS) {
            goto CleanExit;
        }

        //
        // Find the list of providers to call for this request.
        // If there are no active providers, MprFindCallOrder returns
        // WN_NO_NETWORK.
        //
        INIT_IF_NECESSARY(NETWORK_LEVEL,status);

        status = MprFindCallOrder(
                    NULL,
                    &index,
                    &numProviders,
                    NETWORK_TYPE);

        if (status != WN_SUCCESS) {
            goto CleanExit;
        }

        //
        // if none of them are started, return error
        //
        if (!MprNetIsAvailable())
        {
            status = WN_NO_NETWORK;
            goto CleanExit;
        }

        //
        // Loop through the list of providers until one answers the request,
        // or the list is exhausted.
        //
        for (i=0; i<numProviders; i++) {

            //
            // Call the appropriate providers API entry point
            //
            LPPROVIDER provider = &GlobalProviderInfo[ index[i] ];

            if (provider->GetUser != NULL) {

                fcnSupported = TRUE;

                __try {
                    status = provider->GetUser(
                                (LPWSTR) lpName,
                                lpUserName,
                                lpBufferSize);
                }
                __except(MPR_EXCEPTION_FILTER) {
                    status = GetExceptionCode();
                    if (status != EXCEPTION_ACCESS_VIOLATION) {
                        MPR_LOG(ERROR,"WNetGetUser:Unexpected Exception 0x%lx\n",status);
                    }
                    status = WN_BAD_POINTER;
                }

                //
                // WN_CONNECTED_OTHER_PASSWORD_DEFAULT will be returned when user X mapped a
                // drive as user Y and the credentials for user Y were stored in CredMan when
                // the connection was made.  Since the username is correctly filled in with
                // user Y in this case, simply massage the return code to success.
                //

                if (status == WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
                {
                    status = WN_SUCCESS;
                }

                if (status == WN_NO_NETWORK) {
                    statusFlag |= NO_NET;
                }
                else if ((status == WN_NOT_CONNECTED)  ||
                         (status == WN_BAD_LOCALNAME)){

                    statusFlag |= BAD_NAME;
                }
                else {
                    //
                    // If it wasn't one of those errors, then the provider
                    // must have accepted responsibility for the request.
                    // so we exit and process the results.  Note that the
                    // statusFlag is cleared because we want to ignore other
                    // error information that we gathered up until now.
                    //
                    statusFlag = 0;
                    break;
                }
            }
        }
    }

    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // Handle special errors.
    //
    if (statusFlag == (NO_NET | BAD_NAME)) {
        //
        // Check to see if there was a mix of special errors that occured.
        // If so, pass back the combined error message.  Otherwise, let the
        // last error returned get passed back.
        //
        status = WN_NO_NET_OR_BAD_PATH;
    }

CleanExit:
    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (index != indexArray) {
        LocalFree(index);
    }

    if (status != WN_SUCCESS){
        SetLastError(status);
    }

    return(status);
}


DWORD
WNetGetDirectoryTypeW (
    IN  LPTSTR  lpName,
    OUT LPINT   lpType,
    IN  BOOL    bFlushCache
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD       status = WN_SUCCESS;
    LPDWORD     index;
    DWORD       indexArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders = 0;
    DWORD       providerIndex;
    DWORD       statusFlag = 0; // used to indicate major error types
    WCHAR       lpDriveName[4];
    UINT        uDriveType;

    index = indexArray;

    //
    // Probe the drive letter portion of the lpName.
    //
    __try {

        lpDriveName[0] = lpName[0];
        lpDriveName[1] = lpName[1];
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetGetDirectoryType:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS) {
        return(status);
    }

    lpDriveName[2] = L'\\';
    lpDriveName[3] = L'\0';

    uDriveType = GetDriveType(lpDriveName);

    if (uDriveType == DRIVE_REMOVABLE ||
        uDriveType == DRIVE_FIXED     ||
        uDriveType == DRIVE_CDROM     ||
        uDriveType == DRIVE_RAMDISK)
    {
        *lpType = 0;        // 0 means a non-network drive
        return WN_SUCCESS;
    }

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    //
    // Find the Provider Index associated with the drive letter in
    // the pathname (lpszName).
    // NOTE:  This function handles exceptions.
    //

    status = MprFindProviderForPath(lpName, &providerIndex);
    if (status != WN_SUCCESS) {
        MPR_LOG1(ERROR,"WNetGetDirectoryType: Couldn't find provider for this "
            "path.  Error = %d\n",status);

        //
        // Find the list of providers to call for this request.
        // Since no provider claimed this path, then
        // we need to at least try the lanman provider.
        // Actually we'll give them all a chance.
        //

        status = MprFindCallOrder(
                    NULL,
                    &index,
                    &numProviders,
                    NETWORK_TYPE);

        if (status != WN_SUCCESS) {
            return(status);
        }
    }
    else {
        numProviders = 1;
        index[0] = providerIndex;
    }

    //
    // Loop through the list of providers until one answers the request,
    // or the list is exhausted.
    //
    BOOL    fcnSupported = FALSE; // Is fcn supported by a provider?
    for (DWORD i=0; i<numProviders; i++) {
        //
        // Call the appropriate provider's API entry point
        //
        LPPROVIDER provider = &GlobalProviderInfo[ index[i] ];

        if (provider->GetDirectoryType != NULL) {

            fcnSupported = TRUE;

            __try {
                status = provider->GetDirectoryType(
                            lpName,
                            lpType,
                            bFlushCache) ;
            }

            __except(MPR_EXCEPTION_FILTER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetGetDirectoryType:Unexpected Exception 0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }
            if (status == WN_NO_NETWORK) {
                statusFlag |= NO_NET;
            }
            else if ((status == WN_NOT_CONNECTED)  ||
                     (status == WN_BAD_LOCALNAME)){

                statusFlag |= BAD_NAME;
            }
            else {
                //
                // If it wasn't one of those errors, then the provider
                // must have accepted responsibility for the request.
                // so we exit and process the results.  Note that the
                // statusFlag is cleared because we want to ignore other
                // error information that we gathered up until now.
                //
                statusFlag = 0;
                break;
            }
        }
    }
    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (index != indexArray) {
        LocalFree(index);
    }

    //
    // Handle special errors.
    //
    if (statusFlag == (NO_NET | BAD_NAME)) {
        //
        // Check to see if there was a mix of special errors that occured.
        // If so, pass back the combined error message.  Otherwise, let the
        // last error returned get passed back.
        //
        status = WN_NO_NET_OR_BAD_PATH;
    }

    if (status != WN_SUCCESS){
        SetLastError(status);
    }

    return(status);
}


DWORD
WNetDirectoryNotifyW (
    IN  HWND    hwnd,
    IN  LPTSTR  lpDir,
    IN  DWORD   dwOper
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD       providerIndex;
    DWORD       status;
    LPDWORD     index;
    DWORD       indexArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders;
    LPPROVIDER  provider;
    DWORD       statusFlag = 0; // used to indicate major error types
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       i;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    index = indexArray;

    //
    // Find the Provider Index associated with the drive letter in
    // the pathname (lpszName).
    // NOTE:  This function handles exceptions.
    //
    status = MprFindProviderForPath(lpDir, &providerIndex);
    if (status != WN_SUCCESS) {
        MPR_LOG1(TRACE,"WNetDirectoryNotify: Couldn't find provider for this "
            "path.  Error = %d\n",status);

        //
        // Find the list of providers to call for this request.
        // Since no provider claimed this path, then
        // we need to at least try the lanman provider.
        // Actually we'll give them all a chance.
        //

        status = MprFindCallOrder(
                    NULL,
                    &index,
                    &numProviders,
                    NETWORK_TYPE);

        if (status != WN_SUCCESS) {
            MPR_LOG(ERROR,"WNetDirectoryNotifyW: FindCallOrder Failed\n",0);
            return(status);
        }
    }
    else {
        numProviders = 1;
        index[0] = providerIndex;
    }

    //
    // Loop through the list of providers until one answers the request,
    // or the list is exhausted.
    //
    for (i=0; i<numProviders; i++) {
        //
        // Call the appropriate provider's API entry point
        //
        provider = GlobalProviderInfo + index[i];

        if (provider->DirectoryNotify != NULL) {

            fcnSupported = TRUE;

            __try {
                status = provider->DirectoryNotify(
                            hwnd,
                            lpDir,
                            dwOper);
            }
            __except(MPR_EXCEPTION_FILTER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetDirectoryNotify:Unexpected Exception 0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }
            if (status == WN_NO_NETWORK) {
                statusFlag |= NO_NET;
            }
            else if ((status == WN_NOT_CONNECTED)  ||
                     (status == WN_BAD_LOCALNAME)){

                statusFlag |= BAD_NAME;
            }
            else {
                //
                // If it wasn't one of those errors, then the provider
                // must have accepted responsibility for the request.
                // so we exit and process the results.  Note that the
                // statusFlag is cleared because we want to ignore other
                // error information that we gathered up until now.
                //
                statusFlag = 0;
                break;
            }
        }
    }
    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (index != indexArray) {
        LocalFree(index);
    }

    //
    // Handle special errors.
    //
    if (statusFlag == (NO_NET | BAD_NAME)) {
        //
        // Check to see if there was a mix of special errors that occured.
        // If so, pass back the combined error message.  Otherwise, let the
        // last error returned get passed back.
        //
        status = WN_NO_NET_OR_BAD_PATH;
    }

    //
    // Handle normal errors passed back from the provider
    //
    if (status != WN_SUCCESS){
        MPR_LOG(TRACE,"WNetDirectoryNotifyW: Call Failed %d\n",status);
        SetLastError(status);
    }

    return(status);
}


DWORD
WNetGetHomeDirectoryW (
    IN      LPCWSTR  lpProviderName,
    OUT     LPWSTR   lpDirectory,
    IN OUT  LPDWORD  lpBufferSize
    )

/*++

Routine Description:

    Returns the user's home directory.

Arguments:

    lpProviderName - Specifies the name of the network provider for which the
        home directory is retrieved.  This parameter exists for Win95 compati-
        bility, and is ignored.

    lpDirectory - Buffer in which to return the directory path.  This will be
        in either UNC or drive-relative form.

    lpBufferSize - Specifies the size of the lpDirectory buffer, in characters.
        If the call fails because the buffer is not big enough, this will be
        set to the required buffer size.

Return Value:

    WN_SUCCESS - successful

    WN_MORE_DATA - buffer not large enough

    WN_NOT_SUPPORTED - user doesn't have a home directory

Note:

    This is an unpublished function, so it doesn't catch exceptions.

    The path is obtained from environment variables and equals
        %HOMESHARE%%HOMEPATH% if the %HOMESHARE% variable is set, else
        %HOMEDIR%%HOMEPATH% .

--*/
{
    //
    // If HOMESHARE is set, use it in preference to HOMEDRIVE
    //
    LPWSTR  ExpandString = L"%HOMEDRIVE%%HOMEPATH%";
    if (GetEnvironmentVariable(L"HOMESHARE", NULL, 0))
    {
        ExpandString = L"%HOMESHARE%%HOMEPATH%";
    }

    //
    // Expand the environment variables into the buffer
    //
    DWORD cchReturned = ExpandEnvironmentStrings(
                                ExpandString,
                                lpDirectory,
                                *lpBufferSize
                                );

    if (cchReturned == 0)
    {
        // ExpandEnvironmentStrings failed
        return GetLastError();
    }

    if (cchReturned > *lpBufferSize)
    {
        // Buffer too small; cchReturned is the required size
        *lpBufferSize = cchReturned;
        return WN_MORE_DATA;
    }

    //
    // Fail if HOMEDRIVE or HOMEPATH is not set - detected by the result
    // string beginning with %HOMEDRIVE% or ending with %HOMEPATH%
    //
    if (wcsncmp(lpDirectory, L"%HOMEPATH%", sizeof("%HOMEPATH%") - 1) == 0 ||
        (cchReturned > sizeof("%HOMEPATH%") &&
         wcscmp(&lpDirectory[cchReturned-sizeof("%HOMEPATH%")], L"%HOMEPATH%") == 0))
    {
        return WN_NOT_SUPPORTED;
    }

    return WN_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\mib\util.h ===
//
//  Copyright (c) 1991  Microsoft Corporation
//

#ifndef util_h
#define util_h

//-------------------------- MODULE DESCRIPTION ----------------------------
//
//  util.h
//
//---------------------------------------------------------------------------
//
//  Declarations, constants, and prototypes for SNMP utility functions.
//
//---------------------------------------------------------------------------

//--------------------------- VERSION INFO ----------------------------------

static char *util__h = "@(#) $Logfile:   N:/agent/common/vcs/util.h_v  $ $Revision:   1.5  $";

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define SNMP_MAX_OID_LEN     0x7f00 // Max number of elements in obj id


//--------------------------- PUBLIC STRUCTS --------------------------------

#include <winsock.h>

typedef SOCKET SockDesc;


//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

//--------------------------- PUBLIC PROTOTYPES -----------------------------

//
// Debugging functions
//

#define DBGCONSOLEBASEDLOG   0x1
#define DBGFILEBASEDLOG      0x2
#define DBGEVENTLOGBASEDLOG  0x4

VOID dbgprintf(
        IN INT nLevel,
        IN LPSTR szFormat,
        IN ...
        );

//
// Internal OID routines
//

void SNMP_oiddisp(
        IN AsnObjectIdentifier *Oid // OID to display
	);

//
// Buffer manipulation
//

void SNMP_bufrev(
        IN OUT BYTE *szStr, // Buffer to reverse
	IN UINT nLen        // Length of buffer
	);

void SNMP_bufcpyrev(
        OUT BYTE *szDest,  // Destination buffer
	IN BYTE *szSource, // Source buffer
	IN UINT nLen       // Length of buffers
	);

//------------------------------- END ---------------------------------------

#endif /* util_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\mib\winsmib.c ===
//
// TODO: Make it multithreaded
//

/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    winsmib.c

Abstract:

    Sample SNMP Extension Agent for Windows NT.

    These files (testdll.c, winsmib.c, and winsmib.h) provide an example of
    how to structure an Extension Agent DLL which works in conjunction with
    the SNMP Extendible Agent for Windows NT.

    Extensive comments have been included to describe its structure and
    operation.  See also "Microsoft Windows/NT SNMP Programmer's Reference".

Created:

    7-Oct-1991

Revision History:

--*/


#ifdef UNICODE
#undef UNICODE
#endif

// This Extension Agent implements the Internet toaster MIB.  It's
// definition follows here:
//
//

// Necessary includes.

#include "wins.h"
#include <malloc.h>

#include <snmp.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <search.h>
#include <winsock2.h>
#include "nmsdb.h"
//#include "winsif.h"
#include "winsintf.h"
#include "winscnf.h"
#include "nmsmsgf.h"


// Contains definitions for the table structure describing the MIB.  This
// is used in conjunction with winsmib.c where the MIB requests are resolved.

#include "winsmib.h"


// If an addition or deletion to the MIB is necessary, there are several
// places in the code that must be checked and possibly changed.
//
// The last field in each MIB entry is used to point to the NEXT
// leaf variable.  If an addition or deletetion is made, these pointers
// may need to be updated to reflect the modification.

#define _WINS_CNF_KEY         TEXT("System\\CurrentControlSet\\Services\\Wins")
#define _WINS_PARAMETERS_KEY       TEXT("Parameters")
#define _WINS_PARTNERS_KEY         TEXT("Partners")
#define _WINS_DATAFILES_KEY        TEXT("Datafiles")
#define _WINS_PULL_KEY             TEXT("Pull")
#define _WINS_PUSH_KEY             TEXT("Push")

#define NO_FLDS_IN_PULLADD_KEY      8  //Flds are ip add, time interval, sp time
#define NO_FLDS_IN_PUSHADD_KEY      2  //Flds are ip add, update count
#define NO_FLDS_IN_DR               5  //Flds in a data record

#define LOCAL_ADD                     "127.0.0.1"
#define WINSMIB_FILE_INFO_SIZE         255

#define WINSMIB_DR_CACHE_TIME        (120)                //2 minutes
BOOL  fWinsMibWinsKeyOpen           = FALSE;

HKEY  WinsMibWinsKey;

STATIC HKEY  sParametersKey;
STATIC HKEY  sPartnersKey;
STATIC HKEY  sPullKey;
STATIC HKEY  sPushKey;
STATIC HKEY  sDatafilesKey;

STATIC BOOL  sfParametersKeyOpen = FALSE;
STATIC BOOL  sfPartnersKeyOpen   = FALSE;
STATIC BOOL  sfDatafilesKeyOpen  = FALSE;
STATIC BOOL  sfPullKeyOpen       = FALSE;
STATIC BOOL  sfPushKeyOpen       = FALSE;

STATIC time_t  sDRCacheInitTime = 0;

//
// The prefix to all of the WINS MIB variables is 1.3.6.1.4.1.311.1.2
//
// The last digit -- 2 is for the WINS MIB
//

UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 311, 1 , 2};
AsnObjectIdentifier MIB_OidPrefix = { OID_SIZEOF(OID_Prefix), OID_Prefix };
BOOL        fWinsMibWinsStatusCnfCalled;
BOOL        fWinsMibWinsStatusStatCalled;

WINSINTF_BIND_DATA_T        sBindData;
WINSINTF_RECS_T                sRecs = {0};



//
// Definition of the Wins MIB  (not used)
//

//UINT MIB_Wins[]  = { 2 };

//
// OID definitions for MIB
//

//
// Definition of group and leaf variables under the wins group
// All leaf variables have a zero appended to their OID to indicate
// that it is the only instance of this variable and it exists.
//

UINT MIB_Parameters[]                        = { 1 };
UINT MIB_WinsStartTime[]                     = { 1, 1, 0 };
UINT MIB_LastPScvTime[]                        = { 1, 2, 0 };
UINT MIB_LastATScvTime[]                = { 1, 3, 0 };
UINT MIB_LastTombScvTime[]                = { 1, 4, 0 };
UINT MIB_LastVerifyScvTime[]                = { 1, 5, 0 };
UINT MIB_LastPRplTime[]                        = { 1, 6, 0 };
UINT MIB_LastATRplTime[]                = { 1, 7, 0 };
UINT MIB_LastNTRplTime[]                = { 1, 8, 0 };
UINT MIB_LastACTRplTime[]                = { 1, 9, 0 };
UINT MIB_LastInitDbTime[]                = { 1, 10, 0 };
UINT MIB_LastCounterResetTime[]                = { 1, 11, 0 };
UINT MIB_WinsTotalNoOfReg[]             = { 1, 12, 0 };
UINT MIB_WinsTotalNoOfQueries[]         = { 1, 13, 0 };
UINT MIB_WinsTotalNoOfRel[]             = { 1, 14, 0 };
UINT MIB_WinsTotalNoOfSuccRel[]         = { 1, 15, 0 };
UINT MIB_WinsTotalNoOfFailRel[]         = { 1, 16, 0 };
UINT MIB_WinsTotalNoOfSuccQueries[]         = { 1, 17, 0 };
UINT MIB_WinsTotalNoOfFailQueries[]         = { 1, 18, 0 };
UINT MIB_RefreshInterval[]                 = { 1, 19, 0 };
UINT MIB_TombstoneInterval[]                 = { 1, 20, 0 };
UINT MIB_TombstoneTimeout[]                 = { 1, 21, 0 };
UINT MIB_VerifyInterval[]                 = { 1, 22, 0 };
UINT MIB_VersCounterStartVal_LowWord[]        = { 1, 23, 0 };
UINT MIB_VersCounterStartVal_HighWord[] = { 1, 24, 0 };
UINT MIB_RplOnlyWCnfPnrs[]                 = { 1, 25, 0 };
UINT MIB_StaticDataInit[]                 = { 1, 26, 0 };
UINT MIB_LogFlag[]                          = { 1, 27, 0 };
UINT MIB_LogFileName[]                        = { 1, 28, 0 };
UINT MIB_BackupDirPath[]                = { 1, 29, 0 };
UINT MIB_DoBackupOnTerm[]                = { 1, 30, 0 };
UINT MIB_MigrateOn[]                        = { 1, 31, 0 };

//
// Pull mib vars
//
UINT MIB_Pull[]                                = { 2 };
UINT MIB_PullInitTime[]                        = { 2, 1, 0 };
UINT MIB_CommRetryCount[]                = { 2, 2, 0 };
UINT MIB_PullPnrTable[]                        = { 2, 3};
UINT MIB_PullPnrTableEntry[]                = { 2, 3, 1};

//
// Push mib vars
//
UINT MIB_Push[]                                = { 3 };
UINT MIB_PushInitTime[]                        = { 3, 1, 0 };
UINT MIB_RplOnAddChg[]                         = { 3, 2, 0 };
UINT MIB_PushPnrTable[]                        = { 3, 3};
UINT MIB_PushPnrTableEntry[]                = { 3, 3, 1};


//
// Datafile mib vars
//
UINT MIB_Datafiles[]                        = { 4 };
UINT MIB_DatafilesTable[]                = { 4 , 1};
UINT MIB_DatafilesTableEntry[]                = { 4 , 1, 1};

//
// Cmd mib Vars
UINT MIB_Cmd[]                                = { 5 };
UINT MIB_PullTrigger[]                        = { 5, 1, 0};
UINT MIB_PushTrigger[]                        = { 5, 2, 0};
UINT MIB_DeleteWins[]                        = { 5, 3, 0};
UINT MIB_DoScavenging[]                        = { 5, 4, 0};
UINT MIB_DoStaticInit[]                        = { 5, 5, 0};
UINT MIB_NoOfWrkThds[]                        = { 5, 6, 0};
UINT MIB_PriorityClass[]                = { 5, 7, 0};
UINT MIB_ResetCounters[]                = { 5, 8, 0};
UINT MIB_DeleteDbRecs[]                        = { 5, 9, 0};
UINT MIB_GetDbRecs[]                        = { 5, 10, 0};
UINT MIB_DbRecsTable[]                        = { 5, 11};
UINT MIB_DbRecsTableEntry[]                = { 5, 11, 1};
UINT MIB_MaxVersNo_LowWord[]                 = { 5, 12, 0 };
UINT MIB_MaxVersNo_HighWord[]                 = { 5, 13, 0 };

//
//                             //
// Storage definitions for MIB //
//                             //

// Parameters group
char       MIB_WinsStartTimeStore[80];
char MIB_LastPScvTimeStore[80];
char MIB_LastATScvTimeStore[80];
char MIB_LastTombScvTimeStore[80];
char MIB_LastVerifyScvTimeStore[80];
char MIB_LastPRplTimeStore[80];
char MIB_LastATRplTimeStore[80];
char MIB_LastNTRplTimeStore[80];
char MIB_LastACTRplTimeStore[80];
char MIB_LastInitDbTimeStore[80];
char MIB_LastCounterResetTimeStore[80];

AsnCounter MIB_WinsTotalNoOfRegStore                             = 0;
AsnCounter MIB_WinsTotalNoOfQueriesStore                  = 0;
AsnCounter MIB_WinsTotalNoOfRelStore                      = 0;
AsnCounter MIB_WinsTotalNoOfSuccRelStore                  = 0;
AsnCounter MIB_WinsTotalNoOfFailRelStore                  = 0;
AsnCounter MIB_WinsTotalNoOfSuccQueriesStore            = 0;
AsnCounter MIB_WinsTotalNoOfFailQueriesStore            = 0;
AsnInteger MIB_RefreshIntervalStore                          = 0;
AsnInteger MIB_TombstoneIntervalStore                        = 0;
AsnInteger MIB_TombstoneTimeoutStore                         = 0;
AsnInteger MIB_VerifyIntervalStore                           = 0;
AsnCounter MIB_VersCounterStartVal_HighWordStore        = 0;
AsnCounter MIB_VersCounterStartVal_LowWordStore         = 0;
AsnInteger MIB_RplOnlyWCnfPnrsStore                          = 0;
AsnInteger MIB_StaticDataInitStore                          = 0;
AsnInteger MIB_LogFlagStore                                  = 1;

char MIB_LogFileNameStore[256];

char       MIB_BackupDirPathStore[256];
AsnInteger MIB_DoBackupOnTermStore                        = 0;
AsnInteger MIB_MigrateOnStore                                = 0;

//Pull
AsnInteger MIB_PullInitTimeStore        = 1 ;
AsnInteger MIB_CommRetryCountStore        = 0 ;

//PullPnr
char MIB_SpTimeStore[256];
AsnInteger MIB_TimeIntervalStore        = 0 ;
AsnInteger MIB_MemberPrecStore                = 0 ;

//Push
AsnInteger MIB_RplOnAddChgStore         = 0;

//PushPnr
AsnInteger MIB_PushInitTimeStore        = 0 ;
AsnInteger MIB_UpdateCountStore                = 0 ;

//
// Cmd
//
char                MIB_PullTriggerStore[10];   // double the size to store the old value in case of failure
char                MIB_PushTriggerStore[10];   // double the size to store the old value in case of failure
char                MIB_DeleteWinsStore[10];
AsnInteger        MIB_DoScavengingStore;
char                MIB_DoStaticInitStore[WINSMIB_FILE_INFO_SIZE] = {EOS};
AsnInteger        MIB_NoOfWrkThdsStore;
AsnInteger        MIB_PriorityClassStore;
AsnInteger        MIB_ResetCountersStore;
char                MIB_DeleteDbRecsStore[10];
char                MIB_GetDbRecsStore[5] = {0};
AsnInteger         MIB_MaxVersNo_LowWordStore;
AsnInteger         MIB_MaxVersNo_HighWordStore;

CRITICAL_SECTION WinsMibCrtSec;

//
// Value Id.
//
// NOTE NOTE NOTE:  The sequence must be the same as in VarInfo[]
//
typedef enum _VAL_ID_E {

//values for the Parameters Key
                REF_INTVL_E = 0,
                TOMB_INTVL_E,
                TOMB_TMOUT_E,
                VER_INTVL_E,
                VERS_COUNT_LW_E,
                VERS_COUNT_HW_E,
                RPL_ONLY_W_CNF_PNRS_E,
                STATIC_DATA_INIT_E,
                LOG_FLAG_E,
                LOG_FILE_NAME_E,
                BACKUP_DIR_PATH_E,
                DO_BACKUP_ON_TERM_E,
                MIGRATE_ON_E,

//values for the Pull Key
                COMM_RETRY_E,
                PULL_INIT_TIME_E,

//values for pnrs under the pull key
                SP_TIME_E,
                TIME_INTVL_E,
                MEMBER_PREC_E,

//values for the Push Key
                PUSH_INIT_TIME_E,

//values for pnrs under the push key
                RPL_ON_ADD_CHG_E,
                UPD_CNT_E


                } VAL_ID_E, *PVAL_ID_E;


//
// Holds information about partners (pull/push) used for accessing the
// Pull and Push partner tables
//
typedef struct _ADD_KEY_T {
        BYTE        asIpAddress[20];
        DWORD        IpAdd;
        BYTE        asSpTime[20];
        BOOL        fSpTimeSet;
        union {
                DWORD TimeInterval;
                DWORD UpdateCount;
             };
        BOOL  fTimeIntOrUpdCntSet;
        DWORD        MemberPrec;
        DWORD        NoOfRpls;
        DWORD        NoOfCommFails;
        WINSINTF_VERS_NO_T        VersNo;
                } ADD_KEY_T, *PADD_KEY_T;


typedef struct _DATAFILE_INFO_T {
        TCHAR        FileNm[WINSMIB_FILE_INFO_SIZE];
        DWORD   StrType;
        TCHAR   ValNm[10];
                } DATAFILE_INFO_T, *PDATAFILE_INFO_T;


#define DATAFILE_INFO_SZ        sizeof(DATAFILE_INFO_T)

//
// holds info about variable used when accessing registry.
//
typedef struct _VAR_INFO_T {
        LPDWORD                pId;                //Oid under WINS
        LPBYTE                pName;
        LPVOID                 pStorage;
        VAL_ID_E        Val_Id_e;
        DWORD                ValType;
        DWORD                SizeOfData;
        HKEY                *pRootKey;
        } VARINFO_T, *PVARINFO_T;

//
// This array comprises of stuff that needs to be read from/written to
// the registry.
//
VARINFO_T VarInfo[] = {
                        {
                          &MIB_RefreshInterval[1],
                          { WINSCNF_REFRESH_INTVL_NM },
                          &MIB_RefreshIntervalStore,
                          REF_INTVL_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_TombstoneInterval[1],
                          WINSCNF_TOMBSTONE_INTVL_NM,
                          &MIB_TombstoneIntervalStore,
                          TOMB_INTVL_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_TombstoneTimeout[1],
                          WINSCNF_TOMBSTONE_TMOUT_NM,
                          &MIB_TombstoneTimeoutStore,
                          TOMB_TMOUT_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_VerifyInterval[1],
                          WINSCNF_VERIFY_INTVL_NM,
                          &MIB_VerifyIntervalStore,
                          VER_INTVL_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_VersCounterStartVal_LowWord[1],
                          WINSCNF_INIT_VERSNO_VAL_LW_NM,
                          &MIB_VersCounterStartVal_LowWordStore,
                          VERS_COUNT_LW_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_VersCounterStartVal_HighWord[1],
                          WINSCNF_INIT_VERSNO_VAL_HW_NM,
                          &MIB_VersCounterStartVal_HighWordStore,
                          VERS_COUNT_HW_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_RplOnlyWCnfPnrs[1],
                          WINSCNF_RPL_ONLY_W_CNF_PNRS_NM,
                          &MIB_RplOnlyWCnfPnrsStore,
                          RPL_ONLY_W_CNF_PNRS_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_StaticDataInit[1],
                          WINSCNF_STATIC_INIT_FLAG_NM,
                          &MIB_StaticDataInitStore,
                          STATIC_DATA_INIT_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_LogFlag[1],
                          WINSCNF_LOG_FLAG_NM,
                          &MIB_LogFlagStore,
                          LOG_FLAG_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_LogFileName[1],
                          WINSCNF_LOG_FILE_PATH_NM,
                          &MIB_LogFileNameStore,
                          LOG_FILE_NAME_E,
                          REG_EXPAND_SZ,
                          sizeof(MIB_LogFileNameStore),
                          &sParametersKey
                        },
                        {
                          &MIB_BackupDirPath[1],
                          WINSCNF_BACKUP_DIR_PATH_NM,
                          &MIB_BackupDirPathStore,
                          BACKUP_DIR_PATH_E,
                          REG_EXPAND_SZ,
                          sizeof(MIB_BackupDirPathStore),
                          &sParametersKey
                        },
                        {
                          &MIB_DoBackupOnTerm[1],
                          WINSCNF_DO_BACKUP_ON_TERM_NM,
                          &MIB_DoBackupOnTermStore,
                          DO_BACKUP_ON_TERM_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_MigrateOn[1],
                          WINSCNF_MIGRATION_ON_NM,
                          &MIB_MigrateOnStore,
                          MIGRATE_ON_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },

                        {
                          &MIB_CommRetryCount[1],
                          WINSCNF_RETRY_COUNT_NM,
                          &MIB_CommRetryCountStore,
                          COMM_RETRY_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sPullKey
                        },
                        {
                          &MIB_PullInitTime[1],
                          WINSCNF_INIT_TIME_RPL_NM,
                          &MIB_PullInitTimeStore,
                          PULL_INIT_TIME_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sPullKey
                        },
                        {
                          NULL, //&MIB_SpTime[1]
                          WINSCNF_SP_TIME_NM,
                          &MIB_SpTimeStore,
                          SP_TIME_E,
                          REG_SZ,
                          sizeof(MIB_SpTimeStore),
                          &sPullKey
                        },

                        {
                          NULL, //&MIB_TimeInterval[1]
                          WINSCNF_RPL_INTERVAL_NM,
                          &MIB_TimeIntervalStore,
                          TIME_INTVL_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sPullKey
                        },
                        {
                          NULL,
                          WINSCNF_MEMBER_PREC_NM,
                          &MIB_MemberPrecStore,
                          MEMBER_PREC_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sPullKey
                        },
                        {
                          &MIB_PushInitTime[1],
                          WINSCNF_INIT_TIME_RPL_NM,
                          &MIB_PushInitTimeStore,
                          PUSH_INIT_TIME_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sPushKey
                        },
                        {
                          &MIB_RplOnAddChg[1],
                          WINSCNF_ADDCHG_TRIGGER_NM,
                          &MIB_RplOnAddChgStore,
                          RPL_ON_ADD_CHG_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sPushKey
                        },
                        {
                          NULL, //&MIB_UpdateCount[1]
                          WINSCNF_UPDATE_COUNT_NM,
                          &MIB_UpdateCountStore,
                          UPD_CNT_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sPushKey
                        }
        };

//
// Type of key
//
typedef enum _KEY_TYPE_E {
        PARAMETERS_E_KEY,
        PARTNERS_E_KEY,
        DATAFILES_E_KEY,
        PULL_E_KEY,
        PUSH_E_KEY,
        IPADD_E_KEY
        } KEY_TYPE_E, *PKEY_TYPE_E;

//
// Determines if the MIB variable falls in the range requiring access to the
// the registry
//
#define PARAMETERS_VAL_M(pMib)                (  \
                ((pMib)->Oid.ids[0] == 1)  \
                        &&                   \
                ((pMib)->Oid.ids[1] >= 19) \
                        &&                   \
                ((pMib)->Oid.ids[1] <= 31) \
                                )

//
// All MIB variables in the common group have 1 as their first id
//
#define COMMON_VAL_M(pMib)         ((pMib)->Oid.ids[0] == 1)

//
// All MIB variables in the common group have 2 as their first id
//
#define PULL_VAL_M(pMib)         ((pMib)->Oid.ids[0] == 2)

//
// All MIB variables in the common group have 3 as their first id
//
#define PUSH_VAL_M(pMib)         ((pMib)->Oid.ids[0] == 3)

//
//  Finds the enumerator corresponding to the registry parameter
//
#define PARAMETERS_ID_M(pMib, Val_Id_e) { \
if(pMib->Storage==&MIB_RefreshIntervalStore) { Val_Id_e = REF_INTVL_E; }else{\
if(pMib->Storage==&MIB_TombstoneIntervalStore){ Val_Id_e=TOMB_INTVL_E;}else{\
if(pMib->Storage==&MIB_TombstoneTimeoutStore) { Val_Id_e=TOMB_TMOUT_E; }else{\
if(pMib->Storage==&MIB_VerifyIntervalStore) { Val_Id_e = VER_INTVL_E; } else{\
if (pMib->Storage==&MIB_VersCounterStartVal_LowWordStore) { Val_Id_e = VERS_COUNT_LW_E; } else{ \
  if (pMib->Storage == &MIB_VersCounterStartVal_HighWordStore) { Val_Id_e = VERS_COUNT_HW_E; } else{ \
  if (pMib->Storage == &MIB_RplOnlyWCnfPnrsStore) { Val_Id_e = RPL_ONLY_W_CNF_PNRS_E; } else {\
  if (pMib->Storage == &MIB_StaticDataInitStore) { Val_Id_e = STATIC_DATA_INIT_E; } else {\
  if (pMib->Storage == &MIB_LogFlagStore)     { Val_Id_e = LOG_FLAG_E; } else {\
  if (pMib->Storage == &MIB_LogFileNameStore) { Val_Id_e = LOG_FILE_NAME_E; } else {\
  if (pMib->Storage == &MIB_BackupDirPathStore) { Val_Id_e = BACKUP_DIR_PATH_E; } else {\
  if (pMib->Storage == &MIB_DoBackupOnTermStore) { Val_Id_e = DO_BACKUP_ON_TERM_E; } else {\
  if (pMib->Storage == &MIB_MigrateOnStore) { Val_Id_e = MIGRATE_ON_E; } else {\
  }}}}}}}}}}}}}}

//
//  Finds the enumerator corresponding to the pull group's parameter
//
#define PULL_ID_M(pMib, Val_Id_e) { \
  if (pMib->Storage == &MIB_CommRetryCountStore) { Val_Id_e = COMM_RETRY_E; }else{\
  if (pMib->Storage == &MIB_PullInitTimeStore) { Val_Id_e = PULL_INIT_TIME_E;} else{\
 }}}

//
//  Finds the enumerator corresponding to the push group's parameter
//
#define PUSH_ID_M(pMib, Val_Id_e) { \
  if (pMib->Storage == &MIB_RplOnAddChgStore) { Val_Id_e = RPL_ON_ADD_CHG_E;} else{\
  if (pMib->Storage == &MIB_PushInitTimeStore) { Val_Id_e = PUSH_INIT_TIME_E;}else{ \
 }}}

STATIC
UINT
HandleCmd(
        IN UINT           Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
        );
STATIC
UINT
ExecuteCmd(
  IN PMIB_ENTRY pMibPtr
        );

STATIC
UINT
MIB_RWReg(
        IN UINT           Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
        );

STATIC
UINT
PullPnrs(
        IN UINT Action,
        IN PMIB_ENTRY pMibPtr,
        IN RFC1157VarBind *VarBind
        );

STATIC
UINT
PushPnrs(
        IN UINT Action,
        IN PMIB_ENTRY pMibPtr,
        IN RFC1157VarBind *VarBind
        );
STATIC
UINT
MIB_Table(
        IN DWORD           Index,
        IN UINT            Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind,
        IN KEY_TYPE_E           KeyType_e
        );

STATIC
UINT
MIB_PullTable(
        IN UINT           Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
                );
STATIC
UINT
MIB_PushTable(
        IN UINT           Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
                );
STATIC
UINT
MIB_DFTable(
        IN UINT           Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
                );

STATIC
UINT
MIB_DRTable(
        IN UINT           Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
);

STATIC
UINT
WriteDFValue(
        IN RFC1157VarBind         *pVarBind,
        PDATAFILE_INFO_T          pDFKey,
        DWORD                         Index
        );

STATIC
UINT
MIB_leaf_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN RFC1157VarBind *VarBind
        );


STATIC
UINT
MIB_Stat(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN RFC1157VarBind *VarBind
        );
//
// MIB definiton
//

MIB_ENTRY Mib[] = {
//parameters
      { { OID_SIZEOF(MIB_Parameters), MIB_Parameters },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_NOACCESS, NULL, &Mib[1] },

      { { OID_SIZEOF(MIB_WinsStartTime), MIB_WinsStartTime },
        &MIB_WinsStartTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[2] },

      { { OID_SIZEOF(MIB_LastPScvTime), MIB_LastPScvTime },
        &MIB_LastPScvTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[3] },

      { { OID_SIZEOF(MIB_LastATScvTime), MIB_LastATScvTime },
        &MIB_LastATScvTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[4] },

      { { OID_SIZEOF(MIB_LastTombScvTime), MIB_LastTombScvTime },
        &MIB_LastTombScvTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[5] },

      { { OID_SIZEOF(MIB_LastVerifyScvTime), MIB_LastVerifyScvTime },
        &MIB_LastVerifyScvTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[6] },

      { { OID_SIZEOF(MIB_LastPRplTime), MIB_LastPRplTime },
        &MIB_LastPRplTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[7] },

      { { OID_SIZEOF(MIB_LastATRplTime), MIB_LastATRplTime },
        &MIB_LastATRplTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[8] },

      { { OID_SIZEOF(MIB_LastNTRplTime), MIB_LastNTRplTime },
        &MIB_LastNTRplTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[9] },

      { { OID_SIZEOF(MIB_LastACTRplTime), MIB_LastACTRplTime },
        &MIB_LastACTRplTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[10] },

      { { OID_SIZEOF(MIB_LastInitDbTime), MIB_LastInitDbTime },
        &MIB_LastInitDbTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[11] },

      { { OID_SIZEOF(MIB_LastCounterResetTime), MIB_LastCounterResetTime },
        &MIB_LastCounterResetTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[12] },

      { { OID_SIZEOF(MIB_WinsTotalNoOfReg), MIB_WinsTotalNoOfReg },
        &MIB_WinsTotalNoOfRegStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[13] },

      { { OID_SIZEOF(MIB_WinsTotalNoOfQueries), MIB_WinsTotalNoOfQueries },
        &MIB_WinsTotalNoOfQueriesStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[14] },

      { { OID_SIZEOF(MIB_WinsTotalNoOfRel), MIB_WinsTotalNoOfRel },
        &MIB_WinsTotalNoOfRelStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[15] },

      { { OID_SIZEOF(MIB_WinsTotalNoOfSuccRel), MIB_WinsTotalNoOfSuccRel },
        &MIB_WinsTotalNoOfSuccRelStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[16] },

      { { OID_SIZEOF(MIB_WinsTotalNoOfFailRel), MIB_WinsTotalNoOfFailRel },
        &MIB_WinsTotalNoOfFailRelStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[17] },

      { { OID_SIZEOF(MIB_WinsTotalNoOfSuccQueries),
                                  MIB_WinsTotalNoOfSuccQueries },
        &MIB_WinsTotalNoOfSuccQueriesStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[18] },

      { { OID_SIZEOF(MIB_WinsTotalNoOfFailQueries),
                                   MIB_WinsTotalNoOfFailQueries },
        &MIB_WinsTotalNoOfFailQueriesStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[19] },

      { { OID_SIZEOF(MIB_RefreshInterval), MIB_RefreshInterval },
        &MIB_RefreshIntervalStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[20] },

      { { OID_SIZEOF(MIB_TombstoneInterval), MIB_TombstoneInterval },
        &MIB_TombstoneIntervalStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[21] },

      { { OID_SIZEOF(MIB_TombstoneTimeout), MIB_TombstoneTimeout },
        &MIB_TombstoneTimeoutStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[22] },

      { { OID_SIZEOF(MIB_VerifyInterval), MIB_VerifyInterval },
        &MIB_VerifyIntervalStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[23] },

      { { OID_SIZEOF(MIB_VersCounterStartVal_LowWord),
                        MIB_VersCounterStartVal_LowWord },
        &MIB_VersCounterStartVal_LowWordStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[24] },

      { { OID_SIZEOF(MIB_VersCounterStartVal_HighWord),
                        MIB_VersCounterStartVal_HighWord },
        &MIB_VersCounterStartVal_HighWordStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[25] },

      { { OID_SIZEOF(MIB_RplOnlyWCnfPnrs),  MIB_RplOnlyWCnfPnrs },
        &MIB_RplOnlyWCnfPnrsStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[26] },

      { { OID_SIZEOF(MIB_StaticDataInit),  MIB_StaticDataInit },
        &MIB_StaticDataInitStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[27] },


      { { OID_SIZEOF(MIB_LogFlag), MIB_LogFlag },
        &MIB_LogFlagStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[28] },

      { { OID_SIZEOF(MIB_LogFileName), MIB_LogFileName },
        &MIB_LogFileNameStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[29] },

      { { OID_SIZEOF(MIB_BackupDirPath), MIB_BackupDirPath },
        &MIB_BackupDirPathStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[30] },

      { { OID_SIZEOF(MIB_DoBackupOnTerm), MIB_DoBackupOnTerm },
        &MIB_DoBackupOnTermStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[31] },

      { { OID_SIZEOF(MIB_MigrateOn), MIB_MigrateOn },
        &MIB_MigrateOnStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[32] },

//
// Pull
//
      { { OID_SIZEOF(MIB_Pull), MIB_Pull },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_NOACCESS, NULL, &Mib[33] },

      { { OID_SIZEOF(MIB_PullInitTime), MIB_PullInitTime },
        &MIB_PullInitTimeStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[34] },

      { { OID_SIZEOF(MIB_CommRetryCount), MIB_CommRetryCount },
        &MIB_CommRetryCountStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[35] },

      { { OID_SIZEOF(MIB_PullPnrTable), MIB_PullPnrTable },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_ACCESS_READWRITE, NULL, &Mib[36] },

      { { OID_SIZEOF(MIB_PullPnrTableEntry), MIB_PullPnrTableEntry },
        NULL, ASN_SEQUENCE,
        MIB_ACCESS_READWRITE, MIB_PullTable, &Mib[37] },

//
// Push
//
      { { OID_SIZEOF(MIB_Push), MIB_Push },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_NOACCESS, NULL, &Mib[38] },


      { { OID_SIZEOF(MIB_PushInitTime), MIB_PushInitTime },
        &MIB_PushInitTimeStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[39] },

      { { OID_SIZEOF(MIB_RplOnAddChg),
                        MIB_RplOnAddChg },
        &MIB_RplOnAddChgStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[40] },

      { { OID_SIZEOF(MIB_PushPnrTable), MIB_PushPnrTable },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_ACCESS_READWRITE, NULL, &Mib[41] },

      { { OID_SIZEOF(MIB_PushPnrTableEntry), MIB_PushPnrTableEntry },
        NULL, ASN_SEQUENCE,
        MIB_ACCESS_READWRITE, MIB_PushTable, &Mib[42] },

//
// Datafiles
//
      { { OID_SIZEOF(MIB_Datafiles), MIB_Datafiles },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_NOACCESS, NULL, &Mib[43] },

      { { OID_SIZEOF(MIB_DatafilesTable), MIB_DatafilesTable },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_ACCESS_READWRITE, NULL, &Mib[44] },

      { { OID_SIZEOF(MIB_DatafilesTableEntry), MIB_DatafilesTableEntry },
        NULL, ASN_SEQUENCE,
        MIB_ACCESS_READWRITE, MIB_DFTable, &Mib[45] },

//
// Cmds
//
      { { OID_SIZEOF(MIB_Cmd), MIB_Cmd },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_NOACCESS, NULL, &Mib[46] },

      { { OID_SIZEOF(MIB_PullTrigger), MIB_PullTrigger },
        &MIB_PullTriggerStore, ASN_RFC1155_IPADDRESS,
        MIB_ACCESS_READWRITE, HandleCmd, &Mib[47] },

      { { OID_SIZEOF(MIB_PushTrigger), MIB_PushTrigger },
        &MIB_PushTriggerStore, ASN_RFC1155_IPADDRESS,
        MIB_ACCESS_READWRITE, HandleCmd, &Mib[48] },

      // NOTE: The following command was changed from READWRITE
      // to READ only due to security reason.
      // Anyone with access to SNMP agent, could delete
      // the wins database with this sigle command.
      { { OID_SIZEOF(MIB_DeleteWins), MIB_DeleteWins },
        &MIB_DeleteWinsStore, ASN_RFC1155_IPADDRESS,
        MIB_ACCESS_READ, HandleCmd, &Mib[49] },

      { { OID_SIZEOF(MIB_DoScavenging), MIB_DoScavenging },
        &MIB_DoScavengingStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, HandleCmd, &Mib[50] },

      { { OID_SIZEOF(MIB_DoStaticInit), MIB_DoStaticInit },
        &MIB_DoStaticInitStore, ASN_OCTETSTRING,
        MIB_ACCESS_READWRITE, HandleCmd, &Mib[51] },

      { { OID_SIZEOF(MIB_NoOfWrkThds), MIB_NoOfWrkThds },
        &MIB_NoOfWrkThdsStore, ASN_INTEGER,
        MIB_ACCESS_READ, HandleCmd, &Mib[52] },

      { { OID_SIZEOF(MIB_PriorityClass), MIB_PriorityClass},
        &MIB_PriorityClassStore, ASN_INTEGER,
        MIB_ACCESS_READ, HandleCmd, &Mib[53] },

      { { OID_SIZEOF(MIB_ResetCounters), MIB_ResetCounters},
        &MIB_ResetCountersStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, HandleCmd, &Mib[54] },

      { { OID_SIZEOF(MIB_DeleteDbRecs), MIB_DeleteDbRecs},
        &MIB_DeleteDbRecsStore, ASN_RFC1155_IPADDRESS,
        MIB_ACCESS_READWRITE, HandleCmd, &Mib[55] },

      { { OID_SIZEOF(MIB_GetDbRecs), MIB_GetDbRecs},
        &MIB_GetDbRecsStore, ASN_RFC1155_IPADDRESS,
        MIB_ACCESS_READWRITE, HandleCmd, &Mib[56] },

      { { OID_SIZEOF(MIB_DbRecsTable), MIB_DbRecsTable },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_ACCESS_READWRITE, NULL, &Mib[57] },

      { { OID_SIZEOF(MIB_DbRecsTableEntry), MIB_DbRecsTableEntry },
        NULL, ASN_SEQUENCE,
        MIB_ACCESS_READWRITE, MIB_DRTable, &Mib[58] },

      { { OID_SIZEOF(MIB_MaxVersNo_LowWord), MIB_MaxVersNo_LowWord },
        &MIB_MaxVersNo_LowWordStore, ASN_INTEGER,
        MIB_ACCESS_READ, HandleCmd, &Mib[59] },

      { { OID_SIZEOF(MIB_MaxVersNo_HighWord), MIB_MaxVersNo_HighWord },
        &MIB_MaxVersNo_HighWordStore, ASN_INTEGER,
        MIB_ACCESS_READ, HandleCmd, NULL }
      };


//
//  defines pertaining to tables
//
#define PNR_OIDLEN                 (MIB_PREFIX_LEN + OID_SIZEOF(MIB_PullPnrTableEntry))
#define PULLPNR_OIDLEN                PNR_OIDLEN
#define PUSHPNR_OIDLEN                PNR_OIDLEN
#define DR_OIDLEN                 (MIB_PREFIX_LEN + OID_SIZEOF(MIB_DbRecsTableEntry))
#define DF_OIDLEN                 (MIB_PREFIX_LEN + OID_SIZEOF(MIB_DatafilesTableEntry))

#define PULL_TABLE_INDEX        0
#define PUSH_TABLE_INDEX        1
#define DF_TABLE_INDEX                2
#define DR_TABLE_INDEX                3
#define NUM_TABLES                sizeof(Tables)/sizeof(TAB_INFO_T)

UINT MIB_num_variables = sizeof Mib / sizeof( MIB_ENTRY );

//
// table structure containing the functions to invoke for different actions
// on the table
//
typedef struct _TAB_INFO_T {
        UINT (*ti_get)(
                RFC1157VarBind *VarBind,
                DWORD                NoOfKeys,
                LPVOID                pKey
                     );
        UINT (*ti_getf)(
                RFC1157VarBind *VarBind,
                PMIB_ENTRY        pMibEntry,
                KEY_TYPE_E        KeyType_e
                     );
        UINT (*ti_getn)(
                RFC1157VarBind *VarBind,
                PMIB_ENTRY        pMibEntry,
                KEY_TYPE_E        KeyType_e
                    );
        UINT (*ti_set)(
                RFC1157VarBind *VarBind
                    );

        PMIB_ENTRY pMibPtr;
        } TAB_INFO_T, *PTAB_INFO_T;



STATIC
UINT
WriteReg(
        PMIB_ENTRY pMib
        );
STATIC
UINT
ReadReg(
        PMIB_ENTRY pMib
        );
STATIC
UINT
SetVal(
        PVARINFO_T        pVarInfo
);

STATIC
UINT
GetVal(
        PVARINFO_T        pVarInfo
);


STATIC
UINT
OpenKey(
        KEY_TYPE_E        Key_e,
        LPBYTE                pKeyStr,
        HKEY                *ptrNewKey,
        HKEY                *pRootKey,
        BOOL                fCreateAllowed
);

STATIC
UINT
OpenReqKey(
        PMIB_ENTRY  pMib,
        PVAL_ID_E  pVal_Id_e,
        BOOL           fCreateAllowed
);

STATIC
UINT
CloseReqKey(
        VOID
        );

STATIC
UINT
GetKeyInfo(
        IN  HKEY                   Key,
        OUT LPDWORD                  pNoOfSubKeys,
        OUT LPDWORD                pNoOfVals
        );


STATIC
UINT
PnrGetNext(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY          pMibPtr,
       IN KEY_TYPE_E         KeyType_e
        );


STATIC
UINT
PullGet(
       IN RFC1157VarBind *VarBind,
       IN DWORD          NumKeys,
       IN LPVOID         pAddKey
);

STATIC
UINT
PushGet(
       IN RFC1157VarBind *VarBind,
       IN DWORD          NumKeys,
       IN LPVOID         pAddKey
);

STATIC
UINT
PnrGetFirst(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY         pMibPtr,
       IN KEY_TYPE_E         KeyType_e
        );
STATIC
UINT
PullSet(
       IN RFC1157VarBind *VarBind
);

STATIC
UINT
PushSet(
       IN RFC1157VarBind *VarBind
);

STATIC
UINT
PnrMatch(
       IN RFC1157VarBind *VarBind,
       DWORD                 NoOfKeys,
       IN PADD_KEY_T         pAddKey,
       IN LPDWORD         pIndex,
       IN LPDWORD         pField,
       IN KEY_TYPE_E         KeyType_e,
       IN UINT                 PduAction,
       IN LPBOOL        pfFirst
        );

extern
UINT
PnrFindNext(
        INT           AddKeyNo,
        DWORD           NumAddKeys,
        PADD_KEY_T pAddKey
        );
STATIC
UINT
EnumAddKeys(
             KEY_TYPE_E        KeyType_e,
        PADD_KEY_T        *ppAddKey,
        LPDWORD                pNumAddKeys
          );
STATIC
UINT
EnumDataFileKeys(
        PDATAFILE_INFO_T        *ppDFValues,
        LPDWORD                        pNumDFValues
          );
STATIC
UINT
DFSet(
       IN RFC1157VarBind *VarBind
);

STATIC
UINT
DFGet(
       IN RFC1157VarBind                  *VarBind,
       IN DWORD                           NumValues,
       IN LPVOID                          pKey
    );

STATIC
UINT
DFGetFirst(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY        pMibPtr,
       IN KEY_TYPE_E        KeyType_e
        );
STATIC
UINT
DFGetNext(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY          pMibPtr,
       IN KEY_TYPE_E         KeyType_e
          );
STATIC
DWORD
PopulateDRCache(
        VOID
        );
STATIC
UINT
DRGetNext(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY          pMibPtr,
       IN KEY_TYPE_E         KeyType_e
        );

STATIC
UINT
DRMatch(
       IN RFC1157VarBind *VarBind,
       IN PWINSINTF_RECORD_ACTION_T         *ppRow,
       IN LPDWORD         pIndex,
       IN LPDWORD         pField,
       IN UINT                 PduAction,
       OUT LPBOOL         pfFirst
        );

STATIC
int
__cdecl
CompareIndexes(
        const VOID *pKey1,
        const VOID *pKey2
        );

STATIC
int
__cdecl
CompareNames(
        const VOID *pKey1,
        const VOID *pKey2
        );
// NOTE:
//
// Info passed for 2nd and 3rd param is different from other table's GET
// functions
//
STATIC
UINT
DRGet(
       IN RFC1157VarBind *VarBind,
       IN DWORD          FieldParam,
       IN LPVOID         pRowParam
);

STATIC
UINT
DRGetFirst(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY        pMibPtr,
       IN KEY_TYPE_E        KeyType_e
        );
STATIC
UINT
DRSet(
       IN RFC1157VarBind *VarBind
);

STATIC
UINT
WriteKeyNValues(
        KEY_TYPE_E        KeyType_e,
        PADD_KEY_T        pAddKey,
        DWORD                FieldNo
        );
STATIC
VOID
GetSpTimeData(
        HKEY                  SubKey,
        PADD_KEY_T          pAddKey
);

STATIC
int
__cdecl
CompareAdd(
        const VOID *pKey1,
        const VOID *pKey2
        );

STATIC
UINT
GetNextVar(
        IN RFC1157VarBind *pVarBind,
        IN PMIB_ENTRY          pMibPtr
);

TAB_INFO_T Tables[] = {
                {
                        PullGet,
                        PnrGetFirst,
                        PnrGetNext,
                        PullSet,
                        &Mib[36]
                },
                {
                        PushGet,
                        PnrGetFirst,
                        PnrGetNext,
                        PushSet,
                        &Mib[41]
                },
                {

                        DFGet,
                        DFGetFirst,
                        DFGetNext,
                        DFSet,
                        &Mib[44]
                },
                {

                        DRGet,
                        DRGetFirst,
                        DRGetNext,
                        DRSet,
                        &Mib[57]
                }
        };



UINT
ResolveVarBind(
        IN OUT RFC1157VarBind *VarBind, // Variable Binding to resolve
        IN UINT PduAction               // Action specified in PDU
        )
//
// ResolveVarBind
//    Resolves a single variable binding.  Modifies the variable on a GET
//    or a GET-NEXT.
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
{
   MIB_ENTRY            *MibPtr;
   AsnObjectIdentifier  TempOid;
   int                  CompResult;
   UINT                 I;
   UINT                 nResult;
   DWORD TableIndex;
   BOOL  fTableMatch = FALSE;

//    SNMPDBG ((SNMP_LOG_TRACE,
//              "WINSMIB: Entering ResolveVarBind.\n"));

   // initialize MibPtr to NULL. When this becomes not null, it means we found a match (table or scalar)
   MibPtr = NULL;

   //
   // Check the Tables array
   //
   // See if the prefix of the variable matches the prefix of
   // any of the tables
   //
   for (TableIndex = 0; TableIndex < NUM_TABLES; TableIndex++)
   {
        //
           // Construct OID with complete prefix for comparison purposes
        //
           SNMP_oidcpy( &TempOid, &MIB_OidPrefix );
           if (TempOid.ids == NULL)
           {
                nResult = SNMP_ERRORSTATUS_GENERR;
                goto Exit;
           }
           SNMP_oidappend( &TempOid,  &Tables[TableIndex].pMibPtr->Oid );

        //
        // is there a match with the prefix oid of a table entry
        //
        if (
                SnmpUtilOidNCmp(
                            &VarBind->name,
                             &TempOid,
                             MIB_PREFIX_LEN +
                                Tables[TableIndex].pMibPtr->Oid.idLength
                               )  == 0
           )
        {

                //
                // the prefix string of the var. matched the oid
                // of a table.
                //
                MibPtr = Tables[TableIndex].pMibPtr;
                fTableMatch = TRUE;
                break;
        }

           // Free OID memory before checking with another table entry
           SNMP_oidfree( &TempOid );
   }
   //
   // There was an exact match with a table entry's prefix.
   //
   if ( fTableMatch)
   {

        if (
                (SnmpUtilOidCmp(
                        &VarBind->name,
                        &TempOid
                               ) == 0)
           )
           {
           //
           // The oid specified is a prefix of a table entry. if the operation
           // is not GETNEXT, return NOSUCHNAME
           //
           if (PduAction != MIB_GETNEXT)
           {
                           SNMP_oidfree( &TempOid );
                             nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
                              goto Exit;
           }
           else
           {
                UINT           TableEntryIds[1];
                AsnObjectIdentifier TableEntryOid = {
                                OID_SIZEOF(TableEntryIds), TableEntryIds };
                //
                // Replace var bind name with new name
                //

                //
                // A sequence item oid always starts with a field no.
                // The first item has a field no of 1.
                //
                TableEntryIds[0] = 1;
                SNMP_oidappend( &VarBind->name, &TableEntryOid);

                //
                // Get the first entry in the table
                //
                PduAction = MIB_GETFIRST;
           }
        }
           SNMP_oidfree( &TempOid );
        //
        //  if there was no exact match with a prefix entry, then we
        //  don't touch the PduAction value specified.
        //
   }
   else
   {

      //
      // There was no match with any table entry.  Let us see if there is
      // a match with a group entry, a table, or a leaf variable
      //

      //
      // Search for var bind name in the MIB
      //
      I      = 0;
      while ( MibPtr == NULL && I < MIB_num_variables )
      {

         //
         // Construct OID with complete prefix for comparison purposes
         //
         SNMP_oidcpy( &TempOid, &MIB_OidPrefix );
         SNMP_oidappend( &TempOid, &Mib[I].Oid );

         //
         //Check for OID in MIB - On a GET-NEXT the OID does not have to exactly
         // match a variable in the MIB, it must only fall under the MIB root.
         //
         CompResult = SNMP_oidcmp( &VarBind->name, &TempOid );

        //
        // If CompResult is negative, the only valid operation is GET_NEXT
        //
        if (  CompResult  < 0)
        {

                //
                // This could be the oid of a leaf (without a 0)
                // or it could be  an invalid oid (in between two valid oids)
                // The next oid might be that of a group or a table or table
                // entry.  In that case, we do not change the PduAction
                //
                if (PduAction == MIB_GETNEXT)
                {
                       MibPtr = &Mib[I];
                             SNMP_oidfree( &VarBind->name );
                       SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
                       SNMP_oidappend( &VarBind->name, &MibPtr->Oid );
                       if (MibPtr->Type != ASN_RFC1155_OPAQUE)
                       {
                           PduAction = (MibPtr->Type == ASN_SEQUENCE)? MIB_GETFIRST : MIB_GET;
                       }
                }
                else
                {
                  nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
                        SNMP_oidfree( &TempOid );
                  goto Exit;
                }

                      SNMP_oidfree( &TempOid );
                break;
      }
      else
      {
         //
         // An exact match was found ( a group, table, or leaf).
         //
         if ( CompResult == 0)
         {
            MibPtr = &Mib[I];
         }
      }

      //
      // Free OID memory before checking another variable
      //
      SNMP_oidfree( &TempOid );
      I++;
    } // while
   } // end of else

   //
   // if there was a match
   //
   if (MibPtr != NULL)
   {

//        SNMPDBG ((SNMP_LOG_TRACE,
//              "WINSMIB: Found MibPtr.\n"));
        //
        // the function will be NULL only if the match was with a group
        // or a sequence (table). If the match was with a table entry
        // (entire VarBind string match or partial string match), we
        // function would be a table function
        //
        if (MibPtr->MibFunc == NULL)
        {
                if(PduAction != MIB_GETNEXT)
                {
                              nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
                              goto Exit;
                }
                else
                {
                        //
                        // Get the next variable which allows access
                        //
                         nResult = GetNextVar(VarBind, MibPtr);
                        goto Exit;
                }
        }
   }
   else
   {
              nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
              goto Exit;
   }

//   SNMPDBG ((SNMP_LOG_TRACE,
//              "WINSMIB: Diving in OID handler.\n"));
   //
   // Call function to process request.  Each MIB entry has a function pointer
   // that knows how to process its MIB variable.
   //
   nResult = (*MibPtr->MibFunc)( PduAction, MibPtr, VarBind );

Exit:
   return nResult;
} // ResolveVarBind

//
// MIB_leaf_func
//    Performs generic actions on LEAF variables in the MIB.
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
UINT MIB_leaf_func(
        IN UINT            Action,
        IN MIB_ENTRY            *MibPtr,
        IN RFC1157VarBind  *VarBind
        )

{
   UINT   ErrStat;

   switch ( Action )
   {
      case MIB_GETNEXT:
         //
         // If there is no GET-NEXT pointer, this is the end of this MIB
         //
         if ( MibPtr->MibNext == NULL )
         {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
         }
         ErrStat = GetNextVar(VarBind, MibPtr);
         if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
         {
                goto Exit;
         }
         break;

      case MIB_GETFIRST: // fall through
      case MIB_GET:

         // Make sure that this variable's ACCESS is GET'able
         if ( MibPtr->Access != MIB_ACCESS_READ &&
              MibPtr->Access != MIB_ACCESS_READWRITE )
         {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
         }

         // Setup varbind's return value
         VarBind->value.asnType = MibPtr->Type;
         switch ( VarBind->value.asnType )
         {
            case ASN_RFC1155_COUNTER:
               VarBind->value.asnValue.number = *(AsnCounter *)(MibPtr->Storage);
               break;
            case ASN_RFC1155_GAUGE:
            case ASN_INTEGER:
               VarBind->value.asnValue.number = *(AsnInteger *)(MibPtr->Storage);
               break;

            case ASN_RFC1155_IPADDRESS:
                // continue as for ASN_OCTETSTRING

            case ASN_OCTETSTRING:
               if (VarBind->value.asnType == ASN_RFC1155_IPADDRESS)
               {
                               VarBind->value.asnValue.string.length = 4;
               }
               else
               {
                               VarBind->value.asnValue.string.length =
                                 strlen( (LPSTR)MibPtr->Storage );
               }

               if ( NULL ==
                    (VarBind->value.asnValue.string.stream =
                    SNMP_malloc(VarBind->value.asnValue.string.length *
                           sizeof(char))) )
               {
                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                  goto Exit;
               }

               memcpy( VarBind->value.asnValue.string.stream,
                       (LPSTR)MibPtr->Storage,
                       VarBind->value.asnValue.string.length );
               VarBind->value.asnValue.string.dynamic = TRUE;

               break;



            default:
               ErrStat = SNMP_ERRORSTATUS_GENERR;
               goto Exit;
         }

         break;

      case MIB_SET:

         // Make sure that this variable's ACCESS is SET'able
         if ( MibPtr->Access != MIB_ACCESS_READWRITE &&
              MibPtr->Access != MIB_ACCESS_WRITE )
         {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
         }

         // Check for proper type before setting
         if ( MibPtr->Type != VarBind->value.asnType )
         {
            ErrStat = SNMP_ERRORSTATUS_BADVALUE;
            goto Exit;
         }

         // Save value in MIB
         switch ( VarBind->value.asnType )
         {
            case ASN_RFC1155_COUNTER:
               *(AsnCounter *)(MibPtr->Storage) = VarBind->value.asnValue.number;
               break;
            case ASN_RFC1155_GAUGE:
            case ASN_INTEGER:
               *(AsnInteger *)(MibPtr->Storage) = VarBind->value.asnValue.number;
               break;

            case ASN_RFC1155_IPADDRESS:
               if (MibPtr->Storage == &MIB_PullTriggerStore ||
                   MibPtr->Storage == &MIB_PushTriggerStore ||
                   MibPtr->Storage == &MIB_DeleteDbRecsStore ||
                   MibPtr->Storage == &MIB_DeleteWinsStore)
               {
                   int backupSize = (MibPtr->Storage == &MIB_PullTriggerStore) ?
                                    sizeof(MIB_PullTriggerStore)/2 :
                                    sizeof(MIB_PushTriggerStore)/2 ;
                   // those variables are ASN_RFC1155_IPADDRESS
                   // their old values have to be stored as the WinsTrigger() might fail
                   // in which case the old values will be restored
                   // each of these variables has 10 octets, the payload being of 5 octets.
                   // the last 5 = for backup
                   memcpy( (LPSTR)MibPtr->Storage + backupSize, (LPSTR)MibPtr->Storage, backupSize);
               }

            case ASN_OCTETSTRING:
               // The storage must be adequate to contain the new string
               // including a NULL terminator.
               memcpy( (LPSTR)MibPtr->Storage,
                       VarBind->value.asnValue.string.stream,
                       VarBind->value.asnValue.string.length );

               ((LPSTR)MibPtr->Storage)[VarBind->value.asnValue.string.length] =
                                                                          '\0';
#if 0
               if ( VarBind->value.asnValue.string.dynamic)
               {
                  SNMP_free( VarBind->value.asnValue.string.stream);
               }
#endif
               break;

            default:
               ErrStat = SNMP_ERRORSTATUS_GENERR;
               goto Exit;
            }

         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
         goto Exit;
      } // switch

   // Signal no error occurred
   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_leaf_func


#define TMST(x)        sResults.WinsStat.TimeStamps.x.wHour,\
                sResults.WinsStat.TimeStamps.x.wMinute,\
                sResults.WinsStat.TimeStamps.x.wSecond,\
                sResults.WinsStat.TimeStamps.x.wMonth,\
                sResults.WinsStat.TimeStamps.x.wDay,\
                sResults.WinsStat.TimeStamps.x.wYear

#define PRINTTIME(Var, x)      sprintf(Var, "%02u:%02u:%02u on %02u:%02u:%04u.\n", TMST(x))

static  WINSINTF_RESULTS_T        sResults;

//
// MIB_Stat
//    Performs specific actions on the different MIB variable
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
UINT MIB_Stat(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
        )

{
//WINSINTF_RESULTS_T        Results;
DWORD                        Status;
UINT                           ErrStat;
handle_t                BindHdl;


   switch ( Action )
   {
      case MIB_SET:
                   ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
                break;
      case MIB_GETNEXT:
                   ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
                break;

      case MIB_GETFIRST:
#if 0
                //
                // If it is an OPAQUE type (i.e. aggregate)
                //
                if (MibPtr->Type == ASN_RFC1155_OPAQUE)
                {
                      ErrStat = MIB_leaf_func( MIB_GETNEXT, MibPtr, VarBind );
                   break;
                }
#endif

                //
                // fall through
                //
      case MIB_GET:

        if (!fWinsMibWinsStatusStatCalled)
        {
          //
          // Call the WinsStatus function to get the statistics
          //
          BindHdl = WinsBind(&sBindData);
          sResults.WinsStat.NoOfPnrs = 0;
          sResults.WinsStat.pRplPnrs = NULL;
          if ((Status = WinsStatus(BindHdl, WINSINTF_E_STAT, &sResults)) !=
                                        WINSINTF_SUCCESS)
          {
             SNMPDBG((
                SNMP_LOG_ERROR,
                "WINSMIB: Error from WinsStatus = (%d).\n",
                Status
                ));
             WinsFreeMem(sResults.WinsStat.pRplPnrs);
             ErrStat = SNMP_ERRORSTATUS_GENERR;
             goto Exit;
          }
          else
          {
            fWinsMibWinsStatusStatCalled = TRUE;
          }
          WinsFreeMem(sResults.WinsStat.pRplPnrs);
          WinsUnbind(&sBindData, BindHdl);
        }

        if (MibPtr->Storage  == &MIB_WinsStartTimeStore)
        {
                PRINTTIME(MIB_WinsStartTimeStore, WinsStartTime);
                goto LEAF1;
        }

        if (MibPtr->Storage  == &MIB_LastPScvTimeStore)
        {
                PRINTTIME(MIB_LastPScvTimeStore, LastPScvTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastATScvTimeStore)
        {
                PRINTTIME(MIB_LastATScvTimeStore, LastATScvTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastTombScvTimeStore)
        {
                PRINTTIME(MIB_LastTombScvTimeStore, LastTombScvTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastVerifyScvTimeStore)
        {
                PRINTTIME(MIB_LastVerifyScvTimeStore, LastVerifyScvTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastPRplTimeStore)
        {
                PRINTTIME(MIB_LastPRplTimeStore, LastPRplTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastATRplTimeStore)
        {
                PRINTTIME(MIB_LastATRplTimeStore, LastATRplTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastNTRplTimeStore)
        {
                PRINTTIME(MIB_LastNTRplTimeStore, LastNTRplTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastACTRplTimeStore)
        {
                PRINTTIME(MIB_LastACTRplTimeStore, LastACTRplTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastInitDbTimeStore)
        {
                PRINTTIME(MIB_LastInitDbTimeStore, LastInitDbTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastCounterResetTimeStore)
        {
                PRINTTIME(MIB_LastCounterResetTimeStore, CounterResetTime);
                goto LEAF1;
        }

        if (MibPtr->Storage == &MIB_WinsTotalNoOfRegStore)
        {
                MIB_WinsTotalNoOfRegStore =
                        sResults.WinsStat.Counters.NoOfUniqueReg +
                                sResults.WinsStat.Counters.NoOfGroupReg;
                goto LEAF1;
        }

        if (MibPtr->Storage == &MIB_WinsTotalNoOfQueriesStore)
        {
                MIB_WinsTotalNoOfQueriesStore =
                        sResults.WinsStat.Counters.NoOfQueries;
                goto LEAF1;
        }

        if (MibPtr->Storage == &MIB_WinsTotalNoOfRelStore)
        {
                MIB_WinsTotalNoOfRelStore = sResults.WinsStat.Counters.NoOfRel;
                goto LEAF1;
        }

        if (MibPtr->Storage == &MIB_WinsTotalNoOfSuccRelStore)
        {
                MIB_WinsTotalNoOfSuccRelStore =
                        sResults.WinsStat.Counters.NoOfSuccRel;
                goto LEAF1;
        }
        if (MibPtr->Storage == &MIB_WinsTotalNoOfFailRelStore)
        {
                MIB_WinsTotalNoOfFailRelStore =
                        sResults.WinsStat.Counters.NoOfFailRel;
                goto LEAF1;
        }
        if (MibPtr->Storage == &MIB_WinsTotalNoOfSuccQueriesStore)
        {
                MIB_WinsTotalNoOfSuccQueriesStore =
                        sResults.WinsStat.Counters.NoOfSuccQueries;
                goto LEAF1;
         }
         if (MibPtr->Storage == &MIB_WinsTotalNoOfFailQueriesStore)
         {
                MIB_WinsTotalNoOfFailQueriesStore =
                        sResults.WinsStat.Counters.NoOfFailQueries;
        //        goto LEAF1;
         }

LEAF1:
         // Call the more generic function to perform the action
         ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );

         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
         goto Exit;
      } // switch

Exit:
   return ErrStat;
} // MIB_Stat



//
// MIB_RWReg
//    Performs specific actions on the different MIB variable
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
UINT MIB_RWReg(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN RFC1157VarBind *VarBind
        )

{
WINSINTF_RESULTS_T         Results;
DWORD                        Status;
UINT                           ErrStat = SNMP_ERRORSTATUS_NOERROR;
handle_t                BindHdl;

//   SNMPDBG ((SNMP_LOG_TRACE,
//              "WINSMIB: Entering MIB_RWReg.\n"));
        

   switch ( Action )
      {
      case MIB_SET:
                   if (MIB_leaf_func( Action, MibPtr, VarBind )
                        == SNMP_ERRORSTATUS_NOERROR)
                {
                        ErrStat = WriteReg(MibPtr);
                }
                break;

      case MIB_GETFIRST:
#if 0
                //
                // If it is an OPAQUE type (i.e. aggregate)
                //
                if (MibPtr->Type == ASN_RFC1155_OPAQUE)
                {
                      ErrStat = MIB_leaf_func( MIB_GETNEXT, MibPtr, VarBind );
                   break;
                }

#endif
                //
                // fall through
                //
      case MIB_GET:
        //
        // Call the WinsStatus function to get the statistics
        //
        if (
                (MibPtr->Storage  == &MIB_RefreshIntervalStore)
                        ||
                (MibPtr->Storage  == &MIB_TombstoneIntervalStore)
                        ||
                (MibPtr->Storage  == &MIB_TombstoneTimeoutStore)
                        ||
                (MibPtr->Storage  == &MIB_VerifyIntervalStore)

            )
        {

                   BindHdl = WinsBind(&sBindData);
                Results.WinsStat.NoOfPnrs = 0;
                Results.WinsStat.pRplPnrs = NULL;
                if ((Status = WinsStatus(BindHdl, WINSINTF_E_CONFIG, &Results))
                        == WINSINTF_SUCCESS)
                {
                        MIB_RefreshIntervalStore   = Results.RefreshInterval;
                        MIB_TombstoneIntervalStore = Results.TombstoneInterval;
                        MIB_TombstoneTimeoutStore  = Results.TombstoneTimeout;
                        MIB_VerifyIntervalStore    = Results.VerifyInterval;

                }
                 else
                 {
                           SNMPDBG((
                                SNMP_LOG_ERROR,
                                "WINSMIB: Error from WinsStatus = (%d).\n",
                                Status
                                ));
                           ErrStat = SNMP_ERRORSTATUS_GENERR;
                 }
                 WinsUnbind(&sBindData, BindHdl);
        }
        else
        {
                //
                // If a value could not be read
                // then the storage for the mib variable would have been
                // initialized to 0.
                //
                ErrStat = ReadReg(MibPtr);
        }
      //
      // fall through
      //
      case MIB_GETNEXT:

        //
        // Call the more generic function to perform the action
        //
        ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
        break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
         goto Exit;
      } // switch

Exit:
   return ErrStat;
} // MIB_RWReg


UINT
OpenReqKey(
        MIB_ENTRY *pMib,
        VAL_ID_E  *pVal_Id_e,
        BOOL           fCreateAllowed
        )


/*++

Routine Description:
        The function opens the required keys for the parameter indicated
        by the structure pointed to by pMib

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        UINT Status = SNMP_ERRORSTATUS_GENERR;

//        SNMPDBG ((SNMP_LOG_TRACE,
//              "WINSMIB: Entering OpenReqKey.\n"));

        //
        // if it is a parameter value, open the parameters key
        //
        if (PARAMETERS_VAL_M(pMib))
        {

                Status = OpenKey(PARAMETERS_E_KEY, NULL, NULL, NULL, fCreateAllowed);
                if (Status == SNMP_ERRORSTATUS_NOERROR)
                {
                //        sfParametersKeyOpen = TRUE;
                        PARAMETERS_ID_M(pMib, *pVal_Id_e);
                }

        }
        else
        {
                //
                //  if it is a Pull key value, open the partner and
                //  pull keys
                //
                if (PULL_VAL_M(pMib))
                {
                        Status = OpenKey(PARTNERS_E_KEY, NULL, NULL, NULL, fCreateAllowed);
                        if (Status == SNMP_ERRORSTATUS_NOERROR)
                        {
                                //sfPartnersKeyOpen = TRUE;
                                Status = OpenKey(PULL_E_KEY, NULL, NULL, NULL, fCreateAllowed);
                                if (Status == SNMP_ERRORSTATUS_NOERROR)
                                {
                                        PULL_ID_M(pMib, *pVal_Id_e);
                                }
                        }
                }
                else
                {
                   //
                   //  if it is a Push key value, open the partner and
                   //  pull keys
                   //
                   if (PUSH_VAL_M(pMib))
                   {
                        Status = OpenKey(PARTNERS_E_KEY, NULL, NULL, NULL, fCreateAllowed);
                        if (Status == SNMP_ERRORSTATUS_NOERROR)
                        {
                                sfPartnersKeyOpen = TRUE;
                                Status = OpenKey(PUSH_E_KEY, NULL, NULL, NULL, fCreateAllowed);
                                if (Status == SNMP_ERRORSTATUS_NOERROR)
                                {
                                        PUSH_ID_M(pMib, *pVal_Id_e);
                                }
                        }
                   }
                }
        }

        return(Status);
}
UINT
CloseReqKey(
        VOID
        )
/*++

Routine Description:

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        UINT Status = SNMP_ERRORSTATUS_NOERROR;
        if (sfParametersKeyOpen)
        {
                if (sfDatafilesKeyOpen)
                {
                        SNMPDBG((
                            SNMP_LOG_VERBOSE,
                            "WINSMIB: Closing sDatafilesKey 0x%08lx (fKeyOpen=TRUE).\n",
                            sDatafilesKey
                            ));
                        RegCloseKey(sDatafilesKey);
                        sfDatafilesKeyOpen = FALSE;
                }
                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "WINSMIB: Closing sParametersKey 0x%08lx (fKeyOpen=TRUE).\n",
                    sParametersKey
                    ));
                RegCloseKey(sParametersKey);
                sfParametersKeyOpen = FALSE;
        }
        else
        {
                if (sfPartnersKeyOpen)
                {
                        if (sfPullKeyOpen)
                        {
                                SNMPDBG((
                                    SNMP_LOG_VERBOSE,
                                    "WINSMIB: Closing sPullKey 0x%08lx (fKeyOpen=TRUE).\n",
                                    sPullKey
                                    ));
                                RegCloseKey(sPullKey);
                                sfPullKeyOpen = FALSE;
                        }
                        else
                        {
                                if (sfPushKeyOpen)
                                {
                                        SNMPDBG((
                                            SNMP_LOG_VERBOSE,
                                            "WINSMIB: Closing sPushKey 0x%08lx (fKeyOpen=TRUE).\n",
                                            sPushKey
                                            ));
                                        RegCloseKey(sPushKey);
                                        sfPushKeyOpen = FALSE;
                                }
                        }
                        SNMPDBG((
                            SNMP_LOG_VERBOSE,
                            "WINSMIB: Closing sPartnersKey 0x%08lx (fKeyOpen=TRUE).\n",
                            sPartnersKey
                            ));
                        RegCloseKey(sPartnersKey);
                        sfPartnersKeyOpen = FALSE;
                }
        }
        return(Status);
}

UINT
ReadReg(
        MIB_ENTRY *pMib
        )
{
        UINT Status = SNMP_ERRORSTATUS_NOERROR;
        VAL_ID_E  Val_Id_e;

//        SNMPDBG ((SNMP_LOG_TRACE,
//              "WINSMIB: Entering ReadReg.\n"));
        
        Status = OpenReqKey(pMib, &Val_Id_e, FALSE);
        if (Status == SNMP_ERRORSTATUS_NOERROR)
        {
          Status = GetVal(&VarInfo[Val_Id_e]);
        }
        CloseReqKey();

        return(Status);
}

UINT
WriteReg(
        MIB_ENTRY *pMib
        )
{
        UINT Status = SNMP_ERRORSTATUS_NOERROR;
        VAL_ID_E Val_Id_e;

        Status = OpenReqKey(pMib, &Val_Id_e, TRUE);
        if (SNMP_ERRORSTATUS_NOERROR == Status) {
            Status = SetVal(&VarInfo[Val_Id_e]);
            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "WINSMIB: Closing sParametersKey 0x%08lx (fKeyOpen=%s).\n",
                sParametersKey, sfParametersKeyOpen ? "TRUE" : "FALSE"
                ));

        }
        CloseReqKey();
        //RegCloseKey(sParametersKey);
        return(Status);
}


UINT
OpenKey(
        KEY_TYPE_E        Key_e,
        LPBYTE                ptrKeyStr,
           HKEY            *ptrNewKey,
        HKEY                *pRootKey,
        BOOL                fCreateAllowed
)
{
   LONG    RetVal;
   DWORD   NewKeyInd;
   HKEY    RootKey;
   LPBYTE  pKeyStr;
   HKEY    *pNewKey;
   LPBOOL  pfNewKeyOpen;


   if (!fWinsMibWinsKeyOpen)
   {
      SNMPDBG((
         SNMP_LOG_VERBOSE,
         "WINSMIB: Creating/opening Wins key.\n",
         WinsMibWinsKey
         ));

     RetVal = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,        //predefined key value
                _WINS_CNF_KEY,                //subkey for WINS
                0,                        //must be zero (reserved)
                TEXT("Class"),                //class -- may change in future
                REG_OPTION_NON_VOLATILE, //non-volatile information
                KEY_ALL_ACCESS,                //we desire all access to the keyo
                NULL,                         //let key have default sec. attributes
                &WinsMibWinsKey,                //handle to key
                &NewKeyInd                //is it a new key (out arg)
                );



      if (RetVal != ERROR_SUCCESS)
      {
         SNMPDBG((
            SNMP_LOG_ERROR,
            "WINSMIB: Error creating/opening Wins key 0x%08lx.\n",
            GetLastError()
            ));
         return(SNMP_ERRORSTATUS_GENERR);
      }

      fWinsMibWinsKeyOpen = TRUE;
   }

    SNMPDBG((
       SNMP_LOG_VERBOSE,
       "WINSMIB: WinsMibWinsKey=0x%08lx, opening %s.\n",
       WinsMibWinsKey,
       (Key_e == PARAMETERS_E_KEY)
            ? "PARAMETERS_E_KEY"
            : (Key_e == PARTNERS_E_KEY)
                ? "PARTNERS_E_KEY"
                : (Key_e == PULL_E_KEY)
                    ? "PULL_E_KEY"
                    : (Key_e == PUSH_E_KEY)
                        ? "PUSH_E_KEY"
                        : (Key_e == DATAFILES_E_KEY)
                            ? "DATAFILES_E_KEY"
                            : "IPADD_E_KEY"
                            ));

    switch(Key_e)
    {
        case(PARAMETERS_E_KEY):
                RootKey = WinsMibWinsKey;
                pKeyStr = _WINS_PARAMETERS_KEY;
                pNewKey = &sParametersKey;
                pfNewKeyOpen = &sfParametersKeyOpen;
                break;

        case(PARTNERS_E_KEY):
                RootKey = WinsMibWinsKey;
                pKeyStr = _WINS_PARTNERS_KEY;
                pNewKey = &sPartnersKey;
                pfNewKeyOpen = &sfPartnersKeyOpen;
                break;
        case(PULL_E_KEY):
                RootKey = sPartnersKey;
                pKeyStr = _WINS_PULL_KEY;
                pNewKey = &sPullKey;
                pfNewKeyOpen = &sfPullKeyOpen;
                break;
        case(PUSH_E_KEY):
                RootKey = sPartnersKey;
                pKeyStr = _WINS_PUSH_KEY;
                pNewKey = &sPushKey;
                pfNewKeyOpen = &sfPushKeyOpen;
                break;
        case(DATAFILES_E_KEY):
                RootKey = sParametersKey;
                pKeyStr = _WINS_DATAFILES_KEY;
                pNewKey = &sDatafilesKey;
                pfNewKeyOpen = &sfDatafilesKeyOpen;
                break;
        case(IPADD_E_KEY):
                RootKey = *pRootKey;
                pKeyStr = ptrKeyStr;
                pNewKey = ptrNewKey;
                break;
        default:
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "WINSMIB: Error in key type.\n"
                    ));
                 return(SNMP_ERRORSTATUS_GENERR);
     }

    if (fCreateAllowed)
    {
      RetVal = RegCreateKeyEx(
                  RootKey,        //predefined key value
                  pKeyStr,        //subkey for WINS
                  0,                //must be zero (reserved)
                  TEXT("Class"),        //class -- may change in future
                  REG_OPTION_NON_VOLATILE, //non-volatile information
                  KEY_ALL_ACCESS,        //we desire all access to the keyo
                  NULL,                 //let key have default sec. attributes
                  pNewKey,                //handle to key
                  &NewKeyInd                //is it a new key (out arg)
                  );
    }
    else
    {

      RetVal = RegOpenKeyEx(
                  RootKey,        //predefined key value
                  pKeyStr,        //subkey for WINS
                  0,                //must be zero (reserved)
                  KEY_READ,        //we desire read access to the keyo
                  pNewKey        //handle to key
                  );
    }


     if (RetVal != ERROR_SUCCESS)
     {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "WINSMIB: Error creating/opening Wins/Parameters key 0x%08lx.\n",
            GetLastError()
            ));
         return(SNMP_ERRORSTATUS_GENERR);
     }

    SNMPDBG((
       SNMP_LOG_VERBOSE,
       "WINSMIB: Opened %s=0x%08lx (fKeyOpen=TRUE).\n",
       (Key_e == PARAMETERS_E_KEY)
            ? "sParametersKey"
            : (Key_e == PARTNERS_E_KEY)
                ? "sPartnersKey"
                : (Key_e == PULL_E_KEY)
                    ? "sPullKey"
                    : (Key_e == PUSH_E_KEY)
                        ? "sPushKey"
                        : (Key_e == DATAFILES_E_KEY)
                            ? "sDatafilesKey"
                            : "ipAddKey", *pNewKey
                            ));

     if (Key_e != IPADD_E_KEY)
     {
       if (ptrNewKey != NULL)
       {
         *ptrNewKey = *pNewKey;
       }
       *pfNewKeyOpen = TRUE;
     }

     return(SNMP_ERRORSTATUS_NOERROR);
}


UINT
SetVal(
        PVARINFO_T        pVarInfo

)
{
        UINT Status = SNMP_ERRORSTATUS_NOERROR;
        LONG  RetVal;

        RetVal = RegSetValueEx(
                                *(pVarInfo->pRootKey),
                                pVarInfo->pName,
                                0,         //reserved -- must be 0
                                pVarInfo->ValType,
                                pVarInfo->pStorage,
                                pVarInfo->ValType == REG_DWORD ?
                                        pVarInfo->SizeOfData :
                                        strlen(pVarInfo->pStorage)
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                        SNMPDBG((
                            SNMP_LOG_ERROR,
                            "WINSMIB: Could not set value of %s.\n",
                            pVarInfo->pName
                            ));
                        Status = SNMP_ERRORSTATUS_GENERR;
        }

        return(Status);
}

UINT
GetVal(
        PVARINFO_T        pVarInfo
)
{
        LONG        RetVal;
        UINT        ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD   ValType;
        DWORD   Sz;

//        SNMPDBG ((SNMP_LOG_TRACE,
//             "WINSMIB: GetVal(%s).\n",
//              pVarInfo->pName));

        Sz = pVarInfo->SizeOfData;
        RetVal = RegQueryValueEx(
                *(pVarInfo->pRootKey),
                pVarInfo->pName,
                NULL,
                &ValType,
                pVarInfo->pStorage,
                &Sz
                );

//        SNMPDBG ((SNMP_LOG_TRACE,
//               "WINSMIB: GetVal()->%d\n",
//               RetVal));

        if (RetVal != ERROR_SUCCESS)
        {
                (VOID)RtlFillMemory(pVarInfo->pStorage, pVarInfo->SizeOfData, 0);
                ErrStat = SNMP_ERRORSTATUS_GENERR;
        }
        return(ErrStat);

}
#if 0
//
// PullPnrs
//    Performs specific actions on the PullPnrs table
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
UINT
PullPnrs(
       IN UINT                  Action,
       IN MIB_ENTRY          *MibPtr,
       IN RFC1157VarBind *VarBind,
       IN PTABLE_ENTRY         *TablePtr
        )
{
   WINSINTF_RESULTS_T         Results;
   DWORD                Status = WINSINTF_SUCCESS;
   UINT                   ErrStat = SNMP_ERRORSTATUS_NOERROR;
   handle_t                BindHdl;



   BindHdl = WinsBind(&sBindData);
   switch ( Action )
      {
      case MIB_SET:
                break;
      case MIB_GETNEXT:

      case MIB_GET:
                ErrStat = TableMatch(MibPtr, VarBind, TablePtr);
                if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
                {
                        return(ErrStat);
                }
        //
        // Call the WinsStatus function to get the statistics
        //
        if (
                (MibPtr->Storage  == &MIB_RefreshIntervalStore)
                        ||
                (MibPtr->Storage  == &MIB_TombstoneIntervalStore)
                        ||
                (MibPtr->Storage  == &MIB_TombstoneTimeoutStore)
                        ||
                (MibPtr->Storage  == &MIB_VerifyIntervalStore)

            )
        {

                Status = WinsStatus(WINSINTF_E_CONFIG, &Results);

                if (Status == WINSINTF_SUCCESS)
                {
                        MIB_RefreshIntervalStore   = Results.RefreshInterval;
                        MIB_TombstoneIntervalStore = Results.TombstoneInterval;
                        MIB_TombstoneTimeoutStore  = Results.TombstoneTimeout;
                        MIB_VerifyIntervalStore    = Results.VerifyInterval;

                }
                 else
                 {
                           SNMPDBG((
                                SNMP_LOG_ERROR,
                                "WINSMIB: Error from WinsStatus = (%d).\n",
                                Status
                                ));
                           ErrStat = SNMP_ERRORSTATUS_GENERR;
                 }
        }
        else
        {
                if ((ErrStat = ReadReg(MibPtr)) != SNMP_ERRORSTATUS_NOERROR)
                {
                        break;
                }
        }

        // Call the more generic function to perform the action
        ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
         goto Exit;
      } // switch

Exit:
   WinsUnbind(&sBindData, BindHdl);
   return ErrStat;
} //PullPnrs
#endif

UINT
PnrGetNext(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY          *MibPtr,
       IN KEY_TYPE_E         KeyType_e
          )
{
     DWORD          OidIndex;
     DWORD          NumAddKeys;
     INT            Index;
     PADD_KEY_T  pAddKey = NULL;
     DWORD         FieldNo;
     UINT         ErrStat = SNMP_ERRORSTATUS_NOERROR;
     BOOL         fFirst;

     //
     // Read in all ip address keys. For each key, the values of its fields
     // is stored in the ADD_KEY_T structure.  The number of Address
     // keys are stored in NumAddKeys and in the TABLE_INFO structure
     //
     ErrStat = EnumAddKeys(KeyType_e, &pAddKey, &NumAddKeys);
     if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
     {
                return ErrStat;
     }

     //
     // Check if the name passed matches any in the table (i.e. table of
     // of ADD_KEY_T structures.  If there is a match, the address
     // of the ip address key and the matching field's no. are returned
     //
     ErrStat = PnrMatch(VarBind,  NumAddKeys, pAddKey, &Index,
                                &FieldNo, KeyType_e, MIB_GETNEXT, &fFirst);
     if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
     {
                goto Exit;
               // return(ErrStat);
     }

     //
     // We were passed an oid that is less than all oids in the table. Set
     // the Index to -1 so that we retrieve the first record in the table
     //
     if (fFirst)
     {
        Index = -1;
     }
     //
     // Since the operation is GETNEXT, get the next IP address (i.e. one
     // that is lexicographically bigger.  If there is none, we must increment
     // the field value and move back to the lexically first item in the table
     // If the new field value is more than the largest supported, we call
     // the MibFunc of the next MIB entry.
     //
     if ((Index = PnrFindNext(Index, NumAddKeys, pAddKey)) < 0)
     {

          //
          // if we were trying to retrieve the second or subsequent record
          // we must increment the field number nd get the first record in
          // the table.  If we were retrieving the first record, then
          // we should get the next var.
          //
          if (!fFirst)
          {
            Index = PnrFindNext(-1, NumAddKeys, pAddKey);
          }
          else
          {
                HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pAddKey);
                return(GetNextVar(VarBind, MibPtr));
          }

          //
          // If either there is no entry in the table or if we have
          // exhausted all fields of the entry, call the function
          // of the next mib entry.
          //
          if (
                (++FieldNo > (DWORD)((KeyType_e == PULL_E_KEY)
                                ? NO_FLDS_IN_PULLADD_KEY
                                : NO_FLDS_IN_PUSHADD_KEY)) || (Index < 0)
             )
          {
                HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pAddKey);
                return(GetNextVar(VarBind, MibPtr));
          }
     }

     //
     // The fixed part of the objid is corect. Update the rest.
     //

     //
     // If there is not enough space, deallocate what is currently
     // there and allocate.
     //
     if (VarBind->name.idLength <= (PNR_OIDLEN + 4))
     {
         UINT TableEntryIds[5];  //field and Ip address have a length of 5
         AsnObjectIdentifier  TableEntryOid = {OID_SIZEOF(TableEntryIds),
                                             TableEntryIds };
         SNMP_oidfree( &VarBind->name);
         SNMP_oidcpy(&VarBind->name, &MIB_OidPrefix);
         SNMP_oidappend(&VarBind->name, &MibPtr->Oid);
         TableEntryIds[0] = (UINT)FieldNo;
         OidIndex = 1;
         TableEntryIds[OidIndex++] = (UINT)((pAddKey + Index)->IpAdd >> 24);
         TableEntryIds[OidIndex++] = (UINT)((pAddKey + Index)->IpAdd >> 16 & 0xFF);
         TableEntryIds[OidIndex++] = (UINT)((pAddKey + Index)->IpAdd >> 8 & 0xFF);
         TableEntryIds[OidIndex++]   = (UINT)((pAddKey + Index)->IpAdd & 0xFF);
         TableEntryOid.idLength            = OidIndex;
         SNMP_oidappend(&VarBind->name, &TableEntryOid);
     }
     else
     {
          OidIndex = PNR_OIDLEN;
          VarBind->name.ids[OidIndex++] = (UINT)FieldNo;
          VarBind->name.ids[OidIndex++] = (UINT)((pAddKey + Index)->IpAdd >> 24);
          VarBind->name.ids[OidIndex++] = (UINT)((pAddKey + Index)->IpAdd >> 16 & 0xFF);
          VarBind->name.ids[OidIndex++] = (UINT)((pAddKey + Index)->IpAdd >> 8 & 0xFF);
          VarBind->name.ids[OidIndex++] = (UINT)((pAddKey + Index)->IpAdd & 0xFF);
          VarBind->name.idLength = OidIndex;

     }

     //
     // Get the value
     //
     if (KeyType_e == PULL_E_KEY)
     {
        ErrStat = PullGet(VarBind, NumAddKeys, pAddKey);
     }
     else
     {
        ErrStat = PushGet(VarBind, NumAddKeys, pAddKey);
     }

     //
     // Let us free the memory that was allocated earlier.  No need to
     // check whether pAddKey is NULL.  It just can not be otherwise we
     // would have returned from this function earlier.
     //
Exit:
     HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pAddKey);
     return(ErrStat);
}

UINT
PullGet(
       IN RFC1157VarBind *VarBind,
       IN DWORD          NumKeys,
       IN LPVOID         pKey
    )
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD           Field;
        DWORD                Index;
        DWORD           NumAddKeys = NumKeys;
        IN PADD_KEY_T         pAddKey = pKey;

        if (pAddKey == NULL)
        {
           //
           // Call EnumAddresses only if we have not been invoked by PnrGetNext
           //
           EnumAddKeys(PULL_E_KEY, &pAddKey, &NumAddKeys);
        }

        ErrStat = PnrMatch(VarBind, NumAddKeys, pAddKey, &Index, &Field,
                                        PULL_E_KEY, MIB_GET, NULL);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
                goto Exit;
                //return(ErrStat);
        }

        switch(Field)
        {
                case 1:                //IP address itself

                      VarBind->value.asnType        = ASN_RFC1155_IPADDRESS;
                      VarBind->value.asnValue.string.length = sizeof(ULONG);

                      if ( NULL ==  (VarBind->value.asnValue.string.stream =
                                   SNMP_malloc(VarBind->value.asnValue.string.length
                                   )) )
                      {
                                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                                  goto Exit;
                      }

                      VarBind->value.asnValue.string.stream[0] =
                                        (BYTE)((pAddKey + Index)->IpAdd >> 24);
                      VarBind->value.asnValue.string.stream[1] =
                                (BYTE)(((pAddKey + Index)->IpAdd >> 16) & 0xFF);
                      VarBind->value.asnValue.string.stream[2] =
                                (BYTE)(((pAddKey + Index)->IpAdd >> 8) & 0xFF);
                      VarBind->value.asnValue.string.stream[3] =
                                (BYTE)((pAddKey + Index)->IpAdd & 0xFF );
                      VarBind->value.asnValue.address.dynamic = TRUE;
#if 0
                      memcpy( VarBind->value.asnValue.string.stream,
                                       (LPSTR)(&((pAddKey + Index)->IpAdd)),
                                       VarBind->value.asnValue.string.length );
                        *((ULONG *)VarBind->value.asnValue.address.stream)
                                = (ULONG)(pAddKey + Index)->IpAdd;
#endif
#if 0
                               VarBind->value.asnValue.string.length =
                                 strlen( (LPSTR)((pAddKey + Index)->asIpAddress));

                               if ( NULL ==
                                    (VarBind->value.asnValue.string.stream =
                                    SNMP_malloc(VarBind->value.asnValue.string.length *
                                   sizeof(char))) )
                          {
                                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                                  goto Exit;
                          }

                               memcpy( VarBind->value.asnValue.string.stream,
                                       (LPSTR)((pAddKey + Index)->asIpAddress),
                                       VarBind->value.asnValue.string.length );
#endif
                        break;
                case 2:                // SpTime
                      VarBind->value.asnType        = ASN_RFC1213_DISPSTRING;
                      if (((pAddKey + Index)->asSpTime[0]) != EOS)
                      {
                           VarBind->value.asnValue.string.length =
                             strlen( (LPSTR)((pAddKey + Index)->asSpTime));

                           if ( NULL ==
                                    (VarBind->value.asnValue.string.stream =
                                    SNMP_malloc(VarBind->value.asnValue.string.length *
                                   sizeof(char))) )
                           {
                                    ErrStat = SNMP_ERRORSTATUS_GENERR;
                                    goto Exit;
                           }
                           memcpy( VarBind->value.asnValue.string.stream,
                                       (LPSTR)((pAddKey + Index)->asSpTime),
                                       VarBind->value.asnValue.string.length );
                    }
                    else
                    {
                                 VarBind->value.asnValue.string.length = 0;
                                 VarBind->value.asnValue.string.stream = NULL;
                    }
                    VarBind->value.asnValue.address.dynamic = TRUE;
                    break;

                case 3:                // TimeInterval
                        VarBind->value.asnType        = ASN_INTEGER;
                               VarBind->value.asnValue.number =
                                        (AsnInteger)((pAddKey + Index)->
                                                                TimeInterval);
                               break;

                case 4:   //Member Precedence
                        VarBind->value.asnType        = ASN_INTEGER;
                               VarBind->value.asnValue.number =
                                        (AsnInteger)((pAddKey + Index)->
                                                                MemberPrec);

                               break;

                case 5:   //No of successful replications
                        VarBind->value.asnType        = ASN_RFC1155_COUNTER;
                               VarBind->value.asnValue.number =
                                        (AsnCounter)((pAddKey + Index)->
                                                                NoOfRpls);

                               break;

                case 6:   //No of replication failures due to comm failures
                        VarBind->value.asnType        = ASN_RFC1155_COUNTER;
                               VarBind->value.asnValue.number =
                                        (AsnCounter)((pAddKey + Index)->
                                                                NoOfCommFails);

                        break;
                case 7:   //Low part of the highest vers. no of owned records
                        VarBind->value.asnType        = ASN_RFC1155_COUNTER;
                               VarBind->value.asnValue.number =
                                        (AsnCounter)((pAddKey + Index)->
                                                        VersNo.LowPart);

                        break;
                case 8:   //High part of the highest vers. no of owned records
                        VarBind->value.asnType        = ASN_RFC1155_COUNTER;
                               VarBind->value.asnValue.number =
                                        (AsnCounter)((pAddKey + Index)->
                                                        VersNo.HighPart);

                        break;

                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;

        }
Exit:
        //
        // if we allocated memory here, free it
        //
        if ((pKey == NULL) && (pAddKey != NULL))
        {
                HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pAddKey);
        }
        return(ErrStat);
}


UINT
PnrMatch(
       IN RFC1157VarBind *VarBind,
       DWORD                 NoOfKeys,
       IN PADD_KEY_T         pAddKey,
       IN LPDWORD         pIndex,
       IN LPDWORD         pField,
       IN KEY_TYPE_E         KeyType_e,
       IN UINT                 PduAction,
       IN LPBOOL        pfFirst
        )
{
        DWORD OidIndex;
        DWORD Index;
        DWORD AddIndex;
        DWORD  Add = 0;
        UINT ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD AddLen;

        ASSERT(PduAction != MIB_SET);

        if (pfFirst != NULL)
        {
                *pfFirst = FALSE;
        }
        //
        // If there are no keys, return error
        //
        if (NoOfKeys == 0)
        {
                return(SNMP_ERRORSTATUS_NOSUCHNAME);
        }

        //
        // fixed part of the PullPnr table entries
        //
        OidIndex = PNR_OIDLEN;

        //
        // if the field specified is more than the max. in the table entry
        // barf
        //
        if (
                (NoOfKeys == 0)
                        ||
                ((*pField = VarBind->name.ids[OidIndex++]) >
                        (DWORD)
                   ((KeyType_e == PULL_E_KEY) ? NO_FLDS_IN_PULLADD_KEY
                                        : NO_FLDS_IN_PUSHADD_KEY))
           )
        {
                if (PduAction == MIB_GETNEXT)
                {
                        if (NoOfKeys == 0)
                        {
                                *pfFirst = TRUE;
                        }
                        else
                        {
                                *pIndex = NoOfKeys - 1;
                        }
                }
                else
                {
                        ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
                }
                goto Exit;
        }

        //
        // get the length of key specified
        //
        AddLen = VarBind->name.idLength - (PNR_OIDLEN + 1);

        AddIndex = OidIndex;
        for (Index = 0; Index < AddLen; Index++)
        {
           Add = Add | (((BYTE)(VarBind->name.ids[AddIndex++])) << (24 - (Index * 8)));
        }

        //
        // Check if the address specified matches with one of the keys
        //
        for (Index = 0; Index < NoOfKeys; Index++, pAddKey++)
        {
                if (Add == pAddKey->IpAdd)
                {
                        *pIndex = Index;
                        return(SNMP_ERRORSTATUS_NOERROR);
                }
                else
                {
                        //
                        // if passed in value is greater, continue on to
                        // the next item.  The list is in ascending order
                        //
                        if (Add > pAddKey->IpAdd)
                        {
                                continue;
                        }
                        else
                        {
                                //
                                // the list element is > passed in value,
                                // break out of the loop
                                //
                                break;
                        }
                }
        }

        //
        // if no match, but field is GetNext, return the (highest index - 1)
        // reached above.  This is because, PnrFindNext will be called by
        // the caller
        //
        if (PduAction == MIB_GETNEXT)
        {
                if (Index == 0)
                {
                        *pfFirst = TRUE;
                }
                else
                {
                        *pIndex = Index - 1;
                }
                ErrStat =  SNMP_ERRORSTATUS_NOERROR;
                goto Exit;
        }
        else
        {
                ErrStat =  SNMP_ERRORSTATUS_NOSUCHNAME;
        }
Exit:
        return(ErrStat);
}

UINT
PnrFindNext(
        INT           AddKeyNo,
        DWORD           NumAddKeys,
        PADD_KEY_T pAddKey
        )
{
        DWORD i;
        LONG  nextif;

        //
        // if AddKeyNo is 0  or more, search for the key next to
        // the key passed.
        //
        for (nextif =  -1, i = 0 ; i < NumAddKeys; i++)
        {
                if (AddKeyNo >= 0)
                {
                        if ( (pAddKey + i)->IpAdd <=
                                                (pAddKey + AddKeyNo)->IpAdd)
                        {
                          //
                          // This item is lexicographically less or equal,
                          // continue
                          //
                          continue;
                        }
                        else
                        {
                                nextif = i;
                                break;
                        }
                }
                else
                {
                        //
                        // We want the first key
                        //
                        nextif = 0;
                        break;
                }

#if 0
                //
                // if we want the first entry, then continue until
                // we get an entry that is lexicographically same or
                // greater
                //
                if (
                        (nextif < 0)
                           ||
                        (pAddKey + (i - 1))->IpAdd < (pAddKey + nextif)->IpAdd
                   )
                {
                        nextif = i;
                }
#endif

        }
        return(nextif);
}

UINT
PnrGetFirst(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY        *MibPtr,
       IN KEY_TYPE_E        KeyType_e
        )
{

        PADD_KEY_T pAddKey = NULL;
        DWORD      NumAddKeys;
        INT        Iface;
        UINT       TableEntryIds[5];
        AsnObjectIdentifier        TableEntryOid = { OID_SIZEOF(TableEntryIds),
                                                        TableEntryIds };
        UINT   ErrStat;

        //
        // Get all the address key information
        //
        EnumAddKeys(KeyType_e, &pAddKey, &NumAddKeys);

        //
        // If there is no entry in the table, go to the next MIB variable
        //
        if (NumAddKeys == 0)
        {
                 return(GetNextVar(VarBind, MibPtr));
        }
        //
        // Get the first entry in the table
        //
        Iface = PnrFindNext(-1, NumAddKeys, pAddKey);


        //
        // Write the object Id into the binding list and call get
        // func
        //
        SNMP_oidfree( &VarBind->name );
        SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
        SNMP_oidappend( &VarBind->name, &MibPtr->Oid );

        //
        // The fixed part of the objid is correct. Update the rest.
        //

        TableEntryIds[0] = 1;
        TableEntryIds[1] = (UINT)((pAddKey + Iface)->IpAdd >> 24);
        TableEntryIds[2] = (UINT)(((pAddKey + Iface)->IpAdd >> 16)
                                                                & 0xFF);
        TableEntryIds[3] = (UINT)(((pAddKey + Iface)->IpAdd >> 8)
                                                                & 0xFF);
        TableEntryIds[4] = (UINT)((pAddKey + Iface)->IpAdd & 0xFF);
        SNMP_oidappend( &VarBind->name, &TableEntryOid );

        ErrStat =         (KeyType_e == PULL_E_KEY)
                ? PullGet(VarBind, NumAddKeys, pAddKey)
                : PushGet(VarBind, NumAddKeys, pAddKey);

        HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pAddKey);
        return(ErrStat);
}

UINT
PullSet(
       IN RFC1157VarBind *VarBind
)
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD           Field;
        ADD_KEY_T        AddKey;
#if 0
        LPBYTE                pTmpB;
#endif
        struct in_addr  InAddr;

        //
        // Extract the field that needs to be set
        //
        Field = VarBind->name.ids[PULLPNR_OIDLEN];

        AddKey.IpAdd  = (VarBind->name.ids[PNR_OIDLEN  + 1] << 24);
        AddKey.IpAdd |= (VarBind->name.ids[PNR_OIDLEN + 2] << 16);
        AddKey.IpAdd |= (VarBind->name.ids[PNR_OIDLEN + 3] << 8);
        AddKey.IpAdd |= VarBind->name.ids[PNR_OIDLEN + 4];
        InAddr.s_addr = htonl(AddKey.IpAdd);

        //
        // The storage must be adequate to contain the new
        // string including a NULL terminator.
        //
        strcpy( (LPSTR)AddKey.asIpAddress, inet_ntoa(InAddr) );
        switch(Field)
        {
                case 1:

                        if (VarBind->value.asnType != ASN_RFC1155_IPADDRESS)
                        {
                                return(SNMP_ERRORSTATUS_BADVALUE);
                        }
#if 0
                        pTmpB =
                            VarBind->value.asnValue.string.stream;

                        NMSMSGF_RETRIEVE_IPADD_M(pTmpB, AddKey.IpAdd);
                        InAddr.s_addr = htonl(AddKey.IpAdd);


                        //
                               // The storage must be adequate to contain the new
                        // string including a NULL terminator.
                        //
                        strcpy(
                                        (LPSTR)AddKey.asIpAddress,
                                inet_ntoa(InAddr)
                                );
#endif
#if 0
                               memcpy( (LPSTR)AddKey.asIpAddress,
                            VarBind->value.asnValue.string.stream,
                            VarBind->value.asnValue.string.length );

                               ((LPSTR)AddKey.asIpAddress)
                                [VarBind->value.asnValue.string.length] = '\0';
#endif
                               break;

                case 2:                // SpTime
                        if (VarBind->value.asnType != ASN_RFC1213_DISPSTRING)
                        {
                                return(SNMP_ERRORSTATUS_BADVALUE);
                        }
                               // The storage must be adequate to contain the new
                        // string including a NULL terminator.
                               memcpy( (LPSTR)AddKey.asSpTime,
                            VarBind->value.asnValue.string.stream,
                            VarBind->value.asnValue.string.length );

                               ((LPSTR)AddKey.asSpTime)
                                [VarBind->value.asnValue.string.length] = '\0';

                               break;

                case 3:                // TimeInterval
                        if (VarBind->value.asnType != ASN_INTEGER)
                        {
                                return(SNMP_ERRORSTATUS_BADVALUE);
                        }
                               (AsnInteger)(AddKey.TimeInterval) =
                                        VarBind->value.asnValue.number;
                               break;
                case 4:                // MemberPrec
                        if (VarBind->value.asnType != ASN_INTEGER)
                        {
                                return(SNMP_ERRORSTATUS_BADVALUE);
                        }
                               (AsnInteger)(AddKey.MemberPrec) =
                                        VarBind->value.asnValue.number;
                               break;
                case 5:        //fall through
                case 6: //fall through
                case 7: //fall through
                case 8: //fall through
                        ErrStat = SNMP_ERRORSTATUS_READONLY;
                        break;
                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;

        }

        if (ErrStat == SNMP_ERRORSTATUS_NOERROR)
        {
                ErrStat = WriteKeyNValues(PULL_E_KEY, &AddKey, Field);
        }
        return(ErrStat);
} //PullSet


UINT
WriteKeyNValues(
        KEY_TYPE_E        KeyType_e,
        PADD_KEY_T        pAddKey,
        DWORD                FieldNo
        )
{

        HKEY        AddKeyHdl;
        HKEY        RootKeyHdl;
        UINT        ErrStat = SNMP_ERRORSTATUS_NOERROR;

        //
        // Open the Parameters key and the key under that
        //
        ErrStat = OpenKey(PARTNERS_E_KEY, NULL, NULL, NULL, TRUE);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
           return(ErrStat);
        }
        ErrStat = OpenKey(KeyType_e, NULL, &RootKeyHdl, NULL, TRUE);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
           return(ErrStat);
        }
        ErrStat = OpenKey(IPADD_E_KEY, pAddKey->asIpAddress, &AddKeyHdl, &RootKeyHdl, TRUE);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
            return(ErrStat);
        }

        switch(FieldNo)
        {
                case(1):
                        //
                        // for this field, we don't need to do anything.
                        // The field (actually the key) has already been
                        // created.
                        //
                        break;

                case(2):
                        if (KeyType_e == PUSH_E_KEY)
                        {
                                MIB_UpdateCountStore =
                                        pAddKey->UpdateCount;
                                VarInfo[UPD_CNT_E].pRootKey = &AddKeyHdl;
                                SetVal(&VarInfo[UPD_CNT_E]);

                        }
                        else
                        {
                           strcpy(MIB_SpTimeStore, pAddKey->asSpTime);
                           VarInfo[SP_TIME_E].SizeOfData = strlen(pAddKey->asSpTime);
                           VarInfo[SP_TIME_E].pRootKey = &AddKeyHdl;
                           SetVal(&VarInfo[SP_TIME_E]);
                        }
                        break;
                case(3):
                        MIB_TimeIntervalStore =   pAddKey->TimeInterval;
                        VarInfo[TIME_INTVL_E].pRootKey = &AddKeyHdl;
                        SetVal(&VarInfo[TIME_INTVL_E]);
                        break;
                case(4):
                        MIB_MemberPrecStore =   pAddKey->MemberPrec;
                        VarInfo[MEMBER_PREC_E].pRootKey = &AddKeyHdl;
                        SetVal(&VarInfo[MEMBER_PREC_E]);
                        break;
                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;
        }

        //
        // Let us close the keys that we opened/created
        //
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "WINSMIB: Closing AddKeyHdl 0x%08lx.\n",
            AddKeyHdl
            ));
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "WINSMIB: Closing RootKeyHdl 0x%08lx.\n",
            RootKeyHdl
            ));
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "WINSMIB: Closing sParametersKey 0x%08lx (fKeyOpen=%s).\n",
            sParametersKey, sfParametersKeyOpen ? "TRUE" : "FALSE"
            ));
        RegCloseKey(AddKeyHdl);
        CloseReqKey();
/*
        RegCloseKey(RootKeyHdl);
        RegCloseKey(sParametersKey);
*/

        return(SNMP_ERRORSTATUS_NOERROR);
}

UINT
MIB_PullTable(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
)
{
        //
        // if the length indicates a 0 or partial key, then only the get next
        // operation is allowed.  The field and the full key
        // have a length of 5
        //
        if (VarBind->name.idLength <= (PULLPNR_OIDLEN + 4))
        {
                if ((Action == MIB_GET) || (Action == MIB_SET))
                {
                        return(SNMP_ERRORSTATUS_NOSUCHNAME);
                }
        }
        return(
          MIB_Table(PULL_TABLE_INDEX, Action, MibPtr, VarBind, PULL_E_KEY)
             );
}

UINT
MIB_PushTable(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
)
{
        //
        // if the length indicates a 0 or partial key, then only the get next
        // operation is allowed. The field and the full key
        // have a length of 5.
        //
        if (VarBind->name.idLength <= (PUSHPNR_OIDLEN + 4))
        {
                if ((Action == MIB_GET) || (Action == MIB_SET))
                {
                        return(SNMP_ERRORSTATUS_NOSUCHNAME);
                }
        }
        return(
           MIB_Table(PUSH_TABLE_INDEX, Action, MibPtr, VarBind, PUSH_E_KEY)
              );
}
UINT
MIB_DFTable(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
)
{
        //
        // if the length indicates a 0 or partial key, then only the get next
        // operation is allowed.  Actually, the length can never
        // be < DF_OIDLEN + 1
        //
        if (VarBind->name.idLength <= (DF_OIDLEN + 1))
        {
                if ((Action == MIB_GET) || (Action == MIB_SET))
                {
                        return(SNMP_ERRORSTATUS_NOSUCHNAME);
                }
                Action = MIB_GETFIRST;
        }
        return(
           MIB_Table(DF_TABLE_INDEX, Action, MibPtr, VarBind, PUSH_E_KEY)
              );
}

UINT
MIB_DRTable(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
)
{
        time_t        CurrentTime;
        DWORD   RetStat = WINSINTF_SUCCESS;

        if (Action == MIB_SET)
        {
                return(SNMP_ERRORSTATUS_READONLY);

        }
        //
        // if the length indicates a 0 or partial key, then only the get next
        // operation is allowed.  Actually, the length can never
        // be < DR_OIDLEN + 1
        //
        if (VarBind->name.idLength <= (DR_OIDLEN + 1))
        {
                if ((Action == MIB_GET) || (Action == MIB_SET))
                {
                        return(SNMP_ERRORSTATUS_NOSUCHNAME);
                }
        }
        (void)time(&CurrentTime);
        if ((CurrentTime - sDRCacheInitTime) > WINSMIB_DR_CACHE_TIME)
        {
                if ((RetStat = PopulateDRCache()) == WINSINTF_SUCCESS)
                {
                        sDRCacheInitTime = CurrentTime;
                }

                if ((RetStat != WINSINTF_SUCCESS) || (sRecs.NoOfRecs == 0))
                {
                        if (Action == MIB_GETNEXT)
                        {
                                    return(GetNextVar(VarBind, MibPtr));
                        }
                        else
                        {
                                return(SNMP_ERRORSTATUS_NOSUCHNAME);
                        }
                }
        }
        return(
          MIB_Table(DR_TABLE_INDEX, Action, MibPtr, VarBind, PUSH_E_KEY)
             );
}
UINT
MIB_Table(
        IN DWORD          Index,
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind,
        IN KEY_TYPE_E          KeyType_e
       )
{
        UINT        ErrStat;
        switch(Action)
        {
                case(MIB_GET):
                        ErrStat = (*Tables[Index].ti_get)(VarBind, 0, NULL);
                        break;

                case(MIB_GETFIRST):
                        ErrStat = (*Tables[Index].ti_getf)(VarBind, MibPtr, KeyType_e);
                        break;

                case(MIB_GETNEXT):
                        ErrStat = (*Tables[Index].ti_getn)(VarBind, MibPtr, KeyType_e);
                        break;
                case(MIB_SET):
                        ErrStat = (*Tables[Index].ti_set)(VarBind);
                        break;
                default:
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                        break;

        }

        return(ErrStat);

}  //MIB_Table



UINT
PushSet(
       IN RFC1157VarBind *VarBind
)
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD           Field;
        ADD_KEY_T        AddKey;
        LPBYTE                pTmpB;
        struct in_addr  InAddr;

        Field = VarBind->name.ids[PUSHPNR_OIDLEN];
        AddKey.IpAdd  = VarBind->name.ids[PNR_OIDLEN + 1] << 24;
        AddKey.IpAdd |= (VarBind->name.ids[PNR_OIDLEN + 2] << 16);
        AddKey.IpAdd |= (VarBind->name.ids[PNR_OIDLEN + 3] << 8);
        AddKey.IpAdd |= VarBind->name.ids[PNR_OIDLEN + 4];
        InAddr.s_addr = htonl(AddKey.IpAdd);


        //
        // The storage must be adequate to contain the new
        // string including a NULL terminator.
        //
        pTmpB = inet_ntoa(InAddr);
        if (NULL == pTmpB) {
            return SNMP_ERRORSTATUS_GENERR;
        }
        strcpy( (LPSTR)AddKey.asIpAddress, pTmpB);
        switch(Field)
        {
               case 1:
                        if (VarBind->value.asnType != ASN_RFC1155_IPADDRESS)
                        {
                                return(SNMP_ERRORSTATUS_BADVALUE);
                        }
                               break;


                case 2:                // UpdateCount
                        if (VarBind->value.asnType != ASN_INTEGER)
                        {
                                return(SNMP_ERRORSTATUS_BADVALUE);
                        }
                               (AsnInteger)(AddKey.UpdateCount) =
                                        VarBind->value.asnValue.number;

                               break;

                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;

        }

        if (ErrStat == SNMP_ERRORSTATUS_NOERROR)
        {
                ErrStat = WriteKeyNValues(PUSH_E_KEY, &AddKey, Field);
        }
        return(ErrStat);
} //PushSet

UINT
PushGet(
       IN RFC1157VarBind *VarBind,
       IN DWORD          NumKeys,
       IN LPVOID         pKey
    )
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD           Field;
        DWORD                Index;
        DWORD           NumAddKeys = NumKeys;
        IN PADD_KEY_T         pAddKey = pKey;

        if (pAddKey == NULL)
        {
           //
           // Call EnumAddresses only if we have not been invoked by PnrGetNext
           //
           EnumAddKeys(PUSH_E_KEY, &pAddKey, &NumAddKeys);
        }

        ErrStat = PnrMatch(VarBind, NumAddKeys, pAddKey, &Index, &Field,
                                        PUSH_E_KEY, MIB_GET, NULL);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
                return(ErrStat);
        }

        switch(Field)
        {
                case 1:                //IP address itself

                        VarBind->value.asnType        = ASN_RFC1155_IPADDRESS;
                        VarBind->value.asnValue.string.length = sizeof(ULONG);

                        if ( NULL ==
                                    (VarBind->value.asnValue.string.stream =
                                    SNMP_malloc(VarBind->value.asnValue.string.length
                                   )) )
                        {
                                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                                  goto Exit;
                        }

                        //
                        // SNMP expects the MSB to be in the first byte, MSB-1
                        // to be in the second, ....
                        //
                        VarBind->value.asnValue.string.stream[0] =
                                        (BYTE)((pAddKey + Index)->IpAdd >> 24);
                        VarBind->value.asnValue.string.stream[1] =
                                (BYTE)(((pAddKey + Index)->IpAdd >> 16) & 0xFF);
                        VarBind->value.asnValue.string.stream[2] =
                                (BYTE)(((pAddKey + Index)->IpAdd >> 8) & 0xFF);
                        VarBind->value.asnValue.string.stream[3] =
                                (BYTE)((pAddKey + Index)->IpAdd & 0xFF );
                        VarBind->value.asnValue.address.dynamic = TRUE;
                        break;

                case 2:                // UpdateCount
                        VarBind->value.asnType        = ASN_INTEGER;
                               VarBind->value.asnValue.number =
                                        (AsnInteger)((pAddKey + Index)->
                                                                UpdateCount);
                               break;

                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;

        }
Exit:
        if ((pKey == NULL) && (pAddKey != NULL))
        {
              HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pAddKey);
        }
        return(ErrStat);
} // PushGet

UINT
EnumAddKeys(
        KEY_TYPE_E        KeyType_e,
        PADD_KEY_T        *ppAddKey,
        LPDWORD           pNumAddKeys
          )
{


  LONG                 RetVal;
  TCHAR                KeyName[20];  // will hold name of subkey of
                                     // PULL/PUSH records. These keys are IP
                                     // addresses for which 20 is a
                                     // big enough size

#ifdef UNICODE
  CHAR                 AscKeyName[20];
#endif
  DWORD                KeyNameSz;
  FILETIME             LastWrite;
  DWORD                BuffSize;
  HKEY                 SubKey;
  DWORD                ValTyp;
  DWORD                Sz;
  DWORD                NoOfPnrs = 0;        //# of PULL or PUSH pnrs
  DWORD                NoOfVals;
  HKEY                 KeyHdl;
  UINT                 ErrStat = SNMP_ERRORSTATUS_NOERROR;
  PADD_KEY_T           pAddKey;
  PADD_KEY_T           pAddKeySave;
  DWORD                IndexOfPnr;
  HANDLE               PrHeapHdl;

  *pNumAddKeys = 0;             //init to 0
  PrHeapHdl = GetProcessHeap();

   /*
   *  Open the key (PARTNERS)
   */
   ErrStat = OpenKey(PARTNERS_E_KEY, NULL, NULL, NULL, FALSE);

   if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
   {
        return(ErrStat);
   }

   //
   // Open the Pull/Push key
   //
   ErrStat = OpenKey(KeyType_e, NULL, &KeyHdl, NULL, FALSE);
   if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
   {
        CloseReqKey();
        return(ErrStat);
   }
   else   //key was successfully opened
   {

        /*
         *   Query the key.  The subkeys are IP addresses of PULL
         *   partners.
        */
        GetKeyInfo(
                        KeyHdl,
                        &NoOfPnrs,
                        &NoOfVals   //ignored
                      );

        if (NoOfPnrs == 0)
        {
                *ppAddKey = NULL;

        }
        else
        {

                 //
                 // Allocate buffer big enough to hold data for
                 // the number of subkeys found under the PULL key
                 //
                 BuffSize  = sizeof(ADD_KEY_T) * NoOfPnrs;
                 *ppAddKey = HeapAlloc(
                                        PrHeapHdl,
                                        HEAP_NO_SERIALIZE |
                                          HEAP_GENERATE_EXCEPTIONS |
                                          HEAP_ZERO_MEMORY,
                                         BuffSize
                                     );
                if (NULL == *ppAddKey) {
                    
                    return SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
                }
                pAddKey   = *ppAddKey;
                pAddKeySave = pAddKey;

                /*
                 *   For each key, get the values
                */
                for(
                        IndexOfPnr = 0;
                        IndexOfPnr < NoOfPnrs;
                        IndexOfPnr++
                         )
                {
                     KeyNameSz = sizeof(KeyName);  //init before every call
                     RetVal = RegEnumKeyEx(
                                KeyHdl,             //handle of Push/Pull key
                                IndexOfPnr,        //key
                                KeyName,
                                &KeyNameSz,
                                NULL,                //reserved
                                NULL,          //don't need class name
                                NULL,          //ptr to var. to hold class name
                                &LastWrite     //not looked at by us
                                );

                     if (RetVal != ERROR_SUCCESS)
                     {
                                break;
                     }

#ifdef UNICODE
                     if (wcstombs(AscKeyName, KeyName, KeyNameSz) == -1)
                        {
                                DBGPRINT0(ERR,
                           "Conversion not possible in the current locale\n");
                        }
                        AscKeyName[KeyNameSz] = EOS;

NONPORT("Call a comm function to do this")
                        pAddKey->IpAdd = inet_addr(AscKeyName);
                        strcpy(pAddKey->asIpAddress, AscKeyName);
#else
                        pAddKey->IpAdd = inet_addr(KeyName);
                        strcpy(pAddKey->asIpAddress, KeyName);
#endif


                        //
                        // inet_addr returns bytes in network byte order
                        // (Left to
                        // Right).  Let us convert this into host order.  This
                        // will avoid confusion later on. All formatting
                        // functions
                        // expect address to be in host order.
                        //
                        pAddKey->IpAdd = ntohl( pAddKey->IpAdd );

                        RetVal = RegOpenKeyEx(
                                                KeyHdl,
                                                KeyName,
                                                0,        //reserved; must be 0
                                                KEY_READ,
                                                &SubKey
                                                    );

                        if (RetVal != ERROR_SUCCESS)
                        {
                                CloseReqKey();

                                HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, 
                                            *ppAddKey);
                                *ppAddKey = NULL;

                                return(SNMP_ERRORSTATUS_GENERR);
                        }


                        if (KeyType_e == PULL_E_KEY)
                        {

                           //
                           // Read in specific time for replication if one
                           // has been specified
                           //
                           GetSpTimeData(SubKey, pAddKey);

                           Sz = sizeof(pAddKey->TimeInterval);
                           RetVal = RegQueryValueEx(
                                               SubKey,
                                               WINSCNF_RPL_INTERVAL_NM,
                                               NULL,        //reserved; must be NULL
                                               &ValTyp,
                                               (LPBYTE)&(pAddKey->TimeInterval),
                                               &Sz
                                                );

                           if (RetVal != ERROR_SUCCESS)
                           {
                                pAddKey->TimeInterval              = 0;
                                pAddKey->fTimeIntOrUpdCntSet =  FALSE;
                           }
                           else  // a value was read in
                           {
                                pAddKey->fTimeIntOrUpdCntSet =  TRUE;
                           }
                           Sz = sizeof(pAddKey->MemberPrec);
                           RetVal = RegQueryValueEx(
                                               SubKey,
                                               WINSCNF_MEMBER_PREC_NM,
                                               NULL,        //reserved; must be NULL
                                               &ValTyp,
                                               (LPBYTE)&(pAddKey->MemberPrec),
                                               &Sz
                                                );

                           if (RetVal != ERROR_SUCCESS)
                           {
                                pAddKey->MemberPrec              = 0;
                           }
                        }
                        else  // it is a PUSH record
                        {

                                //
                                // Currently, we don't support periodic
                                // or specific time replication for Push
                                // records
                                //

                                Sz = sizeof(pAddKey->UpdateCount);
                                RetVal = RegQueryValueEx(
                                                SubKey,
                                                WINSCNF_UPDATE_COUNT_NM,
                                                NULL,
                                                &ValTyp,
                                                (LPBYTE)&(pAddKey->UpdateCount),
                                                &Sz
                                                        );

                                if (RetVal != ERROR_SUCCESS)
                                {
                                    pAddKey->UpdateCount          = 0;
                                    pAddKey->fTimeIntOrUpdCntSet =  FALSE;
                                }
                                else
                                {
                                     pAddKey->fTimeIntOrUpdCntSet =  TRUE;
                                }


                        }

                        pAddKey->NoOfRpls      = 0;
                        pAddKey->NoOfCommFails = 0;
                        WINS_ASSIGN_INT_TO_VERS_NO_M(pAddKey->VersNo, 0);
                        RegCloseKey(SubKey);


                        pAddKey++;
                 } // end of for {..} for looping over subkeys of PULL

                 NoOfPnrs = IndexOfPnr;

                 /*
                  * Close the  key
                 */
         //        RegCloseKey(KeyHdl);
   } //end of else  (key could not be opened)


   if ((NoOfPnrs > 0) && (KeyType_e == PULL_E_KEY))
   {
          DWORD                    Status;
          DWORD                    i, j;
          WINSINTF_RESULTS_NEW_T   ResultsN;
          WINSINTF_RESULTS_T       Results;
          handle_t                 BindHdl;
          PWINSINTF_RPL_COUNTERS_T pTmp;
          PWINSINTF_ADD_VERS_MAP_T pTmp2;
          BOOL                     fOld = FALSE;

//          pAddKey = *ppAddKey;
          BindHdl = WinsBind(&sBindData);

          ResultsN.WinsStat.NoOfPnrs = 0;
          ResultsN.WinsStat.pRplPnrs = NULL;
          ResultsN.pAddVersMaps = NULL;

          if ((Status = WinsStatusNew(BindHdl, WINSINTF_E_STAT, &ResultsN)) ==
                         RPC_S_PROCNUM_OUT_OF_RANGE)
          {
              Results.WinsStat.NoOfPnrs = 0;
              Results.WinsStat.pRplPnrs = NULL;
              Status = WinsStatus(BindHdl, WINSINTF_E_STAT, &Results);
              fOld = TRUE;
          }
PERF("Can be speeded up by restructuring the data structure and code on the")
PERF("Wins side")

          if (Status == WINSINTF_SUCCESS)
          {
                DWORD NoOfRplPnrs;
                DWORD NoOfOwners;
                //
                // Get the stats for comm. with pnrs.   For this we
                // compare each member that we found in the registry
                // with all members returned in the WinsStat structure
                // until there is a match.  If there is no match, we
                // make the values of the stats 0.
                //
                NoOfRplPnrs   = fOld ? Results.WinsStat.NoOfPnrs :
                                        ResultsN.WinsStat.NoOfPnrs;
                if (NoOfRplPnrs > 0)
                {
                  pTmp = fOld ? Results.WinsStat.pRplPnrs :
                                ResultsN.WinsStat.pRplPnrs;

                  for (j=0; j < NoOfRplPnrs; j++, pTmp++)
                  {
                        pAddKey = pAddKeySave;  //init to the first element
                        for (i = 0; i < NoOfPnrs; i++, pAddKey++)
                        {
                           if (pAddKey->IpAdd == pTmp->Add.IPAdd)
                           {

                                pAddKey->NoOfRpls = pTmp->NoOfRpls;
                                pAddKey->NoOfCommFails =
                                                pTmp->NoOfCommFails;
                                break;
                           }
                        }

                  }

                  // WinsFreeMem(fOld ? Results.WinsStat.pRplPnrs : ResultsN.WinsStat.pRplPnrs); // deallocation at the end of the if branch - bug #187206
                 }

                 //
                 // Add the highest vers. no. for each pnr
                 //
                 pTmp2 = fOld ? &Results.AddVersMaps[1] :
                               (ResultsN.pAddVersMaps + 1);

                 NoOfOwners = fOld ? Results.NoOfOwners : ResultsN.NoOfOwners;

NOTE("This is an assumption that we should not rely on in the future")
                  //
                  // We start from 1 since 0 is always the local WINS.
                  //
                  for (i = 1; i < NoOfOwners; i++, pTmp2++)
                  {
                        pAddKey = pAddKeySave;
                        for (j = 0; j < NoOfPnrs; j++, pAddKey++)
                        {
                           if (pAddKey->IpAdd == pTmp2->Add.IPAdd)
                           {
                                pAddKey->VersNo = pTmp2->VersNo;
                                break;
                           }
                        }
                  }
                  if (!fOld)
                  {
                    WinsFreeMem( ResultsN.pAddVersMaps);
                  }
                  WinsFreeMem( fOld? Results.WinsStat.pRplPnrs : ResultsN.WinsStat.pRplPnrs );
         }

         WinsUnbind(&sBindData, BindHdl);

     }
     if (NoOfPnrs > 1)
     {
        qsort((LPVOID)*ppAddKey,(size_t)NoOfPnrs,sizeof(ADD_KEY_T),CompareAdd );
    }

 }
     CloseReqKey();
     *pNumAddKeys = NoOfPnrs;
     if ((*pNumAddKeys == 0) && (*ppAddKey != NULL))
     {
          HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, *ppAddKey);
          *ppAddKey = NULL;
     }
     return (ErrStat);
} // EnumAddKeys



UINT
GetKeyInfo(
        IN  HKEY                   Key,
        OUT LPDWORD                  pNoOfSubKeys,
        OUT LPDWORD                pNoOfVals
        )

/*++

Routine Description:
        This function is called to get the number of subkeys under a key

Arguments:
        Key         - Key whose subkey count has to be determined
        KeyType_e
        pNoOfSubKeys

Externals Used:
        None


Return Value:

        None
Error Handling:

Called by:
        GetPnrInfo()

Side Effects:

Comments:
        None
--*/

{
          TCHAR    ClsStr[40];
          DWORD    ClsStrSz = sizeof(ClsStr);
          DWORD    LongestKeyLen;
          DWORD    LongestKeyClassLen;
          DWORD    LongestValueNameLen;
          DWORD    LongestValueDataLen;
          DWORD    SecDesc;
        LONG         RetVal;

          FILETIME LastWrite;
        UINT  ErrStat = SNMP_ERRORSTATUS_NOERROR;
          /*
                Query the key.
          */
          RetVal = RegQueryInfoKey(
                        Key,
                        ClsStr,
                        &ClsStrSz,
                        NULL,                        //must be NULL, reserved
                        pNoOfSubKeys,
                        &LongestKeyLen,
                        &LongestKeyClassLen,
                        pNoOfVals,
                        &LongestValueNameLen,
                        &LongestValueDataLen,
                        &SecDesc,
                        &LastWrite
                                );

          if (RetVal != ERROR_SUCCESS)
          {
                ErrStat = SNMP_ERRORSTATUS_GENERR;
        }
        return (ErrStat);
}


VOID
GetSpTimeData(
        HKEY                  SubKey,
        PADD_KEY_T          pAddKey
)
/*++

Routine Description:
        This function is called to get the specific time and period information
        for a PULL/PUSH record.

Arguments:
        SubKey   - Key of a WINS under the Pull/Push key

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_NO_SP_TIME

Error Handling:

Called by:
        GetPnrInfo

Side Effects:

Comments:
        None
--*/

{
          DWORD     ValTyp;
        DWORD          Sz;
        LONG          RetVal;


        pAddKey->fSpTimeSet = FALSE;

FUTURES("Do internationalization of strings here")

            Sz = sizeof(pAddKey->asSpTime);
            RetVal = RegQueryValueEx(
                             SubKey,
                             WINSCNF_SP_TIME_NM,
                             NULL,        //reserved; must be NULL
                             &ValTyp,
                             pAddKey->asSpTime,
                             &Sz
                                );

//PERF(If memory is initialized to 0, we don't need to do the following
            //
            // If the user has not specifed a specific time, then we use
            // the current time as the specific time.  For current time,
            // the interval is 0
            //
            if (RetVal == ERROR_SUCCESS)
            {
                pAddKey->fSpTimeSet = TRUE;
            }
            else
            {
                pAddKey->asSpTime[0] = EOS;
            }

            return;
}

int
__cdecl
CompareAdd(
        const VOID *pKey1,
        const VOID *pKey2
        )

{
        const PADD_KEY_T        pAddKey1 = (PADD_KEY_T)pKey1;
        const PADD_KEY_T        pAddKey2 = (PADD_KEY_T)pKey2;

        return(pAddKey1->IpAdd - pAddKey2->IpAdd);
}

UINT
GetNextVar(
        IN RFC1157VarBind *pVarBind,
        IN MIB_ENTRY          *pMibPtr
)
{
       UINT                ErrStat;

       while (pMibPtr != NULL)
       {
         if (pMibPtr->MibNext != NULL)
         {
            //
            // Setup var bind name of NEXT MIB variable
            //
            SNMP_oidfree( &pVarBind->name );
            SNMP_oidcpy( &pVarBind->name, &MIB_OidPrefix );
            SNMP_oidappend( &pVarBind->name, &pMibPtr->MibNext->Oid );

            //
            // If the func. ptr is  NULL and the type of the mib variable
            // is anything but OPAQUE, call function to process the
            // MIB variable
            //
            if (
                 (pMibPtr->MibNext->MibFunc != NULL)
                        &&
                 (pMibPtr->MibNext->Type !=  ASN_RFC1155_OPAQUE)
               )

            {
                ErrStat = (*pMibPtr->MibNext->MibFunc)( MIB_GETFIRST,
                                                pMibPtr->MibNext, pVarBind );
                if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
                {
                        goto Exit;
                }
                break;
            }
            else
            {
                pMibPtr = pMibPtr->MibNext;
            }
          }
          else
          {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            break;
          }
         }

         if (pMibPtr == NULL)
         {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
         }
Exit:
        return(ErrStat);
}

UINT
EnumDFValues(
        PDATAFILE_INFO_T                *ppDFValues,
        LPDWORD                                pNumDFValues
          )

/*++

Routine Description:
        This function gets the names of all the datafiles that need to
        be used for initializing WINS.

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        LONG             RetVal;
        DWORD            BuffSize;
        STATUS          RetStat = WINS_SUCCESS;
        DWORD          NoOfSubKeys;
        DWORD          NoOfDFValues;
        UINT          ErrStat;
        DWORD          n;

        *pNumDFValues = 0;
        *ppDFValues = NULL;
        n = 0;
        ErrStat = OpenKey(PARAMETERS_E_KEY, NULL, NULL, NULL, FALSE);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
                return(ErrStat);
        }
        ErrStat = OpenKey(DATAFILES_E_KEY, NULL, &sDatafilesKey, NULL, FALSE);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
                CloseReqKey();
                return(ErrStat);
        }

try {
        //
        // Get the count of data files listed under the DATAFILES
        // key
        //
        GetKeyInfo(
                        sDatafilesKey,
                        &NoOfSubKeys,  //ignored
                        &NoOfDFValues
                  );

        if (NoOfDFValues > 0)
        {

                DWORD                          Index;
                PDATAFILE_INFO_T pTmp;
#if 0
                TCHAR ValNmBuff[MAX_PATH];
#endif
                DWORD ValNmBuffSz;


                  //
                  // Allocate buffer big enough to hold data for
                // the number of values found under the Datafiles key
                  //
                  BuffSize = DATAFILE_INFO_SZ * NoOfDFValues;
                    pTmp          = HeapAlloc(
                                GetProcessHeap(),
                                HEAP_NO_SERIALIZE |
                                HEAP_GENERATE_EXCEPTIONS |
                                HEAP_ZERO_MEMORY,
                                BuffSize
                                   );

                if (pTmp != NULL)
                {
                        *ppDFValues = pTmp;
                }
                else
                {
                        Index = 0;
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                        goto Exit;
                }

                   /*
                    *   Get the values
                     */
                     for(
                        Index = 0, n = 0;
                        Index <  NoOfDFValues;
                        Index++
                         )
                {
                        ValNmBuffSz = sizeof(pTmp->ValNm);  //init before
                                                            // every call
                        BuffSize  = WINSMIB_FILE_INFO_SIZE;
                          RetVal = RegEnumValue(
                                    sDatafilesKey,
                                    Index,                        //value index
                                    pTmp->ValNm,
                                    &ValNmBuffSz,
                                    (LPDWORD)NULL,                //reserved
                                    &pTmp->StrType,
                                    (LPBYTE)(pTmp->FileNm),//ptr to var. to
                                                           //hold name of
                                                           //datafile
                                    &BuffSize        //not looked at by us
                                            );
                        if (RetVal != ERROR_SUCCESS)
                        {
                                continue;
                        }
                        pTmp->FileNm[BuffSize] = EOS;

                        //
                        // if StrType is not REG_SZ or REG_EXPAND_SZ, go to
                        // the next  Value
                        //
                        if  (
                                (pTmp->StrType != REG_EXPAND_SZ)
                                        &&
                                   (pTmp->StrType != REG_SZ)
                                )
                        {
                                continue;
                        }

                        n++;
                        pTmp = (PDATAFILE_INFO_T)((LPTCH)pTmp +
                                                      DATAFILE_INFO_SZ);
                }

Exit:
                if (n > 1)
                {
                          qsort(
                        (LPVOID)*ppDFValues,
                        (size_t)n,
                        sizeof(DATAFILE_INFO_T),
                        CompareIndexes
                                );
                }
                *pNumDFValues = n;
        }
 } // end of try ..
except (EXCEPTION_EXECUTE_HANDLER) {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "WINSMIB: WinsCnfGetNamesOfDataFiles. Exception = (%d).\n",
                    GetExceptionCode()
                    ));
                ErrStat = SNMP_ERRORSTATUS_GENERR;
        }

        CloseReqKey();

        if ((*pNumDFValues == 0) && (*ppDFValues != NULL))
        {
                HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, *ppDFValues);
        }
        return(ErrStat);
}


UINT
DFGet(
       IN RFC1157VarBind                  *VarBind,
       IN DWORD                           NumValues,
       IN LPVOID                          pValues
    )
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD                Index;
        DWORD                i;
        DWORD           NumDFValues = NumValues;
        PDATAFILE_INFO_T         pDFValues;
        PVOID       pDFValuesSv;
        INT                iValNm;

        //
        // Get the index of the file to get.  If the Index is more than
        // the # of files, we return an error.
        //
        Index =  VarBind->name.ids[VarBind->name.idLength - 1];
        if (Index == 0)
        {
            return(SNMP_ERRORSTATUS_NOSUCHNAME);
        }

        EnumDFValues(&pDFValues, &NumDFValues);
        pDFValuesSv = pDFValues;
        for (i=0; i < NumDFValues; i++, pDFValues++)
        {
           //
           // atoi returns a 0 if it can not do a conversion, so if
           // somebody other than an snmp agent messes with the
           // registry names and introduces alphabets, atoi will return
           // 0 and we will not see a match
           //
           iValNm = atoi(pDFValues->ValNm);
           if (iValNm == (INT)Index)
           {
                break;
           }

        }
        if (i == NumDFValues)
        {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
        }

        //
        // Initialize VarBind fields with the type, length, and value
        //
        VarBind->value.asnType        = ASN_RFC1213_DISPSTRING;
        VarBind->value.asnValue.string.length =
                                strlen((LPSTR)(pDFValues->FileNm));

        if ( NULL ==  (VarBind->value.asnValue.string.stream =
                                   SNMP_malloc(VarBind->value.asnValue.string.length *
                                   sizeof(CHAR))) )
        {
                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                goto Exit;
        }

        memcpy( VarBind->value.asnValue.string.stream,
                                       (LPSTR)(pDFValues->FileNm),
                                       VarBind->value.asnValue.string.length );

        VarBind->value.asnValue.string.dynamic = TRUE;

Exit:
        //
        // If we allocated memory for storing datafiles info, deallocate it
        // now
        //
        if (pDFValuesSv != NULL)
        {
                HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pDFValuesSv);
        }
        return(ErrStat);
}

UINT
DFGetNext(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY          *MibPtr,
       IN KEY_TYPE_E         KeyType_e
          )
{
     DWORD          NumDFValues;
     INT            Index;
     PDATAFILE_INFO_T  pDFValues;
     PVOID             pDFValuesSv;
     UINT         ErrStat = SNMP_ERRORSTATUS_NOERROR;
     DWORD          i;
     INT         iValNm;
     BOOL         fMatch = FALSE;

     UNREFERENCED_PARAMETER(KeyType_e);
     //
     // Read in all ip address keys. For each key, the values of its fields
     // is stored in the PDATAFILE_INFO structure.  The number of
     // files found is stored in NumDFValues
     //
     EnumDFValues(&pDFValues, &NumDFValues);
     pDFValuesSv = pDFValues;

     //
     // Check if the name passed matches any in the table (i.e. table of
     // of ADD_KEY_T structures.  If there is a match, the address
     // of the ip address key and the matching field's no. are returned
     //
     Index =  VarBind->name.ids[DF_OIDLEN + 1];
//     Index =  VarBind->name.ids[VarBind->name.idLength - 1];
     for (i=0; i < NumDFValues; i++, pDFValues++)
     {
           iValNm = atoi(pDFValues->ValNm);
           if (iValNm == Index)
           {
                fMatch = TRUE;
                break;
           }
           if (iValNm > Index)
           {
                break;
           }
     }
     //
     // if the index specified is higher than all existing indices or if
     // match was with the last entry in the list, get to next var.
     //
     if ((i == 0) || (i >= (NumDFValues - 1)))
     {
            if (pDFValuesSv != NULL)
            {
              HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pDFValuesSv);
            }
            return(GetNextVar(VarBind, MibPtr));
     }

     //
     // Since the operation is GET_NEXT, get the next Value number
     // If there is no next file, we call the MibFunc of the next MIB entry.
     // Put the index of the next datafile
     //
     if (fMatch)
     {
        ++pDFValues;
     }
     VarBind->name.ids[VarBind->name.idLength - 1] = atoi(pDFValues->ValNm);

     //
     // Get the value
     //
        //
        // Initialize VarBind fields with the type, length, and value
        //
        VarBind->value.asnType        = ASN_RFC1213_DISPSTRING;
        VarBind->value.asnValue.string.length =
                                strlen((LPSTR)(pDFValues->FileNm));

        if ( NULL ==  (VarBind->value.asnValue.string.stream =
                                   SNMP_malloc(VarBind->value.asnValue.string.length *
                                   sizeof(CHAR))) )
        {
                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                goto Exit;
        }

        memcpy( VarBind->value.asnValue.string.stream,
                                       (LPSTR)(pDFValues->FileNm),
                                       VarBind->value.asnValue.string.length );

Exit:
      
     if (pDFValuesSv != NULL)
     {
        HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pDFValuesSv);
     }
     return(ErrStat);
}

UINT
DFGetFirst(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY        *MibPtr,
       IN KEY_TYPE_E        KeyType_e
        )
{

        PDATAFILE_INFO_T pDFValues;
        DWORD           NumDFValues;
        UINT           TableEntryId[2];
        AsnObjectIdentifier        TableEntryOid = { OID_SIZEOF(TableEntryId),
                                                        TableEntryId };
        UINT   ErrStat = SNMP_ERRORSTATUS_NOERROR;

        UNREFERENCED_PARAMETER(KeyType_e);

        //
        // Get all the address key information
        //
PERF("Get the first entry only. Since we won't have very many entries, this")
PERF("is ok.  When a cache is implemented, this will serve to populate the")
PERF("cache")
             EnumDFValues(&pDFValues, &NumDFValues);

        //
        // If there is no entry in the table, go to the next MIB variable
        //
        if (NumDFValues == 0)
        {
                 return(GetNextVar(VarBind, MibPtr));
        }


        //
        // Write the object Id into the binding list and call get
        // func
        //
        SNMP_oidfree( &VarBind->name );
        SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
        SNMP_oidappend( &VarBind->name, &MibPtr->Oid );

        //
        // The fixed part of the objid is correct. Update the rest.
        //

        TableEntryId[0] = 2;        //put 2 to access the datafile name
#if 0
        TableEntryId[1] = 1;        //put 1 (for the datafile index).  This is
                                //used for indexing the row of the table
#endif
        TableEntryId[1] = atoi(pDFValues->ValNm);
        SNMP_oidappend( &VarBind->name, &TableEntryOid );

        //
        // Initialize VarBind fields with the type, length, and value
        //
        VarBind->value.asnType        = ASN_RFC1213_DISPSTRING;
        VarBind->value.asnValue.string.length =
                                strlen((LPSTR)(pDFValues->FileNm));

        if ( NULL ==  (VarBind->value.asnValue.string.stream =
                                   SNMP_malloc(VarBind->value.asnValue.string.length *
                                   sizeof(CHAR))) )
        {
                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                goto Exit;
        }

        (void)memcpy( VarBind->value.asnValue.string.stream,
                                       (LPSTR)(pDFValues->FileNm),
                                       VarBind->value.asnValue.string.length );
#if 0
        //
        // get the file name
        //
        ErrStat = DFGet(VarBind, NumDFValues, pDFValues);
#endif
Exit:
        HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pDFValues);
        return(ErrStat);
}
UINT
DFSet(
       IN RFC1157VarBind *pVarBind
)
{
        UINT                                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD                           Index;
        DATAFILE_INFO_T                DFValue;
#if 0
        PDATAFILE_INFO_T        pDFValues;
#endif

             Index =  pVarBind->name.ids[pVarBind->name.idLength - 1];

             if (Index == 0)
             {
            return(SNMP_ERRORSTATUS_NOSUCHNAME);
             }

        if ( pVarBind->value.asnType != ASN_RFC1213_DISPSTRING)
        {
                return(SNMP_ERRORSTATUS_BADVALUE);
        }

#if 0
               // The storage must be adequate to contain the new
        // string including a NULL terminator.
               memcpy( (LPSTR)DFValue.FileNm,
                            pVarBind->value.asnValue.string.stream,
                            pVarBind->value.asnValue.string.length );

        ((LPSTR)DFValue.FileNm)[pVarBind->value.asnValue.string.length] = '\0';
#endif

        ErrStat = WriteDFValue(pVarBind, &DFValue, Index);
        return(ErrStat);

} //DFSet

UINT
WriteDFValue(
        IN RFC1157VarBind          *pVarBind,
        PDATAFILE_INFO_T          pDFValue,
        DWORD                         Index
        )
{

//
// remove pDFValue as an argument. Use local
//
        TCHAR   ValNmBuff[MAX_PATH];
        DWORD   ValNmBuffSz         = MAX_PATH;
        UINT    ErrStat         = SNMP_ERRORSTATUS_NOERROR;
        LONG          RetVal;

        if (pVarBind->value.asnType != ASN_RFC1213_DISPSTRING)
        {
                return(SNMP_ERRORSTATUS_BADVALUE);
        }

        if (
                pVarBind->value.asnValue.string.stream[0] == '%')
        {
                pDFValue->StrType = REG_EXPAND_SZ;
        }
        else
        {
                pDFValue->StrType = REG_SZ;
        }

        //
        // Open the Parameters key and the Datafiles key under that
        //
        ErrStat = OpenKey(PARAMETERS_E_KEY, NULL, NULL, NULL, TRUE);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
           return(ErrStat);
        }
        ErrStat = OpenKey(DATAFILES_E_KEY, NULL, NULL, NULL, TRUE);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
           return(ErrStat);
        }

        //
        // If the index is within the range that we have in the registry,
        // let us get the name of the value that stores the datafile name
        //
        // We get the name because we don't know what it is.  If we have
        // to overwrite the name, we need to know what it is first.
        //
        sprintf(ValNmBuff, "%d",  Index);

        //
        // Set the name
        //
        RetVal = RegSetValueEx(
                                sDatafilesKey,
                                ValNmBuff,
                                0,         //reserved -- must be 0
                                pDFValue->StrType,
                                pVarBind->value.asnValue.string.stream,
                                pVarBind->value.asnValue.string.length
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "WINSMIB: Could not set value of %s.\n",
                    pVarBind->value.asnValue.string.stream
                    ));
                ErrStat = SNMP_ERRORSTATUS_GENERR;
        }


        //
        // Let us close the keys that we opened/created
        //
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "WINSMIB: Closing sParametersKey 0x%08lx (fKeyOpen=%s).\n",
            sParametersKey, sfParametersKeyOpen ? "TRUE" : "FALSE"
            ));
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "WINSMIB: Closing sDatafilesKey 0x%08lx (fKeyOpen=%s).\n",
            sDatafilesKey, sfDatafilesKeyOpen ? "TRUE" : "FALSE"
            ));
       CloseReqKey();
/*
        RegCloseKey(sParametersKey);
        RegCloseKey(sDatafilesKey);
*/

        return(ErrStat);
}

//
// HandleCmd
//    Performs specific actions on the different Cmd MIB variable
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
UINT HandleCmd(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN RFC1157VarBind *VarBind
        )

{
WINSINTF_RESULTS_T         Results;
handle_t                BindHdl;
DWORD                        Status;
UINT                           ErrStat = SNMP_ERRORSTATUS_NOERROR;

   switch ( Action )
   {
      case MIB_SET:
                   if ((ErrStat = MIB_leaf_func( Action, MibPtr, VarBind ))
                        == SNMP_ERRORSTATUS_NOERROR)
                {

                        ErrStat = ExecuteCmd(MibPtr);
                }
                break;

      case MIB_GETFIRST:
                //
                // fall through
                //
      case MIB_GET:
                if (
                        (MibPtr->Storage == &MIB_NoOfWrkThdsStore)
                                        ||
                        (MibPtr->Storage == &MIB_PriorityClassStore)
                                        ||
                        (MibPtr->Storage == &MIB_MaxVersNo_LowWordStore)
                                        ||
                        (MibPtr->Storage == &MIB_MaxVersNo_HighWordStore)

                   )

                {
                  if (!fWinsMibWinsStatusCnfCalled)
                  {
                    Results.WinsStat.NoOfPnrs = 0;
                    Results.WinsStat.pRplPnrs = NULL;
                       BindHdl                 = WinsBind(&sBindData);
                    Status = WinsStatus(BindHdl, WINSINTF_E_CONFIG, &Results);
                    if (Status != WINSINTF_SUCCESS)
                    {
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                        WinsUnbind(&sBindData, BindHdl);
                        goto Exit;
                    }

                    MIB_NoOfWrkThdsStore   = Results.NoOfWorkerThds;
                    if (Results.WinsPriorityClass == NORMAL_PRIORITY_CLASS)
                    {
                       MIB_PriorityClassStore = 0;
                    }
                    else
                    {
                       MIB_PriorityClassStore = 1;
                    }
                    MIB_MaxVersNo_LowWordStore = Results.AddVersMaps[0].VersNo.LowPart;
                    MIB_MaxVersNo_HighWordStore = Results.AddVersMaps[0].VersNo.HighPart;
                    fWinsMibWinsStatusCnfCalled = TRUE;
                    WinsUnbind(&sBindData, BindHdl);

                  }
                }
                      //
                      // fall through
                      //
      case MIB_GETNEXT:

        //
        // Call the more generic function to perform the action
        //
        ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
        break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
         goto Exit;
  } // switch

Exit:
   return ErrStat;
} // HandleCmd

UINT
ExecuteCmd(
  IN MIB_ENTRY *pMibPtr
        )
{
        UINT                        ErrStat = SNMP_ERRORSTATUS_NOERROR;
        WINSINTF_ADD_T                WinsAdd;
        LPBYTE                        pStorage;
        handle_t                BindHdl;
        DWORD                        Status;
        WinsAdd.Len        = 4;
        WinsAdd.Type        = 0;


           BindHdl                 = WinsBind(&sBindData);

        //
        // For Performance, arrange the following in the order of
        // expected frequency.
        //
        if ( pMibPtr->Storage  == &MIB_PullTriggerStore )
        {
                pStorage = MIB_PullTriggerStore;
                WinsAdd.IPAdd = ntohl(*(DWORD*)pStorage);
                //NMSMSGF_RETRIEVE_IPADD_M(pStorage, WinsAdd.IPAdd);
                Status = WinsTrigger(BindHdl, &WinsAdd, WINSINTF_E_PULL);
                if (Status != WINSINTF_SUCCESS)
                {
                        int backupSize = sizeof(MIB_PullTriggerStore) / 2;
                        // setting back the original value
                        memcpy( (LPSTR)pMibPtr->Storage, (LPSTR)pMibPtr->Storage + backupSize, backupSize);
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_PushTriggerStore )
        {
                pStorage = MIB_PushTriggerStore;
                WinsAdd.IPAdd = ntohl(*(DWORD*)pStorage);
                //NMSMSGF_RETRIEVE_IPADD_M(pStorage, WinsAdd.IPAdd);
                Status = WinsTrigger(BindHdl, &WinsAdd, WINSINTF_E_PUSH);
                if (Status != WINSINTF_SUCCESS)
                {
                        int backupSize = sizeof(MIB_PushTriggerStore) / 2;
                        // setting back the original value
                        memcpy( (LPSTR)pMibPtr->Storage, (LPSTR)pMibPtr->Storage + backupSize, backupSize);
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_DoScavengingStore )
        {
                if (MIB_DoScavengingStore == 1)
                {
                  Status = WinsDoScavenging(BindHdl);
                  if (Status != WINSINTF_SUCCESS)
                  {
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                  }
                }
                else
                {
                        if (MIB_DoScavengingStore != 0)
                        {
                                MIB_DoScavengingStore = 0;
                                ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        }
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_DoStaticInitStore )
        {
                LPBYTE pDataFile = MIB_DoStaticInitStore;
                WCHAR UcDataFile[WINSMIB_FILE_INFO_SIZE];
                if (MIB_DoStaticInitStore[0] == EOS)
                {
                        UcDataFile[0] = (WCHAR)NULL;
                }
                else
                {
                        MultiByteToWideChar(        CP_ACP, 0,
                                                pDataFile, -1, UcDataFile,
                                                WINSMIB_FILE_INFO_SIZE
                                           );
                }
                Status = WinsDoStaticInit(BindHdl, UcDataFile, FALSE);
                if (Status != WINSINTF_SUCCESS)
                {
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_NoOfWrkThdsStore )
        {
                if (
                        (MIB_NoOfWrkThdsStore < 1)
                                ||
                        (MIB_NoOfWrkThdsStore > 4)
                   )
                {
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        goto Exit;
                }
                Status = WinsWorkerThdUpd(BindHdl, (DWORD)MIB_NoOfWrkThdsStore);
                if (Status != WINSINTF_SUCCESS)
                {
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_PriorityClassStore )
        {
                if (
                        (MIB_PriorityClassStore < 0)
                                ||
                        (MIB_PriorityClassStore > 1)

                   )
                {
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        goto Exit;
                }
                Status = WinsSetPriorityClass(
                                BindHdl,
                                (DWORD)MIB_PriorityClassStore);
                if (Status != WINSINTF_SUCCESS)
                {
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_ResetCountersStore )
        {
                Status = WinsResetCounters(BindHdl);
                if (Status != WINSINTF_SUCCESS)
                {
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_DeleteDbRecsStore )
        {
                WINSINTF_VERS_NO_T        MaxVersNo, MinVersNo;
                WINS_ASSIGN_INT_TO_VERS_NO_M(MaxVersNo, 0);
                WINS_ASSIGN_INT_TO_VERS_NO_M(MinVersNo, 0);

                pStorage = MIB_DeleteDbRecsStore;
                WinsAdd.IPAdd = ntohl(*(DWORD*)pStorage);
                //NMSMSGF_RETRIEVE_IPADD_M(pStorage, WinsAdd.IPAdd);
                Status = WinsDelDbRecs(BindHdl, &WinsAdd, MinVersNo, MaxVersNo);
                if (Status != WINSINTF_SUCCESS)
                {
                        int backupSize = sizeof(MIB_DeleteDbRecsStore) / 2;
                        // setting back the original value
                        memcpy( (LPSTR)pMibPtr->Storage, (LPSTR)pMibPtr->Storage + backupSize, backupSize);

                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_GetDbRecsStore )
        {
                if (PopulateDRCache() == WINSINTF_SUCCESS)
                {
                        (VOID)time(&sDRCacheInitTime);

                }
                else
                {
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_DeleteWinsStore )
        {

                pStorage = MIB_DeleteWinsStore;
                WinsAdd.IPAdd = ntohl(*(DWORD*)pStorage);
                //NMSMSGF_RETRIEVE_IPADD_M(pStorage, WinsAdd.IPAdd);
                Status = WinsDeleteWins(BindHdl, &WinsAdd);
                if (Status != WINSINTF_SUCCESS)
                {
                    int backupSize = sizeof(MIB_DeleteWinsStore) / 2;
                    // setting back the original value
                    memcpy( (LPSTR)pMibPtr->Storage, (LPSTR)pMibPtr->Storage + backupSize, backupSize);

                    ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;


Exit:
   WinsUnbind(&sBindData, BindHdl);
   return ErrStat;
}


VOID
WinsMibInit(
        VOID
)
{
#if 0
        DWORD           i;
        MIB_ENTRY *pMib;
#endif
        //
        // We use named pipe to communicate with WINS when it is on
        // the same machine since it is faster than TCP/IP.  We don't
        // use LRPC since WINS does not listen on that (to minimize
        // on thread usage)
        //
           sBindData.fTcpIp     =  TRUE;
           sBindData.pServerAdd =  LOCAL_ADD;
           sBindData.pPipeName  =  NULL;
//        InitializeCriticalSection(&WinsMibCrtSec);
#if 0
        pMib = Mib;
        for (i=1; i < (MIB_num_variables + 1); i++, pMib++)
        {
                if (pMib->
                pMib->MibNext = &Mib[i];
        }

        for (i=0; i < NUM_TABLES; i++)
        {

        }
#endif
        return;
}

UINT
DRGet(
       IN RFC1157VarBind *VarBind,
       IN DWORD          FieldParam,
       IN LPVOID         pRowParam
    )
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD           Field;
        PWINSINTF_RECORD_ACTION_T        pRow = NULL;
        DWORD                i, n;
        LPBYTE                pTmp;


        //
        // if the row was passed (for instance from DRGetNext), skip
        // the search part
        //
        if (pRowParam == NULL)
        {
          ErrStat = DRMatch(VarBind, &pRow, &i /*not used*/ , &Field,
                                MIB_GET, NULL);
               if (
                        (ErrStat != SNMP_ERRORSTATUS_NOERROR)
                                ||
                        (pRow == NULL)
                                ||
                        (pRow->State_e == WINSINTF_E_DELETED)
             )
               {
//              bug #235928 - if the first condition in the above if is true, then the
//              derefferencing pRow causes a first chance exception!
//              if (pRow->State_e == WINSINTF_E_DELETED)
                if (ErrStat == SNMP_ERRORSTATUS_NOERROR)
                {
                        ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
                }
                return(ErrStat);
               }
        }
        else
        {
                pRow  = pRowParam;
                Field = FieldParam;
        }

        switch(Field)
        {
                case 1:                //name

                        VarBind->value.asnType        = ASN_OCTETSTRING;
                               VarBind->value.asnValue.string.length = pRow->NameLen;

                               if ( NULL ==
                                    (VarBind->value.asnValue.string.stream =
                                     SNMP_malloc(VarBind->value.asnValue.string.length
                                   )) )
                          {
                                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                                  goto Exit;
                          }

                               memcpy( VarBind->value.asnValue.string.stream,
                                       (LPSTR)(pRow->pName),
                                       VarBind->value.asnValue.string.length );

                               VarBind->value.asnValue.string.dynamic = TRUE;

                        break;
                case 2:                // address(es)
                        VarBind->value.asnType        = ASN_OCTETSTRING;
                        if (
                                (pRow->TypOfRec_e == WINSINTF_E_UNIQUE)
                                          ||
                                (pRow->TypOfRec_e == WINSINTF_E_NORM_GROUP)
                           )
                        {
                                       VarBind->value.asnValue.string.length = 4;
                        }
                        else
                        {
                                       VarBind->value.asnValue.string.length =
                                                4 * pRow->NoOfAdds;
                        }


                               if ( NULL ==
                                    (VarBind->value.asnValue.string.stream =
                                    SNMP_malloc(VarBind->value.asnValue.string.length *
                                   sizeof(char))) )
                          {
                                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                                  goto Exit;
                          }

                        pTmp =  VarBind->value.asnValue.string.stream;

                        if (
                                (pRow->TypOfRec_e == WINSINTF_E_UNIQUE)
                                          ||
                                (pRow->TypOfRec_e == WINSINTF_E_NORM_GROUP)
                           )
                        {
                                NMSMSGF_INSERT_IPADD_M(pTmp,pRow->Add.IPAdd);
                        }
                        else
                        {
                         for (i = 0, n = 0; i < pRow->NoOfAdds/2; i++)
                         {
                                NMSMSGF_INSERT_IPADD_M(pTmp,
                                                (pRow->pAdd + n)->IPAdd);
                                n++;

                                NMSMSGF_INSERT_IPADD_M(pTmp,
                                                (pRow->pAdd + n)->IPAdd);
                                n++;
                         }
                        }
                               VarBind->value.asnValue.string.dynamic = TRUE;
                        break;
                case 3:                // Record Type
                        VarBind->value.asnType        = ASN_INTEGER;
                               VarBind->value.asnValue.number =
                                (AsnInteger)(pRow->TypOfRec_e);
                               break;

                case 4:   //Persistence Type
                        VarBind->value.asnType        = ASN_INTEGER;
                               VarBind->value.asnValue.number =
                                (AsnInteger)pRow->fStatic;

                               break;

                case 5:   //State
                        VarBind->value.asnType        = ASN_INTEGER;
                               VarBind->value.asnValue.number =
                                (AsnInteger)pRow->State_e;

                               break;


                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;

        }
Exit:
        return(ErrStat);
}
UINT
DRGetNext(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY          *MibPtr,
       IN KEY_TYPE_E         KeyType_e
          )
{
     DWORD          OidIndex;
     DWORD         FieldNo;
     UINT         ErrStat = SNMP_ERRORSTATUS_NOERROR;
     DWORD       Index;
     DWORD         i;
     LPBYTE      pNameChar;
     UINT         TableEntryIds[NMSDB_MAX_NAM_LEN];
     BOOL         fFirst;
     AsnObjectIdentifier        TableEntryOid = { OID_SIZEOF(TableEntryIds),
                                                        TableEntryIds };

     PWINSINTF_RECORD_ACTION_T        pRow;


     //
     // If there is no entry in the table, go to the next MIB variable
     //
     if (sRecs.NoOfRecs == 0)
     {
           return(GetNextVar(VarBind, MibPtr));
     }
     //
     // Check if the name passed matches any in the table (i.e. table of
     // of WINSINTF_RECORD_ACTION_T structures.  If there is a match, the
     // address of the structure and the matching field's no. are returned
     //
     ErrStat = DRMatch(VarBind, &pRow, &Index,  &FieldNo, MIB_GETNEXT, &fFirst);
     if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
     {
        return(ErrStat);
     }

     //
     // Since the operation is GETNEXT, get the next name  (i.e. one
     // that is lexicographically bigger.  If there is none, we must increment
     // the field value and move back to the lexically first item in the table
     // If the new field value is more than the largest supported, we call
     // the MibFunc of the next MIB entry.
     //
     // sRecs.NoOfRecs > 0 since otherwise we won't be here.
     //
     //
     // If we are at the last record and this is not that case where no name
     // was passed to us, then increment the field and if it is still within
     // bounds, get the first record in the cache
     //
     //
     if  ((Index == (sRecs.NoOfRecs - 1))  && !fFirst)
     {
                     if (++FieldNo > NO_FLDS_IN_DR)
                {
                    return(GetNextVar(VarBind, MibPtr));
                }
                else
                {
                        Index = 0;
                        pRow  = (PWINSINTF_RECORD_ACTION_T)sRecs.pRow;
                }
     }
     else
     {
         //
         // no name was passed, so we need to get the field of the first
         // record in the table
         //
         if (fFirst)
         {
                pRow = (PWINSINTF_RECORD_ACTION_T)sRecs.pRow;
         }
         else
         {
           //
           // Get the field of the next record in the cache
           //
           Index++;
           pRow++;
         }

         while(pRow->State_e == WINSINTF_E_DELETED)
         {
                     if (Index == (sRecs.NoOfRecs - 1))
                     {
                       if (++FieldNo > NO_FLDS_IN_DR)
                  {
                        return(GetNextVar(VarBind, MibPtr));
                       }
                  else
                  {
                        Index = 0;
                        pRow  = (PWINSINTF_RECORD_ACTION_T)sRecs.pRow;
                  }
                }
                else
                {
                  pRow++;
                  Index++;
                }
         }
      }

      //
      // Write the object Id into the binding list and call get
      // func
      //
      SNMP_oidfree( &VarBind->name );
      SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
      SNMP_oidappend( &VarBind->name, &MibPtr->Oid );

      TableEntryIds[0] = FieldNo;
      OidIndex =  1;
      pNameChar = pRow->pName;

     //
     // The fixed part of the objid is correct. Update the rest.
     //
     for (i = 0; i < pRow->NameLen; i++)
     {
              TableEntryIds[OidIndex++] = (UINT)*pNameChar++;
     }
     TableEntryOid.idLength = OidIndex;
     SNMP_oidappend( &VarBind->name, &TableEntryOid );

     //
     // Get the value
     //
     ErrStat = DRGet(VarBind, FieldNo, pRow);

     return(ErrStat);
}
//
// The rpc function WinsRecordAction has changed in that now it takes
// the address of a pointer.  On return the buffer allocated by RPC has
// to be freed. Modify this function to account for that.  Currently,
// we never call this function so this work is being deferred - 4/28/94.
//
UINT
DRSet(
       IN RFC1157VarBind *VarBind
)
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD           Field;
        LPBYTE                pName;
        DWORD                NameLen;
        PWINSINTF_RECORD_ACTION_T        pRow;
        PWINSINTF_RECORD_ACTION_T        pSvRow;
        DWORD                Index;
        DWORD                FieldNo;
        handle_t        BindHdl;
        DWORD                i;
        BOOL                fFound = FALSE;

        //
        // Extract the field that needs to be set
        //
        Field = VarBind->name.ids[DR_OIDLEN];

        switch(Field)
        {
                //
                // Only the state field is settable
                //
                case 5:
                        if ( VarBind->value.asnType != ASN_INTEGER)
                        {
                                return(SNMP_ERRORSTATUS_BADVALUE);
                        }
                        if (
                                (VarBind->value.asnValue.number != WINSINTF_E_RELEASED)
                                        &&
                                (VarBind->value.asnValue.number != WINSINTF_E_DELETED)
                           )
                        {

                                return(SNMP_ERRORSTATUS_BADVALUE);

                        }

                        if (sRecs.NoOfRecs == 0)
                            return (SNMP_ERRORSTATUS_NOSUCHNAME);

                        NameLen = VarBind->name.idLength - (DR_OIDLEN + 1);
                        if ( NULL ==  (pName = SNMP_malloc(NameLen * sizeof(char))) )
                        {
                            return(SNMP_ERRORSTATUS_GENERR);
                        }


                        ErrStat = DRMatch(VarBind,  &pRow, &Index,  &FieldNo, MIB_SET, NULL);

                        if (ErrStat == SNMP_ERRORSTATUS_NOERROR)
                        {
                            fFound = TRUE;
                        }
                        else
                        {
                            LPBYTE      pNameChar = pRow->pName;
                            DWORD       n = DR_OIDLEN + 1;

                            for (i=0; i<NameLen;i++)
                            {
                                *pNameChar = (BYTE)
                                VarBind->name.ids[n++];
                            }
                            pRow->NameLen        = NameLen;
                        }

                        pRow->fStatic = 1;
                        if ( VarBind->value.asnValue.number ==
                                        WINSINTF_E_RELEASED)
                        {
                           pRow->Cmd_e = WINSINTF_E_RELEASE;

                        }
                        else
                        {
                           pRow->Cmd_e = WINSINTF_E_DELETE;

                        }
                        BindHdl = WinsBind(&sBindData);
                        pSvRow  = pRow;
                        if ( WinsRecordAction(BindHdl, &pSvRow) != WINSINTF_SUCCESS)
                        {
                                ErrStat = SNMP_ERRORSTATUS_GENERR;
                                  goto Exit;
                        }
                        WinsFreeMem(pSvRow->pName);
                        WinsFreeMem(pSvRow->pAdd);
                        WinsFreeMem(pSvRow);
                        pRow->State_e = VarBind->value.asnValue.number;

                               break;

                case(1):
                case(2):
                case(3):
                case(4):
                        ErrStat = SNMP_ERRORSTATUS_READONLY;
                        break;

                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;

        }

Exit:
        WinsUnbind(&sBindData, BindHdl);
        return(ErrStat);
} //DRSet

UINT
DRGetFirst(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY        *MibPtr,
       IN KEY_TYPE_E        KeyType_e
        )
{

        DWORD           OidIndex;
        UINT           TableEntryIds[NMSDB_MAX_NAM_LEN];
        AsnObjectIdentifier        TableEntryOid = { OID_SIZEOF(TableEntryIds),
                                                        TableEntryIds };
           UINT             ErrStat;
        PTUCHAR          pNameChar;
        PWINSINTF_RECORD_ACTION_T        pRow = (PWINSINTF_RECORD_ACTION_T)sRecs.pRow;
        DWORD        i;

        if (sRecs.NoOfRecs == 0)
        {
           return(GetNextVar(VarBind, MibPtr));
        }

        //
        // Write the object Id into the binding list and call get
        // func
        //
        SNMP_oidfree( &VarBind->name );
        SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
        SNMP_oidappend( &VarBind->name, &MibPtr->Oid );

        //
        // The fixed part of the objid is corect. Update the rest.
        //
        //OidIndex = VarBind->name.idLength;

        TableEntryIds[0] = 1;
        OidIndex = 1;
        pNameChar = pRow->pName;
        for (i = 0; i < pRow->NameLen; i++)
        {
              TableEntryIds[OidIndex++] = (UINT)*pNameChar++;
        }
        TableEntryOid.idLength = OidIndex;

        SNMP_oidappend( &VarBind->name, &TableEntryOid );

        ErrStat = DRGet(VarBind, 0, NULL);
        return(ErrStat);
}

UINT
DRMatch(
       IN RFC1157VarBind *VarBind,
       IN PWINSINTF_RECORD_ACTION_T         *ppRow,
       IN LPDWORD         pIndex,
       IN LPDWORD         pField,
       IN UINT                 PduAction,
       OUT LPBOOL         pfFirst
        )
{
        DWORD NameLen;
        BYTE  Name[NMSDB_MAX_NAM_LEN];
        LPBYTE pNameChar = Name;
        DWORD NameIndex = DR_OIDLEN + 1;
        UINT *pTmp = &VarBind->name.ids[NameIndex];
        DWORD i;
        PWINSINTF_RECORD_ACTION_T        pRow = (PWINSINTF_RECORD_ACTION_T)sRecs.pRow;
        UINT        ErrStat = SNMP_ERRORSTATUS_NOERROR;
        INT        CmpVal;

        if (pfFirst != NULL)
        {
                *pfFirst = FALSE;
             }


        NameLen = VarBind->name.idLength - (DR_OIDLEN + 1);
        *pField = VarBind->name.ids[DR_OIDLEN];

        //
        // if a name has been specified, get it into Name array
        //
        if (NameLen > 0)
        {
          for(i=0; i<NameLen; i++)
          {
                *pNameChar++ = (BYTE)*pTmp++;
          }

          //
          // Compare the name with names in the cache (in ascending order)
          //
          for (i=0; i < sRecs.NoOfRecs; i++, pRow++)
          {

                //
                // replace with RtlCompareMemory
                //
                CmpVal = memcmp(Name, pRow->pName, NameLen);

                if (CmpVal == 0)
                {
                          *pIndex = i;
                          *ppRow  = pRow;
                         return(SNMP_ERRORSTATUS_NOERROR);
                }
                else
                {
                        //
                        // Passed in name is lexicographically > than
                        // name being looked at, continue on
                        //
                        if (CmpVal > 0)
                        {
                                continue;
                        }
                        else
                        {
                                //
                                // Passed in name is lexicographically < than
                                // name being looked at, continue on
                                //
                                break;
                        }
                }
          }

          //
          // if the action is not GETNEXT, we return an error, since we
          // did not find a matching name
          //
          if (PduAction != MIB_GETNEXT)
          {
                return(SNMP_ERRORSTATUS_NOSUCHNAME);
          }
          else
          {
                //
                // Either the name is lexicographically > than all names
                // or we reached a name in the list that is lexicographically
                // < it.  In the first case, i needs to be decremented by
                // 1. *ppRow  needs to be initialized to either the last
                // row in the table or to the element before the one we
                // found to be lexicographically greater.
                //
                  *pIndex = i - 1;
                  *ppRow  = --pRow;
                return(SNMP_ERRORSTATUS_NOERROR);
          }

        }
        else  // NameLen == 0
        {
                //
                // The action has got to be GETNEXT (see MIB_DRTable)
                // which means that pfFirst is not NULL
                //
                //--ft: prefix bug #444993
                *pIndex = 0;
                if (pfFirst != NULL)
                    *pfFirst = TRUE;
        }
        return(ErrStat);
}

int
__cdecl
CompareNames(
        const VOID *pKey1,
        const VOID *pKey2
        )
{
        const PWINSINTF_RECORD_ACTION_T        pRow1 = (PWINSINTF_RECORD_ACTION_T)pKey1;
        const PWINSINTF_RECORD_ACTION_T        pRow2 = (PWINSINTF_RECORD_ACTION_T)pKey2;
        ULONG CmpVal;
        DWORD LenToCmp =  min(pRow1->NameLen, pRow2->NameLen);


PERF("replace with RtlCompareMemory")
        CmpVal = memcmp(pRow1->pName, pRow2->pName, LenToCmp);
        if (CmpVal == LenToCmp)
        {
                return(pRow1->NameLen - pRow2->NameLen);
        }
        else
        {
                return(CmpVal);
        }

}

int
__cdecl
CompareIndexes(
        const VOID *pKey1,
        const VOID *pKey2
        )
{
        const PDATAFILE_INFO_T        pRow1 = (PDATAFILE_INFO_T)pKey1;
        const PDATAFILE_INFO_T        pRow2 = (PDATAFILE_INFO_T)pKey2;

PERF("replace with RtlCompareMemory")
        return(strcmp(pRow1->ValNm, pRow2->ValNm));
}

DWORD
PopulateDRCache(
        VOID
        )
{
        DWORD                        RetStat = WINSINTF_SUCCESS;
        WINSINTF_VERS_NO_T        MaxVersNo, MinVersNo;
        handle_t                BindHdl;
        WINSINTF_ADD_T                WinsAdd;
        DWORD                        SvNoOfRecs;
        LPVOID                        pSvRplPnrs;
           LPBYTE                  pStorage;

        WINS_ASSIGN_INT_TO_VERS_NO_M(MaxVersNo, 0);
        WINS_ASSIGN_INT_TO_VERS_NO_M(MinVersNo, 0);
        WinsAdd.Len        = 4;
        WinsAdd.Type        = 0;
        pSvRplPnrs     = sRecs.pRow;
        SvNoOfRecs     = sRecs.NoOfRecs;
        sRecs.pRow     = NULL;
        sRecs.NoOfRecs = 0;
        pStorage = MIB_GetDbRecsStore;
        WinsAdd.IPAdd = ntohl(*(DWORD*)pStorage);
        //NMSMSGF_RETRIEVE_IPADD_M(pStorage, WinsAdd.IPAdd);
        BindHdl = WinsBind(&sBindData);
        RetStat = WinsGetDbRecs(BindHdl, &WinsAdd, MinVersNo, MaxVersNo, &sRecs);
        WinsUnbind(&sBindData, BindHdl);

        if (RetStat == WINSINTF_SUCCESS)
        {
              if (sRecs.NoOfRecs > 1)
              {
                      qsort(
                        (LPVOID)sRecs.pRow,
                        (size_t)sRecs.NoOfRecs,
                        sizeof(WINSINTF_RECORD_ACTION_T),
                        CompareNames
                                );
              }

              if (pSvRplPnrs != NULL)
              {
                WinsFreeMem(pSvRplPnrs);
              }

        }
        else
        {
                sRecs.NoOfRecs = SvNoOfRecs;
                sRecs.pRow     = pSvRplPnrs;
        }
        return(RetStat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\mib\winstst.c ===
//
//
//  Copyright (c) 1991  Microsoft Corporation
//

//-------------------------- MODULE DESCRIPTION ----------------------------
//  
//  winsmain.c
//  
//---------------------------------------------------------------------------


//--------------------------- WINDOWS DEPENDENCIES --------------------------

#include <windows.h>

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <malloc.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <util.h>
#include "winsmib.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

typedef AsnObjectIdentifier View; // temp until view is defined...

_cdecl main(
    IN int  argumentCount,
    IN char *argumentVector[])
{
    HANDLE  hExtension;
    FARPROC initAddr;
    FARPROC queryAddr;
    FARPROC trapAddr;

    DWORD  timeZeroReference;
    HANDLE hPollForTrapEvent;
    View   supportedView;
    UINT   Val;
    DWORD  Choice;
    DWORD  Oper;
    BYTE   Name[255];

    INT numQueries = 10;

    extern INT nLogLevel;
    extern INT nLogType;

    nLogLevel = 15;
    nLogType  = 1;

    // avoid compiler warning...
    UNREFERENCED_PARAMETER(argumentCount);
    UNREFERENCED_PARAMETER(argumentVector);

    timeZeroReference = GetCurrentTime();

    // load the extension agent dll and resolve the entry points...
    if (GetModuleHandle("winsmib.dll") == NULL)
    {
        if ((hExtension = LoadLibrary("winsmib.dll")) == NULL)
        {
            dbgprintf(1, "error on LoadLibrary %d\n", GetLastError());

        }
        else 
	{
	    if ((initAddr = GetProcAddress(hExtension, 
                 		"SnmpExtensionInit")) == NULL)
            {
              dbgprintf(1, "error on GetProcAddress %d\n", GetLastError());
            }
            else 
	    {
	      if ((queryAddr = GetProcAddress(hExtension, 
                 		"SnmpExtensionQuery")) == NULL)
              {
                    dbgprintf(1, "error on GetProcAddress %d\n", 
                              GetLastError());

              }
              else 
	      {
		if ((trapAddr = GetProcAddress(hExtension, 
                                   "SnmpExtensionTrap")) == NULL)
                {
                   dbgprintf(1, "error on GetProcAddress %d\n", 
                      GetLastError());
                }
         	else
                {
                  // initialize the extension agent via its init entry point...
                  (*initAddr)(
                       timeZeroReference,
                       &hPollForTrapEvent,
                    &supportedView);
                }
	     }
	   }
	}
      } // end if (Already loaded)

      {
         RFC1157VarBindList varBinds;
         AsnInteger         errorStatus;
         AsnInteger         errorIndex;
         UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 311, 1 };
	 UINT OID_Suffix1[] = { 1, 2, 0};
	 UINT OID_Suffix2[] = { 1, 3, 0};
	 UINT OID_Suffix3[] = { 1, 4, 0};
         AsnObjectIdentifier MIB_OidPrefix = { OID_SIZEOF(OID_Prefix), OID_Prefix };
	 AsnObjectIdentifier Sf1Oid = { OID_SIZEOF(OID_Suffix1), OID_Suffix1};
	 AsnObjectIdentifier Sf2Oid = { OID_SIZEOF(OID_Suffix2), OID_Suffix2};
	 AsnObjectIdentifier Sf3Oid = { OID_SIZEOF(OID_Suffix3), OID_Suffix3};


	 errorStatus = 0;
	 errorIndex  = 0;
         varBinds.list = (RFC1157VarBind *)SNMP_malloc( sizeof(RFC1157VarBind));
//         varBinds.list = (RFC1157VarBind *)SNMP_malloc( sizeof(RFC1157VarBind) * 4);
//         varBinds.len = 4;
         varBinds.len = 1;
         SNMP_oidcpy( &varBinds.list[0].name, &MIB_OidPrefix );
         varBinds.list[0].value.asnType = ASN_NULL;

#if 0
         SNMP_oidcpy( &varBinds.list[1].name, &MIB_OidPrefix );
	 SNMP_oidappend(  &varBinds.list[1].name, &Sf1Oid ); 
         varBinds.list[1].value.asnType = ASN_NULL;

         SNMP_oidcpy( &varBinds.list[2].name, &MIB_OidPrefix );
	 SNMP_oidappend(  &varBinds.list[2].name, &Sf2Oid ); 
         varBinds.list[2].value.asnType = ASN_NULL;

         SNMP_oidcpy( &varBinds.list[3].name, &MIB_OidPrefix );
	 SNMP_oidappend(  &varBinds.list[3].name, &Sf3Oid ); 
         varBinds.list[3].value.asnType = ASN_NULL;

#endif
	 printf("Walk ? (1 for yes) -- ");
	 scanf("%d", &Choice);
	 if (Choice == 1)
	 {
          do
          {
	    printf( "\nGET-NEXT of:  " ); SNMP_oiddisp( &varBinds.list[0].name );
                                        printf( "   " );
            (*queryAddr)( (AsnInteger)ASN_RFC1157_GETNEXTREQUEST,
                          &varBinds,
		          &errorStatus,
		          &errorIndex
                          );
            printf( "\n  is  " ); SNMP_oiddisp( &varBinds.list[0].name );
	    if ( errorStatus )
	       {
               printf( "\nErrorstatus:  %lu\n\n", errorStatus );
	       }
	    else
	       {
               printf( "\n  =  " ); SNMP_printany( &varBinds.list[0].value );
	       }
//            putchar( '\n' );

         } while ( varBinds.list[0].name.ids[MIB_PREFIX_LEN-1] == 1 );

         // Free the memory
         SNMP_FreeVarBindList( &varBinds );
	 }
       } // block


       {


       char String[80];
       DWORD i;
       RFC1157VarBindList varBinds;
       UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 311, 1 };
       UINT TempOid[255];
       AsnObjectIdentifier MIB_OidPrefix = { OID_SIZEOF(OID_Prefix), OID_Prefix };
       AsnObjectIdentifier MIB_Suffix = { OID_SIZEOF(TempOid), TempOid};
       AsnInteger errorStatus;
       AsnInteger errorIndex;
       UINT	Code;


        varBinds.list = (RFC1157VarBind *)SNMP_malloc( sizeof(RFC1157VarBind) );
        varBinds.len = 1;
Loop:
       printf("Enter Code for Group \nPar\t1\nPull\t2\nPush\t3\nDF\t4\nCmd\t5\nCode is --");
       scanf("%d", &TempOid[0]);
       if (TempOid[0] < 1 || TempOid[0] > 5)
       {
	  goto Loop;
       }
LoopLT:
       printf("Leaf or Table access (0/1) -- ");
       scanf("%d", &Code);
       if (Code != 0 && Code != 1)
       {
	  goto LoopLT;

       }
       printf("Enter Code for var. --");
        scanf("%d", &TempOid[1]);
       if (Code == 0)
       {
        TempOid[2] = 0;
	MIB_Suffix.idLength = 3;
       }
       else
       {
	TempOid[2] = 1;
        printf("Enter Code for field --");
        scanf("%d", &TempOid[3]);
	switch(TempOid[0])
	{
		case(2):
		case(3):
			printf("Input IP address in host order\n");
			for (i=0; i< 4; i++)
			{
			  printf("\nByte (%d) -- ", i);
			  scanf("%d", &TempOid[4 + i]);
			}
			MIB_Suffix.idLength = 8;
			break;
		case(4):
			printf("Index of file ? -- ");
			scanf("%d", &TempOid[4]);
			MIB_Suffix.idLength = 5;
		case(5):
			printf("name -- ");
			scanf("%s", Name);
			for (i=0; i<strlen(Name); i++)
			{
				TempOid[4+i] = (UINT)Name[i];
			}
			TempOid[4+i] = 0;
			MIB_Suffix.idLength = 4 + i + 1;
			break;
			
	}
	 

       }
	//
	// Construct OID with complete prefix for comparison purposes
	//
	SNMP_oidcpy( &varBinds.list[0].name, &MIB_OidPrefix );
	SNMP_oidappend( &varBinds.list[0].name, &MIB_Suffix );
 
       	//printf( "SET:  " ); 
	SNMP_oiddisp( &varBinds.list[0].name );
Loop1:
	printf("\nSET/GET/GET_NEXT - 0/1/? -- ");
	scanf("%d", &Oper);
	printf("\nEnter Type (1 - Integer, 2-Octet String, 3 -IP address, 4 -Counter -- ");
	scanf("%d",&Choice);
        if (Choice < 1 || Choice > 4)
	{
	  goto Loop1;
        }
	switch(Choice)
	{
		case(1):
       			varBinds.list[0].value.asnType = ASN_INTEGER;
			if (Oper == 0)
			{
			printf("\nInteger Value -- ");
			scanf("%d", &Val);
       			varBinds.list[0].value.asnValue.number = Val;
			}
			break;
		case(2):
       			varBinds.list[0].value.asnType = ASN_OCTETSTRING;
			if (Oper == 0)
			{
			printf("\nCharacter array -- ");
			scanf("%s", String);
		  	varBinds.list[0].value.asnValue.string.length =
                    		strlen( (LPSTR)String );

       			varBinds.list[0].value.asnValue.string.stream = String;

  			varBinds.list[0].value.asnValue.string.dynamic = FALSE;
			}
	
			break;
		case(3):
       			varBinds.list[0].value.asnType = ASN_RFC1155_IPADDRESS;
			if (Oper == 0)
			{
			printf("\nInput ip address bytes in network byte order\n");
			for (i=0; i< 4; i++)
			{
			  printf("\nByte (%d) -- ", i);
			  scanf("%d", &String[i]);
			}
			String[4] = 0;
		  	varBinds.list[0].value.asnValue.string.length =
                    		strlen( (LPSTR)String );

       			varBinds.list[0].value.asnValue.string.stream = String;

  			varBinds.list[0].value.asnValue.string.dynamic = TRUE;
			}
			break;
		case(4):
       			varBinds.list[0].value.asnType = ASN_RFC1155_COUNTER;
			if (Oper == 0)
			{
			printf("\nInteger Value -- ");
			scanf("%d", &Val);
       			varBinds.list[0].value.asnValue.number = Val;

			}
			break;
		default:
			printf("wrong type\n");
			break;
       }		

       errorStatus       = 0;
       errorIndex        = 0;

	switch(Oper)
	{
		case(0): 
			Code = ASN_RFC1157_SETREQUEST;
       			printf( "SET:  " ); SNMP_oiddisp( &varBinds.list[0].name );
       			printf( " to " ); SNMP_printany( &varBinds.list[0].value );
			break;
		case(1):
			Code = ASN_RFC1157_GETREQUEST;
       			printf( "GET:  " ); SNMP_oiddisp( &varBinds.list[0].name );
			break;
		default:
       			printf( "GETNEXT:  " ); SNMP_oiddisp( &varBinds.list[0].name );
			Code = ASN_RFC1157_GETNEXTREQUEST;
			break;


	}
       (*queryAddr)( (BYTE)Code,
                              &varBinds,
			      &errorStatus,
			      &errorIndex
                              );
       printf( "\n Errorstatus:  %lu\n\n", errorStatus );
       if (Code != ASN_RFC1157_SETREQUEST)
       {
          if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
          {
            printf( "Value:  " );
	    SNMP_printany( &varBinds.list[0].value ); putchar( '\n' );
	    SNMP_oidfree(&varBinds.list[0].name);
	  }
       }
	
#if 0
       varBinds.list = (RFC1157VarBind *)SNMP_malloc( sizeof(RFC1157VarBind) );
       varBinds.len = 1;
       varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
       varBinds.list[0].name.ids = (UINT *)SNMP_malloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
       memcpy( varBinds.list[0].name.ids, &itemn,
               sizeof(UINT)*varBinds.list[0].name.idLength );
       varBinds.list[0].value.asnType = ASN_INTEGER;
       printf("Value ? -- ");
       scanf("%d", &Val);
       varBinds.list[0].value.asnValue.number = Val;
       printf( "SET:  " ); SNMP_oiddisp( &varBinds.list[0].name );
       printf( " to " ); SNMP_printany( &varBinds.list[0].value );
       (*queryAddr)( ASN_RFC1157_SETREQUEST,
                              &varBinds,
			      &errorStatus,
			      &errorIndex
                              );
       printf( "\nSET Errorstatus:  %lu\n\n", errorStatus );

       (*queryAddr)( ASN_RFC1157_GETREQUEST,
                              &varBinds,
			      &errorStatus,
			      &errorIndex
                              );
       if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
       {
          printf( "Value:  " );
	  SNMP_printany( &varBinds.list[0].value ); putchar( '\n' );
	  SNMP_oidfree(&varBinds.list[0].name);
	}
       printf( "\nGET Errorstatus:  %lu\n\n", errorStatus );

#endif
#if 0
       // Free the memory
       SNMP_FreeVarBindList( &varBinds );
#endif
       
       printf( "\n\n" );
       printf("Enter 1 to exit -- ");
       scanf("%d", &Choice);
       if (Choice != 1)
       {
       		goto Loop;
       }
    }

    return 0;

} // end main()


//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\check.h ===
/*++

Copyright (C) 1999 Microsoft Corporation


--*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtypes.h>


#include <fcntl.h>
#include <sys/stropts.h>
#include <ctype.h>

#include <windows.h>
#include <tdi.h>
#include <sys\uio.h>

#include <winsock.h>
#include <wsahelp.h>

#include <sockets\resolv.h>
#include <nb30.h>
#include <nbtioctl.h>

#include "winsintf.h"

#include "common.h"

#define MAX_PATH_LEN 100
#define WINSTEST_FOUND            0
#define WINSTEST_NOT_FOUND        1
#define WINSTEST_NO_RESPONSE      2

#define WINSTEST_VERIFIED         0
#define WINSTEST_OUT_OF_MEMORY    3
#define WINSTEST_BAD_IP_ADDRESS   4
#define WINSTEST_HOST_NOT_FOUND   5
#define WINSTEST_NOT_VERIFIED     6

#define WINSTEST_INVALID_ARG      7
#define WINSTEST_OPEN_FAILED      8

#define  _WINS_CFG_PULL_KEY              TEXT("System\\CurrentControlSet\\Services\\Wins\\Partners\\Pull")
#define  _WINS_CFG_PUSH_KEY              TEXT("System\\CurrentControlSet\\Services\\Wins\\Partners\\Push")
#define  WINSCNF_ONLY_DYN_RECS_NM           TEXT("OnlyDynRecs")

#define  _NBT_CFG_ADAPTERS_KEY              TEXT("System\\CurrentControlSet\\Services\\NetBT\\Adapters")

#define  RPL_E_PULL 0
#define  RPL_E_PUSH 1

#define RE_QUERY_REGISTRY_COUNT 10

#define MAX_NB_NAMES 1000
#define MAX_SERVERS  1000
#define BUFF_SIZE    650

#define MY_PRINT0(_continuous, _str) { \
    MY_FPRINT(_continuous, _str); \
    }

#define MY_PRINT1(_continuous, _str, _v1) { \
    UCHAR   __str[500]; \
    sprintf(__str, _str, _v1); \
    MY_FPRINT(_continuous, __str); \
    }

#define MY_PRINT2(_continuous, _str, _v1, _v2) { \
    UCHAR   __str[500]; \
    sprintf(__str, _str, _v1, _v2); \
    MY_FPRINT(_continuous, __str); \
    }

#define MY_PRINT3(_continuous, _str, _v1, _v2, _v3) { \
    UCHAR   __str[500]; \
    sprintf(__str, _str, _v1, _v2, _v3); \
    MY_FPRINT(_continuous, __str); \
    }

#define MY_PRINT4(_continuous, _str, _v1, _v2, _v3, _v4) { \
    UCHAR   __str[500]; \
    sprintf(__str, _str, _v1, _v2, _v3, _v4); \
    MY_FPRINT(_continuous, __str); \
    }

#define MY_FPRINT(_continuous, __str_) \
    if (_continuous) { \
        fprintf (fp1, __str_); \
    } else { \
        fprintf (fp, __str_); \
        if (Interactive) { \
            printf (__str_);  \
        }\
    }

typedef struct  _PUSH_PULL_ENTRY {
    ULONG   PE_IpAddr;
    UCHAR   PE_Name[MAX_PATH_LEN];
    struct  _PUSH_PULL_ENTRY *PE_Next;
} PUSH_PULL_ENTRY, *PPUSH_PULL_ENTRY;

typedef struct  _NODE_INFO {
    ULONG   NI_IpAddr;
    UCHAR   NI_Name[MAX_PATH_LEN];
    PPUSH_PULL_ENTRY   NI_Lists[2]; // 0 - RPL_E_PULL - PULL list; 1 - RPL_E_PUSH - PUSH list
    struct  _NODE_INFO  *NI_Next;
    struct  _NODE_INFO  *NI_DoneNext;
} NODE_INFO, *PNODE_INFO;

PNODE_INFO   GlobalListHead=NULL;
PNODE_INFO   GlobalListTail=NULL;
PNODE_INFO   GlobalDoneListHead=NULL;
PNODE_INFO   GlobalDoneListTail=NULL;

ULONG   LocalIpAddress;
CHAR    pScope[128];

#define PUSH_BUT_NOT_PULL_LOCAL 0
#define PULL_BUT_NOT_PUSH 1
#define PUSH_BUT_NOT_PULL 2
#define PULL_BUT_NOT_PUSH_LOCAL 3

#define MAX_WINS    1000

//
// <Server> - <Owner> Table - [SO] Table
//
//LARGE_INTEGER    SO_Table[MAX_WINS][MAX_WINS];
LARGE_INTEGER   **SO_Table = NULL;

//
// Lookaside table to map IP addrs to the index into the SO_Table
//


UCHAR   LA_Table[MAX_WINS][20];
ULONG   LA_TableSize;

#define ME_PULL 0x1
#define ME_PUSH 0x2

//
// Push/Pull matrix
//
typedef struct _MATRIX_ENTRY {
    BOOLEAN ME_Down;        // 0 - UP; 1 - Down
    USHORT  ME_Entry;       // 1 - Pull; 2 - Push
} MATRIX_ENTRY, *PMATRIX_ENTRY;

MATRIX_ENTRY   PP_Matrix[MAX_WINS][MAX_WINS];

VOID
DumpSOTable(
    IN DWORD    MasterOwners,
    IN BOOL     fFile,
    IN FILE *   pFile
    );

VOID
DumpLATable(
    IN DWORD    MasterOwners,
    IN BOOL     fFile,
    IN FILE  *  pFile
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\mib\winsmib.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    winsmib.h

Abstract:

    Sample SNMP Extension Agent for Windows NT.

    These files (winsmibm.c, winsmib.c, and winsmib.h) provide an example of 
    how to structure an Extension Agent DLL which works in conjunction with 
    the SNMP Extendible Agent for Windows NT.

    Extensive comments have been included to describe its structure and
    operation.  See also "Microsoft Windows/NT SNMP Programmer's Reference".

Created:

    13-Jun-1991

Revision History:

--*/

#ifndef winsmib_h
#define winsmib_h

static char *winsmib__h = "@(#) $Logfile:   N:/xtest/vcs/winsmib.h_v  $ $Revision:   1.2  $";


// Necessary includes.

#include <snmp.h>


// MIB Specifics.

#define MIB_PREFIX_LEN            MIB_OidPrefix.idLength
#define MAX_STRING_LEN            255


// Ranges and limits for specific MIB variables.





#define NON_ASN_USED_RANGE_START	0xe0	//high 3 bits not used by
						//ASN
//
// MIB function actions.
//

#define MIB_GET         ASN_RFC1157_GETREQUEST
#define MIB_SET         ASN_RFC1157_SETREQUEST
#define MIB_GETNEXT     ASN_RFC1157_GETNEXTREQUEST
#define MIB_GETFIRST	(ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0)


// MIB Variable access privileges.

#define MIB_ACCESS_READ        0
#define MIB_ACCESS_WRITE       1
#define MIB_ACCESS_READWRITE   2
#define MIB_NOACCESS  	       3	


// Macro to determine number of sub-oid's in array.

#define OID_SIZEOF( Oid )      ( sizeof Oid / sizeof(UINT) )


// MIB variable ENTRY definition.  This structure defines the format for
// each entry in the MIB.

typedef struct mib_entry
           {
	   AsnObjectIdentifier Oid;
	   void *              Storage;
	   BYTE                Type;
	   UINT                Access;
	   UINT                (*MibFunc)( UINT, struct mib_entry *,
	                                   RFC1157VarBind * );
	   struct mib_entry *  MibNext;
	   } MIB_ENTRY, *PMIB_ENTRY;

typedef struct table_entry
           {
	   UINT                (*MibFunc)( UINT, struct mib_entry *,
	                                   RFC1157VarBind * );
	   struct mib_entry *  Mibptr;
	   } TABLE_ENTRY, *PTABLE_ENTRY;


// Internal MIB structure.

extern UINT      MIB_num_variables;
extern BOOL	 fWinsMibWinsStatusCnfCalled;
extern BOOL	 fWinsMibWinsStatusStatCalled;

// Prefix to every variable in the MIB.

extern AsnObjectIdentifier MIB_OidPrefix;
extern CRITICAL_SECTION	   WinsMibCrtSec;
extern HKEY		   WinsMibWinsKey;
extern BOOL		   fWinsMibWinsKeyOpen;

//extern MIB_ENTRY	Mib[];
extern MIB_ENTRY	*pWinsMib;
// Function Prototypes.

extern
UINT ResolveVarBind(
        IN OUT RFC1157VarBind *VarBind, // Variable Binding to resolve
	IN UINT PduAction               // Action specified in PDU
	);

extern
VOID WinsMibInit(
	VOID
	);

#if 0
extern
VOID
WinsMibInitTables();
#endif

#endif /* winsmib_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\check.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/

#include "precomp.h"


#define WCHARTONUM(wchr) (iswalpha(wchr)?(towlower(wchr)-L'a')+10:wchr-L'0')

UCHAR  StringToHexA(IN LPCWSTR pwcString)
{
    UCHAR   ch = (CHAR)0x00;

    if( pwcString is NULL )
        return ch;

    while(*pwcString != L'\0')
    {
        ch <<= 4;
        ch |= WCHARTONUM(*pwcString);
        pwcString++;
    }

   return ch;
}



ULONG LA_TableSize = 0;

VOID
FreeLATable(ULONG TableSize)
{
    DWORD i = 0;

    if( IsBadReadPtr((void *)LA_Table, TableSize) is FALSE && 
        TableSize > 0 )
    {
        for( i=0; i<TableSize; i++ )
        {
            if( IsBadStringPtr(LA_Table[i], 20*sizeof(WCHAR)) is FALSE )
            {
                WinsFreeMemory((PVOID)LA_Table[i]);
                LA_Table[i] = NULL;
            }
        }

        WinsFreeMemory((PVOID)LA_Table);
        LA_Table = NULL;
    }
}

VOID
FreeSOTable(ULONG TableSize)
{
    DWORD i = 0;

    if( SO_Table )
    {
        for( i=0; i<TableSize; i++ )
        {
            if( SO_Table[i] )
            {
                WinsFreeMemory((PVOID)SO_Table[i]);
                SO_Table[i] = NULL;
            }
        }

        WinsFreeMemory((PVOID)SO_Table);
        SO_Table = NULL;
    }
}

VOID
DumpSOTable(
    IN DWORD MasterOwners,
    IN BOOL     fFile,
    IN FILE *   pFile
    )
{
    ULONG   i;
    ULONG   j;

    DisplayMessage(g_hModule, 
                   MSG_WINS_SOTABLE_HEADER);
    if( fFile is TRUE )
    {
        DumpMessage(g_hModule,
                    pFile,
                    FMSG_WINS_SOTABLE_HEADER);
    }


    for (i = 0; i < MasterOwners; i++) 
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_MASTEROWNER_INDEX,
                       i);
        if( fFile )
        {
            DumpMessage(g_hModule,
                        pFile,
                        FMSG_WINS_MASTEROWNER_INDEX,
                        i);
        }
    }

    DisplayMessage(g_hModule,
                   WINS_FORMAT_LINE);
    if( fFile )
    {
        DumpMessage(g_hModule,
                    pFile,
                    WINS_FORMAT_LINE);
    }

    for (i = 0; i < MasterOwners; i++) 
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_MASTEROWNER_INDEX1,
                       i);
        if( fFile )
        {
            DumpMessage(g_hModule,
                        pFile,
                        FMSG_WINS_MASTEROWNER_INDEX1,
                        i);
        }
        for (j = 0; j < MasterOwners; j++) 
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_MASTEROWNER_INDEX,
                           SO_Table[i][j]);
            if( fFile )
            {
                DumpMessage(g_hModule,
                            pFile,
                            FMSG_WINS_MASTEROWNER_INDEX,
                            SO_Table[i][j]);
            }
        }

        DisplayMessage(g_hModule,
                       WINS_FORMAT_LINE);
        if( fFile )
        {
            DumpMessage(g_hModule,
                        pFile,
                        WINS_FORMAT_LINE);
        }
    }

    
    DisplayMessage(g_hModule,
                   MSG_WINS_MAP_SOURCE);

    if( fFile )
    {
        DumpMessage(g_hModule,
                    pFile,
                    FMSG_WINS_MAP_SOURCE);
    }

    DumpLATable(MasterOwners, fFile, pFile);
}

VOID
DumpLATable(
    IN DWORD MasterOwners,
    IN BOOL     fFile,
    IN FILE  *  pFile
    )
{
    ULONG   i;
    ULONG   j;

    
    DisplayMessage(g_hModule,
                   MSG_WINS_INDEXTOIP_TABLE);

    if( fFile )
    {
        DumpMessage(g_hModule,
                    pFile,
                    FMSG_WINS_INDEXTOIP_TABLE);

    }
    for (i = 0; i < MasterOwners; i++) 
    {
        if (LA_Table[i][0] == '0') 
        {
            break;
        }
    
        DisplayMessage(g_hModule,
                       MSG_WINS_INDEXTOIP_ENTRY,
                       i,
                       LA_Table[i]);

        if( pFile )
        {
            DumpMessage(g_hModule,
                        pFile,
                        FMSG_WINS_INDEXTOIP_ENTRY,
                        i,
                        LA_Table[i]);
        }

    }
    
    DisplayMessage(g_hModule,
                   WINS_FORMAT_LINE);
    if( fFile )
    {
        DumpMessage(g_hModule,
                    pFile,
                    WINS_FORMAT_LINE);
    }
}

LONG
IPToIndex(
    IN  LPWSTR  IpAddr,
    DWORD   NoOfOwners
    )
{
    ULONG   i=0;
    WCHAR **pTempLA = NULL;
    //
    // Get the Row #
    //
    for ( i = 0; i < NoOfOwners; i++) {
        if (wcscmp(LA_Table[i], IpAddr) == 0) {
            return i;
        }
        //
        // The first NULL entry indicates end
        //
        if (LA_Table[i][0] is L'0') {
            break;
        }
    }

    //
    // Entry not found - add
    //
    
    wcscpy(LA_Table[i], IpAddr);
    
    LA_TableSize = i+1;
    return i;
}

//
// Check if the diagonal elements are the max in their cols.
//
VOID
CheckSOTableConsistency(
    DWORD   MasterOwners
    )
{
    ULONG   i;
    ULONG   j;
    BOOLEAN fProblem = FALSE;

    for (i = 0; i < MasterOwners; i++) 
    {

        //
        // Is the diagonal element at i the largest in its column?
        //
        for (j = 0; j < MasterOwners; j++) 
        {
            if (i == j) 
            {
                continue;
            }

            //
            // Compare only non-zero values
            //
            if (SO_Table[i][i].QuadPart &&
                SO_Table[j][i].QuadPart &&
                (SO_Table[i][i].QuadPart < SO_Table[j][i].QuadPart))
            {
                 
                DisplayMessage(g_hModule, EMSG_WINS_VERSION_HIGHER, LA_Table[j], LA_Table[i]);
                fProblem = TRUE;
            }
        }
    }

    if ( fProblem is FALSE ) 
    {
        DisplayMessage(g_hModule, EMSG_WINS_VERSION_CORRECT);
    }
}

DWORD
InitLATable(
    PWINSINTF_ADD_VERS_MAP_T  pAddVersMaps,
    DWORD   MasterOwners,           // 0 first time
    DWORD   NoOfOwners
    )
{
    ULONG   i, j, k;

    if( LA_Table is NULL )
    {
        LA_Table = WinsAllocateMemory(MAX_WINS*sizeof(LPWSTR));
        if( LA_Table is NULL )
        {
             return 0;
        }    

        for( i=0; i< MAX_WINS; i++ )
        {
            LA_Table[i] = WinsAllocateMemory(20*sizeof(WCHAR));
            if( LA_Table[i] is NULL )
            {
                FreeLATable(i);
                return 0;
            }

        }
    }

    if (MasterOwners == 0) 
    {
        //
        // first time - init the LA table
        //
        for (i = 0; i < NoOfOwners; i++, pAddVersMaps++) 
        {
            struct in_addr            InAddr;

            LPWSTR  pwsz = IpAddressToString(pAddVersMaps->Add.IPAdd);
            if( pwsz is NULL )
            {
                FreeLATable(MAX_WINS);
                return 0;
            }

            wcscpy(LA_Table[i], pwsz);
            
            WinsFreeMemory(pwsz);
            pwsz = NULL;

        }
    } 
    else 
    {
        //
        // More came in this time - add them to the LA table after the others
        //
        for (i = 0; i < NoOfOwners; i++, pAddVersMaps++) 
        {
            LPWSTR pwszIp = IpAddressToString(pAddVersMaps->Add.IPAdd);

            if( pwszIp is NULL )
            {
                FreeLATable(MAX_WINS);
                return 0;
            }
            //
            // If this entry is not in the LA table, insert
            //
            for (j = 0; j < MasterOwners; j++) 
            {
                if (wcscmp(LA_Table[j], pwszIp) is 0 ) 
                {
                    WinsFreeMemory(pwszIp);
                    pwszIp = NULL;
                    break;
                }
            }

            if (j == MasterOwners) 
            {
                //
                // Insert
                //


                wcscpy(LA_Table[MasterOwners], pwszIp);
                MasterOwners++;
            }

            if( pwszIp )
            {
                WinsFreeMemory(pwszIp);
                pwszIp = NULL;
            }
        }
    }
    
    if( SO_Table is NULL )
    {
        SO_Table = WinsAllocateMemory((MAX_WINS+1)*sizeof(LARGE_INTEGER *));
        if (SO_Table == NULL)
        {
            FreeLATable(MAX_WINS);
            return 0;
        }
    
        for( i=0; i<MAX_WINS+1; i++ )
        {
            SO_Table[i] = WinsAllocateMemory((MAX_WINS+1)*sizeof(LARGE_INTEGER));
            if( SO_Table[i] is NULL )
            {
                FreeLATable(MAX_WINS);
                FreeSOTable(MAX_WINS+1);
                return 0;
            }
        }
    }

    LA_TableSize = NoOfOwners;
    return MasterOwners;
}



VOID
AddSOTableEntry (
    IN  LPWSTR  IpAddr,
    PWINSINTF_ADD_VERS_MAP_T  pMasterMaps,
    DWORD   NoOfOwners,
    DWORD   MasterOwners
    )
{
    ULONG   i;
    LONG   Row;
    struct in_addr            InAddr;

    Row = IPToIndex(IpAddr, MasterOwners);

    //
    // Fill the row
    //
    for ( i = 0; i < NoOfOwners; i++, pMasterMaps++) 
    {
        LONG    col;
        LPTSTR  pstr;

        InAddr.s_addr = htonl(pMasterMaps->Add.IPAdd);

        pstr = IpAddressToString(pMasterMaps->Add.IPAdd);
        if (pstr == NULL)
            break;

        col = IPToIndex(pstr, MasterOwners);
        // clean out memory
        WinsFreeMemory(pstr);
        //
        // Place only a non-deleted entry
        //
        if (!((pMasterMaps->VersNo.HighPart == MAXLONG) &&
              (pMasterMaps->VersNo.LowPart == MAXULONG))) {

            //
            // Also if the entry above us was 0, write 0 there so as to make the fail case stand out
            //
            if (Row && SO_Table[Row-1][col].QuadPart == 0) 
            {
                SO_Table[Row][col].QuadPart = 0;
            } 
            else 
            {
                SO_Table[Row][col] = pMasterMaps->VersNo;
            }

        }
    }
}

VOID
RemoveFromSOTable(
    IN  LPWSTR  IpAddr,
    IN  DWORD   MasterOwners
    )
{
    ULONG   i;
    LONG   Row;
    struct in_addr            InAddr;

    Row = IPToIndex(IpAddr, MasterOwners);

    //
    // Mark the row and col as down (0's)
    //
    for (i = 0; i < MasterOwners; i++) 
    {
        SO_Table[Row][i].QuadPart = SO_Table[i][Row].QuadPart = 0;
    }
}


//
// Get the <owner address> - <version #> [OV table] mapping tables from each WINS server on the net and check for inconsistencies.
//
VOID
CheckVersionNumbers( 
                    IN  LPCSTR  pStartIp,
                    IN  BOOL    fFile,
                    OUT FILE *  pFile
                   )
{
    DWORD                     Status = NO_ERROR;
    ULONG                     i, k;
    PWINSINTF_ADD_VERS_MAP_T  pAddVersMaps;
    PWINSINTF_ADD_VERS_MAP_T  pMasterMaps;  // master OV maps used to place into the OV table
    DWORD                     NoOfOwners=0;
    DWORD                     MasterOwners=0;
    struct in_addr            InAddr;
    WINSINTF_RESULTS_NEW_T    ResultsN;
    DWORD                     ret;
    handle_t                  hBindTemp = g_hBind;
    WINSINTF_BIND_DATA_T      BindDataTemp = g_BindData;
    LPWSTR                    wszStartIp = NULL;
    
    if( pStartIp is NULL )
        return;
    
    wszStartIp = WinsOemToUnicode(pStartIp, NULL);  
    
    if( wszStartIp is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_OUT_OF_MEMORY);
        return;
    }

    //
    // Get the OV table from this server
    //
    if (NO_ERROR isnot (Status = GetStatus(TRUE, &ResultsN, TRUE, FALSE, pStartIp)) )
    {
        DisplayErrorMessage(EMSG_SRVR_CHECK_VERSION,
                            Status);
          
        WinsFreeMemory(wszStartIp);
        wszStartIp = NULL;
        return;
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_GETSTATUS_SUCCESS);

        DisplayMessage(g_hModule,
                       WINS_FORMAT_LINE);
    }

    MasterOwners = NoOfOwners = ResultsN.NoOfOwners;

    pMasterMaps = pAddVersMaps = ResultsN.pAddVersMaps;

    ret = InitLATable(pAddVersMaps, 0, NoOfOwners);
    
    if( LA_Table is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_OUT_OF_MEMORY);
        WinsFreeMemory(wszStartIp);
        wszStartIp = NULL;
        return;
    }

    if( SO_Table is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_OUT_OF_MEMORY);
        FreeLATable(MAX_WINS);    
        WinsFreeMemory(wszStartIp);
        wszStartIp = NULL;
        return;
    }

    AddSOTableEntry(wszStartIp, pMasterMaps, NoOfOwners, MasterOwners);


    if( ResultsN.pAddVersMaps )
    {
        WinsFreeMem(ResultsN.pAddVersMaps);
        ResultsN.pAddVersMaps = NULL;
    }



    //
    // For each server X (other than Start addr) in the LA table:
    //
    for ( i = 0; i < MasterOwners; i++) 
    {
        LPSTR   pszName = NULL;

        if( wcscmp(LA_Table[i], wszStartIp) is 0 )
        {
            continue;
        }

        //
        // Get X's OV table
        //
        pszName = WinsUnicodeToOem(LA_Table[i], NULL);

        if( pszName is NULL )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_OUT_OF_MEMORY);
            if( SO_Table )
            {
                FreeSOTable(MAX_WINS+1);
            }
            if( wszStartIp )
            {
                WinsFreeMemory(wszStartIp);
                wszStartIp = NULL;
            }
            
            if( LA_Table )
            {
                FreeLATable(MAX_WINS);
            }
            return;

        }

        if( NO_ERROR isnot (Status = GetStatus(TRUE, &ResultsN, TRUE, FALSE, pszName) ) )
        {
            RemoveFromSOTable(LA_Table[i], MasterOwners);
            if( pszName )
            {
                WinsFreeMemory(pszName);
                pszName = NULL;
            }
            if( ResultsN.pAddVersMaps )
            {
                WinsFreeMem(ResultsN.pAddVersMaps);
                ResultsN.pAddVersMaps = NULL;
            }
            DisplayErrorMessage(EMSG_WINS_GETSTATUS_FAILED,
                                Status);
            continue;
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_GETSTATUS_SUCCESS);
        }
        
        if (MasterOwners < ResultsN.NoOfOwners) 
        {

            ret = InitLATable(ResultsN.pAddVersMaps, MasterOwners, ResultsN.NoOfOwners);
            if( LA_Table is NULL or
                SO_Table is NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_OUT_OF_MEMORY);
                if( pszName )
                {
                    WinsFreeMemory(pszName);
                    pszName = NULL;
                }
                if( ResultsN.pAddVersMaps )
                {
                    WinsFreeMem(ResultsN.pAddVersMaps);
                    ResultsN.pAddVersMaps = NULL;
                }
                
                if( SO_Table )
                {
                    WinsFreeMemory(SO_Table);
                    SO_Table = NULL;
                }
                if( LA_Table )
                {
                    WinsFreeMemory(LA_Table);
                    LA_Table = NULL;
                }

                if( wszStartIp )
                {
                    WinsFreeMemory(wszStartIp);
                    wszStartIp = NULL;
                }

                return;
            }

            MasterOwners = ret;
        }

        //
        // Place entry in the SO Table in proper order
        //
        AddSOTableEntry(LA_Table[i], ResultsN.pAddVersMaps, ResultsN.NoOfOwners, MasterOwners);
        if( pszName )
        {
            WinsFreeMemory(pszName);
            pszName = NULL;
        }

        if( ResultsN.pAddVersMaps )
        {
            WinsFreeMem(ResultsN.pAddVersMaps);
            ResultsN.pAddVersMaps = NULL;
        }

    }

    //
    // Check if diagonal elements in the [SO] table are the highest in their cols.
    //
    CheckSOTableConsistency(MasterOwners);
    
    DumpSOTable(MasterOwners,
                fFile,
                pFile);

    //
    // Destroy SO table
    //
    FreeSOTable(MasterOwners+1);
    FreeLATable(MasterOwners);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\common.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    common.c

Abstract:

    This module contains miscellaneous utility routines used by the
    DHCP server service. Code is hacked from convert.c

Author:

    Shubho Bhattacharya (a-sbhatt) 11/17/98

Revision History:

   

--*/

#include <precomp.h>

WCHAR    *messages[] = {
                        L"success",
                        L"name not found",
                        L"no response",
                        L"out of memory",
                        L"bad ip address",
                        L"host not found",
                        L"host address not verified",
                        L"invalid argument",
                        L"failed to open NBT driver"
                     };

SOCKET  sd;
WSADATA WsaData;

u_long NonBlocking = 1;

int     NumWinServers=0;
int     NumNBNames=0;

LPWSTR
WinsAnsiToUnicode(
    IN      LPCSTR Ansi,
    IN OUT  LPWSTR Unicode
    )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitString( &AnsiString, Ansi );

    UnicodeString.MaximumLength = 
        (USHORT)RtlAnsiStringToUnicodeSize( &AnsiString );

    if( Unicode == NULL ) {
        UnicodeString.Buffer =
            WinsAllocateMemory( UnicodeString.MaximumLength );
    }
    else {
        UnicodeString.Buffer = Unicode;
    }

    if ( UnicodeString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlAnsiStringToUnicodeString( &UnicodeString,
                                                  &AnsiString,
                                                  FALSE))){
        if( Unicode == NULL ) {
            WinsFreeMemory( UnicodeString.Buffer );
            UnicodeString.Buffer = NULL;
        }
        return NULL;
    }

    return UnicodeString.Buffer;
}

LPSTR
WinsUnicodeToAnsi(
    IN      LPCWSTR  Unicode,
    IN OUT  LPSTR   Ansi
)
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    AnsiString.MaximumLength =
        (USHORT) RtlUnicodeStringToAnsiSize( &UnicodeString );

    if( Ansi == NULL ) 
    {
        AnsiString.Buffer = WinsAllocateMemory( AnsiString.MaximumLength ); 
    }
    else 
    {
        AnsiString.Buffer = Ansi;
    }

    if ( AnsiString.Buffer == NULL ) 
    {
        return NULL;
    }

    if(!NT_SUCCESS( RtlUnicodeStringToAnsiString( &AnsiString,
                                                  &UnicodeString,
                                                  FALSE))){
        if( Ansi == NULL ) {
            WinsFreeMemory( AnsiString.Buffer );
            AnsiString.Buffer = NULL;
        }

        return NULL;
    }

    return AnsiString.Buffer;
}

LPSTR
WinsAnsiToOem(
    IN      LPCSTR   Ansi
    )
{
    LPSTR   Oem = NULL;
    LPWSTR  Unicode = NULL;

    Unicode = WinsAnsiToUnicode(Ansi, NULL);

    if( Unicode is NULL )
        return NULL;

    Oem = WinsUnicodeToOem(Unicode, NULL);

    WinsFreeMemory(Unicode);
    Unicode = NULL;

    return Oem;

}

LPWSTR
WinsOemToUnicodeN(
    IN      LPCSTR   Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    )
{

    
    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitString( &AnsiString, Ansi );

    UnicodeString.MaximumLength =
        cChars;

    if( Unicode == NULL ) {
        UnicodeString.Buffer =
            WinsAllocateMemory( UnicodeString.MaximumLength );
    }
    else {
        UnicodeString.Buffer = Unicode;
    }

    if ( UnicodeString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlOemStringToUnicodeString( &UnicodeString,
                                                  &AnsiString,
                                                  FALSE))){
        if( Unicode == NULL ) {
            WinsFreeMemory( UnicodeString.Buffer );
            UnicodeString.Buffer = NULL;
        }
        return NULL;
    }

    return UnicodeString.Buffer;
}



LPWSTR
WinsOemToUnicode(
    IN      LPCSTR Ansi,
    IN OUT  LPWSTR Unicode
    )
{
    OEM_STRING  AnsiString;

    RtlInitString( &AnsiString, Ansi );

    return WinsOemToUnicodeN(
                Ansi,
                Unicode,
                (USHORT) RtlOemStringToUnicodeSize( &AnsiString )
                );
}

/*++

Routine Description:

    Convert an OEM (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Ansi - Specifies the ASCII zero terminated string to convert.

    Unicode - Specifies the pointer to the unicode buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/



LPSTR
WinsUnicodeToOem(
    IN     LPCWSTR Unicode,
    IN OUT LPSTR   Ansi
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding OEM
    string.

Arguments:

    Ansi - Specifies the UNICODE zero terminated string to convert.

    Ansi - Specifies the pointer to the oem buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated OEM string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/

{

    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    AnsiString.MaximumLength =
        (USHORT) RtlUnicodeStringToOemSize( &UnicodeString );

    if( Ansi == NULL ) 
    {
        AnsiString.Buffer = WinsAllocateMemory( AnsiString.MaximumLength ); 
    }
    else 
    {
        AnsiString.Buffer = Ansi;
    }

    if ( AnsiString.Buffer == NULL ) 
    {
        return NULL;
    }

    if(!NT_SUCCESS( RtlUnicodeStringToOemString( &AnsiString,
                                                  &UnicodeString,
                                                  FALSE))){
        if( Ansi == NULL ) {
            WinsFreeMemory( AnsiString.Buffer );
            AnsiString.Buffer = NULL;
        }

        return NULL;
    }

    return AnsiString.Buffer;

}



VOID
WinsHexToString(
    OUT LPWSTR Buffer,
    IN  const BYTE * HexNumber,
    IN  DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to a Unicode
    string.  The string is not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.


Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length * 2; i+=2 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + L'0';
        } else {
            Buffer[i+1] = j + L'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + L'0';
        } else {
            Buffer[i] = j + L'A' - 10;
        }

        HexNumber++;
    }

    return;
}



VOID
WinsHexToAscii(
    OUT LPSTR Buffer,
    IN  const BYTE * HexNumber,
    IN  DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to an ASCII
    string.  The string is not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.

Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length; i+=1 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + '0';
        } else {
            Buffer[i+1] = j + 'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + '0';
        } else {
            Buffer[i] = j + 'A' - 10;
        }

        HexNumber++;
    }

    return;
}



VOID
WinsDecimalToString(
    OUT LPWSTR Buffer,
    IN  BYTE Number
    )
/*++

Routine Description:

    This functions converts a single byte decimal digit to a 3 character
    Unicode string.  The string not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least 3 characters in size.

    Number - The number to convert.

Return Value:

    None.

--*/
{
    Buffer[2] = Number % 10 + L'0';
    Number /= 10;

    Buffer[1] = Number % 10 + L'0';
    Number /= 10;

    Buffer[0] = Number + L'0';

    return;
}



DWORD
WinsDottedStringToIpAddress(
    IN LPCSTR String
    )
/*++

Routine Description:

    This functions converts a dotted decimal form ASCII string to a
    Host order IP address.

Arguments:

    String - The address to convert.

Return Value:

    The corresponding IP address.

--*/
{
    struct in_addr addr;

    addr.s_addr = inet_addr( String );
    return( ntohl(*(LPDWORD)&addr) );
}



LPSTR
WinsIpAddressToDottedString(
    IN DWORD IpAddress
    )
/*++

Routine Description:

    This functions converts a Host order IP address to a dotted decimal
    form ASCII string.

Arguments:

    IpAddress - Host order IP Address.

Return Value:

    String for IP Address.

--*/
{
    DWORD NetworkOrderIpAddress;

    NetworkOrderIpAddress = htonl(IpAddress);
    return(inet_ntoa( *(struct in_addr *)&NetworkOrderIpAddress));
}



#if DBG

VOID
WinsAssertFailed(
    IN LPCSTR FailedAssertion,
    IN LPCSTR FileName,
    IN DWORD LineNumber,
    IN LPCSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{
#ifndef DHCP_NOASSERT
    RtlAssert(
            (LPVOID)FailedAssertion,
            (LPVOID)FileName,
            (ULONG) LineNumber,
            (PCHAR) Message);
#endif

    WinsPrint(( 0, "Assert @ %s \n", FailedAssertion ));
    WinsPrint(( 0, "Assert Filename, %s \n", FileName ));
    WinsPrint(( 0, "Line Num. = %ld.\n", LineNumber ));
    WinsPrint(( 0, "Message is %s\n", Message ));

}

VOID
WinsPrintRoutine(
    IN DWORD  DebugFlag,
    IN LPCSTR Format,
    ...
)

{

#define WSTRSIZE( wsz ) ( ( wcslen( wsz ) + 1 ) * sizeof( WCHAR ) )

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

#if DBG
    WinsAssert(length <= MAX_PRINTF_LEN);
#endif //DBG


    //
    // Output to the debug terminal,
    //

    DbgPrint( "%s", OutputBuffer);
}

#endif // DBG

DWORD
CreateDumpFile(
    IN  LPCWSTR pwszName,
    OUT PHANDLE phFile
    )
{
    HANDLE  hFile;

    *phFile = NULL;

    hFile = CreateFileW(pwszName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if(hFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    *phFile = hFile;

    return NO_ERROR;
}

VOID
CloseDumpFile(
    HANDLE  hFile
)
{
    if( hFile )
        CloseHandle(hFile);
}





DWORD
WinsDottedStringToIpAddressW(
    IN LPCWSTR pwszString
)
{
    DWORD dwStrlen = 0;
    DWORD dwLen = 0;
    DWORD dwRes = INADDR_NONE;
    LPSTR pszString = NULL;
    if( pwszString == NULL )
        return dwRes;

    pszString = WinsUnicodeToOem(pwszString, NULL);
    if( pszString )
    {
        dwRes = WinsDottedStringToIpAddress(pszString);
        WinsFreeMemory(pszString);
        pszString = NULL;
    }
    
    return dwRes;
}


LPWSTR
WinsIpAddressToDottedStringW(
    DWORD   IpAddress
)
{
    DWORD dwStrlen = 0;
    DWORD dwLen = 0;
    DWORD dwRes = 0;
    LPWSTR pwszString = NULL;
    LPSTR  pszString = NULL;
    
    pszString = WinsIpAddressToDottedString(IpAddress);

    pwszString = WinsOemToUnicode(pszString, NULL);

    return pwszString;
}

BOOL
IsIpAddress(
    IN LPCWSTR pwszAddress
)
{
    LPSTR  pszAdd = NULL;
    LPSTR  pszTemp = NULL;
    

    if( IsBadStringPtr(pwszAddress, MAX_IP_STRING_LEN+1) is TRUE )
        return FALSE;
    if( wcslen(pwszAddress) < 3 )
        return FALSE;
    
    if( wcslen(pwszAddress) > 16 )
        return FALSE;
    pszAdd = WinsUnicodeToOem(pwszAddress, NULL);

    if( pszAdd is NULL )
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    pszTemp = strtok(pszAdd, ".");
    while(pszTemp isnot NULL )
    {
        DWORD i=0;
      
        for(i=0; i<strlen(pszTemp); i++)
        {
            if( tolower(pszTemp[i]) < L'0' or
                tolower(pszTemp[i]) > L'9' )
            return FALSE;
        }

        if( atol(pszTemp) < 0 or
            atol(pszTemp) > 255 )
        {
            return FALSE;
        }
        pszTemp = strtok(NULL, ".");
    }


    if( INADDR_NONE is inet_addr(pszAdd) )
    {
        WinsFreeMemory(pszAdd);
        pszAdd = NULL;
        return FALSE;
    }
    else
    {
        WinsFreeMemory(pszAdd);
        pszAdd = NULL;
        return TRUE;
    }
}

BOOL
IsValidServer(
    IN LPCWSTR pwszServer
)
{

    struct  hostent * lpHostEnt = NULL;
    DWORD             dwIpAddress = 0;
    
    LPSTR pszServer = NULL;

    if( pwszServer is NULL )
        return FALSE;

    pszServer = WinsUnicodeToAnsi(pwszServer, NULL);
    
    if( pszServer is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_OUT_OF_MEMORY);
        return FALSE;
    }

    //Is it an IPAddress?
    if( IsIpAddress(pwszServer) )
    {   
        dwIpAddress = inet_addr(pszServer);

        lpHostEnt = gethostbyaddr((char *)&dwIpAddress, 4, AF_INET);
    }
    else if( wcslen(pwszServer) > 2 and
             _wcsnicmp(pwszServer, L"\\\\", 2) is 0 )
    {
        lpHostEnt = gethostbyname(pszServer+2);

    }

    WinsFreeMemory(pszServer);

    return (lpHostEnt != NULL);
}

LPWSTR
MakeTimeString(
               DWORD dwTime
)
{
    LPWSTR  pwszTime = NULL;
    WCHAR   wcHr[3] = {L'\0'},
            wcMt[3] = {L'\0'},
            wcSc[3] = {L'\0'};
    DWORD   dwHr = 0,
            dwMt = 0,
            dwSc = 0,
            dw = 0;
    
    pwszTime = WinsAllocateMemory(9*sizeof(WCHAR));
    if( pwszTime )
    {
        for( dw=0; dw<8; dw++ )
            pwszTime[dw] = L'0';
        
        pwszTime[2] = pwszTime[5] = L':';

        dwHr = dwTime/(60*60);
        dwTime = dwTime - dwHr*60*60;
        dwMt = dwTime/60;
        dwTime = dwTime - dwMt*60;
        dwSc = dwTime;
        
        _itow((int)dwHr, wcHr, 10);
        _itow((int)dwMt, wcMt, 10);
        _itow((int)dwSc, wcSc, 10);

        if( dwHr isnot 0 )
        {
            wcsncpy(pwszTime+2-wcslen(wcHr), wcHr, wcslen(wcHr));
        }
        
        if( dwMt isnot 0 )
        {
            wcsncpy(pwszTime+5-wcslen(wcMt), wcMt, wcslen(wcMt));
        }

        wcsncpy(pwszTime+8-wcslen(wcSc), wcSc, wcslen(wcSc));

    }
    return pwszTime;
}

LPWSTR
MakeDayTimeString(
               DWORD dwTime
)
{
    LPWSTR  pwszTime = NULL;
    WCHAR   wcDay[4] = {L'\0'},
            wcHr[3] = {L'\0'},
            wcMt[3] = {L'\0'};
    DWORD   dwDay = 0,
            dwHr = 0,
            dwMt = 0,
            dw = 0;
    
    pwszTime = WinsAllocateMemory(10*sizeof(WCHAR));
    if( pwszTime )
    {
        for( dw=0; dw < 10; dw++ )
            pwszTime[dw] = L'0';

        
        pwszTime[3] = L':';
        pwszTime[6] = L':';
        pwszTime[9] = L'\0';

        dwDay = dwTime/(24*60*60);
        dwTime = dwTime - dwDay*24*60*60;

        dwHr = dwTime/(60*60);
        dwTime = dwTime - dwHr*60*60;
        
        dwMt = dwTime/60;
        dwTime = dwTime - dwMt*60;
       
        _itow(dwDay, wcDay,10);
        _itow(dwHr, wcHr, 10);
        _itow(dwMt, wcMt, 10);

        if( dwDay isnot 0 )
        {
            wcsncpy(pwszTime+3-wcslen(wcDay), wcDay, wcslen(wcDay));
        }

        if( dwHr isnot 0 )
        {
            wcsncpy(pwszTime+6-wcslen(wcHr), wcHr, wcslen(wcHr));
        }

        if( dwMt isnot 0 )
        {
            wcsncpy(pwszTime+9-wcslen(wcMt), wcMt, wcslen(wcMt));
        }
    }
    return pwszTime;
}


DWORD
ImportStaticMappingsFile(LPWSTR strFile,
                         BOOL fDelete
)
{
	DWORD   Status = NO_ERROR;
    WCHAR ws[256];

	Status = WinsDoStaticInit(g_hBind,
			     			 strFile,
							 fDelete);


	return Status;
}

BOOL
IsLocalServer(VOID)
{
    BOOL    fReturn = TRUE;
    WCHAR   wcName[MAX_COMPUTER_NAME_LEN+1] = {L'\0'};
    DWORD   dwLen = MAX_COMPUTER_NAME_LEN;

    fReturn = GetComputerNameEx(ComputerNameNetBIOS,
                                wcName,
                                &dwLen);
    if( fReturn is TRUE )
    {
        if( _wcsnicmp(wcName, g_ServerNameUnicode, dwLen ) is 0 )
        {
            return TRUE;
        }
        else
            return FALSE;
    }
    else
    {
        return FALSE;
    }
    
}

BOOL
IsPureNumeric(IN LPCWSTR pwszStr)
{
    DWORD   dwLen = 0,
            i;

    if( pwszStr is NULL )
        return FALSE;

    dwLen = wcslen(pwszStr);

    for(i=0; i<dwLen; i++ )
    {
        if( pwszStr[i] >= L'0' and
            pwszStr[i] <= L'9' )
        {
            continue;
        }
        else
            return FALSE;
            
    }
    return TRUE;
}


DWORD
DisplayErrorMessage(
    DWORD   dwMsgID,
    DWORD   dwErrID,
    ...
)
{
    LPWSTR  pwszErrorMsg = NULL;
    WCHAR   rgwcInput[MAX_MSG_LENGTH + 1] = {L'\0'};
    DWORD   dwMsgLen = 0;
    HANDLE  hWinsEvnt = NULL;
    va_list arglist;
    
    va_start(arglist, dwErrID);

    switch(dwErrID)
    {
    case ERROR_INVALID_PARAMETER:
        {
            DisplayMessage(g_hModule, EMSG_WINS_INVALID_PARAMETER);
            return dwErrID;
        }
    case ERROR_NOT_ENOUGH_MEMORY:
        {
            DisplayMessage(g_hModule, EMSG_WINS_OUT_OF_MEMORY);
            return dwErrID;
        }
    case ERROR_NO_MORE_ITEMS:
        {
            DisplayMessage(g_hModule, EMSG_WINS_NO_MORE_ITEMS);
            return dwErrID;
        }
    case ERROR_MORE_DATA:
        {
            DisplayMessage(g_hModule, EMSG_WINS_MORE_DATA);
            return dwErrID;
        }
    case ERROR_ACCESS_DENIED:
        {
            DisplayMessage(g_hModule, EMSG_WINS_ACCESS_DENIED);
            return dwErrID;
        }
    case ERROR_INVALID_DB_VERSION:
        {
            DisplayMessage(g_hModule, EMSG_INVALID_DB_VERSION);
            return dwErrID;
        }
    case ERROR_INVALID_IPADDRESS:
        {
            DisplayMessage(g_hModule, EMSG_INVALID_IPADDRESS);
            return dwErrID;
        }
    case ERROR_INVALID_PARTNER_NAME:
        {
            DisplayMessage(g_hModule, EMSG_INVALID_PARTNER_NAME);
            return dwErrID;
        }
    case ERROR_NO_PARTNER_EXIST:
        {
            DisplayMessage(g_hModule, EMSG_NO_PARTNER_EXIST);
            return dwErrID;
        }
    case ERROR_WINS_BIND_FAILED:
        {
            DisplayMessage(g_hModule, EMSG_WINS_BIND_FAILED, arglist);
            return dwErrID;
        }
    case ERROR_INVALID_PARAMETER_SPECIFICATION:
        {
            DisplayMessage(g_hModule, EMSG_INVALID_PARAMETER_SPECIFICATION);
            return dwErrID;
        }
    default:
        break;
    }

    //Is it Wins specific message ?

    hWinsEvnt = LoadLibrary(TEXT("WinsEvnt.dll"));
    
    if( hWinsEvnt is NULL )
    {
        DisplayMessage(g_hModule, MSG_DLL_LOAD_FAILED, TEXT("WinsEvnt.dll"));
        goto System;
    }

    if( !LoadStringW(hWinsEvnt,
                     dwErrID,
                     rgwcInput,
                     MAX_MSG_LENGTH) )
    {
        goto System;
    }

    dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |FORMAT_MESSAGE_FROM_STRING,
                              rgwcInput,
                              0,
                              0L,         // Default country ID.
                              (LPWSTR)&pwszErrorMsg,
                              0,
                              NULL);
    if( dwMsgLen isnot 0)
    {
        DisplayMessage(g_hModule, dwMsgID, pwszErrorMsg);
        goto Cleanup;
    }


    //Might be a system error returned by GetLastError();
System:
    dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwErrID,
                              0L,
                              (LPWSTR)&pwszErrorMsg,
                              0,
                              NULL);

    if( dwMsgLen isnot 0)
    {
        DisplayMessage(g_hModule, dwMsgID, pwszErrorMsg);
        goto Cleanup;
    }

    _itow(dwErrID, rgwcInput, 10);
    DisplayMessage(g_hModule, dwMsgID, rgwcInput);

Cleanup:
    if (hWinsEvnt)
        FreeLibrary(hWinsEvnt);

    if (pwszErrorMsg)
        LocalFree(pwszErrorMsg);

    return dwMsgLen;
}

/*---------------------------------------------------------------------------
	ControlWINSService(LPCTSTR pszName, BOOL bStop)
		Stops ot starts the WINS service on the local machine
    //Code hacked from the WINS MMC code
---------------------------------------------------------------------------*/


DWORD 
ControlWINSService(BOOL bStop)
{
    DWORD           dwState = bStop ? SERVICE_STOPPED : SERVICE_RUNNING;
    DWORD           dwPending = bStop ? SERVICE_STOP_PENDING : SERVICE_START_PENDING;
    DWORD           err = ERROR_SUCCESS;
	int             i;
    SERVICE_STATUS  ss;
    DWORD           dwControl;
    BOOL            fSuccess;
	SC_HANDLE       hService = NULL;
    SC_HANDLE       hScManager = NULL;

	// oepmnt he service control manager
    hScManager = OpenSCManager(g_ServerNameUnicode, NULL, SC_MANAGER_ALL_ACCESS);
    if (hScManager == NULL)
    {
        err = GetLastError();
        goto Error;
    }

	// get the handle to the WINS service
    hService = OpenService(hScManager, _T("WINS"), SERVICE_ALL_ACCESS);
    if (hService == NULL)
    {
        err = GetLastError();
        goto Error;
    }

	// if stop requested
	if (bStop)
	{
		dwControl = SERVICE_CONTROL_STOP;
		fSuccess = ControlService(hService, dwControl, &ss);
	    if (!fSuccess)
	    {
	        err = GetLastError();
            goto Error;
	    }
    }
	// otherwise start the service
	else
	{
		fSuccess = StartService(hService, 0, NULL);
	    if (!fSuccess)
	    {
	        err = GetLastError();
            goto Error;
	    }
	}

#define LOOP_TIME   5000
#define NUM_LOOPS   600

    // wait for the service to start/stop.  
    for (i = 0; i < NUM_LOOPS; i++)
    {
        QueryServiceStatus(hService, &ss);

        // check to see if we are done6
        if (ss.dwCurrentState == dwState)
        {
            int time = LOOP_TIME * i;
            DisplayMessage(g_hModule, MSG_WINS_SERVICE_TIME, time);
            break;
        }
        
        // now see if something bad happened
        if (ss.dwCurrentState != dwPending)
        {
            int time = LOOP_TIME * i;
            DisplayMessage(g_hModule, MSG_WINS_SERVICE_TIME, time);
            break;
        }

        Sleep(LOOP_TIME);
    }

    if (i == NUM_LOOPS)
        DisplayMessage(g_hModule, EMSG_WINS_SERVICE_FAILED);

    if (ss.dwCurrentState != dwState)
        err = ERROR_SERVICE_REQUEST_TIMEOUT;

Error:
    // close the respective handles
	if (hService)
        CloseServiceHandle(hService);

    if (hScManager)
        CloseServiceHandle(hScManager);

	return err;
}

VOID
OEMprintf(
    FILE * pFile,
    IN  PWCHAR  pwszUnicode
    )
{
    PCHAR achOem;
    DWORD dwLen;

    dwLen = WideCharToMultiByte( CP_OEMCP,
                         0,
                         pwszUnicode,
                         -1,
                         NULL,
                         0,
                         NULL,
                         NULL );

    achOem = malloc(dwLen);
    if (achOem) 
    {
        WideCharToMultiByte( CP_OEMCP,
                             0,
                             pwszUnicode,
                             -1,
                             achOem,
                             dwLen,
                             NULL,
                             NULL );
    
        fprintf( stdout, "%hs", achOem );
    
        free(achOem);
    }
}

VOID
MyDisplayMessage(
    IN  FILE     *pFile,
    IN  PWCHAR   pwszFormat,
    IN  va_list *parglist
    )
{
    DWORD        dwMsgLen = 0;
    PWCHAR       pwszOutput = NULL;
    LPSTR        pszOutput = NULL;

    do
    {
        dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER 
                                  |FORMAT_MESSAGE_FROM_STRING,
                                  pwszFormat,
                                  0,
                                  0L,         // Default country ID.
                                  (LPWSTR)&pwszOutput,
                                  0,
                                  parglist);

        if(dwMsgLen == 0)
        {
            fwprintf( pFile, L"Error %d in FormatMessageW()\n", GetLastError());            

            ASSERT(pwszOutput == NULL);

            break;
        }
        
        pszOutput = WinsUnicodeToOem(pwszOutput, NULL );
        if( pszOutput is NULL )
        {
            fwprintf(pFile, pwszOutput);
        }
        else
        {
            fprintf(pFile, pszOutput);
            WinsFreeMemory(pszOutput);
            pszOutput = NULL;
        }


    } while ( FALSE );

    if ( pwszOutput) { LocalFree( pwszOutput ); }

    return;
}

VOID
DumpMessage(
            HANDLE      hModule,
            FILE      * pFile,           
            DWORD       dwMsgId,
            ...
           )
{
    DWORD        dwMsgLen = 0;
    PWCHAR       pwszOutput = NULL;
    WCHAR        rgwcInput[MAX_MSG_LENGTH + 1];
    va_list      arglist;

    if ( !LoadStringW(hModule,
                      dwMsgId,
                      rgwcInput,
                      MAX_MSG_LENGTH) )
    {
        return;
    }

    va_start(arglist, dwMsgId);

    MyDisplayMessage(pFile,
                     rgwcInput,
                     &arglist);
    return;

}

VOID
TimeToFileTime(time_t time,
               LPFILETIME pftTime)
{
    LONGLONG longval = (LONGLONG)0;

    longval = Int32x32To64(time, 10000000) + 116444736000000000;
    pftTime->dwLowDateTime = (DWORD)longval;

    longval = (longval & 0xFFFFFFFF00000000);
    longval >>= 32;
    pftTime->dwHighDateTime = (DWORD)longval;
}

DWORD
GetDateTimeInfo(LCTYPE          lcType,
                LPSYSTEMTIME    lpSystemTime,
                LPWSTR          pwszBuffer,
                DWORD           *pdwBufferLen)
{
    DWORD   dwError = NO_ERROR;
    BOOL    fQueryLen = FALSE;
    int     cchFormat = 0,
            cchData = 0;
    
    PVOID   pfnPtr = NULL;
    DWORD   dwBuff = 0,
            dwInputBuff = 0;


    LPWSTR  pwszFormat = NULL,
            pwszData = NULL;


    if( pdwBufferLen is NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwInputBuff = *pdwBufferLen;
    *pdwBufferLen = 0;

    if( pwszBuffer is NULL or
        dwInputBuff is 0 )
    {
        fQueryLen = TRUE;
    }

    cchFormat = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT,
                            lcType,
                            NULL,
                            0);

    if( cchFormat is 0 )
    {
        dwError = GetLastError();
        goto RETURN;
    }

    pwszFormat = WinsAllocateMemory(cchFormat*sizeof(WCHAR));
    if( pwszFormat is NULL )
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto RETURN;
    }

    cchFormat = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT,
                              lcType,
                              pwszFormat,
                              cchFormat);

    if( cchFormat is 0 )
    {
        dwError = GetLastError();
        goto RETURN;
    }
    
    if( lcType isnot LOCALE_STIMEFORMAT )
    {
        cchData = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                0,
                                lpSystemTime,
                                pwszFormat,
                                NULL,
                                0);

        if( cchData is 0 )
        {
            dwError = GetLastError();
            goto RETURN;
        }
    
        if( fQueryLen is FALSE )
        {    
            if( cchData > (int)dwInputBuff )
            {
                dwError = ERROR_INSUFFICIENT_BUFFER;
                goto RETURN;
            }

            cchData = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                    0,
                                    lpSystemTime,
                                    pwszFormat,
                                    pwszBuffer,
                                    (int)dwInputBuff);

            if( cchData is 0 )
            {
                dwError = GetLastError();
                goto RETURN;
            }   
        }
    }
    else
    {
        cchData = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                                0,
                                lpSystemTime,
                                pwszFormat,
                                NULL,
                                0);

        if( cchData is 0 )
        {
            dwError = GetLastError();
            goto RETURN;
        }
    
        if( fQueryLen is FALSE )
        {    
            if( cchData > (int)dwInputBuff )
            {
                dwError = ERROR_INSUFFICIENT_BUFFER;
                goto RETURN;
            }

            cchData = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                                    0,
                                    lpSystemTime,
                                    pwszFormat,
                                    pwszBuffer,
                                    (int)dwInputBuff);

            if( cchData is 0 )
            {
                dwError = GetLastError();
                goto RETURN;
            }   
        }
    }

    dwBuff += cchData;
    *pdwBufferLen = dwBuff;

RETURN:
    if( pwszFormat )
    {
        WinsFreeMemory(pwszFormat);
        pwszFormat = NULL;
    }
    return dwError;

}

DWORD
FormatDateTimeString( time_t  time,
                      BOOL    fShort,
                      LPWSTR  pwszBuffer,
                      DWORD  *pdwBuffLen)
{
    BOOL        fQueryLen = FALSE;
    DWORD       dwError = NO_ERROR,
                dwBufferLen = 0;
    DWORD       dwBuff = 0,
                dwInputBuff = 0;
    FILETIME    ftTime = {0},
                ftLocalTime = {0};
    SYSTEMTIME  stTime = {0};

    if( pdwBuffLen is NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    dwInputBuff = *pdwBuffLen;

    if( pwszBuffer is NULL or
        dwInputBuff is 0 )
    {
        fQueryLen = TRUE;
    }
    
    TimeToFileTime(time, &ftTime);

    if( !FileTimeToLocalFileTime(&ftTime, &ftLocalTime) )
    {
        dwError = GetLastError();
        goto RETURN;
    }

    if( !FileTimeToSystemTime(&ftLocalTime, &stTime) )
    {
        dwError = GetLastError();
        goto RETURN;
    }
    
    if( fQueryLen is TRUE )
    {
        dwError = GetDateTimeInfo(fShort ? LOCALE_SSHORTDATE : LOCALE_SLONGDATE,
                                  &stTime,
                                  NULL,
                                  &dwBuff);

        if( dwError isnot NO_ERROR )
            goto RETURN;

    }
    else
    {
        dwBuff = dwInputBuff;
        dwError = GetDateTimeInfo(fShort ? LOCALE_SSHORTDATE : LOCALE_SLONGDATE,
                                  &stTime,
                                  pwszBuffer,
                                  &dwBuff);
        if( dwError isnot NO_ERROR )
            goto RETURN;
    }

    dwBufferLen += dwBuff;

    //Increment to add a space between date and time
    dwBufferLen ++;

    if( fQueryLen is TRUE )
    {
        dwBuff = 0;
        dwError = GetDateTimeInfo(LOCALE_STIMEFORMAT,
                                  &stTime,
                                  NULL,
                                  &dwBuff);
        if( dwError isnot NO_ERROR )
            goto RETURN;
    }
    else
    {
        if( dwBufferLen > dwInputBuff )
        {
            dwError = ERROR_INSUFFICIENT_BUFFER;
            goto RETURN;
        }

        wcscat( pwszBuffer, L" ");
        dwBuff = dwInputBuff - dwBufferLen;
        dwError = GetDateTimeInfo(LOCALE_STIMEFORMAT,
                                  &stTime,
                                  pwszBuffer + dwBufferLen - 1,
                                  &dwBuff);
        if( dwError isnot NO_ERROR )
            goto RETURN;
    }

    dwBufferLen += dwBuff;
    
    *pdwBuffLen = dwBufferLen;
    
RETURN:
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\mib\winsmibm.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    winsmibm.c

Abstract:

    Sample SNMP Extension Agent for Windows NT.

    These files (winsdll.c, winsmib.c, and winsmib.h) provide an example of 
    how to structure an Extension Agent DLL which works in conjunction with 
    the SNMP Extendible Agent for Windows NT.

    Extensive comments have been included to describe its structure and
    operation.  See also "Microsoft Windows/NT SNMP Programmer's Reference".

Created:

    28-Jun-1991

Revision History:

--*/


static char *vcsid = "@(#) $Logfile:   N:/xtest/vcs/winsdll.c_v  $ $Revision:   1.6  $";

#ifdef UNICODE
#undef UNICODE
#endif

// General notes:
//
//   Microsoft's Extendible Agent for Windows NT is implemented by dynamically
// linking to Extension Agent DLLs that implement portions of the MIB.  These
// Extension Agents are configured in the Windows NT Registration Database.
// When the Extendible Agent Service is started, it queries the registry to
// determine which Extension Agent DLLs have been installed and need to be
// loaded and initialized.  The Extendible Agent invokes various DLL entry
// points (examples follow in this file) to request MIB queries and obtain
// Extension Agent generated traps.


// Necessary includes.

#include <windows.h>
#include <malloc.h>
#include <tchar.h>
#include <snmp.h>


// Contains definitions for the table structure describing the MIB.  This
// is used in conjunction with winsmib.c where the MIB requests are resolved.

#include "winsmib.h"


// Extension Agent DLLs need access to elapsed time agent has been active.
// This is implemented by initializing the Extension Agent with a time zero
// reference, and allowing the agent to compute elapsed time by subtracting
// the time zero reference from the current system time.  This example
// Extension Agent implements this reference with dwTimeZero.

DWORD dwTimeZero = 0;


// Extension Agent DLLs that generate traps must create a Win32 Event object
// to communicate occurence of traps to the Extendible Agent.  The event
// handle is given to the Extendible Agent when the Extension Agent is 
// initialized, it should be NULL if traps will not be generated.  This
// example Extension Agent simulates the occurance of traps with hSimulateTrap.

HANDLE hSimulateTrap = NULL;

// The following variables are needed in order to figure out if the WINS service
// is installed and running on the box. If this is not true, the subagent should
// return SNMP_ERRORSTATUS_NOSUCHNAME for any query, instead of failing later with
// SNMP_ERRORSTATUS_GENERR.
#define WINS_SVC_NAME   _T("WINS")
SC_HANDLE hSvcController = NULL;
SC_HANDLE hWinsSvc = NULL;

// This call returns true if the WINS service is installed and running and
// false otherwise. If WINS is not running, the subagent should fail with
// SNMP_ERRORSTATUS_NOSUCHNAME or should return the first OID out of the MIB view
// instead of an SNMP_ERRORSTATUS_GENERR.
BOOL CheckWinsServiceUp(
    OUT AsnInteger *errorStatus)
{
    SERVICE_STATUS winsSvcStatus;

    // at first request, open the service controller handle
    if (hSvcController == NULL)
    {
        hSvcController = OpenSCManager(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
        // if unsuccessful this is a real genErr case (any app should be able to do so)
        if (hSvcController == NULL)
        {
            *errorStatus = SNMP_ERRORSTATUS_GENERR;
            return FALSE;
        }
    }

    // at first request, open the Wins service handle
    if (hWinsSvc == NULL)
    {
        hWinsSvc = OpenService(hSvcController, WINS_SVC_NAME, SERVICE_QUERY_STATUS);
        // if unsuccessful it might be that the service is not installed. In this case,
        // return noSuchName, otherwise there is a genErr case
        if (hWinsSvc == NULL)
        {
            *errorStatus = (GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) ?
                                SNMP_ERRORSTATUS_NOSUCHNAME :
                                SNMP_ERRORSTATUS_GENERR;
            return FALSE;
        }
    }

    // we have both the service controller and the wins service handle, just query for the status
    if (!QueryServiceStatus(hWinsSvc, &winsSvcStatus))
    {
        // if querying the status of the service failed, this is a case of genErr
        *errorStatus = SNMP_ERRORSTATUS_GENERR;
        return FALSE;
    }


    // if WINS is in any other state than 'running', will handle as the service is stopped
    // and return NOSUCHNAME (allowing a possible MIB walk to continue)
    if (winsSvcStatus.dwCurrentState != SERVICE_RUNNING)
    {
       *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
       return FALSE;
    }

    // at this point the service is up and running
    *errorStatus = SNMP_ERRORSTATUS_NOERROR;
    return TRUE;
}

// This call returns true if the WINSMIB is allowed to run (via registry setting)
// and FALSE otherwise. If FALSE, the errorStatus is set to SNMP_ERRORSTATUS_NOSUCHNAME.
BOOL CheckWinsMibAllowed(
    OUT AsnInteger *errorStatus)
{
    BOOL bRetCode = FALSE;
    HKEY hKey = NULL;

    RegOpenKey(
        HKEY_LOCAL_MACHINE,
        _T("System\\CurrentControlSet\\Services\\WINS\\Parameters"),
        &hKey);

    if (hKey != NULL)
    {
        DWORD dwDataSize = sizeof(BOOL);
        DWORD dwDataType = 0;

        if ((RegQueryValueEx(
                hKey,
                _T("AllowMIB"),
                NULL,
                &dwDataType,
                (LPBYTE)&bRetCode,
                &dwDataSize) == ERROR_SUCCESS) &&
             (dwDataType == REG_DWORD)
            )
        {
            // normalize the return value to a boolean
            bRetCode = (bRetCode != 0);
        }
    }

    if (hKey != NULL)
        RegCloseKey(hKey);

    *errorStatus = bRetCode ? SNMP_ERRORSTATUS_NOSUCHNAME : SNMP_ERRORSTATUS_NOERROR;

    return bRetCode;
}

// This is a standard Win32 DLL entry point.  See the Win32 SDK for more
// information on its arguments and their meanings.  This example DLL does 
// not perform any special actions using this mechanism.

BOOL WINAPI DllMain(
    HANDLE hDll,
    DWORD  dwReason,
    LPVOID lpReserved)
    {
    switch(dwReason)
        {
        case DLL_PROCESS_ATTACH:
        case DLL_PROCESS_DETACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            break;

        } // end switch()

    return TRUE;

    } // end DllEntryPoint()


// Extension Agent DLLs provide the following entry point to coordinate the
// initializations of the Extension Agent and the Extendible Agent.  The
// Extendible Agent provides the Extension Agent with a time zero reference;
// and the Extension Agent provides the Extendible Agent with an Event handle 
// for communicating occurence of traps, and an object identifier representing
// the root of the MIB subtree that the Extension Agent supports.

BOOL SnmpExtensionInit(
    IN  DWORD               dwTimeZeroReference,
    OUT HANDLE              *hPollForTrapEvent,
    OUT AsnObjectIdentifier *supportedView)
    {

    // Record the time reference provided by the Extendible Agent.

    dwTimeZero = dwTimeZeroReference;


    // Create an Event that will be used to communicate the occurence of traps
    // to the Extendible Agent.  The Extension Agent will assert this Event
    // when a trap has occured.  This is explained further later in this file.

    if ((*hPollForTrapEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        {
        // Indicate error?, be sure that NULL is returned to Extendible Agent.
        }


    // Indicate the MIB view supported by this Extension Agent, an object
    // identifier representing the sub root of the MIB that is supported.

    *supportedView = MIB_OidPrefix; // NOTE!  structure copy


    // Record the trap Event.  This example Extension Agent simulates traps by 
    // generating a trap after every given number of processed requests.

    hSimulateTrap = *hPollForTrapEvent;

    WinsMibInit();

    // Indicate that Extension Agent initialization was sucessfull.

    return TRUE;

    } // end SnmpExtensionInit()


// Extension Agent DLLs provide the following entry point to communcate traps
// to the Extendible Agent.  The Extendible Agent will query this entry point
// when the trap Event (supplied at initialization time) is asserted, which
// indicates that zero or more traps may have occured.  The Extendible Agent 
// will repetedly call this entry point until FALSE is returned, indicating 
// that all outstanding traps have been processed.

BOOL SnmpExtensionTrap(
    OUT AsnObjectIdentifier *enterprise,
    OUT AsnInteger          *genericTrap,
    OUT AsnInteger          *specificTrap,
    OUT AsnTimeticks        *timeStamp,
    OUT RFC1157VarBindList  *variableBindings)
    {
    // The body of this routine is an extremely simple example/simulation of
    // the trap functionality.  A real implementation will be more complex.


    // The following define data inserted into the trap below.  The Lan Manager
    // bytesAvailAlert from the Lan Manager Alerts-2 MIB is generated with an
    // empty variable bindings list.

    static UINT OidList[]  = { 1, 3, 6, 1, 4, 1, 311, 1, 2 };
    static UINT OidListLen = 9;


    // The following variable is used for the simulation, it allows a single
    // trap to be generated and then causes FALSE to be returned indicating
    // no more traps.

    static whichTime = 0;


    // The following if/else support the simulation.

    if (whichTime == 0)
        {
        whichTime = 1;    // Supports the simulation.


        // Communicate the trap data to the Extendible Agent.

        enterprise->idLength = OidListLen;
        enterprise->ids = (UINT *)SNMP_malloc(sizeof(UINT) * OidListLen);
        memcpy(enterprise->ids, OidList, sizeof(UINT) * OidListLen);

        *genericTrap      = SNMP_GENERICTRAP_ENTERSPECIFIC;

        *specificTrap     = 1;                    // the bytesAvailAlert trap

        *timeStamp        = GetCurrentTime() - dwTimeZero;

        variableBindings->list = NULL;
        variableBindings->len  = 0;


        // Indicate that valid trap data exists in the parameters.

        return TRUE;
        }
    else
        {
        whichTime = 0;    // Supports the simulation.


        // Indicate that no more traps are available and parameters do not
        // refer to any valid data.

        return FALSE;
        }

    } // end SnmpExtensionTrap()


// Extension Agent DLLs provide the following entry point to resolve queries
// for MIB variables in their supported MIB view (supplied at initialization
// time).  The requestType is Get/GetNext/Set.

BOOL SnmpExtensionQuery(
    IN BYTE                   requestType,
    IN OUT RFC1157VarBindList *variableBindings,
    OUT AsnInteger            *errorStatus,
    OUT AsnInteger            *errorIndex)
{
    static unsigned long requestCount = 0;  // Supports the trap simulation.
    UINT    I;


//    EnterCriticalSection(&WinsMibCrtSec);
try {
    //
    // Iterate through the variable bindings list to resolve individual
    // variable bindings.
    //

    fWinsMibWinsStatusCnfCalled  = FALSE;
    fWinsMibWinsStatusStatCalled = FALSE;
    for ( I=0;I < variableBindings->len;I++ )
    {
        // resolve the variables only if WINS is up and running.
        if (CheckWinsServiceUp(errorStatus) &&
            CheckWinsMibAllowed(errorStatus))
        {
            *errorStatus = ResolveVarBind( &variableBindings->list[I],
                                           requestType );
        }


	//
        // Test and handle case where Get Next past end of MIB view supported
        // by this Extension Agent occurs.  Special processing is required to 
        // communicate this situation to the Extendible Agent so it can take 
        // appropriate action, possibly querying other Extension Agents.
	//

        if ( *errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME &&
             requestType == MIB_GETNEXT )
           {
           *errorStatus = SNMP_ERRORSTATUS_NOERROR;


           // Modify variable binding of such variables so the OID points
           // just outside the MIB view supported by this Extension Agent.
           // The Extendible Agent tests for this, and takes appropriate
           // action.

           SNMP_oidfree( &variableBindings->list[I].name );
           SNMP_oidcpy( &variableBindings->list[I].name, &MIB_OidPrefix );
           variableBindings->list[I].name.ids[MIB_PREFIX_LEN-1] ++;
           }


        // If an error was indicated, communicate error status and error
        // index to the Extendible Agent.  The Extendible Agent will ensure
        // that the origional variable bindings are returned in the response
        // packet.

        if ( *errorStatus != SNMP_ERRORSTATUS_NOERROR )
        {
	   *errorIndex = I+1;
	//   goto Exit;
	}
	else
	{
		*errorIndex = 0;
	}
   }

} // end of try
except(EXCEPTION_EXECUTE_HANDLER) {
	//
	// for now do nothing
	//	
	}
   // LeaveCriticalSection(&WinsMibCrtSec);

#if 0
    // Supports the trap simulation.

    if (++requestCount % 3 == 0 && hSimulateTrap != NULL)
        SetEvent(hSimulateTrap);


    // Indicate that Extension Agent processing was sucessfull.


#if 0
      if (*errorStatus != SNMP_ERRORSTATUS_NOERROR)
      {
	 return(FALSE);
      }	

    return TRUE;
#endif
#endif
    if (fWinsMibWinsKeyOpen)
    {
	RegCloseKey(WinsMibWinsKey);
	fWinsMibWinsKeyOpen = FALSE;
    }
    return SNMPAPI_NOERROR;

} // end SnmpExtensionQuery()

VOID
SnmpExtensionClose()
{
    // close the Wins service handle if it was previously opened
    if (hWinsSvc != NULL)
    {
        CloseServiceHandle(hWinsSvc);
    }

    // close the service controller handle if it was previously opened
    if (hSvcController != NULL)
    {
        CloseServiceHandle(hSvcController);
    }
}

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\dump.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/
#include "precomp.h"
#include "strdefs.h"


DWORD
WinsDumpServer(IN LPCWSTR              pwszServerIp,
               IN LPCWSTR              pwszNetBiosName,
               IN handle_t             hBind,
               IN WINSINTF_BIND_DATA_T BindData
              )
{
    DWORD           Status = NO_ERROR;
    HKEY            hServer = NULL,
                    hParameter = NULL,
                    hDefaultPull = NULL,
                    hDefaultPush = NULL,
                    hPartner = NULL,
                    hCheck = NULL,
                    hPullPart = NULL,
                    hPushPart = NULL;

    DWORD           dwType = 0,
                    dwSize = 1024*sizeof(WCHAR),
                    dwData = 0;

    LPWSTR          pwszData = NULL,
                    pTemp = NULL;

    WCHAR           wcData[1024] = {L'\0'};
    BOOL            fBackDir = TRUE;

    Status = RegConnectRegistry(pwszNetBiosName,
                                HKEY_LOCAL_MACHINE,
                                &hServer);

    if( Status isnot NO_ERROR )
    {
        goto RETURN;
    }

    Status = RegOpenKeyEx(hServer,
                          PARAMETER,
                          0,
                          KEY_READ,//KEY_ALL_ACCESS,
                          &hParameter);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegOpenKeyEx(hServer,
                          PARTNERROOT,
                          0,
                          KEY_READ, //KEY_ALL_ACCESS,
                          &hPartner);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegOpenKeyEx(hServer,
                          PULLROOT,
                          0,
                          KEY_READ, //KEY_ALL_ACCESS,
                          &hPullPart);

    if( Status isnot NO_ERROR )
        goto RETURN;



    Status = RegOpenKeyEx(hServer,
                          PUSHROOT,
                          0,
                          KEY_READ, //KEY_ALL_ACCESS,
                          &hPushPart);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegOpenKeyEx(hServer,
                          DEFAULTPULL,
                          0,
                          KEY_READ, //KEY_ALL_ACCESS,
                          &hDefaultPull);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegOpenKeyEx(hServer,
                          DEFAULTPUSH,
                          0,
                          KEY_READ, //KEY_ALL_ACCESS,
                          &hDefaultPush);

    if( Status isnot NO_ERROR )
        goto RETURN;

    //Set Backuppath, Display only when Backup path is set.

    Status = NO_ERROR;

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_BACKUP_DIR_PATH_NM,
                             NULL,
                             &dwType,
                             NULL,
                             &dwSize);

    
    if( Status is NO_ERROR and
        dwSize >= sizeof(WCHAR) )
    {
        pwszData = WinsAllocateMemory(dwSize);

        if( pwszData is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto RETURN;
        }

        Status = NO_ERROR;
    
        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_BACKUP_DIR_PATH_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)pwszData,
                                 &dwSize);
        
        if( Status isnot NO_ERROR )
        {
            if( pwszData )
            {
                WinsFreeMemory(pwszData);
                pwszData = NULL;
            }
            goto RETURN;
        }

        if( wcscmp(pwszData, L" ") is 0 or
            wcslen(pwszData) < 1 )
        {
            fBackDir = FALSE;
        }

        if( !ExpandEnvironmentStrings(pwszData, wcData, 1023) )
        {
            if( pwszData )
            {
                WinsFreeMemory(pwszData);
                pwszData = NULL;
            }
            Status = GetLastError();
            goto RETURN;
        }
    }
    else if( Status is ERROR_FILE_NOT_FOUND || 
             dwSize < sizeof(WCHAR) )
    {
        fBackDir = FALSE;
    }
    else if( Status isnot NO_ERROR ) 
    {
        goto RETURN;
    }
    else
    {
        fBackDir = FALSE;
    }
         

    dwSize = sizeof(DWORD);

    Status = NO_ERROR;

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_DO_BACKUP_ON_TERM_NM,
                             NULL,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwSize);

    if( Status isnot NO_ERROR )
        goto RETURN;

    if( dwData > 0 )
        dwData = 1;

    if( fBackDir )
    {
        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_BACKUPPATH,
                       pwszServerIp,
                       wcData,
                       dwData);
    }
    else
    {
        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_BACKUPTERM,
                       pwszServerIp,
                       dwData);
    }  

    memset(wcData, 0x00, 1024*sizeof(WCHAR));

    //Set Name record
    {

        WINSINTF_RESULTS_T      Results = {0};
        WINSINTF_RESULTS_NEW_T  ResultsN = {0};
        BOOL                    fNew = TRUE;
        

		ResultsN.WinsStat.NoOfPnrs = 0;
		ResultsN.WinsStat.pRplPnrs = NULL;
		ResultsN.NoOfWorkerThds = 1;

        Status = WinsStatusNew(g_hBind,
                               WINSINTF_E_CONFIG,
                               &ResultsN);

        if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
        {
            //Try old API
            Results.WinsStat.NoOfPnrs = 0;
            Results.WinsStat.pRplPnrs = 0;
            Status = WinsStatus(g_hBind, WINSINTF_E_CONFIG, &Results);
            fNew = FALSE;
        }
        
        if( Status is NO_ERROR )
        {
            if( fNew )
            {
                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_NAMERECORD,
                               pwszServerIp,
                               ResultsN.RefreshInterval,
                               ResultsN.TombstoneInterval,
                               ResultsN.TombstoneTimeout,
                               ResultsN.VerifyInterval);
                               
            }
            else
            {
                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_NAMERECORD,
                               pwszServerIp,
                               Results.RefreshInterval,
                               Results.TombstoneInterval,
                               Results.TombstoneTimeout,
                               Results.VerifyInterval);                
            }

        }
        else
        {
               DisplayMessage(g_hModule,
                               DMP_SRVR_SET_NAMERECORD,
                               pwszServerIp,
                               NAMERECORD_REFRESH_DEFAULT,
                               NAMERECORD_EXINTVL_DEFAULT,
                               NAMERECORD_EXTMOUT_DEFAULT,
                               NAMERECORD_VERIFY_DEFAULT);
        }

                            
    }


    //Set Periodic DB Checking 
    {
        DWORD   dwMaxRec = 30000,
                dwUseRpl = 0,
                dwTimeIntvl = 24,
                dwState = 0,
                dwStart = 2*60*60;        
        LPWSTR  pwcTemp = NULL;
        
        Status = NO_ERROR;
        
        Status = RegOpenKeyEx(hServer,
                              CCROOT,
                              0,
                              KEY_READ, //KEY_ALL_ACCESS,
                              &hCheck);

        if( Status is NO_ERROR )
        {
            dwState = 1;
            dwData = 0;
            dwSize = sizeof(DWORD);
        
            Status = RegQueryValueEx(hCheck,
                                     WINSCNF_CC_MAX_RECS_AAT_NM,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwSize);

            if( Status is NO_ERROR )
                dwMaxRec = dwData;

            dwData = 0;
            Status = RegQueryValueEx(hCheck,
                                     WINSCNF_CC_USE_RPL_PNRS_NM,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwSize);

            if( Status is NO_ERROR )
                dwUseRpl = dwData;

            if( dwUseRpl > 1 )
                dwUseRpl = 1;

            dwData = 0;
            Status = RegQueryValueEx(hCheck,
                                     WINSCNF_CC_INTVL_NM,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwSize);

            if( Status is NO_ERROR )
            {
                dwTimeIntvl = dwData/(60*60);
            }
            
            dwSize = 1024*sizeof(WCHAR);

            Status = RegQueryValueEx(hCheck,
                                     WINSCNF_SP_TIME_NM,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)&wcData,
                                     &dwSize);

            if( Status is NO_ERROR )
            {
                WCHAR wcHr[3] = {L'\0'},
                      wcMt[3] = {L'\0'},
                      wcSc[3] = {L'\0'};

                wcsncpy(wcHr, wcData, 2);

                wcsncpy(wcMt, wcData+3, 2);
                wcsncpy(wcSc, wcData+6, 2);

                dwStart = wcstoul(wcHr, NULL, 10)*60*60 + 
                          wcstoul(wcMt, NULL, 10)*60 + 
                          wcstoul(wcSc, NULL, 10);
            }

        }

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_PERIODICDBCHECKING,
                       pwszServerIp,
                       dwState,
                       dwMaxRec,
                       dwUseRpl,
                       dwTimeIntvl,
                       dwStart);

        if( hCheck )
        {
            RegCloseKey(hCheck);
            hCheck = NULL;
        }
    }
    
    //Set replicate flag
    dwSize = sizeof(DWORD);
    dwData = 0;
    
    Status = NO_ERROR;
    
    Status = RegQueryValueEx(hParameter,
                             WINSCNF_RPL_ONLY_W_CNF_PNRS_NM,
                             NULL,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwSize);
    
    if( Status isnot NO_ERROR )
    {
        dwData = 0;
    }
    
    if( dwData > 1 )
        dwData = 1;

    DisplayMessage(g_hModule,
                   DMP_SRVR_SET_REPLICATEFLAG,
                   pwszServerIp,
                   dwData);

    //Set Migrate flag
    dwSize = sizeof(DWORD);
    dwData = 0;

    Status = NO_ERROR;

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_MIGRATION_ON_NM,
                             NULL,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwSize);
    
    if( Status isnot NO_ERROR )
    {
        dwData = 0;
    }
    
    if( dwData > 1 )
        dwData = 1;

    DisplayMessage(g_hModule,
                   DMP_SRVR_SET_MIGRATEFLAG,
                   pwszServerIp,
                   dwData);

    //Set PullParam
    {
        DWORD   dwState = 0,
                dwStartUp = 0,
                dwStart = 0,
                dwRepIntvl = 0,
                dwRetry = 0;

        Status = NO_ERROR;

        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hDefaultPull,
                                 WINSCNF_RPL_INTERVAL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
           dwRepIntvl = dwData;

        dwSize = 1024*sizeof(WCHAR);

        Status = RegQueryValueEx(hDefaultPull,
                                 WINSCNF_SP_TIME_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)wcData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            WCHAR wcHr[3] = {L'\0'},
                  wcMt[3] = {L'\0'},
                  wcSc[3] = {L'\0'};

            wcsncpy(wcHr, wcData, 2);

            wcsncpy(wcMt, wcData+3, 2);
            wcsncpy(wcSc, wcData+6, 2);
            dwStart = wcstoul(wcHr, NULL, 10)*60*60 + 
                      wcstoul(wcMt, NULL, 10)*60 + 
                      wcstoul(wcSc, NULL, 10);
        }

        dwSize = sizeof(DWORD);
        dwData = 0;

        Status = RegQueryValueEx(hPullPart,
                                 PERSISTENCE,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            dwState = dwData;
        }

        if( dwState > 1 )
            dwState = 1;

        dwData = 0;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hPullPart,
                                 WINSCNF_RETRY_COUNT_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);
        
        if(Status is NO_ERROR )
        {
            dwRetry = dwData;
        }

        dwData = 0;
        dwSize = sizeof(DWORD);
        Status = RegQueryValueEx(hPullPart,
                                 WINSCNF_INIT_TIME_RPL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            dwStartUp = dwData;
        }

        if( dwStartUp > 1 )
            dwStartUp = 1;

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_PULLPARAM,
                       pwszServerIp,
                       dwState,
                       dwStartUp,
                       dwStart,
                       dwRepIntvl,
                       dwRetry);

    }
    

    //Set PushParam
    {
        DWORD   dwState = 0,
                dwAddChng = 0,
                dwStartUp = 0,
                dwUpdate = 0;
        
        dwData = 0;
        dwSize = sizeof(DWORD);

        Status = NO_ERROR;
    
        Status = RegQueryValueEx(hDefaultPush,
                                 WINSCNF_UPDATE_COUNT_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
            dwUpdate = dwData;

        dwData = 0;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hPushPart,
                                 WINSCNF_INIT_TIME_RPL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
            dwStartUp = dwData;

        if( dwStartUp > 1 )
            dwStartUp = 1;

        dwSize = sizeof(DWORD);
        dwData = 0;

        Status = RegQueryValueEx(hPushPart,
                                 PERSISTENCE,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            dwState = dwData;
        }

        if( dwState > 1 )
            dwState = 1;


        dwData = 0;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hPushPart,
                                 WINSCNF_ADDCHG_TRIGGER_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
            dwAddChng = dwData;

        if( dwAddChng > 1 )
        {
            dwAddChng = 1;
        }

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_PUSHPARAM,
                       pwszServerIp,
                       dwState,
                       dwStartUp,
                       dwAddChng,
                       dwUpdate);
    }

    //Add PNG Server List
    while( TRUE )
    {
        LPBYTE  pbData = NULL;
        DWORD   dwCount = 0,
                dw = 0;

        Status = NO_ERROR;

        Status = RegQueryValueEx(hPartner,
                                 WinsOemToUnicode(WINSCNF_PERSONA_NON_GRATA_NM, NULL),
                                 NULL,
                                 &dwType,
                                 pbData,
                                 &dwSize);

        if( Status isnot NO_ERROR )
            break;

        if( dwSize < 7 )
            break;

        pbData = WinsAllocateMemory(dwSize);
    
        if( pbData is NULL )
            break;

        Status = RegQueryValueEx(hPartner,
                                 WinsOemToUnicode(WINSCNF_PERSONA_NON_GRATA_NM, NULL),
                                 NULL,
                                 &dwType,
                                 pbData,
                                 &dwSize);
        if( Status isnot NO_ERROR )
        {
            WinsFreeMemory(pbData);
            pbData = NULL;
            break;
        }

        pTemp = (LPWSTR)pbData;

        for( dw=0; dw<dwSize/sizeof(WCHAR); dw++ )
        {
            if( pTemp[dw] is L'\0' and
                pTemp[dw+1] isnot L'\0' )
            {
                pTemp[dw] = L',';
            }
        }

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_PGMODE,
                       pwszServerIp,
                       PERSMODE_NON_GRATA);

        DisplayMessage(g_hModule,
                       DMP_SRVR_ADD_PNGSERVER,
                       pwszServerIp,
                       pTemp);

        WinsFreeMemory(pbData);
        pbData = NULL;

        break;
    }

    //Add PG Server List
    while( TRUE )
    {
        LPBYTE  pbData = NULL;
        DWORD   dwCount = 0,
                dw = 0;

        Status = NO_ERROR;

        Status = RegQueryValueEx(hPartner,
                                 WinsOemToUnicode(WINSCNF_PERSONA_GRATA_NM, NULL),
                                 NULL,
                                 &dwType,
                                 pbData,
                                 &dwSize);

        if( Status isnot NO_ERROR )
            break;

        if( dwSize < 7 )
            break;

        pbData = WinsAllocateMemory(dwSize);
    
        if( pbData is NULL )
            break;

        Status = RegQueryValueEx(hPartner,
                                 WinsOemToUnicode(WINSCNF_PERSONA_GRATA_NM, NULL),
                                 NULL,
                                 &dwType,
                                 pbData,
                                 &dwSize);
        if( Status isnot NO_ERROR )
        {
            WinsFreeMemory(pbData);
            pbData = NULL;
            break;
        }

        pTemp = (LPWSTR)pbData;

        for( dw=0; dw<dwSize/sizeof(WCHAR); dw++ )
        {
            if( pTemp[dw] is L'\0' and
                pTemp[dw+1] isnot L'\0' )
            {
                pTemp[dw] = L',';
            }
        }

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_PGMODE,
                       pwszServerIp,
                       PERSMODE_GRATA);

        DisplayMessage(g_hModule,
                       DMP_SRVR_ADD_PGSERVER,
                       pwszServerIp,
                       pTemp);

        WinsFreeMemory(pbData);
        pbData = NULL;

        break;
    }

    //Set the PGMode
    {
        DWORD   dwPGMode = PERSMODE_NON_GRATA;

        Status = NO_ERROR;

        dwSize = sizeof(DWORD);
        Status = RegQueryValueEx(hPartner,
                                 WinsOemToUnicode(WINSCNF_PERSONA_MODE_NM, NULL),
                                 NULL,
                                 &dwType,
                                 (LPVOID)&dwPGMode,
                                 &dwSize);

        if (dwPGMode != PERSMODE_GRATA)
            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_PGMODE,
                           pwszServerIp,
                           dwPGMode);
    }

    //Set AutoPartner config
    {
        DWORD   dwState = 0,
                dwInterval = 0,
                dwTTL = 2;

        dwData = 0;
        dwSize = sizeof(DWORD);

        Status = NO_ERROR;

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_USE_SELF_FND_PNRS_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            dwState = dwData;
        }
        if( dwState > 1 )
            dwState = 0;

        dwData = 0;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_MCAST_TTL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
            dwTTL = dwData;

        dwData = 0;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_MCAST_INTVL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);


        if( Status is NO_ERROR )
            dwInterval = dwData;

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_AUTOPARTNERCONFIG,
                       pwszServerIp,
                       dwState,
                       dwInterval,
                       dwTTL);
        
    }

    Status = NO_ERROR;
    //Set Burst Handling parameters
    {
        DWORD    dwState = 0;
        
        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_BURST_HANDLING_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwState,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            dwSize = sizeof(DWORD);

            Status = RegQueryValueEx(hParameter,
                                     WINSCNF_BURST_QUE_SIZE_NM,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwSize);

            if( Status isnot NO_ERROR )
            {
                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_BURSTPARAM,
                               pwszServerIp,
                               dwState);
            }
            else
            {
                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_BURSTPARAM_ALL,
                               pwszServerIp,
                               dwState,
                               dwData);
            }

        }
        else
        {
            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_BURSTPARAM,
                           pwszServerIp,
                           dwState);
        }

    }

    Status = NO_ERROR;

    //Set Log Parameter
    {
        DWORD   dwLog = 0;
        
        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);
        dwData = 0;

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_LOG_FLAG_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwLog,
                                 &dwSize);

        
        dwSize = sizeof(DWORD);
        dwType = REG_DWORD;

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_LOG_DETAILED_EVTS_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_LOGPARAM,
                       pwszServerIp,
                       dwLog,
                       dwData);

    }
    
    Status = NO_ERROR;

    //Start Version count
    {
        DWORD   dwHigh = 0;
        dwData = 0;
        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_INIT_VERSNO_VAL_HW_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwHigh,
                                 &dwSize);

        if( Status isnot NO_ERROR )
            dwHigh = 0;

        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_INIT_VERSNO_VAL_LW_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);
        
        if( Status isnot NO_ERROR )
            dwData = 0;

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_STARTVERSION,
                       pwszServerIp,
                       dwHigh,
                       dwData);

    }

    Status = NO_ERROR;
    //For all partners, set PullPersistentConnections
    {
        DWORD    i, dwSubKey = 0;
        HKEY     hKey = NULL;
        WCHAR    wcIp[MAX_IP_STRING_LEN+1] = {L'\0'};
        DWORD    dwBuffer = MAX_IP_STRING_LEN+1;

        Status = NO_ERROR;

        while( TRUE )
        {
            Status = RegQueryInfoKey(hPullPart,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &dwSubKey,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);

            if( Status isnot NO_ERROR )
                break;

            if ( dwSubKey is 0 )
                break;

            for( i=0; i<dwSubKey; i++ )
            {
                DWORD   dwState = 0,
                        dwIntvl = 0,
                        dwStart = 0;
                
                dwBuffer = MAX_IP_STRING_LEN+1;

                dwSize = sizeof(DWORD);
                
                dwData = 0;

                Status = RegEnumKeyEx(hPullPart,
                                      i,
                                      wcIp,
                                      &dwBuffer,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);

                if( Status isnot NO_ERROR )
                    continue;
                
                DisplayMessage(g_hModule,
                               DMP_SRVR_ADD_PARTNER,
                               pwszServerIp,
                               wcIp,
                               0);

                Status = RegOpenKeyEx(hPullPart,
                                      wcIp,
                                      0,
                                      KEY_READ, //KEY_ALL_ACCESS,
                                      &hKey);

                if( Status isnot NO_ERROR )
                    continue;
                
                Status = RegQueryValueEx(hKey,
                                         PERSISTENCE,
                                         NULL,
                                         &dwType,
                                         (LPBYTE)&dwData,
                                         &dwSize);

                if( Status isnot NO_ERROR )
                {
                    Status = RegQueryValueEx(hPullPart,
                                             PERSISTENCE,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&dwData,
                                             &dwSize);
                }

                if( Status is NO_ERROR )
                {
                    dwState = dwData;
                    if( dwState > 1 )
                        dwState = 1;
                }

                dwData = 0;
                dwSize = sizeof(DWORD);

                Status = RegQueryValueEx(hKey,
                                         WINSCNF_RPL_INTERVAL_NM,
                                         NULL,
                                         &dwType,
                                         (LPBYTE)&dwData,
                                         &dwSize);

                if( Status isnot NO_ERROR )
                {
                    Status = RegQueryValueEx(hDefaultPull,
                                             WINSCNF_RPL_INTERVAL_NM,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&dwData,
                                             &dwSize);

                }
                
                if( Status is NO_ERROR )
                {
                    dwIntvl = dwData;
                }

                dwSize = 1024*sizeof(WCHAR);

                Status = RegQueryValueEx(hKey,
                                         WINSCNF_SP_TIME_NM,
                                         NULL,
                                         &dwType,
                                         (LPBYTE)wcData,
                                         &dwSize);

                if( Status isnot NO_ERROR )
                {
                    dwSize = 1024*sizeof(WCHAR);

                    Status = RegQueryValueEx(hDefaultPull,
                                             WINSCNF_SP_TIME_NM,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)wcData,
                                             &dwSize);
                }
                
                if( Status is NO_ERROR )
                {
                    WCHAR wcHr[3] = {L'\0'},
                          wcMt[3] = {L'\0'},
                          wcSc[3] = {L'\0'};

                    wcsncpy(wcHr, wcData, 2);

                    wcsncpy(wcMt, wcData+3, 2);
                    wcsncpy(wcSc, wcData+6, 2);
                    dwStart = wcstoul(wcHr, NULL, 10)*60*60 + 
                              wcstoul(wcMt, NULL, 10)*60 + 
                              wcstoul(wcSc, NULL, 10);
                }

                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_PULLPERSISTENTCONNECTION,
                               pwszServerIp,
                               dwState,
                               wcIp,
                               dwStart,
                               dwIntvl);

                RegCloseKey(hKey);
                hKey = NULL;
            }
            break;
        }
    }

    //Set PushPersistentConnection
    {
        DWORD    i, dwSubKey = 0;
        HKEY     hKey = NULL;
        WCHAR    wcIp[MAX_IP_STRING_LEN+1] = {L'\0'};
        DWORD    dwBuffer = MAX_IP_STRING_LEN+1;

        Status = NO_ERROR;

        while( TRUE )
        {
            Status = RegQueryInfoKey(hPushPart,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &dwSubKey,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);

            if( Status isnot NO_ERROR )
                break;

            if ( dwSubKey is 0 )
                break;

            for( i=0; i<dwSubKey; i++ )
            {
                DWORD   dwState = 0,
                        dwUpdate = 0;

                dwBuffer = MAX_IP_STRING_LEN+1;
                dwSize = sizeof(DWORD);
                dwData = 0;

                Status = RegEnumKeyEx(hPushPart,
                                      i,
                                      wcIp,
                                      &dwBuffer,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);

                if( Status isnot NO_ERROR )
                    continue;
                
                DisplayMessage(g_hModule,
                               DMP_SRVR_ADD_PARTNER,
                               pwszServerIp,
                               wcIp,
                               1);

                Status = RegOpenKeyEx(hPushPart,
                                      wcIp,
                                      0,
                                      KEY_READ, //KEY_ALL_ACCESS,
                                      &hKey);

                if( Status isnot NO_ERROR )
                    continue;
                
                Status = RegQueryValueEx(hKey,
                                         PERSISTENCE,
                                         NULL,
                                         &dwType,
                                         (LPBYTE)&dwData,
                                         &dwSize);

                if( Status isnot NO_ERROR )
                {
                    Status = RegQueryValueEx(hPushPart,
                                             PERSISTENCE,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&dwData,
                                             &dwSize);
                }

                if( Status is NO_ERROR )
                {
                    dwState = dwData;
                    if( dwState > 1 )
                        dwState = 1;
                }

                dwData = 0;
                dwSize = sizeof(DWORD);

                Status = RegQueryValueEx(hKey,
                                         WINSCNF_UPDATE_COUNT_NM,
                                         NULL,
                                         &dwType,
                                         (LPBYTE)&dwData,
                                         &dwSize);

                if( Status isnot NO_ERROR )
                {
                    Status = RegQueryValueEx(hDefaultPush,
                                             WINSCNF_UPDATE_COUNT_NM,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&dwData,
                                             &dwSize);

                }
                
                if( Status is NO_ERROR )
                {
                    dwUpdate = dwData;
                }


                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_PUSHPERSISTENTCONNECTION,
                               pwszServerIp,
                               dwState,
                               wcIp,
                               dwUpdate);

                RegCloseKey(hKey);
                hKey = NULL;
            }
            break;
        }

        if( Status is 2 )
            Status = NO_ERROR;

    }


RETURN:
    
    if( pwszData )
    {
        WinsFreeMemory(pwszData);
        pwszData = NULL;
    }

    if( hPushPart )
    {
        RegCloseKey(hPushPart);
        hPushPart = NULL;
    }

    if( hPullPart )
    {
        RegCloseKey(hPullPart);
        hPullPart = NULL;
    }

    if( hPartner )
    {
        RegCloseKey(hPartner);
        hPartner = NULL;
    }

    if( hCheck )
    {
        RegCloseKey(hCheck);
        hCheck = NULL;
    }
    
    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if (hDefaultPull)
    {
        RegCloseKey(hDefaultPull);
        hDefaultPull = NULL;
    }

    if (hDefaultPush)
    {
        RegCloseKey(hDefaultPush);
        hDefaultPull = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }
    return Status;
}


DWORD
WINAPI
WinsDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    DWORD                   Status = NO_ERROR;
    
    WCHAR                   wcServerIp[MAX_IP_STRING_LEN+1] = {L'\0'};
    CHAR                    cServerIp[MAX_IP_STRING_LEN+1] = {'\0'};
    LPWSTR                  pwcServerName = NULL;
    WCHAR                   wcNetBios[MAX_COMPUTER_NAME_LEN+1] = {L'\0'};
    struct hostent *        lpHostEnt = NULL;         
    
    handle_t                hServer = NULL;
    WINSINTF_BIND_DATA_T    BindData={0};

    LPWSTR                  pwszComputerName = NULL;
    LPSTR                   pszComputerName = NULL,
                            pTemp = NULL,
                            pTemp1 = NULL;

    DWORD                   dwComputerNameLen = 0,
                            dwTempLen = 0,
                            nLen = 0, i = 0;
    BYTE                    pbAdd[4] = {0x00};
    char                    szAdd[4] = {'\0'};
    DWORD                   Access = 0;

    wcNetBios[0] = L'\\';
    wcNetBios[1] = L'\\';

    if( !GetComputerNameEx(ComputerNameDnsFullyQualified,
                          NULL,
                          &dwComputerNameLen) )
    {
        
        pwszComputerName = WinsAllocateMemory((dwComputerNameLen+1)*sizeof(WCHAR));

        if(pwszComputerName is NULL)
        {
            return FALSE;
        }
        
        dwComputerNameLen++;
        if( !GetComputerNameEx(ComputerNameDnsFullyQualified,
                               pwszComputerName,
                               &dwComputerNameLen) )
        {
            WinsFreeMemory(pwszComputerName);
            pwszComputerName = NULL;
            return GetLastError();
        }

    }
    else
    {
        return GetLastError();
    }
 
    //Now process the Computer name and convert it to ANSI because
    //gethostbyname requires ANSI character string.

    //pszComputerName = WinsUnicodeToOem(pwszComputerName, NULL);
    pszComputerName = WinsUnicodeToAnsi(pwszComputerName, NULL);
    if( pszComputerName is NULL )
        return ERROR_NOT_ENOUGH_MEMORY;
    
    //Now get the server IP Address
    lpHostEnt = gethostbyname(pszComputerName);

    //Not a valid server name
    if( lpHostEnt is NULL )
    {
        DisplayMessage(g_hModule, EMSG_WINS_INVALID_COMPUTERNAME);
        if( pszComputerName )
        {
            WinsFreeMemory(pszComputerName);
            pszComputerName = NULL;
        }
        return WSAGetLastError();        
    }

    //Get the IP Address from the returned struct...
    memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
    nLen = 0;
    for( i=0; i<4; i++)
    {

        _itoa((int)pbAdd[i], szAdd, 10);
        memcpy(cServerIp+nLen, szAdd, strlen(szAdd));
        nLen += strlen(szAdd);
        *(cServerIp+nLen) = '.';
        nLen++;
    
    }
    *(cServerIp+nLen-1) = '\0';

    {
        LPWSTR pwstrServerIp;

        pwstrServerIp = WinsAnsiToUnicode(cServerIp, NULL);
        if (pwstrServerIp == NULL)
            return ERROR_NOT_ENOUGH_MEMORY;

        wcscpy(wcServerIp, pwstrServerIp);
        wcscpy(wcNetBios+2, wcServerIp);
        WinsFreeMemory(pwstrServerIp);
    }

    if(pTemp1)
    {
        WinsFreeMemory(pTemp1);
        pTemp1 = NULL;
    }

    pwcServerName = WinsAllocateMemory((strlen(lpHostEnt->h_name) + 1)*sizeof(WCHAR));

    if( pwcServerName is NULL ) 
    {
        if( pszComputerName )
        {
            WinsFreeMemory(pszComputerName);
            pszComputerName = NULL;
        }
        if( pwszComputerName )
        {
            WinsFreeMemory(pwszComputerName);
            pwszComputerName = NULL;
        }
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if( pszComputerName )
    {
        WinsFreeMemory(pszComputerName);
        pszComputerName = NULL;
    }
    if( pwszComputerName )
    {
        WinsFreeMemory(pwszComputerName);
        pwszComputerName = NULL;
    }
    
    wcscpy(pwcServerName, WinsOemToUnicode(lpHostEnt->h_name, NULL));

    //Bind the server
    BindData.fTcpIp = TRUE;
    BindData.pServerAdd = (LPBYTE)wcServerIp;
    BindData.pPipeName = (LPBYTE)pwcServerName;
    hServer = WinsBind(&BindData);

    if (hServer is NULL)
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_BIND_FAILED,
                       pwcServerName);
        WinsFreeMemory(pwcServerName);
        pwcServerName = NULL;
        return ERROR_INVALID_PARAMETER;

    }
   
    //find out what type of access do we have
    Access = WINS_NO_ACCESS;
    Status = WinsCheckAccess(hServer, &Access);

    if (WINSINTF_SUCCESS == Status) 
    {
        if (Access != WINS_NO_ACCESS)
        {
            DisplayMessage(g_hModule, 
                           Access == WINS_CONTROL_ACCESS ? MSG_WINS_RWACCESS : MSG_WINS_ROACCESS,
                           pwcServerName);
        }

        if( Access is WINS_NO_ACCESS )
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_NOACCESS,
                           pwcServerName);

            WinsUnbind(&BindData, hServer);
            hServer = NULL;
        }
    }
    else
    {
        DisplayErrorMessage(EMSG_WINS_GETSTATUS_FAILED,
                            Status);
        WinsFreeMemory(pwcServerName);
        pwcServerName = NULL;
        return Status;
    }

    //Now dump the configuration information for this server.

    Status = WinsDumpServer(wcServerIp,
                            wcNetBios,
                            hServer,
                            BindData);

    DisplayMessage(g_hModule,
                   WINS_FORMAT_LINE);


    WinsFreeMemory(pwcServerName);
    pwcServerName = NULL;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\common.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/

#ifndef _COMMON_H_
#define _COMMON_H_

#define is                          ==
#define isnot                       !=
#define and                         &&
#define or                          ||

#define FUTURES(x)
#define MCAST       1

#define MAX_DLL_NAME                48
#define WINS_HELPER_VERSION         1

#define MAX_IP_STRING_LEN           15
#define MAX_MSG_LENGTH  5120

#define MAX_HELPER_NAME             MAX_DLL_NAME
#define MAX_NAME_LEN                MAX_DLL_NAME
#define MAX_ENTRY_PT_NAME           MAX_DLL_NAME

#define MAX_STRING_LEN  256
#define TMSTN                       ResultsN.WinsStat.TimeStamps
#define TMST                        Results.WinsStat.TimeStamps

#define ARRAY_SIZE(x)       (sizeof(x)/sizeof((x)[0]))

#define TIME_ARGSN(x)        \
 TMSTN.x.wMonth, TMSTN.x.wDay, TMSTN.x.wYear, TMSTN.x.wHour, TMSTN.x.wMinute, TMSTN.x.wSecond

#define TIME_ARGS(x)         \
 TMST.x.wMonth, TMST.x.wDay, TMST.x.wYear, TMST.x.wHour, TMST.x.wMinute, TMST.x.wSecond    

#ifdef UNICODE
#define STRICMP(x, y)    _wcsicmp(x, y)
#else
#define STRICMP(x, y)    _stricmp(x, y)
#endif  //UNICODE

#ifdef UNICODE
#define STRTOUL(x, y, z)    wcstoul(x, y, z)
#else
#define STRTOUL(x, y, z)    strtoul(x, y, z)
#endif  //UNICODE

#ifdef UNICODE
#define STRCHR(x, y)        wcschr(x, y)
#else
#define STRCHR(x, y)        strchr(x, y)
#endif  //UNICODE

#ifdef UNICODE
#define STRCAT(x, y)        wcscat(x, y)
#else
#define STRCAT(x, y)        strcat(x, y)
#endif  //UNICODE

#ifdef UNICODE
#define STRLEN(x)        wcslen(x)
#else
#define STRCAT(x)        strlen(x)
#endif  //UNICODE

#ifdef UNICODE
#define ATOI(x)        _wtoi(x)
#else
#define ATOI(x)        atoi(x)
#endif  //UNICODE

#ifdef NT5
#define CHKNULL(Str) ((Str)?(Str):TEXT("<None>"))
#endif  //NT5

#ifdef UNICODE
#define IpAddressToString   WinsIpAddressToDottedStringW
#else
#define IpAddressToString   WinsIpAddressToDottedString
#endif //UNICODE

#ifdef UNICODE
#define StringToIpAddress   WinsDottedStringToIpAddressW
#else
#define StringToIpAddress   WinsDottedStringToIpAddress
#endif //UNICODE

#ifndef _DEBUG
#define DEBUG(s)
#define DEBUG1(s1,s2)
#define DEBUG2(s1,s2)
#else
#define DEBUG(s) wprintf(L"%s\n", L##s)
#define DEBUG1(s1,s2) wprintf(L##s1, L##s2)
#define DEBUG2(s1,s2) wprintf(L##s1, L##s2)
#endif

#define LiLtr(a, b)           ((a).QuadPart < (b).QuadPart)
#define LiAdd(a,b)            ((a).QuadPart + (b).QuadPart)

#define MAX_COMPUTER_NAME_LEN   256

//
//
//Wins registry entry definitions

#define WINSROOT    TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins")
#define CCROOT      TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Parameters\\ConsistencyCheck")
#define CC          TEXT("ConsistencyCheck")
#define PARAMETER   TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Parameters")
#define DEFAULTROOT TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Parameters\\Defaults")
#define DEFAULTPULL TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Parameters\\Defaults\\Pull")
#define DEFAULTPUSH TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Parameters\\Defaults\\Push")
#define PARTNERROOT TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Partners")
#define PULLROOT    TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Partners\\Pull")
#define PUSHROOT    TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Partners\\Push")
#define NETBIOSNAME TEXT("NetBiosName")
#define PERSISTENCE TEXT("PersistentRplOn")
#define PNGSERVER   TEXT(WINSCNF_PERSONA_NON_GRATA_NM)
#define PGSERVER    TEXT(WINSCNF_PERSONA_GRATA_NM)

//These definitions copied from rnraddrs.h 
#define TTL_SUBNET_ONLY 1         // no routing
#define TTL_REASONABLE_REACH 2    // across one router
#define TTL_MAX_REACH  6          // Default max diameter. This may
                                  // be overriden via the Registry.
//
//For determining Systems version
//
#define SERVERVERSION   TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion")
#define WINSVERSION     TEXT("CurrentVersion")
#define SPVERSION       TEXT("CSDVersion")
#define BUILDNUMBER     TEXT("CurrentBuildNumber")   

//different default settings...

#define NAMERECORD_REFRESH_DEFAULT   6*24*60*60
#define NAMERECORD_EXTMOUT_DEFAULT   6*24*60*60
#define NAMERECORD_EXINTVL_DEFAULT   6*24*60*60
#define NAMERECORD_VERIFY_DEFAULT   24*24*60*60
#define ONE_YEAR                   365*24*60*60

#define MAX_PATH_LEN 100
#define WINSTEST_FOUND            0
#define WINSTEST_NOT_FOUND        1
#define WINSTEST_NO_RESPONSE      2

#define WINSTEST_VERIFIED         0
#define WINSTEST_OUT_OF_MEMORY    3
#define WINSTEST_BAD_IP_ADDRESS   4
#define WINSTEST_HOST_NOT_FOUND   5
#define WINSTEST_NOT_VERIFIED     6

#define WINSTEST_INVALID_ARG      7
#define WINSTEST_OPEN_FAILED      8

#define  _NBT_CFG_ADAPTERS_KEY              TEXT("System\\CurrentControlSet\\Services\\NetBT\\Adapters")

#define  RPL_E_PULL 0
#define  RPL_E_PUSH 1

#define RE_QUERY_REGISTRY_COUNT 10



ULONG   LocalIpAddress;
CHAR    pScope[128];


#define MAX_WINS    1000

//
// <Server> - <Owner> Table - [SO] Table
//
extern LARGE_INTEGER  **  SO_Table;

//
// Lookaside table to map IP addrs to the index into the SO_Table
//

extern WCHAR   ** LA_Table;
extern ULONG   LA_TableSize;

VOID
DumpSOTable(
    IN DWORD    MasterOwners,
    IN BOOL     fFile,
    IN FILE *   pFile
    );

VOID
DumpLATable(
    IN DWORD    MasterOwners,
    IN BOOL     fFile,
    IN FILE  *  pFile
    ); 

typedef struct _WINSMON_SUBCONTEXT_TABLE_ENTRY
{
    //
    // Name of the context
    //

    LPWSTR                  pwszContext;
    //
    //Short command help
    DWORD                   dwShortCmdHlpToken;
    
    //Detail command help
    DWORD                   dwCmdHlpToken;

    PNS_CONTEXT_ENTRY_FN    pfnEntryFn;    

}WINSMON_SUBCONTEXT_TABLE_ENTRY,*PWINSMON_SUBCONTEXT_TABLE_ENTRY;

PVOID WinsAllocateMemory(DWORD dwSize);
VOID WinsFreeMemory(PVOID Memory);

extern HANDLE   g_hModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;
extern BOOL     g_fServer;
extern DWORD    g_dwNumTableEntries;
extern PWCHAR   g_pwszServer;

extern ULONG    g_ulInitCount;
extern ULONG    g_ulNumTopCmds;
extern ULONG    g_ulNumGroups;

extern DWORD    g_dwMajorVersion;
extern DWORD    g_dwMinorVersion;
 
extern LPWSTR g_ServerNameUnicode;
extern LPSTR  g_ServerNameAnsi;
extern CHAR   g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR  g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern HKEY   g_hServerRegKey;
extern WCHAR  g_ServerNetBiosName[MAX_COMPUTER_NAME_LEN];

extern handle_t                    g_hBind;
extern WINSINTF_BIND_DATA_T        g_BindData;

extern WCHAR   wszUnknown[50];
extern WCHAR   wszEnable[50];
extern WCHAR   wszDisable[50];
extern WCHAR   wszRandom[150];
extern WCHAR   wszOwner[150];
extern WCHAR   wszInfinite[100];
extern WCHAR   wszPush[50];
extern WCHAR   wszPull[50];
extern WCHAR   wszPushpull[50];
extern WCHAR   wszHigh[50];
extern WCHAR   wszNormal[50];
extern WCHAR   wszDeleted[150];
extern WCHAR   wszOK[50];
extern WCHAR   wszFailure[50];
extern WCHAR   wszNameVerify[100];
//
// The format of Adapter Status responses
//
typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
} tADAPTERSTATUS;

extern WCHAR *messages[];



#define MAX_NB_NAMES            1000
#define MAX_SERVERS             1000
#define BUFF_SIZE               650
#define MAX_SIZE                1024
#define INFINITE_EXPIRATION     0x7FFFFFFF


#define MAX(a, b) ( ( (a) > (b) ) ? (a) : (b) )
#define MIN(a, b) ( ( (a) > (b) ) ? (b) : (a) )

extern SOCKET  sd;
extern WSADATA WsaData;

struct sockaddr_in myad;
struct sockaddr_in recvad;
int addrlen;
u_short TranID;
extern u_long NonBlocking;


extern int     NumWinServers;
extern int     NumNBNames;
extern u_char  **NBNames;
u_long  VerifiedAddress[MAX_NB_NAMES];

typedef struct
{
    BOOLEAN         fQueried;
    struct in_addr  Server;
    struct in_addr  RetAddr;
    int             Valid;
    int             Failed;
    int             Retries;
    int             LastResponse;
    int             Completed;
} WINSERVERS;

extern WINSERVERS * WinServers;

#define NBT_NONCODED_NMSZ   17
#define NBT_NAMESIZE        34

ULONG   NetbtIpAddress;

typedef struct _NameResponse
{
    u_short TransactionID;
    u_short Flags;
    u_short QuestionCount;
    u_short AnswerCount;
    u_short NSCount;
    u_short AdditionalRec;
    u_char  AnswerName[NBT_NAMESIZE];
    u_short AnswerType;
    u_short AnswerClass;
    u_short AnswerTTL1;
    u_short AnswerTTL2;
    u_short AnswerLength;
    u_short AnswerFlags;
    u_short AnswerAddr1;
    u_short AnswerAddr2;
} NameResponse;

#define NAME_RESPONSE_BUFFER_SIZE sizeof(NameResponse) * 10

DWORD
FormatDateTimeString( IN  time_t  time,
                      IN  BOOL    fShort,
                      OUT LPWSTR  pwszBuffer,
                      IN  DWORD  *pdwBuffLen);

INT
CheckNameConsistency();



DWORD
DisplayErrorMessage(
    IN DWORD   dwMsgID,
    IN DWORD   dwErrID,
    ...
);


BOOL
IsIpAddress(
    IN LPCWSTR  pwszAddress
);

UCHAR  StringToHexA(IN LPCWSTR pwcString);

BOOL
IsPureNumeric(
    IN LPCWSTR pwszStr
);

BOOL
IsValidServer(
    IN LPCWSTR    pwszServer
);

BOOL
IsLocalServer( VOID );

DWORD
CreateDumpFile(
    IN  LPCWSTR pwszName,
    OUT PHANDLE phFile
);


VOID
CheckVersionNumbers(
                    IN  LPCSTR  pStartIp,
                    IN  BOOL    fFile,
                    OUT FILE *  pFile
                   );

DWORD 
ControlWINSService(IN BOOL bStop);

VOID
CloseDumpFile(
    IN HANDLE  hFile
);


LPWSTR
WinsOemToUnicodeN(
    IN      LPCSTR  Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    );

LPWSTR
WinsOemToUnicode(
    IN      LPCSTR Ansi,
    IN OUT  LPWSTR Unicode
    );

LPSTR
WinsUnicodeToOem(
    IN      LPCWSTR Unicode,
    IN OUT  LPSTR   Ansi
    );

LPWSTR
WinsAnsiToUnicode(
    IN      LPCSTR Ansi,
    IN OUT  LPWSTR Unicode
    );

LPSTR
WinsUnicodeToAnsi(
    IN      LPCWSTR Unicode,
    IN OUT  LPSTR   Ansi
    );

LPSTR
WinsAnsiToOem(
    IN      LPCSTR   Ansi
    );
VOID

WinsHexToString(
    OUT LPWSTR Buffer,
    IN  const BYTE * HexNumber,
    IN  DWORD Length
    );

VOID
WinsHexToAscii(
    OUT LPSTR Buffer,
    IN  const BYTE * HexNumber,
    IN  DWORD Length
    );

VOID
WinsDecimalToString(
    OUT LPWSTR Buffer,
    IN  BYTE Number
    );

DWORD
WinsDottedStringToIpAddress(
    IN LPCSTR String
    );

LPSTR
WinsIpAddressToDottedString(
    IN DWORD IpAddress
    );

DWORD
WinsStringToHwAddress(
    IN LPCSTR AddressBuffer,
    IN LPCSTR AddressString
    );

LPWSTR
MakeTimeString(
               IN DWORD dwTime
);

LPWSTR
MakeDayTimeString(
                  IN DWORD dwTime
);


DWORD
WinsDottedStringToIpAddressW(
    IN LPCWSTR pwszString
);

LPWSTR
WinsIpAddressToDottedStringW(
    IN DWORD   IpAddress
);

DWORD
GetVersionData(
               IN LPWSTR               pwszVers,
               IN WINSINTF_VERS_NO_T   *Version
);


DWORD
ImportStaticMappingsFile(IN LPWSTR strFile,
                         IN BOOL fDelete
);

DWORD
PreProcessCommand(
      IN OUT      LPWSTR           *ppwcArguments,
      IN          DWORD             dwArgCount,
      IN          DWORD             dwCurrentIndex,
      IN OUT      PTAG_TYPE         pTagTable,
      IN OUT      PDWORD            pdwTagCount,
      OUT         PDWORD            pdwTagType,
      OUT         PDWORD            pdwTagNum
);

DWORD
GetStatus(
        IN BOOL            fPrint,
        LPVOID          pResultsA,
        BOOL            fNew,
        BOOL            fShort,
        LPCSTR           pStartIp
);


DWORD
GetDbRecs(
   WINSINTF_VERS_NO_T LowVersNo,
   WINSINTF_VERS_NO_T HighVersNo,
   PWINSINTF_ADD_T    pWinsAdd,
   LPBYTE             pTgtAdd,
   BOOL               fSetFilter,
   LPBYTE             pFilterName,
   DWORD              Len,
   BOOL               fAddFilter,
   DWORD              AddFilter,
   BOOL               fCountRec,
   BOOL               fCase,
   BOOL               fFile,
   LPWSTR             pwszFile
);

DWORD
WinsDumpServer(IN LPCWSTR               pwszServerIp,
               IN LPCWSTR               pwszNetBiosName,
               IN handle_t             hBind,
               IN WINSINTF_BIND_DATA_T BindData
              );

NS_CONTEXT_DUMP_FN WinsDump;

VOID
ChkAdd(
        PWINSINTF_RECORD_ACTION_T pRow,
        DWORD                     Add,
        BOOL                      fFile,
        FILE  *                   pFile,
        DWORD                     OwnerIP,
        LPBOOL                    pfMatch
);

VOID
DumpMessage(
            HANDLE      hModule,
            FILE *      pFile,            
            DWORD       dwMsgId,
            ...
           );


#if DBG



VOID
WinsPrintRoutine(
    IN DWORD DebugFlag,
    IN LPCSTR Format,
    ...
);

VOID
WinsAssertFailed(
    IN LPCSTR FailedAssertion,
    IN LPCSTR FileName,
    IN DWORD LineNumber,
    IN LPCSTR Message
    );

#define WinsPrint(_x_)   WinsPrintRoutine _x_


#define WinsAssert(Predicate) \
    { \
        if (!(Predicate)) \
            WinsAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#define WinsVerify(Predicate) \
    { \
        if (!(Predicate)) \
            WinsAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#else

#define WinsAssert(_x_)
#define WinsDumpMessage(_x_, _y_)
#define WinsVerify(_x_) (_x_)

#endif // not DBG
#endif	//_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\precomp.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <signal.h>
#include <memory.h>
#include <malloc.h>

#include <fcntl.h>
#include <stropts.h>

#include <tdi.h>
#include <uio.h>

#include <winsock.h>
#include <wsahelp.h>

#include <nb30.h>
#include <nbtioctl.h>
#include <time.h>
#include <tchar.h>
#include <wchar.h>
#include <sys\types.h>
#include <sys\stat.h>

#include <netsh.h>
#include <netshp.h>

#include "winsintf.h"

#define PRSCONN 1

#include "common.h"
#include "winscnst.h"
#include "winsmon.h"
#include "winshndl.h"

#include "srvrmon.h"
#include "srvrhndl.h"

#include "strdefs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\srvrhndl.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/
#ifndef _WINSSRVR_H_
#define _WINSSRVR_H_

FN_HANDLE_CMD  HandleSrvrHelp;
FN_HANDLE_CMD  HandleSrvrContexts;
FN_HANDLE_CMD  HandleSrvrDump;

FN_HANDLE_CMD  HandleSrvrAddName;
FN_HANDLE_CMD  HandleSrvrAddPartner;
FN_HANDLE_CMD  HandleSrvrAddPersona;

FN_HANDLE_CMD  HandleSrvrCheckDatabase;
FN_HANDLE_CMD  HandleSrvrCheckVersion;
FN_HANDLE_CMD  HandleSrvrCheckName;

FN_HANDLE_CMD  HandleSrvrDeleteName;
FN_HANDLE_CMD  HandleSrvrDeleteRecords;
FN_HANDLE_CMD  HandleSrvrDeleteWins;
FN_HANDLE_CMD  HandleSrvrDeletePartner;
FN_HANDLE_CMD  HandleSrvrDeletePersona;

FN_HANDLE_CMD  HandleSrvrInitBackup;
//FN_HANDLE_CMD  HandleSrvrInitCompact;
//FN_HANDLE_CMD  HandleSrvrInitExport;
FN_HANDLE_CMD  HandleSrvrInitImport;
FN_HANDLE_CMD  HandleSrvrInitPush;
FN_HANDLE_CMD  HandleSrvrInitPullrange;
FN_HANDLE_CMD  HandleSrvrInitPull;
FN_HANDLE_CMD  HandleSrvrInitReplicate;
FN_HANDLE_CMD  HandleSrvrInitRestore;
FN_HANDLE_CMD  HandleSrvrInitScavenge;
FN_HANDLE_CMD  HandleSrvrInitSearch;

FN_HANDLE_CMD  HandleSrvrResetCounter;


FN_HANDLE_CMD  HandleSrvrSetAutopartnerconfig;
FN_HANDLE_CMD  HandleSrvrSetBackuppath;
FN_HANDLE_CMD  HandleSrvrSetBurstparam;
FN_HANDLE_CMD  HandleSrvrSetDefaultparam;
FN_HANDLE_CMD  HandleSrvrSetLogparam;
FN_HANDLE_CMD  HandleSrvrSetMigrateflag;
FN_HANDLE_CMD  HandleSrvrSetNamerecord;
FN_HANDLE_CMD  HandleSrvrSetPeriodicdbchecking;
FN_HANDLE_CMD  HandleSrvrSetPullpersistentconnection;
FN_HANDLE_CMD  HandleSrvrSetPushpersistentconnection;
FN_HANDLE_CMD  HandleSrvrSetPullparam;
FN_HANDLE_CMD  HandleSrvrSetPushparam;
FN_HANDLE_CMD  HandleSrvrSetReplicateflag;
FN_HANDLE_CMD  HandleSrvrSetStartversion;
FN_HANDLE_CMD  HandleSrvrSetPersMode;


FN_HANDLE_CMD  HandleSrvrShowDatabase;
FN_HANDLE_CMD  HandleSrvrShowInfo;
FN_HANDLE_CMD  HandleSrvrShowPartner;
FN_HANDLE_CMD  HandleSrvrShowName;
FN_HANDLE_CMD  HandleSrvrShowServer;
FN_HANDLE_CMD  HandleSrvrShowStatistics;
FN_HANDLE_CMD  HandleSrvrShowVersion;
FN_HANDLE_CMD  HandleSrvrShowVersionmap;
FN_HANDLE_CMD  HandleSrvrShowPartnerproperties;
FN_HANDLE_CMD  HandleSrvrShowPullpartnerproperties;
FN_HANDLE_CMD  HandleSrvrShowPushpartnerproperties;
FN_HANDLE_CMD  HandleSrvrShowDomain;
FN_HANDLE_CMD  HandleSrvrShowReccount;
FN_HANDLE_CMD  HandleSrvrShowRecbyversion;

#endif //_WINSSRVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\srvrhndl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\wins\srvrhndl.c

Abstract:

    WINS Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 12/10/98

--*/

#include "precomp.h"


extern ULONG g_ulSrvrNumTopCmds;
extern ULONG g_ulSrvrNumGroups;

extern CMD_GROUP_ENTRY                  g_SrvrCmdGroups[];
extern CMD_ENTRY                        g_SrvrCmds[];

DWORD  g_dwSearchCount = 0;
BOOL   g_fHeader = FALSE;

WCHAR          **LA_Table = NULL;
LARGE_INTEGER  **SO_Table = NULL;
u_char         **NBNames = NULL;
WINSERVERS      * WinServers = NULL;


LPWSTR
GetDateTimeString(DWORD_PTR TimeStamp,
                  BOOL      fShort,
                  int      *piType);

DWORD
HandleSrvrDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description :
        Dumps the current configuration of the Wins Server.

Arguments :
        Does not take any arguments.

Return Value:
        Returns the status of the operation.

--*/

{
    DWORD   Status = NO_ERROR;

    if( dwArgCount > dwCurrentIndex )
    {
        if( IsHelpToken(ppwcArguments[dwCurrentIndex]) is TRUE )
        {
            DisplayMessage(g_hModule,
                           HLP_WINS_DUMP_EX);
        }
    }

    Status = WinsDumpServer(g_ServerIpAddressUnicodeString,
                            g_ServerNetBiosName,
                            g_hBind,
                            g_BindData);
    if( Status is NO_ERROR )
	{
        DisplayMessage(g_hModule,
                       EMSG_WINS_ERROR_SUCCESS);
	}
    else if( Status is ERROR_FILE_NOT_FOUND )
	{
		DisplayMessage(g_hModule,
					   EMSG_WINS_NOT_CONFIGURED);
	}
	else
	{
        DisplayErrorMessage(EMSG_SRVR_DUMP,
                            Status);
	}
    return Status;

}


DWORD
HandleSrvrHelp(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the help for Wins Server context.

Arguments :
        Does not take any arguments.

Return Value:
        Returns the status of the operation. NO_ERROR always. 

--*/

{
    DWORD    i, j;

    for(i = 0; i < g_ulSrvrNumTopCmds -2; i++)
    {
        if ((g_SrvrCmds[i].dwCmdHlpToken == WINS_MSG_NULL)
         || !g_SrvrCmds[i].pwszCmdToken[0] )
        {
            continue;
        }

        DisplayMessage(g_hModule, 
                       g_SrvrCmds[i].dwShortCmdHelpToken);

    }

    for(i = 0; i < g_ulSrvrNumGroups; i++)
    {
        if ((g_SrvrCmdGroups[i].dwShortCmdHelpToken == WINS_MSG_NULL)
         || !g_SrvrCmdGroups[i].pwszCmdGroupToken[0] )
        {
            continue;
        }

        DisplayMessage(g_hModule, g_SrvrCmdGroups[i].dwShortCmdHelpToken);
    }
      
    DisplayMessage(g_hModule, WINS_FORMAT_LINE);

    return NO_ERROR;
}


DWORD
HandleSrvrAddName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Adds and registers a name record to the WINS server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory, Record Name and Ip Address
        Optional,   Endchar, Scope, RecordType, NodeType, GroupType
        Note : GroupType is ignored if EndChar is specified.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount = 0;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_NAME, TRUE, FALSE},
                                {WINS_TOKEN_ENDCHAR, FALSE, FALSE},
                                {WINS_TOKEN_SCOPE, FALSE, FALSE},
                                {WINS_TOKEN_RECORDTYPE, FALSE, FALSE},
                                {WINS_TOKEN_GROUP, FALSE, FALSE},
                                {WINS_TOKEN_NODE, FALSE, FALSE},
                                {WINS_TOKEN_IP, TRUE, FALSE},
                            };
    PDWORD      pdwTagNum = NULL,
                pdwTagType = NULL;

    WCHAR       wszName[MAX_STRING_LEN+1] = {L'\0'};
    BOOL        fEndChar = FALSE;
    BOOL        fDomain = FALSE;
    CHAR        ch16thChar = 0x00;

    BOOL        fScope = FALSE;
    WCHAR       wszScope[MAX_STRING_LEN] = {L'\0'};
    BOOL        fStatic = TRUE;
    DWORD       dwRecType = WINSINTF_E_UNIQUE;
    
    BYTE        rgbNodeType = WINSINTF_E_PNODE;
    PDWORD      pdwIpAddress = NULL;
    DWORD       dwIpCount = 0;
    DWORD       dwStrLen = 0;
    LPWSTR      pwszTemp = NULL;
    WINSINTF_RECORD_ACTION_T    RecAction = {0};
    PWINSINTF_RECORD_ACTION_T   pRecAction = NULL;
    LPSTR       pszTempName = NULL;

    memset(&RecAction, 0x00, sizeof(WINSINTF_RECORD_ACTION_T));
    RecAction.fStatic = fStatic;

    //We need at least Name and Ip for the record.
    if( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_ADD_NAME_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //Start processing the arguments passed by ppwcArguments and dwArgCount

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;
    
    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    i = dwTagCount;
    for( j=0; j<i; j++ )
    {
        switch(pdwTagType[j])
        {
        //Name of the record ( Compulsory )
        case 0:
            {
               DWORD dwLen = 0;
                
               dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dwLen = ( 255 < dwLen ) ? 255 : dwLen;
                memcpy(wszName, 
                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 
                       dwLen*sizeof(WCHAR));
                wszName[dwLen] = L'\0';               
                break;
            }
        //End Char or 16th Character( Optional )
        case 1:
            {
                DWORD dwLen = 0, k=0;
                fEndChar = TRUE;
                dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen > 2 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                        
                }
                
                for( k=0; k<dwLen; k++ )
                {
                    WCHAR  wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][k];
                    
                    if( towlower(wc) >= L'a' and
                        towlower(wc) <= L'z' )
                    {
                        if( towlower(wc) > L'f' )
                        {
                            Status = ERROR_INVALID_PARAMETER;
                            goto ErrorReturn;
                        }
                    }
                }

                ch16thChar = StringToHexA(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);

                break;
            }
        //Scope ( Optional )
        case 2:
            {
                DWORD dwLen;
                
                dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                fScope = TRUE;
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dwLen = ( 255 < dwLen ) ? 255 : dwLen;
                memcpy(wszScope,
                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 
                       dwLen*sizeof(WCHAR));
                wszScope[dwLen] = L'\0';   
                break;
            }
        //Record Type ie Static or Dynamic ( Optional )
        case 3:
            {
              
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                else
                {
                    WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                    if( wc is L'1' )
                        fStatic = FALSE;
                    else if( wc is L'0' )
                        fStatic = TRUE;
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                }
                break;
            }
        // Group Type ( Optional )
        case 4:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                switch(dw)
                {
                case 0:
                    {
                        dwRecType = WINSINTF_E_UNIQUE;
                        break;
                    }
                case 1:
                    {
                        dwRecType = WINSINTF_E_NORM_GROUP;
                        break;
                    }
                case 2:
                    {
                        dwRecType = WINSINTF_E_SPEC_GROUP;
                        break;
                    }
                case 3:
                    {
                        dwRecType = WINSINTF_E_MULTIHOMED;
                        break;
                    }
                case 4:
                    {
                        fDomain = TRUE;
                        dwRecType = WINSINTF_E_SPEC_GROUP;
                        break;
                    }
                default:
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                }
                break;
            }
        //Node Type( Optional )
        case 5:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);

                switch(dw)
                {
                case 0:
                    {
                        rgbNodeType = WINSINTF_E_BNODE;
                        break;
                    }
                case 1:
                    {
                        rgbNodeType = WINSINTF_E_PNODE;
                        break;
                    }
                case 3:
                    {
                        rgbNodeType = WINSINTF_E_HNODE;
                        break;
                    }
                default:
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                }
                break;
            }
        //IP Address corresponding to the record( Compulsory )
        case 6:
            {
                LPWSTR  pszIps = NULL;
                DWORD   dwIpLen = 0;
                LPWSTR  pTemp = NULL;
                
                dwIpCount = 0;

               
                dwIpLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwIpLen is 0 )
                {
                    break;
                }
                pszIps = WinsAllocateMemory((dwIpLen+1)*sizeof(WCHAR));
                if( pszIps is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }

                wcscpy(pszIps, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( pszIps[0] isnot L'{' or 
                    pszIps[dwIpLen-1] isnot L'}')
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                
                pTemp = pszIps+1;                               
                pszIps[dwIpLen-1] = L'\0';

                pTemp = wcstok(pTemp, L",");
                
                while(( pTemp isnot NULL ) && (dwIpCount < WINSINTF_MAX_MEM ) )
                {
                    PDWORD  pdwTemp = NULL;
                    if( IsIpAddress(pTemp) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }

                    dwIpCount++;

                    pdwTemp = WinsAllocateMemory(dwIpCount*sizeof(DWORD));
                    if( pdwTemp is NULL )
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }
                    if( pdwIpAddress )
                    {
                        memcpy(pdwTemp, pdwIpAddress, (dwIpCount-1)*sizeof(DWORD));
                        WinsFreeMemory(pdwIpAddress);
                        pdwIpAddress = NULL;
                    }
                    
                    pdwTemp[dwIpCount-1] = StringToIpAddress(pTemp);
                    pdwIpAddress = pdwTemp;
                    pTemp = wcstok(NULL, L",");
                }
                WinsFreeMemory(pszIps);
                pszIps = NULL;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
    
    //Process Name, Scope and Endchar if specified.

    _wcsupr(wszName);
    _wcsupr(wszScope);

    RecAction.pName = WinsAllocateMemory(273);
    if( RecAction.pName is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }
    
    pszTempName = WinsUnicodeToOem(wszName, NULL);

    if( pszTempName is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwStrLen = strlen(pszTempName);

    if( dwStrLen >= 16 )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_NETBIOS_NAME);
        Status = ERROR_INVALID_PARAMETER;
        WinsFreeMemory(pszTempName);
        pszTempName = NULL;
        goto ErrorReturn;
    }

    strncpy(RecAction.pName, pszTempName, ( 16 > dwStrLen ) ? dwStrLen : 16);

    WinsFreeMemory(pszTempName);
    pszTempName = NULL;


    if( fDomain is TRUE &&
        fEndChar is FALSE )
    {
        ch16thChar = StringToHexA(L"1C");
        fEndChar = TRUE;
    }

 
    for( j=dwStrLen; j<16; j++ )
    {
        RecAction.pName[j] = ' ';
    }
    if( fEndChar is TRUE )
    {
        RecAction.pName[15] = (CHAR)ch16thChar;
    }
    RecAction.pName[16] = '\0';

    dwStrLen = 16;

    if( fScope )
    {
        DWORD dwLen;
    
        RecAction.pName[dwStrLen] = '.';

        pszTempName = WinsUnicodeToOem(wszScope, NULL);
        if( pszTempName is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        dwLen = strlen(pszTempName);
        dwLen = ( 255 - dwStrLen < dwLen ) ? 255 - dwStrLen : dwLen;

        strncpy(RecAction.pName+dwStrLen+1, pszTempName, dwLen); 
        
        WinsFreeMemory(pszTempName);
        pszTempName = NULL;

        RecAction.pName[dwStrLen+dwLen+1] = '\0';
    
        dwStrLen = strlen(RecAction.pName);

        if( fEndChar and 
            ch16thChar is 0x00 )
            dwStrLen++;      
    }


    RecAction.NameLen = dwStrLen;
    RecAction.Cmd_e      = WINSINTF_E_INSERT;
    RecAction.fStatic = fStatic;
    

    if( pdwIpAddress is NULL )
    {
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
  
    if( dwRecType isnot WINSINTF_E_NORM_GROUP and
        dwRecType isnot WINSINTF_E_SPEC_GROUP)
    {
        RecAction.NodeTyp = rgbNodeType;
    }


    //Treat each of the rectype when no endchar is specified specially.
    //This part of the code needs to be cleaned up after Beta3
    if( fEndChar is FALSE )
    {
        if( dwRecType is WINSINTF_E_SPEC_GROUP or
            dwRecType is WINSINTF_E_MULTIHOMED )
        {
            RecAction.pAdd = WinsAllocateMemory(dwIpCount*sizeof(WINSINTF_ADD_T));
            if( RecAction.pAdd is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            for( j=0; j<dwIpCount; j++ )
            {
                (RecAction.pAdd+j)->IPAdd = pdwIpAddress[j];
                (RecAction.pAdd+j)->Type = 0;
                (RecAction.pAdd+j)->Len = 4;
            }
            RecAction.NoOfAdds = dwIpCount;
        }
        else
        {
            RecAction.Add.IPAdd = pdwIpAddress[0];
            RecAction.Add.Type = 0;
            RecAction.Add.Len = 4;
        }

        switch(dwRecType)
        {
        case WINSINTF_E_UNIQUE:
            {
                CHAR Type[]={0x03, 0x20, 0x00};

                for( i=0; i<3; i++ )
                {
                    *(RecAction.pName + 15) = Type[i];
                    if( Type[i] is 0x00 )
                    {
                        RecAction.pName[16] = '\0';
                        RecAction.NameLen = 16;
                    }
                    RecAction.TypOfRec_e = dwRecType;
                    pRecAction = &RecAction;
        
                    Status = WinsRecordAction(g_hBind, &pRecAction);
                    if( Status isnot NO_ERROR )
                        goto ErrorReturn;
                }
                break;
            }
        case WINSINTF_E_NORM_GROUP:
            {             
                RecAction.pName[15] = (CHAR)0x1E;
                pRecAction = &RecAction;
                RecAction.TypOfRec_e = dwRecType;
                Status = WinsRecordAction(g_hBind, &pRecAction);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;

                break;
            }

        case WINSINTF_E_SPEC_GROUP:
            {           
                RecAction.pName[15] = (CHAR)0x20;
                pRecAction = &RecAction;
                RecAction.TypOfRec_e = dwRecType;
                Status = WinsRecordAction(g_hBind, &pRecAction);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }

        case WINSINTF_E_MULTIHOMED:
            {
                CHAR Type[]={0x03, 0x20, 0x00};
                for( i=0; i<3; i++ )
                {
                    *(RecAction.pName + 15) = Type[i];
                    if( Type[i] is 0x00 )
                    {
                        *(RecAction.pName+16) = '\0';
                        RecAction.NameLen = 16;
                    }

                    RecAction.TypOfRec_e = dwRecType;
                    pRecAction = &RecAction;
                    RecAction.NodeTyp = WINSINTF_E_PNODE;
                    Status = WinsRecordAction(g_hBind, &pRecAction);
                    if( Status isnot NO_ERROR )
                        goto ErrorReturn;
                }
                break;
            }
        }
    }

    //Otherwise when Endchar is specified
    else
    {        
        //if endchar is 0x00, ignore the scope if spcefied
        if( RecAction.pName[15] is 0x00 )
        {
            RecAction.NameLen = 16;
        }

        // by default, initialize the rec type to whatever the user specified
        RecAction.TypOfRec_e = dwRecType;

        //If endchar is 0x1C
        if( RecAction.pName[15] is 0x1C )
        {
            RecAction.TypOfRec_e = WINSINTF_E_SPEC_GROUP;
            RecAction.NodeTyp = 0;
        }
        //else if EndChar is 0x1E or 0x1D
        else if( RecAction.pName[15] is 0x1E or
                 RecAction.pName[15] is 0x1D)
        {
            RecAction.TypOfRec_e = WINSINTF_E_NORM_GROUP;
            RecAction.NodeTyp = 0;
        }        

        if( RecAction.TypOfRec_e is WINSINTF_E_SPEC_GROUP )
            
        {
            RecAction.pAdd = WinsAllocateMemory(dwIpCount*sizeof(WINSINTF_ADD_T));
            if( RecAction.pAdd is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            for( j=0; j<dwIpCount; j++ )
            {
                (RecAction.pAdd+j)->IPAdd = pdwIpAddress[j];
                (RecAction.pAdd+j)->Type = 0;
                (RecAction.pAdd+j)->Len = 4;
            }
            RecAction.NoOfAdds = dwIpCount;
        }
        else
        {
            RecAction.Add.IPAdd = pdwIpAddress[0];
            RecAction.Add.Type = 0;
            RecAction.Add.Len = 4;
        }
    
        pRecAction = &RecAction;

        Status = WinsRecordAction(g_hBind, &pRecAction );

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    }

CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pszTempName )
    {
        WinsFreeMemory(pszTempName);
        pszTempName = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( RecAction.pName )
    {
        WinsFreeMemory(RecAction.pName);
        RecAction.pName = NULL;
    }
    
    if( RecAction.pAdd )
    {
        WinsFreeMemory(RecAction.pAdd);
        RecAction.pAdd = NULL;
    }

    if( pdwIpAddress )
    {
        WinsFreeMemory(pdwIpAddress);
        pdwIpAddress = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_ADD_NAME, Status);
    goto CommonReturn;

}


DWORD
HandleSrvrAddPartner(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Adds a partner ( either Push or Pull or Both ) to the WINS server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory, ServerIpAddress
        Optional,   ServerNetBios name and PartnerType.
        Note : Server NetBios name is required when Ip address can not be resolved
               to a name. 
               PartherType by default is both. Otherwise whatever specified.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                                {WINS_TOKEN_NETBIOS, FALSE, FALSE},
                                {WINS_TOKEN_TYPE, FALSE, FALSE},
                            };
    LPWSTR      pwszServerName = NULL;
    WCHAR       wcServerIpAdd[MAX_IP_STRING_LEN+1] = {L'\0'};
    PDWORD      pdwTagType=NULL, pdwTagNum=NULL;
    BOOL        fPush = TRUE,
                fPull = TRUE;
 
    HKEY        hServer = NULL,
                hPartner = NULL,
                hDefault = NULL,
                hKey = NULL;

    LPWSTR      pTemp = NULL;
    DWORD       dwKeyLen = 0;
    DWORD       dwData = 0, 
                dwDataLen = 0,
                dwType = 0;

    BOOL        fIsNetBios = TRUE;

    //Need at least the server Ip Address
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_ADD_PARTNER_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    //Start processing the arguments based on ppwcArguments and dwArgCount and dwCurrnetIndex
    dwNumArgs = dwArgCount - dwCurrentIndex;
    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++)
    {
        switch(pdwTagType[j])
        {
        //Server IP Address. Try to resolve the IP to a name
        case 0:
            {
                struct  hostent * lpHostEnt = NULL;
                CHAR    cAddr[16];
                BYTE    pbAdd[4];
                char    szAdd[4];
                int     k = 0, l=0;
                DWORD   dwLen,nLen = 0;
                CHAR    *pTemp = NULL;
                CHAR    *pNetBios = NULL;
                
                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) is FALSE )
                {
                    Status = ERROR_INVALID_IPADDRESS;
                    goto ErrorReturn;
                }

                //if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) )
                else
                {
                    DWORD dwIp = inet_addr(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL));
                    lpHostEnt = gethostbyaddr((char *)&dwIp, 4, AF_INET);
                    if(lpHostEnt isnot NULL )//Valid IP Address
                    {
                        wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    }
                    else
                    {
                        wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                        fIsNetBios = FALSE;                                       
                        break;
                    }
                }

                dwLen = strlen(lpHostEnt->h_name);
                pTemp = WinsAllocateMemory(dwLen+1);
                if( pTemp is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }

                strcpy(pTemp, lpHostEnt->h_name);
                pNetBios = strchr(pTemp, '.');

                if( pNetBios isnot NULL )
                {
                    dwLen = (DWORD)(pNetBios - pTemp);
                    pTemp[dwLen] = '\0';
                }
                

                pwszServerName = WinsAllocateMemory((dwLen+1)*sizeof(WCHAR));
                if( pwszServerName is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
 
                wcscpy(pwszServerName, WinsAnsiToUnicode(pTemp, NULL));

                if( pTemp )
                {
                    WinsFreeMemory(pTemp);
                    pTemp = NULL;
                }
                break;
            }
        //Server NetBios Name. Required only when Ip can not be resolved to a name.
        //Otherwise ignored.
        case 1:
            {
                if( fIsNetBios is FALSE )
                {
                    pwszServerName = WinsAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]])+1)*sizeof(WCHAR));
                    if( pwszServerName is NULL )
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }

                    wcscpy(pwszServerName, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    fIsNetBios = TRUE;
                    
                }
                break;
            }
        //Partner Type. Default is BOTH
        case 2:
            {
                DWORD dwType = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dwType = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                switch(dwType)
                {
                case 0:
                    {
                        fPull = TRUE;
                        fPush = FALSE;
                        break;
                    }
                case 1:
                    {
                        fPull = FALSE;
                        fPush = TRUE;
                        break;
                    }
                case 2:
                default:
                    {
                        fPull = TRUE;
                        fPush = TRUE;
                        break;
                    }
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }

        }
    }

    if( fIsNetBios is FALSE )
    {
        Status = ERROR_INVALID_IPADDRESS;
        goto ErrorReturn;
    }
    //Add the partner information to the registry and set the appropriate parameter
    {
        
        if( wcslen(g_ServerNetBiosName) > 0 )
        {
            pTemp = g_ServerNetBiosName;
        }
        
        Status = RegConnectRegistry(pTemp,
                                    HKEY_LOCAL_MACHINE,
                                    &hServer);

        if( Status isnot ERROR_SUCCESS )
            goto ErrorReturn;

        //Add the pull partner information
        if( fPull )
        {
            DWORD dwDisposition = 0;
            Status = RegCreateKeyEx(hServer,
                                    PULLROOT,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hPartner,
                                    &dwDisposition);
            if( Status isnot NO_ERROR )
            {
                if( fPush )
                    goto PUSH;
                goto ErrorReturn;
            }

            Status = RegCreateKeyEx(hPartner,
                                    wcServerIpAdd,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hKey,
                                    NULL);
            if( Status isnot NO_ERROR )
            {
                if( fPush )
                    goto PUSH;
                goto ErrorReturn;
            }
            
            Status = RegSetValueEx(hKey,
                                   NETBIOSNAME,
                                   0,
                                   REG_SZ,
                                   (LPBYTE)pwszServerName,
                                   (wcslen(pwszServerName)+1)*sizeof(WCHAR));
            if(Status isnot NO_ERROR )
            {
                if( fPush )
                    goto PUSH;
                goto ErrorReturn;
            }
            
            dwType = REG_DWORD;
            dwData = 0;
            dwDataLen = sizeof(DWORD);


            Status = RegQueryValueEx(
                                     hPartner,
                                     PERSISTENCE,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwDataLen);
            if( Status isnot NO_ERROR )
            {
                dwData = 0;
                dwDataLen = sizeof(DWORD);
            }
            
            Status = RegSetValueEx(hKey,
                                   PERSISTENCE,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwData,
                                   dwDataLen);
            
            if( Status isnot NO_ERROR )
            {
                if( fPush )
                    goto PUSH;
                goto ErrorReturn;
            }

            dwType = REG_DWORD;
            dwData = 0;
            dwDataLen = sizeof(DWORD);

            Status = RegQueryValueEx(hPartner,
                                     WINSCNF_SELF_FND_NM,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwDataLen);

            if( Status isnot NO_ERROR )
            {
                dwData = 0;
                dwDataLen = sizeof(DWORD);
            }

            Status = RegSetValueEx(hKey,
                                   WINSCNF_SELF_FND_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwData,
                                   dwDataLen);

            if( Status isnot NO_ERROR )
            {
                if( fPush )
                    goto PUSH;
                goto ErrorReturn;
            }

            Status = RegOpenKeyEx(hServer,
                                  DEFAULTPULL,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hDefault);
            if( Status is NO_ERROR )
            {
                dwType = REG_DWORD;
                dwData = 0;
                dwDataLen = sizeof(DWORD);
                Status = RegQueryValueEx(hDefault,
                                         WINSCNF_RPL_INTERVAL_NM,
                                         0,
                                         &dwType,
                                         (LPBYTE)&dwData,
                                         &dwDataLen);
                if(Status isnot NO_ERROR )
                {
                    dwData = 1800;
                    dwDataLen = sizeof(DWORD);
                }
            }
            else
            {
                dwData = 1800;
                dwDataLen = sizeof(DWORD);
            }
         
            Status = RegSetValueEx(hKey,
                                   WINSCNF_RPL_INTERVAL_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwData,
                                   dwDataLen);

            if( Status isnot NO_ERROR )
            {
                if( fPush )
                    goto PUSH;
                goto ErrorReturn;
            }
        }

        //Add the push partner information
PUSH:   if( hKey )
        {
            RegCloseKey(hKey);
            hKey = NULL;
        }
        
        if( hDefault )
        {
            RegCloseKey(hDefault);
            hDefault = NULL;
        }

        if( hPartner )
        {
            RegCloseKey(hPartner);
            hPartner = NULL;
        }
    
        if( fPush )
        {
            DWORD dwDisposition = 0;
            Status = RegCreateKeyEx(hServer,
                                    PUSHROOT,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hPartner,
                                    &dwDisposition);
            if( Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }
            Status = RegCreateKeyEx(hPartner,
                                    wcServerIpAdd,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hKey,
                                    NULL);
            if( Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }
            
            Status = RegSetValueEx(hKey,
                                   NETBIOSNAME,
                                   0,
                                   REG_SZ,
                                   (LPBYTE)pwszServerName,
                                   (wcslen(pwszServerName)+1)*sizeof(WCHAR));
            if(Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }

            dwType = REG_DWORD;
            dwData = 0;
            dwDataLen = sizeof(DWORD);            
            
            Status = RegQueryValueEx(
                                     hPartner,
                                     PERSISTENCE,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwDataLen);
            if( Status isnot NO_ERROR )
            {
                dwData = 0;
                dwDataLen = sizeof(DWORD);
            }

            Status = RegSetValueEx(hKey,
                                   PERSISTENCE,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwData,
                                   dwDataLen);
            
            if( Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }

            dwType = REG_DWORD;
            dwData = 0;
            dwDataLen = sizeof(DWORD);

            Status = RegQueryValueEx(hPartner,
                                     WINSCNF_SELF_FND_NM,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwDataLen);

            if( Status isnot NO_ERROR )
            {
                dwData = 0;
                dwDataLen = sizeof(DWORD);
            }

            Status = RegSetValueEx(hKey,
                                   WINSCNF_SELF_FND_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwData,
                                   dwDataLen);

            if( Status isnot NO_ERROR )
                goto ErrorReturn;

            Status = RegOpenKeyEx(hServer,
                                  DEFAULTPUSH,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hDefault);
            if( Status is NO_ERROR )
            {
                dwType = REG_DWORD;
                dwData = 0;
                dwDataLen = sizeof(DWORD);
            
                Status = RegQueryValueEx(hDefault,
                                         WINSCNF_UPDATE_COUNT_NM,
                                         0,
                                         &dwType,
                                         (LPBYTE)&dwData,
                                         &dwDataLen);
                if(Status isnot NO_ERROR )
                {
                    dwData = 0;
                    dwDataLen = sizeof(DWORD);
                }
            }
            else
            {
                dwData = 0;
                dwDataLen = sizeof(DWORD);
            }
         
            Status = RegSetValueEx(hKey,
                                   WINSCNF_UPDATE_COUNT_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwData,
                                   dwDataLen);

            if( Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }

            if( hKey )
            {
                RegCloseKey(hKey);
                hKey = NULL;
            }
            
            if( hDefault )
            {
                RegCloseKey(hDefault);
                hDefault = NULL;
            }

            if( hPartner )
            {
                RegCloseKey(hPartner);
                hPartner = NULL;
            }

        }
    }
     
CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( pwszServerName )
    {
        WinsFreeMemory(pwszServerName);
        pwszServerName = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }
    if( hDefault )
    {
        RegCloseKey(hDefault);
        hDefault = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_ADD_PARTNER, Status);

    if( hKey )
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    if( hPartner )
    {
        RegDeleteKey(hPartner, g_ServerIpAddressUnicodeString);
        RegCloseKey(hPartner);
        hPartner = NULL;
    }


    goto CommonReturn;

}

BOOL CheckValidPgOp(HKEY hPartner, BOOL fGrata)
/*++

Routine Description :
        Check whether Persona Mode allows operation for persona grata (fGrata) or non-grata (!fGrata)
Arguments :
        hPartner = opened handle to the 'Partners' registry key
        fGrata specifies whether the check is done for a persona Grata (TRUE) operation or of
        a persona Non-Grata (FALSE) operation
Return Value:
        Returns TRUE if the operation is allowed, FALSE otherwise.

--*/
{
    DWORD dwPersMode = 0;   // default (entry not existant) = Persona Non-Grata
    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);

    // don't chare about the return code. If something goes wrong (entry not existant)
    // consider Persona Mode as being 'Persona Non-Grata'.
    RegQueryValueExA(hPartner,
                    WINSCNF_PERSONA_MODE_NM,
                    NULL,
                    &dwType,
                    (LPVOID)&dwPersMode,
                    &dwSize);

    return dwPersMode ? fGrata : !fGrata;
}

DWORD
HandleSrvrAddPersona(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Add Persona Non Grata servers for the WINS Server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory, List of Server Ip addresses seperated by commas and enclosed
        by {} ( curly braces )
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                               {WINS_TOKEN_SERVERS, TRUE, FALSE},
                            };
    DWORD       dwTagType = 0,
                dwTagNum = 0;
    DWORD       dwSize = 0,
                dwType = REG_MULTI_SZ,
                dwPngIp = 0,
                dwTotal = 0;
                
    LPWSTR      pwszPngIp = NULL;
    LPWSTR      pTemp = NULL;
    LPWSTR      pwszTempKey = NULL;
    LPBYTE      pbByte = NULL;
    HKEY        hServer = NULL,
                hPartner = NULL;
    LPDWORD     pdwPngIp = NULL;
    DWORD       dwLenCount = 0,
                dwTemp = 0;
    BOOL        fGrata;

    fGrata = (wcsstr(CMD_SRVR_ADD_PNGSERVER, ppwcArguments[dwCurrentIndex-1]) == NULL);

    //Needs a parameter always
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, fGrata ? HLP_SRVR_ADD_PGSERVER_EX : HLP_SRVR_ADD_PNGSERVER_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;


    if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp,
                                HKEY_LOCAL_MACHINE,
                                &hServer);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegOpenKeyEx(hServer,
                          PARTNERROOT,
                          0,
                          KEY_ALL_ACCESS,
                          &hPartner);
    
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    if (!CheckValidPgOp(hPartner, fGrata))
    {
        DisplayMessage(g_hModule, fGrata ? EMSG_SRVR_PG_INVALIDOP : EMSG_SRVR_PNG_INVALIDOP);
        Status = ERROR_INVALID_PARAMETER;
        goto CommonReturn;
    }

    if (fGrata)
        pwszTempKey = WinsOemToUnicode(WINSCNF_PERSONA_GRATA_NM, NULL);
    else
        pwszTempKey = WinsOemToUnicode(WINSCNF_PERSONA_NON_GRATA_NM, NULL);

    if( pwszTempKey is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    Status = RegQueryValueEx(hPartner,
                             pwszTempKey,
                             NULL,
                             &dwType,
                             pbByte,
                             &dwSize);

    
    WinsFreeMemory(pwszTempKey);
    pwszTempKey = NULL;

    if( Status isnot NO_ERROR and
        Status isnot 2 )
        goto ErrorReturn;

    if( dwSize > 7 )
    {
        LPWSTR  pwszPng = NULL;
        pbByte = WinsAllocateMemory(dwSize+2);

        dwSize+=2;

        if( pbByte is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        
        Status = RegQueryValueEx(hPartner,
                                 fGrata ? PGSERVER : PNGSERVER,
                                 NULL,
                                 &dwType,
                                 pbByte,
                                 &dwSize);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        pwszPng = (LPWSTR)pbByte;

        pwszPngIp = WinsAllocateMemory(dwSize);

        if( pwszPngIp is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        memcpy(pwszPngIp, pbByte, dwSize);

        for( i=0; i<(dwSize+2)/sizeof(WCHAR); i++ )
        {
            if( pwszPng[i] is L'\0' and
                pwszPng[i+1] isnot L'\0')
            {
                pwszPng[i] = L',';
                i++;
            }
        }

        dwPngIp = 0;
        
        pTemp = wcstok(pwszPng, L",");
        
        while(pTemp isnot NULL )
        {
            LPDWORD     pdwTemp = pdwPngIp;
            
            dwPngIp++;
            
            dwLenCount += wcslen(pTemp);
            pdwPngIp = WinsAllocateMemory(dwPngIp*sizeof(DWORD));

            if( pdwPngIp is NULL )
            {
                WinsFreeMemory(pdwTemp);
                pdwTemp = NULL;
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            if( pdwTemp isnot NULL )
            {
                memcpy(pdwPngIp, pdwTemp, (dwPngIp-1)*sizeof(DWORD));
                WinsFreeMemory(pdwTemp);
                pdwTemp = NULL;
            }
            
            pdwPngIp[dwPngIp-1] = StringToIpAddress(pTemp);

            pTemp = wcstok(NULL, L","); 
            dwLenCount++;

        }
    }


    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               &dwTagType,
                               &dwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(dwTagType)
        {
        //Server Ip Address List
        case 0:
            {
                DWORD   dwIpLen = 0;
                LPWSTR  pwszIps = NULL;
                dwIpLen = wcslen(ppwcArguments[dwCurrentIndex+dwTagNum]);

                if( ppwcArguments[dwCurrentIndex+dwTagNum][0] isnot L'{' or 
                    ppwcArguments[dwCurrentIndex+dwTagNum][dwIpLen-1] isnot L'}')
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                
                ppwcArguments[dwCurrentIndex+dwTagNum][dwIpLen-1] =L'\0';

                dwIpLen--;

                pwszIps = WinsAllocateMemory((dwIpLen)*sizeof(WCHAR));

                if( pwszIps is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                
                memcpy(pwszIps, ppwcArguments[dwCurrentIndex+dwTagNum]+1, (dwIpLen-1)*sizeof(WCHAR));
               
                i=0;
                pTemp = wcstok(pwszIps, L",");
                while(pTemp isnot NULL)
                {       
                    BOOL  fPresent = FALSE;
                    DWORD dw = 0;

                    if( IsIpAddress(pTemp) is FALSE )
                    {
                        DisplayMessage(g_hModule,
                                       EMSG_SRVR_IP_DISCARD,
                                       pTemp);
                        pTemp = wcstok(NULL, L",");
                        continue;
                    }
                    else
                    {
                        dw = StringToIpAddress(pTemp);

                        for( j=0; j<dwPngIp; j++ )
                        {           
                            if( dw is INADDR_NONE )
                            {
                                continue;
                            }
                            if( pdwPngIp[j] is dw )
                            {
                                fPresent = TRUE;
                                break;
                            }
                            else
                            {
                                continue;
                            }
                        }
                        if( fPresent is FALSE )
                        {
                            LPDWORD pdwTemp = pdwPngIp;

                            pdwPngIp = WinsAllocateMemory((dwPngIp+1)*sizeof(DWORD));
                            if( pdwPngIp is NULL )
                            {
                                WinsFreeMemory(pdwTemp);
                                pdwTemp = NULL;
                                Status = ERROR_NOT_ENOUGH_MEMORY;
                                goto ErrorReturn;
                            }

                            if( pdwTemp )
                            {
                                memcpy(pdwPngIp, pdwTemp, dwPngIp*sizeof(DWORD));
                                WinsFreeMemory(pdwTemp);
                                pdwTemp = NULL;
                            }

                            pdwPngIp[dwPngIp] = dw;
                            dwPngIp++;
                            dwTotal++;
                        }
                        else
                        {
                            DisplayMessage(g_hModule,
                                           EMSG_SRVR_DUPLICATE_DISCARD,
                                           pTemp);
                        }
                    }
                    pTemp = wcstok(NULL, L",");
                }

                
                if( pwszIps )
                {
                    WinsFreeMemory(pwszIps);
                    pwszIps = NULL;
                }
                break;            
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
    
    if( pwszPngIp )
    {
        WinsFreeMemory(pwszPngIp);
        pwszPngIp = NULL;
    }

    pwszPngIp = WinsAllocateMemory((dwPngIp*(MAX_IP_STRING_LEN+1)+2)*sizeof(WCHAR));

    if( pwszPngIp is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }
    
    dwTemp = 0;

    for( i=0; i<dwPngIp; i++ )
    {
        LPWSTR pwIp = IpAddressToString(pdwPngIp[i]);
        
        if( pwIp is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwszPngIp+dwTemp, pwIp);
        dwTemp+= wcslen(pwIp);

        dwTemp++;
        WinsFreeMemory(pwIp);
        pwIp = NULL;
    }
 
    pwszPngIp[dwTemp] = L'\0';
    pwszPngIp[dwTemp+1] = L'\0';

    Status = RegSetValueEx(hPartner,
    fGrata? PGSERVER : PNGSERVER,
                           0,
                           REG_MULTI_SZ,
                           (LPBYTE)pwszPngIp,
                           (dwTemp+1)*sizeof(WCHAR));


    if( Status isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Status is NO_ERROR )
    {
        if( dwTotal is 0 )
        {
            DisplayMessage(g_hModule,
                            fGrata ? EMSG_SRVR_NO_IP_ADDED_PG : EMSG_SRVR_NO_IP_ADDED_PNG);
        }
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }
    
    if( hPartner )
    {
        RegCloseKey(hPartner);
        hPartner = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pwszPngIp )
    {
        WinsFreeMemory(pwszPngIp);
        pwszPngIp = NULL;
    }

    if( pdwPngIp )
    {
        WinsFreeMemory(pdwPngIp);
        pdwPngIp = NULL;
    }

    if( pbByte )
    {
        WinsFreeMemory(pbByte);
        pbByte = NULL;
    }


    return Status;
ErrorReturn:
    DisplayErrorMessage(fGrata ? EMSG_SRVR_ADD_PGSERVER : EMSG_SRVR_ADD_PNGSERVER, Status);
    goto CommonReturn;                    

}


DWORD
HandleSrvrCheckDatabase(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Checks the consistency of the database
Arguments :
        No arguments
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_ALL, FALSE, FALSE},
                                {WINS_TOKEN_FORCE, FALSE, FALSE},
                            };

    BOOL        fAll = FALSE, fForce = FALSE;
    LPDWORD     pdwTagType = NULL, pdwTagNum = NULL;

  	WINSINTF_SCV_REQ_T ScvReq;

    if( dwArgCount > dwCurrentIndex )
    {
        //Start processing the arguments
        dwNumArgs = dwArgCount - dwCurrentIndex;

        pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
        pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

        if( pdwTagType is NULL or
            pdwTagNum is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

        Status = PreProcessCommand(ppwcArguments,
                                   dwArgCount,
                                   dwCurrentIndex,
                                   pttTags,
                                   &dwTagCount,
                                   pdwTagType,
                                   pdwTagNum);
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        for( j=0; j<dwTagCount; j++ )
        {
            switch(pdwTagType[j])
            {
            //Consistency check all or those older than verify interval
            case 0:
                {
                    DWORD dw = 0;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }                    

                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                    if( dw == 1 )
                    {
                        fAll = TRUE;
                    }
                    else if( dw == 0 )
                    {
                        fAll = FALSE;
                    }
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    break;
                }
            //Override wins checking in overloaded condition
            case 1 :
                {
                    DWORD dw = 0;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }                    

                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                    if( dw == 1 )
                    {
                        fForce = TRUE;
                    }
                    else if( dw == 0 )
                    {
                        fForce = FALSE;
                    }
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    break;
                }
            default:
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
            }
        }
    }
    if( fAll )
        ScvReq.Age = 0;				// check all the replicas
    else
        ScvReq.Age = 1;

    if( fForce )
        ScvReq.fForce = TRUE;
    else
	    ScvReq.fForce = FALSE;

	ScvReq.Opcode_e = WINSINTF_E_SCV_VERIFY;

	Status = WinsDoScavengingNew(g_hBind, &ScvReq);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;
    
    DisplayMessage(g_hModule, MSG_WINS_COMMAND_QUEUED);

CommonReturn:
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_CHECK_DATABASE, 
                        Status);
    goto CommonReturn;
}


DWORD
HandleSrvrCheckName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Checks a list of names against a list of WINS servers
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory, either a list of names or a file which contains the list of names.
        Names should be in the format (name)*(16th char) and either a list of server
        IP addresses, separated by commas and enclosed by {} or a file that contains
        the list of ip address in comma seperated format.
        Optional, to include all partners in the server list.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_NAMELIST, FALSE, FALSE},
                                {WINS_TOKEN_NAMEFILE, FALSE, FALSE},
                                {WINS_TOKEN_SERVERLIST, FALSE, FALSE},
                                {WINS_TOKEN_SERVERFILE, FALSE, FALSE},
                                {WINS_TOKEN_INCLPARTNER, FALSE, FALSE},
                            };
    BOOL        fNameFile = FALSE,
                fServerFile = FALSE;
    LPWSTR      pwszNameFile = NULL,
                pwszServerFile = NULL;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    PDWORD      pdwIpAddress = NULL;
    LPWSTR      *ppNames = NULL;
    BOOL        fInclPartner = FALSE,
                fIpEmpty = TRUE;

    //Need at least a list of names either directly or thro' file and
    //a list of server Ip either direcly or thro' file.
    if( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_CHECK_NAME_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //Start processing the arguments
    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    if( ( pttTags[0].bPresent is TRUE and
          pttTags[1].bPresent is TRUE ) or
        ( pttTags[2].bPresent is TRUE  and
          pttTags[3].bPresent is TRUE ) )
    {
        Status = ERROR_INVALID_PARAMETER_SPECIFICATION;
        goto ErrorReturn;
    }
    
    WinServers = WinsAllocateMemory(MAX_SERVERS*sizeof(*WinServers));

    if( WinServers is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    NBNames = (u_char ** )WinsAllocateMemory(MAX_NB_NAMES*sizeof(u_char*));

    if( NBNames is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0://NameList
            {
                LPWSTR  pwszToken = L",\r\n\t ";
                LPWSTR  pwszName = NULL;
                LPWSTR  pwszTemp = NULL;
                int     ilen = 0;
                LPWSTR  pTemp = NULL;
                BOOL    fPresent = FALSE;
                DWORD   dw = 0,
                        dwType = 0;
                DWORD   dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                

                if( dwLen < 2 )
                {
                    NumNBNames = 0;
                    break;
                }
                if( ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0] isnot L'{' or
                    ppwcArguments[dwCurrentIndex+pdwTagNum[j]][dwLen-1] isnot L'}' )
                {
                    NumNBNames = 0;
                    break;
                }

                pwszTemp = WinsAllocateMemory((dwLen)*sizeof(WCHAR));

                if(pwszTemp is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                
                for( ilen=0; ilen<NumNBNames; ilen++ )
                {
                    if( NBNames[ilen] isnot NULL )
                    {
                        WinsFreeMemory(NBNames[ilen]);
                        NBNames[ilen] = NULL;
                    }
                }
                NumNBNames = 0;

                wcscpy(pwszTemp, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+1);
                pwszTemp[dwLen-2] = L'\0';
                
                pwszName = wcstok(pwszTemp, pwszToken);
                
                while(pwszName isnot NULL )
                {                    
                    dw = wcslen(pwszName);
                    
                    if( dw < 1 or
                        dw > 18 )
                    {
                        DisplayMessage(g_hModule, EMSG_WINS_INVALID_NAME, pwszName);

                    }
                    else
                    {
                        pTemp = wcsstr(pwszName, L"*");
                        if( pTemp is NULL )
                        {
                            DisplayMessage(g_hModule, EMSG_WINS_INVALID_NAME, pwszName);
                        }
                        else
                        {
                            CHAR   chEnd = 0x00;
                            dw = (DWORD)(pTemp - pwszName + 1);
                            
                            if( dw > 16 )
                            {
                                DisplayMessage(g_hModule,
                                               EMSG_SRVR_INVALID_NETBIOS_NAME);
                                goto ErrorReturn;
                            }
                            pwszName[dw-1] = L'\0';
                            
                            chEnd = StringToHexA(pTemp+1);

                            if( dwType > 255 )
                            {
                                DisplayMessage(g_hModule, EMSG_WINS_VALUE_OUTOFRANGE);
                            }
                            else
                            {
                                LPWSTR   pwcTemp = WinsAllocateMemory((NBT_NONCODED_NMSZ+1)*sizeof(WCHAR));
                                LPWSTR pwTemp = NULL;
                                if( pwcTemp is NULL )
                                {
                                    Status = ERROR_NOT_ENOUGH_MEMORY;
                                    if( pwszTemp isnot NULL )
                                    {
                                        WinsFreeMemory(pwszTemp );
                                        pwszTemp = NULL;
                                    }
                                    goto ErrorReturn;                            
                                }
                                
                                wcscpy(pwcTemp, pwszName);
                                wcsncat(pwcTemp,
                                        L"                ",
                                        (16 - wcslen(pwszName)));
                                pwcTemp[15] = chEnd;
                                                                
                                for( ilen=0; ilen<NumNBNames; ilen++)
                                {
                                    pwTemp = WinsOemToUnicode(NBNames[ilen], NULL);
                                    if( pwTemp is NULL )
                                    {
                                        Status = ERROR_NOT_ENOUGH_MEMORY;
                                        goto ErrorReturn;
                                    }
                                    if(_wcsicmp(pwTemp, pwcTemp) is 0 )
                                    {
                                        fPresent = TRUE;
                                        break;
                                    }
                                    WinsFreeMemory(pwTemp);
                                    pwTemp = NULL;
                                }
                                if( pwTemp )
                                {
                                    WinsFreeMemory(pwTemp);
                                    pwTemp = NULL;
                                }
                                
                                if( fPresent is FALSE )
                                {
                                    LPSTR pcTemp = NULL;

                                    NBNames[NumNBNames] = WinsAllocateMemory(17);
                                    if( NBNames[NumNBNames] is NULL )
                                    {
                                        if( pwszTemp isnot NULL )
                                        {
                                            WinsFreeMemory(pwszTemp );
                                            pwszTemp = NULL;
                                        }
                                        Status = ERROR_NOT_ENOUGH_MEMORY;
                                        goto ErrorReturn;
                                    }
                                    pcTemp = WinsUnicodeToOem(pwcTemp, NULL);
                                    if( pcTemp is NULL )
                                    {
                                        Status = ERROR_NOT_ENOUGH_MEMORY;
                                        goto ErrorReturn;
                                    }
                                    strncpy(NBNames[NumNBNames], pcTemp, 16);
                                    NBNames[NumNBNames][15] = (CHAR)chEnd;
                                    NBNames[NumNBNames][16] = '\0';
                                    NumNBNames++;
                                    WinsFreeMemory(pcTemp);
                                    pcTemp = NULL;
                                }
                                if( pwcTemp )
                                {
                                    WinsFreeMemory(pwcTemp);
                                    pwcTemp = NULL;
                                }

                            }
                        }
                    }
                    pwszName = wcstok(NULL, pwszToken);

                }
                
                if( pwszTemp )
                {
                    WinsFreeMemory(pwszTemp);
                    pwszTemp = NULL;
                }

                break;
            }
        case 1://NameFile
            {
                HANDLE  hFile = NULL;
                DWORD   dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]),
                        dwFileSize = 0,
                        dw = 0,
                        dwType = 0,
                        dwBytesRead = 0;
                BOOL    fPresent = FALSE;
                int     ilen = 0;
                LPBYTE  pbFileData = NULL;
                LPSTR   pszToken = " ,\r\n\t",
                        pszData = NULL,
                        pTemp = NULL,
                        pszName = NULL,                        
                        pszTemp = NULL;
                LPWSTR  pwszTempName = NULL;
                        

                if( dwLen < 1 )
                {
                    DisplayMessage(g_hModule, 
                                   EMSG_WINS_INVALID_FILENAME, 
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    goto CommonReturn;
                }

                hFile = CreateFile(ppwcArguments[dwCurrentIndex+pdwTagNum[j]],
                                   GENERIC_READ | GENERIC_WRITE,
                                   0,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);

                if( hFile is INVALID_HANDLE_VALUE )
                {
                    Status = GetLastError();
                    goto ErrorReturn;
                }

                dwFileSize = GetFileSize(hFile, NULL);

                if( dwFileSize is 0 )
                {
                    DisplayMessage(g_hModule, 
                                   EMSG_WINS_EMPTY_FILE, 
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    CloseHandle(hFile);
                    hFile = NULL;
                    goto CommonReturn;
                }

                pbFileData = WinsAllocateMemory(dwFileSize+1);

                if( pbFileData is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    CloseHandle(hFile);
                    hFile = NULL;
                    goto ErrorReturn;
                }

                if( !ReadFile( hFile, pbFileData, dwFileSize, &dwBytesRead, NULL) )
                {
                    DisplayMessage(g_hModule, EMSG_WINS_FILEREAD_FAILED);
                    CloseHandle(hFile);
                    hFile = NULL;
                    goto CommonReturn;
                }
                
                CloseHandle(hFile);
                hFile = NULL;

                for( ilen=0; ilen<NumNBNames; ilen++ )
                {
                    if( NBNames[ilen] isnot NULL )
                    {
                        WinsFreeMemory(NBNames[ilen]);
                        NBNames[ilen] = NULL;
                    }
                }
                NumNBNames = 0;

                pszData = (LPSTR)pbFileData;
                
                pszName = strtok(pszData, pszToken);
                while( pszName isnot NULL )
                {
                    dw = strlen(pszName);
                    
                    if( dw < 1 or
                        dw > 18 )
                    {
                        pwszTempName = WinsOemToUnicode(pszName, NULL);
                        if( pwszTempName is NULL )
                        {
                            Status = ERROR_NOT_ENOUGH_MEMORY;
                            goto ErrorReturn;
                        }
                        DisplayMessage(g_hModule, EMSG_WINS_INVALID_NAME, pwszTempName);
                        WinsFreeMemory(pwszTempName);
                        pwszTempName = NULL;
                    }
                    else
                    {
                        WCHAR wcEnd[2] = {L'\0'};
                        CHAR  cEnd[2] = {L'\0'};

                        pTemp = strstr(pszName, "*");
                        if( pTemp is NULL )
                        {
                            pwszTempName = WinsOemToUnicode(pszName, NULL);
                            if( pwszTempName is NULL )
                            {
                                Status = ERROR_NOT_ENOUGH_MEMORY;
                                goto ErrorReturn;
                            }
                            DisplayMessage(g_hModule, EMSG_WINS_INVALID_NAME, pwszTempName);
                            WinsFreeMemory(pwszTempName);
                            pwszTempName = NULL;
                        }
                        else
                        {
                            CHAR    chEndChar = 0x00;
                            LPWSTR  pwszTempBuf = NULL;
                            dw = (DWORD)(pTemp - pszName + 1);
                            if( dw > 16 )
                            {
                                DisplayMessage(g_hModule,
                                               EMSG_SRVR_INVALID_NETBIOS_NAME);
                                goto ErrorReturn;
                            }
                            pszName[dw-1] = L'\0';
                            pwszTempBuf = WinsOemToUnicode(pTemp+1, NULL);

                            if( pwszTempBuf is NULL )
                            {
                                Status = ERROR_NOT_ENOUGH_MEMORY;
                                goto ErrorReturn;
                            }

                            chEndChar = StringToHexA(pwszTempBuf);
                            
                            WinsFreeMemory(pwszTempBuf);
                            pwszTempBuf = NULL;

                            if( dwType > 255 )
                            {
                                DisplayMessage(g_hModule, EMSG_WINS_VALUE_OUTOFRANGE);
                            }
                            else
                            {
                                LPSTR pcTemp = WinsAllocateMemory(NBT_NONCODED_NMSZ+1);
                                if( pcTemp is NULL )
                                {
                                    Status = ERROR_NOT_ENOUGH_MEMORY;
                                    if( pbFileData isnot NULL )
                                    {
                                        WinsFreeMemory(pbFileData );
                                        pbFileData = NULL;
                                    }
                                    goto ErrorReturn;                            
                                }
                                
                                strcpy(pcTemp, pszName);
                                strncat(pcTemp, 
                                        "               ", 
                                        (16-strlen(pszName)));
                           
                                pcTemp[15] = chEndChar;

                                for( ilen=0; ilen<NumNBNames; ilen++)
                                {
                                    if(_stricmp(NBNames[ilen], pcTemp) is 0 )
                                    {
                                        fPresent = TRUE;
                                        break;
                                    }
                                }
                                
                                if( fPresent is FALSE )
                                {
                                    LPSTR   pszOem = NULL;
                                    NBNames[NumNBNames] = WinsAllocateMemory(17);
                                    if( NBNames[NumNBNames] is NULL )
                                    {
                                        Status = ERROR_NOT_ENOUGH_MEMORY;
                                        goto ErrorReturn;
                                    }
                                    
                                    pszOem = WinsAnsiToOem(pcTemp);
                                    if( pszOem is NULL )
                                    {
                                        Status = ERROR_NOT_ENOUGH_MEMORY;
                                        goto ErrorReturn;
                                    }
                                    strncpy(NBNames[NumNBNames], pszOem, 16);
                                    
                                    WinsFreeMemory(pszOem);
                                    pszOem = NULL;

                                    NBNames[NumNBNames][15] = (CHAR)chEndChar;
                                    NumNBNames++;
                                }
                                if( pcTemp )
                                {
                                    WinsFreeMemory(pcTemp);
                                    pcTemp = NULL;
                                }
                            }
                        }
                    }
                    pszName = strtok(NULL, pszToken);
                }
                if( pbFileData )
                {
                    WinsFreeMemory(pbFileData);
                    pbFileData = NULL;
                }
                break;
            }
        case 2://ServerList
            {
                LPWSTR  pwszToken = L",\r\n\t ",
                        pwszName = NULL,
                        pwszTemp = NULL;
                int     ilen = 0;
                BOOL    fPresent = FALSE;
                DWORD   dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                

                if( dwLen < 2 )
                {
                    NumWinServers = 0;
                    break;
                }
                if( ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0] isnot L'{' or
                    ppwcArguments[dwCurrentIndex+pdwTagNum[j]][dwLen-1] isnot L'}' )
                {
                    NumWinServers = 0;
                    break;
                }

                pwszTemp = WinsAllocateMemory((dwLen)*sizeof(WCHAR));

                if(pwszTemp is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                
                if( fInclPartner is FALSE )
                {
                    memset(WinServers, 0x00, MAX_SERVERS*sizeof(WINSERVERS));

                    NumWinServers = 0;
                }

                wcscpy(pwszTemp, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+1);
                pwszTemp[dwLen-2] = L'\0';
                
                pwszName = wcstok(pwszTemp, pwszToken);
                
                while(pwszName isnot NULL )
                {             
                    fPresent = FALSE;
                    if( IsIpAddress(pwszName) is FALSE )
                    {
                        DisplayMessage(g_hModule, EMSG_WINS_INVALID_IPADDRESS, pwszName);
                    }
                    else
                    {
                        struct in_addr  Temp;
                        LPSTR           pszTempAddr = NULL;

                        pszTempAddr = WinsUnicodeToAnsi(pwszName, NULL);
                        if( pszTempAddr is NULL )
                        {
                            Status = ERROR_NOT_ENOUGH_MEMORY;
                            goto ErrorReturn;
                        }
                        Temp.s_addr = inet_addr(pszTempAddr);
                        
                        WinsFreeMemory(pszTempAddr);
                        pszTempAddr = NULL;

                        if( Temp.s_addr isnot INADDR_NONE )
                        {
                            for( ilen=0; ilen<NumWinServers; ilen++)
                            {
                                if( WinServers[ilen].Server.s_addr is Temp.s_addr )
                                {
                                    fPresent = TRUE;
                                    break;
                                }
                            }
                        
                            fIpEmpty = FALSE;

                            if( fPresent is FALSE )
                            {
                                WinServers[NumWinServers].Server.s_addr = Temp.s_addr;
                                NumWinServers++;
                            }                       
                        }
                    }
                    pwszName = wcstok(NULL, pwszToken);
                }
                
                break;
            }
        case 3://ServerFile
            {
                HANDLE hFile = NULL;
                DWORD   dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]),
                        dwFileSize = 0,
                        dwBytesRead = 0;
                BOOL    fPresent = FALSE;
                int     ilen = 0;
                LPBYTE  pbFileData = NULL;
                LPSTR   pszToken = " ,\r\n\t",
                        pszData = NULL,
                        pszName = NULL;
                LPWSTR  pwszToken = L" ,\r\n\t",
                        pwszName = NULL,
                        pwszData = NULL;
            
                if( dwLen < 1 )
                {
                    DisplayMessage(g_hModule, 
                                   EMSG_WINS_INVALID_FILENAME, 
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    goto CommonReturn;
                }

                hFile = CreateFile(ppwcArguments[dwCurrentIndex+pdwTagNum[j]],
                                   GENERIC_READ | GENERIC_WRITE,
                                   0,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);

                if( hFile is INVALID_HANDLE_VALUE )
                {
                    Status = GetLastError();
                    goto ErrorReturn;
                }

                dwFileSize = GetFileSize(hFile, NULL);

                if( dwFileSize is 0 )
                {
                    DisplayMessage(g_hModule, 
                                   EMSG_WINS_EMPTY_FILE, 
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    CloseHandle(hFile);
                    hFile = NULL;
                    goto CommonReturn;
                }

                pbFileData = WinsAllocateMemory(dwFileSize+1);

                if( pbFileData is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    CloseHandle(hFile);
                    hFile = NULL;
                    goto ErrorReturn;
                }

                if( !ReadFile( hFile, pbFileData, dwFileSize, &dwBytesRead, NULL) )
                {
                    CloseHandle(hFile);
                    hFile = NULL;
                    DisplayMessage(g_hModule, EMSG_WINS_FILEREAD_FAILED);
                    goto CommonReturn;
                }
                
                CloseHandle(hFile);
                hFile = NULL;
                
                if( fInclPartner is FALSE )
                {
                    memset(WinServers, 0x00, MAX_SERVERS*sizeof(WINSERVERS));

                    NumWinServers = 0;
                }

                pszData = (LPSTR)pbFileData;
                pwszData = WinsOemToUnicode(pszData, NULL);
                if( pwszData is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                pwszName = wcstok(pwszData, pwszToken);
                while( pwszName isnot NULL )
                {
                    fPresent = FALSE;
                    pszName = WinsUnicodeToOem(pwszName, NULL);
                    
                    if( pszName is NULL )
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }

                    if( IsIpAddress(pwszName) is FALSE )
                    {
                        DisplayMessage(g_hModule, EMSG_WINS_INVALID_IPADDRESS, pwszName);
                    }
                    else
                    {
                        struct in_addr  Temp;

                        Temp.s_addr = inet_addr(pszName);

                        if( Temp.s_addr isnot INADDR_NONE )
                        {
                            for( ilen=0; ilen<NumWinServers; ilen++)
                            {
                                if( WinServers[ilen].Server.s_addr is Temp.s_addr )
                                {
                                    fPresent = TRUE;
                                    break;
                                }
                            }
                 
                            fIpEmpty = FALSE;
                            
                            if( fPresent is FALSE )
                            {
                                WinServers[NumWinServers].Server.s_addr = Temp.s_addr;
                                NumWinServers++;
                            }
                        }
                    }
                    pwszName = wcstok(NULL, pwszToken);
                    if( pszName )
                    {
                        WinsFreeMemory(pszName);
                        pszName = NULL;
                    }
                }

                if( pbFileData )
                {
                    WinsFreeMemory(pbFileData);
                    pbFileData = NULL;
                }
                if( pwszData )
                {
                    WinsFreeMemory(pwszData);
                    pwszData = NULL;
                }

                break;
            }
        case 4://IncludePartners
            {
                HKEY    hServer = NULL,
                        hPull = NULL,
                        hPush = NULL;
                LPWSTR  pTemp = NULL;
                WCHAR   wcKey[MAX_IP_STRING_LEN+1] = {L'\0'};
                DWORD   dw = 0,
                        dwLen = MAX_IP_STRING_LEN+1,
                        dwKeys = 0;                
                if(wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) isnot 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                if( ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0] isnot L'Y' and
                    ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0] isnot L'y' )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                if( wcslen(g_ServerNetBiosName) < 2 )
                {
                    pTemp = NULL;
                }

                Status = RegConnectRegistry(pTemp,
                                            HKEY_LOCAL_MACHINE,
                                            &hServer );
                if( Status isnot NO_ERROR )
                {
                    Status = NO_ERROR;
                    break;
                }
                
                while(TRUE)
                {
                    Status = RegOpenKeyEx(hServer,
                                          PULLROOT,
                                          0,
                                          KEY_ALL_ACCESS,
                                          &hPull);

                    if( Status isnot NO_ERROR )
                    {
                        Status = NO_ERROR;
                        break;
                    }

                    Status = RegQueryInfoKey(hPull,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &dwKeys,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL);
                    
                    if( Status isnot NO_ERROR )
                    {
                        Status = NO_ERROR;
                        break;
                    }

                    if( dwKeys < 1 )
                        break;

                    for( dw=0; dw<dwKeys; dw++ )
                    {
                        DWORD i = 0;                             
                        LPSTR pszTempAddr = NULL;
                        BOOL  fPresent = FALSE;
                        struct in_addr  Temp;

                        dwLen = MAX_IP_STRING_LEN+1;

                        memset(wcKey, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));

                        Status = RegEnumKeyEx(hPull,
                                              dw,
                                              wcKey,
                                              &dwLen,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL);

                        if( Status isnot NO_ERROR )
                            continue;

                        pszTempAddr = WinsUnicodeToOem(wcKey, NULL);
                        if( pszTempAddr is NULL )
                        {
                            Status = ERROR_NOT_ENOUGH_MEMORY;
                            goto ErrorReturn;
                        }
                        Temp.s_addr = inet_addr(pszTempAddr);

                        WinsFreeMemory(pszTempAddr);
                        pszTempAddr = NULL;

                        if( Temp.s_addr isnot INADDR_NONE )
                        {
                            fPresent = FALSE;
                            if( MAX_SERVERS > NumWinServers )
                            {
                                for( i=0; i<(DWORD)NumWinServers; i++)
                                {
                                    if( WinServers[i].Server.s_addr is Temp.s_addr )
                                    {
                                        fPresent = TRUE;
                                        break;
                                    }
                                }
                            
                                if( fPresent is FALSE )
                                {
                                    WinServers[NumWinServers].Server.s_addr = Temp.s_addr;
                                    NumWinServers++;
                                }

                            }
                            else
                                break;
                        }

                    }

                }

                if( hPull )
                {
                    RegCloseKey(hPull);
                    hPull = NULL;
                }

                dw = dwKeys = 0;

                while(TRUE)
                {
                    Status = RegOpenKeyEx(hServer,
                                          PUSHROOT,
                                          0,
                                          KEY_ALL_ACCESS,
                                          &hPush);

                    if( Status isnot NO_ERROR )
                    {
                        Status = NO_ERROR;
                        break;
                    }

                    Status = RegQueryInfoKey(hPush,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &dwKeys,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL);
                    
                    if( Status isnot NO_ERROR )
                    {
                        Status = NO_ERROR;
                        break;
                    }

                    if( dwKeys < 1 )
                        break;

                    for( dw=0; dw<dwKeys; dw++ )
                    {
                        DWORD i = 0;
                        BOOL  fPresent = FALSE;
                        LPSTR pszTempAddr = NULL;
                        struct in_addr  Temp;

                        dwLen = MAX_IP_STRING_LEN+1;

                        memset(wcKey, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));

                        Status = RegEnumKeyEx(hPush,
                                              dw,
                                              wcKey,
                                              &dwLen,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL);

                        if( Status isnot NO_ERROR )
                            continue;

                        pszTempAddr = WinsUnicodeToOem(wcKey, NULL);
                        if( pszTempAddr is NULL )
                        {
                            Status = ERROR_NOT_ENOUGH_MEMORY;
                            goto ErrorReturn;
                        }

                        Temp.s_addr = inet_addr(pszTempAddr);
                        WinsFreeMemory(pszTempAddr);
                        pszTempAddr = NULL;

                        if( Temp.s_addr isnot INADDR_NONE )
                        {
                            if( MAX_SERVERS > NumWinServers )
                            {
                                for( i=0; i<(DWORD)NumWinServers; i++)
                                {
                                    if( WinServers[i].Server.s_addr is Temp.s_addr )
                                    {
                                        fPresent = TRUE;
                                        break;
                                    }
                                }
                            
                                if( fPresent is FALSE )
                                {
                                    WinServers[NumWinServers].Server.s_addr = Temp.s_addr;
                                    NumWinServers++;
                                }

                            }
                            else
                                break;
                        }

                    }

                }
                if( hPush )
                {
                    RegCloseKey(hPush);
                    hPush = NULL;
                }

                if( hServer )
                {
                    RegCloseKey(hServer);
                    hServer = NULL;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    if( NumNBNames is 0 )
    {
        DisplayMessage(g_hModule, EMSG_WINS_NO_NAMES);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( NumWinServers is 0 )
    {
        DisplayMessage(g_hModule, EMSG_WINS_NO_SERVERS);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( fIpEmpty is TRUE )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_NO_SERVERS);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    else
    {
        CheckNameConsistency();
    }

    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);


CommonReturn:

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( pdwIpAddress )
    {
        WinsFreeMemory(pdwIpAddress);
        pdwIpAddress = NULL;
    }

    if( ppNames )
    {    
        WinsFreeMemory(ppNames);
        ppNames = NULL;
    }

    if( WinServers )
    {
        WinsFreeMemory(WinServers);
        WinServers = NULL;
    }

    if( NBNames )
    {
        WinsFreeMemory(NBNames);
        NBNames = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_CHECK_NAME, Status);
    goto CommonReturn;
}

DWORD
HandleSrvrCheckVersion(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Checks the version number consistencies for the records
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory, IP address of the server to start with.
        Optional, a File Name to store the output in proper format.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount = 0;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                                {WINS_TOKEN_FILE, FALSE, FALSE},
                            };

    PDWORD      pdwTagNum = NULL,
                pdwTagType = NULL;
    
    BOOL        fFile = FALSE;
    FILE        *pFile = NULL;
    LPSTR       pStartIp = NULL;

    //Must provide the IP address of the server to start with
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_CHECK_VERSION_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;

    }

    //Start processing the arguements based on the 
    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }
    
    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        //Ip Address of the server to start with
        case 0:
            {
                WCHAR   wcServerIpAdd[MAX_IP_STRING_LEN+1] = {L'\0'};
                                    
                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) is FALSE )
                {
                    Status = ERROR_INVALID_IPADDRESS;
                    goto ErrorReturn;
                }

                wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);

                pStartIp = WinsUnicodeToOem(wcServerIpAdd, NULL);

                if( pStartIp is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                break;

            }
        //File to store the output data
        case 1:
            {
                WCHAR       wcFile[MAX_PATH] = {L'\0'};
            
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 or
                    wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > MAX_PATH )
                {
                    wcscpy(wcFile, L"wins.rec");
                }
                else
                {
                    wcscpy(wcFile, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                }

                pFile = _wfopen(wcFile, L"w+");

                if( pFile is NULL )
                {
                    pFile = _wfopen(L"wins.rec", L"w+");
                    fFile = TRUE;
                }
                else
                {
                    fFile = TRUE;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }


    CheckVersionNumbers( pStartIp,
                         fFile,
                         pFile);

CommonReturn:
    
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    
    if( pFile )
    {
        fclose(pFile);
        pFile = NULL;
    }
    
    if( pStartIp)
    {
        WinsFreeMemory(pStartIp);
        pStartIp = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_CHECK_VERSION,
                        Status);
    goto CommonReturn;
}


DWORD
HandleSrvrDeleteName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Deletes an record entry for the WINS server database
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory, Record Name, Endchar
        Optional, Scope
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount = 0;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_NAME, TRUE, FALSE},
                                {WINS_TOKEN_ENDCHAR, TRUE, FALSE},
                                {WINS_TOKEN_SCOPE, FALSE, FALSE}
                            };
    PDWORD      pdwTagNum = NULL,
                pdwTagType = NULL;

    WCHAR       wszName[MAX_STRING_LEN] = {L'\0'};
    BOOL        fEndChar = FALSE;

    CHAR        ch16thChar = 0x00;
    BOOL        fScope = FALSE;
    WCHAR       wszScope[MAX_STRING_LEN] = {L'\0'};
    LPSTR       pszTempName = NULL;
    DWORD       dwTempNameLen = 0;
    
    DWORD       dwStrLen = 0;
    LPWSTR      pwszTemp = NULL;
    WINSINTF_RECORD_ACTION_T    RecAction = {0};
    PWINSINTF_RECORD_ACTION_T   pRecAction = NULL;

    memset(&RecAction, 0x00, sizeof(WINSINTF_RECORD_ACTION_T));
    RecAction.fStatic = FALSE;

    //Must provide at least the record name and endchar
    if( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_NAME_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //Start processing the arguments based on ppwcArguments, dwArgCount and dwCurrentIndex
    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    i = dwTagCount;
    for( j=0; j<i; j++ )
    {
        switch(pdwTagType[j])
        {
        //Record Name
        case 0:
            {
                DWORD dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dwLen = ( 255 < dwLen ) ? 255 : dwLen;
                memcpy(wszName, 
                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 
                       dwLen*sizeof(WCHAR));
                wszName[dwLen] = L'\0';               
                break;
            }
        //Endchar
        case 1:
            {   
                DWORD dwLen = 0, k=0;
                fEndChar = TRUE;
                dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen > 2 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                        
                }
                
                for( k=0; k<dwLen; k++ )
                {
                    WCHAR  wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][k];
                    if( towlower(wc) >= L'a' and
                        towlower(wc) <= L'z' )
                    {
                        if( towlower(wc) > L'f' )
                        {
                            Status = ERROR_INVALID_PARAMETER;
                            goto ErrorReturn;
                        }
                    }
                }                

                ch16thChar = StringToHexA(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);

                break;
            }
        //Scope 
        case 2:
            {
                DWORD dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                fScope = TRUE;
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dwLen = ( 255 < dwLen ) ? 255 : dwLen;
                memcpy(wszScope,
                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 
                       dwLen*sizeof(WCHAR));
                wszScope[dwLen] = L'\0';               
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
    
     
    _wcsupr(wszName);
    _wcsupr(wszScope);

    pszTempName = WinsUnicodeToOem(wszName, NULL);

    if( pszTempName is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwStrLen = strlen(pszTempName);
    
    if( dwStrLen >= 16 )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_NETBIOS_NAME);
        Status = ERROR_INVALID_PARAMETER;
        WinsFreeMemory(pszTempName);
        pszTempName = NULL;
        goto ErrorReturn;
    }    
    
    RecAction.pName = WinsAllocateMemory(273);

    if( RecAction.pName is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    strncpy(RecAction.pName, pszTempName, dwStrLen);
    
    WinsFreeMemory(pszTempName);
    pszTempName = NULL;

    for( i=dwStrLen; i < 16; i++ )
    {
        RecAction.pName[i] = ' ';
    }

    if( fEndChar )
    {
        if( ch16thChar is 0x00 )
        {
            RecAction.pName[15] = 0x00;
        }
        else
        {           
            RecAction.pName[15] = ch16thChar;
        }

    }
    
    RecAction.pName[16] = '\0';
    
    dwStrLen = 16;

    if( fScope )
    {
        DWORD dwLen = 0;

        RecAction.pName[dwStrLen] = '.';
        pszTempName = WinsUnicodeToOem(wszScope, NULL);
        if( pszTempName is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        dwLen = strlen(pszTempName);
        dwLen = ( 255 - dwStrLen < dwLen ) ? 255 - dwStrLen : dwLen;

        strncpy(RecAction.pName + dwStrLen + 1, pszTempName, dwLen);
        WinsFreeMemory(pszTempName);
        pszTempName = NULL;
        RecAction.pName[dwLen + dwStrLen + 1] = '\0';
        if( fEndChar and 
            ch16thChar is 0x00 )
            dwStrLen = 16+dwLen+1;
        else
            dwStrLen = strlen(RecAction.pName);
    }
    else
    {

        RecAction.pName[dwStrLen] = '\0';
    }

    RecAction.NameLen = dwStrLen;

    RecAction.Cmd_e = WINSINTF_E_QUERY;

    RecAction.OwnerId = StringToIpAddress(g_ServerIpAddressUnicodeString);
   
    RecAction.NameLen = dwStrLen;
    pRecAction = &RecAction;

    Status = WinsRecordAction(g_hBind, &pRecAction);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    RecAction.Cmd_e      = WINSINTF_E_DELETE;
    
    RecAction.State_e      = WINSINTF_E_DELETED;   

    pRecAction = &RecAction;

    Status = WinsRecordAction(g_hBind, &pRecAction);
    
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pszTempName )
    {
        WinsFreeMemory(pszTempName);
        pszTempName = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    
    if( RecAction.pName )
    {
        WinsFreeMemory(RecAction.pName);
        RecAction.pName = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_DELETE_NAME, Status);
    goto CommonReturn;

    return NO_ERROR;
}


DWORD
HandleSrvrDeletePartner(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Delete a partner from the WINS server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Confirmation
        Optional : Server IP and Type.
        Note : If no ip is provided, it deletes all partners in the list.
               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    
    TAG_TYPE    pttTags[] = { 
                                {WINS_TOKEN_SERVER, FALSE, FALSE},
                                {WINS_TOKEN_TYPE, FALSE, FALSE},
                                {WINS_TOKEN_CONFIRM, TRUE, FALSE},
                            };
    WCHAR       wcServerIpAdd[MAX_IP_STRING_LEN + 1] = {L'\0'};
    DWORD       dwIpLen = (MAX_IP_STRING_LEN+1);
    BOOL        fPull = TRUE,
                fPush = TRUE,
                fConfirm = FALSE;

    HKEY        hServer = NULL,
                hPartner = NULL;

    LPWSTR      pTemp = NULL;

    //Must provide the confirmation in order for this to succeed.
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_DELETE_PARTNER_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    //Start processing the arguments based on ppwcArguments, dwCurrentIndex and dwArgCount
    else
    {
        dwNumArgs = dwArgCount - dwCurrentIndex;

        pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
        pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

        if( pdwTagType is NULL or
            pdwTagNum is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

        Status = PreProcessCommand(ppwcArguments,
                                   dwArgCount,
                                   dwCurrentIndex,
                                   pttTags,
                                   &dwTagCount,
                                   pdwTagType,
                                   pdwTagNum);
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
        {
            if( pttTags[i].dwRequired is TRUE and
                pttTags[i].bPresent is FALSE 
              )
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }

        for( j=0; j<dwTagCount; j++ )
        {
            switch(pdwTagType[j])
            {
            //Server Ip
            case 0:
                {
                    struct  hostent * lpHostEnt = NULL;
                    CHAR    cAddr[16];
                    BYTE    pbAdd[4];
                    char    szAdd[4];
                    int     k = 0, l=0;
                    DWORD   dwLen, nLen = 0;
                    CHAR    *pTemp = NULL;
                    CHAR    *pNetBios = NULL;
                    
                    if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) is FALSE )
                    {
                        Status = ERROR_INVALID_IPADDRESS;
                        goto ErrorReturn;
                    }

                    wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    break;

                }
            //Partner Type
            case 1:
                {
                    DWORD dw = 0;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }                    

                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                    switch(dw)
                    {
                    case 0:
                        {
                            fPull = TRUE;
                            fPush = FALSE;
                            break;
                        }
                    case 1:
                        {
                            fPull = FALSE;
                            fPush = TRUE;
                            break;
                        }
                    case 2:
                        {
                            fPull = TRUE;
                            fPush = TRUE;
                            break;
                        }
                    default:
                        {
                            Status = ERROR_INVALID_PARAMETER;
                            break;
                        }
                    }
                    break;
                }
            //Confirmation
            case 2 :
                {
                    if( 0 is _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"Y", 1) )
                        fConfirm = TRUE;
                    else if ( 0 is _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"N", 1) )
                        fConfirm = FALSE;
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    break;

                }
            default:
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
            }
        }
    }

    if( fConfirm is FALSE )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_CONFIRMATION_DENIED);
        goto CommonReturn;
    }

    {
        if( wcslen(g_ServerNetBiosName) > 0 )
        {
            pTemp = g_ServerNetBiosName;
        }
        
        Status = RegConnectRegistry(pTemp,
                                    HKEY_LOCAL_MACHINE,
                                    &hServer);

        if( Status isnot ERROR_SUCCESS )
            goto ErrorReturn;

        //PullPartners
        if( fPull )
        {
            Status = RegOpenKeyEx(hServer,
                                  PULLROOT,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hPartner);
            if( Status isnot NO_ERROR )
            {
                if (Status == ERROR_FILE_NOT_FOUND)
                    Status = NO_ERROR;

                goto PUSH;
            }
            
            if( wcslen(wcServerIpAdd) < 3 )//not a valid Ip, delete all partners
            {
     
                while(TRUE)
                {
                    Status = RegEnumKeyEx(hPartner, 0, wcServerIpAdd, &dwIpLen, NULL, NULL, NULL, NULL);
                    if (Status != ERROR_SUCCESS)
                        break;
                    RegDeleteKey(hPartner, wcServerIpAdd);
                    dwIpLen = (MAX_IP_STRING_LEN + 1)*sizeof(WCHAR);
                    memset(wcServerIpAdd, L'\0', MAX_IP_STRING_LEN+1);
                }
            }
            else
            {
                RegDeleteKey(hPartner,
                             wcServerIpAdd);
            }

            if( hPartner )
            {
                RegCloseKey(hPartner);
                hPartner = NULL;
            }

            if( Status is ERROR_NO_MORE_ITEMS )
            {
                Status = NO_ERROR;
                goto PUSH;
            }
            
            if( Status is ERROR_FILE_NOT_FOUND )
            {
                DisplayMessage(g_hModule,
                               EMSG_INVALID_PARTNER_NAME);
                if( fPush )
                    goto PUSH;
                else
                    goto CommonReturn;
            }
            if( Status isnot NO_ERROR )
            {
                if( fPush )
                    goto PUSH;
                else
                    goto CommonReturn;
            }


        }
        //Push Partner
PUSH:   if( fPush )
        {
            Status = RegOpenKeyEx(hServer,
                                  PUSHROOT,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hPartner);

            if (Status is ERROR_FILE_NOT_FOUND)
            {
                DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
                goto CommonReturn;
            }

            if( Status isnot NO_ERROR )
                goto ErrorReturn;
    
            dwIpLen = (MAX_IP_STRING_LEN + 1);
            if( wcslen(wcServerIpAdd) < 3 )//not a valid Ip, delete all partners
            {
                while( TRUE )
                {
                    Status = RegEnumKeyEx(hPartner, 0, wcServerIpAdd, &dwIpLen, NULL, NULL, NULL, NULL);
                    if (Status != ERROR_SUCCESS)
                        break;
                    RegDeleteKey(hPartner, wcServerIpAdd);
                    dwIpLen = (MAX_IP_STRING_LEN + 1)*sizeof(WCHAR);
                }
            }
            else
            {
                RegDeleteKey(hPartner,
                             wcServerIpAdd);
            }

            if( Status is ERROR_NO_MORE_ITEMS )
            {
                Status = NO_ERROR;
            }

            if( Status is ERROR_FILE_NOT_FOUND )
            {
                DisplayMessage(g_hModule,
                               EMSG_INVALID_PARTNER_NAME);
                goto ErrorReturn;
            }

            if( Status isnot NO_ERROR )
                goto ErrorReturn;
            
            if( hPartner )
            {
                RegCloseKey(hPartner);
                hPartner = NULL;
            }
        }
    }    



    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    else
        goto ErrorReturn;

CommonReturn:


    if( hPartner )
    {
        RegCloseKey(hPartner);
        hPartner = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_DELETE_PARTNER, Status);
    goto CommonReturn;
}

DWORD
HandleSrvrDeleteRecords(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Delete or Tombstone records from a WINS server based on the version
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Minimum and Maximum version numbers( range of version ) to be 
                     deleted/tombstoned
        Optional : Operation - tombstone(default) or delete
               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount = 0;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_MINVER, TRUE, FALSE},
                                {WINS_TOKEN_MAXVER, TRUE, FALSE},
                                {WINS_TOKEN_OP, FALSE, FALSE},
                            };
    BOOL        fDelete = TRUE;
    WINSINTF_VERS_NO_T  MinVer, MaxVer;
    WINSINTF_ADD_T      WinsAdd;
    LPWSTR              pwszTemp = NULL;

    //Needs at least both Min Ver and Max ver
    if( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_RECORDS_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //Start processing the arguments based on ppwcArguments, dwCurrentIndex and dwArgCount
    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    if( pdwTagType is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    if( pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }
        
    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    i = dwTagCount;

    for( j=0; j<i; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0://{high,low} format, Min version
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MinVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }
        case 1://{high,low} format, Max version
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MaxVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }
        case 2: //Operation 0 - delete 1 - Tombstone
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                if( dw is 0 )
                    fDelete = TRUE;
                else if( dw is 1 )
                    fDelete = FALSE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        
        }
    }

    WinsAdd.IPAdd = StringToIpAddress(g_ServerIpAddressUnicodeString);
    WinsAdd.Len = 4;
    WinsAdd.Type = 0;

    if( fDelete )
    {
        Status = WinsDelDbRecs(g_hBind, &WinsAdd, MinVer, MaxVer);
    }
    else
    {
        Status = WinsTombstoneDbRecs(g_hBind, &WinsAdd, MinVer, MaxVer);
    }
    if( Status isnot NO_ERROR )
        goto ErrorReturn;
CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_DELETE_RECORDS,
                        Status);
    goto CommonReturn;
}                  


DWORD
HandleSrvrDeleteWins(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Delete a partner from the WINS server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Confirmation
        Optional : Server IP and Type.
        Note : If no ip is provided, it deletes all partners in the list.
               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD                   Status = NO_ERROR;
    DWORD                   i, j, dwNumArgs, dwTagCount;
    TAG_TYPE                pttTags[] = {
                                            {WINS_TOKEN_SERVERS, TRUE, FALSE},
                                            {WINS_TOKEN_OP, FALSE, FALSE},
                                        };
    DWORD                   dwIpCount = 0;
    LPDWORD                 pdwIp = NULL,
                            pdwTagType = NULL,
                            pdwTagNum = NULL;
                    
    BOOL                    fDelete = FALSE;

    WINSINTF_ADD_T          WinsAdd;
    handle_t                hBind;
    WINSINTF_BIND_DATA_T    BindData;
    
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, 
                       HLP_SRVR_DELETE_WINS_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;

    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }


    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                LPWSTR  pszIps = NULL;
                DWORD   dwIpLen = 0;
                LPWSTR  pTemp = NULL;
                DWORD   dwIp = 0;
                
                dwIpCount = 0;

               
                dwIpLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
    
                if( dwIpLen < 2 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                pszIps = WinsAllocateMemory((dwIpLen+1)*sizeof(WCHAR));
                if( pszIps is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(pszIps, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                
                if( pszIps[0] isnot L'{' or 
                    pszIps[dwIpLen-1] isnot L'}')
                {
                    Status = ERROR_INVALID_PARAMETER;
                    if( pszIps )
                    {
                        WinsFreeMemory(pszIps);
                        pszIps = NULL;
                    }
                    goto ErrorReturn;
                }
                
                pTemp = pszIps+1;                               
                pszIps[dwIpLen-1] = L'\0';

                pTemp = wcstok(pTemp, L",");
                
                while(pTemp isnot NULL)
                {
                    PDWORD  pdwTemp = NULL;
                    dwIpCount++;
                    pdwTemp = WinsAllocateMemory(dwIpCount*sizeof(DWORD));
                    if( pdwTemp is NULL )
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        if( pszIps )
                        {
                            WinsFreeMemory(pszIps);
                            pszIps = NULL;
                        }
                        goto ErrorReturn;
                    }
                    if( pdwIp )
                    {
                        memcpy(pdwTemp, pdwIp, (dwIpCount-1)*sizeof(DWORD));
                        WinsFreeMemory(pdwIp);
                        pdwIp = NULL;
                    }
                    
                    dwIp = StringToIpAddress(pTemp);

                    if( dwIp is INADDR_NONE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        if( pszIps )
                        {
                            WinsFreeMemory(pszIps);
                            pszIps = NULL;
                        }
                        
                        if( pdwTemp )
                        {
                            WinsFreeMemory(pdwTemp);
                            pdwTemp = NULL;
                        }

                        goto ErrorReturn;
                    }
                    pdwTemp[dwIpCount-1] = dwIp;
                    pdwIp = pdwTemp;
                    pTemp = wcstok(NULL, L",");
                }
                if( pszIps )
                {
                    WinsFreeMemory(pszIps);
                    pszIps = NULL;
                }
                break;
            }
        case 1:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 10);
                if( dw is 0 )
                {
                    fDelete = FALSE;
                    break;
                }
                else if( dw is 1 )
                {
                    fDelete = TRUE;
                    break;
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            
        }
    }
    

    for( i=0; i<dwIpCount; i++ )
    {
        WinsAdd.Len = 4;
        WinsAdd.Type = 0;
        WinsAdd.IPAdd = pdwIp[i];

        if( fDelete is TRUE )
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_DELETING_RECORD,
                           IpAddressToString(pdwIp[i]));

            Status = WinsDeleteWins(g_hBind, 
                                    &WinsAdd);
        }
        else
        {
            WINSINTF_RESULTS_T  Results;
            WINSINTF_VERS_NO_T	MinVer;
	        WINSINTF_VERS_NO_T	MaxVer;
            
            MaxVer.HighPart = 0;
            MaxVer.LowPart = 0;
            MinVer.HighPart = 0;
            MinVer.LowPart = 0;

            DisplayMessage(g_hModule,
                           MSG_WINS_TOMBSTONE_RECORD,
                           IpAddressToString(pdwIp[i]));


            Status = WinsTombstoneDbRecs(g_hBind,
                                         &WinsAdd,
                                         MinVer,
                                         MaxVer);
        }
        if( Status isnot NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_OPERATION_FAILED,
                           IpAddressToString(pdwIp[i]));

            DisplayErrorMessage(EMSG_SRVR_ERROR_MESSAGE,
                                Status);
                           
            continue;
        }


    }

    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_ERROR_SUCCESS);
    }

CommonReturn:

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( pdwIp )
    {
        WinsFreeMemory(pdwIp);
        pdwIp = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_DELETE_WINS,
                        Status);
    goto CommonReturn;
}


DWORD
HandleSrvrDeletePersona(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Delete one or all PNG servers from the list of PNG servers
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : A list of server IP Address separated by commas and 
                     enclosed by {}. If no server address is provided within {}
                     it will delete all PNG servers.              
Return Value:
        Returns the status of the operation.

--*/
{   
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwTagCount, dwNumArgs;
    HKEY        hServer = NULL,
                hPartner = NULL;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_SERVERS,TRUE, FALSE},
                            };

    LPBYTE      pbData = NULL,
                pbValue = NULL;
    DWORD       dwSize = 0,
                dwType = 0,
                dwCount = 0,
                dwTemp = 0;
    
    LPWSTR      pTemp = NULL,
                pwszPng = NULL;
    DWORD       dwTagType = 1,
                dwTagNum = 1,
                dwLenCount = 0,
                dwPngIp = 0;
    
    LPDWORD     pdwPngIp = NULL;
    BOOL        fAtleastone = FALSE;
    BOOL        fGrata;

    fGrata = (wcsstr(CMD_SRVR_DELETE_PNGSERVER, ppwcArguments[dwCurrentIndex-1]) == NULL);

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, fGrata ? HLP_SRVR_DELETE_PGSERVER_EX : HLP_SRVR_DELETE_PNGSERVER_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               &dwTagType,
                               &dwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    if( pttTags[0].bPresent is FALSE )
    {
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( wcslen(g_ServerNetBiosName) > 0 )
        pTemp = g_ServerNetBiosName;

    Status = RegConnectRegistry(pTemp,
                                HKEY_LOCAL_MACHINE,
                                &hServer);

    if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    Status = RegOpenKeyEx(hServer,
                          PARTNERROOT,
                          0,
                          KEY_ALL_ACCESS,
                          &hPartner);

    
    if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    if (!CheckValidPgOp(hPartner, fGrata))
    {
        DisplayMessage(g_hModule, fGrata ? EMSG_SRVR_PG_INVALIDOP : EMSG_SRVR_PNG_INVALIDOP);
        Status = ERROR_INVALID_PARAMETER;
        goto CommonReturn;
    }

    Status = RegQueryValueEx(hPartner,
                             fGrata ? PGSERVER : PNGSERVER,
                             NULL,
                             &dwType,
                             NULL,
                             &dwSize);

    if( Status isnot NO_ERROR && Status isnot ERROR_FILE_NOT_FOUND)
        goto ErrorReturn;

    if( dwSize < 7 )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_ERROR_SUCCESS);
        goto CommonReturn;
    }
    
    pbData = WinsAllocateMemory(dwSize);
    

    if( pbData is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    Status = RegQueryValueEx(hPartner,
                             fGrata ? PGSERVER : PNGSERVER,
                             NULL,
                             &dwType,
                             pbData,
                             &dwSize);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    pwszPng = (LPWSTR)pbData;

    for( i=0; i<(dwSize+2)/sizeof(WCHAR); i++ )
    {
        if( pwszPng[i] is L'\0' and
            pwszPng[i+1] isnot L'\0')
        {
            pwszPng[i] = L',';
            i++;
        }
    }

    dwPngIp = 0;
    dwCount = 0;
    pTemp = wcstok(pwszPng, L",");
    
    while((pTemp isnot NULL) && (dwLenCount+sizeof(WCHAR)*7<dwSize))
    {
        LPDWORD     pdwTemp = pdwPngIp;
        
        dwPngIp++;
        
        dwLenCount += wcslen(pTemp)*sizeof(WCHAR);
        pdwPngIp = WinsAllocateMemory(dwPngIp*sizeof(DWORD));

        if( pdwPngIp is NULL )
        {
            WinsFreeMemory(pdwTemp);
            pdwTemp = NULL;
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        if( pdwTemp isnot NULL )
        {
            memcpy(pdwPngIp, pdwTemp, (dwPngIp-1)*sizeof(DWORD));
            WinsFreeMemory(pdwTemp);
            pdwTemp = NULL;
        }
        
        pdwPngIp[dwPngIp-1] = StringToIpAddress(pTemp);

        pTemp = wcstok(NULL, L","); 
        dwLenCount+=sizeof(WCHAR);
    }


    //Now parse the data
    {
        LPWSTR      pwszTemp = NULL;
        DWORD dwLen = wcslen(ppwcArguments[dwCurrentIndex]);
        
        if( ppwcArguments[dwCurrentIndex][0] isnot L'{' or
            ppwcArguments[dwCurrentIndex][dwLen-1] isnot L'}' )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        if( dwLen < 7 )
        {
            BYTE    rgbByte[] = {0x00, 0x00, 0x00, 0x00};
            
            Status = RegSetValueEx(hPartner,
                                   fGrata ? PGSERVER : PNGSERVER,
                                   0,
                                   REG_MULTI_SZ,
                                   rgbByte,
                                   sizeof(rgbByte));

            if( Status isnot NO_ERROR )
                goto ErrorReturn;

            fAtleastone = TRUE;

            DisplayMessage(g_hModule,
                           EMSG_WINS_ERROR_SUCCESS);
            goto CommonReturn;

        }

        pwszTemp = WinsAllocateMemory((dwLen-1)*sizeof(WCHAR));

        if( pwszTemp is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        wcsncpy(pwszTemp, ppwcArguments[dwCurrentIndex]+1, dwLen-1);
        pwszTemp[dwLen-2] = L'\0';
        
        pTemp = wcstok(pwszTemp, L",");
        
        dwCount = 0;

        while(pTemp isnot NULL )
        {
            DWORD   dw = StringToIpAddress(pTemp);
            BOOL fPresent = TRUE;
            if( dw is INADDR_NONE )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_INVALID_IPADDRESS,
                               pTemp);
            }
            else
            {
                for( i=0; i<dwPngIp; i++ )
                {

                    if( dw is pdwPngIp[i] )
                    {
                        LPDWORD pdwTemp = pdwPngIp;
            
                        pdwPngIp = WinsAllocateMemory((dwPngIp-1)*sizeof(DWORD));

                        if( pdwPngIp is NULL )
                        {
                            WinsFreeMemory(pdwTemp);
                            pdwTemp = NULL;
                            WinsFreeMemory(pwszTemp);
                            pwszTemp = NULL;
                            Status = ERROR_NOT_ENOUGH_MEMORY;
                            goto ErrorReturn;
                        }
                        fAtleastone = TRUE;
                        memcpy(pdwPngIp, pdwTemp, i*sizeof(DWORD));
                        for( j=i+1; j<dwPngIp; j++ )
                        {
                            pdwPngIp[j-1] = pdwTemp[j];
                        }
                        dwPngIp--;                    
                        break;
                    }
                    else
                        continue;
                }
            }
            
            pTemp = wcstok(NULL, L",");
        }
        
        dwTemp += 0;

        pbValue = WinsAllocateMemory((dwPngIp*(MAX_IP_STRING_LEN+1)+1)*sizeof(WCHAR));
        if( pbValue is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
                    
        pTemp = (LPWSTR)pbValue;

        for( i=0; i<dwPngIp; i++ )
        {
            LPWSTR  pwIp = NULL;

            pwIp = IpAddressToString(pdwPngIp[i]);
            if( pwIp is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            wcscpy(pTemp+dwTemp, pwIp);
            dwTemp+=wcslen(pwIp);
            dwTemp++;
            WinsFreeMemory(pwIp);
            pwIp = NULL;
        }

        pTemp[dwTemp++] = L'\0';
        
    }
    
    Status = RegSetValueEx(hPartner,
                           fGrata ? PGSERVER : PNGSERVER,
                           0,
                           REG_MULTI_SZ,
                           pbValue,
                           dwTemp*sizeof(WCHAR));

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    if( fAtleastone is FALSE )
    {
        DisplayMessage(g_hModule,
                            fGrata ? EMSG_SRVR_ATLEAST_ONE_PG : EMSG_SRVR_ATLEAST_ONE_PNG);
    }
    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);

CommonReturn:

    if( pbData )
    {
        WinsFreeMemory(pbData);
        pbData = NULL;
    }

    if( pbValue )
    {
        WinsFreeMemory(pbValue);
        pbValue = NULL;
    }

    if( pdwPngIp )
    {
        WinsFreeMemory(pdwPngIp);
        pdwPngIp = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( hPartner )
    {
        RegCloseKey(hPartner);
        hPartner = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(fGrata ? EMSG_SRVR_DELETE_PGSERVER : EMSG_SRVR_DELETE_PNGSERVER,
                        Status);
    goto CommonReturn;
    
}


DWORD
HandleSrvrInitBackup(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiates a backup operation of WINS Server database.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Optional : Backup directory. If none is specified, it will assume the 
                   the default directory.             
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwNumTags = NULL, pdwTypeTags = NULL;
    LPSTR       pszBackupPath = NULL;
    LPWSTR      pwszTemp = NULL;
    BOOL        fIncremental = FALSE;
    LPBYTE      lpStr = NULL;
    TAG_TYPE    pttTags[] = { {WINS_TOKEN_DIR, FALSE, FALSE},
                              {WINS_TOKEN_TYPE, FALSE, FALSE},
                            };
    
       
    if( dwArgCount > dwCurrentIndex )
    {
        dwNumArgs = dwArgCount - dwCurrentIndex;

        pdwNumTags = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

        if( pdwNumTags is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        pdwTypeTags = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

        if( pdwTypeTags is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

        Status = PreProcessCommand(ppwcArguments,
                                   dwArgCount,
                                   dwCurrentIndex,
                                   pttTags,
                                   &dwTagCount,
                                   pdwTypeTags,
                                   pdwNumTags);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
        {
            if( pttTags[i].dwRequired is TRUE and
                pttTags[i].bPresent is FALSE 
              )
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }

        i = dwTagCount;

        for( j = 0; j < i ; j++ )
        {
            switch(pdwTypeTags[j])
            {
            case 0:
                {
                    pszBackupPath = WinsUnicodeToOem(ppwcArguments[dwCurrentIndex+pdwNumTags[j]], NULL);

                    if( pszBackupPath is NULL )
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }
                    break;
                }
            case 1:
                {
                    DWORD dwType = 0;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwNumTags[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }                    
                    dwType = STRTOUL(ppwcArguments[dwCurrentIndex+pdwNumTags[j]], NULL, 0);
                    if( dwType is 0 )
                        fIncremental = FALSE;
                    else if( dwType is 1 )
                        fIncremental = TRUE;
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }

                    break;
                }
            default:
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
            }
        }
    }
    if( pszBackupPath is NULL ) //Look for the previously set backup path from Registry
    {
        HKEY    hServer = NULL,
                hParameter = NULL;
        WCHAR   wcTempSrc[1024] = {L'\0'},
                wcTempDst[1024] = {L'\0'};
        LPSTR   pszTempPath = NULL;
        DWORD   dwType = REG_EXPAND_SZ,
                dwTempLen = 1024*sizeof(WCHAR);

        if( wcslen(g_ServerNetBiosName) > 0 )
            pwszTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pwszTemp,
                                    HKEY_LOCAL_MACHINE,
                                    &hServer);
        if( Status isnot NO_ERROR )
        {
            goto ErrorReturn;
        }

        Status = RegOpenKeyEx(hServer,
                              PARAMETER,
                              0,
                              KEY_ALL_ACCESS,
                              &hParameter);

        if( Status isnot NO_ERROR )
        {
            RegCloseKey(hServer);
            hServer = NULL;
            goto ErrorReturn;
        }

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_BACKUP_DIR_PATH_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)wcTempSrc,
                                 &dwTempLen);

        RegCloseKey(hParameter);
        hParameter = NULL;
        RegCloseKey(hServer);
        hServer = NULL;

        if( Status is ERROR_FILE_NOT_FOUND or
            wcslen(wcTempSrc) is 0 )
        {
            DisplayMessage(g_hModule,
                           EMSG_SRVR_NOBACKUP_PATH);
            Status = ERROR_INVALID_PARAMETER;
            goto CommonReturn;
        }
        if( Status isnot NO_ERROR )
        {
            goto ErrorReturn;
        }

        dwTempLen =  ExpandEnvironmentStrings(wcTempSrc,
                                              wcTempDst,
                                              1024);

        if( dwTempLen is 0 )
        {
            goto ErrorReturn;
        }

        pszTempPath = WinsUnicodeToOem(wcTempDst, NULL);
        
        if( pszTempPath is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        
        dwTempLen = MAX(dwTempLen, strlen(pszTempPath));

        pszBackupPath = WinsAllocateMemory(dwTempLen+1);

        if( pszBackupPath is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        strcpy(pszBackupPath, pszTempPath);

        WinsFreeMemory(pszTempPath);
        pszTempPath = NULL;
    }
    
    if( pszBackupPath[strlen(pszBackupPath) - 1] is '\\' )
    {
        pszBackupPath[strlen(pszBackupPath) - 1] = '\0';
    } 
    Status = WinsBackup(g_hBind,
                       (LPBYTE)pszBackupPath,
                       (short)fIncremental);
 

    if( Status isnot NO_ERROR )
        goto ErrorReturn;
                                
CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    
    if( pdwTypeTags )
    {
        WinsFreeMemory(pdwTypeTags);
        pdwTypeTags = NULL;
    }
    if( pdwNumTags )
    {
        WinsFreeMemory(pdwNumTags);
        pdwNumTags = NULL;
    }
    if( pszBackupPath )
    {
        WinsFreeMemory(pszBackupPath);
        pszBackupPath = NULL;
    }
   
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_INIT_BACKUP,
                        Status);
    goto CommonReturn;   
}



DWORD
HandleSrvrInitImport(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiates import of records from LMHOSTS file.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Lmhosts file name.             
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_FILE, TRUE, FALSE},
                            };
    
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    LPWSTR      pwszFileName = NULL;
    WCHAR       wcTemp[2042] = {L'\0'};    

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_INIT_IMPORT_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                DWORD dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                pwszFileName = WinsAllocateMemory((dwLen+1)*sizeof(WCHAR));
                if( pwszFileName is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(pwszFileName, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
	if( pwszFileName )
    {
        //
        // If this is a local connection, we copy the file to
        // temporary name (the source may be on a remote drive
        // which is not accessible to the WINS service.
        //
        // If this is not a local connection, attempt to copy
        // the file to a temp name on C$ of the WINS server
        //

    	do
        {
            if (IsLocalServer())
            {
                wcscpy(wcTemp ,_wtempnam(NULL, L"WINS"));
                //
                // First copy file to a temporary name (since the file
                // could be remote), and then import and delete this file
                //
                if (!CopyFile(pwszFileName, wcTemp, TRUE) ||
                    !SetFileAttributes(wcTemp,FILE_ATTRIBUTE_NORMAL))
                {
                    Status = GetLastError();
                    break;
                }
                //
                // Now import the temporary file, and delete the file
                // afterwards.
                //
                Status = ImportStaticMappingsFile(wcTemp, TRUE);
                DeleteFile(wcTemp);
            }
            else
            {
                //
                // Try copying to the remote machine C: drive
                //
                wcscat(wcTemp, L"\\\\");
                wcscat(wcTemp, g_ServerNameUnicode);
                wcscat(wcTemp, L"\\");
                wcscat(wcTemp, L"C$");
                wcscat(wcTemp, L"\\");
                wcscat(wcTemp, L"WINS");
                j = wcslen(wcTemp);

                i=0;
                while (TRUE)
                {
                    WCHAR Buffer[10] = {L'\0'};
                    DWORD  dwErr = 0;
                    _itow(i, Buffer, 10);
		            wcscat(wcTemp,Buffer);

                    if (GetFileAttributes(wcTemp) == -1)
                    {
                        dwErr = GetLastError();
                        if (dwErr is ERROR_FILE_NOT_FOUND)
                        {
			            	break;
                        }
                    }
                    wcTemp[j] = L'\0';
                    i++;                        
                }
    
                //
                // First copy file to a temporary name (since the file
                // could be remote), and then import and delete this file
                //
                if (!CopyFile(pwszFileName, wcTemp, TRUE) ||
                    !SetFileAttributes(pwszFileName, FILE_ATTRIBUTE_NORMAL))
                {
                    Status = GetLastError();
                    break;
                }

                //
                // Now import the temporary file, and delete the file
                // afterwards.
                //
                Status = ImportStaticMappingsFile(wcTemp, TRUE);
                DeleteFile(wcTemp);
            }
        }while(FALSE);

        if (Status isnot NO_ERROR )
        {
            goto ErrorReturn;
        }

	}

CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pwszFileName )
    {
        WinsFreeMemory(pwszFileName);
        pwszFileName = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;

ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_INIT_IMPORT,
                        Status);
    goto CommonReturn;
}

DWORD
HandleSrvrInitPull(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiates and send pull trigger to the specified pull partner.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Server Ip Address
               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    WINSINTF_ADD_T  WinsAdd;
    DWORD       i, j, dwNumArgs, dwTagCount = 0;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                            };
    LPWSTR      pwszTemp = NULL;

    if( dwArgCount < dwCurrentIndex+1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_INIT_PULL_EX);
        Status = ERROR_INVALID_PARAMETER;                     
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if(pdwTagType is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    if(pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }


    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    i = dwTagCount;

    for( j=0; j<i; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WinsAdd.Len = 4;
                WinsAdd.Type = 0;
                
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                if( IsIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) )
                {
                    WinsAdd.IPAdd = StringToIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    break;
                }
                else //Server UNC name
                {
                    struct  hostent * lpHostEnt = NULL;
                    CHAR    cAddr[16];
                    BYTE    pbAdd[4];
                    char    szAdd[4];
                    int     k = 0, l=0;
                    DWORD   nLen = 0;

                    if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 2 and
                        _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"\\\\", 2) is 0 )
                        k = 2;
                        
                    lpHostEnt = gethostbyname(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k, NULL));
                    if( lpHostEnt is NULL )
                    {
                        DisplayMessage(g_hModule,
                                       EMSG_WINS_INVALID_COMPUTER_NAME,
                                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k);
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;                                       
                    }

                    memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
                    for( l=0;l<4; l++)
                    {
                        _itoa((int)pbAdd[l], szAdd, 10);
                        memcpy(cAddr+nLen, szAdd, strlen(szAdd));
                        nLen += strlen(szAdd);
                        *(cAddr+nLen) = '.';
                        nLen++;
    
                    }
                    *(cAddr+nLen-1) = '\0';
                    WinsAdd.IPAdd = WinsDottedStringToIpAddress(cAddr);
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    for( j=0; j<sizeof(pttTags)/sizeof(TAG_TYPE); j++)
    {
        if( pttTags[j].dwRequired is TRUE &&
            pttTags[j].bPresent is FALSE )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_REQUIRED_PARAMETER,
                           j);
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
                           
        }
    }

    Status = WinsTrigger(g_hBind, &WinsAdd, WINSINTF_E_PULL);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_INIT_PULL,
                        Status);
    goto CommonReturn;

}


DWORD
HandleSrvrInitPullrange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiates and pulls a range of database from a particular server.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Pulls a range of database from a particular server owned by
                     a particular server within the given version range.
        Note : If no ip is provided, it deletes all partners in the list.
               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD               Status = NO_ERROR;
    DWORD               i, j, dwTagCount, dwNumArgs;
    TAG_TYPE            pttTags[] = {
                                        {WINS_TOKEN_OWNER, TRUE, FALSE},
                                        {WINS_TOKEN_SERVER, TRUE, FALSE},
                                        {WINS_TOKEN_MAXVER, TRUE, FALSE},
                                        {WINS_TOKEN_MINVER, TRUE, FALSE},
                                    };

    LPDWORD             pdwTagType = NULL,
                        pdwTagNum = NULL;

    WINSINTF_VERS_NO_T  MinVer, MaxVer;
    WINSINTF_ADD_T      PullAdd, OwnerAdd ;

        
    
    if( dwArgCount < dwCurrentIndex + 4 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_INIT_PULLRANGE_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or 
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);


    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( j=0; j<sizeof(pttTags)/sizeof(TAG_TYPE); j++ )
    {
        if( pttTags[j].dwRequired is TRUE and
            pttTags[j].bPresent is FALSE )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                if( IsIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                OwnerAdd.IPAdd = StringToIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                OwnerAdd.Type = 0;
                OwnerAdd.Len = 4;
                break;
            }
        case 1:
            {
                if( IsIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                PullAdd.IPAdd = StringToIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                PullAdd.Type = 0;
                PullAdd.Len = 4;
                break;
            }
        case 2:
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MaxVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;    
            }
        case 3:
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MinVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }

    }

    Status = WinsPullRange(g_hBind, &PullAdd, &OwnerAdd, MinVer, MaxVer);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);

CommonReturn:

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_INIT_PULLRANGE,
                        Status);
    goto CommonReturn;
                        
}


DWORD
HandleSrvrInitPush(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiate and sends push trigger to a particular Push partner.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Push partner's IP Address
        Optional : If user wants to propagate the push trigger               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    WINSINTF_ADD_T  WinsAdd;
    DWORD       i, j, dwNumArgs, dwTagCount=0;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                                {WINS_TOKEN_PROPAGATION, FALSE, FALSE},
                            };
    LPWSTR      pwszTemp = NULL;
    DWORD       dwChoice = WINSINTF_E_PUSH;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_INIT_PUSH_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if(pdwTagType is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    if(pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }


    i = dwTagCount;

    for( j=0; j<i; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WinsAdd.Len = 4;
                WinsAdd.Type = 0;

                if( IsIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) )
                {
                    WinsAdd.IPAdd = StringToIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                }
                else //Server UNC name
                {
                    struct  hostent * lpHostEnt = NULL;
                    CHAR    cAddr[16];
                    BYTE    pbAdd[4];
                    char    szAdd[4];
                    int     k = 0, l=0;
                    DWORD   nLen = 0;

                    if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 2 and
                        _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"\\\\", 2) is 0 )
                        k = 2;
                    
                    lpHostEnt = gethostbyname(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k, NULL));
                    if( lpHostEnt is NULL )
                    {
                        DisplayMessage(g_hModule,
                                       EMSG_WINS_INVALID_COMPUTER_NAME,
                                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k);
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;                                       
                    }

                    memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
                    for( l=0;l<4; l++)
                    {
                        _itoa((int)pbAdd[l], szAdd, 10);
                        memcpy(cAddr+nLen, szAdd, strlen(szAdd));
                        nLen += strlen(szAdd);
                        *(cAddr+nLen) = '.';
                        nLen++;
    
                    }
                    *(cAddr+nLen-1) = '\0';
                    WinsAdd.IPAdd = WinsDottedStringToIpAddress(cAddr);
                }
                break;
            }
        case 1:
            {
                DWORD dwVal = 0;
                if( ( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE ) or
                    ( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 1 ) )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                
                if( ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0] is L'1' )
                    dwChoice = WINSINTF_E_PUSH_PROP;
                else if( ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0] is L'0' )
                    dwChoice = WINSINTF_E_PUSH;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                break;

            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    for( j=0; j<sizeof(pttTags)/sizeof(TAG_TYPE); j++)
    {
        if( pttTags[j].dwRequired is TRUE &&
            pttTags[j].bPresent is FALSE )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_REQUIRED_PARAMETER,
                           j);
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
                           
        }
    }

    Status = WinsTrigger(g_hBind, &WinsAdd, dwChoice);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_INIT_PUSH,
                        Status);
    goto CommonReturn;

}


DWORD
HandleSrvrInitReplicate(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiates a database replication with the partners
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    
    HKEY        hServer = NULL,
                hPullRoot = NULL,
                hPushRoot = NULL;
    DWORD       dw = 0,
                dwKeyLen = MAX_IP_STRING_LEN+1,
                dwPullKeys = 0,                
                dwPushKeys = 0;

    WCHAR       wcIpAddress[MAX_IP_STRING_LEN+1] = {L'\0'};
    LPWSTR      pTemp = NULL;

    WINSINTF_ADD_T  WinsAdd;

    if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp,
                                HKEY_LOCAL_MACHINE,
                                &hServer);

    if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    Status = RegOpenKeyEx(hServer,
                          PULLROOT,
                          0,
                          KEY_ALL_ACCESS,
                          &hPullRoot);


    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegQueryInfoKey(hPullRoot,
                             NULL,
                             NULL,
                             NULL,
                             &dwPullKeys,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    
    Status = RegOpenKeyEx(hServer,
                          PUSHROOT,
                          0,
                          KEY_ALL_ACCESS,
                          &hPushRoot);


    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegQueryInfoKey(hPushRoot,
                             NULL,
                             NULL,
                             NULL,
                             &dwPushKeys,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule, MSG_WINS_TIME_WARNING);

    WinsAdd.Len = 4;
    WinsAdd.Type = 0;

    if( dwPullKeys is 0 )
    {
        DisplayMessage(g_hModule, EMSG_WINS_NO_PULLPARTNER);
    }

    if( dwPushKeys is 0 )
    {
        DisplayMessage(g_hModule, EMSG_WINS_NO_PUSHPARTNER);
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);

    for( dw=0; dw<dwPullKeys; dw++ )
    {
        dwKeyLen = MAX_IP_STRING_LEN+1;
        
        Status = RegEnumKeyEx(hPullRoot,
                              dw,
                              wcIpAddress,
                              &dwKeyLen,
                              NULL,
                              NULL,
                              NULL,
                              NULL);
        if( Status isnot NO_ERROR )
            continue;

        WinsAdd.IPAdd = StringToIpAddress(wcIpAddress);

        DisplayMessage(g_hModule, MSG_WINS_SEND_PULL, wcIpAddress);
        Status = WinsTrigger(g_hBind, &WinsAdd, WINSINTF_E_PULL);
        if( Status isnot NO_ERROR )
        {
            DisplayMessage(g_hModule, EMSG_WINS_PULL_FAILED);           
        }
        else
        {
            DisplayMessage(g_hModule, MSG_WINS_TRIGGER_DONE);
        }

    }

    WinsAdd.Len = 4;
    WinsAdd.Type = 0;

    for( dw=0; dw<dwPushKeys; dw++ )
    {
        dwKeyLen = MAX_IP_STRING_LEN+1;

        Status = RegEnumKeyEx(hPushRoot,
                              dw,
                              wcIpAddress,
                              &dwKeyLen,
                              NULL,
                              NULL,
                              NULL,
                              NULL);
        if( Status isnot NO_ERROR )
            continue;

        WinsAdd.IPAdd = StringToIpAddress(wcIpAddress);

        DisplayMessage(g_hModule, MSG_WINS_SEND_PUSH, wcIpAddress);
        Status = WinsTrigger(g_hBind, &WinsAdd, WINSINTF_E_PUSH_PROP);

        if( Status isnot NO_ERROR )
        {
            DisplayMessage(g_hModule, EMSG_WINS_PUSH_FAILED);
        }
        else
        {
            DisplayMessage(g_hModule, MSG_WINS_TRIGGER_DONE);
        }
    }
    
    
    if( Status isnot NO_ERROR )
        goto CommonReturn;

    DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
CommonReturn:
    
    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( hPullRoot )
    {
        RegCloseKey(hPullRoot);
        hPullRoot = NULL;
    }

    if( hPushRoot )
    {
        RegCloseKey(hPushRoot);
        hPushRoot = NULL;
    }

    return Status;

ErrorReturn:
    if( Status is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_NO_PARTNER);
    }
    else
    {
        DisplayErrorMessage(EMSG_SRVR_INIT_REPLICATE,
                            Status);
    }
    goto CommonReturn;

}

DWORD
HandleSrvrInitRestore(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiates and restore database 
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Directory to do restore from              
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR,
                Status1 = NO_ERROR,
                i, j, dwNumArgs, dwTagCount=0;
    PDWORD      pdwNumTags = NULL, pdwTypeTags = NULL;
    TAG_TYPE    pttTags[] = { {WINS_TOKEN_DIR, TRUE, FALSE},
                              {WINS_TOKEN_VERSION, FALSE, FALSE},
                            };
    CHAR        szRestorePath[MAX_PATH+1] = {'\0'};
    LPWSTR      pwszTemp = NULL;
    DWORD       dwService = NO_ERROR;
    DbVersion   eVersion = 3;
    BOOL        fBackupOnTerm = FALSE;

    handle_t                wbdhBind = g_hBind;
  	WINSINTF_BIND_DATA_T    wbdBindData = g_BindData;
    DWORD                   dwError = NO_ERROR;
    
    
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_INIT_RESTORE_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( IsLocalServer() is FALSE )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_LOCAL_SERVER,
                       g_ServerIpAddressUnicodeString);
        return ERROR_INVALID_PARAMETER;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwNumTags = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwNumTags is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    pdwTypeTags = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTypeTags is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

        dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTypeTags,
                               pdwNumTags);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    i = dwTagCount;

    for( j = 0; j < i ; j++ )
    {
        switch(pdwTypeTags[j])
        {
        case 0:
            {
                DWORD   dw = 0;
                LPSTR   pszTempPath = NULL;
                pszTempPath = WinsUnicodeToOem(ppwcArguments[dwCurrentIndex+pdwNumTags[j]], NULL);

                if( pszTempPath is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                
                dw = strlen(pszTempPath);

                if( dw < 2 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    WinsFreeMemory( pszTempPath );
                    pszTempPath = NULL;
                    goto ErrorReturn;
                }

                strncpy(szRestorePath, 
                        pszTempPath,
                        ( dw > MAX_PATH - 1 ) ? MAX_PATH - 1 : dw );

                WinsFreeMemory(pszTempPath);
                pszTempPath = NULL;

                break;
            }
        case 1:
            {
                DWORD eVer = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwNumTags[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                eVer = STRTOUL(ppwcArguments[dwCurrentIndex+pdwNumTags[j]], NULL, 0);
                if( eVer > DbVersionMin && eVer < DbVersionMax )
                    eVersion = eVer;
                else
                {
                    Status = ERROR_INVALID_DB_VERSION;
                    goto ErrorReturn;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
    
    //To restore the database, first stop WINS Service, Cleanup earlier dabase
    //do DB restore and then restart WINS

    
    {
       

        //Unbind WINS

        WinsUnbind(&g_BindData, g_hBind);
        g_hBind = NULL;
        
        //Reset Backup on Termination flag
        {
            HKEY hServer = NULL,
                 hParameter = NULL;

            LPWSTR  pTemp = NULL;
            
            DWORD   dwSize = sizeof(DWORD);
            DWORD   dwType = REG_DWORD;
            DWORD   dwData = 0;

            if( wcslen(g_ServerNetBiosName) > 0 )
                pTemp = g_ServerNetBiosName;
            
            Status = RegConnectRegistry(pTemp,
                                        HKEY_LOCAL_MACHINE,
                                        &hServer);
            if( Status isnot NO_ERROR )
                goto EXIT;

            Status = RegOpenKeyEx(hServer,
                                  PARAMETER,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hParameter);

            if( Status isnot NO_ERROR )
                goto EXIT;
            
            Status = RegQueryValueEx(hParameter,
                                     WINSCNF_DO_BACKUP_ON_TERM_NM,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwSize);

            if( Status is NO_ERROR )
            {
                if( dwData is 1 )
                {
                    DWORD dw = 0;
                    Status = RegSetValueEx(hParameter,
                                           WINSCNF_DO_BACKUP_ON_TERM_NM,
                                           0,
                                           REG_DWORD,
                                           (LPBYTE)&dw,
                                           sizeof(DWORD));
                    
                    if( Status is NO_ERROR )
                        fBackupOnTerm = TRUE;

                }
                else
                {
                    fBackupOnTerm = FALSE;
                }
            }

EXIT:
            if( Status isnot NO_ERROR )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_RESTORE_IMPROPER);
            }

            if( hServer )
            {
                RegCloseKey(hServer);
                hServer = NULL;
            }

            if( hParameter )
            {
                RegCloseKey(hParameter);
                hParameter = NULL;
            }

            Status = NO_ERROR;
        }

        //Stop WINS Service
        Status = ControlWINSService(TRUE);

        if( Status isnot NO_ERROR )
        {
            if( Status isnot ERROR_SERVICE_NOT_ACTIVE )
            {
                g_BindData = wbdBindData;
                g_hBind = WinsBind(&g_BindData);
                goto ErrorReturn;
            }
            else
            {
                dwService = ERROR_SERVICE_NOT_ACTIVE;
                Status = NO_ERROR;
            }

        }

       //Now try restoring the database      
        Status1 = WinsRestore((LPBYTE)szRestorePath);

        if( Status1 isnot NO_ERROR )
        {
            DisplayErrorMessage(EMSG_SRVR_INIT_RESTORE,
                                Status1);
        }

        if( dwService isnot ERROR_SERVICE_NOT_ACTIVE )
            Status = ControlWINSService(FALSE);
    }

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    if( Status1 isnot NO_ERROR )
    {
        Status = Status1;
        goto ErrorReturn;
    }

    DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

CommonReturn:
    
    g_BindData = wbdBindData;
    g_hBind = WinsBind(&g_BindData);
     
    //Reset the DoBackUpOnTerm value
    if( fBackupOnTerm is TRUE )
    {
        HKEY    hServer = NULL,
                hParameter = NULL;
        LPWSTR  pTemp = NULL;
        DWORD   dwErr = NO_ERROR;
        if( wcslen(g_ServerNetBiosName) > 0 )
        {
            pTemp = g_ServerNetBiosName;
        }
        
        dwErr = RegConnectRegistry(pTemp,
                                   HKEY_LOCAL_MACHINE,
                                   &hServer);
        if( dwErr isnot NO_ERROR )
        {
            DisplayErrorMessage(EMSG_WINS_REGCONNECT_FAILED,
                                dwErr);
        }
        else
        {
            dwErr = RegOpenKeyEx(hServer,
                                 PARAMETER,
                                 0,
                                 KEY_ALL_ACCESS,
                                 &hParameter);
            if( dwErr isnot NO_ERROR )
            {
                RegCloseKey(hServer);
                hServer = NULL;
                DisplayErrorMessage(EMSG_WINS_REGOPEN_FAILED,
                                    dwErr);
            }
            else
            {
                DWORD dw = 1;
                dwErr = RegSetValueEx(hParameter,
                                      WINSCNF_DO_BACKUP_ON_TERM_NM,
                                      0,
                                      REG_DWORD,
                                      (LPBYTE)&dw,
                                      sizeof(DWORD));
                if( dwErr isnot NO_ERROR )
                {
                    DisplayErrorMessage(EMSG_WINS_REGSETVAL_FAILED,
                                        dwErr);
                }

                RegCloseKey(hParameter);
                hParameter = NULL;
                RegCloseKey(hServer);
                hServer = NULL;
            }
        }
        
    }
    if( pdwTypeTags )
    {
        WinsFreeMemory(pdwTypeTags);
        pdwTypeTags = NULL;
    }
    if( pdwNumTags )
    {
        WinsFreeMemory(pdwNumTags);
        pdwNumTags = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_INIT_RESTORE,
                        Status);
    goto CommonReturn;   
}


DWORD
HandleSrvrInitScavenge(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiates scavenging of database for the server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD           Status = NO_ERROR;
    struct in_addr            InAddr;
    BOOL            fIpAddress = TRUE;
    DWORD           j = 0;

    WCHAR       wcName[256] = {L'\0'};
    DWORD       dwLen = 0;

    WINSINTF_ADD_T            WinsAdd;
    WINSINTF_RESULTS_T        Results;    
    WINSINTF_VERS_NO_T        MaxVer, MinVer;
    WINSINTF_RECS_T           Recs;
    PWINSINTF_RECORD_ACTION_T pRow =  NULL;

    Status = WinsDoScavenging( g_hBind );
    
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_ERROR_SUCCESS);
    }

    else
    {
        DisplayErrorMessage(EMSG_SRVR_INIT_SCAVENGE,
                            Status);
    }

    return Status;
}

DWORD
HandleSrvrInitSearch(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Search WINS database based on Name, 16th char, case and optionally stores the result to a file,
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Name to search for
        Optional : 16th char, case sensitive or not and if the result to be stored in a file, then the file
                   Name.               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, k, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[]={
                              {WINS_TOKEN_NAME, TRUE, FALSE},
                              {WINS_TOKEN_ENDCHAR, FALSE, FALSE},
                              {WINS_TOKEN_CASE, FALSE, FALSE},
                              {WINS_TOKEN_FILE, FALSE, FALSE},
                          };
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    CHAR        chEndChar = (CHAR)0x00;
    BOOL        fEndChar = FALSE;
    WCHAR       wcName[256+1] = {L'\0'};
    WCHAR       wcFile[MAX_PATH] = {L'\0'};
    BOOL        fFile = FALSE;
    DWORD       dwLen = 0;
    BOOL        fIpAddress = TRUE;
    BOOL        fMatch = FALSE;
    BOOL        fCase = FALSE;
    BOOL        fNew = TRUE;
    struct in_addr            InAddr;
    LPSTR       pszName = NULL;


    WINSINTF_ADD_T            WinsAdd;
    WINSINTF_RESULTS_T        Results = {0};
    WINSINTF_RESULTS_NEW_T    ResultsN = {0};
    WINSINTF_VERS_NO_T        MaxVer, MinVer;
    WINSINTF_RECS_T           Recs;
    PWINSINTF_RECORD_ACTION_T pRow =  NULL;

    
    i = j = k = dwNumArgs = dwTagCount = 0;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_INIT_SEARCH_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    
    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);
    
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++)
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                DWORD dwLen = 0;
                
                dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                dwLen = ( 255 < dwLen ) ? 255 : dwLen;
                memcpy(wcName, 
                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 
                       dwLen*sizeof(WCHAR));
                wcName[dwLen] = L'\0';
                fIpAddress = FALSE;
                break;
            }
        case 1:
            {
                DWORD dwLen = 0, k=0;
                fEndChar = TRUE;
                dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen > 2 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                        
                }
                
                for( k=0; k<dwLen; k++ )
                {
                    WCHAR  wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][k];
                    if( towlower(wc) >= L'a' and
                        towlower(wc) <= L'z' )
                    {
                        if( towlower(wc) > L'f' )
                        {
                            Status = ERROR_INVALID_PARAMETER;
                            goto ErrorReturn;
                        }
                    
                    }
                }
                chEndChar = StringToHexA(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                break;
            }
        case 2:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 10);
                
                if( dw is 0 )
                {
                    fCase = FALSE;
                    break;
                }
                if( dw is 1 )
                {
                    fCase = TRUE;
                    break;
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                

            }
        case 3:
            {
                DWORD   dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen is 0 )
                {
                    wcscpy(wcFile, L"wins.rec");
                    fFile = TRUE;
                    break;
                }
                wcscpy(wcFile, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                fFile = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
       
    pszName = WinsUnicodeToOem(wcName, NULL);

    if( pszName is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwLen = strlen(pszName);
    
    if( dwLen >= 16 )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_NETBIOS_NAME);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( fEndChar )
    {
        LPSTR pTemp = pszName;
        pszName = WinsAllocateMemory(17);
        if( pszName is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        memcpy(pszName, pTemp, 15);
        for( i=strlen(pszName); i<16; i++ )
        {
            pszName[i] = ' ';
        }
        pszName[15] = chEndChar;
        pszName[16] = '\0';
        WinsFreeMemory(pTemp);
        pTemp = NULL;
        dwLen = 16;
    }


    ResultsN.WinsStat.NoOfPnrs = 0;
    ResultsN.WinsStat.pRplPnrs = 0;
    ResultsN.NoOfWorkerThds = 1;
    ResultsN.pAddVersMaps = NULL;


    Status = WinsStatusNew(g_hBind, WINSINTF_E_CONFIG_ALL_MAPS, &ResultsN);
    
    if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
    {
        //Try old API
        Results.WinsStat.NoOfPnrs = 0;
        Results.WinsStat.pRplPnrs = 0;
        Status = WinsStatus(g_hBind, WINSINTF_E_CONFIG_ALL_MAPS, &Results);
        fNew = FALSE;
    }
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    g_dwSearchCount = 0;
    g_fHeader = FALSE;

    if( fNew is FALSE )
    {
        if( Results.NoOfOwners is 0 )
            goto CommonReturn;

        for( j=0; j<Results.NoOfOwners; j++)
        {
            WinsAdd.Len = 4;
            WinsAdd.Type = 0;
            WinsAdd.IPAdd = Results.AddVersMaps[j].Add.IPAdd;

            if( WinsAdd.IPAdd is 0 )
                continue;
            DisplayMessage(g_hModule,
                           MSG_WINS_SEARCHING_STATUS,
                           IpAddressToString(Results.AddVersMaps[j].Add.IPAdd));

            InAddr.s_addr = htonl(Results.AddVersMaps[j].Add.IPAdd);
            
            MaxVer = Results.AddVersMaps[j].VersNo;
            MinVer.HighPart = 0;
            MinVer.LowPart = 0;
            Status = GetDbRecs(MinVer,
                               MaxVer,
                               &WinsAdd,
                               inet_ntoa(InAddr),
                               fIpAddress ? FALSE : TRUE,
                               pszName, 
                               dwLen,
                               FALSE,
                               0,
                               FALSE,
                               fCase,
                               fFile,
                               fFile ? wcFile : NULL);
            if(Status isnot NO_ERROR )
            {
                if( Results.WinsStat.pRplPnrs)
                {
                    WinsFreeMem(Results.WinsStat.pRplPnrs);
                    Results.WinsStat.pRplPnrs = NULL;
                }
                goto ErrorReturn;
            }
        }
        if( Results.WinsStat.pRplPnrs)
        {
            WinsFreeMem(Results.WinsStat.pRplPnrs);
            Results.WinsStat.pRplPnrs = NULL;
        }
        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    }
    else
    {
        if( ResultsN.NoOfOwners is 0 )
            goto CommonReturn;
        for( j=0; j<ResultsN.NoOfOwners; j++)
        {

            WinsAdd.Len = 4;
            WinsAdd.Type = 0;
            WinsAdd.IPAdd = ResultsN.pAddVersMaps[j].Add.IPAdd;

            if( WinsAdd.IPAdd is 0 )
                continue;

            DisplayMessage(g_hModule,
                           MSG_WINS_SEARCHING_STATUS,
                           IpAddressToString(ResultsN.pAddVersMaps[j].Add.IPAdd));

            InAddr.s_addr = htonl(ResultsN.pAddVersMaps[j].Add.IPAdd);
            MaxVer = ResultsN.pAddVersMaps[j].VersNo;
            MinVer.HighPart = 0;
            MinVer.LowPart = 0;
            Status = GetDbRecs(MinVer,
                               MaxVer,
                               &WinsAdd,
                               inet_ntoa(InAddr),
                               fIpAddress ? FALSE : TRUE,
                               pszName, 
                               dwLen,
                               FALSE,
                               0,
                               FALSE,
                               fCase,
                               fFile,
                               fFile ? wcFile : NULL);

            if(Status isnot NO_ERROR )
            {
                if( ResultsN.WinsStat.pRplPnrs)
                {
                    WinsFreeMem(ResultsN.WinsStat.pRplPnrs);
                    ResultsN.WinsStat.pRplPnrs = NULL;
                }
                goto ErrorReturn;
            }
        }
        if( ResultsN.WinsStat.pRplPnrs)
        {
            WinsFreeMem(ResultsN.WinsStat.pRplPnrs);
            ResultsN.WinsStat.pRplPnrs = NULL;
        }
        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    }

    if( pszName )
    {
        WinsFreeMemory(pszName);
        pszName = NULL;
    }    

    DisplayMessage(g_hModule,
                   MSG_SRVR_SEARCH_COUNT,
                   g_dwSearchCount);

    if( fFile )
    {
        FILE * pFile = _wfopen(wcFile, L"a+");

        if( pFile isnot NULL )
        {
            DumpMessage(g_hModule,
                        pFile,
                        MSG_SRVR_SEARCH_COUNT,
                        g_dwSearchCount);

            fclose(pFile);
            pFile = NULL;
        }
    }

CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( pszName )
    {
        WinsFreeMemory(pszName);
        pszName = NULL;
    }
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    
    g_dwSearchCount = 0;
    g_fHeader = FALSE;

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_INIT_SEARCH,
                        Status);
    goto CommonReturn;   
}

DWORD
HandleSrvrResetCounter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Resets the version counter
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD Status = NO_ERROR;

    Status = WinsResetCounters( g_hBind );
    
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_ERROR_SUCCESS);
    }

    else
    {
        DisplayErrorMessage(EMSG_SRVR_INIT_BACKUP,
                            Status);
    }
    return Status;
}

DWORD
HandleSrvrSetAutopartnerconfig(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Sets automatic partner configuration parameters.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : State to set or disable
        Optional : Time Interval or TTL value
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    LPWSTR      pTemp = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                                {WINS_TOKEN_INTERVAL, FALSE, FALSE},
                                {WINS_TOKEN_TTL, FALSE, FALSE},
                            };
    DWORD       dwInterval = WINSCNF_DEF_MCAST_INTVL;
    DWORD       dwTTL = WINSCNF_DEF_MCAST_TTL;
    BOOL        fState = FALSE,
                fTTL   = FALSE,
                fInterval = FALSE;

    HKEY        hServer = NULL,
                hParameter = NULL;
                


    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_AUTOPARTNERCONFIG_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    {
        dwNumArgs = dwArgCount - dwCurrentIndex;

        pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
        pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

        if( pdwTagType is NULL or
            pdwTagNum is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

        Status = PreProcessCommand(ppwcArguments,
                                   dwArgCount,
                                   dwCurrentIndex,
                                   pttTags,
                                   &dwTagCount,
                                   pdwTagType,
                                   pdwTagNum);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
        {
            if( pttTags[i].dwRequired is TRUE and
                pttTags[i].bPresent is FALSE 
              )
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }

        for( j=0; j<dwTagCount; j++ )
        {
            switch(pdwTagType[j])
            {
            case 0:
                {
                    WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                    if( wc is L'1' )
                    {
                        fState = TRUE;                  
                    }
                    else if( wc is L'0' )
                    {
                        fState = FALSE;
                    }
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    break;
                }
            case 1:
                {
                    DWORD dw = 0;
                    fInterval = TRUE;
                    if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                        break;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);

                    if( dw >= ONEDAY )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    dwInterval = dw;
                    break;

                }
            case 2:
                {
                    DWORD dw = 0;
                    fTTL = TRUE;    
                    if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                        break;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                    if( dw > 32 )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    if( dw <= 0 )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    dwTTL = dw;
                    break;
                }
            default:
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
            }
        }
    }
    {
        if( wcslen(g_ServerNetBiosName) > 0 )
        {
            pTemp = g_ServerNetBiosName;
        }
        
        Status = RegConnectRegistry(pTemp,
                                    HKEY_LOCAL_MACHINE,
                                    &hServer);
        
        if( Status isnot NO_ERROR )
            goto ErrorReturn;
        
        Status = RegOpenKeyEx(hServer,
                              PARAMETER,
                              0,
                              KEY_ALL_ACCESS,
                              &hParameter);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
        
        Status = RegSetValueEx(hParameter,
                               WINSCNF_USE_SELF_FND_PNRS_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fState,
                               sizeof(BOOL));
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        if( fInterval )
        {
            Status = RegSetValueEx(hParameter,
                                   WINSCNF_MCAST_INTVL_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwInterval,
                                   sizeof(DWORD));

            if( Status isnot NO_ERROR )
                goto ErrorReturn;
        }

        if( fTTL )
        {
            Status = RegSetValueEx(hParameter,
                                   WINSCNF_MCAST_TTL_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwTTL,
                                   sizeof(DWORD));
            if( Status isnot NO_ERROR )
                goto ErrorReturn;
        }
                                      
    }
CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_AUTOPARTNERCONFIG,
                        Status);
    goto CommonReturn;   
   
}


DWORD
HandleSrvrSetBackuppath(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Sets the backup path for the WINS database
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Backup dir
        Optional : Enable backup at server shutdown.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_DIR, FALSE, FALSE},
                                {WINS_TOKEN_ATSHUTDOWN, FALSE, FALSE},
                            };

    LPWSTR      pwszDir = L"C:\\\\";
    BOOL        fDir = FALSE;
    BOOL        fAtShutDown = FALSE;
    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hParameter = NULL;
    

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_BACKUPPATH_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 0 )
                {
                    pwszDir = ppwcArguments[dwCurrentIndex+pdwTagNum[j]];
                }
                else
                {
                    pwszDir = L"";
                }

                fDir = TRUE;

                break;
            }
        case 1:
            {
                WCHAR   wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) isnot 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                
                if( wc is L'0' )
                    fAtShutDown = FALSE;
                else if( wc is L'1' )
                    fAtShutDown = TRUE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }

        }
    }

    if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegCreateKeyEx(hServer,
                            PARAMETER,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hParameter,
                            NULL);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    if( fDir )
    {
       
        Status = RegSetValueEx(hParameter,
                               WINSCNF_BACKUP_DIR_PATH_NM,
                               0,
                               REG_EXPAND_SZ,
                               (LPBYTE)pwszDir,
                               (wcslen(pwszDir)+1)*sizeof(WCHAR));

        if( Status isnot NO_ERROR )
        {
            goto ErrorReturn;
        }
    }
    
    Status = RegSetValueEx(hParameter,
                           WINSCNF_DO_BACKUP_ON_TERM_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&fAtShutDown,
                           sizeof(BOOL));
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    
CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_BACKUPPATH,
                        Status);
    goto CommonReturn;   


}


DWORD
HandleSrvrSetDefaultparam(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Sets the default values for all the configuration parameter. This command
        must be run at least once before running the dump command.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD           Status = NO_ERROR;
    HKEY            hServer = NULL,
                    hWins = NULL,
                    hParameter = NULL,
                    hDefault = NULL,
                    hDefaultPull = NULL,
                    hDefaultPush = NULL,
                    hPartner = NULL,
                    hCheck = NULL,
                    hPullPart = NULL,
                    hPushPart = NULL;
    DWORD           dwSize = 0,
                    dwType = 0,
                    dwData = 0;
    LPWSTR          pTemp = NULL;

    if( wcslen(g_ServerNetBiosName) > 2 )
        pTemp = g_ServerNetBiosName;

    Status = RegConnectRegistry(pTemp,
                                HKEY_LOCAL_MACHINE,
                                &hServer);

    if( Status isnot NO_ERROR )
    {
        goto RETURN;
    }


    //Open all required Registry key handles
    Status = RegCreateKeyEx(hServer,
                            PARAMETER,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hParameter,
                            NULL);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegCreateKeyEx(hServer,
                            PARTNERROOT,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hPartner,
                            NULL);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegCreateKeyEx(hServer,
                            PULLROOT,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hPullPart,
                            NULL);

    if( Status isnot NO_ERROR )
        goto RETURN;



    Status = RegCreateKeyEx(hServer,
                            PUSHROOT,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hPushPart,
                            NULL);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegCreateKeyEx(hServer,
                            DEFAULTPULL,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hDefaultPull,
                            NULL);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegCreateKeyEx(hServer,
                            DEFAULTPUSH,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hDefaultPush,
                            NULL);

    if( Status isnot NO_ERROR )
        goto RETURN;

    //Start setting the default values.

    Status = RegSetValueEx(hParameter,
                           WINSCNF_BACKUP_DIR_PATH_NM,
                           0,
                           REG_EXPAND_SZ,
                           (LPBYTE)L"",
                           (wcslen(L"")+1)*sizeof(WCHAR));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_DO_BACKUP_ON_TERM_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x7e900;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_REFRESH_INTVL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));
    
    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x54600;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_TOMBSTONE_INTVL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x7e900;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_TOMBSTONE_TMOUT_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x1fa400;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_VERIFY_INTVL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));
    
    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 1;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_BURST_HANDLING_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x1f4;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_BURST_QUE_SIZE_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_LOG_DETAILED_EVTS_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 1;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_LOG_FLAG_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_LOG_FILE_PATH_NM,
                           0,
                           REG_EXPAND_SZ,
                           (LPBYTE)L"%windir%\\system32\\wins",
                           (wcslen(L"%windir%\\system32\\wins")+1)*sizeof(WCHAR));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_USE_SELF_FND_PNRS_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_MIGRATION_ON_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x1;
    Status = RegSetValueEx(hParameter,
                           WINSCNF_RPL_ONLY_W_CNF_PNRS_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;
    
    Status = RegSetValueEx(hParameter,
                           WINSCNF_DB_FILE_NM,
                           0,
                           REG_EXPAND_SZ,
                           (LPBYTE)L"%windir%\\system32\\wins\\wins.mdb",
                           (wcslen(L"%windir%\\system32\\wins\\wins.mdb")+1)*sizeof(WCHAR));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 2;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_MCAST_TTL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x960;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_MCAST_INTVL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_INIT_VERSNO_VAL_HW_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_INIT_VERSNO_VAL_LW_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x708;

    Status = RegSetValueEx(hDefaultPull,
                           WINSCNF_RPL_INTERVAL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0;
    Status = RegSetValueEx(hDefaultPush,
                           WINSCNF_UPDATE_COUNT_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x3;

    Status = RegSetValueEx(hPullPart,
                           WINSCNF_RETRY_COUNT_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x1;

    Status = RegSetValueEx(hPullPart,
                           WINSCNF_INIT_TIME_RPL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;
    
    dwData = 0x1;

    Status = RegSetValueEx(hPullPart,
                           WINSCNF_PRS_CONN_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x0;

    Status = RegSetValueEx(hPushPart,
                           WINSCNF_INIT_TIME_RPL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;
    
    dwData = 0x1;

    Status = RegSetValueEx(hPushPart,
                           WINSCNF_PRS_CONN_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x0;

    Status = RegSetValueEx(hPushPart,
                           WINSCNF_ADDCHG_TRIGGER_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);
RETURN:                   

    if( Status isnot NO_ERROR )
        DisplayErrorMessage(EMSG_SRVR_SET_DEFAULTPARAM,
                            Status);
    if( hPushPart )
    {
        RegCloseKey(hPushPart);
        hPushPart = NULL;
    }

    if( hPullPart )
    {
        RegCloseKey(hPullPart);
        hPullPart = NULL;
    }

    if( hPartner )
    {
        RegCloseKey(hPartner);
        hPartner = NULL;
    }

    if( hCheck )
    {
        RegCloseKey(hCheck);
        hCheck = NULL;
    }

    if( hDefaultPull )
    {
        RegCloseKey(hDefaultPull);
        hDefaultPull = NULL;
    }

    if( hDefaultPush )
    {
        RegCloseKey(hDefaultPush);
        hDefaultPush = NULL;
    }

    if( hDefault )
    {
        RegCloseKey(hDefault);
        hDefault = NULL;
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hWins )
    {
        RegCloseKey(hWins);
        hWins = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }    

    return Status;
}   



DWORD
HandleSrvrSetMigrateflag(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the migrate on/off flag
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Set or disable
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                            };

    BOOL        fMigrate = FALSE;
    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hParameter = NULL;
    

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_MIGRATEFLAG_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE or
                    wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                if( dw is 1 )
                    fMigrate = TRUE;
                else if( dw is 0 )
                    fMigrate = FALSE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    {
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
        
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegCreateKeyEx(hServer,
                                PARAMETER,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hParameter,
                                NULL);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegSetValueEx(hParameter,
                               WINSCNF_MIGRATION_ON_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fMigrate,
                               sizeof(BOOL));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    }


CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_MIGRATEFLAG,
                        Status);
    goto CommonReturn;   

}


DWORD
HandleSrvrSetNamerecord(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the name record parameters for the server.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Optional : Renew, extinction interval, extinction timeout and verification values.
        Note : All parameters are optional.                 
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_RENEW, FALSE, FALSE},
                                {WINS_TOKEN_EXTINCTION, FALSE, FALSE},
                                {WINS_TOKEN_EXTIMEOUT, FALSE, FALSE},
                                {WINS_TOKEN_VERIFICATION, FALSE, FALSE},
                            };

    DWORD       dwRenew = SIX_DAYS,
                dwExtinction = SIX_DAYS,
                dwExTimeOut = SIX_DAYS,
                dwVerify = WINSCNF_MIN_VERIFY_INTERVAL;

    BOOL        fRenew = FALSE,
                fExtinction = FALSE,
                fExTimeOut = FALSE,
                fVerify = FALSE;

    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hParameter = NULL;
    
    
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
        return NO_ERROR;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                {
                    dwRenew = SIX_DAYS;
                }
                else
                {
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 10);
                    dwRenew = dw;
                }
                fRenew = TRUE;            
                break;
            }
        case 1:
            {   
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                {
                    dwExtinction = SIX_DAYS;
                }
                else
                {
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                    dwExtinction = dw;
                }
                fExtinction = TRUE;
                break;
            }
        case 2:
            {

                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                {
                    dwExTimeOut = SIX_DAYS;
                }
                else
                {
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                    dwExTimeOut = dw;
                }
                fExTimeOut = TRUE;
                break;
            }
        case 3:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                {
                    dwVerify = WINSCNF_MIN_VERIFY_INTERVAL;
                }
                else
                {
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                    dwVerify = dw;
                }
                fVerify = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    {
        DWORD dwValue = 0,
              dwType = REG_DWORD,
              dwSize = sizeof(DWORD);
                
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
        
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegCreateKeyEx(hServer,
                                PARAMETER,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hParameter,
                                NULL);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        //First retrieve the older values for all the parameters
        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_REFRESH_INTVL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwValue,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            if( fRenew is FALSE )
            {
                dwRenew = dwValue;
            }
        }
            
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_TOMBSTONE_INTVL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwValue,
                                 &dwSize);
        if( Status is NO_ERROR )
        {
            if( fExtinction is FALSE )
                dwExtinction = dwValue;
        }

        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_TOMBSTONE_TMOUT_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwValue,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            if( fExTimeOut is FALSE )
                dwExTimeOut = dwValue;
        }

        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_VERIFY_INTVL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwValue,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            if( fVerify is FALSE )
                dwVerify = dwValue;
        }

        //Check the validity and range of values
        {
            if( dwRenew < WINSCNF_MIN_REFRESH_INTERVAL )
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_RENEW_INTERVAL);
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;                                           
            }
            if( dwRenew > ONE_YEAR )
            {
                dwRenew = ONE_YEAR;
            }

            if( dwExTimeOut < WINSCNF_MIN_TOMBSTONE_TIMEOUT )
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_TOMBSTONE_TIMEOUT,
                               WINSCNF_MIN_TOMBSTONE_TIMEOUT);
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            if( dwExTimeOut > ONE_YEAR )
            {
                dwExTimeOut = ONE_YEAR;
            }

            if( dwExTimeOut < dwRenew )
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_TOMBSTONE_TIMEOUT,
                               dwRenew);
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }

            if( dwExtinction < WINSCNF_MAKE_TOMB_INTVL_0_M(dwRenew) )
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_TOMBSTONE_INTERVAL,
                               WINSCNF_MAKE_TOMB_INTVL_0_M(dwRenew) );
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }

            if( dwVerify < WINSCNF_MAKE_VERIFY_INTVL_M(dwExtinction) )
            {
                if( WINSCNF_MAKE_VERIFY_INTVL_M(dwExtinction) == TWENTY_FOUR_DAYS )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_SRVR_VERIFY_INTERVAL,
                                   TOMB_MULTIPLIER_FOR_VERIFY,
                                   WINSCNF_MAKE_VERIFY_INTVL_M(dwExtinction));
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

            }
        }


        Status = RegSetValueEx(hParameter,
                               WINSCNF_REFRESH_INTVL_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&dwRenew,
                               sizeof(DWORD));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegSetValueEx(hParameter,
                               WINSCNF_TOMBSTONE_INTVL_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&dwExtinction,
                               sizeof(DWORD));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegSetValueEx(hParameter,
                               WINSCNF_TOMBSTONE_TMOUT_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&dwExTimeOut,
                               sizeof(DWORD));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegSetValueEx(hParameter,
                               WINSCNF_VERIFY_INTVL_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&dwVerify,
                               sizeof(DWORD));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

    }

    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }
CommonReturn:


    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_NAMERECORD,
                        Status);
    goto CommonReturn;   
    
}

DWORD
HandleSrvrSetPeriodicdbchecking(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the periodic database checking parameters for the server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : State
        Optional : Maximum record count, and other parameters.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                                {WINS_TOKEN_MAXRECORDCOUNT, FALSE, FALSE},
                                {WINS_TOKEN_CHECKAGAINST, FALSE, FALSE},
                                {WINS_TOKEN_CHECKEVERY, FALSE, FALSE},
                                {WINS_TOKEN_START, FALSE, FALSE},
                            };

    DWORD       dwMaxRec = WINSCNF_CC_DEF_RECS_AAT,
                dwEvery = WINSCNF_CC_DEF_INTERVAL,
                dwStart = WINSCNF_DEF_CC_SP_HR*60*60;

    BOOL        fPartner = WINSCNF_CC_DEF_USE_RPL_PNRS,
                fIsPartner = FALSE,
                fMax = FALSE,
                fEvery = FALSE,
                fStart = FALSE,
                fState = TRUE;


    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hCCRoot = NULL;
    

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_PERIODICDBCHECKING_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                
                if( dw is 0 )
                    fState = FALSE;
                else
                    fState = TRUE;
                break;
            }
        case 1:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwMaxRec = dw;
                fMax = TRUE;
                break;
            }
        case 2:
            {   
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                if( dw is 1 )
                    fPartner = TRUE;
                else
                    fPartner = FALSE;
                fIsPartner = TRUE;
                break;
            }
        case 3:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwEvery = dw*60*60;                   
                fEvery = TRUE;
                break;
            }
        case 4:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwStart = dw;
                fStart = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    if( fState is FALSE )
    {
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
       
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        RegDeleteKey(hServer, CCROOT);
    }
    else
    {
        if( fMax is TRUE or
            fEvery is TRUE or
            fIsPartner is TRUE or
            fStart is TRUE )
        {
            if( wcslen(g_ServerNetBiosName) > 0 )
                pTemp = g_ServerNetBiosName;

            Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
        
            if( Status isnot NO_ERROR )
                goto ErrorReturn;

            Status = RegCreateKeyEx(hServer,
                                    CCROOT,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hCCRoot,
                                    NULL);

            if( Status isnot NO_ERROR )
                goto ErrorReturn;


            if( fMax )
            {
                Status = RegSetValueEx(hCCRoot,
                                       WINSCNF_CC_MAX_RECS_AAT_NM,
                                       0,
                                       REG_DWORD,
                                       (LPBYTE)&dwMaxRec,
                                       sizeof(DWORD));

                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
            }

            if( fIsPartner )
            {
                Status = RegSetValueEx(hCCRoot,
                                       WINSCNF_CC_USE_RPL_PNRS_NM,
                                       0,
                                       REG_DWORD,
                                       (LPBYTE)&fPartner,
                                       sizeof(BOOL));

                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
            }
        
            if( fEvery )
            {
                Status = RegSetValueEx(hCCRoot,
                                       WINSCNF_CC_INTVL_NM,
                                       0,
                                       REG_DWORD,
                                       (LPBYTE)&dwEvery,
                                       sizeof(DWORD));

                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
            }

            if( fStart )
            {
                LPWSTR pwszTime = MakeTimeString(dwStart);
                if( pwszTime is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                Status = RegSetValueEx(hCCRoot,
                                       WINSCNF_SP_TIME_NM,
                                       0,
                                       REG_SZ,
                                       (LPBYTE)pwszTime,
                                       (wcslen(pwszTime)+1)*sizeof(WCHAR));

                WinsFreeMemory(pwszTime);
                pwszTime = NULL;
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
            }

        }
    }

CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hCCRoot )
    {
        RegCloseKey(hCCRoot);
        hCCRoot = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_PERIODICDBCHECKING,
                        Status);
    if( hServer )
    {
        if( hCCRoot )
        {
            RegCloseKey(hCCRoot);
            hCCRoot = NULL;
        }
        RegDeleteKey(hServer, CCROOT);
    }
    goto CommonReturn;   
}


DWORD
HandleSrvrSetPullpersistentconnection(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the pull partner configuration parameters
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Server IP and persistence state
        Optional : Start value and Time interval
        Note : All parameters are optional.                 
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                                {WINS_TOKEN_START, FALSE, FALSE},
                                {WINS_TOKEN_INTERVAL, FALSE, FALSE},
                            };

    DWORD       dwStart = 0,
                dwInterval = 1800; 

    WCHAR       wcServerIpAdd[MAX_IP_STRING_LEN + 1] = {L'\0'};

    BOOL        fState = TRUE,
                fStart = FALSE,
                fInterval = FALSE;

    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hPullRoot = NULL,
                hPullServer = NULL;
    

    if( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_PULLPERSISTENTCONNECTION_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'0' )
                    fState = FALSE;
                else if ( wc is L'1' )
                    fState = TRUE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        case 1:
            {
                struct  hostent * lpHostEnt = NULL;
                CHAR    cAddr[16];
                BYTE    pbAdd[4];
                char    szAdd[4];
                int     k = 0, l=0;
                DWORD   dwLen, nLen = 0;

                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) )
                {
                    DWORD dwIp = inet_addr(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL));
                    lpHostEnt = gethostbyaddr((char *)&dwIp, 4, AF_INET);
                    if(lpHostEnt isnot NULL )//Valid IP Address
                    {
                        wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                        break;
                    }
                    else
                    {
                        Status = ERROR_INVALID_IPADDRESS;
                        goto ErrorReturn;
                    }
                }

                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 2 and
                    _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"\\\\", 2) is 0 )
                    k = 2;

                lpHostEnt = gethostbyname(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k, NULL));
                if( lpHostEnt is NULL )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_WINS_INVALID_COMPUTER_NAME,
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k);
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;                                       
                }

                memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
                for( l=0; l<4; l++)
                {
                    _itoa((int)pbAdd[l], szAdd, 10);
                    memcpy(cAddr+nLen, szAdd, strlen(szAdd));
                    nLen += strlen(szAdd);
                    *(cAddr+nLen) = '.';
                    nLen++;

                }
                *(cAddr+nLen-1) = '\0';
                WinsAnsiToUnicode(cAddr, wcServerIpAdd);
                break;            }
        case 2:
            {   
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwStart = dw;
                fStart = TRUE;
                break;
            }
        case 3:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwInterval = dw;
                fInterval = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    {
        DWORD   dwDisposition = 0;
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegOpenKeyEx(hServer,
                              PULLROOT,
                              0,
                              KEY_ALL_ACCESS,
                              &hPullRoot);


        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegOpenKeyEx(hPullRoot,
                              wcServerIpAdd,
                              0,
                              KEY_ALL_ACCESS,
                              &hPullServer);

        if( Status is ERROR_FILE_NOT_FOUND )
        {
            DisplayMessage(g_hModule,
                           EMSG_SRVR_INVALID_PARTNER,
                           wcServerIpAdd);
            goto CommonReturn;
        }
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegSetValueEx(hPullServer,
                               PERSISTENCE,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fState,
                               sizeof(BOOL));
        
        if( Status isnot NO_ERROR )
        {
            goto ErrorReturn;
        }
     
        if( fInterval )
        {
            Status = RegSetValueEx(hPullServer,
                                   WINSCNF_RPL_INTERVAL_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwInterval,
                                   sizeof(DWORD));

            if( Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }
        }
        if( fStart )
        {
            LPWSTR pwszTime = MakeTimeString(dwStart);
            if( pwszTime is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            Status = RegSetValueEx(hPullServer,
                                   WINSCNF_SP_TIME_NM,
                                   0,
                                   REG_SZ,
                                   (LPBYTE)pwszTime,
                                   (wcslen(pwszTime)+1)*sizeof(WCHAR));

            WinsFreeMemory(pwszTime);
            pwszTime = NULL;
            if( Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }
        }

    }
    
CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hPullServer )
    {
        RegCloseKey(hPullServer);
        hPullServer = NULL;
    }

    if( hPullRoot )
    {
        RegCloseKey(hPullRoot);
        hPullRoot = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_PULLPERSISTENTCONNECTION,
                        Status);
    goto CommonReturn;   
}

DWORD
HandleSrvrSetPushpersistentconnection(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the push partner configuration parameters
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Server IP and persistence state
        Optional : Update count
        Note : All parameters are optional.                 
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                                {WINS_TOKEN_UPDATE,FALSE, FALSE},
                            };

    DWORD       dwUpdate = 0;

    WCHAR       wcServerIpAdd[MAX_IP_STRING_LEN + 1] = {L'\0'};

    BOOL        fState = TRUE,
                fUpdate = FALSE;

    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hPushRoot = NULL,
                hPushServer = NULL;
    

    if( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_PUSHPERSISTENTCONNECTION_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'0' )
                    fState = FALSE;
                else if ( wc is L'1' )
                    fState = TRUE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        case 1:
            {
                struct  hostent * lpHostEnt = NULL;
                CHAR    cAddr[16];
                BYTE    pbAdd[4];
                char    szAdd[4];
                int     k = 0, l=0;
                DWORD   dwLen, nLen = 0;

                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) )
                {
                    DWORD dwIp = inet_addr(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL));
                    lpHostEnt = gethostbyaddr((char *)&dwIp, 4, AF_INET);
                    if(lpHostEnt isnot NULL )//Valid IP Address
                    {
                        wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                        break;
                    }
                    else
                    {
                        Status = ERROR_INVALID_IPADDRESS;
                        goto ErrorReturn;
                    }
                }

                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 2 and
                    _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"\\\\", 2) is 0 )
                    k = 2;

                lpHostEnt = gethostbyname(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k, NULL));
                if( lpHostEnt is NULL )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_WINS_INVALID_COMPUTER_NAME,
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k);
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;                                       
                }

                memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
                for( l=0;l<4; l++)
                {
                    _itoa((int)pbAdd[l], szAdd, 10);
                    memcpy(cAddr+nLen, szAdd, strlen(szAdd));
                    nLen += strlen(szAdd);
                    *(cAddr+nLen) = '.';
                    nLen++;

                }
                *(cAddr+nLen-1) = '\0';
                WinsAnsiToUnicode(cAddr, wcServerIpAdd);
                break;            
            }
        case 2:
            {   
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwUpdate = dw;
                fUpdate = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    {
        DWORD   dwDisposition = 0;
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegOpenKeyEx(hServer,
                              PUSHROOT,
                              0,
                              KEY_ALL_ACCESS,
                              &hPushRoot);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        
        Status = RegOpenKeyEx(hPushRoot,
                              wcServerIpAdd,
                              0,
                              KEY_ALL_ACCESS,
                              &hPushServer);

        if( Status is ERROR_FILE_NOT_FOUND )
        {
            DisplayMessage(g_hModule,
                           EMSG_SRVR_INVALID_PARTNER,
                           wcServerIpAdd);
            goto CommonReturn;
        }

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegSetValueEx(hPushServer,
                               PERSISTENCE,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fState,
                               sizeof(BOOL));
        
        if( Status isnot NO_ERROR )
        {
            goto ErrorReturn;
        }
     
        if( fUpdate )
        {
            Status = RegSetValueEx(hPushServer,
                                   WINSCNF_UPDATE_COUNT_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwUpdate,
                                   sizeof(DWORD));

            if( Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }
        }
    }
    
CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hPushServer )
    {
        RegCloseKey(hPushServer);
        hPushServer = NULL;
    }

    if( hPushRoot )
    {
        RegCloseKey(hPushRoot);
        hPushRoot = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_PUSHPERSISTENTCONNECTION,
                        Status);
    goto CommonReturn;   
}


DWORD
HandleSrvrSetPullparam(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the default pull parameters
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : persistence state
        Optional : Startup value, Start time and Time interval and retry count
        Note : All parameters are optional.                 
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                                {WINS_TOKEN_STARTUP, FALSE, FALSE},
                                {WINS_TOKEN_START, FALSE, FALSE},
                                {WINS_TOKEN_INTERVAL, FALSE, FALSE},
                                {WINS_TOKEN_RETRY, FALSE, FALSE},
                            };

    DWORD       dwStart = 0,
                dwInterval = 1800,
                dwRetry = 3;

    BOOL        fStart = FALSE,
                fStartup = FALSE,
                fInterval = FALSE,
                fRetry = FALSE,
                fState = TRUE;


    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hDefault = NULL,
                hPullRoot = NULL;
    

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_PULLPARAM_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'0' )
                    fState = FALSE;
                else if ( wc is L'1' )
                    fState = TRUE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        case 1:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'1' )
                {
                    fStartup = TRUE;
                }
                else if ( wc is L'0' )
                {
                    fStartup = FALSE;
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        case 2:
            {   
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwStart = dw;
                fStart = TRUE;
                break;
            }
        case 3:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                
                

                if( dw > 0 && 
                    dw < 60 )   // 1 minute
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dwInterval = dw;
                fInterval = TRUE;
                break;
            }
        case 4:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwRetry = dw;
                fRetry = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
    {
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegCreateKeyEx(hServer,
                                PULLROOT,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hPullRoot,
                                NULL);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;


    
        Status = RegSetValueEx(hPullRoot,
                               PERSISTENCE,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fState,
                               sizeof(BOOL));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    

        Status = RegSetValueEx(hPullRoot,
                               WINSCNF_INIT_TIME_RPL_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fStartup,
                               sizeof(BOOL));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        if( fRetry )
        {
            Status = RegSetValueEx(hPullRoot,
                                   WINSCNF_RETRY_COUNT_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwRetry,
                                   sizeof(DWORD));
            if( Status isnot NO_ERROR )
                goto ErrorReturn;
        }

        if( fStart is TRUE or
            fInterval is TRUE )
        {
            Status = RegCreateKeyEx(hServer,
                                    DEFAULTPULL,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hDefault,
                                    NULL);

            if( Status isnot NO_ERROR )
                goto ErrorReturn;

            if( fStart )
            {
                LPWSTR pwszTime = MakeTimeString(dwStart);
                if( pwszTime is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                Status = RegSetValueEx(hDefault,
                                       WINSCNF_SP_TIME_NM,
                                       0,
                                       REG_SZ,
                                       (LPBYTE)pwszTime,
                                       (wcslen(pwszTime)+1)*sizeof(WCHAR));
                
                WinsFreeMemory(pwszTime);
                pwszTime = NULL;
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
            }

            if( fInterval )
            {
                Status = RegSetValueEx(hDefault,
                                       WINSCNF_RPL_INTERVAL_NM,
                                       0,
                                       REG_DWORD,
                                       (LPBYTE)&dwInterval,
                                       sizeof(DWORD));
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
            }
        } 
    }

CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hPullRoot )
    {
        RegCloseKey(hPullRoot);
        hPullRoot = NULL;
    }

    if( hDefault )
    {
        RegCloseKey(hDefault);
        hDefault = NULL;
    }
    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_PULLPARAM,
                        Status);
    goto CommonReturn;   
}

DWORD
HandleSrvrSetPushparam(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the default push parameters
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Server IP and persistence state
        Optional : Start value and Time interval
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                                {WINS_TOKEN_STARTUP, FALSE, FALSE},
                                {WINS_TOKEN_ADDRESSCHANGE, FALSE, FALSE},
                                {WINS_TOKEN_UPDATE, FALSE, FALSE},
                            };

    DWORD       dwUpdate = 3;

    BOOL        fStartup = FALSE,
                IsStartup = FALSE,
                fAddressChange = FALSE,
                IsAddChange = FALSE,
                fAdd = FALSE,
                IsAdd = FALSE,
                fUpdate = FALSE,
                IsUpdate = FALSE,
                fState = TRUE;


    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hDefault = NULL,
                hPushRoot = NULL;
    

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_PUSHPARAM_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'0' )
                    fState = FALSE;
                else if ( wc is L'1' )
                    fState = TRUE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        case 1:
            {
                WCHAR wc ;
                IsStartup = TRUE;
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                    break;
                wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'1' )
                {
                    fStartup = TRUE;
                }
                else if( wc is L'0' )
                    fStartup = 0;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        case 2:
            {   
                WCHAR wc ;
                IsAddChange = TRUE;
                fAdd = TRUE;
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                    break;
                wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'1' )
                    fAddressChange = TRUE;
                else if( wc is L'0' )
                    fAddressChange = FALSE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
     
                break;
            }
        case 3:
            {
                DWORD dw = 0;
                IsUpdate = TRUE;
                fUpdate = TRUE;  
                if( wcslen( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) < 1 )
                    break;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                if( dw < 1000 )
                    dwUpdate = dw;
                else
                    dwUpdate = 999;

                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
    {
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegCreateKeyEx(hServer,
                                PUSHROOT,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hPushRoot,
                                NULL);
                        

        if( Status isnot NO_ERROR )
            goto ErrorReturn;


    
        Status = RegSetValueEx(hPushRoot,
                               PERSISTENCE,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fState,
                               sizeof(BOOL));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    

        if( IsStartup )
        {
            Status = RegSetValueEx(hPushRoot,
                                   WINSCNF_INIT_TIME_RPL_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&fStartup,
                                   sizeof(BOOL));

            if( Status isnot NO_ERROR )
                goto ErrorReturn;
        }

        if( fAdd )
        {
            Status = RegSetValueEx(hPushRoot,
                                   WINSCNF_ADDCHG_TRIGGER_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&fAddressChange,
                                   sizeof(DWORD));
        
            if( Status isnot NO_ERROR )
                goto ErrorReturn;
        }

       
        if( fUpdate is TRUE )
        {
            Status = RegCreateKeyEx(hServer,
                                    DEFAULTPUSH,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hDefault,
                                    NULL);

            if( Status isnot NO_ERROR )
                goto ErrorReturn;

            Status = RegSetValueEx(hDefault,
                                   WINSCNF_UPDATE_COUNT_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwUpdate,
                                   sizeof(DWORD));

            if( Status isnot NO_ERROR )
                goto ErrorReturn;
        }
    }

CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hPushRoot )
    {
        RegCloseKey(hPushRoot);
        hPushRoot = NULL;
    }

    if( hDefault )
    {
        RegCloseKey(hDefault);
        hDefault = NULL;
    }
    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_PUSHPARAM,
                        Status);
    goto CommonReturn;   
}


DWORD
HandleSrvrSetReplicateflag(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the replication flag
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Flag state
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                            };

    BOOL        fReplicate = FALSE;
    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hParameter = NULL;
    

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_REPLICATEFLAG_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                if( dw is 1 )
                    fReplicate = TRUE;
                else if( dw is 0 )
                    fReplicate = FALSE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    {
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
        
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegCreateKeyEx(hServer,
                                PARAMETER,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hParameter,
                                NULL);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    
        Status = RegSetValueEx(hParameter,
                               WINSCNF_RPL_ONLY_W_CNF_PNRS_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fReplicate,
                               sizeof(BOOL));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    }


CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_REPLICATEFLAG,
                        Status);
    goto CommonReturn;   
}


DWORD
HandleSrvrSetLogparam(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the logging parameters
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Optional : Log database change and detail event log options
        Note : All parameters are optional.                 
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_DBCHANGE, FALSE, FALSE},
                                {WINS_TOKEN_EVENT, FALSE, FALSE},
                            };
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    BOOL        fDbChange = FALSE,
                IsDbChange = FALSE,
                fEvent = FALSE,
                IsEvent = FALSE;


    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_ERROR_SUCCESS);
        goto CommonReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];

                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is 0 )
                {
                    fDbChange = FALSE;
                    IsDbChange = TRUE;
                    break;
                }
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) isnot 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                if( wc is L'0' )
                {
                    fDbChange = FALSE;
                }
                else if( wc is L'1' )
                {
                     fDbChange = TRUE;
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                IsDbChange = TRUE;
                break;

            }
        case 1:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is 0 )
                {
                    fEvent = FALSE;
                    IsEvent = TRUE;
                    break;
                }

                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) isnot 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                if( wc is L'0' )
                {
                    fEvent = FALSE;
                }
                else if( wc is L'1' )
                {
                     fEvent = TRUE;
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                IsEvent = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    {
        HKEY    hServer = NULL,
                hParameter = NULL;
        LPWSTR  pTemp = NULL;
        DWORD   dwType = REG_DWORD,
                dwSize = sizeof(BOOL);

        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp,
                                    HKEY_LOCAL_MACHINE,
                                    &hServer);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
        
        Status = RegOpenKeyEx(hServer,
                              PARAMETER,
                              0,
                              KEY_ALL_ACCESS,
                              &hParameter);

        if( Status isnot NO_ERROR )
        {
            RegCloseKey(hServer);
            hServer = NULL;
            goto ErrorReturn;
        }
        
        if( IsDbChange )
        {
            Status = RegSetValueEx(hParameter,
                                   WINSCNF_LOG_FLAG_NM,
                                   0,
                                   dwType,
                                   (LPBYTE)&fDbChange,
                                   dwSize);

            if( Status isnot NO_ERROR )
            {
                RegCloseKey(hServer);
                hServer = NULL;
                RegCloseKey(hParameter);
                hParameter = NULL;
                goto ErrorReturn;                                    
            }
        }

        if( IsEvent )
        {
            Status = RegSetValueEx(hParameter,
                                   WINSCNF_LOG_DETAILED_EVTS_NM,
                                   0,
                                   dwType,
                                   (LPBYTE)&fEvent,
                                   dwSize);

            if( Status isnot NO_ERROR )
            {
                RegCloseKey(hServer);
                hServer = NULL;
                RegCloseKey(hParameter);
                hParameter = NULL;
                goto ErrorReturn;
            }
        }
        
        if( hServer )
        {
            RegCloseKey(hServer);
            hServer = NULL;
        }

        if( hParameter )
        {
            RegCloseKey(hParameter);
            hParameter = NULL;
        }

    }

    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);
CommonReturn:
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_LOGPARAM,
                        Status);
    goto CommonReturn;
}



DWORD
HandleSrvrSetBurstparam(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the burst handling parameters
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : To enable or disable burst handling
        Optional : Burst handling value.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                                {WINS_TOKEN_VALUE, FALSE, FALSE},
                            };
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    BOOL        fState = FALSE,
                fValue = FALSE;

    DWORD       dwValue = 0;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SET_BURSTPARAM_EX);

        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is 0 )
                {
                    fState = FALSE;
                    break;
                }
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) isnot 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                if( wc is L'0' )
                {
                    fState = FALSE;
                }
                else if( wc is L'1' )
                {
                     fState = TRUE;
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;

            }
        case 1:
            {                
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                
                dwValue = wcstoul(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 10);

                if( dwValue < 50 or
                    dwValue > 5000 )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_SRVR_BURST_PARAM_OUTOFRANGE);
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;

                }

                fValue = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    {
        HKEY    hServer = NULL,
                hParameter = NULL;
        LPWSTR  pTemp = NULL;
        DWORD   dwType = REG_DWORD,
                dwSize = sizeof(BOOL);

        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp,
                                    HKEY_LOCAL_MACHINE,
                                    &hServer);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
        
        Status = RegOpenKeyEx(hServer,
                              PARAMETER,
                              0,
                              KEY_ALL_ACCESS,
                              &hParameter);

        if( Status isnot NO_ERROR )
        {
            RegCloseKey(hServer);
            hServer = NULL;
            goto ErrorReturn;
        }
        
         Status = RegSetValueEx(hParameter,
                               WINSCNF_BURST_HANDLING_NM,
                               0,
                               dwType,
                               (LPBYTE)&fState,
                               dwSize);

        if( Status isnot NO_ERROR )
        {
            RegCloseKey(hServer);
            hServer = NULL;
            RegCloseKey(hParameter);
            hParameter = NULL;
            goto ErrorReturn;                                    
        }

        if( fValue )
        {
            dwSize = sizeof(DWORD);
            Status = RegSetValueEx(hParameter,
                                   WINSCNF_BURST_QUE_SIZE_NM,
                                   0,
                                   dwType,
                                   (LPBYTE)&dwValue,
                                   dwSize);

            if( Status isnot NO_ERROR )
            {
                RegCloseKey(hServer);
                hServer = NULL;
                RegCloseKey(hParameter);
                hParameter = NULL;
                goto ErrorReturn;
            }
        }
        
        if( hServer )
        {
            RegCloseKey(hServer);
            hServer = NULL;
        }

        if( hParameter )
        {
            RegCloseKey(hParameter);
            hParameter = NULL;
        }

    }

    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);
CommonReturn:
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_BURSTPARAM,
                        Status);
    goto CommonReturn;
}


DWORD
HandleSrvrSetStartversion(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set start value of the version counter
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Version counter value in {high,low} format
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD               Status = 0;
    DWORD               i, j, dwTagCount, dwNumArgs;
    TAG_TYPE            pttTags[] = {
                                        {WINS_TOKEN_VERSION, TRUE, FALSE},
                                    };
    WINSINTF_VERS_NO_T  Version={0};
    
    LPWSTR              pServer = NULL;
    PDWORD              pdwTagNum = NULL,
                        pdwTagType = NULL;

    HKEY                hServer = NULL,
                        hParameter = NULL;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SET_STARTVERSION_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount, 
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[0])
        {
        case 0:
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &Version);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                 break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            
            }
        }
    }   
    
    if( wcslen(g_ServerNetBiosName) > 0 )
        pServer = g_ServerNetBiosName;

    Status = RegConnectRegistry(pServer,
                                HKEY_LOCAL_MACHINE,
                                &hServer);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegOpenKeyEx(hServer,
                          PARAMETER,
                          0,
                          KEY_ALL_ACCESS,
                          &hParameter);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_INIT_VERSNO_VAL_HW_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&Version.HighPart,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_INIT_VERSNO_VAL_LW_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&Version.LowPart,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);

CommonReturn:

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_STARTVERSION,
                        Status);
    goto CommonReturn;
}

DWORD
HandleSrvrSetPersMode(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set Persona Grata/Non-Grata mode
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Grat|Non-Grata
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD     Status = 0;
    DWORD     dwTagCount;
    DWORD     dwPersMode;
    PDWORD    pdwTagNum = NULL;
    PDWORD    pdwTagType = NULL;
    TAG_TYPE  pttTags[] = {{WINS_TOKEN_MODE, TRUE, FALSE},};
    LPWSTR    lpwszMode;
    LPWSTR    pTemp;
    HKEY      hServer = NULL, hPartner = NULL;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_PGMODE_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    pdwTagType = WinsAllocateMemory((dwArgCount - dwCurrentIndex)*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory((dwArgCount - dwCurrentIndex)*sizeof(DWORD));

    if( pdwTagType is NULL || pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount, 
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    lpwszMode = ppwcArguments[dwCurrentIndex+pdwTagNum[0]];
    if (wcslen(lpwszMode) == 1 &&
        (lpwszMode[0] == L'0' || lpwszMode[0] == L'1'))
    {
        // set the value for 'persona grata mode'
        dwPersMode = lpwszMode[0] == L'0' ? PERSMODE_NON_GRATA : PERSMODE_GRATA;     
    }
    else
    {
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp,
                                HKEY_LOCAL_MACHINE,
                                &hServer);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegOpenKeyEx(hServer,
                          PARTNERROOT,
                          0,
                          KEY_ALL_ACCESS,
                          &hPartner);

    if (Status isnot NO_ERROR)
        goto ErrorReturn;

    Status = RegSetValueExA(
                hPartner,
                WINSCNF_PERSONA_MODE_NM,
                0,
                REG_DWORD,
                (LPVOID)&dwPersMode,
                sizeof(DWORD));

    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);

CommonReturn:
    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( hPartner )
    {
        RegCloseKey(hPartner);
        hPartner = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    return Status;

ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_PGMODE, Status);
    goto CommonReturn; 
}


DWORD
HandleSrvrShowDatabase(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays wins database based on (optionally)different filtering conditions
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Server ip whose database to be displayed
        Optional : Different conditions
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD                       Status = NO_ERROR;
    WINSINTF_ADD_T              WinsAdd = {0};
    TAG_TYPE                    pttTags[] = {   {WINS_TOKEN_SERVERS, TRUE, FALSE},
                                                {WINS_TOKEN_RECORDTYPE, FALSE, FALSE},
                                                {WINS_TOKEN_RECCOUNT, FALSE, FALSE},
                                                {WINS_TOKEN_START, FALSE, FALSE},
                                                {WINS_TOKEN_ENDCHAR, FALSE, FALSE},
                                                {WINS_TOKEN_FILE, FALSE, FALSE},
                                            };
    PDWORD                      pdwTagType = NULL,
                                pdwTagNum = NULL,
                                pdwIp = NULL;
    WCHAR                       wcFilter = L'\0';
    CHAR                        chFilter = 0x00;
    WCHAR                       wcServerIpAdd[MAX_IP_STRING_LEN+1]={L'\0'};
    WCHAR                       wcFile[MAX_PATH] = {L'\0'};
    DWORD                       i, j, dwNumArgs, dwTagCount;
    DWORD                       dwStart = WINSINTF_BEGINNING;
    DWORD                       NoOfRecsDesired = (DWORD)~0;
    DWORD                       TypeOfRec,
                                dwIpCount = 0,
                                dwRecCount = 0,
                                dwTotal = 0,
                                dw=0;
    WINSINTF_RECS_T             Recs = {0};
    PWINSINTF_RECORD_ACTION_T   pRow = NULL;
    BOOL                        fFilter = FALSE,
                                fFile = FALSE;
    BOOL                        fAll = FALSE,
                                fHeader = FALSE,
                                fError = FALSE,
                                fOnce = FALSE,
                                fNew = TRUE;
    WINSINTF_RESULTS_T          Results = {0};
    WINSINTF_RESULTS_NEW_T      ResultsN = {0};
    FILE                        *pFile = NULL;
    BOOL                        fOpenFile = FALSE;
    WCHAR                       wszFilter[3] = {L'\0'};
    LPWSTR                      pwszTemp = NULL;
    LPWSTR                      pwszTime = NULL;

    NoOfRecsDesired = (DWORD)~0;
    TypeOfRec = WINSINTF_BOTH;
    
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SHOW_DATABASE_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    {
        dwNumArgs = dwArgCount - dwCurrentIndex;
        pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
        pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
        if( pdwTagType is NULL or
            pdwTagNum is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);
        Status = PreProcessCommand(ppwcArguments,
                                   dwArgCount,
                                   dwCurrentIndex,
                                   pttTags,
                                   &dwTagCount,
                                   pdwTagType,
                                   pdwTagNum);
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
        {
            if( pttTags[i].dwRequired is TRUE and
                pttTags[i].bPresent is FALSE 
              )
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }

        for( j=0; j<dwTagCount; j++ )
        {
            switch(pdwTagType[j])
            {
            case 0:
                {
                    LPWSTR  pwcTemp = NULL,
                            pwcTag = L",\r\n",
                            pwcToken = NULL,
                            pwszIps = NULL;
                    DWORD   dwLen = 0;

                    dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);

                    if( ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0] isnot L'{' or
                        ppwcArguments[dwCurrentIndex+pdwTagNum[j]][dwLen-1] isnot L'}')
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    
                    pwcTemp = ppwcArguments[dwCurrentIndex+pdwTagNum[j]] + 1;
                    dwLen--;
                    ppwcArguments[dwCurrentIndex+pdwTagNum[j]][dwLen] = L'\0';
                    dwLen--;
                    
                    if( dwLen <= 0 )
                    {
                        fAll = TRUE;
                        break;
                    }
                    
                    if( dwLen < 7 )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }

                    pwszIps = WinsAllocateMemory((dwLen + 1)*sizeof(WCHAR));

                    if( pwszIps is NULL )
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }
                    
                    wcscpy(pwszIps, pwcTemp);
                    
                    pwcToken = wcstok(pwszIps, pwcTag);

                    dwIpCount = 0;

                    while( pwcToken isnot NULL )
                    {
                        PDWORD pdwTemp = NULL;

                        if( IsIpAddress( pwcToken ) is FALSE )
                        {
                            Status = ERROR_INVALID_PARAMETER;
                            WinsFreeMemory(pwszIps);
                            pwszIps = NULL;
                            goto ErrorReturn;
                        }

                        pdwTemp = pdwIp;
                        pdwIp = WinsAllocateMemory((dwIpCount+1)*sizeof(DWORD));
                        if( pdwIp is NULL )
                        {
                            Status = ERROR_NOT_ENOUGH_MEMORY;
                            WinsFreeMemory(pwszIps);
                            pwszIps = NULL;
                            if( pdwTemp )
                            {
                                WinsFreeMemory(pdwTemp);
                                pdwTemp = NULL;
                            }
                            goto ErrorReturn;
                        }

                        if( pdwTemp )
                        {
                            memcpy(pdwIp, pdwTemp, dwIpCount*sizeof(DWORD));
                            WinsFreeMemory(pdwTemp);
                            pdwTemp = NULL;
                        }

                        
                        pdwIp[dwIpCount] = StringToIpAddress(pwcToken);
                        dwIpCount++;
                        pwcToken = wcstok(NULL, pwcTag);

                    }
                    
                    if( pwszIps )
                    {
                        WinsFreeMemory(pwszIps);
                        pwszIps = NULL;
                    }

                    break;

                }
            case 1:
                {
                    DWORD dw = 0;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 10);
                    if( dw is 1 )
                        TypeOfRec = WINSINTF_STATIC;
                    else if( dw is 2 )
                        TypeOfRec = WINSINTF_DYNAMIC;
                    else if( dw is 0 )
                        TypeOfRec = WINSINTF_BOTH;
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    break;
                }
            case 2:
                {
                    DWORD dw = 0;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }                    
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 10);
                    NoOfRecsDesired = dw;
                    break;
                }
            case 3:
                {
                    DWORD dw = 0;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 10);
                    if( dw is 0 )
                    {
                        dwStart = WINSINTF_BEGINNING;
                    }
                    else if ( dw is 1 )
                    {
                        dwStart = WINSINTF_END;
                    }
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    break;
                }
            case 4:
                {
                    DWORD dwLen = 0, k=0;
                    dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    if( dwLen > 2 )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                        
                    }
                
                    for( k=0; k<dwLen; k++ )
                    {
                        WCHAR  wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][k];
                        if( isalpha(wc) is TRUE )
                        {
                            if( towlower(wc) < L'a' or
                                towlower(wc) > L'f' )
                            {
                                Status = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                        }
                    }
               
                    chFilter = StringToHexA(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    wcsncpy(wszFilter, ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 2);
                    fFilter = TRUE;
                    break;
                }
            case 5:
                {
                    DWORD   dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    if( dwLen is 0 or
                        dwLen > MAX_PATH )
                    {
                        wcscpy(wcFile, L"wins.rec");
                        fFile = TRUE;
                        break;
                    }
                    
                    wcscpy(wcFile, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    fFile = TRUE;
                    break;
                }
            default:
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
            }
        }
    }
    
    if( fAll )
    {   
        ResultsN.WinsStat.NoOfPnrs = 0;
        ResultsN.WinsStat.pRplPnrs = 0;
        ResultsN.NoOfWorkerThds = 1;
        ResultsN.pAddVersMaps = NULL;


        Status = WinsStatusNew(g_hBind, WINSINTF_E_CONFIG_ALL_MAPS, &ResultsN);
    
        if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
        {
            //Try old API
            Results.WinsStat.NoOfPnrs = 0;
            Results.WinsStat.pRplPnrs = 0;
            Status = WinsStatus(g_hBind, WINSINTF_E_CONFIG_ALL_MAPS, &Results);
            fNew = FALSE;
        }
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        if( fNew )
        {
            dwIpCount = ResultsN.NoOfOwners;
        }
        else
        {
            dwIpCount = Results.NoOfOwners;
        }
    }

    if( fFile is TRUE )
    {
        pFile = _wfopen(wcFile, L"a+");
        if( pFile is NULL )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_FILEOPEN_FAILED,
                           wcFile);
            fOpenFile = FALSE;
        }
        else
        {
            fOpenFile = TRUE;
        }
    }    
  
    for( dw=0; dw<dwIpCount; dw++ )
    {
        LPSTR   pszLastName = NULL;
        DWORD   dwLastNameLen = 0;
        DWORD   dwDesired = 0;
        BOOL    fDone = FALSE;

        if( fHeader is FALSE )
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_RECORD_DESC);


            DisplayMessage(g_hModule,
                           MSG_WINS_RECORD_TABLE);

            if( fOpenFile )
            {
                DumpMessage(g_hModule,
                            pFile,
                            FMSG_WINS_RECORDS_TABLE);
            }
            DisplayMessage(g_hModule,
                           WINS_FORMAT_LINE);


            fHeader = TRUE;
        }                             

        WinsAdd.Len = 4;
        WinsAdd.Type = 0;

        if( fAll )
        {
            if( fNew )
            {
                WinsAdd.IPAdd = ResultsN.pAddVersMaps[dw].Add.IPAdd;
            }
            else
            {
                WinsAdd.IPAdd = Results.AddVersMaps[dw].Add.IPAdd;
            }
        }
        else
        {
            WinsAdd.IPAdd = pdwIp[dw];
        }

        DisplayMessage(g_hModule,
                       MSG_SRVR_RETRIEVE_DATABASE,
                       IpAddressToString(WinsAdd.IPAdd));
        fOnce = FALSE;
        Status = NO_ERROR;
        dwTotal = 0;
        fDone = FALSE;

        while( Status is NO_ERROR and
               dwTotal < NoOfRecsDesired and
               fDone is FALSE )
        {
            dwDesired = ( NoOfRecsDesired - dwTotal > 500 ) ? 500 : (NoOfRecsDesired - dwTotal);
            if( Recs.pRow )
            {
                WinsFreeMem(Recs.pRow);
                Recs.pRow = NULL;
            }
            
            memset( &Recs, 0x00, sizeof(WINSINTF_RECS_T));

            Status = WinsGetDbRecsByName(g_hBind,
                                         &WinsAdd, 
                                         dwStart,
                                         fOnce ? pszLastName: NULL,
                                         dwLastNameLen,
                                         dwDesired, 
                                         TypeOfRec, 
                                         &Recs);
            if( Status isnot NO_ERROR )
            {
                if( fOnce is FALSE )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_SRVR_RETRIEVEDB_FAILED,
                                   IpAddressToString(WinsAdd.IPAdd));

                    DisplayErrorMessage(EMSG_SRVR_ERROR_MESSAGE,
                                        Status);
                    fError = TRUE;
                }
                else if (  Status isnot ERROR_REC_NON_EXISTENT )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_SRVR_RETRIEVEDB_FAILED,
                                   IpAddressToString(WinsAdd.IPAdd));

                    DisplayErrorMessage(EMSG_SRVR_ERROR_MESSAGE,
                                        Status);
                    fError = TRUE;
                }

                Status = NO_ERROR;


                break;
            }

            fOnce = TRUE;

            dwTotal += Recs.NoOfRecs;

            if( dwDesired > Recs.NoOfRecs )
            {
                fDone = TRUE;
            }
            pRow = Recs.pRow;

            if( Recs.NoOfRecs is 0 )
            {
                DisplayMessage(g_hModule,
                               MSG_WINS_NO_RECORDS);
            }
            else
            {
                WCHAR   Name[21] = {L'\0'};
                WCHAR   Type[2] = {L'\0'};
                WCHAR   State[2] = {L'\0'};
                WCHAR   Version[9] = {L'\0'};
                WCHAR   Group[2] = {L'\0'};
                WCHAR   IPAdd[MAX_IP_STRING_LEN+1] = {L'\0'};
                WCHAR   Buffer[16] = {L'\0'};
                DWORD   dwState = WINS_STATE_ACTIVE;
                DWORD   dwType = WINS_TYPE_STATIC;
                DWORD   dwGroup = WINS_GROUP_UNIQUE;
                DWORD   dwTempLen = 0;
                struct  tm* time = NULL;
                int     iType = 1;          
                for( j=0; j<Recs.NoOfRecs; j++ )
                {
            
                    LPWSTR  pwszGroup = NULL,
                            pwszStatic = NULL,
                            pwszType = NULL,
                            pwszState = NULL;
                    WCHAR   wszGroup[100] = {L'\0'},
                            wszType[100] = {L'\0'},
                            wszState[100] = {L'\0'};

                    CHAR    chEndChar = (CHAR)0x00;

                    DWORD   dwGrouplen = 0,
                            dwTypelen = 0,
                            dwStatelen = 0;
                    
                    memset( Name, 0x00, 21*sizeof(WCHAR));
                    if( j is Recs.NoOfRecs - 1 )
                    {
                        if( pszLastName )
                        {
                            WinsFreeMemory(pszLastName);
                            pszLastName = NULL;
                        }
                        pszLastName = WinsAllocateMemory(pRow->NameLen+2);
                        if(pszLastName is NULL )
                        {
                            Status = ERROR_NOT_ENOUGH_MEMORY;
                            goto ErrorReturn;
                        }
                        memset(pszLastName, 0x00, pRow->NameLen+2);

                        memcpy(pszLastName, pRow->pName, pRow->NameLen);
                        
                        //1B records detected at the boundary, swap 1st and
                        //16th char
                        
                        if( pszLastName[15] == 0x1B )
                        {
                            CHAR ch = pszLastName[15];
                            pszLastName[15] = pszLastName[0];
                            pszLastName[0] = ch;
                        }

                        strcat(pszLastName, "\x01");
                        dwLastNameLen = pRow->NameLen+1;
                    }
                    
                    if( pRow->NameLen > 16 )
                        i = 15;
                    else
                        i = pRow->NameLen;
                    
                    chEndChar = pRow->pName[i];

                    pRow->pName[i] = (CHAR)0x20;
                    //pRow->pName[16] = '\0';

                    if( fFilter is TRUE )
                    {
                        if( chFilter isnot chEndChar )
                        {
                            pRow++;
                            continue;
                        }
                    }
                    
                    pwszTemp = WinsOemToUnicode(pRow->pName, NULL);
                    if( pwszTemp is NULL )
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }
                    
                    dwTempLen = wcslen(pwszTemp);
                    
                    dwTempLen = (dwTempLen>16) ? 16 : dwTempLen;

                    wcsncpy(Name, pwszTemp, dwTempLen);
            
                    WinsFreeMemory(pwszTemp);
                    pwszTemp = NULL;

                    for( i=dwTempLen; i<16; i++ )
                        Name[i] = L' ';
                    Name[15] = L'[';
                    i=0;


                    WinsHexToString(Name+16, (LPBYTE)&chEndChar, 1);
                    Name[18] = L'h';
                    Name[19] = L']';
                    Name[20] = L'\0';


                    if( pRow->fStatic )
                    {
                        wcscpy(Type, L"S");
                        pwszType = L"STATIC ";
                        dwType = WINS_TYPE_STATIC;
                    }
                    else
                    {
                        wcscpy(Type, L"D");
                        pwszType = L"DYNAMIC";
                        dwType = WINS_TYPE_DYNAMIC;

                    }

                    if( pRow->State_e is WINSINTF_E_ACTIVE )
                    {
                        wcscpy(State, L"A");
                        pwszState = L"ACTIVE   ";
                        dwState = WINS_STATE_ACTIVE;
                    }

                    else if( pRow->State_e is WINSINTF_E_RELEASED )
                    {
                        wcscpy(State, L"R");
                        pwszState = L"RELEASED ";
                        dwState = WINS_STATE_RELEASED;
                    }
                    else
                    {
                        wcscpy(State, L"T");
                        pwszState = L"TOMBSTONE";
                        dwState = WINS_STATE_TOMBSTONE;
                    }

            
                    if( pRow->TypOfRec_e is WINSINTF_E_UNIQUE )
                    {
                        wcscpy(Group,L"U");
                        pwszGroup = L"UNIQUE        ";
                        dwGroup = WINS_GROUP_UNIQUE;
                    }
                    else if( pRow->TypOfRec_e is WINSINTF_E_NORM_GROUP )
                    {
                        wcscpy(Group,L"N");
                        pwszGroup = L"GROUP         ";
                        dwGroup = WINS_GROUP_GROUP;
                    }
                    else if( pRow->TypOfRec_e is WINSINTF_E_SPEC_GROUP )
                    {
                        if( pRow->pName[15] is 0x1C )
                        {
                            wcscpy(Group, L"D");
                            pwszGroup = L"DOMAIN NAME   ";
                            dwGroup = WINS_GROUP_DOMAIN;
                        }
                        else
                        {
                            wcscpy(Group,L"I");
                            pwszGroup = L"INTERNET GROUP";
                            dwGroup = WINS_GROUP_INTERNET;
                        }
                    }
                    else
                    {
                        wcscpy(Group,L"M");
                        pwszGroup = L"MULTIHOMED    ";
                        dwGroup = WINS_GROUP_MULTIHOMED;
                    }
    
            
                    dwStatelen = LoadStringW(g_hModule,
                                            dwState,
                                            wszState,
                                            sizeof(wszState)/sizeof(WCHAR));

                    dwGrouplen = LoadStringW(g_hModule,
                                            dwGroup,
                                            wszGroup,
                                            sizeof(wszGroup)/sizeof(WCHAR));

                    dwTypelen = LoadStringW(g_hModule,
                                           dwType,
                                           wszType,
                                           sizeof(wszType)/sizeof(WCHAR));

                    memset(Version, L'\0', 9);
                    _itow((int)pRow->VersNo.LowPart, Buffer, 16);
                    wcsncpy(Version, Buffer, wcslen(Buffer)>8?8:wcslen(Buffer));

                    for( i=wcslen(Version); i<9; i++ )
                        Version[i] = L' ';
                           
                    Version[8] = L'\0';

                    pwszTime = GetDateTimeString(pRow->TimeStamp,
                                                 TRUE,
                                                 &iType);

                    if ( pRow->TypOfRec_e is WINSINTF_E_UNIQUE  or
                         pRow->TypOfRec_e is WINSINTF_E_NORM_GROUP )
                    {

                        wcscpy(IPAdd, IpAddressToString(pRow->Add.IPAdd));

                        for( i=wcslen(IPAdd); i<MAX_IP_STRING_LEN; i++ )
                            IPAdd[i] = L' ';
                
                        IPAdd[MAX_IP_STRING_LEN] = L'\0';
                
                        DisplayMessage(g_hModule,
                                       MSG_WINS_RECORD_ENTRY,
                                       Name,
                                       Type,
                                       State,
                                       Version,
                                       Group,
                                       IPAdd,
                                       iType ? wszInfinite : pwszTime);
                        if( fOpenFile )
                        {
                            DumpMessage(g_hModule,
                                        pFile,
                                        FMSG_WINS_RECORD_ENTRY,
                                        Name,
                                        ( dwTypelen > 0 ) ? wszType : pwszType,
                                        ( dwStatelen > 0 ) ? wszState : pwszState,
                                        Version,
                                        ( dwGrouplen > 0 ) ? wszGroup : pwszGroup,
                                        iType ? wszInfinite : pwszTime,
                                        IPAdd,
                                        IpAddressToString(WinsAdd.IPAdd));

                        }

         
            
                    }
                    else //spec. grp or multihomed
                    {
                        DWORD ind;
                        BOOL  fFirst = FALSE;
                        for ( ind=0;  ind < pRow->NoOfAdds ;  /*no third expr*/ )
                        {
                            struct in_addr InAddr1, InAddr2;
                            LPWSTR  pwszTempAddr = NULL;
                            InAddr1.s_addr = htonl( (pRow->pAdd + ind++)->IPAdd);
                            InAddr2.s_addr = htonl( (pRow->pAdd + ind++)->IPAdd);

                            pwszTempAddr = WinsOemToUnicode(inet_ntoa(InAddr2), NULL);

                            if( pwszTempAddr is NULL )
                            {
                                Status = ERROR_NOT_ENOUGH_MEMORY;
                                goto ErrorReturn;
                            }

                            wcscpy(IPAdd, pwszTempAddr);

                            WinsFreeMemory(pwszTempAddr);
                            pwszTempAddr = NULL;

                            for( i=wcslen(IPAdd); i<MAX_IP_STRING_LEN; i++ )
                                IPAdd[i] = L' ';

                            if( fFirst is FALSE )
                            {

                                fFirst = TRUE;
                                DisplayMessage(g_hModule,
                                               MSG_WINS_RECORD_ENTRY,
                                               Name,
                                               Type,
                                               State,
                                               Version,
                                               Group,
                                               IPAdd,
                                               iType ? wszInfinite : pwszTime); 
                                if( fOpenFile )
                                {
                                    pwszTempAddr = WinsOemToUnicode(inet_ntoa(InAddr1), NULL);
                                    if( pwszTempAddr is NULL )
                                    {
                                        Status = ERROR_NOT_ENOUGH_MEMORY;
                                        goto ErrorReturn;
                                    }
                                    DumpMessage(g_hModule,
                                                pFile,
                                                FMSG_WINS_RECORD_ENTRY,
                                                Name,
                                                ( dwTypelen > 0 ) ? wszType : pwszType,
                                                ( dwStatelen > 0 ) ? wszState : pwszState,
                                                Version,
                                                ( dwGrouplen > 0 ) ? wszGroup : pwszGroup,
                                                iType ? wszInfinite : pwszTime,
                                                IPAdd,
                                                pwszTempAddr);
                                    WinsFreeMemory(pwszTempAddr);
                                    pwszTempAddr = NULL;

                                }
 
                            }
                            else
                            {

                                pwszTempAddr = WinsOemToUnicode(inet_ntoa(InAddr2), NULL);
                                if( pwszTempAddr is NULL )
                                {
                                    Status = ERROR_NOT_ENOUGH_MEMORY;
                                    goto ErrorReturn;
                                }

                                DisplayMessage(g_hModule,
                                               MSG_WINS_RECORD_IPADDRESS,
                                               pwszTempAddr);

                                WinsFreeMemory(pwszTempAddr);
                                pwszTempAddr = NULL;

                                if( fOpenFile )
                                {
                                    pwszTempAddr = WinsOemToUnicode(inet_ntoa(InAddr1), NULL);
                                    if( pwszTempAddr is NULL )
                                    {
                                        Status = ERROR_NOT_ENOUGH_MEMORY;
                                        goto ErrorReturn;
                                    }
                                    DumpMessage(g_hModule,
                                                pFile,
                                                FMSG_WINS_RECORD_IPADDRESS,
                                                IPAdd,
                                                pwszTempAddr);

                                    WinsFreeMemory(pwszTempAddr);
                                    pwszTempAddr = NULL;
                                    DumpMessage(g_hModule,
                                                pFile,
                                                WINS_FORMAT_LINE);
                                }
                                DisplayMessage(g_hModule,
                                               WINS_FORMAT_LINE);

                            }
                        }
                    }

                    pRow++;
                    dwRecCount++;
                    if( pwszTime )
                    {
                        WinsFreeMemory(pwszTime);
                        pwszTime = NULL;
                    }
                }
      

            }
        }

        DisplayMessage(g_hModule,
                       MSG_WINS_RECORDS_RETRIEVED,
                       IpAddressToString(WinsAdd.IPAdd),
                       dwTotal);
    }

    

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    if( fFilter )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_FILTER_RECCOUNT,
                       wszFilter,
                       dwRecCount);
        if( fOpenFile )
        {
            DumpMessage(g_hModule,
                        pFile,
                        MSG_SRVR_FILTER_RECCOUNT,
                        wszFilter,
                        dwRecCount);
        }
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_TOTAL_RECCOUNT,
                       dwRecCount);

        if( fOpenFile )
        {
            DumpMessage(g_hModule,
                        pFile,
                        MSG_SRVR_TOTAL_RECCOUNT,
                        dwRecCount);
        }

    }

CommonReturn:
    if( Status is NO_ERROR and
        fError is FALSE )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }
    else if( fError is TRUE )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_RETRIEVEDB_PARTIAL);
    }
    if( fOpenFile )
    {
        fclose(pFile);
        pFile = NULL;
    }
    if( Recs.pRow )
    {
        WinsFreeMem(Recs.pRow);
        Recs.pRow = NULL;
    }

    if( pwszTime )
    {
        WinsFreeMemory(pwszTime);
        pwszTime = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_DATABASE,
                        Status);
    goto CommonReturn;
}

DWORD
HandleSrvrShowDomain(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the domain master browser records
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/

{
    DWORD                     Status = NO_ERROR;
    DWORD                     i = 0, j=0;
    WINSINTF_BROWSER_NAMES_T  Names;
    PWINSINTF_BROWSER_INFO_T  pInfo = NULL;
    PWINSINTF_BROWSER_INFO_T  pInfoSv = NULL;
    WCHAR                     wcName[273] = {L'\0'},
                              wcCount[20] = {L'\0'}; 

    

    for(i=0; i<273; i++ )
        wcName[i] = L' ';

    for(i=0; i<20; i++ )
        wcCount[i] = L' ';

    wcCount[19] = L'\0';

    Names.EntriesRead = 0;
    Names.pInfo = NULL;
    Status = WinsGetBrowserNames(&g_BindData, &Names);
    if (Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_DOMAIN_COUNT,
                       Names.EntriesRead);
        
        DisplayMessage(g_hModule,
                       WINS_FORMAT_LINE);

        DisplayMessage(g_hModule,
                       MSG_WINS_DOMAIN_TABLE);

        pInfoSv = pInfo = Names.pInfo;
        for(i=0;  i < Names.EntriesRead; i++)
        {
            LPWSTR  pwcTemp = NULL;
            LPSTR   pcTemp = NULL;

            _itow((int)i, wcCount+3, 10);
            
            for( j=wcslen(wcCount); j<19; j++ )
                wcCount[j] = L' ';
            wcCount[19] = L'\0';

            pwcTemp = WinsOemToUnicode(pInfo->pName, NULL);
            if( pwcTemp is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }

            wcsncpy(wcName+3, pwcTemp, (15>wcslen(pwcTemp))? wcslen(pwcTemp) : 15);
                
            wcName[18] = L'[';

            if( strlen(pInfo->pName ) > 15 )
                pcTemp = pInfo->pName + 15;
            else
                pcTemp = pInfo->pName + strlen(pInfo->pName);

            WinsHexToString(wcName+19,
                            (LPBYTE)pcTemp,
                            1);
            wcName[21] = L'h';
            wcName[22] = L']';
            if( strlen(pInfo->pName)>16)
            {
                wcName[23] = L'.';
                wcscpy(wcName+24, pwcTemp+17);
                wcName[wcslen(wcName)] = L'\0';
            }
            else
                wcName[23] = L'\0';

            DisplayMessage(g_hModule,
                           MSG_WINS_DOMAIN_ENTRY,
                           wcCount,
                           wcName);
            if( pwcTemp )
            {
                WinsFreeMemory(pwcTemp);
                pwcTemp = NULL;
            }
             pInfo++;
        }
        WinsFreeMem(pInfoSv);
        pInfoSv = NULL;
        if( Status is NO_ERROR )
            DisplayMessage(g_hModule,
                           EMSG_WINS_ERROR_SUCCESS);
    }
    else
        goto ErrorReturn;

CommonReturn:
    if( pInfoSv )
    {
        WinsFreeMem(pInfoSv);
        pInfoSv = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_DOMAIN,
                        Status);
    goto CommonReturn;

}


DWORD
HandleSrvrShowInfo(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays server properties
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    HKEY        hServer = NULL,
                hParameter = NULL,
                hCCRoot = NULL;
    LPWSTR      pTemp = NULL;

    WCHAR       wcData[256] = {L'\0'};
    DWORD       dwType = REG_SZ,
                dwLen = 256*sizeof(WCHAR),
                dwData = 0,
                dwLow = 0;
    LPWSTR      pwszDayString = NULL,
                pwszTimeString = NULL;
    

    if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    Status = RegOpenKeyEx(hServer,
                          PARAMETER,
                          0,
                          KEY_READ,
                          &hParameter);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_WINS_DATABASE_BACKUPPARAM);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_BACKUP_DIR_PATH_NM,
                             0,
                             &dwType,
                             (LPBYTE)wcData,
                             &dwLen);
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_DATABASE_BACKUPDIR,
                       wcData);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_DATABASE_BACKUPDIR,
                       wszUnknown);
                       
    }

    dwLen = sizeof(DWORD);
    dwType = REG_DWORD;

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_DO_BACKUP_ON_TERM_NM,
                             0,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwLen);

    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_DATABASE_BACKUPONTERM,
                       dwData ? wszEnable : wszDisable);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_DATABASE_BACKUPONTERM,
                       wszUnknown);
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_WINS_NAMERECORD_SETTINGS);


    {

        WINSINTF_RESULTS_T      Results = {0};
        WINSINTF_RESULTS_NEW_T  ResultsN = {0};
        BOOL                    fNew = TRUE;
        

		ResultsN.WinsStat.NoOfPnrs = 0;
		ResultsN.WinsStat.pRplPnrs = NULL;
		ResultsN.NoOfWorkerThds = 1;

        Status = WinsStatusNew(g_hBind,
                               WINSINTF_E_CONFIG,
                               &ResultsN);

        if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
        {
            //Try old API
            Results.WinsStat.NoOfPnrs = 0;
            Results.WinsStat.pRplPnrs = 0;
            Status = WinsStatus(g_hBind, WINSINTF_E_CONFIG, &Results);
            fNew = FALSE;
        }
        
        if( Status is NO_ERROR )
        {
            if( fNew )
            {
                LPWSTR  pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(ResultsN.RefreshInterval);

                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_REFRESHINTVL,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(ResultsN.TombstoneInterval);
                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_TOMBSTONEINTVL,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(ResultsN.TombstoneTimeout);
                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_TOMBSTONETMOUT,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(ResultsN.VerifyInterval);
                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_VERIFYINTVL,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                if( ResultsN.WinsStat.pRplPnrs)
                {
                    WinsFreeMem(ResultsN.WinsStat.pRplPnrs);
                    ResultsN.WinsStat.pRplPnrs = NULL;
                }
            }
            else
            {
                LPWSTR  pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(Results.RefreshInterval);

                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_REFRESHINTVL,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(Results.TombstoneInterval);
                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_TOMBSTONEINTVL,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(Results.TombstoneTimeout);
                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_TOMBSTONETMOUT,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(Results.VerifyInterval);
                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_VERIFYINTVL,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                if( Results.WinsStat.pRplPnrs)
                {
                    WinsFreeMem(Results.WinsStat.pRplPnrs);
                    Results.WinsStat.pRplPnrs = NULL;
                }
            }

        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_NAMERECORD_REFRESHINTVL,
                           wszUnknown);
            
            DisplayMessage(g_hModule,
                           MSG_WINS_NAMERECORD_TOMBSTONEINTVL,
                           wszUnknown);

            DisplayMessage(g_hModule,
                           MSG_WINS_NAMERECORD_TOMBSTONETMOUT,
                           wszUnknown);

            DisplayMessage(g_hModule,
                           MSG_WINS_NAMERECORD_VERIFYINTVL,
                           wszUnknown);

        }

                            
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_WINS_DBCC_PARAM);

    Status = RegOpenKeyEx(hParameter,
                          CC,
                          0,
                          KEY_READ,
                          &hCCRoot);

    if( Status isnot NO_ERROR )
    {
        DisplayMessage(g_hModule, 
                       MSG_WINS_DBCC_STATE,
                       wszDisable);
    }
    else
    {
        DisplayMessage(g_hModule, 
                       MSG_WINS_DBCC_STATE,
                       wszEnable);

        dwType = REG_DWORD;
        dwData = 0;
        dwLen = sizeof(DWORD);
        Status = RegQueryValueEx(hCCRoot,
                               WINSCNF_CC_MAX_RECS_AAT_NM,
                               0,
                               &dwType,
                               (LPBYTE)&dwData,
                               &dwLen);

        if( Status is NO_ERROR )
        {
            WCHAR Buffer[20] = {L'\0'};
            _itow(dwData, Buffer, 10);
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_MAXCOUNT,
                           Buffer);
                           
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_MAXCOUNT,
                           wszUnknown);
        }

        dwType = REG_DWORD;
        dwData = 0;
        dwLen = sizeof(DWORD);
        Status = RegQueryValueEx(hCCRoot,
                                 WINSCNF_CC_USE_RPL_PNRS_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwLen);
        
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_CHECKAGAINST,
                           dwData ? wszRandom : wszOwner);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_CHECKAGAINST,
                           wszUnknown);
        }

        dwType = REG_DWORD;
        dwData = 0;
        dwLen = sizeof(DWORD);

        Status = RegQueryValueEx(hCCRoot,
                                 WINSCNF_CC_INTVL_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwLen);
        if( Status is NO_ERROR )
        {
            WCHAR Buffer[5] = {L'\0'};
            _itow(dwData/(60*60), Buffer, 10);
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_CHECKEVERY,
                           Buffer);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_CHECKEVERY,
                           wszUnknown);
        }

        memset(wcData, 0x00, 256*sizeof(WCHAR));

        dwType = REG_SZ;
        dwLen = 256*sizeof(WCHAR);

        Status = RegQueryValueEx(hCCRoot,
                                 WINSCNF_SP_TIME_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)wcData,
                                 &dwLen);
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_STARTAT,
                           wcData);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_STARTAT,
                           wszUnknown);
        }
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_WINS_LOGGING_PARAM);


    dwType = REG_DWORD;
    dwData = 0;
    dwLen = sizeof(DWORD);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_LOG_FLAG_NM,
                             0,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwLen);

    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_LOGGING_FLAG,
                       dwData ? wszEnable : wszDisable);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_LOGGING_FLAG,
                       wszUnknown);
    }

    dwType = REG_DWORD;
    dwData = 0;
    dwLen = sizeof(DWORD);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_LOG_DETAILED_EVTS_NM,
                             0,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwLen);

    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_LOGGING_DETAILS,
                       dwData ? wszEnable : wszDisable);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_LOGGING_DETAILS,
                       wszUnknown);
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_WINS_BURSTHNDL_PARAM);

    dwType = REG_DWORD;
    dwData = 0;
    dwLen = sizeof(DWORD);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_BURST_HANDLING_NM,
                             0,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwLen);

    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_BURSTHNDL_STATE,
                       dwData ? wszEnable : wszDisable);

        if( dwData > 0 )
        {
            dwType = REG_DWORD;
            dwData = 0;
            dwLen = sizeof(DWORD);

            Status = RegQueryValueEx(hParameter,
                            WINSCNF_BURST_QUE_SIZE_NM,
                            0,
                            &dwType,
                            (LPBYTE)&dwData,
                            &dwLen);

            if( Status is NO_ERROR )
            {
                WCHAR   Buffer[10] = {L'\0'};
                _itow(dwData, Buffer, 10);
                DisplayMessage(g_hModule,
                               MSG_WINS_BURSTHNDL_SIZE,
                               Buffer);
            }
            else
            {
                DisplayMessage(g_hModule,
                               MSG_WINS_BURSTHNDL_SIZE,
                               wszUnknown);
            }
                            
        }
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_BURSTHNDL_STATE,
                       wszUnknown);
    }

    DisplayMessage(g_hModule,
                   WINS_FORMAT_LINE);

    dwType = REG_DWORD;
    dwData = 0;
    dwLen = sizeof(DWORD);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_INIT_VERSNO_VAL_HW_NM,
                             NULL,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwLen);
    dwLow = 0;

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_INIT_VERSNO_VAL_LW_NM,
                             NULL,
                             &dwType,
                             (LPBYTE)&dwLow,
                             &dwLen);

    
    if(Status is NO_ERROR )
    {
        wsprintf(wcData, L" %x , %x", dwData, dwLow);
        DisplayMessage(g_hModule,
                       MSG_SRVR_START_VERSION,
                       wcData);
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( hCCRoot )
    {
        RegCloseKey(hCCRoot);
        hCCRoot = NULL;
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    return Status;

ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_INFO,
                        Status);
    goto CommonReturn;

}


DWORD
HandleSrvrShowPartner(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the list of Partners optionally based on the partner type.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Optional : Partner type - Pull or Push or Both(default)
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount, dwCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_TYPE, FALSE, FALSE}
                            };

    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    DWORD       p = 0;
    typedef enum {all=0, pull, push, both}eType;

    eType       Type = all;

    BOOL        fPush = TRUE,
                fPull = TRUE;
    HKEY        hServer = NULL,
                hPullRoot = NULL,
                hPushRoot = NULL;
    WCHAR       wcServerIpAdd[MAX_IP_STRING_LEN] = {L'\0'};
    WCHAR       wcServer[256] = {L'\0'};
    DWORD       dwLen = 0;
    typedef struct _Server_List {
        WCHAR   wcServerIpAddress[MAX_IP_STRING_LEN + 1];
        WCHAR   wcServerName[1024];
        eType   etype;
    }Server_List, *PServer_List;
    
    PServer_List pServerList = NULL;
                
            
    LPWSTR      pwszServerList = NULL;

    LPWSTR      pTemp = NULL;
    
    dwCount = 0;

    if( dwArgCount >= dwCurrentIndex + 1  )
    {
        dwNumArgs = dwArgCount - dwCurrentIndex;

        pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
        pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
        if( pdwTagType is NULL or
            pdwTagNum is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

        Status = PreProcessCommand(ppwcArguments,
                                   dwArgCount,
                                   dwCurrentIndex,
                                   pttTags,
                                   &dwTagCount,
                                   pdwTagType,
                                   pdwTagNum);
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
        {
            if( pttTags[i].dwRequired is TRUE and
                pttTags[i].bPresent is FALSE 
              )
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }

        for( j=0; j<dwTagCount; j++ )
        {
            switch(pdwTagType[j])
            {
            case 0:
                {
                    WCHAR wc = L'\0';

                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE or
                        wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 1 )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    
                    wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];

                    if( wc is L'0' )
                    {
                        Type = all;
                    }
                    if( wc is L'1' )
                    {
                        Type = pull;
                        break;
                    }
                    else if( wc is L'2' )
                    {
                        Type = push;
                        break;
                    }
                    else if ( wc is L'3' )
                    {
                        Type = both;
                        break;
                    }
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    break;
                }
            default:
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
            }
        }
    }

    if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegOpenKeyEx(hServer,
                          PULLROOT,
                          0,
                          KEY_READ,
                          &hPullRoot);
    if( Status isnot ERROR_FILE_NOT_FOUND and 
        Status isnot NO_ERROR ) 
        goto ErrorReturn;

    Status = RegOpenKeyEx(hServer,
                          PUSHROOT,
                          0,
                          KEY_READ,
                          &hPushRoot);
    
    if( Status isnot ERROR_FILE_NOT_FOUND and 
        Status isnot NO_ERROR ) 
        goto ErrorReturn;
    
    if( hPullRoot is NULL and
        hPushRoot is NULL )
    {        
        goto ErrorReturn;
    }

    Status = NO_ERROR;

    {
        DWORD dwSubkey = 0;
        HKEY  hKey = NULL;

        if (hPullRoot != NULL)
        {
            Status = RegQueryInfoKey(hPullRoot,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &dwSubkey,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL);

            if (Status isnot NO_ERROR)
            {
                goto ErrorReturn;
            }
        }

        if( dwSubkey > 0 )
        {
            pServerList = WinsAllocateMemory(dwSubkey*sizeof(Server_List));
            if( pServerList is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }

            for( j=0; j<dwSubkey; j++ )
            {
                DWORD dwLen = (MAX_IP_STRING_LEN + 1)*sizeof(WCHAR);
                DWORD dwType = REG_SZ;
                Status = RegEnumKeyEx(hPullRoot,
                                      j,
                                      pServerList[j].wcServerIpAddress,
                                      &dwLen,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);
                if( Status isnot NO_ERROR )
                {
                    if( Status is ERROR_FILE_NOT_FOUND )
                    {
                        continue;    
                    }
                    else
                    {
                        goto ErrorReturn;
                    }
                }
            
                Status = RegOpenKeyEx(hPullRoot,
                                      pServerList[j].wcServerIpAddress,
                                      0,
                                      KEY_READ,
                                      &hKey);
                if( Status isnot NO_ERROR )
                {
                    if( Status is ERROR_FILE_NOT_FOUND )
                    {
                        continue;    
                    }
                    else
                    {
                        goto ErrorReturn;
                    }
                }

                dwLen = 1024*sizeof(WCHAR);

                Status = RegQueryValueEx(hKey,
                                         L"NetBIOSName",
                                         0,
                                         &dwType,
                                         (LPBYTE)pServerList[j].wcServerName,
                                         &dwLen);
                if( Status isnot NO_ERROR )
                {
                    if( Status is ERROR_FILE_NOT_FOUND )
                    {
                        wcscpy(pServerList[j].wcServerName, wszUnknown);
                    }
                    else
                    {
                        goto ErrorReturn;
                    }
                }

                pServerList[j].etype = pull;
                RegCloseKey(hKey);
                hKey = NULL;
            }
        }

        i = dwSubkey;
        dwCount = i;
        Status = NO_ERROR;
        dwSubkey = 0;

        if (hPushRoot != NULL)
        {
            Status = RegQueryInfoKey(hPushRoot,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &dwSubkey,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL);

            if (Status isnot NO_ERROR)
            {
                goto ErrorReturn;
            }
        }

        if( dwSubkey > 0 )
        {
            PServer_List pTempList = NULL;

            if( pServerList )
                pTempList = pServerList;
            
            pServerList= WinsAllocateMemory((dwSubkey+i)*sizeof(Server_List));
            
            if( pServerList is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            
            memcpy(pServerList, pTempList, i*sizeof(Server_List));
            
            if( pTempList )
            {
                WinsFreeMemory(pTempList);
                pTempList = NULL;
            }

            p = 0;
            for( j=0; j<dwSubkey; j++ )
            {
                DWORD dwLen = (MAX_IP_STRING_LEN + 1)*sizeof(WCHAR);
                DWORD dwType = REG_SZ;
                WCHAR wcIpTemp[MAX_IP_STRING_LEN+1] = {L'\0'};
                DWORD k = 0;
                BOOL  fFind = FALSE;
                Status = RegEnumKeyEx(hPushRoot,
                                      j,
                                      wcIpTemp,
                                      &dwLen,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);
                if( Status isnot NO_ERROR )
                {
                    if( Status is ERROR_FILE_NOT_FOUND )
                    {
                        Status = NO_ERROR;
                        continue;
                    }
                    else
                    {
                        goto ErrorReturn;
                    }
                }
            
                for( k=0; k<i; k++ )
                {
                    if( _wcsicmp(pServerList[k].wcServerIpAddress, wcIpTemp) is 0 )
                    {
                        pServerList[k].etype = all;
                        fFind = TRUE;
                        break;
                    }
                }

                if( fFind is FALSE )
                {
                    wcscpy(pServerList[i+p].wcServerIpAddress, wcIpTemp);
                    Status = RegOpenKeyEx(hPushRoot,
                                          pServerList[i+p].wcServerIpAddress,
                                          0,
                                          KEY_READ,
                                          &hKey);
                    if( Status isnot NO_ERROR )
                    {
                        if( Status is ERROR_FILE_NOT_FOUND )
                        {
                            Status = NO_ERROR;
                            continue;    
                        }
                        else
                        {
                            goto ErrorReturn;
                        }
                    }

                    dwLen = 1024*sizeof(WCHAR);
    
                    Status = RegQueryValueEx(hKey,
                                             L"NetBIOSName",
                                             0,
                                             &dwType,
                                             (LPBYTE)pServerList[i+p].wcServerName,
                                             &dwLen);
                    if( Status isnot NO_ERROR )
                    {
                     
                        if( Status is ERROR_FILE_NOT_FOUND )
                        {
                            wcscpy(pServerList[i+p].wcServerName, wszUnknown);
                            Status = NO_ERROR;
                        }
                        else
                        {
                            goto ErrorReturn;
                        }
                    }
                    pServerList[i+p].etype = push;
                    RegCloseKey(hKey);
                    hKey = NULL;
                    p++;
                    dwCount++;
                }
                else
                    continue;
            }
        }
                                   
    }

    if( dwCount <= 0 )
    {
        DisplayMessage(g_hModule, MSG_WINS_NO_PARTNER);
    }
    else
    {
        DisplayMessage(g_hModule, WINS_FORMAT_LINE);
        DisplayMessage(g_hModule,
                       MSG_WINS_PARTNER_COUNT,
                       dwCount);

        DisplayMessage(g_hModule, WINS_FORMAT_LINE);
        DisplayMessage(g_hModule, MSG_WINS_PARTNERLIST_TABLE);
        
        

        for( j=0; j<dwCount; j++)
        {
            WCHAR   wcServer[32] = {L'\0'};       
            WCHAR   wcIp[25] = {L'\0'};
            DWORD   dwServerLen = 0;
            DWORD   k = 0;
            for( k=0; k<31; k++ )
                wcServer[k] = L' ';
            wcServer[31] = L'\0';

            for( k=0; k<24; k++ )
                wcIp[k] = L' ';
            wcIp[24] = L'\0';
            
            dwServerLen = MIN( 24, wcslen(pServerList[j].wcServerName) );
            switch(Type)
            {
            case all:
            default:
                {
                    

                    memcpy(wcServer+3, pServerList[j].wcServerName, dwServerLen*sizeof(WCHAR) );
                    memcpy(wcIp+3, pServerList[j].wcServerIpAddress, wcslen(pServerList[j].wcServerIpAddress)*sizeof(WCHAR));
                    DisplayMessage(g_hModule,
                                   MSG_WINS_PARTNERLIST_ENTRY,
                                   wcServer,
                                   wcIp,
                                   pServerList[j].etype is all ? wszPushpull:
                                   (pServerList[j].etype is pull) ? wszPull : wszPush);
                    break;
                }
            case pull:
                {
                    if( pServerList[j].etype is pull or
                        pServerList[j].etype is all )
                    {
                        memcpy(wcServer+3, pServerList[j].wcServerName, dwServerLen*sizeof(WCHAR));
                        memcpy(wcIp+3, pServerList[j].wcServerIpAddress, wcslen(pServerList[j].wcServerIpAddress)*sizeof(WCHAR));

                        DisplayMessage(g_hModule,
                                       MSG_WINS_PARTNERLIST_ENTRY,
                                       wcServer,
                                       wcIp,
                                       pServerList[j].etype is all ? wszPushpull : wszPull);
                                   
                    }
                    break;
                }
            case push:
                {
                    if( pServerList[j].etype is push or
                        pServerList[j].etype is all )
                    {
                        memcpy(wcServer+3, pServerList[j].wcServerName, dwServerLen*sizeof(WCHAR));
                        memcpy(wcIp+3, pServerList[j].wcServerIpAddress, wcslen(pServerList[j].wcServerIpAddress)*sizeof(WCHAR));

                        DisplayMessage(g_hModule,
                                       MSG_WINS_PARTNERLIST_ENTRY,
                                       wcServer,
                                       wcIp,
                                       pServerList[j].etype is all ? wszPushpull : wszPush);
                    }
                    break;
                }
            case both:
                {
                    if( pServerList[j].etype is all )
                    {
                        memcpy(wcServer+3, pServerList[j].wcServerName, dwServerLen*sizeof(WCHAR));
                        memcpy(wcIp+3, pServerList[j].wcServerIpAddress, wcslen(pServerList[j].wcServerIpAddress)*sizeof(WCHAR));

                        DisplayMessage(g_hModule,
                                       MSG_WINS_PARTNERLIST_ENTRY,
                                       wcServer,
                                       wcIp,
                                       wszPushpull);

                    }
                }

            }
        }
    }
    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( hPullRoot )
    {
        RegCloseKey(hPullRoot);
        hPullRoot = NULL;
    }

    if( hPushRoot )
    {
        RegCloseKey(hPushRoot);
        hPushRoot = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:

    if( Status is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_NO_PARTNER);
        Status = NO_ERROR;
    }
    else
    {
        DisplayErrorMessage(EMSG_SRVR_SHOW_PARTNER,
                            Status);
    }
    goto CommonReturn;
    

}

DWORD
HandleSrvrShowReccount(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the record count based on the version(optionally)
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Address of the server whose records to be counted
        Optional : Version range. Max and Min version both in the format {high,low}
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD               Status = NO_ERROR;
    DWORD               i, j, dwNumArgs, dwTagCount = 0;
    TAG_TYPE            pttTags[] = {
                                        {WINS_TOKEN_SERVER, TRUE, FALSE},
                                        {WINS_TOKEN_MAXVER, FALSE, FALSE},
                                        {WINS_TOKEN_MINVER, FALSE, FALSE},
                                    };
    WINSINTF_VERS_NO_T  MinVer={0}, MaxVer={0};
    WINSINTF_ADD_T      WinsAdd = {0};
    WINSINTF_RECS_T     Recs = {0};
    WCHAR               wcServerIpAdd[MAX_IP_STRING_LEN+1] = {L'\0'};
    LPWSTR              pwszTemp = NULL;
    LPDWORD             pdwTagType = NULL,
                        pdwTagNum = NULL;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SHOW_RECCOUNT_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch( pdwTagType[j] )
        {
        case 0:
            {
                struct  hostent * lpHostEnt = NULL;
                CHAR    cAddr[16];
                BYTE    pbAdd[4];
                char    szAdd[4];
                int     k = 0, l=0;
                DWORD   dwLen, nLen = 0;
                CHAR    *pTemp = NULL;
                CHAR    *pNetBios = NULL;

                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) )
                {
                    DWORD dwIp = inet_addr(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL));
                    lpHostEnt = gethostbyaddr((char *)&dwIp, 4, AF_INET);
                    if(lpHostEnt isnot NULL )//Valid IP Address
                    {
                        wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                        break;
                    }
                    else
                    {
                        Status = WSAGetLastError();
                        goto ErrorReturn;
                    }
                }

                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 2 and
                        _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"\\\\", 2) is 0 )
                        k = 2;

                lpHostEnt = gethostbyname(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k, NULL));
                if( lpHostEnt is NULL )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_WINS_INVALID_COMPUTER_NAME,
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k);
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;                                       
                }

                memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
                for( l=0;l<4; l++)
                {
                    _itoa((int)pbAdd[l], szAdd, 10);
                    memcpy(cAddr+nLen, szAdd, strlen(szAdd));
                    nLen += strlen(szAdd);
                    *(cAddr+nLen) = '.';
                    nLen++;

                }
                *(cAddr+nLen-1) = '\0';
                {
                    LPWSTR pstr = WinsAnsiToUnicode(cAddr, NULL);
                    if (pstr != NULL)
                    {
                        wcscpy(wcServerIpAdd, pstr);
                        WinsFreeMemory(pstr);
                    }
                    else
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }
                }
                break;
            }
        case 1:
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MaxVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }
        case 2:
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MinVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
     
    WinsAdd.IPAdd = StringToIpAddress(wcServerIpAdd);
    WinsAdd.Len = 4;
    WinsAdd.Type = 0;

    Status = WinsGetDbRecs(g_hBind, 
                           &WinsAdd, 
                           MinVer, 
                           MaxVer, 
                           &Recs);


    if( Status isnot NO_ERROR )
        goto ErrorReturn;
    
    DisplayMessage(g_hModule,
                   MSG_WINS_RECORDS_COUNT_OWNER,
                   wcServerIpAdd,
                   Recs.TotalNoOfRecs);

    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);

CommonReturn:
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;        
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( Recs.pRow )
    {
        WinsFreeMem(Recs.pRow);
        Recs.pRow = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_RECCOUNT,
                        Status);
    goto CommonReturn;
}


DWORD
HandleSrvrShowRecbyversion(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays records based on Version range, filtered by 16th char
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Address of the server whose records to be displayed
        Optional : Version range. Max and Min version both in the format {high,low},
                   16th character, Name etc
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD               Status = NO_ERROR;
    DWORD               i, j, dwTagCount, dwNumArgs;
    TAG_TYPE            pttTags[] = {
                                        {WINS_TOKEN_SERVER, TRUE, FALSE},
                                        {WINS_TOKEN_MAXVER, FALSE, FALSE},
                                        {WINS_TOKEN_MINVER, FALSE, FALSE},
                                        {WINS_TOKEN_NAME, FALSE, FALSE},
                                        {WINS_TOKEN_ENDCHAR, FALSE, FALSE},
                                        {WINS_TOKEN_CASE, FALSE, FALSE},
                                    };
    WCHAR               wcName[17] = {L'\0'};
    LPWSTR              pwcScope = NULL;
    CHAR                ch16thChar = 0x00;
    DWORD               dwNameLen = 0;
    WINSINTF_VERS_NO_T  MinVer={0}, MaxVer={0};
    WINSINTF_ADD_T      WinsAdd = {0};
    WINSINTF_RECS_T     Recs = {0};
    WCHAR               wcServerIpAdd[MAX_IP_STRING_LEN+1] = {L'\0'};
    WCHAR               wcFile[MAX_PATH] = {L'\0'};
    LPWSTR              pwszTemp = NULL;
    BOOL                fEndChar = FALSE,
                        fCase = FALSE,
                        fFile = FALSE,
                        fName = FALSE;
    LPDWORD             pdwTagType = NULL,
                        pdwTagNum = NULL;
    LPSTR               pszTempAddr = NULL;
    LPSTR               lpName = NULL;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SHOW_RECBYVERSION_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    for( j=0; j<dwTagCount; j++ )
    {
        switch( pdwTagType[j] )
        {
        case 0:
            {
                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) )
                {
                    wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        case 1:
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MaxVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }
        case 2:
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MinVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }
        case 3:
            {
                wcsncpy(wcName, ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 15);
                fName = TRUE;
                break;
            }
        case 4:
            {
                DWORD dwLen = 0, k=0;
                fEndChar = TRUE;
                dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen > 2 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                        
                }
                
                for( k=0; k<dwLen; k++ )
                {
                    WCHAR  wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][k];
                    if( towlower(wc) >= L'a' and
                        towlower(wc) <= L'z' )
                    {
                        if( towlower(wc) > L'f' )
                        {
                            Status = ERROR_INVALID_PARAMETER;
                            goto ErrorReturn;
                        }                    
                    }
                }
                ch16thChar = StringToHexA(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                break;
            }
        case 5:
            {
                WCHAR wc = L'\0';
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) isnot 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'0' )
                {
                    fCase = FALSE;
                }
                else if( wc is L'1' )
                {
                    fCase = TRUE;
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;

            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
    
    for( j=0; j<sizeof(pttTags)/sizeof(TAG_TYPE); j++ )
    {
        if( pttTags[j].dwRequired is TRUE and
            pttTags[j].bPresent is FALSE )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }
    
    if( fName )
    {
     
        //Process the name option if present
        lpName = WinsUnicodeToOem(wcName, NULL);
        if( lpName is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        dwNameLen = strlen(lpName);

        if( dwNameLen >= 16 )
        {
            DisplayMessage(g_hModule,
                           EMSG_SRVR_INVALID_NETBIOS_NAME);
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        if( fEndChar)
        {
            LPSTR pTemp = lpName;
            lpName = WinsAllocateMemory(17);
            if( lpName is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            strcpy(lpName, pTemp);
            for( i=strlen(pTemp); i<16; i++ )
            {
                lpName[i] = ' ';
            }
            lpName[15] = ch16thChar;
            lpName[16] = '\0';

            WinsFreeMemory(pTemp);
            dwNameLen = 16;
        }
    }   



    WinsAdd.IPAdd = StringToIpAddress(wcServerIpAdd);
    WinsAdd.Len = 4;
    WinsAdd.Type = 0;

    pszTempAddr = WinsUnicodeToOem(wcServerIpAdd, NULL);

    if( pszTempAddr is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    Status = GetDbRecs(MinVer,
                       MaxVer,
                       &WinsAdd,
                       pszTempAddr,
                       fName,
                       lpName,
                       dwNameLen,
                       FALSE,
                       0,
                       FALSE,
                       fCase,
                       fFile,
                       fFile ? wcFile : NULL);

    WinsFreeMemory(pszTempAddr);
    pszTempAddr = NULL;

    if( lpName )
    {
        WinsFreeMemory(lpName);
        lpName = NULL;
    }
    if( Status isnot NO_ERROR )
        goto ErrorReturn;
    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);
CommonReturn:
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_RECBYVERSION,
                        Status);
    goto CommonReturn;
}


DWORD
HandleSrvrShowName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays detail information for a particular name records
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Name of the records
        Optional : 16th character and Scope
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount = 0;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_NAME, TRUE, FALSE},
                                {WINS_TOKEN_ENDCHAR, FALSE, FALSE},
                                {WINS_TOKEN_SCOPE, FALSE, FALSE}
                            };
    PDWORD      pdwTagNum = NULL,
                pdwTagType = NULL;

    WCHAR       wszName[MAX_STRING_LEN+4] = {L'\0'};
    BOOL        fEndChar = FALSE;
    CHAR        ch16thChar = 0x00;
    BOOL        fScope = FALSE;
    WCHAR       wszScope[MAX_STRING_LEN] = {L'\0'};
    
    DWORD       dwStrLen = 0;
    LPWSTR      pwszTemp = NULL;
    WINSINTF_RECORD_ACTION_T    RecAction = {0};
    PWINSINTF_RECORD_ACTION_T   pRecAction = NULL;
    LPWSTR      pwszGroup = NULL,
                pwszState = NULL,
                pwszType = NULL;
    CHAR        chEndChar = (CHAR)0x00;

    WCHAR       wszGroup[50] = {L'\0'},
                wszState[50] = {L'\0'},
                wszType[50] = {L'\0'};
    DWORD       dwTempLen = 0;

    struct  tm* time = NULL;
    DWORD       dwGroup = WINS_GROUP_UNIQUE;
    DWORD       dwState = WINS_STATE_ACTIVE;
    DWORD       dwType = WINS_TYPE_STATIC;
    DWORD       dwGrouplen = 0,
                dwStatelen = 0,
                dwTypelen = 0;
    LPSTR       pszTemp = NULL;
    LPWSTR      pwszTime = NULL;
    int         iType = 1;

    memset(&RecAction, 0x00, sizeof(WINSINTF_RECORD_ACTION_T));
    RecAction.fStatic = TRUE;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SHOW_NAME_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    i = dwTagCount;
    
    for( j=0; j<i; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                DWORD dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dwLen = ( 255 < dwLen ) ? 255 : dwLen;
                memcpy(wszName, 
                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 
                       dwLen*sizeof(WCHAR));
                wszName[dwLen] = L'\0';               
                break;
            }
        case 1:
            {
                DWORD dwLen = 0, k=0;
                fEndChar = TRUE;
                dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen > 2 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                        
                }
                
                for( k=0; k<dwLen; k++ )
                {
                    WCHAR  wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][k];
                    if( towlower(wc) >= L'a' and
                        towlower(wc) <= L'z' )
                    {
                        if( towlower(wc) > L'f' )
                        {
                            Status = ERROR_INVALID_PARAMETER;
                            goto ErrorReturn;
                        }                    
                    }
                }
                ch16thChar = StringToHexA(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                break;
            }
        case 2:
            {
                DWORD dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                fScope = TRUE;
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dwLen = ( 255 < dwLen ) ? 255 : dwLen;
                memcpy(wszScope,
                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 
                       dwLen*sizeof(WCHAR));
                wszScope[dwLen] = L'\0';               
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
           
    _wcsupr(wszName);
    _wcsupr(wszScope);
      
    wszName[16] = L'\0';

    pszTemp = WinsUnicodeToOem(wszName, NULL);

    if( pszTemp is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwStrLen = strlen(pszTemp);


    if( dwStrLen >= 16 )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_NETBIOS_NAME);
        Status = ERROR_INVALID_PARAMETER;
        WinsFreeMemory(pszTemp);
        pszTemp = NULL;
        goto ErrorReturn;
    }

    RecAction.pName = WinsAllocateMemory(273);

    if( RecAction.pName is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    strncpy(RecAction.pName, pszTemp, 16);
    
    WinsFreeMemory(pszTemp);
    pszTemp = NULL;

    for( i = dwStrLen; i<16; i++ )
    {
        RecAction.pName[i] = ' ';        
    }

    if( fEndChar )
    {
        RecAction.pName[15] = ch16thChar;
    }
    if( fEndChar and 
        ch16thChar is 0x00 )
        RecAction.pName[15] = 0x00;
    RecAction.pName[16] = '\0';

    dwStrLen = 16;

    if( fScope )
    {
        DWORD dwLen;

        RecAction.pName[dwStrLen] = '.';
        
        pszTemp = WinsUnicodeToOem(wszScope, NULL);
        
        if( pszTemp is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        dwLen = strlen(pszTemp);
        dwLen = ( 255 - dwStrLen < dwLen ) ? 255 - dwStrLen : dwLen;
        
        strncpy(RecAction.pName + dwStrLen + 1, pszTemp, dwLen);

        WinsFreeMemory(pszTemp);
        pszTemp = NULL;

        RecAction.pName[dwLen + dwStrLen + 1] = '\0';
        if( fEndChar and 
            ch16thChar is 0x00 )
            dwStrLen = 16+dwLen+1;
        else
            dwStrLen = strlen(RecAction.pName);
    }
    else
    {

        RecAction.pName[dwStrLen] = '\0';
    }


    RecAction.NameLen = dwStrLen;

    RecAction.Cmd_e = WINSINTF_E_QUERY;

    RecAction.OwnerId = StringToIpAddress(g_ServerIpAddressUnicodeString);
   
    RecAction.NameLen = dwStrLen;
    pRecAction = &RecAction;

    Status = WinsRecordAction(g_hBind, &pRecAction);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    RecAction.pName[RecAction.NameLen] = L'\0';

    memset(wszName, 0x00, MAX_STRING_LEN*sizeof(WCHAR));
    
    if( pRecAction->NameLen >= 16 )
    {
        chEndChar = pRecAction->pName[15];
        pRecAction->pName[15] = 0x00;
    }
    else
    {
        chEndChar = pRecAction->pName[pRecAction->NameLen];
        pRecAction->pName[pRecAction->NameLen] = 0x00;
    }
    
    pwszTemp = WinsOemToUnicode(pRecAction->pName, NULL);
    
    if( pwszTemp is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }
    
    wcscpy(wszName, pwszTemp);

    WinsFreeMemory(pwszTemp);
    pwszTemp = NULL;

    for( i=wcslen(wszName); i<16; i++ )
    {
        wszName[i] = L' ';
    }

    wszName[15] = L'[';
    WinsHexToString(wszName+16, (LPBYTE)&chEndChar, 1);
    wszName[18] = L'h';
    wszName[19] = L']';

    if( pRecAction->NameLen > 16 )
    {
        pwszTemp = WinsOemToUnicode(pRecAction->pName+16, NULL);
        
        if( pwszTemp is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        wcscpy(wszName + 20 , pwszTemp);
        WinsFreeMemory(pwszTemp);
        pwszTemp = NULL;
        wszName[wcslen(wszName)] = L'\0';
    }
    else
    {
        wszName[20] = L'\0';
    }
    
    if( pRecAction->pName[15] is 0x1C )
    {
        pwszGroup = L"DOMAIN NAME";
        dwGroup = WINS_GROUP_DOMAIN;
    }
    else if( pRecAction->TypOfRec_e is WINSINTF_E_UNIQUE )
    {
        pwszGroup = L"UNIQUE";
        dwGroup = WINS_GROUP_UNIQUE;
    }
    else if( pRecAction->TypOfRec_e is WINSINTF_E_NORM_GROUP )
    {
        pwszGroup = L"GROUP";
        dwGroup = WINS_GROUP_GROUP;
    }
    else if( pRecAction->TypOfRec_e is WINSINTF_E_SPEC_GROUP )
    {
        pwszGroup = L"INTERNET GROUP";
        dwGroup = WINS_GROUP_INTERNET;
    }
    else
    {
        pwszGroup = L"MULTIHOMED";
        dwGroup = WINS_GROUP_MULTIHOMED;
    }

    //Load the group string
    {
        dwGrouplen = LoadStringW(g_hModule,
                                dwGroup,
                                wszGroup,
                                sizeof(wszGroup)/sizeof(WCHAR));

        if( dwGrouplen is 0 )
            wcscpy(wszGroup, pwszGroup);
    }

    pwszTime = GetDateTimeString(pRecAction->TimeStamp,
                                 FALSE,
                                 &iType);
    
    if( pRecAction->State_e is WINSINTF_E_ACTIVE )
    {
        pwszState = L"ACTIVE";
        dwState = WINS_STATE_ACTIVE;
    }
    else if( pRecAction->State_e is WINSINTF_E_RELEASED )
    {
        dwState = WINS_STATE_RELEASED;
        pwszState = L"RELEASED";
    }
    else
    {
        dwState = WINS_STATE_TOMBSTONE;
        pwszState = L"TOMBSTONE";
    }

    //Load the State string
    {
        dwStatelen = LoadStringW(g_hModule,
                                dwState,
                                wszState,
                                sizeof(wszState)/sizeof(WCHAR));

        if( dwStatelen is 0 )
            wcscpy(wszState, pwszState);
    }



    if( pRecAction->fStatic )
    {
        dwType = WINS_TYPE_STATIC;
        pwszType = L"STATIC";
    }
    else
    {
        dwType = WINS_TYPE_DYNAMIC;
        pwszType = L"DYNAMIC";
    }

    //Load the State string
    {
        dwTypelen = LoadStringW(g_hModule,
                               dwType,
                               wszType,
                               sizeof(wszType)/sizeof(WCHAR));

        if( dwTypelen is 0 )
            wcscpy(wszType, pwszType);
    }
    
    DisplayMessage( g_hModule,
                    MSG_WINS_DISPLAY_NAME,
                    wszName,
                    pRecAction->NodeTyp,
                    wszState,
                    iType ? wszInfinite : pwszTime,
                    wszGroup,
                    pRecAction->VersNo.HighPart,
                    pRecAction->VersNo.LowPart,
                    wszType);
    
    if( pwszTime )
    {
        WinsFreeMemory(pwszTime);
        pwszTime = NULL;
    }

    if ( ( pRecAction->pName[15] isnot 0x1C and
           pRecAction->pName[15] isnot 0x1E ) and
         ( pRecAction->TypOfRec_e is WINSINTF_E_UNIQUE or
            pRecAction->TypOfRec_e is WINSINTF_E_NORM_GROUP )
       )
    {      
        DisplayMessage(g_hModule,
                       MSG_WINS_IPADDRESS_STRING,
                       IpAddressToString(pRecAction->Add.IPAdd));        
    }
    else
    {
       for (i=0; i<pRecAction->NoOfAdds; )
       {
           DisplayMessage(g_hModule,
                          MSG_WINS_OWNER_ADDRESS,
                          IpAddressToString((pRecAction->pAdd + i++)->IPAdd));
           DisplayMessage(g_hModule,
                          MSG_WINS_MEMBER_ADDRESS,
                          IpAddressToString((pRecAction->pAdd + i++)->IPAdd));
       }
    }


    //If UNIQUE, look for 0x00 and 0x03 records also
    if( ( pRecAction->TypOfRec_e is WINSINTF_E_UNIQUE or
          pRecAction->TypOfRec_e is WINSINTF_E_MULTIHOMED ) and
        fEndChar is FALSE )
    {
        
        DWORD dwNameLen = RecAction.NameLen;

        DisplayMessage(g_hModule,
                       WINS_FORMAT_LINE);

        RecAction.pName[15] = 0x00;
        RecAction.NameLen = 16;
        pRecAction = &RecAction;

        Status = WinsRecordAction(g_hBind, &pRecAction);

        if( Status is NO_ERROR )
        {
        
            RecAction.pName[RecAction.NameLen] = L'\0';

            memset(wszName, 0x00, MAX_STRING_LEN*sizeof(WCHAR));
            
            pwszTemp = WinsOemToUnicode(pRecAction->pName, NULL);
            if( pwszTemp is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            wcscpy(wszName, pwszTemp);
            
            WinsFreeMemory(pwszTemp);
            pwszTemp = NULL;

            for( i=wcslen(wszName); i<16; i++ )
            {
                wszName[i] = L' ';
            }

            for( i=wcslen(wszName)+3; j>=15; j-- )
                wszName[j-1] = wszName[j-4];
            
            wszName[15] = L'[';
            WinsHexToString(wszName+16, (LPBYTE)(pRecAction->pName+15), 1);
            wszName[18] = L'h';
            wszName[19] = L']';

            if( pRecAction->NameLen > 16 )
            {
                pwszTemp = WinsOemToUnicode(pRecAction->pName+16, NULL);
                if( pwszTemp is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }

                wcscpy(wszName + 20 , pwszTemp);
                WinsFreeMemory(pwszTemp);
                pwszTemp = NULL;
                wszName[wcslen(wszName)] = L'\0';
            }
            else
            {
                wszName[20] = L'\0';
            }

            iType = 1;
            pwszTime = GetDateTimeString(pRecAction->TimeStamp,
                                         FALSE,
                                         &iType);

            DisplayMessage( g_hModule,
                            MSG_WINS_DISPLAY_NAME,
                            wszName,
                            pRecAction->NodeTyp,
                            wszState,
                            iType ? wszInfinite : pwszTime,
                            wszGroup,
                            pRecAction->VersNo.HighPart,
                            pRecAction->VersNo.LowPart,
                            wszType);
            
            if( pwszTime )
            {
                WinsFreeMemory(pwszTime);
                pwszTime = NULL;
            }

            if( pRecAction->TypOfRec_e is WINSINTF_E_UNIQUE ) 
            {      
                DisplayMessage(g_hModule,
                               MSG_WINS_IPADDRESS_STRING,
                               IpAddressToString(pRecAction->Add.IPAdd));        
            }
        
            else
            {
               for (i=0; i<pRecAction->NoOfAdds; )
               {
                   DisplayMessage(g_hModule,
                                  MSG_WINS_OWNER_ADDRESS,
                                  IpAddressToString((pRecAction->pAdd + i++)->IPAdd));
                   DisplayMessage(g_hModule,
                                  MSG_WINS_MEMBER_ADDRESS,
                                  IpAddressToString((pRecAction->pAdd + i++)->IPAdd));
                }
            }                    
            
        }
        
        
        DisplayMessage(g_hModule,
                       WINS_FORMAT_LINE);

        //Now Look for 0x03 record
        if( fScope )
        {
            DWORD dwLen;
            dwStrLen = 16;
            RecAction.pName[dwStrLen] = '.';
            pszTemp = WinsUnicodeToOem(wszScope, NULL);
            if( pszTemp is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            dwLen = strlen(pszTemp);
            dwLen = ( 255 - dwStrLen < dwLen ) ? 255 - dwStrLen : dwLen;
            
            strncpy(RecAction.pName + dwStrLen + 1, pszTemp, dwLen);
            
            WinsFreeMemory(pszTemp);
            pszTemp = NULL;

            RecAction.pName[dwLen + dwStrLen + 1] = '\0';
            if( fEndChar and 
                ch16thChar is 0x00 )
                dwStrLen = 16+dwLen+1;
            else
                dwStrLen = strlen(RecAction.pName);
        }
        else
        {

            RecAction.pName[dwStrLen] = '\0';
        }


        RecAction.pName[15] = 0x03;
        RecAction.NameLen = dwNameLen;

        pRecAction = &RecAction;
               
        Status = WinsRecordAction(g_hBind, &pRecAction);

        if( Status is NO_ERROR )
        {       
            
            CHAR chEndChar = pRecAction->pName[15];

            RecAction.pName[RecAction.NameLen] = L'\0';

            memset(wszName, 0x00, MAX_STRING_LEN*sizeof(WCHAR));

            if( pRecAction->NameLen >= 16 )
            {
                chEndChar = pRecAction->pName[15];
                pRecAction->pName[15] = 0x00;
            }
            else
            {
                chEndChar = pRecAction->pName[pRecAction->NameLen];
                pRecAction->pName[pRecAction->NameLen] = 0x00;
            }
            
            pwszTemp = WinsOemToUnicode(pRecAction->pName, NULL);
            
            if( pwszTemp is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            
            
            wcscpy(wszName, pwszTemp);
            
            WinsFreeMemory(pwszTemp);
            pwszTemp = NULL;

            for( i = wcslen(wszName); i < 16; i++ )
            {
                wszName[i] = L' ';
            }

            for( i=wcslen(wszName)+3; j>=15; j-- )
                wszName[j-1] = wszName[j-4];

            wszName[15] = L'[';
            WinsHexToString(wszName+16, (LPBYTE)&chEndChar, 1);
            wszName[18] = L'h';
            wszName[19] = L']';

            if( pRecAction->NameLen > 16 )
            {
                pwszTemp = WinsOemToUnicode(pRecAction->pName+16, NULL);
                if( pwszTemp is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(wszName + 20 , pwszTemp);
                
                WinsFreeMemory(pwszTemp);
                pwszTemp = NULL;
                
                wszName[wcslen(wszName)] = L'\0';
            }
            else
            {
                wszName[20] = L'\0';
            }
    
            iType = 1;
            pwszTime = GetDateTimeString(pRecAction->TimeStamp,
                                         FALSE,
                                         &iType);

            DisplayMessage(g_hModule,
                           MSG_WINS_DISPLAY_NAME,
                           wszName,
                           pRecAction->NodeTyp,
                           wszState,
                           iType ? wszInfinite : pwszTime,
                           wszGroup,
                           pRecAction->VersNo.HighPart,
                           pRecAction->VersNo.LowPart,
                           wszType);
    
            if( pwszTime )
            {
                WinsFreeMemory(pwszTime);
                pwszTime = NULL;
            }

            if( pRecAction->TypOfRec_e is WINSINTF_E_UNIQUE ) 
            {      
                DisplayMessage(g_hModule,
                               MSG_WINS_IPADDRESS_STRING,
                               IpAddressToString(pRecAction->Add.IPAdd));        
            }
        
            else
            {
               for (i=0; i<pRecAction->NoOfAdds; )
               {
                   DisplayMessage(g_hModule,
                                  MSG_WINS_OWNER_ADDRESS,
                                  IpAddressToString((pRecAction->pAdd + i++)->IPAdd));
                   DisplayMessage(g_hModule,
                                  MSG_WINS_MEMBER_ADDRESS,
                                  IpAddressToString((pRecAction->pAdd + i++)->IPAdd));
                }
            }
        }
    }

CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( pszTemp )
    {
        WinsFreeMemory(pszTemp);
        pszTemp = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( RecAction.pName )
    {
        WinsFreeMemory(RecAction.pName);
        RecAction.pName = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_NAME,
                        Status);
    goto CommonReturn;
}


DWORD
HandleSrvrShowServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the current WINS server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{
    DisplayMessage(g_hModule,
                   MSG_WINS_SERVER_NAME,
                   g_ServerNameUnicode,
                   g_ServerIpAddressUnicodeString);
    return NO_ERROR;
                   
}


DWORD
HandleSrvrShowStatistics(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the Server statistics
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{

    DWORD                   Status = NO_ERROR;
    WINSINTF_RESULTS_T      Results = {0};
    WINSINTF_RESULTS_NEW_T  ResultsN = {0};
    WCHAR                   IpAddress[33] = {L'\0'};
    WCHAR                   RepCount[25] = {L'\0'};
    WCHAR                   Buffer[8] = {L'\0'};
    BOOL                    fNew = TRUE;
    DWORD                   i = 0,
                            k = 0;

    ResultsN.WinsStat.NoOfPnrs = 0;
    ResultsN.WinsStat.pRplPnrs = NULL;
    ResultsN.pAddVersMaps = NULL;

    Status = WinsStatusNew(g_hBind, WINSINTF_E_STAT, &ResultsN);
    
    if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
    {
        //Try old API
        Results.WinsStat.NoOfPnrs = 0;
        Results.WinsStat.pRplPnrs = 0;
        Status = WinsStatus(g_hBind, WINSINTF_E_CONFIG_ALL_MAPS, &Results);
        fNew = FALSE;
    }
    
    if( Status isnot NO_ERROR )
    {
        DisplayErrorMessage(EMSG_SRVR_SHOW_STATISTICS,
                            Status);
    }

    if( fNew )
    {
        DisplayMessage(g_hModule, 
                       MSG_WINS_TIMESTAMP,
                       TMSTN.WinsStartTime.wMonth,
                       TMSTN.WinsStartTime.wDay,
                       TMSTN.WinsStartTime.wYear,
                       TMSTN.WinsStartTime.wHour,
                       TMSTN.WinsStartTime.wMinute,
                       TMSTN.WinsStartTime.wSecond
                       );

        DisplayMessage(g_hModule,
                       MSG_WINS_LAST_INIT,
                       TIME_ARGSN(LastInitDbTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_PLANNED_SCV,
                       TIME_ARGSN(LastPScvTime));
    
        DisplayMessage(g_hModule,
                       MSG_WINS_TRIGGERED_SCV,
                       TIME_ARGSN(LastATScvTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_TOMBSTONE_SCV,
                       TIME_ARGSN(LastTombScvTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_REPLICA_VERIFICATION,
                       TIME_ARGSN(LastVerifyScvTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_PLANNED_REPLICATION,
                       TMSTN.LastPRplTime.wMonth,
                       TMSTN.LastPRplTime.wDay,
                       TMSTN.LastPRplTime.wYear,
                       TMSTN.LastPRplTime.wHour,
                       TMSTN.LastPRplTime.wMinute,
                       TMSTN.LastPRplTime.wSecond
                       );

        DisplayMessage(g_hModule,
                       MSG_WINS_TRIGGERED_REPLICATION,
                       TMSTN.LastATRplTime.wMonth,
                       TMSTN.LastATRplTime.wDay,
                       TMSTN.LastATRplTime.wYear,
                       TMSTN.LastATRplTime.wHour,
                       TMSTN.LastATRplTime.wMinute,
                       TMSTN.LastATRplTime.wSecond
                       );

        DisplayMessage(g_hModule,
                       MSG_WINS_RESET_COUNTER,
                       TIME_ARGSN(CounterResetTime));

        DisplayMessage(g_hModule, WINS_FORMAT_LINE);
        DisplayMessage(g_hModule,
                       MSG_WINS_COUNTER_INFORMATION,
                       ResultsN.WinsStat.Counters.NoOfUniqueReg,
                       ResultsN.WinsStat.Counters.NoOfGroupReg,
                       ResultsN.WinsStat.Counters.NoOfSuccQueries,
                       ResultsN.WinsStat.Counters.NoOfFailQueries,
                       ResultsN.WinsStat.Counters.NoOfUniqueRef,
                       ResultsN.WinsStat.Counters.NoOfGroupRef,
                       ResultsN.WinsStat.Counters.NoOfSuccRel,
                       ResultsN.WinsStat.Counters.NoOfFailRel,
                       ResultsN.WinsStat.Counters.NoOfUniqueCnf,
                       ResultsN.WinsStat.Counters.NoOfGroupCnf
                       );
    
        if (ResultsN.WinsStat.NoOfPnrs)
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PARTNER_TABLE);

            for (i =0; i < ResultsN.WinsStat.NoOfPnrs; i++)
            {
                LPTSTR pstr;

                for(k=0; k<32; k++)
                {
                    IpAddress[k] = L' ';
                }
                IpAddress[32] = L'\0';
                for(k=0; k<24; k++)
                    RepCount[k] = L' ';
                RepCount[24] = L'\0';
            
                pstr = IpAddressToString((ResultsN.WinsStat.pRplPnrs + i)->Add.IPAdd);
                if (pstr == NULL)
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                wcscpy(IpAddress+8, pstr);
                IpAddress[wcslen(IpAddress)] = L' ';
            
                _itow((ResultsN.WinsStat.pRplPnrs + i)->NoOfRpls, Buffer, 10);
                wcscpy(RepCount+8, Buffer);
                RepCount[wcslen(RepCount)] = L' ';

                DisplayMessage(g_hModule,
                               MSG_WINS_PARTNER_INFO,
                               IpAddress,
                               RepCount,
                               (ResultsN.WinsStat.pRplPnrs + i)->NoOfCommFails
                               );
            }
        }

        WinsFreeMem(ResultsN.pAddVersMaps);
        ResultsN.pAddVersMaps = NULL;
        WinsFreeMem(ResultsN.WinsStat.pRplPnrs);
        ResultsN.WinsStat.pRplPnrs = NULL;
    }
    else
    {
        DisplayMessage(g_hModule, 
                       MSG_WINS_TIMESTAMP,
                       TMST.WinsStartTime.wMonth,
                       TMST.WinsStartTime.wDay,
                       TMST.WinsStartTime.wYear,
                       TMST.WinsStartTime.wHour,
                       TMST.WinsStartTime.wMinute,
                       TMST.WinsStartTime.wSecond
                       );

        DisplayMessage(g_hModule,
                       MSG_WINS_LAST_INIT,
                       TIME_ARGS(LastInitDbTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_PLANNED_SCV,
                       TIME_ARGS(LastPScvTime));
    
        DisplayMessage(g_hModule,
                       MSG_WINS_TRIGGERED_SCV,
                       TIME_ARGS(LastATScvTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_TOMBSTONE_SCV,
                       TIME_ARGS(LastTombScvTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_REPLICA_VERIFICATION,
                       TIME_ARGS(LastVerifyScvTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_PLANNED_REPLICATION,
                       TMST.LastPRplTime.wMonth,
                       TMST.LastPRplTime.wDay,
                       TMST.LastPRplTime.wYear,
                       TMST.LastPRplTime.wHour,
                       TMST.LastPRplTime.wMinute,
                       TMST.LastPRplTime.wSecond
                       );

        DisplayMessage(g_hModule,
                       MSG_WINS_TRIGGERED_REPLICATION,
                       TMST.LastATRplTime.wMonth,
                       TMST.LastATRplTime.wDay,
                       TMST.LastATRplTime.wYear,
                       TMST.LastATRplTime.wHour,
                       TMST.LastATRplTime.wMinute,
                       TMST.LastATRplTime.wSecond
                       );

        DisplayMessage(g_hModule,
                       MSG_WINS_RESET_COUNTER,
                       TIME_ARGS(CounterResetTime));

        DisplayMessage(g_hModule, WINS_FORMAT_LINE);
        DisplayMessage(g_hModule,
                       MSG_WINS_COUNTER_INFORMATION,
                       Results.WinsStat.Counters.NoOfUniqueReg,
                       Results.WinsStat.Counters.NoOfGroupReg,
                       Results.WinsStat.Counters.NoOfSuccQueries,
                       Results.WinsStat.Counters.NoOfFailQueries,
                       Results.WinsStat.Counters.NoOfUniqueRef,
                       Results.WinsStat.Counters.NoOfGroupRef,
                       Results.WinsStat.Counters.NoOfSuccRel,
                       Results.WinsStat.Counters.NoOfFailRel,
                       Results.WinsStat.Counters.NoOfUniqueCnf,
                       Results.WinsStat.Counters.NoOfGroupCnf
                       );
    
        if (Results.WinsStat.NoOfPnrs)
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PARTNER_TABLE);

            for (i =0; i < Results.WinsStat.NoOfPnrs; i++)
            {

                for(k=0; k<32; k++)
                {
                    IpAddress[k] = L' ';
                }
                IpAddress[32] = L'\0';
                for(k=0; k<24; k++)
                    RepCount[k] = L' ';
                RepCount[24] = L'\0';
            
                wcscpy(IpAddress+8, IpAddressToString((Results.WinsStat.pRplPnrs + i)->Add.IPAdd));
                IpAddress[wcslen(IpAddress)] = L' ';
            
                _itow((Results.WinsStat.pRplPnrs + i)->NoOfRpls, Buffer, 10);
                wcscpy(RepCount+8, Buffer);
                RepCount[wcslen(RepCount)] = L' ';

                DisplayMessage(g_hModule,
                               MSG_WINS_PARTNER_INFO,
                               IpAddress,
                               RepCount,
                               (Results.WinsStat.pRplPnrs + i)->NoOfCommFails
                               );
            }
        }

        WinsFreeMem(Results.WinsStat.pRplPnrs);
        Results.WinsStat.pRplPnrs = NULL;

    }

    DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    return Status;
                   
}

DWORD
HandleSrvrShowVersion(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displas the current version counter value.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD               Status = NO_ERROR;
    WINSINTF_RESULTS_T  Results;

    Results.AddVersMaps[0].Add.Len   = 4;
    Results.AddVersMaps[0].Add.Type  = 0;
    Results.AddVersMaps[0].Add.IPAdd = StringToIpAddress(g_ServerIpAddressUnicodeString);
    
    Results.WinsStat.NoOfPnrs = 0;
    Results.WinsStat.pRplPnrs = NULL;
    Status = WinsStatus(g_hBind, WINSINTF_E_ADDVERSMAP, &Results);
    
    if( Status isnot NO_ERROR )
    {
        DisplayErrorMessage(EMSG_SRVR_SHOW_VERSION,
                            Status);
        return Status;
    }
    

    DisplayMessage(g_hModule,
                   MSG_WINS_VERSION_INFO,
                   g_ServerIpAddressUnicodeString,
                   Results.AddVersMaps[0].VersNo.HighPart,
                   Results.AddVersMaps[0].VersNo.LowPart);

    return Status;
       
}

DWORD
HandleSrvrShowVersionmap(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the version mapping
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD                  Status = NO_ERROR;
    WINSINTF_RESULTS_T     Results = {0};
    WINSINTF_RESULTS_NEW_T ResultsN = {0};
    LPSTR                  pszIp = NULL;


    ResultsN.WinsStat.NoOfPnrs = 0;
    ResultsN.WinsStat.pRplPnrs = NULL;
    
    pszIp = WinsUnicodeToOem(g_ServerIpAddressUnicodeString, NULL);
    if( pszIp is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_OUT_OF_MEMORY);
        Status = ERROR_NOT_ENOUGH_MEMORY;
        return Status;
    }

    Status = GetStatus(TRUE, (LPVOID)&ResultsN, TRUE, TRUE, pszIp);
    
    if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
    {
        //Try old API
        Results.WinsStat.NoOfPnrs = 0;
        Results.WinsStat.pRplPnrs = 0;
        Status = GetStatus(TRUE, (LPVOID)&Results, FALSE, TRUE, pszIp);
    }

    WinsFreeMemory(pszIp);
    pszIp = NULL;
    
    if( ResultsN.pAddVersMaps )
    {
        WinsFreeMem(ResultsN.pAddVersMaps);
        ResultsN.pAddVersMaps = NULL;
    }

    if( Status isnot NO_ERROR )
    {
        DisplayErrorMessage(EMSG_SRVR_SHOW_VERSIONMAP,
                            Status);
        
        return Status;
    }
    DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    return Status;

}

DWORD
HandleSrvrShowPartnerproperties(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the default partner properties
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    HKEY        hServer = NULL,
                hDefaultPull = NULL,
                hDefaultPush = NULL,
                hPullRoot = NULL,
                hPushRoot = NULL,
                hPartner = NULL,
                hParameter = NULL;
    LPWSTR      pTemp = NULL,
                pServerList = NULL;
    WCHAR       wcBuffer[255] = {L'\0'};

    DWORD       dwRplWCnfPnrs = 0,
                dwMigrate = 0,
                dwData = 0,
                i = 0,
                dwPersonaMode = 0,
                dwSelfFndPnrs = 0;

    DWORD       dwType = REG_DWORD;
    DWORD       dwSize = sizeof(DWORD);
    LPBYTE      pbData = NULL;



    if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    Status = RegOpenKeyEx(hServer,
                          PARAMETER,
                          0,
                          KEY_READ,
                          &hParameter);

    if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_RPL_ONLY_W_CNF_PNRS_NM,
                             0,
                             &dwType,
                             (LPBYTE)&dwRplWCnfPnrs,
                             &dwSize);
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_REPLICATE_STATE,
                       dwRplWCnfPnrs ? wszEnable : wszDisable);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_REPLICATE_STATE,
                       wszUnknown);
    }

    dwMigrate = 0;
    dwSize = sizeof(DWORD);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_MIGRATION_ON_NM,
                             0,
                             &dwType,
                             (LPBYTE)&dwMigrate,
                             &dwSize);
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_MIGRATE_STATE,
                       dwMigrate ? wszEnable : wszDisable);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_MIGRATE_STATE,
                       wszUnknown);
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_SRVR_AUTOCONFIGURE);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_USE_SELF_FND_PNRS_NM,
                             0,
                             &dwType,
                             (LPBYTE)&dwSelfFndPnrs,
                             &dwSize);
    if( Status isnot NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_SELFFINDPNRS_STATE,
                       wszUnknown);
                       
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_SELFFINDPNRS_STATE,
                       dwSelfFndPnrs ? wszEnable : wszDisable);
        if( dwSelfFndPnrs > 0 )
        {
            dwData = 0;
            dwSize = sizeof(DWORD);
            Status = RegQueryValueEx(hParameter,
                                     WINSCNF_MCAST_INTVL_NM,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwSize);
            if(Status is NO_ERROR )
            {
                LPWSTR  pwszTime = MakeTimeString(dwData);
                if( pwszTime is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                DisplayMessage(g_hModule,
                               MSG_SRVR_MCAST_INTERVAL,
                               pwszTime);
                WinsFreeMemory(pwszTime);
                pwszTime = NULL;

            }
            else
            {
                DisplayMessage(g_hModule,
                               MSG_SRVR_MCAST_INTERVAL,
                               wszUnknown);
            }

            dwData = 0;
            dwSize = sizeof(DWORD);
            Status = RegQueryValueEx(hParameter,
                                     WINSCNF_MCAST_TTL_NM,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwSize);
            if( Status is NO_ERROR )
            {
                WCHAR Buffer[10] = {L'\0'};
                _itow(dwData, Buffer, 10);
                DisplayMessage(g_hModule,
                               MSG_SRVR_MCAST_TTL,
                               Buffer);
            }
            else
            {
                DisplayMessage(g_hModule,
                               MSG_SRVR_MCAST_TTL,
                               wszUnknown);
            }

        }
    }

    //Display PNG Servers

    DisplayMessage(g_hModule,
                   WINS_FORMAT_LINE);

    Status = RegOpenKeyEx(hServer,
                          PARTNERROOT,
                          0,
                          KEY_READ,
                          &hPartner);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    dwSize = sizeof(DWORD);
    Status = RegQueryValueEx(hPartner,
                         TEXT(WINSCNF_PERSONA_MODE_NM),
                         0,
                         &dwType,
                         (LPVOID)&dwPersonaMode,
                         &dwSize);

    DisplayMessage(g_hModule,
                   dwPersonaMode == PERSMODE_NON_GRATA ?
                   MSG_WINS_PNGSERVER_TABLE : MSG_WINS_PGSERVER_TABLE);

    dwSize = 0;
    Status = RegQueryValueEx(hPartner,
                             dwPersonaMode == PERSMODE_NON_GRATA ? PNGSERVER : PGSERVER,
                             0,
                             &dwType,
                             NULL,
                             &dwSize);

    if( dwSize <= 2 )
    {
        DisplayMessage(g_hModule,
            dwPersonaMode == PERSMODE_NON_GRATA ? MSG_WINS_NO_PNGSERVER : MSG_WINS_NO_PGSERVER);
    }

    else
    {
        pbData = WinsAllocateMemory(dwSize);

        if( pbData is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
                         
        Status = RegQueryValueEx(hPartner,
                                 dwPersonaMode == PERSMODE_NON_GRATA ? PNGSERVER : PGSERVER,
                                 0,
                                 &dwType,
                                 pbData,
                                 &dwSize);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;    



        pServerList = (LPWSTR)pbData;

        i = 0;
        while(TRUE)
        {
            if ( i+1 < dwSize/sizeof(WCHAR) )
            {
                if( pServerList[i] is L'\0' and 
                    pServerList[i+1] isnot L'\0' )
                {
                    pServerList[i] = L',';
                }
                i++;
            }
            else
                break;
            
        }

        pTemp = wcstok(pServerList, L",");

        while(pTemp isnot NULL )
        {
            DisplayMessage(g_hModule,
                           dwPersonaMode == PERSMODE_NON_GRATA ? MSG_WINS_PNGSERVER_ENTRY : MSG_WINS_PGSERVER_ENTRY,
                           pTemp);
            pTemp = wcstok(NULL, L",");
        }
    }

    Status = RegOpenKeyEx(hServer,
                          DEFAULTPULL,
                          0,
                          KEY_READ,
                          &hDefaultPull);
    
    if( Status is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       MSG_NO_DEFAULT_PULL);
    }
    else if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    Status = RegOpenKeyEx(hServer,
                          PULLROOT,
                          0,
                          KEY_READ,
                          &hPullRoot);

    if( Status is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       MSG_NO_DEFAULT_PULL);
    }
    else if( Status isnot NO_ERROR )
        goto ErrorReturn;


    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_SRVR_PULL_INFO);

    dwData = 0;
	dwSize = sizeof(DWORD);


    if( hPullRoot isnot NULL )
    {
        Status = RegQueryValueEx(hPullRoot,
                                 PERSISTENCE,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_PERSISTENCE_STATE,
                           dwData ? wszEnable : wszDisable);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_PERSISTENCE_STATE,
                           wszUnknown);
        }

        dwData = 0;
		dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hPullRoot,
                                 WINSCNF_INIT_TIME_RPL_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);
    
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_INITTIMEREPL_STATE,
                           dwData ? wszEnable : wszDisable);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_INITTIMEREPL_STATE,
                           wszUnknown);
        }
    }

    dwData = 0;
    dwSize = 255;

    if( hDefaultPull isnot NULL )
    {
        Status = RegQueryValueEx(hDefaultPull,
                                 WINSCNF_SP_TIME_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)wcBuffer,
                                 &dwSize);
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_STARTTIME,
                           wcBuffer);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_STARTTIME,
                           wszUnknown);
        }
    
        dwSize = sizeof(DWORD);
        dwData = 0;

        Status = RegQueryValueEx(hDefaultPull,
                                 WINSCNF_RPL_INTERVAL_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            LPWSTR  pwszDayString = MakeDayTimeString(dwData);
            DisplayMessage(g_hModule,
                           MSG_WINS_PULL_REPLINTERVAL,
                           MakeDayTimeString(dwData));
            WinsFreeMemory(pwszDayString);
            pwszDayString = NULL;
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PULL_REPLINTERVAL,
                           wszUnknown);
        }
    }

    dwData = 0;
	dwSize = sizeof(DWORD);

    if( hPullRoot isnot NULL )
    {
        Status = RegQueryValueEx(hPullRoot,
                                 WINSCNF_RETRY_COUNT_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);
    
        if( Status is NO_ERROR )
        {
            WCHAR   Buffer[20];
            _itow(dwData, Buffer, 10);

            DisplayMessage(g_hModule,
                           MSG_WINS_PULL_RETRYCOUNT,
                           Buffer);

        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PULL_RETRYCOUNT,
                           wszUnknown);
        }
    }

    Status = RegOpenKeyEx(hServer,
                          DEFAULTPUSH,
                          0,
                          KEY_READ,
                          &hDefaultPush);

    if( Status is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       MSG_NO_DEFAULT_PUSH);
    }
    else if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegOpenKeyEx(hServer,
                          PUSHROOT,
                          0,
                          KEY_READ,
                          &hPushRoot);
    
    if( Status is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       MSG_NO_DEFAULT_PUSH);
    }
    else if( Status isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_SRVR_PUSH_INFO);

    dwData = 0;
    dwSize = sizeof(DWORD);
    
    if( hPushRoot isnot NULL )
    {
        Status = RegQueryValueEx(hPushRoot,
                                 PERSISTENCE,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_PERSISTENCE_STATE,
                           dwData ? wszEnable : wszDisable);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_PERSISTENCE_STATE,
                           wszUnknown);
        }

		dwData = 0;
		dwSize = sizeof(DWORD);
    
        Status = RegQueryValueEx(hPushRoot,
                                 WINSCNF_INIT_TIME_RPL_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_INITTIMEREPL_STATE,
                           dwData ? wszEnable : wszDisable);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_INITTIMEREPL_STATE,
                           wszUnknown);
        }

		dwData = 0;
		dwSize = sizeof(DWORD);
    
        
        Status = RegQueryValueEx(hPushRoot,
                                 WINSCNF_ADDCHG_TRIGGER_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_ONADDCHANGE,
                           dwData ? wszEnable : wszDisable);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_ONADDCHANGE,
                           wszUnknown);
        }
    }                     
    
    dwData = 0;
	dwSize = sizeof(DWORD);
    
    Status = NO_ERROR;

    if( hDefaultPush isnot NULL )
    {
        Status = RegQueryValueEx(hDefaultPush,
                                 WINSCNF_UPDATE_COUNT_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);
        if( Status is NO_ERROR )
        {
            WCHAR Buffer[10] = {L'\0'};
        
            _itow(dwData, Buffer, 10);

            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_UPDATECOUNT,
                           Buffer);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_UPDATECOUNT,
                           wszUnknown);
        }
    }


CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( hPushRoot )
    {
        RegCloseKey(hPushRoot);
        hPushRoot = NULL;
    }

    if( hPullRoot )
    {
        RegCloseKey(hPullRoot);
        hPullRoot = NULL;
    }

    if( hDefaultPush )
    {
        RegCloseKey(hDefaultPush);
        hDefaultPush = NULL;
    }

    if( hDefaultPull )
    {
        RegCloseKey(hDefaultPull);
        hDefaultPull = NULL;
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hPartner )
    {
        RegCloseKey(hPartner);
        hPartner = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pbData )
    {
        WinsFreeMemory(pbData);
        pbData = NULL;
    }

    return Status;

ErrorReturn:
    if( Status is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_NO_PARTNER);
    }
    else
    {
        DisplayErrorMessage(EMSG_SRVR_SHOW_PARTNERPROPERTIES,
                            Status);
    }
    goto CommonReturn;


}

DWORD
HandleSrvrShowPullpartnerproperties(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the properties for a particular Pull partner
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Pull partner address
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                            };
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    WCHAR       wcServerIpAdd[MAX_IP_STRING_LEN+1] = {L'\0'};
    HKEY        hPullRoot = NULL,
                hPullServer = NULL,
                hServer = NULL;
    BOOL        fPush = FALSE;

    LPWSTR      pTemp = NULL;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SHOW_PULLPARTNERPROPERTIES_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;
    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }


    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                struct  hostent * lpHostEnt = NULL;
                CHAR    cAddr[16];
                BYTE    pbAdd[4];
                char    szAdd[4];
                int     k = 0, l=0;
                DWORD   dwLen, nLen = 0;
                CHAR    *pTemp = NULL;
                CHAR    *pNetBios = NULL;

                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) )
                {
                    DWORD dwIp = inet_addr(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL));
                    lpHostEnt = gethostbyaddr((char *)&dwIp, 4, AF_INET);
                    if(lpHostEnt isnot NULL )//Valid IP Address
                    {
                        wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                        break;
                    }
                    else
                    {
                        Status = ERROR_INVALID_IPADDRESS;
                        goto ErrorReturn;
                    }
                }

                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 2 and
                    _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"\\\\", 2) is 0 )
                    k = 2;

                lpHostEnt = gethostbyname(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k, NULL));
                if( lpHostEnt is NULL )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_WINS_INVALID_COMPUTER_NAME,
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k);
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;                                       
                }

                memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
                for( l=0;l<4; l++)
                {
                    _itoa((int)pbAdd[l], szAdd, 10);
                    memcpy(cAddr+nLen, szAdd, strlen(szAdd));
                    nLen += strlen(szAdd);
                    *(cAddr+nLen) = '.';
                    nLen++;

                }
                *(cAddr+nLen-1) = '\0';
                {
                    LPWSTR pstr = WinsAnsiToUnicode(cAddr, NULL);

                    if (pstr != NULL)
                    {
                        wcscpy(wcServerIpAdd, pstr);
                        WinsFreeMemory(pstr);
                    }
                    else
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }
                }
                break;               
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

        if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    Status = RegOpenKeyEx(hServer,
                          PULLROOT,
                          0,
                          KEY_READ,
                          &hPullRoot);

    if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);

    //Now check if the desired server is in the list of pull server.
    Status = RegOpenKeyEx(hPullRoot,
                          wcServerIpAdd,
                          0,
                          KEY_READ,
                          &hPullServer);

    if( Status isnot NO_ERROR )
    {
        DisplayMessage(g_hModule, 
                       EMSG_WINS_INVALID_PULLPARTNER,
                       wcServerIpAdd,
                       g_ServerIpAddressUnicodeString);
        goto CommonReturn;
    }

    //Check if it is also a push partner or not.
    {
        DWORD dwKeyLen = 0;
        HKEY hPushServer = NULL;
        dwKeyLen = wcslen(PUSHROOT)+ wcslen(L"\\") + wcslen(wcServerIpAdd);
        pTemp = WinsAllocateMemory((dwKeyLen+1)*sizeof(WCHAR));
        if(pTemp is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        memset(pTemp, 0x00, (dwKeyLen+1)*sizeof(WCHAR));
        wcscat(pTemp,PUSHROOT);
        wcscat(pTemp, L"\\");
        wcscat(pTemp, wcServerIpAdd);

        Status = RegOpenKeyEx(hServer,
                              pTemp,
                              0,
                              KEY_READ,
                              &hPushServer);
        if( Status isnot NO_ERROR )
        {
            fPush = FALSE;
        }
        else
        {
            fPush = TRUE;
        }
        WinsFreeMemory(pTemp);
        pTemp = NULL;
        if( hPushServer )
        {
            RegCloseKey(hPushServer);
            hPushServer = NULL;
        }
        
    }

    //Now look for required parameters to display
    {
        WCHAR   wcData[256] = {L'\0'};
        DWORD   dwData = 0;
        DWORD   dwDatalen = 256;
        DWORD   dwType = REG_SZ;

        Status = RegQueryValueEx(hPullServer,
                                 L"NetBIOSName",
                                 0,
                                 &dwType,
                                 (LPBYTE)wcData,
                                 &dwDatalen);
        if( Status isnot NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PULLPARTNER_INFO,
                           wcServerIpAdd,
                           wszUnknown,
                           (fPush is TRUE) ? wszPushpull : wszPull);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PULLPARTNER_INFO,
                           wcServerIpAdd,
                           wcData,
                           (fPush is TRUE) ? wszPushpull : wszPull);
        }

        dwDatalen = sizeof(DWORD);
        dwType = REG_DWORD;

        Status = RegQueryValueEx(hPullServer,
                                 PERSISTENCE,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwDatalen);
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_PERSISTENCE_STATE,
                           dwData ? wszEnable : wszDisable);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_PERSISTENCE_STATE,
                           wszUnknown);
        }

        dwType = REG_SZ;
        dwDatalen = 256;
        Status = RegQueryValueEx(hPullServer,
                                 WINSCNF_SP_TIME_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)wcData,
                                 &dwDatalen);
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_STARTTIME,
                           wcData);
        }
        else 
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_STARTTIME,
                           L"00:00:00");
        }
    
        dwDatalen = sizeof(DWORD);
        dwType = REG_DWORD;

        Status = RegQueryValueEx(hPullServer,
                                 WINSCNF_RPL_INTERVAL_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwDatalen);

        if( Status is NO_ERROR )
        {
            LPWSTR  pwszDayString = MakeDayTimeString(dwData);
            DisplayMessage(g_hModule,
                           MSG_WINS_PULL_REPLINTERVAL,
                           pwszDayString);
            WinsFreeMemory(pwszDayString);
            pwszDayString = NULL;
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PULL_REPLINTERVAL,
                           L"00:00:00");
        }
                                
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( hPullServer )
    {
        RegCloseKey(hPullServer);
        hPullServer = NULL;
    }


    if( hPullRoot )
    {
        RegCloseKey(hPullRoot);
        hPullRoot = NULL;
    }


    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    return Status;

ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_PULLPARTNERPROPERTIES,
                        Status);
    goto CommonReturn;


}

DWORD
HandleSrvrShowPushpartnerproperties(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the properties for a particular Push partner
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Push partner address
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                            };
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    WCHAR       wcServerIpAdd[MAX_IP_STRING_LEN+1] = {L'\0'};
    HKEY        hPushRoot = NULL,
                hPushServer = NULL,
                hServer = NULL;
    BOOL        fPull = FALSE;

    LPWSTR      pTemp = NULL;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SHOW_PUSHPARTNERPROPERTIES_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;
    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                struct  hostent * lpHostEnt = NULL;
                CHAR    cAddr[16];
                BYTE    pbAdd[4];
                char    szAdd[4];
                int     k = 0, l=0;
                DWORD   dwLen, nLen = 0;
                CHAR    *pTemp = NULL;
                CHAR    *pNetBios = NULL;

                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) )
                {
                    DWORD dwIp = inet_addr(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL));
                    lpHostEnt = gethostbyaddr((char *)&dwIp, 4, AF_INET);
                    if(lpHostEnt isnot NULL )//Valid IP Address
                    {
                        wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                        break;
                    }
                    else
                    {
                        Status = ERROR_INVALID_IPADDRESS;
                        goto ErrorReturn;
                    }
                }

                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 2 and
                    _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"\\\\", 2) is 0 )
                    k = 2;
                lpHostEnt = gethostbyname(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k, NULL));
                if( lpHostEnt is NULL )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_WINS_INVALID_COMPUTER_NAME,
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k);
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;                                       
                }

                memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
                for( l=0;l<4; l++)
                {
                    _itoa((int)pbAdd[l], szAdd, 10);
                    memcpy(cAddr+nLen, szAdd, strlen(szAdd));
                    nLen += strlen(szAdd);
                    *(cAddr+nLen) = '.';
                    nLen++;

                }
                *(cAddr+nLen-1) = '\0';
                {
                    LPWSTR pstr = WinsAnsiToUnicode(cAddr, NULL);

                    if (pstr != NULL)
                    {
                        wcscpy(wcServerIpAdd, pstr);
                        WinsFreeMemory(pstr);
                    }
                    else
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }
                }
                break;               
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

        if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    Status = RegOpenKeyEx(hServer,
                          PUSHROOT,
                          0,
                          KEY_READ,
                          &hPushRoot);

    if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);

    //Now check if the desired server is in the list of push server.
    Status = RegOpenKeyEx(hPushRoot,
                          wcServerIpAdd,
                          0,
                          KEY_READ,
                          &hPushServer);

    if( Status isnot NO_ERROR )
    {
        DisplayMessage(g_hModule, 
                       EMSG_WINS_INVALID_PUSHPARTNER,
                       wcServerIpAdd,
                       g_ServerIpAddressUnicodeString);
        goto CommonReturn;
    }

    //Check if it is also a pull partner or not.
    {
        DWORD dwKeyLen = 0;
        HKEY hPullServer = NULL;
        dwKeyLen = wcslen(PULLROOT)+ wcslen(L"\\") + wcslen(wcServerIpAdd);
        pTemp = WinsAllocateMemory((dwKeyLen+1)*sizeof(WCHAR));
        if(pTemp is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        memset(pTemp, 0x00, (dwKeyLen+1)*sizeof(WCHAR));
        wcscat(pTemp,PULLROOT);
        wcscat(pTemp, L"\\");
        wcscat(pTemp, wcServerIpAdd);

        Status = RegOpenKeyEx(hServer,
                              pTemp,
                              0,
                              KEY_READ,
                              &hPullServer);
        if( Status isnot NO_ERROR )
        {
            fPull = FALSE;
        }
        else
        {
            fPull = TRUE;
        }
        WinsFreeMemory(pTemp);
        pTemp = NULL;
        if( hPullServer )
        {
            RegCloseKey(hPullServer);
            hPullServer = NULL;
        }
        
    }

    //Now look for required parameters to display
    {
        WCHAR   wcData[256] = {L'\0'};
        DWORD   dwData = 0;
        DWORD   dwDatalen = 256;
        DWORD   dwType = REG_SZ;

        Status = RegQueryValueEx(hPushServer,
                                 L"NetBIOSName",
                                 0,
                                 &dwType,
                                 (LPBYTE)wcData,
                                 &dwDatalen);
        if( Status isnot NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PUSHPARTNER_INFO,
                           wcServerIpAdd,
                           wszUnknown,
                           (fPull is TRUE) ? wszPushpull : wszPush);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PUSHPARTNER_INFO,
                           wcServerIpAdd,
                           wcData,
                           (fPull is TRUE) ? wszPushpull : wszPush);
        }

        dwDatalen = sizeof(DWORD);
        dwType = REG_DWORD;

        Status = RegQueryValueEx(hPushServer,
                                 PERSISTENCE,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwDatalen);
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_PERSISTENCE_STATE,
                           dwData ? wszEnable : wszDisable);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_PERSISTENCE_STATE,
                           wszUnknown);
        }

  
        dwDatalen = sizeof(DWORD);
        dwType = REG_DWORD;

        Status = RegQueryValueEx(hPushServer,
                                 WINSCNF_UPDATE_COUNT_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwDatalen);

        if( Status is NO_ERROR )
        {
            WCHAR Buffer[10] = {L'\0'};
        
            _itow(dwData, Buffer, 10);

            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_UPDATECOUNT,
                           Buffer);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_UPDATECOUNT,
                           wszUnknown);
        }
                                
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);


CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( hPushServer )
    {
        RegCloseKey(hPushServer);
        hPushServer = NULL;
    }


    if( hPushRoot )
    {
        RegCloseKey(hPushRoot);
        hPushRoot = NULL;
    }


    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }
    
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    return Status;

ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_PUSHPARTNERPROPERTIES,
                        Status);
    goto CommonReturn;

}

DWORD
GetVersionData(
               LPWSTR               pwszVers,
               WINSINTF_VERS_NO_T   *Version
               )
{
    LPWSTR pTemp = NULL;
    LPWSTR pwcBuffer = NULL;
    DWORD  dwLen = 0;
    LPWSTR pwszToken=L",-.";
    
    if( ( pwszVers is NULL ) or 
        ( IsBadStringPtr(pwszVers, MAX_STRING_LEN) is TRUE ) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwLen = wcslen(pwszVers);

    if( dwLen<2 )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    pwcBuffer = WinsAllocateMemory((dwLen+1)*sizeof(WCHAR));

    if( pwcBuffer is NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(pwcBuffer, pwszVers);
    
    if( pwcBuffer[0] isnot L'{' or
        pwcBuffer[dwLen-1] isnot L'}' )
    {
        WinsFreeMemory(pwcBuffer);
        pwcBuffer = NULL;
        return ERROR_INVALID_PARAMETER;
    }
    
    pwcBuffer[dwLen-1] = L'\0';
    
    pTemp = wcstok(pwcBuffer+1, pwszToken);                
    
    if( pTemp is NULL )
    {
        WinsFreeMemory(pwcBuffer);
        pwcBuffer = NULL;
        return ERROR_INVALID_PARAMETER;
    }
    
    Version->HighPart = wcstoul(pTemp, NULL, 16);
    pTemp = wcstok(NULL, pwszToken);
    if( pTemp is NULL )
    {
        WinsFreeMemory(pwcBuffer);
        pwcBuffer = NULL;
        return ERROR_INVALID_PARAMETER;        
    }
    Version->LowPart = wcstoul(pTemp, NULL, 16);
    WinsFreeMemory(pwcBuffer);
    pwcBuffer = NULL;
    return NO_ERROR;
}


DWORD
PreProcessCommand(
      IN          LPWSTR            *ppwcArguments,
      IN          DWORD             dwArgCount,
      IN          DWORD             dwCurrentIndex,
      IN OUT      PTAG_TYPE         pttTags,
      IN OUT      PDWORD            pdwTagCount,
      OUT         PDWORD            pdwTagType,
      OUT         PDWORD            pdwTagNum
)
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwTag = 0;
    LPWSTR      pwszTemp = NULL;
    

    if( pdwTagType is NULL or
        pdwTagNum is NULL or
        pttTags is NULL or
        pdwTagCount is NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwTag = *pdwTagCount;
    i = 0;
    if( wcsstr(ppwcArguments[dwCurrentIndex], NETSH_ARG_DELIMITER) isnot NULL )
    {

        LPWSTR  pwszTag = NULL;
        while( IsBadStringPtr(ppwcArguments[dwCurrentIndex+i], MAX_STRING_LEN) is FALSE )
        {
            pwszTag = NULL;
            if( dwArgCount <= dwCurrentIndex + i )
                break;
            if( wcslen(ppwcArguments[dwCurrentIndex+i]) is 0 )
                break;

            pwszTemp = WinsAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+i])+1)*sizeof(WCHAR));

            if( pwszTemp is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }

            wcscpy(pwszTemp, ppwcArguments[dwCurrentIndex+i]);
            
            if( wcsstr(ppwcArguments[dwCurrentIndex+i], NETSH_ARG_DELIMITER ) is NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_NOT_TAGGED,
                               i+1);
                i++;
                continue;
            }
            pwszTag = wcstok(pwszTemp, NETSH_ARG_DELIMITER);
            
            for( j=0; j<dwTag; j++ )
            {
                if( FALSE is MatchToken(pwszTag,
                                        pttTags[j].pwszTag) )
                {
                    continue;
                }
                else
                {
                    if( pttTags[j].bPresent is TRUE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        WinsFreeMemory(pwszTemp);
                        pwszTemp = NULL;
                        goto ErrorReturn;
                    }
                    else
                    {
                        LPWSTR pwszVal = wcstok(NULL, NETSH_ARG_DELIMITER);
                        if( pwszVal is NULL )
                        {
                            wcscpy(ppwcArguments[dwCurrentIndex+i], L"");
                        }
                        else
                        {
                            wcscpy(ppwcArguments[dwCurrentIndex+i], pwszVal);
                        }
                        pttTags[j].bPresent = TRUE;
                        pdwTagType[i] = j;
                        pdwTagNum[i] = i;
                        break;
                    }
                }
            }
            if( pwszTemp )
            {
                WinsFreeMemory(pwszTemp);
                pwszTemp = NULL;
            }
            i++;
        }
    }
    else
    {
        while( IsBadStringPtr(ppwcArguments[dwCurrentIndex+i], MAX_STRING_LEN) is FALSE )
        {
            if( wcsstr(ppwcArguments[dwCurrentIndex+i], NETSH_ARG_DELIMITER) isnot NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_NOT_UNTAGGED,
                               i+1);
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            if( dwArgCount <= dwCurrentIndex + i )
                break;
       //     if( wcslen(ppwcArguments[dwCurrentIndex+i]) is 0 )
       //         break;
            if( dwTag <= i )
            {                
                break;
            }
            pdwTagType[i] = i;
            pdwTagNum[i] = i;
            pttTags[i].bPresent = TRUE;
            i++;
        }
    }
    *pdwTagCount = i;
CommonReturn:
    if( pwszTemp )
    {
        WinsFreeMemory(pwszTemp);
        pwszTemp = NULL;
    }
    return Status;
ErrorReturn:
    goto CommonReturn;
}


DWORD
GetStatus(
        BOOL            fPrint,
        LPVOID          pResultsA,
        BOOL            fNew,
        BOOL            fShort,
        LPCSTR          pStartIp
        )
{
    DWORD                     Status, i;
    struct in_addr            InAddr;
    PWINSINTF_RESULTS_T       pResults = pResultsA;
    PWINSINTF_RESULTS_NEW_T   pResultsN = pResultsA;
    PWINSINTF_ADD_VERS_MAP_T  pAddVersMaps;
    DWORD                     NoOfOwners;
    WCHAR                     IpAddress[21] = {L'\0'};
    WCHAR                     OwnerId[15] = {L'\0'};
    WCHAR                     Buffer[5] = {L'\0'};
    LPWSTR                    pwszDay = NULL;
    handle_t                  BindHdl;
    WINSINTF_BIND_DATA_T      BindData = {0};
    

    BindData.fTcpIp = TRUE;
    BindData.pServerAdd = (LPBYTE)WinsOemToUnicode(pStartIp, NULL);

    if( BindData.pServerAdd is NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    DisplayMessage(g_hModule,
                   MSG_SRVR_MAPTABLE_HEADER,
                   BindData.pServerAdd);

    BindHdl = WinsBind(&BindData);

    if( BindHdl is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_BIND_FAILED,
                       BindData.pServerAdd);
        return NO_ERROR;
    }

    if (!fNew)
    {
      Status = WinsStatus(BindHdl, WINSINTF_E_CONFIG, pResultsA);
    }

    else
    {
      pResultsN->pAddVersMaps = NULL;
      Status = WinsStatusNew(BindHdl, WINSINTF_E_CONFIG, pResultsN);
    }
  
    if( Status isnot NO_ERROR )
    {
        WinsUnbind(&BindData, BindHdl);
        return Status;
    }

    if( fShort is TRUE )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_NAMERECORD_SETTINGS);
    
        if( fNew )
        {
            pwszDay = MakeDayTimeString(pResultsN->RefreshInterval);
        }
        else
        {
            pwszDay = MakeDayTimeString(pResults->RefreshInterval);
        }

        DisplayMessage(g_hModule,
                       MSG_WINS_NAMERECORD_REFRESHINTVL,
                       pwszDay);
    
        WinsFreeMemory(pwszDay);
        pwszDay = NULL;

        if( fNew )
        {
            pwszDay = MakeDayTimeString(pResultsN->TombstoneInterval);
        }
        else
        {
            pwszDay = MakeDayTimeString(pResults->TombstoneInterval);
        }

        DisplayMessage(g_hModule,
                       MSG_WINS_NAMERECORD_TOMBSTONEINTVL,
                       pwszDay);
    
        WinsFreeMemory(pwszDay);
        pwszDay = NULL;

        if( fNew )
        {
            pwszDay = MakeDayTimeString(pResultsN->TombstoneTimeout);
        }
        else
        {
            pwszDay = MakeDayTimeString(pResults->TombstoneTimeout);
        }

        DisplayMessage(g_hModule,
                       MSG_WINS_NAMERECORD_TOMBSTONETMOUT,
                       pwszDay);

        WinsFreeMemory(pwszDay);
        pwszDay = NULL;

        if( fNew )
        {
            pwszDay = MakeDayTimeString(pResultsN->VerifyInterval);
        }
        else
        {
            pwszDay = MakeDayTimeString(pResults->VerifyInterval);
        }
        DisplayMessage(g_hModule,
                       MSG_WINS_NAMERECORD_VERIFYINTVL,
                       pwszDay);

        WinsFreeMemory(pwszDay);
        pwszDay = NULL;

        DisplayMessage(g_hModule,WINS_FORMAT_LINE);

        if (!fNew)
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PRIORITY_CLASS, 
                           pResults->WinsPriorityClass == NORMAL_PRIORITY_CLASS ? wszNormal : wszHigh);
            DisplayMessage(g_hModule,
                           MSG_WINS_WORKER_THREAD,
                           pResults->NoOfWorkerThds);

            pAddVersMaps = pResults->AddVersMaps;
            NoOfOwners = pResults->NoOfOwners;
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PRIORITY_CLASS, 
                           pResultsN->WinsPriorityClass == NORMAL_PRIORITY_CLASS ? wszNormal : wszHigh);
            DisplayMessage(g_hModule,
                           MSG_WINS_WORKER_THREAD,
                           pResultsN->NoOfWorkerThds);

            pAddVersMaps = pResultsN->pAddVersMaps;
            NoOfOwners = pResultsN->NoOfOwners;

        }

        DisplayMessage(g_hModule,WINS_FORMAT_LINE);

        if (NoOfOwners isnot 0)
        {
        
            DisplayMessage(g_hModule,
                           MSG_WINS_OWNER_TABLE);

            for ( i= 0; i < NoOfOwners; i++, pAddVersMaps++)
            {
                DWORD j=0;
                for(j=0; j<20; j++)
                {
                    IpAddress[j] = L' ';
                }
                IpAddress[20] = L'\0';
                for(j=0; j<14; j++)
                {
                    OwnerId[j] = L' ';
                }
                OwnerId[14] = L'\0';
    

                _itow(i, Buffer, 10);
                wcscpy(OwnerId+4, Buffer);
                for(j=wcslen(OwnerId); j<14; j++)
                    OwnerId[j] = L' ';
                OwnerId[14] = L'\0';

                wcscpy(IpAddress+2, IpAddressToString(pAddVersMaps->Add.IPAdd));
                for(j=wcslen(IpAddress); j<20; j++)
                    IpAddress[j] = L' ';
                IpAddress[20] = L'\0';

                if (fNew)
                {
                    if( pAddVersMaps->VersNo.HighPart is MAXLONG and
                        pAddVersMaps->VersNo.LowPart is MAXULONG )
                    {

                        DisplayMessage(g_hModule,
                                       MSG_WINS_OWNER_INFO_MAX,
                                       OwnerId,
                                       IpAddress,
                                       wszDeleted);
                    
                        continue;
                    }

                    if (fShort && pAddVersMaps->VersNo.QuadPart == 0)
                    {
                        continue;
                    }

                    DisplayMessage(g_hModule,
                                   MSG_WINS_OWNER_INFO,
                                   OwnerId,
                                   IpAddress,
                                   pAddVersMaps->VersNo.HighPart,
                                   pAddVersMaps->VersNo.LowPart);

                }

            }
        }
        else
        {
            DisplayMessage(g_hModule, MSG_WINS_NO_RECORDS);
        }
    }
    WinsUnbind(&BindData, BindHdl);

    if( BindData.pServerAdd )
    {
        WinsFreeMemory(BindData.pServerAdd);
        BindData.pServerAdd = NULL;
    }
    return(Status);
}


VOID
ChkAdd(
        PWINSINTF_RECORD_ACTION_T pRow,
        DWORD                     Add,
        BOOL                      fFile,
        FILE                      *pFile,
        DWORD                     OwnerIP,
        LPBOOL                    pfMatch
      )
{

    struct in_addr InAddr1, InAddr2;
    DWORD   dwIpAddress = 0;
    LPWSTR  pwszAdd1 = NULL;
    LPWSTR  pwszAdd2 = NULL;
    LPWSTR  pwszOwner = NULL;

    BOOL    fFirst = FALSE;

    if ( pRow->TypOfRec_e is WINSINTF_E_UNIQUE or
         pRow->TypOfRec_e is WINSINTF_E_NORM_GROUP )
    {
            pwszAdd2 = IpAddressToString(pRow->Add.IPAdd);
            pwszOwner = IpAddressToString(OwnerIP);
            
            if( pwszAdd2 is NULL or
                pwszOwner is NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_OUT_OF_MEMORY);

                if( pwszAdd2 )
                {
                    WinsFreeMemory(pwszAdd2);
                    pwszAdd2 = NULL;
                }

                if( pwszOwner )
                {
                    WinsFreeMemory(pwszOwner);
                    pwszOwner = NULL;
                }
                return;
            }

        if (*pfMatch)
        {
            if (Add isnot pRow->Add.IPAdd)
            {
                WinsFreeMemory(pwszAdd2);
                pwszAdd2 = NULL;
                WinsFreeMemory(pwszOwner );
                pwszOwner = NULL;                
                *pfMatch = FALSE;
                return;
            }
        }
        
        DisplayMessage(g_hModule, 
                       MSG_WINS_IPADDRESS_STRING,
                       pwszAdd2 );

        if( fFile )
        {
            DumpMessage(g_hModule,
                        pFile,
                        FMSG_WINS_IPADDRESS_STRING,
                        pwszAdd2,
                        pwszOwner);
        }

        WinsFreeMemory(pwszAdd2);
        pwszAdd2 = NULL;
        WinsFreeMemory(pwszOwner );
        pwszOwner = NULL;

        return;
    }
    else //spec. grp or multihomed
    {
        DWORD ind;
        if (!*pfMatch)
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_MEMBER_COUNT,
                           pRow->NoOfAdds/2);
        }

        for ( ind=0;  ind < pRow->NoOfAdds ;  /*no third expr*/ )
        {
            LPSTR psz1 = NULL;
 
            InAddr1.s_addr = htonl( (pRow->pAdd + ind++)->IPAdd);
            
            psz1 = inet_ntoa(InAddr1);
            
            if( psz1 is NULL )
            {
                continue;
            }

            pwszAdd1 = WinsOemToUnicode(psz1, NULL );

            if( pwszAdd1 is NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_OUT_OF_MEMORY);
                return;
            }


            if (!*pfMatch)
            {
                DisplayMessage(g_hModule,
                               MSG_WINS_OWNER_ADDRESS,
                               pwszAdd1);
            }

            InAddr2.s_addr = htonl((pRow->pAdd + ind++)->IPAdd);
            
            psz1 = inet_ntoa(InAddr2);
            
            if( psz1 is NULL )
            {
                if( pwszAdd1 )
                {
                    WinsFreeMemory(pwszAdd1);
                    pwszAdd1 = NULL;
                }
                continue;
            }

            pwszAdd2 = WinsOemToUnicode(psz1, NULL);

            if( pwszAdd2 is NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_OUT_OF_MEMORY);
                if( pwszAdd1 )
                {
                    WinsFreeMemory(pwszAdd1);
                    pwszAdd1 = NULL;
                }
                return;
            }

            if (!*pfMatch)
            {
                DisplayMessage(g_hModule,
                               MSG_WINS_IPADDRESS_STRING,
                               pwszAdd2 );
                if( fFile )
                {
                    if( fFirst is FALSE )
                    {
                        DumpMessage(g_hModule,
                                    pFile,
                                    FMSG_WINS_IPADDRESS_STRING,
                                    pwszAdd2, 
                                    pwszAdd1);
                        fFirst = TRUE;
                    }
                    else
                    {
                        DumpMessage(g_hModule,
                                    pFile,
                                    FMSG_WINS_IPADDRESS_LIST,
                                    pwszAdd2,
                                    pwszAdd1);
                    }
                }
            }
            if (*pfMatch)
            {
                if (Add isnot (pRow->pAdd + ind - 1)->IPAdd)
                {
                    *pfMatch = FALSE;

                    if( pwszAdd1 )
                    {
                        WinsFreeMemory(pwszAdd1);
                        pwszAdd1 = NULL;
                    }
                    if( pwszAdd2 )
                    {
                        WinsFreeMemory(pwszAdd2);
                        pwszAdd2 = NULL;
                    }                   
                    return;
                }
            }
        }

        //
        // If there were no members to compare with, then
        // let us set *pfMatch to FALSE.
        //
        if (ind == 0)
        {
            if (*pfMatch)
            {
                    *pfMatch = FALSE;
            }
        }
        if( pwszAdd1 )
        {
            WinsFreeMemory(pwszAdd1);
            pwszAdd1 = NULL;
        }

        if( pwszAdd2 )
        {
            WinsFreeMemory(pwszAdd2);
            pwszAdd2 = NULL;
        }

        return;
    }
}

DWORD
GetDbRecs(
   WINSINTF_VERS_NO_T LowVersNo,
   WINSINTF_VERS_NO_T HighVersNo,
   PWINSINTF_ADD_T    pWinsAdd,
   LPBYTE             pTgtAdd,
   BOOL               fSetFilter,
   LPBYTE             pFilterName,
   DWORD              Len,
   BOOL               fAddFilter,
   DWORD              AddFilter,
   BOOL               fCountRec,
   BOOL               fCase,
   BOOL               fFile,
   LPWSTR             pwszFile
  )
{

    WINSINTF_RECS_T    Recs;
    DWORD              Choice;
    DWORD              Status = WINSINTF_SUCCESS;
    DWORD              TotalCnt = 0;
    BOOL               fMatch;
    WINSINTF_VERS_NO_T sTmpVersNo;
    WCHAR              Name[20] = {L'\0'};
    DWORD              dwCount = 0;
    struct tm*         time = NULL;
    LPWSTR             pwszTime = NULL;
    int                iType = 1;
    FILE               *pFile = NULL;
    BOOL               fOpenFile = FALSE;
    BOOL               fHeader = FALSE;
    LPWSTR              pwszGroup = NULL,
                        pwszType = NULL,
                        pwszState = NULL;
    WCHAR               wszGroup[50] = {L'\0'},
                        wszState[50] = {L'\0'},
                        wszType[50] = {L'\0'};

    DWORD               dwGroup = WINS_GROUP_UNIQUE,
                        dwGrouplen = 0,
                        dwState = WINS_STATE_ACTIVE,
                        dwStatelen = 0,
                        dwType = WINS_TYPE_STATIC,
                        dwTypelen = 0;

   
   sTmpVersNo.LowPart = 1;
   sTmpVersNo.HighPart = 0;

   if( fFile )
   {
        pFile = _wfopen(pwszFile,
                        L"a+");
        if( pFile is NULL )
        {
            fOpenFile = FALSE;
            DisplayMessage(g_hModule,
                           EMSG_WINS_FILEOPEN_FAILED,
                           pwszFile);
        }
        else
        {
            fOpenFile = TRUE;
        }

   }
   while (TRUE)
   {
        LPWSTR  pwszTempTgt = NULL;

        Recs.pRow = NULL;
        Status = WinsGetDbRecs(g_hBind, pWinsAdd, LowVersNo, HighVersNo, &Recs);

        if (fCountRec)
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_RECORDS_COUNT,
                           Recs.TotalNoOfRecs);

            break;
        }
        if (Status is WINSINTF_SUCCESS)
        {
            if (Recs.NoOfRecs > 0)
            {
                DWORD i, k;
                PWINSINTF_RECORD_ACTION_T pRow =  Recs.pRow;
                TotalCnt += Recs.NoOfRecs;


                if (!fSetFilter)
                {
                    DisplayMessage(g_hModule,
                                   MSG_WINS_RECORDS_RETRIEVED,
                                   IpAddressToString(pWinsAdd->IPAdd),
                                   Recs.NoOfRecs);
                    
                }

                

                for (i=0; i<Recs.NoOfRecs; i++)
                {

                    if (fAddFilter)
                    {
                        //
                        // The address filter was specfied
                        // If the address matches, then
                        // fMatch will be TRUE after the
                        // function returns.
                        //
                        fMatch = TRUE;
                        ChkAdd(
                                pRow,
                                AddFilter,
                                fOpenFile,
                                pFile,
                                pWinsAdd->IPAdd,
                                &fMatch
                              );
                    }
                    else
                    {
                        fMatch = FALSE;
                    }


                    //
                    // If the address matched or if no filter
                    // was specified or if there was a name
                    // filter and the names matched, print
                    // out the details
                    //
                    if( fCase )
                    {
                        if( fMatch or
                            fSetFilter is FALSE or
                            ( fAddFilter is FALSE and
                              IsBadStringPtrA(pRow->pName, 256) is FALSE and
                              strncmp(pRow->pName, pFilterName, (pRow->NameLen>Len)?Len:pRow->NameLen) is 0 )
                          )
                        {
                            WCHAR   Name[256] = {L'\0'};
                            CHAR    chEndChar = 0x00;
                            LPWSTR  pwszTemp = NULL;
                            DWORD   dwTempLen = 0;
                            
                            DisplayMessage(g_hModule,
                                           MSG_WINS_RECORD_LINE);
                            if( fOpenFile and
                                g_fHeader is FALSE )
                            {
                                DumpMessage(g_hModule,
                                            pFile,
                                            FMSG_WINS_RECORD_TABLE);
                                g_fHeader = TRUE;
                            }
                            
                            chEndChar = (CHAR)pRow->pName[15];
                            pRow->pName[15] = '\0';

                            pwszTemp = WinsOemToUnicode(pRow->pName, NULL);

                            if( pwszTemp is NULL )
                            {
                                DisplayMessage(g_hModule,
                                               EMSG_WINS_OUT_OF_MEMORY);
                                Status = WINSINTF_FAILURE;
                                break;
                            }
                            
                            dwTempLen = ( 16 > wcslen(pwszTemp) ) ? wcslen(pwszTemp) : 16;

                            wcsncpy(Name, pwszTemp, dwTempLen);
                            
                            WinsFreeMemory(pwszTemp);
                            pwszTemp = NULL;
                            
                            for( k=dwTempLen; k<15; k++ )
                            {
                                Name[k] = L' ';
                            }

                            Name[15] = L'[';
                            WinsHexToString(Name+16, (LPBYTE)&chEndChar, 1);
                            Name[18] = L'h';
                            Name[19] = L']';
                            Name[20] = L'\0';
                            
                            if( IsBadStringPtrA(pRow->pName+16, 240) is FALSE )
                            {
                                pwszTemp = WinsOemToUnicode(pRow->pName+16, NULL);
                                if( pwszTemp is NULL )
                                {
                                    DisplayMessage(g_hModule,
                                                   EMSG_WINS_OUT_OF_MEMORY);
                                    Status = WINSINTF_FAILURE;
                                    break;
                                }
                                dwTempLen = ( 240 > wcslen(pwszTemp) ) ? wcslen(pwszTemp) : 240;
                                wcsncpy(Name+20, pwszTemp, dwTempLen);
                                WinsFreeMemory(pwszTemp);
                                pwszTemp = NULL;

                            }
                            
                            Name[wcslen(Name)] = L'\0'; 

                            
                            if( chEndChar is 0x1C )
                            {
                                dwGroup = WINS_GROUP_DOMAIN;
                                pwszGroup = L"DOMAIN NAME   ";
                            }


                            else if( pRow->TypOfRec_e is WINSINTF_E_UNIQUE )
                            {
                                pwszGroup = L"UNIQUE        ";
                                dwGroup = WINS_GROUP_UNIQUE;
                            }
                            else if( pRow->TypOfRec_e is WINSINTF_E_NORM_GROUP )
                            {
                                pwszGroup = L"GROUP         ";
                                dwGroup = WINS_GROUP_GROUP;
                            }
                            else if( pRow->TypOfRec_e is WINSINTF_E_SPEC_GROUP )
                            {
                                pwszGroup = L"INTERNET GROUP";
                                dwGroup = WINS_GROUP_INTERNET;
                            }
                            else
                            {
                                pwszGroup = L"MULTIHOMED    ";
                                dwGroup = WINS_GROUP_MULTIHOMED;
                            }
                            

                           //Load the group string
                            {
                                dwGrouplen = LoadStringW(g_hModule,
                                                        dwGroup,
                                                        wszGroup,
                                                        sizeof(wszGroup)/sizeof(WCHAR));

                                if( dwGrouplen is 0 )
                                    wcscpy(wszGroup, pwszGroup);
                            }

                            if( pRow->State_e is WINSINTF_E_ACTIVE )
                            {
                                pwszState = L"ACTIVE";
                                dwState = WINS_STATE_ACTIVE;
                            }
                            else if( pRow->State_e is WINSINTF_E_RELEASED )
                            {
                                dwState = WINS_STATE_RELEASED;
                                pwszState = L"RELEASED";
                            }
                            else
                            {
                                dwState = WINS_STATE_TOMBSTONE;
                                pwszState = L"TOMBSTONE";
                            }

                            //Load the State string
                            {
                                dwStatelen = LoadStringW(g_hModule,
                                                        dwState,
                                                        wszState,
                                                        sizeof(wszState)/sizeof(WCHAR));

                                if( dwStatelen is 0 )
                                    wcscpy(wszState, pwszState);
                            }



                            if( pRow->fStatic )
                            {
                                dwType = WINS_TYPE_STATIC;
                                pwszType = L"STATIC";
                            }
                            else
                            {
                                dwType = WINS_TYPE_DYNAMIC;
                                pwszType = L"DYNAMIC";
                            }

                            //Load the State string
                            {
                                dwTypelen = LoadStringW(g_hModule,
                                                       dwType,
                                                       wszType,
                                                       sizeof(wszType)/sizeof(WCHAR));

                                if( dwTypelen is 0 )
                                    wcscpy(wszType, pwszType);
                            }

                            iType = 1;
                            pwszTime = GetDateTimeString(pRow->TimeStamp,
                                                         FALSE,
                                                         &iType);
                            DisplayMessage(g_hModule,
                                           MSG_WINS_RECORD_INFO,
                                           Name,
                                           wszType,
                                           wszState,
                                           pRow->VersNo.HighPart,
                                           pRow->VersNo.LowPart,
                                           pRow->NodeTyp,                                           
                                           wszGroup,
                                           iType ? wszInfinite : pwszTime);
                            
                            if( fOpenFile )
                            {
                                DumpMessage(g_hModule,
                                            pFile,
                                            FMSG_WINS_RECORDS_INFO,
                                            Name,
                                            wszType,
                                            wszState,
                                            pRow->VersNo.HighPart,
                                            pRow->VersNo.LowPart,
                                            pRow->NodeTyp,                                           
                                            wszGroup,
                                            iType ? wszInfinite : pwszTime);
                            }

                            if( pwszTime )
                            {
                                WinsFreeMemory(pwszTime);
                                pwszTime = NULL;
                            }
                            fMatch = FALSE;

                            ChkAdd(
                                    pRow,
                                    AddFilter,
                                    fOpenFile,
                                    pFile,
                                    pWinsAdd->IPAdd,
                                    &fMatch
                                  );

                            DisplayMessage(g_hModule,
                                           MSG_WINS_RECORD_LINE);
                            dwCount++;
                        }
                    }
                    else
                    {
                        if( fMatch or
                            fSetFilter is FALSE or
                            ( fAddFilter is FALSE and
                              IsBadStringPtrA(pRow->pName, 256) is FALSE and
                            _strnicmp(pRow->pName, pFilterName, (pRow->NameLen>Len)?Len:pRow->NameLen) is 0 )
                          )
                        {
                            WCHAR   Name[256] = {L'\0'};
                            CHAR    chEndChar = 0x00;
                            LPWSTR  pwszTemp = NULL;
                            DWORD   dwTempLen = 0;

                            DisplayMessage(g_hModule,
                                           MSG_WINS_RECORD_LINE);
                            if( fOpenFile and
                                g_fHeader is FALSE )
                            {
                                DumpMessage(g_hModule,
                                            pFile,
                                            FMSG_WINS_RECORD_TABLE);
                                g_fHeader = TRUE;
                            }
                            
                            chEndChar = (CHAR)pRow->pName[15];
                            pRow->pName[15] = '\0';

                            pwszTemp = WinsOemToUnicode(pRow->pName, NULL);

                            if( pwszTemp is NULL )
                            {
                                DisplayMessage(g_hModule,
                                               EMSG_WINS_OUT_OF_MEMORY);
                                Status = WINSINTF_FAILURE;
                                break;
                            }
                            
                            dwTempLen = ( 16 > wcslen(pwszTemp) ) ? wcslen(pwszTemp) : 16;

                            wcsncpy(Name, pwszTemp, dwTempLen);
                            
                            WinsFreeMemory(pwszTemp);
                            pwszTemp = NULL;
                            
                            for( k=dwTempLen; k<15; k++ )
                            {
                                Name[k] = L' ';
                            }

                            Name[15] = L'[';
                            WinsHexToString(Name+16, (LPBYTE)&chEndChar, 1);
                            Name[18] = L'h';
                            Name[19] = L']';
                            Name[20] = L'\0';
                            
                            if( IsBadStringPtrA(pRow->pName+16, 240) is FALSE )
                            {
                                pwszTemp = WinsOemToUnicode(pRow->pName+16, NULL);
                                if( pwszTemp is NULL )
                                {
                                    DisplayMessage(g_hModule,
                                                   EMSG_WINS_OUT_OF_MEMORY);
                                    Status = WINSINTF_FAILURE;
                                    break;
                                }
                                dwTempLen = ( 240 > wcslen(pwszTemp) ) ? wcslen(pwszTemp) : 240;
                                wcsncpy(Name+20, pwszTemp, dwTempLen);
                                WinsFreeMemory(pwszTemp);
                                pwszTemp = NULL;

                            }
                            
                            Name[wcslen(Name)] = L'\0';

                            if( chEndChar is 0x1C )
                            {
                                dwGroup = WINS_GROUP_DOMAIN;
                                pwszGroup = L"DOMAIN NAME   ";
                            }
                            else if( pRow->TypOfRec_e is WINSINTF_E_UNIQUE )
                            {
                                pwszGroup = L"UNIQUE        ";
                                dwGroup = WINS_GROUP_UNIQUE;
                            }
                            else if( pRow->TypOfRec_e is WINSINTF_E_NORM_GROUP )
                            {
                                pwszGroup = L"GROUP         ";
                                dwGroup = WINS_GROUP_GROUP;
                            }
                            else if( pRow->TypOfRec_e is WINSINTF_E_SPEC_GROUP )
                            {
                                pwszGroup = L"INTERNET GROUP";
                                dwGroup = WINS_GROUP_INTERNET;
                            }
                            else
                            {
                                pwszGroup = L"MULTIHOMED    ";
                                dwGroup = WINS_GROUP_MULTIHOMED;
                            }
                            

                           //Load the group string
                            {
                                dwGrouplen = LoadStringW(g_hModule,
                                                        dwGroup,
                                                        wszGroup,
                                                        sizeof(wszGroup)/sizeof(WCHAR));

                                if( dwGrouplen is 0 )
                                    wcscpy(wszGroup, pwszGroup);
                            }

                            if( pRow->State_e is WINSINTF_E_ACTIVE )
                            {
                                pwszState = L"ACTIVE";
                                dwState = WINS_STATE_ACTIVE;
                            }
                            else if( pRow->State_e is WINSINTF_E_RELEASED )
                            {
                                dwState = WINS_STATE_RELEASED;
                                pwszState = L"RELEASED";
                            }
                            else
                            {
                                dwState = WINS_STATE_TOMBSTONE;
                                pwszState = L"TOMBSTONE";
                            }

                            //Load the State string
                            {
                                dwStatelen = LoadStringW(g_hModule,
                                                        dwState,
                                                        wszState,
                                                        sizeof(wszState)/sizeof(WCHAR));

                                if( dwStatelen is 0 )
                                    wcscpy(wszState, pwszState);
                            }



                            if( pRow->fStatic )
                            {
                                dwType = WINS_TYPE_STATIC;
                                pwszType = L"STATIC";
                            }
                            else
                            {
                                dwType = WINS_TYPE_DYNAMIC;
                                pwszType = L"DYNAMIC";
                            }

                            //Load the State string
                            {
                                dwTypelen = LoadStringW(g_hModule,
                                                       dwType,
                                                       wszType,
                                                       sizeof(wszType)/sizeof(WCHAR));

                                if( dwTypelen is 0 )
                                    wcscpy(wszType, pwszType);
                            }
                            iType = 1;
                            pwszTime = GetDateTimeString(pRow->TimeStamp,
                                                         FALSE,
                                                         &iType);

                            DisplayMessage(g_hModule,
                                           MSG_WINS_RECORD_INFO,
                                           Name,
                                           wszType,
                                           wszState,
                                           pRow->VersNo.HighPart,
                                           pRow->VersNo.LowPart,
                                           pRow->NodeTyp,
                                           wszGroup,
                                           iType ? wszInfinite : pwszTime);

                            if( fOpenFile )
                            {
                                DumpMessage(g_hModule,
                                            pFile,
                                            FMSG_WINS_RECORDS_INFO,
                                            Name,
                                            wszType,
                                            wszState,
                                            pRow->VersNo.HighPart,
                                            pRow->VersNo.LowPart,
                                            pRow->NodeTyp,                                           
                                            wszGroup,
                                            iType ? wszInfinite : pwszTime);
                            }
                            if( pwszTime )
                            {
                                WinsFreeMemory(pwszTime);
                                pwszTime = NULL;
                            }
                            fMatch = FALSE;

                            ChkAdd(
                                    pRow,
                                    AddFilter,
                                    fOpenFile,
                                    pFile,
                                    pWinsAdd->IPAdd,
                                    &fMatch
                                  );

                            DisplayMessage(g_hModule,
                                           MSG_WINS_RECORD_LINE);
                            dwCount++;
                        }

                    }
                    pRow++;
                }// end of for (all recs)

                if (Status != WINSINTF_SUCCESS)
                    break;

                //
                // If a range was chosen and records
                // retrieved are == the limit of 100
                // and if the Max vers no retrieved
                // is less than that specified, ask
                // user if he wishes to continue
                //
                if (!fSetFilter)
                {
                    DisplayMessage(g_hModule,
                                   MSG_WINS_RECORDS_SEARCHED,
                                   Recs.NoOfRecs);                    
                }
                if ( Recs.NoOfRecs < Recs.TotalNoOfRecs and 
                     LiLtr((--pRow)->VersNo,HighVersNo) )
                {
                    LowVersNo.QuadPart = LiAdd(pRow->VersNo, sTmpVersNo);
                    continue;
                }

                DisplayMessage(g_hModule, 
                               MSG_WINS_SEARCHDB_COUNT, 
                               TotalCnt);

                
                break;
            }
            pwszTempTgt = WinsOemToUnicode(pTgtAdd, NULL);

            if( pwszTempTgt is NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_OUT_OF_MEMORY);
                Status = WINSINTF_FAILURE;
                break;
            }

            DisplayMessage(g_hModule,
                           MSG_WINS_NO_RECORD,
                           pwszTempTgt);
            WinsFreeMemory(pwszTempTgt);
            pwszTempTgt = NULL;

        }
        else
        {
            pwszTempTgt = WinsOemToUnicode(pTgtAdd, NULL);

            if( pwszTempTgt is NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_OUT_OF_MEMORY);
                
                break;
            }

            DisplayMessage(g_hModule,
                           MSG_WINS_NO_RECORD, 
                           pwszTempTgt);

            WinsFreeMemory(pwszTempTgt);
            pwszTempTgt = NULL;

        }
        break;

    } // while (TRUE)


    DisplayMessage(g_hModule,
                   MSG_SRVR_RECORD_MATCH,
                   dwCount);



    if( fOpenFile is TRUE )
    {
        fclose(pFile);
        pFile = NULL;
    }

    g_dwSearchCount += dwCount;

    if (Recs.pRow != NULL)
    {
        WinsFreeMem(Recs.pRow);
    }
    return(Status);
} // GetDbRecs

LPWSTR
GetDateTimeString(DWORD_PTR TimeStamp,
                  BOOL      fShort,
                  int      *piType
                  )
{

    DWORD       Status = NO_ERROR,
                dwTime = 0;
    int         iType = 1;

    LPWSTR      pwszTime = NULL;
    
    if( TimeStamp is INFINITE_EXPIRATION )
    {
        iType = 1;
    }
    else
    {
        Status = FormatDateTimeString(TimeStamp,
                                      fShort,
                                      NULL,
                                      &dwTime);

        if( Status is NO_ERROR )
        {
            pwszTime = WinsAllocateMemory((dwTime+1)*sizeof(WCHAR));

            if( pwszTime )
            {
                dwTime++;

                Status = FormatDateTimeString(TimeStamp,
                                              fShort,
                                              pwszTime,
                                              &dwTime);

            }
            if( Status is NO_ERROR )
            {
                iType = 0;
            }
        }
    }

    *piType = iType;
    return pwszTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\srvrmon.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/
#ifndef _SRVRMON_H_
#define _SRVRMON_H_

DWORD
WINAPI
SrvrCommit(
    IN  DWORD   dwAction
);

NS_CONTEXT_ENTRY_FN SrvrMonitor;

DWORD
WINAPI
SrvrUnInit(
    IN  DWORD   dwReserved
);

#endif //_SRVRMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\strdefs.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/
#ifndef _STRDEFS_H_
#define _STRDEFS_H_

#define     WINS_FORMAT_LINE                        1001
#define     WINS_FORMAT_TAB                         1002
#define     WINS_MSG_NULL                           1003

#define     MSG_HELP_START                         _T("%1!-14s! - ")

#define     WINS_TOKEN_SERVER                       L"server"
#define     WINS_TOKEN_ID                           L"id"
#define     WINS_TOKEN_DESC                         L"desc"
#define     WINS_TOKEN_NAME                         L"name"
#define     WINS_TOKEN_ENDCHAR                      L"endchar"
#define     WINS_TOKEN_SCOPE                        L"scope"
#define     WINS_TOKEN_RECORDTYPE                   L"rectype"
#define     WINS_TOKEN_GROUP                        L"group"
#define     WINS_TOKEN_NODE                         L"node"
#define     WINS_TOKEN_IP                           L"ip"
#define     WINS_TOKEN_TYPE                         L"type"
#define     WINS_TOKEN_SERVERS                      L"servers"
#define     WINS_TOKEN_NAMEFILE                     L"namefile"
#define     WINS_TOKEN_NAMELIST                     L"namelist"
#define     WINS_TOKEN_SERVERFILE                   L"serverfile"
#define     WINS_TOKEN_SERVERLIST                   L"serverlist"
#define     WINS_TOKEN_MINVER                       L"minver"
#define     WINS_TOKEN_MAXVER                       L"maxver"
#define     WINS_TOKEN_OP                           L"op"
#define     WINS_TOKEN_PARTNER                      L"partnername"
#define     WINS_TOKEN_DIR                          L"dir"
#define     WINS_TOKEN_FILE                         L"file"
#define     WINS_TOKEN_PARTNERTYPE                  L"partnertype"
#define     WINS_TOKEN_INTERVAL                     L"interval"
#define     WINS_TOKEN_TTL                          L"ttl"
#define     WINS_TOKEN_ATSHUTDOWN                   L"shutdown"
#define     WINS_TOKEN_STATE                        L"state"
#define     WINS_TOKEN_RENEW                        L"renew"
#define     WINS_TOKEN_EXTINCTION                   L"extinction"
#define     WINS_TOKEN_EXTIMEOUT                    L"extimeout"
#define     WINS_TOKEN_VERIFICATION                 L"verification"
#define     WINS_TOKEN_MAXRECORDCOUNT               L"maxrecordcount"
#define     WINS_TOKEN_CHECKAGAINST                 L"checkagainst"
#define     WINS_TOKEN_CHECKEVERY                   L"checkevery"
#define     WINS_TOKEN_START                        L"start"
#define     WINS_TOKEN_STARTUP                      L"strtup"
#define     WINS_TOKEN_RETRY                        L"retry"
#define     WINS_TOKEN_ADDRESSCHANGE                L"addchange"
#define     WINS_TOKEN_VERSION                      L"version"
#define     WINS_TOKEN_MODE                         L"mode"
#define     WINS_TOKEN_PROPAGATION                  L"propagation"
#define     WINS_TOKEN_RECCOUNT                     L"count"
#define     WINS_TOKEN_CONFIRM                      L"confirm"
#define     WINS_TOKEN_CASE                         L"case"
#define     WINS_TOKEN_OWNER                        L"owner"
#define     WINS_TOKEN_UPDATE                       L"update"
#define     WINS_TOKEN_NETBIOS                      L"netbios"
#define     WINS_TOKEN_DBCHANGE                     L"dbchange"
#define     WINS_TOKEN_EVENT                        L"event"
#define     WINS_TOKEN_VALUE                        L"value"
#define     WINS_TOKEN_INCLPARTNER                  L"inclpartner"
#define     WINS_TOKEN_ALL                          L"all"
#define     WINS_TOKEN_FORCE                        L"force"

#define     CMD_GROUP_ADD                           L"add"
#define     CMD_GROUP_CHECK                         L"check"
#define     CMD_GROUP_DELETE                        L"delete"
#define     CMD_GROUP_INIT                          L"init"
#define     CMD_GROUP_RESET                         L"reset"
#define     CMD_GROUP_SET                           L"set"
#define     CMD_GROUP_SHOW                          L"show"


#define     CMD_WINS_HELP1                          L"help"
#define     CMD_WINS_HELP2                          L"?"
#define     CMD_WINS_HELP3                          L"/?"
#define     CMD_WINS_HELP4                          L"-?"
#define     CMD_WINS_DUMP                           L"dump"


#define     CMD_WINS_ADD_SERVER                     L"add    server"
#define     CMD_WINS_DELETE_SERVER                  L"delete server"
#define     CMD_WINS_SHOW_SERVER                    L"show   server"


#define     HLP_WINS_HELP1                          2601
#define     HLP_WINS_HELP1_EX                       2602
#define     HLP_WINS_HELP2                          2604
#define     HLP_WINS_HELP2_EX                       2605
#define     HLP_WINS_HELP3                          2606
#define     HLP_WINS_HELP3_EX                       2607
#define     HLP_WINS_HELP4                          2608
#define     HLP_WINS_HELP4_EX                       2609
#define     HLP_WINS_DUMP                           2612
#define     HLP_WINS_DUMP_EX                        2613


#define     HLP_WINS_ADD_SERVER                     2701
#define     HLP_WINS_ADD_SERVER_EX                  2702
#define     HLP_WINS_CONTEXT_SERVER                 2703
#define     HLP_WINS_CONTEXT_SERVER_EX              2704

#define     HLP_WINS_DELETE_SERVER                  2711
#define     HLP_WINS_DELETE_SERVER_EX               2712


#define     HLP_WINS_SHOW_SERVER                    2721
#define     HLP_WINS_SHOW_SERVER_EX                 2722


#define     HLP_GROUP_ADD                           2801
#define     HLP_GROUP_CHECK                         2802
#define     HLP_GROUP_DELETE                        2803
#define     HLP_GROUP_INIT                          2804
#define     HLP_GROUP_RESET                         2805
#define     HLP_GROUP_SET                           2806
#define     HLP_GROUP_SHOW                          2807


#define     CMD_SRVR_HELP1                          2901
#define     CMD_SRVR_HELP2                          2902
#define     CMD_SRVR_HELP3                          2903
#define     CMD_SRVR_HELP4                          2904
#define     CMD_SRVR_LIST                           2905
#define     CMD_SRVR_DUMP                           2906

#define     HLP_SRVR_ADD_FILTER                     3001
#define     HLP_SRVR_ADD_FILTER_EX                  3002
#define     HLP_SRVR_ADD_NAME                       3003
#define     HLP_SRVR_ADD_NAME_EX                    3004
#define     HLP_SRVR_ADD_PARTNER                    3005
#define     HLP_SRVR_ADD_PARTNER_EX                 3006
#define     HLP_SRVR_ADD_PNGSERVER                  3007
#define     HLP_SRVR_ADD_PNGSERVER_EX               3008
#define     HLP_SRVR_ADD_PGSERVER                   3009
#define     HLP_SRVR_ADD_PGSERVER_EX                3010

#define     HLP_SRVR_CHECK_DATABASE                 3021
#define     HLP_SRVR_CHECK_DATABASE_EX              3022
#define     HLP_SRVR_CHECK_NAME                     3023
#define     HLP_SRVR_CHECK_NAME_EX                  3024
#define     HLP_SRVR_CHECK_VERSION                  3025
#define     HLP_SRVR_CHECK_VERSION_EX               3026

#define     HLP_SRVR_DELETE_NAME                    3041
#define     HLP_SRVR_DELETE_NAME_EX                 3042
#define     HLP_SRVR_DELETE_RECORDS                 3043
#define     HLP_SRVR_DELETE_RECORDS_EX              3044
#define     HLP_SRVR_DELETE_PARTNER                 3045
#define     HLP_SRVR_DELETE_PARTNER_EX              3046
#define     HLP_SRVR_DELETE_WINS                    3047
#define     HLP_SRVR_DELETE_WINS_EX                 3048
#define     HLP_SRVR_DELETE_PNGSERVER               3049
#define     HLP_SRVR_DELETE_PNGSERVER_EX            3050
#define     HLP_SRVR_DELETE_PGSERVER                3051
#define     HLP_SRVR_DELETE_PGSERVER_EX             3052

#define     HLP_SRVR_INIT_BACKUP                    3061
#define     HLP_SRVR_INIT_BACKUP_EX                 3062
#define     HLP_SRVR_INIT_COMPACT                   3063
#define     HLP_SRVR_INIT_COMPACT_EX                3064
#define     HLP_SRVR_INIT_EXPORT                    3065
#define     HLP_SRVR_INIT_EXPORT_EX                 3066
#define     HLP_SRVR_INIT_IMPORT                    3067
#define     HLP_SRVR_INIT_IMPORT_EX                 3068
#define     HLP_SRVR_INIT_PULL                      3069
#define     HLP_SRVR_INIT_PULL_EX                   3070
#define     HLP_SRVR_INIT_PUSH                      3071
#define     HLP_SRVR_INIT_PUSH_EX                   3072
#define     HLP_SRVR_INIT_REPLICATE                 3073
#define     HLP_SRVR_INIT_REPLICATE_EX              3074
#define     HLP_SRVR_INIT_RESTORE                   3075
#define     HLP_SRVR_INIT_RESTORE_EX                3076
#define     HLP_SRVR_INIT_SCAVENGE                  3077
#define     HLP_SRVR_INIT_SCAVENGE_EX               3078
#define     HLP_SRVR_INIT_SEARCH                    3079
#define     HLP_SRVR_INIT_SEARCH_EX                 3080
#define     HLP_SRVR_INIT_PULLRANGE                 3181
#define     HLP_SRVR_INIT_PULLRANGE_EX              3182

#define     HLP_SRVR_RESET_COUNTER                  3085
#define     HLP_SRVR_RESET_COUNTER_EX               3086

#define     HLP_SRVR_SET_AUTOPARTNERCONFIG          3091
#define     HLP_SRVR_SET_AUTOPARTNERCONFIG_EX       3092
#define     HLP_SRVR_SET_AUTOREFRESH                3093
#define     HLP_SRVR_SET_AUTOREFRESH_EX             3094
#define     HLP_SRVR_SET_BACKUPPATH                 3095
#define     HLP_SRVR_SET_BACKUPPATH_EX              3096
#define     HLP_SRVR_SET_FILTER                     3097
#define     HLP_SRVR_SET_FILTER_EX                  3098
#define     HLP_SRVR_SET_MIGRATEFLAG                3099
#define     HLP_SRVR_SET_MIGRATEFLAG_EX             3100
#define     HLP_SRVR_SET_NAMERECORD                 3101
#define     HLP_SRVR_SET_NAMERECORD_EX              3102
#define     HLP_SRVR_SET_PERIODICDBCHECKING         3103
#define     HLP_SRVR_SET_PERIODICDBCHECKING_EX      3104
#define     HLP_SRVR_SET_PULLPERSISTENTCONNECTION   3105
#define     HLP_SRVR_SET_PULLPERSISTENTCONNECTION_EX 3106
#define     HLP_SRVR_SET_PUSHPERSISTENTCONNECTION   3107
#define     HLP_SRVR_SET_PUSHPERSISTENTCONNECTION_EX 3108
#define     HLP_SRVR_SET_PULLPARAM                  3109
#define     HLP_SRVR_SET_PULLPARAM_EX               3110
#define     HLP_SRVR_SET_PUSHPARAM                  3111
#define     HLP_SRVR_SET_PUSHPARAM_EX               3112
#define     HLP_SRVR_SET_REPLICATEFLAG              3113
#define     HLP_SRVR_SET_REPLICATEFLAG_EX           3114
#define     HLP_SRVR_SET_LOGPARAM                   3115
#define     HLP_SRVR_SET_LOGPARAM_EX                3116
#define     HLP_SRVR_SET_BURSTPARAM                 3117
#define     HLP_SRVR_SET_BURSTPARAM_EX              3118
#define     HLP_SRVR_SET_STARTVERSION               3119
#define     HLP_SRVR_SET_STARTVERSION_EX            3120
#define		HLP_SRVR_SET_DEFAULTPARAM				3121
#define		HLP_SRVR_SET_DEFAULTPARAM_EX			3122
#define     HLP_SRVR_SET_PGMODE                     3123
#define     HLP_SRVR_SET_PGMODE_EX                  3124

#define     HLP_SRVR_SHOW_DATABASE                  3131
#define     HLP_SRVR_SHOW_DATABASE_EX               3132
#define     HLP_SRVR_SHOW_FILTERS                   3133
#define     HLP_SRVR_SHOW_FILTERS_EX                3134
#define     HLP_SRVR_SHOW_INFO                      3135
#define     HLP_SRVR_SHOW_INFO_EX                   3136
#define     HLP_SRVR_SHOW_PARTNER                   3137
#define     HLP_SRVR_SHOW_PARTNER_EX                3138
#define     HLP_SRVR_SHOW_NAME                      3139
#define     HLP_SRVR_SHOW_NAME_EX                   3140
#define     HLP_SRVR_SHOW_SERVER                    3141
#define     HLP_SRVR_SHOW_SERVER_EX                 3142
#define     HLP_SRVR_SHOW_SERVERSTATISTICS          3143
#define     HLP_SRVR_SHOW_SERVERSTATISTICS_EX       3144
#define     HLP_SRVR_SHOW_VERSION                   3145
#define     HLP_SRVR_SHOW_VERSION_EX                3146
#define     HLP_SRVR_SHOW_VERSIONMAP                3147
#define     HLP_SRVR_SHOW_VERSIONMAP_EX             3148
#define     HLP_SRVR_SHOW_BYNAME                    3149
#define     HLP_SRVR_SHOW_BYNAME_EX                 3150
#define     HLP_SRVR_SHOW_BYVERSION                 3151
#define     HLP_SRVR_SHOW_BYVERSION_EX              3152
#define     HLP_SRVR_SHOW_PARTNERPROPERTIES         3153
#define     HLP_SRVR_SHOW_PARTNERPROPERTIES_EX      3154
#define     HLP_SRVR_SHOW_PULLPARTNERPROPERTIES     3155
#define     HLP_SRVR_SHOW_PULLPARTNERPROPERTIES_EX  3156
#define     HLP_SRVR_SHOW_PUSHPARTNERPROPERTIES     3157
#define     HLP_SRVR_SHOW_PUSHPARTNERPROPERTIES_EX  3158
#define     HLP_SRVR_SHOW_DOMAIN                    3159
#define     HLP_SRVR_SHOW_DOMAIN_EX                 3160
#define     HLP_SRVR_SHOW_RECCOUNT                  3161
#define     HLP_SRVR_SHOW_RECCOUNT_EX               3162
#define     HLP_SRVR_SHOW_RECBYVERSION              3163
#define     HLP_SRVR_SHOW_RECBYVERSION_EX           3164


#define     CMD_SRVR_ADD_FILTER                     L"add    filter"
#define     CMD_SRVR_ADD_NAME                       L"add    name"
#define     CMD_SRVR_ADD_PARTNER                    L"add    partner"
#define     CMD_SRVR_ADD_PNGSERVER                  L"add    pngserver"
#define     CMD_SRVR_ADD_PGSERVER                   L"add    pgserver"

#define     CMD_SRVR_CHECK_DATABASE                 L"check  database"
#define     CMD_SRVR_CHECK_NAME                     L"check  name"
#define     CMD_SRVR_CHECK_VERSION                  L"check  version"


#define     CMD_SRVR_DELETE_NAME                    L"delete name"
#define     CMD_SRVR_DELETE_RECORDS                 L"delete records"
#define     CMD_SRVR_DELETE_PARTNER                 L"delete partner"
#define     CMD_SRVR_DELETE_WINS                    L"delete owners"
#define     CMD_SRVR_DELETE_PNGSERVER               L"delete pngserver"
#define     CMD_SRVR_DELETE_PGSERVER                L"delete pgserver"

#define     CMD_SRVR_RESET_COUNTER                  L"reset  statistics"

#define     CMD_SRVR_INIT_BACKUP                    L"init   backup"
#define     CMD_SRVR_INIT_COMPACT                   L"init   compact"
#define     CMD_SRVR_INIT_EXPORT                    L"init   export"
#define     CMD_SRVR_INIT_IMPORT                    L"init   import"
#define     CMD_SRVR_INIT_PULL                      L"init   pull"
#define     CMD_SRVR_INIT_PULLRANGE                 L"init   pullrange"
#define     CMD_SRVR_INIT_PUSH                      L"init   push"
#define     CMD_SRVR_INIT_REPLICATE                 L"init   replicate"
#define     CMD_SRVR_INIT_RESTORE                   L"init   restore"
#define     CMD_SRVR_INIT_SCAVENGE                  L"init   scavenge"
#define     CMD_SRVR_INIT_SEARCH                    L"init   search"

#define     CMD_SRVR_SET_AUTOPARTNERCONFIG          L"set    autopartnerconfig"
#define     CMD_SRVR_SET_AUTOREFRESH                L"set    autorefresh"
#define     CMD_SRVR_SET_BACKUPPATH                 L"set    backuppath"
#define		CMD_SRVR_SET_DEFAULTPARAM				L"set	 defaultparam"
#define     CMD_SRVR_SET_FILTER                     L"set    filter"
#define     CMD_SRVR_SET_MIGRATEFLAG                L"set    migrateflag"
#define     CMD_SRVR_SET_NAMERECORD                 L"set    namerecord"
#define     CMD_SRVR_SET_PERIODICDBCHECKING         L"set    periodicdbchecking"
#define     CMD_SRVR_SET_PULLPERSISTENTCONNECTION   L"set    pullpartnerconfig"
#define     CMD_SRVR_SET_PUSHPERSISTENTCONNECTION   L"set    pushpartnerconfig"
#define     CMD_SRVR_SET_PULLPARAM                  L"set    pullparam"
#define     CMD_SRVR_SET_PUSHPARAM                  L"set    pushparam"
#define     CMD_SRVR_SET_REPLICATEFLAG              L"set    replicateflag"
#define     CMD_SRVR_SET_LOGPARAM                   L"set    logparam"
#define     CMD_SRVR_SET_BURSTPARAM                 L"set    burstparam"
#define     CMD_SRVR_SET_STARTVERSION               L"set    startversion"
#define     CMD_SRVR_SET_PGMODE                     L"set    pgmode"

#define     CMD_SRVR_SHOW_DATABASE                  L"show   database"
#define     CMD_SRVR_SHOW_DOMAIN                    L"show   browser"
#define     CMD_SRVR_SHOW_FILTERS                   L"show   filters"
#define     CMD_SRVR_SHOW_INFO                      L"show   info"
#define     CMD_SRVR_SHOW_PARTNER                   L"show   partner"
#define     CMD_SRVR_SHOW_NAME                      L"show   name"
#define     CMD_SRVR_SHOW_SERVER                    L"show   server"
#define     CMD_SRVR_SHOW_SERVERSTATISTICS          L"show   statistics"
#define     CMD_SRVR_SHOW_VERSION                   L"show   version"
#define     CMD_SRVR_SHOW_VERSIONMAP                L"show   versionmap"
#define     CMD_SRVR_SHOW_PARTNERPROPERTIES         L"show   partnerproperties"
#define     CMD_SRVR_SHOW_PULLPARTNERPROPERTIES     L"show   pullpartnerconfig"
#define     CMD_SRVR_SHOW_PUSHPARTNERPROPERTIES     L"show   pushpartnerconfig"
#define     CMD_SRVR_SHOW_RECCOUNT                  L"show   reccount"
#define     CMD_SRVR_SHOW_RECBYVERSION              L"show   recbyversion"

#define     EMSG_WINS_ADD_SERVER                    4500
#define     EMSG_WINS_DELETE_SERVER                 4501
#define     EMSG_WINS_SHOW_SERVER                   4502
#define     EMSG_WINS_REQUIRED_PARAMETER            4503


#define     ERROR_INVALID_DB_VERSION                25001
#define     ERROR_INVALID_IPADDRESS                 25002
#define     ERROR_INVALID_PARTNER_NAME              25003
#define     ERROR_NO_PARTNER_EXIST                  25004
#define     ERROR_WINS_BIND_FAILED                  25005
#define     ERROR_INVALID_PARAMETER_SPECIFICATION   25006

#define     EMSG_INVALID_DB_VERSION                 35001
#define     EMSG_INVALID_IPADDRESS                  35002
#define     EMSG_INVALID_PARTNER_NAME               35003
#define     EMSG_NO_PARTNER_EXIST                   35004
#define     EMSG_INVALID_PARAMETER_SPECIFICATION    35006
#define     EMSG_SRVR_ATLEAST_ONE_PNG               35007
#define     EMSG_SRVR_ATLEAST_ONE_PG                35008

#define     EMSG_WINS_ERROR_SUCCESS                 7000
#define     EMSG_WINS_INCOMPLETE_COMMAND            7001
#define     EMSG_WINS_UNKNOWN_SERVER                7002
#define     EMSG_WINS_INVALID_COMPUTERNAME          7003
#define     EMSG_WINS_NOT_ENOUGH_MEMORY             7004
#define     EMSG_WINS_FAILED                        7005
#define     EMSG_WINS_INVALID_SERVER_HANDLE         7006
#define     EMSG_WINS_INVALID_COMPUTER_NAME         7007
#define     EMSG_WINS_OWNERDB_FAILED                7008
#define     EMSG_WINS_INVALID_PULLPARTNER           7009
#define     EMSG_WINS_INVALID_PUSHPARTNER           7010
#define     EMSG_WINS_SERVERPROP_FAILED             7011
#define     EMSG_WINS_VERSION_HIGHER                7012
#define     EMSG_WINS_VERSION_CORRECT               7013
#define     EMSG_WINS_BIND_FAILED                   7014
#define     EMSG_WINS_INVALID_NAME                  7015
#define     EMSG_WINS_VALUE_OUTOFRANGE              7016
#define     EMSG_WINS_INVALID_FILENAME              7017
#define     EMSG_WINS_FILEREAD_FAILED               7018
#define     EMSG_WINS_EMPTY_FILE                    7019
#define     EMSG_WINS_INVALID_IPADDRESS             7020
#define     EMSG_WINS_NO_NAMES                      7021
#define     EMSG_WINS_NO_SERVERS                    7022
#define     EMSG_WINS_DISPLAY_STRING                7023
#define     EMSG_WINS_PULL_FAILED                   7024
#define     EMSG_WINS_PUSH_FAILED                   7025
#define     EMSG_WINS_NO_PULLPARTNER                7026
#define     EMSG_WINS_NO_PUSHPARTNER                7027
#define     EMSG_WINS_INVALID_PARAMETER             7028
#define     EMSG_WINS_OUT_OF_MEMORY                 7029
#define     EMSG_WINS_NO_MORE_ITEMS                 7030
#define     EMSG_WINS_MORE_DATA                     7031
#define     EMSG_WINS_SERVICE_FAILED                7032
#define     EMSG_WINS_DELETE_FILE                   7033
#define     EMSG_WINS_LOCAL_SERVER                  7034
#define     EMSG_WINS_ACCESS_DENIED                 7035
#define     EMSG_WINS_RESTORE_IMPROPER              7036
#define     EMSG_WINS_REGCONNECT_FAILED             7037
#define     EMSG_WINS_REGOPEN_FAILED                7038
#define     EMSG_WINS_REGSETVAL_FAILED              7039
#define     EMSG_WINS_VERIFY_ADDRESS                7040
#define     EMSG_WINS_ONE_INVALID_PARAMETER         7041
#define     EMSG_SRVR_BURST_PARAM_OUTOFRANGE        7042
#define     EMSG_WINS_OPERATION_FAILED              7043

#define     EMSG_SRVR_ADD_NAME                      7101
#define     EMSG_SRVR_ADD_PARTNER                   7102
#define     EMSG_SRVR_ADD_PNGSERVER                 7103
#define     EMSG_SRVR_ADD_PGSERVER                  7104
#define     EMSG_SRVR_DELETE_NAME                   7105
#define     EMSG_SRVR_DELETE_PARTNER                7106
#define     EMSG_SRVR_DELETE_PNGSERVER              7107
#define     EMSG_SRVR_DELETE_PGSERVER               7108
#define     EMSG_SRVR_DELETE_RECORDS                7109
#define     EMSG_SRVR_DELETE_WINS                   7110
#define     EMSG_SRVR_CHECK_NAME                    7111
#define     EMSG_SRVR_CHECK_DATABASE                7112
#define     EMSG_SRVR_CHECK_VERSION                 7113
#define     EMSG_SRVR_INIT_BACKUP                   7114
#define     EMSG_SRVR_INIT_COMPACT                  7115
#define     EMSG_SRVR_INIT_EXPORT                   7116
#define     EMSG_SRVR_INIT_IMPORT                   7117
#define     EMSG_SRVR_INIT_PULL                     7118
#define     EMSG_SRVR_INIT_PUSH                     7119
#define     EMSG_SRVR_INIT_REPLICATE                7120
#define     EMSG_SRVR_INIT_RESTORE                  7121
#define     EMSG_SRVR_INIT_SCAVENGE                 7122
#define     EMSG_SRVR_INIT_SEARCH                   7123
#define     EMSG_SRVR_SET_AUTOPARTNERCONFIG         7124
#define     EMSG_SRVR_SET_AUTOREFRESH               7125
#define     EMSG_SRVR_SET_BACKUPPATH                7126
#define     EMSG_SRVR_SET_FILTER                    7127
#define     EMSG_SRVR_SET_MIGRATEFLAG               7128
#define     EMSG_SRVR_SET_NAMERECORD                7129
#define     EMSG_SRVR_SET_PERIODICDBCHECKING        7130
#define     EMSG_SRVR_SET_PULLPERSISTENTCONNECTION  7131
#define     EMSG_SRVR_SET_PUSHPERSISTENTCONNECTION  7132
#define     EMSG_SRVR_SET_PULLPARAM                 7133
#define     EMSG_SRVR_SET_PUSHPARAM                 7134
#define     EMSG_SRVR_SET_REPLICATEFLAG             7135
#define     EMSG_SRVR_SHOW_DATABASE                 7136
#define     EMSG_SRVR_SHOW_FILTERS                  7137
#define     EMSG_SRVR_SHOW_INFO                     7138
#define     EMSG_SRVR_SHOW_PARTNER                  7139
#define     EMSG_SRVR_SHOW_NAME                     7140
#define     EMSG_SRVR_SHOW_SERVER                   7141
#define     EMSG_SRVR_SHOW_STATISTICS               7142
#define     EMSG_SRVR_SHOW_VERSION                  7143
#define     EMSG_SRVR_SHOW_VERSIONMAP               7144
#define     EMSG_SRVR_SHOW_BYNAME                   7145
#define     EMSG_SRVR_SHOW_BYVERSION                7146
#define     EMSG_SRVR_SHOW_PARTNERPROPERTIES        7147
#define     EMSG_SRVR_SHOW_PULLPARTNERPROPERTIES    7148
#define     EMSG_SRVR_SHOW_PUSHPARTNERPROPERTIES    7149
#define     EMSG_SRVR_SHOW_DOMAIN                   7150
#define     EMSG_SRVR_INIT_PULLRANGE                7151
#define     EMSG_WINS_DUMP                          7152
#define     EMSG_SRVR_DUMP                          7153
#define     EMSG_SRVR_SHOW_RECCOUNT                 7154
#define     EMSG_SRVR_SHOW_RECBYVERSION             7155
#define     EMSG_SRVR_SET_LOGPARAM                  7156
#define     EMSG_SRVR_SET_BURSTPARAM                7157
#define     EMSG_SRVR_SET_STARTVERSION              7158
#define     EMSG_WINS_FILEOPEN_FAILED               7159
#define     EMSG_WINS_GETSTATUS_FAILED              7160
#define     EMSG_SRVR_NO_REPLPARTNERS               7161
#define     EMSG_SRVR_RETRIEVEDB_FAILED             7162
#define     EMSG_SRVR_ERROR_MESSAGE                 7163
#define     EMSG_WINS_RETRIEVEDB_PARTIAL            7164
#define     EMSG_ACCESS_NOT_DETERMINED              7165
#define     EMSG_SRVR_NOBACKUP_PATH                 7166
#define     EMSG_SRVR_UNABLE_BIND                   7167
#define     EMSG_WINS_GET_WINSSTATUS                7168
#define     EMSG_WINS_OWNER_DATABASE                7169
#define     EMSG_WINS_UNABLE_VERIFY                 7170
#define     EMSG_WINS_SENDTO_FAILED                 7171
#define     EMSG_WINS_GETRESPONSE_FAILED            7172
#define     EMSG_WINS_NAMECHECK_FAILED              7173
#define     EMSG_WINS_NAME_NOT_FOUND                7174
#define     EMSG_WINS_NO_RESPONSE                   7175
#define     EMSG_WINS_NAME_INCONSISTENCY            7176
#define     EMSG_WINS_VERIFIED_ADDRESS              7177
#define     EMSG_WINS_NAMEQUERY_RESULT              7178
#define     EMSG_WINS_WINS_NEVERRESPONDED           7179
#define     EMSG_WINS_WINS_INCOMPLETE               7180
#define     EMSG_WINS_ADDRESS_VERIFY_FAILED         7181
#define     EMSG_WINS_ADMIN_INSTALL                 7182
#define		EMSG_WINS_NOT_CONFIGURED				7183
#define		EMSG_SRVR_SET_DEFAULTPARAM				7184
#define     EMSG_SRVR_INVALID_PARTNER               7185
#define     EMSG_SRVR_IP_DISCARD                    7186
#define     EMSG_SRVR_NO_IP_ADDED_PNG               7187
#define     EMSG_SRVR_NO_IP_ADDED_PG                7188
#define     EMSG_SRVR_NOT_TAGGED                    7189
#define     EMSG_SRVR_NOT_UNTAGGED                  7190
#define     EMSG_SRVR_NO_VALID_IP                   7191
#define     EMSG_SRVR_NAME_NOT_VERIFIED             7192
#define     EMSG_SRVR_RENEW_INTERVAL                7193
#define     EMSG_SRVR_TOMBSTONE_TIMEOUT             7194
#define     EMSG_SRVR_TOMBSTONE_INTERVAL            7195
#define     EMSG_SRVR_VERIFY_INTERVAL               7196
#define     EMSG_WINS_NAME_VERIFIED                 7197
#define     EMSG_SRVR_DUPLICATE_DISCARD             7198
#define     EMSG_SRVR_INVALID_NETBIOS_NAME          7199
#define     EMSG_SRVR_PG_INVALIDOP                  7200
#define     EMSG_SRVR_PNG_INVALIDOP                 7201
#define     EMSG_SRVR_SET_PGMODE                    7202

#define     MSG_WINS_DISPLAY_NAME                   8001
#define     MSG_WINS_IPADDRESS_STRING               8002
#define     MSG_WINS_OWNER_ADDRESS                  8003
#define     MSG_WINS_MEMBER_ADDRESS                 8004
#define     MSG_WINS_VERSION_INFO                   8005
#define     MSG_WINS_SERVER_NAME                    8006
#define     MSG_WINS_REFRESH_INTERVAL               8007
#define     MSG_WINS_TOMBSTONE_INTERVAL             8008
#define     MSG_WINS_TOMBSTONE_TIMEOUT              8009
#define     MSG_WINS_VERIFY_INTERVAL                8010
#define     MSG_WINS_PRIORITY_CLASS                 8011
#define     MSG_WINS_WORKER_THREAD                  8012
#define     MSG_WINS_OWNER_TABLE                    8013
#define     MSG_WINS_OWNER_INFO                     8014
#define     MSG_WINS_NO_RECORDS                     8015
#define     MSG_WINS_OWNER_INFO_MAX                 8016
#define     MSG_WINS_TIMESTAMP                      8017
#define     MSG_WINS_LAST_INIT                      8018
#define     MSG_WINS_PLANNED_SCV                    8019
#define     MSG_WINS_TRIGGERED_SCV                  8020
#define     MSG_WINS_TOMBSTONE_SCV                  8021
#define     MSG_WINS_REPLICA_VERIFICATION           8022
#define     MSG_WINS_PLANNED_REPLICATION            8023
#define     MSG_WINS_TRIGGERED_REPLICATION          8024
#define     MSG_WINS_RESET_COUNTER                  8025
#define     MSG_WINS_COUNTER_INFORMATION            8026
#define     MSG_WINS_PARTNER_TABLE                  8027
#define     MSG_WINS_PARTNER_INFO                   8028
#define     MSG_WINS_RECORDS_COUNT                  8029
#define     MSG_WINS_RECORDS_RETRIEVED              8030
#define     MSG_WINS_RECORD_LINE                    8031
#define     MSG_WINS_MEMBER_COUNT                   8032
#define     MSG_WINS_NODE_ADDRESS                   8033
#define     MSG_WINS_RECORD_INFO                    8034
#define     MSG_WINS_SEARCHING_STATUS               8035
#define     MSG_SRVR_REPLICATE_STATE                8036
#define     MSG_SRVR_MIGRATE_STATE                  8037
#define     MSG_SRVR_SELFFINDPNRS_STATE             8038
#define     MSG_SRVR_MCAST_INTERVAL                 8039
#define     MSG_SRVR_MCAST_TTL                      8040
#define     MSG_SRVR_PULL_PERSISTENCE_STATE         8041
#define     MSG_SRVR_PUSH_PERSISTENCE_STATE         8042
#define     MSG_SRVR_PULL_INITTIMEREPL_STATE        8043
#define     MSG_SRVR_PUSH_INITTIMEREPL_STATE        8044
#define     MSG_SRVR_PULL_STARTTIME                 8045
#define     MSG_WINS_PULL_REPLINTERVAL              8046
#define     MSG_WINS_PULL_RETRYCOUNT                8047
#define     MSG_SRVR_PUSH_INFO                      8048
#define     MSG_SRVR_PULL_INFO                      8049
#define     MSG_SRVR_PUSH_ONADDCHANGE               8050
#define     MSG_SRVR_PUSH_UPDATECOUNT               8051
#define     MSG_SRVR_AUTOCONFIGURE                  8052
#define     MSG_WINS_PULLPARTNER_INFO               8053
#define     MSG_WINS_PUSHPARTNER_INFO               8054
#define     MSG_WINS_PARTNERLIST_TABLE              8055
#define     MSG_WINS_PARTNERLIST_ENTRY              8056
#define     MSG_WINS_DATABASE_BACKUPPARAM           8057
#define     MSG_WINS_DATABASE_BACKUPDIR             8058
#define     MSG_WINS_DATABASE_BACKUPONTERM          8059
#define     MSG_WINS_NAMERECORD_SETTINGS            8060
#define     MSG_WINS_NAMERECORD_REFRESHINTVL        8061
#define     MSG_WINS_NAMERECORD_TOMBSTONEINTVL      8062
#define     MSG_WINS_NAMERECORD_TOMBSTONETMOUT      8063
#define     MSG_WINS_NAMERECORD_VERIFYINTVL         8064
#define     MSG_WINS_DBCC_PARAM                     8065
#define     MSG_WINS_DBCC_STATE                     8066
#define     MSG_WINS_DBCC_MAXCOUNT                  8067
#define     MSG_WINS_DBCC_CHECKAGAINST              8068
#define     MSG_WINS_DBCC_CHECKEVERY                8069
#define     MSG_WINS_DBCC_STARTAT                   8070
#define     MSG_WINS_LOGGING_PARAM                  8071
#define     MSG_WINS_LOGGING_FLAG                   8072
#define     MSG_WINS_LOGGING_DETAILS                8073
#define     MSG_WINS_BURSTHNDL_PARAM                8074
#define     MSG_WINS_BURSTHNDL_STATE                8075
#define     MSG_WINS_BURSTHNDL_SIZE                 8076
#define     MSG_WINS_TIME_WARNING                   8077
#define     MSG_WINS_SEND_PUSH                      8078
#define     MSG_WINS_SEND_PULL                      8079
#define     MSG_WINS_TRIGGER_DONE                   8080
#define     MSG_DLL_LOAD_FAILED                     8081
#define     MSG_WINS_SERVICE_TIME                   8082
#define     MSG_WINS_SEARCHDB_COUNT                 8083
#define     MSG_WINS_NO_RECORD                      8084
#define     MSG_WINS_RECORDS_SEARCHED               8085
#define     MSG_WINS_RECORD_TABLE                   8086
#define     MSG_WINS_RECORD_ENTRY                   8087
#define     MSG_WINS_RECORD_IPADDRESS               8088
#define     MSG_WINS_RECORD_DESC                    8089
#define     MSG_WINS_NO_PARTNER                     8090
#define     MSG_WINS_PARTNER_COUNT                  8091
#define     MSG_WINS_PNGSERVER_TABLE                8092
#define     MSG_WINS_PNGSERVER_ENTRY                8093
#define     MSG_WINS_NO_PNGSERVER                   8094
#define     MSG_WINS_CONFIRMATION_DENIED            8095
#define     MSG_WINS_COMMAND_QUEUED                 8096
#define     MSG_WINS_DOMAIN_COUNT                   8097
#define     MSG_WINS_DOMAIN_TABLE                   8098
#define     MSG_WINS_DOMAIN_ENTRY                   8099
#define     MSG_WINS_DELETING_RECORD                8101
#define     MSG_WINS_TOMBSTONE_RECORD               8102
#define     MSG_SRVR_FILTER_RECCOUNT                8103
#define     MSG_WINS_RECORDS_COUNT_OWNER            8104
#define     MSG_SRVR_START_VERSION                  8105
#define     MSG_SRVR_RECORD_MATCH                   8106
#define     MSG_WINS_SOTABLE_HEADER                 8107
#define     MSG_WINS_MASTEROWNER_INDEX              8108
#define     MSG_WINS_MASTEROWNER_INDEX1             8109
#define     MSG_WINS_MAP_SOURCE                     8110
#define     MSG_WINS_INDEXTOIP_TABLE                8111
#define     MSG_WINS_INDEXTOIP_ENTRY                8112
#define     MSG_SRVR_MAPTABLE_HEADER                8113
#define     MSG_WINS_GETSTATUS_SUCCESS              8114
#define     MSG_SRVR_SEARCH_COUNT                   8115
#define     MSG_NO_DEFAULT_PULL                     8116
#define     MSG_NO_DEFAULT_PUSH                     8117
#define     MSG_WINS_OWNER_RECCOUNT                 8118
#define     MSG_WINS_GET_MAPTABLE                   8119
#define     MSG_WINS_SEND_NAMEQUERY                 8120
#define     MSG_WINS_PASS_COUNT                     8121
#define     MSG_WINS_DISPLAY_STRING                 8122
#define     MSG_SRVR_NAME_VERIFIED                  8123
#define     MSG_WINS_RESULTS                        8124
#define     MSG_WINS_FINAL_RESULTS                  8125
#define     MSG_SRVR_TOTAL_RECCOUNT                 8126
#define     MSG_SRVR_RETRIEVE_DATABASE              8127
#define     MSG_WINS_PGSERVER_TABLE                 8128
#define     MSG_WINS_PGSERVER_ENTRY                 8129
#define     MSG_WINS_NO_PGSERVER                    8130
#define     MSG_WINS_NOACCESS                       8131
#define     MSG_WINS_ROACCESS                       8132
#define     MSG_WINS_RWACCESS                       8133

#define     FMSG_WINS_RECORDS_INFO                  8501
#define     FMSG_WINS_IPADDRESS_STRING              8502
#define     FMSG_WINS_OWNER_ADDRESS                 8603
#define     FMSG_WINS_RECORD_TABLE                  8604
#define     FMSG_WINS_IPADDRESS_LIST                8605
#define     FMSG_WINS_RECORD_IPADDRESS              8606
#define     FMSG_WINS_RECORD_ENTRY                  8607
#define     FMSG_WINS_RECORDS_TABLE                 8608
#define     FMSG_WINS_SOTABLE_HEADER                8609
#define     FMSG_WINS_MASTEROWNER_INDEX             8610
#define     FMSG_WINS_MASTEROWNER_INDEX1            8611
#define     FMSG_WINS_MAP_SOURCE                    8612
#define     FMSG_WINS_INDEXTOIP_TABLE               8613
#define     FMSG_WINS_INDEXTOIP_ENTRY               8614


#define     DMP_SRVR_SET_BACKUPPATH                 9101
#define     DMP_SRVR_SET_NAMERECORD                 9102
#define     DMP_SRVR_SET_PERIODICDBCHECKING         9103
#define     DMP_SRVR_SET_REPLICATEFLAG              9104
#define     DMP_SRVR_SET_MIGRATEFLAG                9105
#define     DMP_SRVR_SET_PULLPARAM                  9106
#define     DMP_SRVR_SET_PUSHPARAM                  9107
#define     DMP_SRVR_ADD_PARTNER                    9108
#define     DMP_SRVR_SET_PULLPERSISTENTCONNECTION   9109
#define     DMP_SRVR_SET_PUSHPERSISTENTCONNECTION   9110
#define     DMP_SRVR_SET_AUTOPARTNERCONFIG          9111
#define     DMP_SRVR_SET_PGMODE                     9112
#define     DMP_SRVR_ADD_PNGSERVER                  9113
#define     DMP_SRVR_ADD_PGSERVER                   9114
#define     DMP_SRVR_SET_BURSTPARAM                 9115
#define     DMP_SRVR_SET_BURSTPARAM_ALL             9116
#define     DMP_SRVR_SET_LOGPARAM                   9117
#define     DMP_SRVR_SET_STARTVERSION               9118
#define     DMP_SRVR_SET_BACKUPTERM                 9119


#define     WINS_TYPE_STATIC                        9500
#define     WINS_TYPE_DYNAMIC                       9501

#define     WINS_STATE_ACTIVE                       9505
#define     WINS_STATE_RELEASED                     9506
#define     WINS_STATE_TOMBSTONE                    9507

#define     WINS_GROUP_UNIQUE                       9510
#define     WINS_GROUP_GROUP                        9511
#define     WINS_GROUP_DOMAIN                       9512
#define     WINS_GROUP_INTERNET                     9513
#define     WINS_GROUP_MULTIHOMED                   9514


#define     WINS_GENERAL_UNKNOWN                    9520
#define     WINS_GENERAL_ENABLE                     9521
#define     WINS_GENERAL_DISABLE                    9522
#define     WINS_GENERAL_RANDOM                     9523
#define     WINS_GENERAL_OWNER                      9524
#define     WINS_GENERAL_INFINITE                   9525
#define     WINS_GENERAL_PUSH                       9526
#define     WINS_GENERAL_PULL                       9527
#define     WINS_GENERAL_PUSHPULL                   9528
#define     WINS_GENERAL_NORMAL                     9529
#define     WINS_GENERAL_HIGH                       9530
#define     WINS_GENERAL_DELETED                    9531
#define     WINS_GENERAL_OK                         9532
#define     WINS_GENERAL_FAILURE                    9533
#define     WINS_GENERAL_READ                       9535
#define     WINS_GENERAL_NAMENOTVERIFIED            9537                    



#endif //_STRDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\winshndl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\wins\winshndl.c

Abstract:

    WINS Server Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 12/14/98

--*/

#include "precomp.h"

extern ULONG g_ulNumTopCmds;
extern ULONG g_ulNumSubContext;

extern WINSMON_SUBCONTEXT_TABLE_ENTRY  g_WinsSubContextTable[];
extern CMD_ENTRY                        g_WinsCmds[];

DWORD
HandleWinsDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD Status = NO_ERROR;

    if( dwArgCount > dwCurrentIndex )
    {
        if( IsHelpToken(ppwcArguments[dwCurrentIndex]) is TRUE )
        {
            DisplayMessage(g_hModule,
                           HLP_WINS_DUMP_EX);
        }
    }
    
    Status = WinsDump(NULL, ppwcArguments, dwArgCount, pvData);

    if( Status is NO_ERROR )
        DisplayMessage(g_hModule,
                       EMSG_WINS_ERROR_SUCCESS);
    else if( Status is ERROR_FILE_NOT_FOUND )
        DisplayMessage(g_hModule,
                       EMSG_WINS_NOT_CONFIGURED);
    else
        DisplayErrorMessage(EMSG_WINS_DUMP,
                            Status);

    return Status;

        
}


DWORD
HandleWinsHelp(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulNumTopCmds -2; i++)
    {
        if ((g_WinsCmds[i].dwCmdHlpToken == WINS_MSG_NULL)
         || !g_WinsCmds[i].pwszCmdToken[0] )
        {
            continue;
        }

        DisplayMessage(g_hModule, 
                       g_WinsCmds[i].dwShortCmdHelpToken);
    }
    
    for(i=0; i < g_ulNumSubContext; i++)
    {
        DisplayMessage(g_hModule, g_WinsSubContextTable[i].dwShortCmdHlpToken);
        DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    }    
    
    DisplayMessage(g_hModule, WINS_FORMAT_LINE);

    return NO_ERROR;
}

DWORD
HandleWinsAddServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
	DWORD		dwError = NO_ERROR;
	DWORD		i, j, dwNumArg;
    PDWORD		pdwTagType = NULL;
	TAG_TYPE	pttTags[] = {{WINS_TOKEN_SERVER, TRUE, FALSE}};
	

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_WINS_ADD_SERVER_EX);
        return ERROR_INVALID_PARAMETER;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

	pdwTagType = WinsAllocateMemory(dwNumArg*sizeof(DWORD));

    if( pdwTagType is NULL )
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    //See if the first argument has tag. If so, then assume all arguments have tag.
    if( wcsstr(ppwcArguments[dwCurrentIndex], NETSH_ARG_DELIMITER) )
    {
        dwError = MatchTagsInCmdLine(g_hModule,
                            ppwcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            pttTags,
                            NUM_TAGS_IN_TABLE(pttTags),
                            pdwTagType);

        if (dwError isnot NO_ERROR)
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

    }
    else
    {
                //
        // No tags in arguments. So assume order of arguments
        // 

        for ( i = 0; i < dwNumArg; i++)
        {
            pdwTagType[i] = i;
        }
    }

CommonReturn:
    if( dwError is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    return dwError;
ErrorReturn:
    DisplayErrorMessage(EMSG_WINS_ADD_SERVER,
                        dwError);

    goto CommonReturn;
}


DWORD
HandleWinsDeleteServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
}


DWORD
HandleWinsShowServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\srvrmon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\wins\srvrmon.c

Abstract:

    WINS Server Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 12/14/98

--*/

#include "precomp.h"

LPWSTR                  g_ServerNameUnicode = NULL;
LPSTR                   g_ServerNameAnsi = NULL;
CHAR                    g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1] = {'\0'};
WCHAR                   g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1] = {L'\0'};
HKEY                    g_hServerRegKey = NULL;
WCHAR                   g_ServerNetBiosName[MAX_COMPUTER_NAME_LEN] = {L'\0'};


handle_t                g_hBind = NULL;
WINSINTF_BIND_DATA_T    g_BindData;

BOOL    g_fServer = FALSE;

CMD_ENTRY g_SrvrAddCmdTable[] =
{
    CREATE_CMD_ENTRY(SRVR_ADD_NAME, HandleSrvrAddName),
    CREATE_CMD_ENTRY(SRVR_ADD_PARTNER, HandleSrvrAddPartner),
    CREATE_CMD_ENTRY(SRVR_ADD_PNGSERVER, HandleSrvrAddPersona),
    CREATE_CMD_ENTRY(SRVR_ADD_PGSERVER, HandleSrvrAddPersona)
};

CMD_ENTRY g_SrvrCheckCmdTable[] =
{
    CREATE_CMD_ENTRY(SRVR_CHECK_DATABASE, HandleSrvrCheckDatabase),
    CREATE_CMD_ENTRY(SRVR_CHECK_NAME, HandleSrvrCheckName),
    CREATE_CMD_ENTRY(SRVR_CHECK_VERSION, HandleSrvrCheckVersion),
};

CMD_ENTRY g_SrvrDeleteCmdTable[] =
{
    CREATE_CMD_ENTRY(SRVR_DELETE_NAME, HandleSrvrDeleteName),
    CREATE_CMD_ENTRY(SRVR_DELETE_PARTNER, HandleSrvrDeletePartner),
    CREATE_CMD_ENTRY(SRVR_DELETE_RECORDS, HandleSrvrDeleteRecords),
    CREATE_CMD_ENTRY(SRVR_DELETE_WINS, HandleSrvrDeleteWins),
    CREATE_CMD_ENTRY(SRVR_DELETE_PNGSERVER, HandleSrvrDeletePersona),
    CREATE_CMD_ENTRY(SRVR_DELETE_PGSERVER, HandleSrvrDeletePersona)
};

CMD_ENTRY g_SrvrInitCmdTable[] =
{
    CREATE_CMD_ENTRY(SRVR_INIT_BACKUP, HandleSrvrInitBackup),
    CREATE_CMD_ENTRY(SRVR_INIT_IMPORT, HandleSrvrInitImport),
    CREATE_CMD_ENTRY(SRVR_INIT_PULL, HandleSrvrInitPull),
    CREATE_CMD_ENTRY(SRVR_INIT_PULLRANGE, HandleSrvrInitPullrange),
    CREATE_CMD_ENTRY(SRVR_INIT_PUSH, HandleSrvrInitPush),
    CREATE_CMD_ENTRY(SRVR_INIT_REPLICATE, HandleSrvrInitReplicate),
    CREATE_CMD_ENTRY(SRVR_INIT_RESTORE, HandleSrvrInitRestore),
    CREATE_CMD_ENTRY(SRVR_INIT_SCAVENGE, HandleSrvrInitScavenge),
    CREATE_CMD_ENTRY(SRVR_INIT_SEARCH, HandleSrvrInitSearch),
};

CMD_ENTRY g_SrvrResetCmdTable[] =
{
    CREATE_CMD_ENTRY(SRVR_RESET_COUNTER, HandleSrvrResetCounter),
};

CMD_ENTRY g_SrvrSetCmdTable[] =
{
    CREATE_CMD_ENTRY(SRVR_SET_AUTOPARTNERCONFIG, HandleSrvrSetAutopartnerconfig),
    CREATE_CMD_ENTRY(SRVR_SET_BACKUPPATH, HandleSrvrSetBackuppath),
    CREATE_CMD_ENTRY(SRVR_SET_BURSTPARAM, HandleSrvrSetBurstparam),
	CREATE_CMD_ENTRY(SRVR_SET_DEFAULTPARAM, HandleSrvrSetDefaultparam),
    CREATE_CMD_ENTRY(SRVR_SET_LOGPARAM, HandleSrvrSetLogparam),
    CREATE_CMD_ENTRY(SRVR_SET_MIGRATEFLAG, HandleSrvrSetMigrateflag),
    CREATE_CMD_ENTRY(SRVR_SET_NAMERECORD, HandleSrvrSetNamerecord),
    CREATE_CMD_ENTRY(SRVR_SET_PERIODICDBCHECKING, HandleSrvrSetPeriodicdbchecking),
    CREATE_CMD_ENTRY(SRVR_SET_PULLPERSISTENTCONNECTION, HandleSrvrSetPullpersistentconnection),
    CREATE_CMD_ENTRY(SRVR_SET_PUSHPERSISTENTCONNECTION, HandleSrvrSetPushpersistentconnection),
    CREATE_CMD_ENTRY(SRVR_SET_PULLPARAM, HandleSrvrSetPullparam),
    CREATE_CMD_ENTRY(SRVR_SET_PUSHPARAM, HandleSrvrSetPushparam),
    CREATE_CMD_ENTRY(SRVR_SET_REPLICATEFLAG, HandleSrvrSetReplicateflag),   
    CREATE_CMD_ENTRY(SRVR_SET_STARTVERSION, HandleSrvrSetStartversion),
    CREATE_CMD_ENTRY(SRVR_SET_PGMODE, HandleSrvrSetPersMode)
};

CMD_ENTRY g_SrvrShowCmdTable[] =
{
    CREATE_CMD_ENTRY(SRVR_SHOW_DOMAIN, HandleSrvrShowDomain),
    CREATE_CMD_ENTRY(SRVR_SHOW_DATABASE, HandleSrvrShowDatabase),
    CREATE_CMD_ENTRY(SRVR_SHOW_INFO, HandleSrvrShowInfo),
    CREATE_CMD_ENTRY(SRVR_SHOW_NAME, HandleSrvrShowName),
    CREATE_CMD_ENTRY(SRVR_SHOW_PARTNER, HandleSrvrShowPartner),
    CREATE_CMD_ENTRY(SRVR_SHOW_PARTNERPROPERTIES, HandleSrvrShowPartnerproperties),
    CREATE_CMD_ENTRY(SRVR_SHOW_PULLPARTNERPROPERTIES, HandleSrvrShowPullpartnerproperties),
    CREATE_CMD_ENTRY(SRVR_SHOW_PUSHPARTNERPROPERTIES, HandleSrvrShowPushpartnerproperties),
    CREATE_CMD_ENTRY(SRVR_SHOW_RECCOUNT, HandleSrvrShowReccount),
    CREATE_CMD_ENTRY(SRVR_SHOW_RECBYVERSION, HandleSrvrShowRecbyversion),
    CREATE_CMD_ENTRY(SRVR_SHOW_SERVER, HandleSrvrShowServer),
    CREATE_CMD_ENTRY(SRVR_SHOW_SERVERSTATISTICS, HandleSrvrShowStatistics),
    CREATE_CMD_ENTRY(SRVR_SHOW_VERSION, HandleSrvrShowVersion),
    CREATE_CMD_ENTRY(SRVR_SHOW_VERSIONMAP, HandleSrvrShowVersionmap),
};

CMD_GROUP_ENTRY g_SrvrCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_SrvrAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_CHECK, g_SrvrCheckCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_SrvrDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_INIT, g_SrvrInitCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_RESET, g_SrvrResetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_SrvrSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_SrvrShowCmdTable),
};


CMD_ENTRY g_SrvrCmds[] = 
{
    CREATE_CMD_ENTRY(WINS_DUMP, HandleSrvrDump),
    CREATE_CMD_ENTRY(WINS_HELP1, HandleSrvrHelp),
    CREATE_CMD_ENTRY(WINS_HELP2, HandleSrvrHelp),
    CREATE_CMD_ENTRY(WINS_HELP3, HandleSrvrHelp),
    CREATE_CMD_ENTRY(WINS_HELP4, HandleSrvrHelp),
};


ULONG g_ulSrvrNumTopCmds = sizeof(g_SrvrCmds)/sizeof(CMD_ENTRY);
ULONG g_ulSrvrNumGroups = sizeof(g_SrvrCmdGroups)/sizeof(CMD_GROUP_ENTRY);


DWORD
WINAPI
SrvrCommit(
    IN  DWORD   dwAction
)
{
   BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. Srvr current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}


DWORD
WINAPI
SrvrMonitor(
    IN      LPCWSTR     pwszMachine,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID     pvData,
    OUT     LPWSTR      pwcNewContext
    )
{
    DWORD                   dwError = NO_ERROR;
    DWORD                   dwIndex, i, j, k;
    BOOL                    bFound = FALSE;
    PFN_HANDLE_CMD          pfnHandler = NULL;
    PNS_CONTEXT_ENTRY_FN    pfnHelperEntryPt;
    PNS_CONTEXT_DUMP_FN     pfnHelperDumpPt;
    WCHAR                   wcSvrTemp[MAX_IP_STRING_LEN+1] = {L'\0'};
    BOOL                    fTemp = FALSE;
    DWORD                   dwNumMatched;
    DWORD                   dwCmdHelpToken = 0;

    if(dwArgCount is 1)
    {
        //Hmm! Hasn't passed any Server Info. Set the server to the value pwsRouter
        WCHAR ServerInfo[1000] = L"\\\\";

        if( pwszMachine and
            wcslen(pwszMachine) > 2 and
            wcsncmp(pwszMachine, L"\\\\", 2) and
            IsIpAddress(pwszMachine) is FALSE )
        {
            wcscpy(&ServerInfo[2], pwszMachine );
            pwszMachine = ServerInfo;

        }
        
        if( FALSE is SetServerInfo(pwszMachine) )
        {
            return GetLastError();
        }
        else
        {
            // wcscpy(pwcNewContext, L"wins server");
            g_fServer = TRUE;
            return ERROR_CONTEXT_SWITCH;
        }
    }

    dwIndex = 1;

    //If it is a help for server command
    if( IsHelpToken(ppwcArguments[dwIndex]) is TRUE and
        g_fServer is FALSE )
    {
        DisplayMessage(g_hModule, HLP_WINS_CONTEXT_SERVER_EX);
        dwError = NO_ERROR;
        goto CleanUp;
    }
    //Is it a servername or address?
    if( IsValidServer(ppwcArguments[dwIndex]) )
    {
        if( g_fServer is TRUE and
            dwArgCount > 2 )
        {
            wcscpy(wcSvrTemp, g_ServerIpAddressUnicodeString);
            fTemp = TRUE;
        }
        if( FALSE is SetServerInfo(ppwcArguments[dwIndex]) )
        {
            dwError = GetLastError();
            goto CleanUp;
        }

        pwcNewContext[wcslen(pwcNewContext)- wcslen(ppwcArguments[dwIndex]) -1 ] = L'\0';
   
        dwIndex++;
        g_fServer = TRUE;

    }
    else if( g_fServer is FALSE )
    {
        WCHAR ServerInfo[1000] = L"\\\\";

        if( pwszMachine and
            wcslen(pwszMachine) > 2 and
            wcsncmp(pwszMachine, L"\\\\", 2) and
            IsIpAddress(pwszMachine) is FALSE )
        {
            wcscpy(&ServerInfo[2], pwszMachine );
            pwszMachine = ServerInfo;
        }

        if( FALSE is SetServerInfo(pwszMachine) )
        {
            dwError = GetLastError();
            goto CleanUp;
        }
        g_fServer = TRUE;
    }

    
    if( dwIndex >= dwArgCount )
    {            
        dwError = ERROR_CONTEXT_SWITCH;
        //wcscpy(pwcNewContext, L"wins server");
        goto CleanUp;
    }

    //Is it a top level(non Group command)?
    for(i=0; i<g_ulSrvrNumTopCmds; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_SrvrCmds[i].pwszCmdToken))
        {
            bFound = TRUE;

            pfnHandler = g_SrvrCmds[i].pfnCmdHandler;

            dwCmdHelpToken = g_SrvrCmds[i].dwCmdHlpToken;
            
            dwIndex++;

            break;
        }
    }


    if(bFound)
    {
        if(dwArgCount > 3 && IsHelpToken(ppwcArguments[dwIndex]))
        {
            DisplayMessage(g_hModule, dwCmdHelpToken);

            dwError = NO_ERROR;
            goto CleanUp;
        }
        
        dwIndex++;

        dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwIndex, dwArgCount,
                                dwFlags, pvData, &bFound);

        goto CleanUp;
    }
 
    bFound = FALSE;

    //It is not a non Group Command. Then is it a config command for the manager?
    for(i = 0; (i < g_ulSrvrNumGroups) and !bFound; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_SrvrCmdGroups[i].pwszCmdGroupToken))
        {
            //
            // Command matched entry i, so look at the table of sub commands 
            // for this command
            //
            if( dwArgCount > dwIndex+1 )
            {
                for (j = 0; j < g_SrvrCmdGroups[i].ulCmdGroupSize; j++)
                {
                    if (MatchCmdLine(ppwcArguments+dwIndex,
                                      dwArgCount - 1,
                                      g_SrvrCmdGroups[i].pCmdGroup[j].pwszCmdToken,
                                      &dwNumMatched))
                    {
                        bFound = TRUE;
                
                        pfnHandler = g_SrvrCmdGroups[i].pCmdGroup[j].pfnCmdHandler;
                
                        dwCmdHelpToken = g_SrvrCmdGroups[i].pCmdGroup[j].dwCmdHlpToken;

                        //
                        // break out of the for(j) loop
                        //
                        dwIndex+=dwNumMatched;
                        break;
                    }
                }
            }

            if(!bFound)
            {
                //
                // We matched the command group token but none of the
                // sub commands
                //

                DisplayMessage(g_hModule, 
                               EMSG_WINS_INCOMPLETE_COMMAND);

                for (j = 0; j < g_SrvrCmdGroups[i].ulCmdGroupSize; j++)
                {
                    DisplayMessage(g_hModule, 
                             g_SrvrCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);
                    
					DisplayMessage(g_hModule, WINS_FORMAT_LINE);
                }

                dwError = ERROR_INVALID_PARAMETER;
                goto CleanUp;
            }
            else
            {
                //
                // quit the for(i)
                //

                break;
            }
        }
    }




    if (!bFound)
    {
        //
        // Command not found. 
        //
        if( _wcsicmp(ppwcArguments[dwIndex], L"..") is 0 )
        {
            if(g_ServerNameUnicode)
            {
                WinsFreeMemory(g_ServerNameUnicode);
                g_ServerNameUnicode = NULL;
            }
            memset(g_ServerIpAddressUnicodeString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));
            memset(g_ServerIpAddressAnsiString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(CHAR));
            g_fServer = FALSE;
        }

        dwError = ERROR_CMD_NOT_FOUND;
        goto CleanUp;
    }

    //
    // See if it is a request for help.
    //

    if (dwNumMatched < (dwArgCount - 1) and
        wcslen(ppwcArguments[dwNumMatched+1]) > 0 and
        IsHelpToken(ppwcArguments[dwNumMatched + 1]))
    {
        DisplayMessage(g_hModule, dwCmdHelpToken);

        dwError = NO_ERROR;
        goto CleanUp;
    }
    
    //
    // Call the parsing routine for the command
    //

    dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwIndex, 
                            dwArgCount, dwFlags, pvData, &bFound);

    if( dwError is ERROR_CONTEXT_SWITCH )
    {
        goto CleanUp;
    }
CleanUp:
    if( fTemp )
    {
        fTemp = SetServerInfo(wcSvrTemp);
    }

    return dwError;
}


DWORD
WINAPI
SrvrUnInit(
    IN  DWORD   dwReserved
)
{
    return NO_ERROR;
}

BOOL
SetServerInfo(
    IN  LPCWSTR  pwszServerInfo
)
{
    BOOL    fReturn = TRUE;
    DWORD   dwComputerNameLen = 0;
    LPSTR   pszComputerName = NULL;
    LPWSTR  pwszComputerName = NULL;
    struct  hostent * lpHostEnt = NULL;
    BYTE    pbAdd[4];
    char    szAdd[4];
    DWORD   dwHostName = 0;
    DWORD   dwIpAddress = 0;
    DWORD   i = 0, nLen = 0;
    DWORD   Status = 0;
    DWORD   Access = 0;
    CHAR    *pTemp = NULL,
            *pTemp1 = NULL;
    DWORD   dwTempLen = 0;
    CHAR    cTempIp[MAX_IP_STRING_LEN+1] = {L'\0'};
    WCHAR   wTempIp[MAX_IP_STRING_LEN+1] = {'\0'};
    LPWSTR  pwszTempServer = NULL;
    LPSTR   pszTempServer = NULL;
    WCHAR   wTempNetBios[MAX_COMPUTER_NAME_LEN] = {L'\0'};

    handle_t                hTempBind = NULL;
    WINSINTF_BIND_DATA_T    TempBindData;

    LPWSTR  pwsz = NULL;
    LPSTR   psz = NULL;
    
    
    if( g_ServerNameUnicode isnot NULL and
        IsIpAddress(g_ServerIpAddressUnicodeString) is TRUE )
    {
        strcpy(cTempIp, g_ServerIpAddressAnsiString);
        wcscpy(wTempIp, g_ServerIpAddressUnicodeString);
        pwszTempServer = g_ServerNameUnicode;
        pszTempServer = g_ServerNameAnsi;
        wcscpy(wTempNetBios, g_ServerNetBiosName);
    }

    memset(g_ServerNetBiosName, 0x00, MAX_COMPUTER_NAME_LEN*sizeof(WCHAR));

    g_ServerNetBiosName[0] = L'\\';
    g_ServerNetBiosName[1] = L'\\';

    
    if( pwszServerInfo is NULL )
    {
        if( !GetComputerNameEx(ComputerNameDnsFullyQualified,
                              NULL,
                              &dwComputerNameLen) )
        {
            
            pwszComputerName = WinsAllocateMemory((dwComputerNameLen+1)*sizeof(WCHAR));

            if(pwszComputerName is NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                fReturn = FALSE;
                goto RETURN;
            }
            
            dwComputerNameLen++;
            if( !GetComputerNameEx(ComputerNameDnsFullyQualified,
                                   pwszComputerName,
                                   &dwComputerNameLen) )
            {
                fReturn = FALSE;
                goto RETURN;
            }

        }
        else
        {
            fReturn = FALSE;
            goto RETURN;
        }
    }

    else    //might be a computer name or IP address. Determine what.
    {
        if( wcslen(pwszServerInfo) > 2 and
            _wcsnicmp(pwszServerInfo, L"\\\\", 2) is 0 )
        {

            pwszComputerName = WinsAllocateMemory((wcslen(pwszServerInfo) - 1)*sizeof(WCHAR));
            if( pwszComputerName is NULL )
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                fReturn = FALSE;
                goto RETURN;
            }
            
            memcpy(pwszComputerName, 
                   (pwszServerInfo+2), 
                   (wcslen(pwszServerInfo) - 1)*sizeof(WCHAR));
        }
        else if( IsIpAddress(pwszServerInfo) is TRUE )    //it is an IP Address
        {

            memset(g_ServerIpAddressUnicodeString, 0x00, 
                   (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));
            

            wcscpy(g_ServerIpAddressUnicodeString, 
                    pwszServerInfo);


            memset(g_ServerIpAddressAnsiString, 0x00, 
                   (MAX_IP_STRING_LEN+1)*sizeof(CHAR));

            psz = WinsUnicodeToAnsi(g_ServerIpAddressUnicodeString, NULL);

            if( psz )
            {
                strcpy(g_ServerIpAddressAnsiString, psz);
                WinsFreeMemory(psz);
                psz = NULL;
            }
           
            dwIpAddress = inet_addr(g_ServerIpAddressAnsiString);


            lpHostEnt = gethostbyaddr((char *)&dwIpAddress, 4, AF_INET);
            
            if( lpHostEnt is NULL )
            {
                DisplayMessage(g_hModule, EMSG_WINS_UNKNOWN_SERVER);
                fReturn = FALSE;
                goto RETURN;
            }

            dwHostName = strlen(lpHostEnt->h_name);

            g_ServerNameAnsi = WinsAllocateMemory(dwHostName+1);

            if (g_ServerNameAnsi == NULL)
                goto RETURN;

            strcpy(g_ServerNameAnsi, lpHostEnt->h_name);
            
            g_ServerNameUnicode = WinsAllocateMemory((dwHostName+1)*sizeof(WCHAR));
         
            wcscpy(g_ServerNameUnicode, WinsAnsiToUnicode(lpHostEnt->h_name, NULL));
            //Bind the server
            
            if( hTempBind )
            {
                //Unbind any previous server
                WinsUnbind(&TempBindData, hTempBind);
                hTempBind = NULL;
            }

            TempBindData.fTcpIp = TRUE;
            TempBindData.pServerAdd = (LPBYTE)g_ServerIpAddressUnicodeString;
            TempBindData.pPipeName = (LPBYTE)g_ServerNameUnicode;
            hTempBind = WinsBind(&TempBindData);

            if (hTempBind == NULL)
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_BIND_FAILED,
                               g_ServerNameUnicode);
                fReturn = FALSE;
                goto RETURN;
            }


            //Make sure this is the correct address for the WINS
            {
                WINSINTF_ADD_T  WinsAdd = {0};
                UCHAR           pName[256] = {'\0'};

                Status = WinsGetNameAndAdd(hTempBind,
                                           &WinsAdd,
                                           pName);

                if( Status is NO_ERROR )
                {
                    LPWSTR  pAdd = IpAddressToString(WinsAdd.IPAdd);

                    if( pAdd is NULL )
                    {
                        fReturn = FALSE;
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        goto RETURN;

                    }
                    wcscpy(g_ServerIpAddressUnicodeString,
                           pAdd);
                    
                    psz = WinsUnicodeToAnsi(g_ServerIpAddressUnicodeString, NULL);

                    if( psz )
                    {
                        strcpy(g_ServerIpAddressAnsiString, psz );
                        WinsFreeMemory(psz);
                        psz = NULL;
                    }
                    
                    pwsz = WinsAnsiToUnicode(pName, NULL);
                    if( pwsz )
                    {
                        wcscpy( g_ServerNetBiosName+2, g_ServerIpAddressUnicodeString);
                        WinsFreeMemory(pwsz);
                        pwsz = NULL;
                    }
                    else
                    {
                        DisplayMessage(g_hModule,
                                       EMSG_WINS_OUT_OF_MEMORY);
                        fReturn = FALSE;
                        WinsFreeMemory(pAdd);
                        pAdd = NULL;
                        goto RETURN;
                    }
                    WinsFreeMemory(pAdd);
                    pAdd = NULL;
                }
                else
                {
                    DisplayErrorMessage(EMSG_WINS_VERIFY_ADDRESS,
                                        Status);
                }


            }

            //find out what type of access do we have
            Access = WINS_NO_ACCESS;
            Status = WinsCheckAccess(hTempBind, &Access);

            if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
            {
                DisplayMessage(g_hModule,
                               EMSG_ACCESS_NOT_DETERMINED,
                               g_ServerNameUnicode);
 
                if( g_hBind )
                {
                    WinsUnbind(&g_BindData, g_hBind);
                }
        
                g_hBind = hTempBind;
                g_BindData = TempBindData;
                fReturn = TRUE;
                goto RETURN;
            }
            else if (WINSINTF_SUCCESS == Status) 
            {
                  if (Access != WINS_NO_ACCESS)
                  {
                      DisplayMessage(g_hModule, 
                                     Access == WINS_CONTROL_ACCESS ? MSG_WINS_RWACCESS : MSG_WINS_ROACCESS,
                                     g_ServerNameUnicode);
                  }
                  
                  if( Access is WINS_NO_ACCESS )                  
                  {
                      DisplayMessage(g_hModule,
                                     MSG_WINS_NOACCESS,
                                     g_ServerNameUnicode);

                      fReturn = FALSE;
                      goto RETURN;
                  }

                  if( g_hBind )
                  {
                      WinsUnbind(&g_BindData, g_hBind);
                  }
                  g_hBind = hTempBind;
                  g_BindData = TempBindData;

                  fReturn = TRUE;
                  goto RETURN;
            }
            else
            {
                DisplayErrorMessage(EMSG_WINS_GETSTATUS_FAILED,
                                    Status);
                {
                    fReturn = FALSE;
                    goto RETURN;
                }
            }
            
            fReturn = TRUE;
            goto RETURN;
        }

    }
    
    //Now process the Computer name and convert it to ANSI because
    //gethostbyname requires ANSI character string.

    {
        int dw = 0;
        
        dw = WideCharToMultiByte(CP_ACP,
                                 0,
                                 pwszComputerName,
                                 wcslen(pwszComputerName),
                                 pszComputerName,
                                 0,
                                 NULL,
                                 NULL);

        if( dw is 0 )
        {
            fReturn = FALSE;
            return FALSE;
        }

        pszComputerName = WinsAllocateMemory((dw+1)*sizeof(CHAR));

        if( pszComputerName is NULL )
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            fReturn = FALSE;
            goto RETURN;
        }

        dw = WideCharToMultiByte(CP_ACP,
                                 0,
                                 pwszComputerName,
                                 wcslen(pwszComputerName),
                                 pszComputerName,
                                 dw+1,
                                 NULL,
                                 NULL);

        if( dw is 0 )
        {
            fReturn = FALSE;
            goto RETURN;
        }

    }

    //Now get the server IP Address
    lpHostEnt = gethostbyname(pszComputerName);

    //Not a valid server name
    if( lpHostEnt is NULL )
    {
        DisplayMessage(g_hModule, EMSG_WINS_INVALID_COMPUTERNAME);
        if( pszComputerName )
        {
            WinsFreeMemory(pszComputerName);
            pszComputerName = NULL;
        }
        fReturn = FALSE;        
        goto RETURN;
    }

    //Get the IP Address from the returned struct...
    memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
    nLen = 0;
    for( i=0; i<4; i++)
    {

        _itoa((int)pbAdd[i], szAdd, 10);
        memcpy(g_ServerIpAddressAnsiString+nLen, szAdd, strlen(szAdd));
        nLen += strlen(szAdd);
        *(g_ServerIpAddressAnsiString+nLen) = '.';
        nLen++;
    
    }
    *(g_ServerIpAddressAnsiString+nLen-1) = '\0';

    dwIpAddress = WinsDottedStringToIpAddress(g_ServerIpAddressAnsiString);
    dwHostName = strlen(g_ServerIpAddressAnsiString);

    //Convert IP Address to a Unicode string and store it to the global variable.


    memset(g_ServerIpAddressUnicodeString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));

    pwsz = WinsAnsiToUnicode(g_ServerIpAddressAnsiString, NULL);

    if( pwsz )
    {
        wcscpy(g_ServerIpAddressUnicodeString, pwsz);
        WinsFreeMemory(pwsz);
        pwsz = NULL;
    }
    else
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_OUT_OF_MEMORY);
        fReturn = FALSE;
        goto RETURN;
    }

    g_ServerNameAnsi = WinsAllocateMemory(strlen(lpHostEnt->h_name)+1);

    g_ServerNameUnicode = WinsAllocateMemory((strlen(lpHostEnt->h_name) + 1)*sizeof(WCHAR));

    if( ( g_ServerNameUnicode is NULL ) or
        ( g_ServerNameAnsi is NULL ) )
    {
        DisplayMessage(g_hModule, EMSG_WINS_NOT_ENOUGH_MEMORY);
        if( pszComputerName )
        {
            WinsFreeMemory(pszComputerName);
            pszComputerName = NULL;
        }
        if( pwszComputerName )
        {
            WinsFreeMemory(pwszComputerName);
            pwszComputerName = NULL;
        }

        fReturn = FALSE;
        goto RETURN;
    }
    
    strcpy(g_ServerNameAnsi, lpHostEnt->h_name);

    {
        int dw = 0;
        dw = MultiByteToWideChar(CP_ACP, 
                                 0, 
                                 lpHostEnt->h_name, 
                                 strlen(lpHostEnt->h_name),
                                 g_ServerNameUnicode,
                                 strlen(lpHostEnt->h_name)+1);

        if ( dw == 0 )
        {
            fReturn = FALSE;
            goto RETURN;
        }
    }
    //Bind the server
    TempBindData.fTcpIp = TRUE;
    TempBindData.pServerAdd = (LPBYTE)g_ServerIpAddressUnicodeString;
    TempBindData.pPipeName = (LPBYTE)g_ServerNameUnicode;
    hTempBind = WinsBind(&TempBindData);

    if (hTempBind == NULL)
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_BIND_FAILED,
                       g_ServerIpAddressUnicodeString);

        SetLastError(ERROR_INVALID_PARAMETER);
        fReturn = FALSE;
        goto RETURN;
    }

    //Make sure this is the correct address for the WINS
    {
        WINSINTF_ADD_T  WinsAdd = {0};
        UCHAR           pName[256] = {'\0'};

        Status = WinsGetNameAndAdd(hTempBind,
                                   &WinsAdd,
                                   pName);

        if( Status is NO_ERROR )
        {
            LPWSTR  pAdd = IpAddressToString(WinsAdd.IPAdd);

            if( pAdd is NULL )
            {
                fReturn = FALSE;
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto RETURN;

            }
            wcscpy(g_ServerIpAddressUnicodeString,
                   pAdd);
            
            psz = WinsUnicodeToOem(pAdd, NULL);
            if( psz )
            {
                strcpy(g_ServerIpAddressAnsiString, psz);
                WinsFreeMemory(psz);
                psz = NULL;
            }
            
            pwsz = WinsOemToUnicode(pName, NULL);
            if( pwsz )
            {
                wcscpy( g_ServerNetBiosName+2, g_ServerIpAddressUnicodeString);
                WinsFreeMemory(pwsz);
                pwsz = NULL;
            }
            else
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_OUT_OF_MEMORY);
                fReturn = FALSE;
                goto RETURN;
            }
           
            WinsFreeMemory(pAdd);
            pAdd = NULL;
        }
        else
        {
            DisplayErrorMessage(EMSG_WINS_VERIFY_ADDRESS,
                                Status);
        }


    }

    //find out what type of access do we have
    Access = WINS_NO_ACCESS;
    Status = WinsCheckAccess(hTempBind, &Access);

    if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
    {
        DisplayMessage(g_hModule,
                       EMSG_ACCESS_NOT_DETERMINED,
                       g_ServerNameUnicode);
 
        if( g_hBind )
        {
            WinsUnbind(&g_BindData, g_hBind);
        }
        
        g_hBind = hTempBind;
        g_BindData = TempBindData;
        fReturn = TRUE;
        goto RETURN;
    }
    else if (WINSINTF_SUCCESS == Status) 
    {
        if (Access != WINS_NO_ACCESS)
        {
            DisplayMessage(g_hModule, 
                           Access == WINS_CONTROL_ACCESS ? MSG_WINS_RWACCESS : MSG_WINS_ROACCESS,
                           g_ServerNameUnicode);
        }
        
        if( Access is WINS_NO_ACCESS )
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_NOACCESS,
                           g_ServerNameUnicode);

            fReturn = FALSE;
            goto RETURN;
        }

        if( g_hBind )
        {
            WinsUnbind(&g_BindData, g_hBind);
        }
        g_hBind = hTempBind;
        g_BindData = TempBindData;
        fReturn = TRUE;
        goto RETURN;

    }
    else
    {
        DisplayErrorMessage(EMSG_WINS_GETSTATUS_FAILED,
                            Status);
        fReturn = FALSE;
        goto RETURN;
    }

RETURN:
    if( pszComputerName)
    {
        WinsFreeMemory(pszComputerName);
        pszComputerName = NULL;
    }

    if( pwszComputerName )
    {
        WinsFreeMemory(pwszComputerName);
        pwszComputerName = NULL;
    }

    if( pTemp1 )
    {
        WinsFreeMemory(pTemp1);
        pTemp1 = NULL;
    }

    if( fReturn is FALSE )
    {
        wcscpy(g_ServerIpAddressUnicodeString, wTempIp);
        strcpy(g_ServerIpAddressAnsiString, cTempIp);
        g_ServerNameUnicode = pwszTempServer;
        g_ServerNameAnsi = pszTempServer;
        wcscpy(g_ServerNetBiosName, wTempNetBios);
    }
    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\verify.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/

#include "precomp.h"


NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    );

void DisplayInfo(int uNames, u_long ulValidAddr);

LPWSTR ToWCS(LPCSTR szMBCSString)
{
	int     nResult = 0;
    LPWSTR  lpWideString = NULL;
	// determone the size first
	nResult = MultiByteToWideChar(
						CP_ACP,
						0,
						szMBCSString,
						-1,
						lpWideString,
						0);

    lpWideString = WinsAllocateMemory((nResult+1)*sizeof(WCHAR));

    if( lpWideString is NULL )
        return NULL;

	nResult = MultiByteToWideChar(
						CP_ACP,
						MB_COMPOSITE,
						szMBCSString,
						-1,
						lpWideString,
						nResult+1);
    
    if( nResult is 0 )
    {
        WinsFreeMemory(lpWideString);
        lpWideString = NULL;
    }
    else
    {
        lpWideString[nResult + 1] = '\0';
    }
    return lpWideString;
}

//------------------------------------------------------------------------
NTSTATUS
GetIpAddress(
    IN HANDLE           fd,
    OUT PULONG          pIpAddress
    )

/*++

Routine Description:

    This function calls into netbt to get the ip address.

Arguments:

   fd - file handle to netbt
   pIpAddress - the ip address returned

Return Value:

   ntstatus

History:
    27-Dec-1995 CDermody    copied from nbtstat.c

--*/

{
    NTSTATUS    status;
    ULONG       BufferSize=100;
    PVOID       pBuffer;

    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = DeviceIoCtrl(fd,
                         pBuffer,
                         BufferSize,
                         IOCTL_NETBT_GET_IP_ADDRS,
                         NULL,
                         0);

    if (NT_SUCCESS(status))
    {
        *pIpAddress = *(ULONG *)pBuffer;
    }
    else
    {
        *pIpAddress = 0;
    }

    LocalFree(pBuffer);

    return(status);
}

//------------------------------------------------------------------------
NTSTATUS
GetInterfaceList
(
    char pDeviceName[][MAX_NAME+1]
)
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string, AnsiString;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    char                pNbtWinsDeviceName[MAX_NAME] = "\\Device\\NetBt_Wins_Export";

    PUCHAR  SubKeyParms = "system\\currentcontrolset\\services\\netbt\\parameters";
    PUCHAR  Scope = "ScopeId";
    CHAR    pScopeBuffer[BUFF_SIZE];
    HKEY    Key;
    LONG    Type;
    ULONG   size;

    NETBT_INTERFACE_INFO    *pInterfaceInfo;
    ULONG                   InterfaceInfoSize = 10 * sizeof(NETBT_ADAPTER_INDEX_MAP) + sizeof(ULONG);
    PVOID                   pInput = NULL;
    ULONG                   SizeInput = 0;

    LONG    i, index = 0;

    pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize);
    if (!pInterfaceInfo)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlInitString(&name_string, pNbtWinsDeviceName);
    RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uc_name_string,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile (&StreamHandle,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0);

    RtlFreeUnicodeString(&uc_name_string);

    if (NT_SUCCESS (status))
    {
        do
        {
            status = DeviceIoCtrl(StreamHandle,
                                 pInterfaceInfo,
                                 InterfaceInfoSize,
                                 IOCTL_NETBT_GET_INTERFACE_INFO,
                                 pInput,
                                 SizeInput);

            if (status == STATUS_BUFFER_OVERFLOW)
            {
                LocalFree(pInterfaceInfo);

                InterfaceInfoSize *= 2;
                pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize);
                if (!pInterfaceInfo || (InterfaceInfoSize == 0xFFFF))
                {
                    NtClose(StreamHandle);
                    //NlsPerror(COMMON_UNABLE_TO_ALLOCATE_PACKET,0);
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
            }
            else if (!NT_SUCCESS (status))
            {
                NtClose(StreamHandle);
                return(status);
            }

        } while (status == STATUS_BUFFER_OVERFLOW);
        NtClose (StreamHandle);

        for (i = 0; i<pInterfaceInfo->NumAdapters; i++)
        {
            RtlInitString(&name_string, NULL);
            RtlInitUnicodeString(&uc_name_string, pInterfaceInfo->Adapter[i].Name);
            if (NT_SUCCESS(RtlUnicodeStringToAnsiString(&name_string, &uc_name_string, TRUE)))
            {
                size = (name_string.Length > MAX_NAME) ? MAX_NAME : name_string.Length;

                strncpy(pDeviceName[index], name_string.Buffer, size);
                pDeviceName[index][size] = '\0';
                RtlFreeAnsiString (&name_string);

                index++;
            }
        }

        //
        // NULL out the next device string ptr
        //
        if (index < NBT_MAXIMUM_BINDINGS)
        {
            pDeviceName[index][0] = '\0';
        }

        //
        // Read the ScopeId key!
        //
        size = BUFF_SIZE;
        *pScope = '\0';     // By default
        status = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                     SubKeyParms,
                     0,
                     KEY_READ,
                     &Key);

        if (status == ERROR_SUCCESS)
        {
            // now read the Scope key
            status = RegQueryValueExA(Key, Scope, NULL, &Type, pScopeBuffer, &size);
            if (status == ERROR_SUCCESS)
            {
                strncpy(pScope,pScopeBuffer,sizeof(pScope));
                pScope[sizeof(pScope) - 1] = '\0';
            }
            status = RegCloseKey(Key);
        }

        status = STATUS_SUCCESS;
    }

    return status;
}

//------------------------------------------------------------------------
NTSTATUS
OpenNbt(
    IN char path[][MAX_NAME+1],
    OUT PHANDLE pHandle,
    int max_paths
    )
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    LONG                index=0;

    ASSERT ( max_paths <= NBT_MAXIMUM_BINDINGS );

    while ((path[index][0] != '\0') && (index < max_paths))
    {
        RtlInitString(&name_string, path[index]);
        RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &uc_name_string,
            OBJ_CASE_INSENSITIVE,
            (HANDLE) NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );

        status =
        NtCreateFile(
            &StreamHandle,
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN_IF,
            0,
            NULL,
            0);

        RtlFreeUnicodeString(&uc_name_string);

        if (NT_SUCCESS(status))
        {
            *pHandle = StreamHandle;
            return(status);
        }

        ++index;
    }

    return (status);
} // s_open

//------------------------------------------------------------------------
NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    )

/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, non-zero otherwise.

History:
    27-Dec-1995 CDermody    copied from nbtstat.c
--*/

{
    NTSTATUS                        status;
    int                             retval;
    ULONG                           QueryType;
    IO_STATUS_BLOCK                 iosb;


    status = NtDeviceIoControlFile(
                      fd,                      // Handle
                      NULL,                    // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &iosb,                   // IoStatusBlock
                      Ioctl,                   // IoControlCode
                      pInput,                  // InputBuffer
                      SizeInput,               // InputBufferSize
                      (PVOID) ReturnBuffer,    // OutputBuffer
                      BufferSize);             // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
        if (NT_SUCCESS(status))
        {
            status = iosb.Status;
        }
    }

    return(status);
}

/****************************************************************************/
/*      CheckRemoteTable                                                    */
/*                                                                          */
/*  This routine does an adapter status query to get the remote name table  */
/*  then checks to see if a netbios name is contained in it.                */
/*                                                                          */
/*  Parameters:                                                             */
/*      RemoteName, the IP address (asci nn.nn.nn.nn format) of a server to */
/*                  query.                                                  */
/*      SearchName, a net bios name.                                        */
/*                                                                          */
/*  Return:                                                                 */
/*      WINSTEST_VERIFIED       The name exists in the remote name table    */
/*      WINSTEST_NOT_VERIFIED   The name does not exist in the remote table */
/*      WINSTEST_BAD_IP_ADDRESS inet_addr could not convert the ip address  */
/*                              character string.                           */
/*      WINSTEST_HOST_NOT_FOUND Could not reach ip address                  */
/*      WINSTEST_OUT_OF_MEMORY  Out of memory                               */
/*  History:                                                                */
/*      27-Dec-1995     CDermody    created following example of nbtstat.c  */
/****************************************************************************/

int
CheckRemoteTable(
    IN HANDLE   fd,
    IN PCHAR    RemoteName,
    IN PCHAR    SearchName
    )

{
    LONG                        Count;
    LONG                        i;
    PVOID                       pBuffer;
    ULONG                       BufferSize=600;
    NTSTATUS                    status;
    tADAPTERSTATUS              *pAdapterStatus;
    NAME_BUFFER                 *pNames;
    CHAR                        MacAddress[20];
    tIPANDNAMEINFO              *pIpAndNameInfo;
    ULONG                       SizeInput;
    ULONG                       IpAddress;
    USHORT                      BytesToCopy;


    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(WINSTEST_OUT_OF_MEMORY);
    }

    status = STATUS_BUFFER_OVERFLOW;
    pIpAndNameInfo = LocalAlloc(LMEM_FIXED,sizeof(tIPANDNAMEINFO));
    if (!pIpAndNameInfo)
    {
        LocalFree(pBuffer);
        return(WINSTEST_OUT_OF_MEMORY);
    }

    RtlZeroMemory((PVOID)pIpAndNameInfo,sizeof(tIPANDNAMEINFO));
    
    //
    // Convert the remote name which is really a dotted decimal ip address
    // into a ulong
    //
    IpAddress = inet_addr(RemoteName);
    
    //
    // Don't allow zero for the address since it sends a broadcast and
    // every one responds
    //
    if ((IpAddress == INADDR_NONE) || (IpAddress == 0))
    {
        LocalFree(pBuffer);
        LocalFree(pIpAndNameInfo);
    
        return(WINSTEST_BAD_IP_ADDRESS);
    }

    pIpAndNameInfo->IpAddress = ntohl(IpAddress);

    pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosName[0] = '*';


    pIpAndNameInfo->NetbiosAddress.TAAddressCount = 1;
    pIpAndNameInfo->NetbiosAddress.Address[0].AddressLength
        = sizeof(TDI_ADDRESS_NETBIOS);
    pIpAndNameInfo->NetbiosAddress.Address[0].AddressType
        = TDI_ADDRESS_TYPE_NETBIOS;
    pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosNameType
        = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    SizeInput = sizeof(tIPANDNAMEINFO);

    while (status == STATUS_BUFFER_OVERFLOW)
    {
        status = DeviceIoCtrl(fd,
                             pBuffer,
                             BufferSize,
                             IOCTL_NETBT_ADAPTER_STATUS,
                             pIpAndNameInfo,
                             SizeInput);

        if (status == STATUS_BUFFER_OVERFLOW)
        {
            LocalFree(pBuffer);

            BufferSize *=2;
            pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
            if (!pBuffer || (BufferSize == 0xFFFF))
            {
                LocalFree(pIpAndNameInfo);

                return(WINSTEST_OUT_OF_MEMORY);
            }
        }
    }

    pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
    if ((pAdapterStatus->AdapterInfo.name_count == 0) ||
        (status != STATUS_SUCCESS))
    {
        LocalFree(pIpAndNameInfo);
        LocalFree(pBuffer);
        
        return(WINSTEST_HOST_NOT_FOUND);
    }

    pNames = pAdapterStatus->Names;
    Count = pAdapterStatus->AdapterInfo.name_count;

    status = 1;

    while (Count--)
    {
        if (0 == _strnicmp(SearchName, pNames->name, strlen(SearchName)))
        {
            LocalFree(pIpAndNameInfo);
            LocalFree(pBuffer);
            
            return WINSTEST_VERIFIED; // found
        }
        
        pNames++;
    }

    LocalFree(pIpAndNameInfo);
    LocalFree(pBuffer);

    return WINSTEST_NOT_VERIFIED;
}


/****************************************************************************/
/*      VerifyRemote                                                        */
/*                                                                          */
/*  This routine checks to see if a netbios name is contained in the remote */
/*  name table at a given IP address.                                       */
/*                                                                          */
/*  Parameters:                                                             */
/*      RemoteName, the IP address (asci nn.nn.nn.nn format) of a server to */
/*                  query.                                                  */
/*      NBName,     a net bios name.                                        */
/*                                                                          */
/*  Return:                                                                 */
/*      WINSTEST_VERIFIED       The name exists in the remote name table    */
/*      WINSTEST_NOT_VERIFIED   The name does not exist in the remote table */
/*      WINSTEST_BAD_IP_ADDRESS inet_addr could not convert the ip address  */
/*                              character string.                           */
/*      WINSTEST_OPEN_FAILED    Could not open NBT driver or could not read */
/*                              the NBT driver info from the registry.      */
/*      WINSTEST_HOST_NOT_FOUND Could not reach ip address                  */
/*      WINSTEST_OUT_OF_MEMORY  Out of memory                               */
/*  History:                                                                */
/*      27-Dec-1995     CDermody    created following example of nbtstat.c  */
/****************************************************************************/

int VerifyRemote(IN PCHAR RemoteName, IN PCHAR NBName)
{
    NTSTATUS    status;
    LONG        interval=-1;
    HANDLE      nbt = 0;
    int         nStatus;
    int         index;
    CHAR        pDeviceName[NBT_MAXIMUM_BINDINGS+1][MAX_NAME+1];
    
    status = GetInterfaceList(pDeviceName);
    if (!NT_SUCCESS(status))
    {
        return WINSTEST_OPEN_FAILED;
    }

    for (index = 0; index < NBT_MAXIMUM_BINDINGS && pDeviceName[index][0]; index++)
    {
        //
        //  Open the device of the appropriate streams module to start with.
        //
        status = OpenNbt(&pDeviceName[index], &nbt, NBT_MAXIMUM_BINDINGS-index);
        if (!NT_SUCCESS(status))
        {
            //
            // Try the next binding!
            //
            continue;
        }

        GetIpAddress(nbt, &NetbtIpAddress);

        if (RemoteName[0] == '\0')
            return WINSTEST_INVALID_ARG;
    
        status = (NTSTATUS)CheckRemoteTable(nbt,RemoteName,NBName);
        if (status == WINSTEST_VERIFIED)
            break;
    }

    return status;
}

/*************************************************************/
/*        NBEncode(name2,name)                               */
/*                                                           */
/* This routine code a netbios name from level1 to level2.   */
/* name2 has to be NBT_NAMESIZE bytes long, remember that.   */
/*************************************************************/

void
NBEncode(
    unsigned char *name2,
    unsigned char *name
    )
{
    int i;

    name2[0] = 0x20;        /* length of first block */

    for (i = 0; i < NBT_NONCODED_NMSZ - 1; i++)
    {
        name2[ 2*i+1 ] =  ((name[ i ] >> 4) & 0x0f) + 0x41;
        name2[ 2*i+2 ] =  (name[ i ]  & 0x0f) + 0x41;
    }

    name2[ NBT_NAMESIZE-1 ] = 0;    /* length of next block */
}

/*******************************************************************/
/*                                                                 */
/* Send a Name Query to a WINS Server                              */
/*                                                                 */
/* name is the name to query                                       */
/* winsaddr is the ip address of the wins server to query          */
/* TransID is the transaction ID to use for the query              */
/*                                                                 */
/*******************************************************************/

void
SendNameQuery(
    unsigned char *name,
    u_long winsaddr,
    u_short TransID
    )
{
    struct sockaddr_in destad;
    char    lpResults[MAX_SIZE] = {0};
    char    paddedname[NBT_NONCODED_NMSZ];
    USHORT usEndPoint = 5005;
    int     err = 0;

    struct
    {
        u_short TransactionID;
        u_short Flags;
        u_short QuestionCount;
        u_short AnswerCount;
        u_short NSCount;
        u_short AdditionalRec;
        u_char  QuestionName[NBT_NAMESIZE];
        u_short QuestionType;
        u_short QuestionClass;
    } NameQuery;

    memset(paddedname, 0x20, sizeof(paddedname));
    memcpy(paddedname, name, strlen(name));

    NBEncode(NameQuery.QuestionName, paddedname);

    NameQuery.TransactionID = htons(TransID);
    NameQuery.Flags = htons(0x0100);
    NameQuery.QuestionCount = htons(1);
    NameQuery.AnswerCount = 0;
    NameQuery.NSCount = 0;
    NameQuery.AdditionalRec = 0;
    NameQuery.QuestionType = htons(0x0020);
    NameQuery.QuestionClass = htons(1);

    destad.sin_family = AF_INET;
    destad.sin_port = htons(137);
    destad.sin_addr.s_addr = winsaddr;


    err = sendto(sd, (char *)&NameQuery, sizeof(NameQuery), 0,
                   (struct sockaddr *)&destad, sizeof(myad));
    
    if( err is SOCKET_ERROR )
    {
        DisplayErrorMessage(EMSG_WINS_SENDTO_FAILED, WSAGetLastError());
        return;
    }
}

/*******************************************************************/
/*                                                                 */
/* Wait for a Name Response which matches the Transaction ID       */
/*                                                                 */
/* recvaddr is the ip address returned by the wins server          */
/*                                                                 */
/*******************************************************************/

int
GetNameResponse(
    u_long * recvaddr,
	u_short  TransactionID
    )

{
    char lpResults[100] = {0};
    int i;
    int len;
    int rslt;
    u_long AnswerAddr;
    struct sockaddr_in addr;
    NameResponse * pNameResponse = NULL;
    BYTE Buf[NAME_RESPONSE_BUFFER_SIZE] = {0};

    i = 0;
    while (i < 15)
    {
        addrlen = sizeof(addr);
        if ((len=recvfrom(sd, (char *) Buf, sizeof(Buf), 0,
                     (struct sockaddr *)&addr, &addrlen)) < 0)
        {
            rslt = WSAGetLastError();
            if (rslt == WSAEWOULDBLOCK)
            {
                Sleep(100);
                i++;
                continue;
            }
            else
            {
                DisplayErrorMessage(EMSG_WINS_GETRESPONSE_FAILED,
                                    rslt);
                return WINSTEST_NO_RESPONSE;
            }
        }

        pNameResponse = (NameResponse *) Buf;

        if (TransactionID == htons(pNameResponse->TransactionID))
        {
            if (htons(pNameResponse->AnswerCount) == 0)
            {
                *recvaddr = 0;
                return(WINSTEST_NOT_FOUND);
            }
        
            AnswerAddr = (pNameResponse->AnswerAddr2 << 16) | pNameResponse->AnswerAddr1;
            *recvaddr = AnswerAddr;
            
            return(WINSTEST_FOUND);
        }
    }
    
    *recvaddr = 0;
    
    return(WINSTEST_NO_RESPONSE);
}

INT
InitNameCheckSocket()
{
	WCHAR lpResults[MAX_SIZE];
    BOOL  fBroadcast = TRUE;
    INT   err = 0;

    /*  Set up a socket to use for querys and responses   */

    WSAStartup( 0x0101, &WsaData ); // make sure winsock is happy - noop for now

    if ((sd = socket( AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
    {
        DisplayErrorMessage(EMSG_WINS_NAMECHECK_FAILED,
                            WSAGetLastError());

		return WSAGetLastError(); 
    }

    myad.sin_family = AF_INET;
    myad.sin_addr.s_addr = htonl(INADDR_ANY);//htonl(INADDR_BROADCAST);//INADDR_ANY;
    myad.sin_port = htons(0);//htons(usEndPoint);

    if (bind( sd, (struct sockaddr *)&myad, sizeof(myad) ) < 0)
    {
        DisplayErrorMessage(EMSG_WINS_NAMECHECK_FAILED,
                            WSAGetLastError());
        
        closesocket( sd );
		return WSAGetLastError(); 
    }

    if (ioctlsocket(sd, FIONBIO, &NonBlocking) < 0)
    {
        DisplayErrorMessage(EMSG_WINS_NAMECHECK_FAILED,
                            WSAGetLastError());
		return WSAGetLastError(); 
    }

	return 0;
}

INT 
CloseNameCheckSocket()
{
	closesocket(sd);

	WSACleanup();

	return 0;
}



INT
CheckNameConsistency()
{
    int             status = 0;
    int             i, j;
    int             Pass;
    int             ServerInx, NameInx, Inx;
    struct in_addr  retaddr;
    struct in_addr  tempaddr;
    u_long          temp;
    WINSERVERS *    ServerTemp;
    int             retry;
	FILE *          nf;
    WCHAR           szBuffer[MAX_SIZE] = {L'\0'};
    WCHAR           szNum[10];
    WCHAR           lpResults[200] = {L'\0'};
    WCHAR           wcName[21] = {L'\0'};
    BOOL            fDone = FALSE;
    LPWSTR          pwszTempBuf = NULL;

    // initialize some things

    memset(VerifiedAddress, 0, sizeof(VerifiedAddress));

    status = InitNameCheckSocket();

    // if the query is sent to the local server, TranIDs less than 0x7fff are dropped by NetBT
    TranID = 0x8000;
        
    if( status )
        return status;

    for (i = 0; i < MAX_SERVERS; i++)
    {
        WinServers[i].LastResponse = -1;
        WinServers[i].fQueried = FALSE;
        WinServers[i].Valid = 0;
        WinServers[i].Failed = 0;
        WinServers[i].Retries = 0;
        WinServers[i].Completed = 0;
    }
 
    /*  We initially have no failed servers   */

    for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
    {
        ServerTemp = &WinServers[ServerInx];
		ServerTemp->Failed = 0;
    }

    for (NameInx = 0; NameInx < NumNBNames; NameInx++)
    {
        CHAR    cchEnd = 0x00;
        cchEnd = NBNames[NameInx][15];
        NBNames[NameInx][15] = 0x00;

        pwszTempBuf = WinsOemToUnicode(NBNames[NameInx], NULL);
        NBNames[NameInx][15] = cchEnd;

        if( pwszTempBuf is NULL )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_OUT_OF_MEMORY);
            return FALSE;
        }
        wcsncpy(wcName, pwszTempBuf, 15);
        
        WinsFreeMemory(pwszTempBuf);
        pwszTempBuf = NULL;

        for( j=wcslen(wcName); j<16; j++ )
        {
            wcName[j] = L' ';
        }

        wcName[15] = L'[';
        WinsHexToString(wcName+16, (LPBYTE)&cchEnd, 1);
        wcName[18] = L'h';
        wcName[19] = L']';
        wcName[20] = L'\0';
        for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
        {
            ServerTemp = &WinServers[ServerInx];

            if (ServerTemp->Completed)
            {
                continue;
            }

            retry = 0;
            TranID++;

            fDone = FALSE;

            while( !fDone )
            {      
                pwszTempBuf = WinsOemToUnicode(inet_ntoa(ServerTemp->Server), NULL);
                if( pwszTempBuf is NULL )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_WINS_OUT_OF_MEMORY);
                    return FALSE;
                }

                DisplayMessage(g_hModule,
                               MSG_WINS_SEND_NAMEQUERY,
                               pwszTempBuf,
                               wcName);

                WinsFreeMemory(pwszTempBuf);
                pwszTempBuf = NULL;

                SendNameQuery(NBNames[NameInx],
                              ServerTemp->Server.s_addr,
                              TranID);

                switch (GetNameResponse(&retaddr.s_addr, TranID))
                {
                case WINSTEST_FOUND:     // found
                    ServerTemp->RetAddr.s_addr = retaddr.s_addr;
                    ServerTemp->Valid = 1;
                    ServerTemp->LastResponse = NameInx;

                    if (retaddr.s_addr == VerifiedAddress[NameInx])
                    {
                        // this address has already been verified... don't
                        // do the checking again
                        DisplayMessage(g_hModule,
                                       MSG_WINS_DISPLAY_STRING,
                                       wszOK);
                        fDone = TRUE;
                        break;
                    }

                    status = VerifyRemote(inet_ntoa(ServerTemp->RetAddr),
                                          NBNames[NameInx]);


                    if (WINSTEST_VERIFIED == status)
                    {
                        DisplayMessage(g_hModule,
                                       MSG_WINS_DISPLAY_STRING,
                                       wszOK);
                        VerifiedAddress[NameInx] = retaddr.s_addr;
                    }
                    else
                    {
                        DisplayMessage(g_hModule,
                                       MSG_WINS_DISPLAY_STRING,
                                       wszNameVerify);//wszFailure);
                    }
                
                    fDone = TRUE;
                    break;

                case WINSTEST_NOT_FOUND:     // responded -- name not found
                    ServerTemp->RetAddr.s_addr = retaddr.s_addr;
                    ServerTemp->Valid = 0;
                    ServerTemp->LastResponse = NameInx;
                
                    DisplayMessage(g_hModule, EMSG_WINS_NAME_NOT_FOUND);
                    retry++;
                    if (retry > 2)
                    {
                        ServerTemp->Failed = 1;
                        fDone = TRUE;
                    }
                    break;

                case WINSTEST_NO_RESPONSE:     // no response
                    ServerTemp->RetAddr.s_addr = retaddr.s_addr;
                    ServerTemp->Valid = 0;
                    ServerTemp->Retries++;

					DisplayMessage(g_hModule, EMSG_WINS_NO_RESPONSE);

                    retry++;
                    if (retry > 2)
                    {
                        ServerTemp->Failed = 1;
                        fDone = TRUE;
                    }
                
                    break;
                default:
                    break;
                }   // switch GetNameResponse
            }   //while loop
        }   // for ServerInx

        //Find a server address for this name
        for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
        {

            ServerTemp = &WinServers[ServerInx];
            if (ServerTemp->Valid)
            {
                DisplayMessage(g_hModule,
                               MSG_WINS_RESULTS);
                DisplayInfo(NameInx, ServerTemp->RetAddr.s_addr);
                break;
            }
        }   // for ServerInx

    }   //Name for loop
        

    //Mark all successful servers as completed;
    for( ServerInx = 0; ServerInx < NumWinServers; ServerInx++ )
    {
        ServerTemp = &WinServers[ServerInx];
        if( !ServerTemp->Failed )
        {
            ServerTemp->Completed = 1;
        }
    }

    DisplayMessage(g_hModule,
                   MSG_WINS_FINAL_RESULTS);

    for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
    {
        ServerTemp = &WinServers[ServerInx];

        pwszTempBuf = WinsOemToUnicode(inet_ntoa(ServerTemp->Server), NULL);

        if( pwszTempBuf is NULL )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_OUT_OF_MEMORY);
            return FALSE;
        }
        if ((-1) == ServerTemp->LastResponse)
        {
            DisplayMessage(g_hModule, 
                           EMSG_WINS_WINS_NEVERRESPONDED,
                           pwszTempBuf);
        }
        else if (0 == ServerTemp->Completed)
        {
            DisplayMessage(g_hModule, 
                           EMSG_WINS_WINS_INCOMPLETE,
                           pwszTempBuf);
        }
        WinsFreeMemory(pwszTempBuf);
        pwszTempBuf = NULL;
    }   // for ServerInx

    for (NameInx = 0; NameInx < NumNBNames; NameInx++)
    {
        CHAR cchEnd = NBNames[NameInx][15];
        NBNames[NameInx][15] = '\0';

        pwszTempBuf = WinsOemToUnicode(NBNames[NameInx], NULL);
        NBNames[NameInx][15] = cchEnd;        
        
        if( pwszTempBuf is NULL )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_OUT_OF_MEMORY);
            return FALSE;
        }
        
        wcsncpy(wcName, pwszTempBuf, 15);
        
        WinsFreeMemory(pwszTempBuf);
        pwszTempBuf = NULL;

        for( j = wcslen(wcName); j < 16; j++ )
        {
            wcName[j] = L' ';
        }

        wcName[15] = L'[';
        WinsHexToString(wcName+16, (LPBYTE)&cchEnd, 1);
        wcName[18] = L'h';
        wcName[19] = L']';
        wcName[20] = L'\0';
        if (0 == VerifiedAddress[NameInx])
        {
            DisplayMessage(g_hModule, 
                           EMSG_WINS_ADDRESS_VERIFY_FAILED,
                           wcName);
        }
    }   // for NameInx

    DisplayMessage(g_hModule,
                   WINS_FORMAT_LINE);
    CloseNameCheckSocket();
    return 1;   // just to keep the compiler happy -- why do we have to?
}

void DisplayInfo(int uNames, u_long ulValidAddr)
{
    int             uServers;
    CHAR            cchEnd = 0x00;
    LPWSTR          pwszTemp = NULL;
    WINSERVERS *    pCurrentServer;
    struct in_addr  tempaddr;
    int             i, j;
    BOOL            fMismatchFound = FALSE;
    WCHAR           wcName[21] = {L'\0'};

    cchEnd = NBNames[uNames][15];
    NBNames[uNames][15] = 0x00;

    pwszTemp = WinsOemToUnicode(NBNames[uNames], NULL);
    NBNames[uNames][15] = cchEnd;

    if( pwszTemp is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_NOT_ENOUGH_MEMORY);
        return;
    }    
    
    wcsncpy(wcName, pwszTemp, 15);
    
    for( j=wcslen(wcName); j<16; j++ )
    {
        wcName[j] = L' ';
    }

    wcName[15] = L'[';
    WinsHexToString(wcName+16, (LPBYTE)&cchEnd, 1);
    wcName[18] = L'h';
    wcName[19] = L']';
    wcName[20] = L'\0';
    
    WinsFreeMemory(pwszTemp);
    pwszTemp = NULL;

	// now check and see which WINS servers didn't match
	for (uServers = 0; uServers < NumWinServers; uServers++)
    {
		pCurrentServer = &WinServers[uServers];

        if (pCurrentServer->Completed)
        {
            continue;
        }
        
        if ( (pCurrentServer->Valid) )
        {
            if ( (pCurrentServer->RetAddr.s_addr != ulValidAddr) || 
				 (VerifiedAddress[uNames] != 0 && 
				  VerifiedAddress[uNames] != ulValidAddr) )
            {

				// mismatch
                DisplayMessage(g_hModule,
                               EMSG_WINS_NAME_INCONSISTENCY,
                               wcName);

                if (VerifiedAddress[uNames] != 0)
                {
                    tempaddr.s_addr = VerifiedAddress[uNames];
                    
                    DisplayMessage(g_hModule,
                                   EMSG_WINS_VERIFIED_ADDRESS,
                                   IpAddressToString(ntohl(tempaddr.S_un.S_addr)));
                }
                
				// display the inconsistent name resolutions
                for (i = 0; i < NumWinServers; i++)
                {
                    if (WinServers[i].Valid &&
						VerifiedAddress[uNames] != WinServers[i].RetAddr.S_un.S_addr)
                    {
                        DisplayMessage(g_hModule,
                                       EMSG_WINS_NAMEQUERY_RESULT,
                                       IpAddressToString(ntohl(WinServers[i].Server.S_un.S_addr)),
                                       wcName,
                                       IpAddressToString(ntohl(WinServers[i].RetAddr.S_un.S_addr)));
                    }
                }
                fMismatchFound = TRUE;
                break;
            }
        }
    }   // end check for invalid addresses

    if (!fMismatchFound)
    {
        // display the correct info
        DisplayMessage(g_hModule,
                       EMSG_WINS_NAME_VERIFIED,
                       wcName,
                       IpAddressToString(ntohl(ulValidAddr)));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\winshndl.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/
#ifndef _WINSHNDL_H_
#define _WINSHNDL_H_

FN_HANDLE_CMD  HandleWinsHelp;
FN_HANDLE_CMD  HandleWinsContexts;
FN_HANDLE_CMD  HandleWinsDump;

FN_HANDLE_CMD  HandleWinsAddServer;

FN_HANDLE_CMD  HandleWinsDeleteServer;

FN_HANDLE_CMD  HandleWinsShowServer;

#endif //_WINSHNDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\perfctrs\debug.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    debug.c

    This module contains debug support routines for the WINS Service.


    FILE HISTORY:
        pradeepb     20-July-1993 Created.

*/


#include "debug.h"
//#include "winsif.h"
//#include "winsintf.h"


#if DBG

//
//  Private constants.
//

#define MAX_PRINTF_OUTPUT       1024            // characters
#define WINSD_OUTPUT_LABEL       "WINS"


//
//  Private types.
//


//
//  Private globals.
//


//
//  Public functions.
//

/*******************************************************************

    NAME:       WinsdAssert

    SYNOPSIS:   Called if an assertion fails.  Displays the failed
                assertion, file name, and line number.  Gives the
                user the opportunity to ignore the assertion or
                break into the debugger.

    ENTRY:      pAssertion - The text of the failed expression.

                pFileName - The containing source file.

                nLineNumber - The guilty line number.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
VOID WinsdAssert( VOID  * pAssertion,
                 VOID  * pFileName,
                 ULONG   nLineNumber )
{
    RtlAssert( pAssertion, pFileName, nLineNumber, NULL );

}   // WinsdAssert

/*******************************************************************

    NAME:       WinsdPrintf

    SYNOPSIS:   Customized debug output routine.

    ENTRY:      Usual printf-style parameters.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
VOID WinsdPrintf( CHAR * pszFormat,
                 ... )
{
    CHAR    szOutput[MAX_PRINTF_OUTPUT];
    va_list ArgList;

    sprintf( szOutput,
             "%s (%lu): ",
             WINSD_OUTPUT_LABEL,
             GetCurrentThreadId() );

    va_start( ArgList, pszFormat );
    vsprintf( szOutput + strlen(szOutput), pszFormat, ArgList );
    va_end( ArgList );

    IF_DEBUG( OUTPUT_TO_DEBUGGER )
    {
        OutputDebugString( (LPCTSTR)szOutput );
    }

}   // WinsdPrintf


//
//  Private functions.
//

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\perfctrs\debug.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    debug.h

    This file contains a number of debug-dependent definitions for
    the WINS Service.


    FILE HISTORY:
        Pradeepb     07-Mar-1993 Created.

*/


#ifndef _DEBUG_H_
#define _DEBUG_H_


#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#if DBG

//
//  Debug output control flags.
//

#define WINSD_DEBUG_ENTRYPOINTS          0x00000001L     // DLL entrypoints
#define WINSD_DEBUG_OPEN                 0x00000002L     // OpenPerformanceData
#define WINSD_DEBUG_CLOSE                0x00000004L     // CollectPerformanceData
#define WINSD_DEBUG_COLLECT              0x00000008L     // ClosePerformanceData
// #define WINSD_DEBUG_                     0x00000010L
// #define WINSD_DEBUG_                     0x00000020L
// #define WINSD_DEBUG_                     0x00000040L
// #define WINSD_DEBUG_                     0x00000080L
// #define WINSD_DEBUG_                     0x00000100L
// #define WINSD_DEBUG_                     0x00000200L
// #define WINSD_DEBUG_                     0x00000400L
// #define WINSD_DEBUG_                     0x00000800L
// #define WINSD_DEBUG_                     0x00001000L
// #define WINSD_DEBUG_                     0x00002000L
// #define WINSD_DEBUG_                     0x00004000L
// #define WINSD_DEBUG_                     0x00008000L
// #define WINSD_DEBUG_                     0x00010000L
// #define WINSD_DEBUG_                     0x00020000L
// #define WINSD_DEBUG_                     0x00040000L
// #define WINSD_DEBUG_                     0x00080000L
// #define WINSD_DEBUG_                     0x00100000L
// #define WINSD_DEBUG_                     0x00200000L
// #define WINSD_DEBUG_                     0x00400000L
// #define WINSD_DEBUG_                     0x00800000L
// #define WINSD_DEBUG_                     0x01000000L
// #define WINSD_DEBUG_                     0x02000000L
// #define WINSD_DEBUG_                     0x04000000L
// #define WINSD_DEBUG_                     0x08000000L
// #define WINSD_DEBUG_                     0x10000000L
// #define WINSD_DEBUG_                     0x20000000L
#define WINSD_DEBUG_OUTPUT_TO_DEBUGGER   0x40000000L
// #define WINSD_DEBUG_                     0x80000000L

extern DWORD WinsdDebug;

#define IF_DEBUG(flag) if ( (WinsdDebug & WINSD_DEBUG_ ## flag) != 0 )


//
//  Debug output function.
//

VOID WinsdPrintf( CHAR * pszFormat,
                 ... );

#define WINSD_PRINT(args) WinsdPrintf args


//
//  Assert & require.
//

VOID WinsdAssert( VOID  * pAssertion,
                 VOID  * pFileName,
                 ULONG   nLineNumber );

#define WINSD_ASSERT(exp) if (!(exp)) WinsdAssert( #exp, __FILE__, __LINE__ )
#define WINSD_REQUIRE WINSD_ASSERT

#else   // !DBG

//
//  No debug output.
//

#define IF_DEBUG(flag) if (0)


//
//  Null debug output function.
//

#define WINSD_PRINT(args)


//
//  Null assert & require.
//

#define WINSD_ASSERT(exp)
#define WINSD_REQUIRE(exp) ((VOID)(exp))

#endif  // DBG


#endif  // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\winsmon.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/
#ifndef _WINSMON_H_
#define _WINSMON_H_



DWORD
WINAPI
WinsCommit(
    IN  DWORD   dwAction
);

BOOL 
WINAPI
WinsDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
);

NS_CONTEXT_ENTRY_FN WinsMonitor;

DWORD
WINAPI
WinsUnInit(
    IN  DWORD   dwReserved
);

BOOL
SetServerInfo(
    IN  LPCWSTR  pwszServerInfo
);

BOOL
IsHelpToken(
    PWCHAR  pwszToken
);

#endif //_WINSMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\netsh\winsmon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\wins\winsmon.c

Abstract:

    WINS Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 12/10/98

--*/

#include "precomp.h"

HANDLE   g_hModule = NULL;
BOOL     g_bCommit = TRUE;
BOOL     g_hConnect = FALSE;
DWORD    g_dwNumTableEntries = 0;


//{bf563723-9065-11d2-be87-00c04fc3357a}
static const GUID g_MyGuid = 
{ 0xbf563723, 0x9065, 0x11d2, { 0xbe, 0x87, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

static const GUID g_NetshGuid = NETSH_ROOT_GUID;

//


ULONG   g_ulInitCount = 0;

WCHAR   wszUnknown[50] = {L'\0'};
WCHAR   wszEnable[50] = {L'\0'};
WCHAR   wszDisable[50] = {L'\0'};
WCHAR   wszRandom[150] = {L'\0'};
WCHAR   wszOwner[150] = {L'\0'};
WCHAR   wszInfinite[100] = {L'\0'};
WCHAR   wszPush[50] = {L'\0'};
WCHAR   wszPull[50] = {L'\0'};
WCHAR   wszPushpull[50] = {L'\0'};
WCHAR   wszHigh[50] = {L'\0'};
WCHAR   wszNormal[50] = {L'\0'};
WCHAR   wszDeleted[150] = {L'\0'};
WCHAR   wszOK[50] = {L'\0'};
WCHAR   wszFailure[50] = {L'\0'};
WCHAR   wszNameVerify[100] = {L'\0'};


WINSMON_SUBCONTEXT_TABLE_ENTRY  g_WinsSubContextTable[] =
{
    {L"Server", HLP_WINS_CONTEXT_SERVER, HLP_WINS_CONTEXT_SERVER_EX, SrvrMonitor},
};


CMD_ENTRY g_WinsCmds[] = 
{
    CREATE_CMD_ENTRY(WINS_DUMP, HandleWinsDump),
    CREATE_CMD_ENTRY(WINS_HELP1, HandleWinsHelp),
    CREATE_CMD_ENTRY(WINS_HELP2, HandleWinsHelp),
    CREATE_CMD_ENTRY(WINS_HELP3, HandleWinsHelp),
    CREATE_CMD_ENTRY(WINS_HELP4, HandleWinsHelp),
};



ULONG g_ulNumTopCmds = sizeof(g_WinsCmds)/sizeof(CMD_ENTRY);
ULONG g_ulNumSubContext = sizeof(g_WinsSubContextTable)/sizeof(WINSMON_SUBCONTEXT_TABLE_ENTRY);

DWORD
WINAPI
WinsCommit(
    IN  DWORD   dwAction
)
{
    BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. Dhcp current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}

BOOL 
WINAPI
WinsDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
)
{
    WORD wVersion = MAKEWORD(1,1); //Winsock version 1.1 will do?
    WSADATA wsaData;
    HINSTANCE hAdmin = NULL;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            if(WSAStartup(wVersion,&wsaData) isnot NO_ERROR)
            {
                return FALSE;
            }

            //Load certain common string to be used extensively 
     
            {
                //Load the general "UNKNOWN" string
                DWORD dw = 0;
                dw = LoadString(g_hModule,
                                WINS_GENERAL_UNKNOWN,
                                wszUnknown,
                                ARRAY_SIZE(wszUnknown));

                if( dw is 0 )
                    wcscpy(wszUnknown, L"Not Set");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_ENABLE,
                                wszEnable,
                                ARRAY_SIZE(wszEnable));

                if( dw is 0 )
                    wcscpy(wszEnable, L"Enabled");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_DISABLE,
                                wszDisable,
                                ARRAY_SIZE(wszDisable));

                if( dw is 0 )
                    wcscpy(wszDisable, L"Disabled");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_RANDOM,
                                wszRandom,
                                ARRAY_SIZE(wszRandom));

                if( dw is 0 )
                    wcscpy(wszRandom, L"Randomly Selected Partner");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_OWNER,
                                wszOwner,
                                ARRAY_SIZE(wszOwner));

                if( dw is 0 )
                    wcscpy(wszOwner, L"Owner Server");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_INFINITE,
                                wszInfinite,
                                ARRAY_SIZE(wszInfinite));

                if( dw is 0 )
                    wcscpy(wszInfinite, L"Infinite                ");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_PULL,
                                wszPull,
                                ARRAY_SIZE(wszPull));

                if( dw is 0 )
                    wcscpy(wszPull, L"    Pull");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_PUSH,
                                wszPush,
                                ARRAY_SIZE(wszPush));

                if( dw is 0 )
                    wcscpy(wszPush, L"    Push");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_PUSHPULL,
                                wszPushpull,
                                ARRAY_SIZE(wszPushpull));

                if( dw is 0 )
                    wcscpy(wszPushpull, L"  Push/Pull");


                dw = LoadString(g_hModule,
                                WINS_GENERAL_NORMAL,
                                wszNormal,
                                ARRAY_SIZE(wszNormal));

                if( dw is 0 )
                    wcscpy(wszNormal, L"NORMAL");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_HIGH,
                                wszHigh,
                                ARRAY_SIZE(wszHigh));

                if( dw is 0 )
                    wcscpy(wszHigh, L"HIGH");


                dw = LoadString(g_hModule,
                                WINS_GENERAL_DELETED,
                                wszDeleted,
                                ARRAY_SIZE(wszDeleted));

                if( dw is 0 )
                    wcscpy(wszDeleted, L"Deleted. Slot will be reused later.");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_OK,
                                wszOK,
                                ARRAY_SIZE(wszOK));
                if( dw is 0 )
                    wcscpy(wszOK, L"OK");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_FAILURE,
                                wszFailure,
                                ARRAY_SIZE(wszFailure));
                if( dw is 0 )
                    wcscpy(wszFailure, L"FAILED");
                
                dw = LoadString(g_hModule,
                                WINS_GENERAL_NAMENOTVERIFIED,
                                wszNameVerify,
                                ARRAY_SIZE(wszNameVerify));

                if( dw is 0 )
                    wcscpy(wszNameVerify, L"Name can not be verified.");

            }

            break;
        }
        case DLL_PROCESS_DETACH:
            {
                if( g_ServerNameAnsi )
                {
                    WinsFreeMemory(g_ServerNameAnsi);
                    g_ServerNameAnsi = NULL;
                }
                if( g_ServerNameUnicode )
                {
                    WinsFreeMemory(g_ServerNameUnicode);
                    g_ServerNameUnicode = NULL;
                }
                break;
            }
        default:
        {
            break;
        }
    }

    return TRUE;
}


DWORD
WINAPI
WinsStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;
    PNS_PRIV_CONTEXT_ATTRIBUTES  pNsPrivContextAttributes;

    pNsPrivContextAttributes = HeapAlloc(GetProcessHeap(), 0, sizeof(PNS_PRIV_CONTEXT_ATTRIBUTES));
    if (!pNsPrivContextAttributes)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    ZeroMemory(pNsPrivContextAttributes, sizeof(PNS_PRIV_CONTEXT_ATTRIBUTES));

    attMyAttributes.pwszContext = L"wins";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = CMD_FLAG_ONLINE;
    attMyAttributes.pfnCommitFn = WinsCommit;
    attMyAttributes.pfnDumpFn   = WinsDump;

    pNsPrivContextAttributes->pfnEntryFn    = WinsMonitor;
    attMyAttributes.pReserved     = pNsPrivContextAttributes;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD WINAPI
InitHelperDll(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved )
{
    DWORD   dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    //
    // See if this is the first time we are being called
    //

    if(InterlockedIncrement(&g_ulInitCount) != 1)
    {
        return NO_ERROR;
    }


    g_bCommit = TRUE;

    // Register helpers
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );

    attMyAttributes.guidHelper         = g_MyGuid;
    attMyAttributes.dwVersion          = WINS_HELPER_VERSION;
    attMyAttributes.pfnStart           = WinsStartHelper;
    attMyAttributes.pfnStop            = NULL;
 
    RegisterHelper( &g_NetshGuid, &attMyAttributes );

    return NO_ERROR;
}


DWORD
WINAPI
WinsMonitor(
    IN      LPCWSTR     pwszMachine,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID     pvData,
    OUT     LPWSTR      pwcNewContext
    )
{
    DWORD  dwError = NO_ERROR;
    DWORD  dwIndex, i, j;
    BOOL   bFound = FALSE;
    PFN_HANDLE_CMD    pfnHandler = NULL;
    DWORD  dwNumMatched;
    DWORD  dwCmdHelpToken = 0;
    DWORD  ThreadOptions = 0;    
    PNS_CONTEXT_ENTRY_FN     pfnHelperEntryPt;
    PNS_CONTEXT_DUMP_FN      pfnHelperDumpPt;

    //if dwArgCount is 1 then it must be a context switch fn. or looking for help

    if(dwArgCount is 1)
    {
        return ERROR_CONTEXT_SWITCH;
    }

    dwIndex = 1;

    //Is it a top level(non Group command)?
    for(i=0; i<g_ulNumTopCmds; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_WinsCmds[i].pwszCmdToken))
        {
            bFound = TRUE;
            dwIndex++;
            dwArgCount--;
            pfnHandler = g_WinsCmds[i].pfnCmdHandler;

            dwCmdHelpToken = g_WinsCmds[i].dwCmdHlpToken;

            break;
        }
    }


    if(bFound)
    {
        if(dwArgCount > dwIndex && IsHelpToken(ppwcArguments[dwIndex]))
        {
            DisplayMessage(g_hModule, dwCmdHelpToken);

            return NO_ERROR;
        }

        dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwIndex, dwArgCount,
                                dwFlags, pvData, &bFound);

        return dwError;
    }

    bFound = FALSE;

    //Is it meant for subcontext?
    for(i = 0; i<g_ulNumSubContext; i++)
    {
        if( MatchToken(ppwcArguments[dwIndex], g_WinsSubContextTable[i].pwszContext) )
        {
            bFound = TRUE;
            dwIndex++;
            dwArgCount--;
            pfnHelperEntryPt = g_WinsSubContextTable[i].pfnEntryFn;
            break;
        }
    }

    if( bFound )    //Subcontext
    {
        dwError = (pfnHelperEntryPt)(pwszMachine,
                                     ppwcArguments+1,
                                     dwArgCount,
                                     dwFlags,
                                     pvData,
                                     pwcNewContext);
        return dwError;
    }

    if (!bFound)
    {
        //
        // Command not found. 
       //
        return ERROR_CMD_NOT_FOUND;
    }   
    return dwError;
}



DWORD
WINAPI
WinsUnInit(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}

BOOL
IsHelpToken(
    PWCHAR  pwszToken
    )
{
    if(MatchToken(pwszToken, CMD_WINS_HELP1))
        return TRUE;

    if(MatchToken(pwszToken, CMD_WINS_HELP2))
        return TRUE;
    
    if(MatchToken(pwszToken, CMD_WINS_HELP3))
        return TRUE;

    if(MatchToken(pwszToken, CMD_WINS_HELP4))
        return TRUE;

    return FALSE;
}

PVOID
WinsAllocateMemory(
                   DWORD dwSize
                  )
{
    LPVOID pvOut = NULL;
    pvOut = malloc(dwSize);
    if( pvOut )
    {
        memset(pvOut, 0x00, dwSize);
    }
    return pvOut;
}

VOID
WinsFreeMemory(
               PVOID Memory
               )
{
    if (Memory != NULL)
        free( Memory );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\perfctrs\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  TEXT("WINSCTRS")

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\perfctrs\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Russ Blake  7/30/92

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
// The definition of the only routine of perfutil.c, It builds part of a 
// performance data instance (PERF_INSTANCE_DEFINITION) as described in 
// winperf.h
//

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
LONG AddSrcToReg ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\perfctrs\perfwins.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    perfwins.c

    This file implements the Extensible Performance Objects for
    the FTP Server service.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created, based on RussBl's sample code.

*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winperf.h>
#include <lm.h>

#include <string.h>
#include <stdlib.h>

#include "winsctrs.h"
#include "perfmsg.h"
#include "perfutil.h"
#include "winsintf.h"
#include "winsdata.h"
#include "debug.h"
#include "winsevnt.h"


//
//  Private globals.
//

DWORD   cOpens    = 0;                 // Active "opens" reference count.
BOOL    fInitOK   = FALSE;             // TRUE if DLL initialized OK.
BOOL    sfLogOpen;                     //indicates whether the log is
                                       //open or closed

BOOL    sfErrReported;                //to prevent the same error from being
                                      //logged continuously
#if DBG
DWORD   WinsdDebug = 0;                  // Debug behaviour flags.
#endif  // DBG

//
//  Public prototypes.
//

PM_OPEN_PROC    OpenWinsPerformanceData;
PM_COLLECT_PROC CollectWinsPerformanceData;
PM_CLOSE_PROC   CloseWinsPerformanceData;


//
//  Public functions.
//

/*******************************************************************

    NAME:       OpenWinsPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate
                performance counters with the registry.

    ENTRY:      lpDeviceNames - Poitner to object ID of each device
                    to be opened.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        Pradeepb     20-July-1993 Created.

********************************************************************/
DWORD OpenWinsPerformanceData( LPWSTR lpDeviceNames )
{
    DWORD err  = NO_ERROR;
    HKEY  hkey = NULL;
//    DWORD size;
//    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;

    IF_DEBUG( ENTRYPOINTS )
    {
        WINSD_PRINT(( "in OpenWinsPerformanceData\n" ));
    }

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem.
    //

    if( !fInitOK )
    {
        PERF_COUNTER_DEFINITION * pctr;
        DWORD                     i;
        if(AddSrcToReg() == ERROR_SUCCESS)
        {
          if (!MonOpenEventLog())
          {
             sfLogOpen = TRUE;
          }
        }

        //
        //  This is the *first* open.
        //

	    dwFirstCounter = WINSCTRS_FIRST_COUNTER;
	    dwFirstHelp    = WINSCTRS_FIRST_HELP;
	
            //
            //  Update the object & counter name & help indicies.
            //


            WinsDataDataDefinition.ObjectType.ObjectNameTitleIndex
                += dwFirstCounter;
            WinsDataDataDefinition.ObjectType.ObjectHelpTitleIndex
                += dwFirstHelp;

            pctr = &WinsDataDataDefinition.UniqueReg;

            for( i = 0 ; i < NUMBER_OF_WINSDATA_COUNTERS ; i++ )
            {
                pctr->CounterNameTitleIndex += dwFirstCounter;
                pctr->CounterHelpTitleIndex += dwFirstHelp;
                pctr++;
            }

            //
            //  Remember that we initialized OK.
            //

            fInitOK = TRUE;

        //
        //  Close the registry if we managed to actually open it.
        //

        if( hkey != NULL )
        {
            RegCloseKey( hkey );
            hkey = NULL;
        }

        IF_DEBUG( OPEN )
        {
            if( err != NO_ERROR )
            {
                WINSD_PRINT(( "Cannot read registry data, error %lu\n", err ));
            }
        }
    }

    //
    //  Bump open counter.
    //

    if( err == NO_ERROR )
    {
        cOpens++;
    }
    //
    // if sfLogOpen is FALSE, it means that all threads we closed the
    // event log in CloseWinsPerformanceData
    //
    if (!sfLogOpen)
    {
       MonOpenEventLog();
    }

    return err;

}   // OpenWinsPerformanceData

/*******************************************************************

    NAME:       CollectWinsPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate

    ENTRY:      lpValueName - The name of the value to retrieve.

                lppData - On entry contains a pointer to the buffer to
                    receive the completed PerfDataBlock & subordinate
                    structures.  On exit, points to the first bytes
                    *after* the data structures added by this routine.

                lpcbTotalBytes - On entry contains a pointer to the
                    size (in BYTEs) of the buffer referenced by lppData.
                    On exit, contains the number of BYTEs added by this
                    routine.

                lpNumObjectTypes - Receives the number of objects added
                    by this routine.

    RETURNS:    DWORD - Win32 status code.  MUST be either NO_ERROR
                    or ERROR_MORE_DATA.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CollectWinsPerformanceData( LPWSTR    lpValueName,
                                 LPVOID  * lppData,
                                 LPDWORD   lpcbTotalBytes,
                                 LPDWORD   lpNumObjectTypes )
{
    DWORD                    dwQueryType;
    ULONG                    cbRequired;
    DWORD                    *pdwCounter;
    WINSDATA_COUNTER_BLOCK   *pCounterBlock;
    WINSDATA_DATA_DEFINITION *pWinsDataDataDefinition;
    WINSINTF_RESULTS_NEW_T	      Results;
#if 0
    WINSINTF_RESULTS_T	      Results;
#endif
    WINSINTF_STAT_T          *pWinsStats = &Results.WinsStat;
    DWORD          	     Status;


    IF_DEBUG( ENTRYPOINTS )
    {
        WINSD_PRINT(( "in CollectWinsPerformanceData\n" ));
        WINSD_PRINT(( "    lpValueName      = %08lX (%ls)\n",
                     lpValueName,
                     lpValueName ));
        WINSD_PRINT(( "    lppData          = %08lX (%08lX)\n",
                     lppData,
                     *lppData ));
        WINSD_PRINT(( "    lpcbTotalBytes   = %08lX (%08lX)\n",
                     lpcbTotalBytes,
                     *lpcbTotalBytes ));
        WINSD_PRINT(( "    lpNumObjectTypes = %08lX (%08lX)\n",
                     lpNumObjectTypes,
                     *lpNumObjectTypes ));
    }

    //
    //  No need to even try if we failed to open...
    //

    if( !fInitOK )
    {
        IF_DEBUG( COLLECT )
        {
            WINSD_PRINT(( "Initialization failed, CollectWinsPerformanceData aborting\n" ));
        }

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        //
        //  According to the Performance Counter design, this
        //  is a successful exit.  Go figure.
        //

        return NO_ERROR;
    }

    //
    //  Determine the query type.
    //

    dwQueryType = GetQueryType( lpValueName );

    if( dwQueryType == QUERY_FOREIGN )
    {
        IF_DEBUG( COLLECT )
        {
            WINSD_PRINT(( "foreign queries not supported\n" ));
        }

        //
        //  We don't do foreign queries.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    if( dwQueryType == QUERY_ITEMS )
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if( !IsNumberInUnicodeList(
                        WinsDataDataDefinition.ObjectType.ObjectNameTitleIndex,
                        lpValueName ) )
        {
            IF_DEBUG( COLLECT )
            {
                WINSD_PRINT(( "%ls not a supported object type\n", lpValueName ));
            }

            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            return NO_ERROR;
        }
    }

    //
    //  See if there's enough space.
    //

    pWinsDataDataDefinition = (WINSDATA_DATA_DEFINITION *)*lppData;

    cbRequired = sizeof(WINSDATA_DATA_DEFINITION) +
				WINSDATA_SIZE_OF_PERFORMANCE_DATA;

    if( *lpcbTotalBytes < cbRequired )
    {
        IF_DEBUG( COLLECT )
        {
            WINSD_PRINT(( "%lu bytes of buffer insufficient, %lu needed\n",
                          *lpcbTotalBytes,
                          cbRequired ));
        }

        //
        //  Nope.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return ERROR_MORE_DATA;
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove( pWinsDataDataDefinition,
             &WinsDataDataDefinition,
             sizeof(WINSDATA_DATA_DEFINITION) );

    //
    //  Try to retrieve the data.
    //

    Results.WinsStat.NoOfPnrs = 0;
    Results.WinsStat.pRplPnrs = NULL;
    Results.pAddVersMaps = NULL;

    {
        WINSINTF_BIND_DATA_T    BindData;
        handle_t                BindHdl;

        BindData.fTcpIp     =  FALSE;
        BindData.pPipeName  =  (LPBYTE)TEXT("\\pipe\\WinsPipe");
        BindData.pServerAdd =  (LPBYTE)TEXT("");

        BindHdl = WinsBind(&BindData);
        Status  = WinsStatusNew(BindHdl, WINSINTF_E_STAT, &Results);
        WinsUnbind(&BindData, BindHdl);
    }

    if( Status != WINSINTF_SUCCESS )
    {
        IF_DEBUG( COLLECT )
        {
            WINSD_PRINT(( "cannot retrieve statistics, error %lu\n",
                         Status ));

        }

        //
        // if we haven't logged the error yet, log it
        //
        if (!sfErrReported)
        {
          REPORT_ERROR(WINS_EVT_WINS_STATUS_ERR, LOG_USER);
          sfErrReported = TRUE;
        }

        //
        //  Error retrieving statistics.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    //
    // Ahaa, we got the statistics, reset flag if set
    //
    if (sfErrReported)
    {
       sfErrReported = FALSE;
    }
    //
    //  Format the WINS Server data.
    //

    pCounterBlock = (WINSDATA_COUNTER_BLOCK *)( pWinsDataDataDefinition + 1 );

    pCounterBlock->PerfCounterBlock.ByteLength =
				WINSDATA_SIZE_OF_PERFORMANCE_DATA;

    //
    //  Get the pointer to the first (DWORD) counter.  This
    //  pointer *must* be quadword aligned.
    //

    pdwCounter = (DWORD *)( pCounterBlock + 1 );

    WINSD_ASSERT( ( (DWORD_PTR)pdwCounter & 3 ) == 0 );

    IF_DEBUG( COLLECT )
    {
        WINSD_PRINT(( "pWinsDataDataDefinition =