4)
{
    LONG    xDst;
    LONG    yDst;

    xDst = pOffDst->x;
    yDst = pOffDst->y;

    CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_RECTL_NOT_NULL(prclDst, xDst, yDst);
    OFFSET_POINTL(pptlSrc, pOffSrc->x, pOffSrc->y);
    OFFSET_POINTL(pptlBrush, xDst, yDst);
    ASSERTGDI((!psoSrc)                            ||
              (!(psoSrc->dhpdev) || !(psoDst->dhpdev)) ||
              (psoSrc->dhpdev == psoDst->dhpdev),
              "OffBitBlt: ERROR blitting across devices.");

    BOOL bRet = pfnBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);

    CLIPOBJ_vOffset(pco, -xDst, -yDst);
    ASSERT_BRUSH_ORIGIN(pptlBrush, xDst, yDst);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffCopyBits
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffCopyBits(
PFN_DrvCopyBits pfnCopyBits,
POINTL*         pOffDst,
SURFOBJ*        psoDst,
POINTL*         pOffSrc,
SURFOBJ*        psoSrc,
CLIPOBJ*        pco,
XLATEOBJ*       pxlo,
RECTL*          prclDst,
POINTL*         pptlSrc)
{
    LONG    xDst;
    LONG    yDst;
    LONG    xSrc;
    LONG    ySrc;

    xSrc = pOffSrc->x;
    ySrc = pOffSrc->y;
    xDst = pOffDst->x;
    yDst = pOffDst->y;

    if (pco != NULL)
        CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_RECTL_NOT_NULL(prclDst, xDst, yDst);
    OFFSET_POINTL_NOT_NULL(pptlSrc, xSrc, ySrc);
    ASSERTGDI((!psoSrc)                                ||
              (!(psoSrc->dhpdev) || !(psoDst->dhpdev)) ||
              (psoSrc->dhpdev == psoDst->dhpdev),
              "OffCopyBits: ERROR copying across devices.");

    // A defacto DDI rule is that on a CopyBits call, the bounds of a complex
    // clip object must intersect with the destination rectangle.  This
    // is due to that fact that some drivers, such as the VGA driver, do not
    // bother checking for intersection with the destination rectangle when
    // enumerating a complex clip object.  Thus, if this assert is hit, the
    // routine which constructed the clip object will have to be fixed.  Note
    // that this is unrelated to sprites; I simply put this assert here because
    // it was a handy place for it, to check all CopyBits calls.

    ASSERTGDI((pco == NULL)                     ||
              (pco->iDComplexity == DC_TRIVIAL) ||
              bIntersect(&pco->rclBounds, prclDst),
        "Clip object bounds doesn't intersect destination rectangle");

    BOOL bRet = pfnCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);

    if (pco != NULL)
        CLIPOBJ_vOffset(pco, -xDst, -yDst);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffStretchBlt
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffStretchBlt(
PFN_DrvStretchBlt   pfnStretchBlt,
POINTL*             pOffDst,
SURFOBJ*            psoDst,
POINTL*             pOffSrc,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)
{
    LONG    xDst;
    LONG    yDst;
    LONG    xSrc;
    LONG    ySrc;

    xSrc = pOffSrc->x;
    ySrc = pOffSrc->y;
    xDst = pOffDst->x;
    yDst = pOffDst->y;

    CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_RECTL_NOT_NULL(prclDst, xDst, yDst);
    OFFSET_RECTL_NOT_NULL(prclSrc, xSrc, ySrc);
    OFFSET_POINTL(pptlHTOrg, xDst, yDst);

    BOOL bRet = pfnStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca,
                              pptlHTOrg, prclDst, prclSrc, pptlMsk, iMode);

    CLIPOBJ_vOffset(pco, -xDst, -yDst);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffStretchBltROP
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffStretchBltROP(
PFN_DrvStretchBltROP    pfnStretchBltROP,
POINTL*                 pOffDst,
SURFOBJ*                psoDst,
POINTL*                 pOffSrc,
SURFOBJ*                psoSrc,
SURFOBJ*                psoMsk,
CLIPOBJ*                pco,
XLATEOBJ*               pxlo,
COLORADJUSTMENT*        pca,
POINTL*                 pptlHTOrg,
RECTL*                  prclDst,
RECTL*                  prclSrc,
POINTL*                 pptlMsk,
ULONG                   iMode,
BRUSHOBJ*               pbo,
DWORD                   rop4)
{
    LONG    xDst;
    LONG    yDst;
    LONG    xSrc;
    LONG    ySrc;

    xSrc = pOffSrc->x;
    ySrc = pOffSrc->y;
    xDst = pOffDst->x;
    yDst = pOffDst->y;

    CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_RECTL(prclDst, xDst, yDst);
    OFFSET_RECTL(prclSrc, xSrc, ySrc);
    OFFSET_POINTL(pptlHTOrg, xDst, yDst);

    BOOL bRet = pfnStretchBltROP(psoDst, psoSrc, psoMsk, pco, pxlo, pca,
                                 pptlHTOrg, prclDst, prclSrc, pptlMsk, iMode,
                                 pbo, rop4);

    CLIPOBJ_vOffset(pco, -xDst, -yDst);

    return(bRet);

}

/******************************Public*Routine******************************\
* BOOL OffTransparentBlt
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffTransparentBlt(
PFN_DrvTransparentBlt   pfnTransparentBlt,
POINTL*                 pOffDst,
SURFOBJ*                psoDst,
POINTL*                 pOffSrc,
SURFOBJ*                psoSrc,
CLIPOBJ*                pco,
XLATEOBJ*               pxlo,
RECTL*                  prclDst,
RECTL*                  prclSrc,
ULONG                   iTransColor,
ULONG                   ulReserved)
{
    LONG    xDst;
    LONG    yDst;
    LONG    xSrc;
    LONG    ySrc;

    xSrc = pOffSrc->x;
    ySrc = pOffSrc->y;
    xDst = pOffDst->x;
    yDst = pOffDst->y;

    CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_RECTL(prclDst, xDst, yDst);
    OFFSET_RECTL(prclSrc, xSrc, ySrc);

    BOOL bRet = pfnTransparentBlt(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc,
                                  iTransColor, ulReserved);

    CLIPOBJ_vOffset(pco, -xDst, -yDst);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffDrawStream
*
* 1-27-2001 bhouse
* Wrote it.
\**************************************************************************/

BOOL OffDrawStream(
PFN_DrvDrawStream       pfnDrawStream,
POINTL*                 pOffDst,
SURFOBJ*                psoDst,
SURFOBJ*                psoSrc,
CLIPOBJ*                pco,
XLATEOBJ*               pxlo,
RECTL*                  prclDstBounds,
POINTL*                 pptlDstOffset,
ULONG                   ulIn,
PVOID                   pvIn,
DSSTATE*                pdss
)
{
    LONG    xDst;
    LONG    yDst;
    LONG    xSrc;
    LONG    ySrc;

    xDst = pOffDst->x;
    yDst = pOffDst->y;

    CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_RECTL(prclDstBounds, xDst, yDst);
    OFFSET_POINTL(pptlDstOffset, xDst, yDst);

    BOOL bRet = pfnDrawStream(psoDst, psoSrc, pco, pxlo, prclDstBounds, pptlDstOffset, ulIn, pvIn, pdss);

    CLIPOBJ_vOffset(pco, -xDst, -yDst);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffAlphaBlend
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffAlphaBlend(
PFN_DrvAlphaBlend   pfnAlphaBlend,
POINTL*             pOffDst,
SURFOBJ*            psoDst,
POINTL*             pOffSrc,
SURFOBJ*            psoSrc,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
RECTL*              prclDst,
RECTL*              prclSrc,
BLENDOBJ*           pBlendObj)
{
    LONG    xDst;
    LONG    yDst;
    LONG    xSrc;
    LONG    ySrc;

    xSrc = pOffSrc->x;
    ySrc = pOffSrc->y;
    xDst = pOffDst->x;
    yDst = pOffDst->y;

    CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_RECTL(prclDst, xDst, yDst);
    OFFSET_RECTL(prclSrc, xSrc, ySrc);

    BOOL bRet = pfnAlphaBlend(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc,
                              pBlendObj);

    CLIPOBJ_vOffset(pco, -xDst, -yDst);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffPlgBlt
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffPlgBlt(
PFN_DrvPlgBlt       pfnPlgBlt,
POINTL*             pOffDst,
SURFOBJ*            psoDst,
POINTL*             pOffSrc,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlBrush,
POINTFIX*           pptfx,
RECTL*              prcl,
POINTL*             pptlMsk,
ULONG               iMode)
{
    LONG        xDst;
    LONG        yDst;
    LONG        xSrc;
    LONG        ySrc;
    POINTFIX    aptfx[3];

    xSrc = pOffSrc->x;
    ySrc = pOffSrc->y;
    xDst = pOffDst->x;
    yDst = pOffDst->y;

    CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_POINTL(pptlBrush, xDst, yDst);
    OFFSET_RECTL(prcl, xSrc, ySrc);

    aptfx[0].x = pptfx[0].x + (xDst << 4);
    aptfx[1].x = pptfx[1].x + (xDst << 4);
    aptfx[2].x = pptfx[2].x + (xDst << 4);
    aptfx[0].y = pptfx[0].y + (yDst << 4);
    aptfx[1].y = pptfx[1].y + (yDst << 4);
    aptfx[2].y = pptfx[2].y + (yDst << 4);

    BOOL bRet = pfnPlgBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlBrush,
                          aptfx, prcl, pptlMsk, iMode);

    CLIPOBJ_vOffset(pco, -xDst, -yDst);
    ASSERT_BRUSH_ORIGIN(pptlBrush, xDst, yDst);

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vSpOrderInY
*
* Re-orders the sprite in the sorted-in-Y list.
*
* 'pSprite' must already be in the list, and all the other elements of the
* list must be properly sorted.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpOrderInY(
SPRITE* pSprite)
{
    LONG    yThis;
    SPRITE* pPrevious;
    SPRITE* pNext;

    ASSERTGDI(pSprite->pState->pListY != NULL,
        "If there's a sprite, there should be a Y-list!");

    yThis = pSprite->rclSprite.top;
    if ((pSprite->pPreviousY != NULL) &&
        (pSprite->pPreviousY->rclSprite.top > yThis))
    {
        // The sprite has to move up in the list.  First, remove
        // the sprite's node from its current position:

        pPrevious = pSprite->pPreviousY;
        pNext = pSprite->pNextY;
        pPrevious->pNextY = pNext;
        if (pNext)
            pNext->pPreviousY = pPrevious;

        // Find the sprite's proper position in the list:

        pNext = pPrevious;
        while (((pPrevious = pNext->pPreviousY) != NULL) &&
               (pPrevious->rclSprite.top > yThis))
            pNext = pPrevious;

        // Insert the sprite in its new position:

        pSprite->pPreviousY = pPrevious;
        pSprite->pNextY = pNext;
        pNext->pPreviousY = pSprite;
        if (pPrevious)
            pPrevious->pNextY = pSprite;
        else
            pSprite->pState->pListY = pSprite;
    }
    else if ((pSprite->pNextY != NULL) &&
             (pSprite->pNextY->rclSprite.top < yThis))
    {
        // The sprite has to move down in the list.  First, remove
        // the sprite's node from its current position:

        pNext = pSprite->pNextY;
        pPrevious = pSprite->pPreviousY;
        pNext->pPreviousY = pPrevious;
        if (pPrevious)
            pPrevious->pNextY = pNext;
        else
            pSprite->pState->pListY = pNext;

        // Find the sprite's proper position in the list:

        pPrevious = pNext;
        while (((pNext = pPrevious->pNextY) != NULL) &&
               (pNext->rclSprite.top < yThis))
            pPrevious = pNext;

        // Insert the sprite in its new position:

        pSprite->pPreviousY = pPrevious;
        pSprite->pNextY = pNext;
        pPrevious->pNextY = pSprite;
        if (pNext)
            pNext->pPreviousY = pSprite;
    }
}

/******************************Public*Routine******************************\
* VOID vSpComputeUncoveredRegion
*
* We construct the true RGNOBJ representing the uncovered portions of
* the screen directly from the sprite-range list.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpComputeUncoveredRegion(
SPRITESTATE*    pState)
{
    REGION* prgnUncovered;
    SIZE_T  sizt;

    // As a simple guess as to the size of the necessary region, we simply
    // use the sprite-range size:

    ASSERTGDI(sizeof(SPRITERANGE) + sizeof(SPRITESCAN) >= NULL_SCAN_SIZE,
        "Our guess will be wrong!");
    ASSERTGDI(pState->pRangeLimit > pState->pRange,
        "pRange/pRangeLimit mismatch");

    sizt = (BYTE*) pState->pRangeLimit - (BYTE*) pState->pRange;

    // Add in the size of a header, which our sprite ranges don't have:

    sizt += NULL_REGION_SIZE;

    prgnUncovered = pState->prgnUncovered;
    if (prgnUncovered->sizeObj < sizt)
    {
        // If the allocation fails, we'll simply stick with the old region
        // and draw wrong (but we won't crash):

        RGNMEMOBJ rmoNew((ULONGSIZE_T)sizt);
        if (!rmoNew.bValid())
            return;

        RGNOBJ roOld(prgnUncovered);
        roOld.vDeleteRGNOBJ();

        prgnUncovered = rmoNew.prgnGet();
        pState->prgnUncovered = prgnUncovered;
    }

    RGNOBJ roUncovered(pState->prgnUncovered);

    PDEVOBJ po(pState->hdev);

    roUncovered.vComputeUncoveredSpriteRegion(po);
    roUncovered.vTighten();

    ASSERTGDI(sizt >= roUncovered.sizeRgn(),
        "Uh oh, we overwrote the end of the region!");

    // Any DirectDraw locked areas have to be added back to the uncovered
    // area:

    if (pState->prgnUnlocked != NULL)
    {
        RGNOBJ roUnlocked(pState->prgnUnlocked);
        RGNOBJ roTmp(pState->prgnTmp);

        RGNMEMOBJTMP rmoLocked;
        if (rmoLocked.bValid())
        {
            roTmp.vSet(&pState->rclScreen);
            if (!rmoLocked.bMerge(roTmp, roUnlocked, gafjRgnOp[RGN_DIFF]))
            {
                rmoLocked.vSet();
            }
            if (!roTmp.bMerge(roUncovered, rmoLocked, gafjRgnOp[RGN_OR]))
            {
                roTmp.vSet();
            }

            pState->prgnUncovered = roTmp.prgnGet();
            pState->prgnTmp = roUncovered.prgnGet();
        }
    }

    pState->prgnUncovered->vStamp();
}

/******************************Public*Routine******************************\
* VOID vSpSetNullRange
*
* Resets the sprite range to a null area.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpSetNullRange(
SPRITESTATE*    pState,
SPRITESCAN*     pScan)  // Must be pool allocated (it will be freed later)
                        //   and at least sizeof(SPRITESCAN)
{
    pScan->yTop         = pState->rclScreen.top;
    pScan->yBottom      = pState->rclScreen.bottom;
    pScan->siztScan     = sizeof(SPRITESCAN);
    pScan->siztPrevious = 0;

    pScan->aRange[0].xLeft   = pState->rclScreen.left;
    pScan->aRange[0].xRight  = pState->rclScreen.right;
    pScan->aRange[0].pSprite = NULL;

    pState->pRange      = pScan;
    pState->pRangeLimit = pScan + 1;
}

#define BATCH_ALLOC_COUNT 20

inline SPRITERANGE* pSpRangeLimit(
SPRITESTATE*    pState)
{
    // We adjust the range limit to leave room for that extra SPRITESCAN
    // structure we allocated.  It's also VERY important that we remove a
    // SPRITERANGE structure to account for sizeof(SPRITERANGE) not
    // dividing evenly into sizeof(SPRITESCAN):

    return((SPRITERANGE*) ((BYTE*) pState->pRangeLimit
            - sizeof(SPRITESCAN) - sizeof(SPRITERANGE)));
}

/******************************Public*Routine******************************\
* SPRITERANGE* pSpGrowRanges
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

SPRITERANGE* pSpGrowRanges(
SPRITESTATE*    pState,
SPRITERANGE*    pCurrentRange,
SPRITESCAN**    ppCurrentScan,
SPRITERANGE**   ppRangeLimit)
{
    SPRITESCAN*     pNewRegion;
    SIZE_T          siztOldAlloc;
    SIZE_T          siztNewAlloc;
    SIZE_T          siztCurrentRange;
    SIZE_T          siztCurrentScan;

#if DEBUG_SPRITES
    KdPrint(("GDI: Growing sprite ranges\n"));
#endif

    // We always add in the size of a SPRITESCAN structure to allow
    // 'bSpComputeScan' to initialize it without checking:

    siztCurrentRange  = (BYTE*) pCurrentRange        - (BYTE*) pState->pRange;
    siztCurrentScan   = (BYTE*) *ppCurrentScan       - (BYTE*) pState->pRange;
    siztOldAlloc      = (BYTE*) pState->pRangeLimit - (BYTE*) pState->pRange;
    siztNewAlloc      = siztOldAlloc + sizeof(SPRITESCAN)
                      + sizeof(SPRITERANGE) * BATCH_ALLOC_COUNT;

    pNewRegion = (SPRITESCAN*) PALLOCNOZ((ULONGSIZE_T)siztNewAlloc, 'rpsG');
    if (pNewRegion == NULL)
    {
        vSpSetNullRange(pState, pState->pRange);

        // Should we mark every sprite as invisible?

        return(NULL);
    }

    RtlCopyMemory(pNewRegion, pState->pRange, siztCurrentRange);

    VFREEMEM(pState->pRange);

    pState->pRange      = pNewRegion;
    pState->pRangeLimit = (BYTE*) pNewRegion + siztNewAlloc;

    *ppCurrentScan  = (SPRITESCAN*)  ((BYTE*) pNewRegion + siztCurrentScan);
    *ppRangeLimit   = pSpRangeLimit(pState);

    return((SPRITERANGE*) ((BYTE*) pNewRegion + siztCurrentRange));
}

/******************************Public*Routine******************************\
* BOOL bSpComputeScan
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpComputeScan(
SPRITESTATE*    pState,
SPRITE*         pActiveList,
LONG            yTop,
LONG            yBottom,
SPRITESCAN**    ppScan,
SIZE_T*         psiztPrevious)
{
    SPRITESCAN*     pScan;
    SPRITERANGE*    pRange;
    SPRITERANGE*    pRangeLimit;
    SPRITERANGE*    pTmp;
    SPRITE*         pSprite;
    LONG            xLeft;
    LONG            xRight;
    LONG            xFinalRight;
    LONG            cSprites;

    ASSERTGDI(yTop < yBottom, "Invalid empty row");

    xLeft       = pState->rclScreen.left;
    xRight      = pState->rclScreen.right;
    xFinalRight = pState->rclScreen.right;

    pScan = *ppScan;

    pScan->yTop         = yTop;
    pScan->yBottom      = yBottom;
    pScan->siztPrevious = *psiztPrevious;

    pRangeLimit = pSpRangeLimit(pState);
    pRange      = &pScan->aRange[0];

    // Note that we always adjust 'pRangeLimit' to leave room for a
    // SPRITESCAN structure:

    ASSERTGDI((pScan >= (SPRITESCAN*) pState->pRange) &&
              (pScan + 1 <= (SPRITESCAN*) pState->pRangeLimit),
        "pScan will overwrite buffer end!");
    ASSERTGDI(pState->pRange < pState->pRangeLimit,
        "pRange/pRangeLimit mismatch");

    do {
        cSprites = 0;
        for (pSprite = pActiveList;
             pSprite != NULL;
             pSprite = pSprite->pNextActive)
        {
            ASSERTGDI((pSprite != NULL) &&
                      (pSprite->rclSprite.top <= yTop) &&
                      (pSprite->rclSprite.bottom >= yBottom) &&
                      (pSprite->rclSprite.left < pSprite->rclSprite.right) &&
                      (pSprite->rclSprite.top < pSprite->rclSprite.bottom),
                "Invalid active list");

            if (pSprite->rclSprite.left <= xLeft)
            {
                if (pSprite->rclSprite.right > xLeft)
                {
                    cSprites++;

                    // Add this sprite:

                    if (pRange >= pRangeLimit)
                    {
                        pRange = pSpGrowRanges(pState,
                                               pRange,
                                               &pScan,
                                               &pRangeLimit);
                        if (!pRange)
                            return(FALSE);
                    }

                    pRange->pSprite = pSprite;
                    pRange++;

                    if (pSprite->rclSprite.right <= xRight)
                        xRight = pSprite->rclSprite.right;
                }
            }
            else if (pSprite->rclSprite.left <= xRight)
            {
                xRight = pSprite->rclSprite.left;
            }
        }

        if (cSprites == 0)
        {
            if (pRange >= pRangeLimit)
            {
                pRange = pSpGrowRanges(pState, pRange, &pScan, &pRangeLimit);
                if (!pRange)
                    return(FALSE);
            }

            pRange->pSprite = NULL;
            pRange->xLeft   = xLeft;
            pRange->xRight  = xRight;
            pRange++;
        }
        else
        {
            // Now, fill in the wall values for every range we just
            // put down:

            pTmp = pRange;
            do {
                pTmp--;
                pTmp->xLeft = xLeft;
                pTmp->xRight = xRight;

            } while (--cSprites != 0);
        }

        // Advance to the next rectangle in this scan:

        xLeft  = xRight;
        xRight = xFinalRight;

    } while (xLeft < xRight);

    pScan->siztScan = (BYTE*) pRange - (BYTE*) pScan;
    *psiztPrevious  = pScan->siztScan;
    *ppScan         = (SPRITESCAN*) pRange;

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL vSpComputeSpriteRanges
*
* Recalculates the 'range' list that describes how the overlays overlap
* the screen.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpComputeSpriteRanges(
SPRITESTATE* pState)
{
    SPRITE*     pPrevious;
    SPRITE*     pNext;
    SPRITE*     pThis;
    SPRITE*     pSpriteY;
    BOOL        bSprite;
    SPRITE      ActiveHead;
    LONG        yTop;
    LONG        yBottom;
    LONG        yFinalBottom;
    SPRITESCAN* pCurrentScan;
    SIZE_T      siztPrevious;

    ASSERTGDI(!(pState->bValidRange),
        "Should be called only when dirty.");

    pCurrentScan = pState->pRange;
    siztPrevious = 0;

    ActiveHead.pNextActive = NULL;

    yTop         = pState->rclScreen.top;
    yBottom      = pState->rclScreen.bottom;
    yFinalBottom = pState->rclScreen.bottom;

    // First, skip over any invisible sprites:

    pSpriteY = pState->pListY;
    while ((pSpriteY != NULL) && (pSpriteY->rclSprite.bottom <= yTop))
        pSpriteY = pSpriteY->pNextY;

    do {
        // Prune the active list, throwing out anyone whose bottom
        // matches the previous row's bottom, and at the same time
        // compute the new bottom:

        pPrevious = &ActiveHead;
        while ((pThis = pPrevious->pNextActive) != NULL)
        {
            if (pThis->rclSprite.bottom == yTop)
            {
                pPrevious->pNextActive = pThis->pNextActive;
            }
            else
            {
                if (pThis->rclSprite.bottom <= yBottom)
                    yBottom = pThis->rclSprite.bottom;

                // Advance to next node:

                pPrevious = pThis;
            }
        }

        // Add to the active list any sprites that have a 'top'
        // value equal to the new top, watching out for a new
        // 'bottom' value:

        while (pSpriteY != NULL)
        {
            if (pSpriteY->rclSprite.top != yTop)
            {
                // Any not-yet-used sprites may affect the height of
                // this row:

                if (pSpriteY->rclSprite.top <= yBottom)
                    yBottom = pSpriteY->rclSprite.top;

                break;                          // =======>
            }

            // The active list is kept in back-to-front z-order:

            pNext = &ActiveHead;
            do {
                pPrevious = pNext;
                pNext = pPrevious->pNextActive;
            } while ((pNext != NULL) && (pNext->z < pSpriteY->z));

            pPrevious->pNextActive = pSpriteY;
            pSpriteY->pNextActive = pNext;

            if (pSpriteY->rclSprite.bottom <= yBottom)
                yBottom = pSpriteY->rclSprite.bottom;

            pSpriteY = pSpriteY->pNextY;
        }

        // Now, use the active-list to compute the new row:

        if (!bSpComputeScan(pState,
                            ActiveHead.pNextActive,
                            yTop,
                            yBottom,
                            &pCurrentScan,
                            &siztPrevious))
        {
            // In case of failure, 'bSpComputeScan' leaves the structure
            // empty but consistent, so we can safely just leave:

            return;
        }

        // Advance to the next row:

        yTop    = yBottom;
        yBottom = yFinalBottom;

    } while (yTop < yBottom);

    // The range cache is now valid:

    pState->bValidRange = TRUE;

    // Finally, use the sprite range to compute a true region representing
    // the uncovered parts:

    vSpComputeUncoveredRegion(pState);
}

/******************************Public*Routine******************************\
* ENUMAREAS::ENUMAREAS
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ENUMAREAS::ENUMAREAS(
SPRITESTATE*    pState,
RECTL*          prclBounds,       // Must be pre-clipped to screen
ULONG           iDirection)       // CD_RIGHTDOWN is the default
{
    LONG            yStart;
    SPRITESCAN*     pTmpScan;
    SPRITERANGE*    pTmpRange;

    if (!pState->bValidRange)
    {
        vSpComputeSpriteRanges(pState);
    }
    bValidRange = pState->bValidRange; // valid only if the sprite range
                                       // computation succeeded

    // BUGFIX #22140 2-18-2000 bhouse
    // We will just leave this assertion code commented out for now.  If we
    // ever have a bug causing us to fix the how we calculate the bounds
    // in BLTRECORD__bRotate then perhaps we can un-comment out these
    // lines.
    // ASSERTGDI((prclBounds->left   >= pState->rclScreen.left)   &&
    //           (prclBounds->top    >= pState->rclScreen.top)),
    //           "invalid rectangle");

    ASSERTGDI((prclBounds->right  <= pState->rclScreen.right)  &&
              (prclBounds->bottom <= pState->rclScreen.bottom) &&
              (prclBounds->left   < prclBounds->right)         &&
              (prclBounds->top    < prclBounds->bottom),
        "Invalid rectangle specified");

    iDir          = iDirection;
    xBoundsLeft   = prclBounds->left;
    xBoundsRight  = prclBounds->right;
    yBoundsTop    = prclBounds->top;
    yBoundsBottom = prclBounds->bottom;

    // Find the first scan that contains the start 'y' value:

    yStart = (iDirection & 2) ? (yBoundsBottom - 1) : (yBoundsTop);
    pTmpScan = pState->pRange;
    while (pTmpScan->yBottom <= yStart)
        pTmpScan = pSpNextScan(pTmpScan);

    // If more than one sprite overlaps a region, there will be
    // multiple sprite-range records for the same area.  When
    // going left-to-right, we should leave 'pTmpRange' pointing to
    // the start of this sequence; when going right-to-left, we
    // should leave 'pTmpRange' pointing to the end of this sequence.

    if ((iDirection & 1) == 0)          // Left-to-right
    {
        pTmpRange = &pTmpScan->aRange[0];
        while (pTmpRange->xRight <= xBoundsLeft)
            pTmpRange++;
    }
    else                                // Right-to-left
    {
        pTmpRange = pSpLastRange(pTmpScan);
        while (pTmpRange->xLeft >= xBoundsRight)
            pTmpRange--;
    }

    yTop    = max(pTmpScan->yTop,    yBoundsTop);
    yBottom = min(pTmpScan->yBottom, yBoundsBottom);

    // We used temporary variables as opposed to the structure members
    // directly so that the compiler would be more efficient:

    pScan = pTmpScan;
    pRange = pTmpRange;
}

/******************************Public*Routine******************************\
* BOOL ENUMAREAS::bEnum
*
* This routine enumerates the list of sprite and non-sprite ranges
* comprising a rectangular area on the screen.  If two sprites overlap,
* for the overlapping rectangle this routine will always return the
* bottom-most sprite.
*
* Returns TRUE if more ranges after this remain to be enumerated.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL ENUMAREAS::bEnum(
SPRITE**    ppSprite,       // Returns touched sprite.  This will be NULL
                            //   if the enumerated area is touched by
                            //   no sprite
RECTL*      prclSprite)     // Returns area of sprite touched
{
    SPRITESCAN*     pTmpScan;
    SPRITERANGE*    pTmpRange;

    // Use local variables where possible to be more efficient in our
    // inner loops:

    pTmpRange = pRange;

    // Remember some state for enumerating the layers:

    pRangeLayer = pTmpRange;
    pScanLayer = pScan;

    // Fill in details about the current range:

    *ppSprite = pTmpRange->pSprite;

    prclSprite->left   = max(pTmpRange->xLeft,  xBoundsLeft);
    prclSprite->right  = min(pTmpRange->xRight, xBoundsRight);
    prclSprite->top    = yTop;
    prclSprite->bottom = yBottom;

    ASSERTGDI((prclSprite->left < prclSprite->right) &&
              (prclSprite->top < prclSprite->bottom),
            "Invalid return rectangle");
    ASSERTGDI((*ppSprite == NULL) ||
              (((*ppSprite)->rclSprite.left   <= prclSprite->left)  &&
               ((*ppSprite)->rclSprite.top    <= prclSprite->top)   &&
               ((*ppSprite)->rclSprite.right  >= prclSprite->right) &&
               ((*ppSprite)->rclSprite.bottom >= prclSprite->bottom)),
            "Invalid return sprite");

    if ((iDir & 1) == 0)            // Left-to-right
    {
        if (pTmpRange->xRight < xBoundsRight)
        {
            do {
                pTmpRange++;
            } while ((pTmpRange - 1)->xLeft == pTmpRange->xLeft);
        }
        else
        {
            pTmpScan = pScan;

            if (iDir == CD_RIGHTDOWN)
            {
                if (pTmpScan->yBottom >= yBoundsBottom)
                    return(FALSE);

                pTmpScan = pSpNextScan(pTmpScan);
            }
            else
            {
                ASSERTGDI(iDir == CD_RIGHTUP, "Unexpected iDir");

                if (pTmpScan->yTop <= yBoundsTop)
                    return(FALSE);

                pTmpScan = pSpPreviousScan(pTmpScan);
            }

            pScan = pTmpScan;

            yTop      = max(pTmpScan->yTop,    yBoundsTop);
            yBottom   = min(pTmpScan->yBottom, yBoundsBottom);
            pTmpRange = &pTmpScan->aRange[0];

            while (pTmpRange->xRight <= xBoundsLeft)
                pTmpRange++;
        }
    }
    else                            // Right-to-left
    {
        if (pTmpRange->xLeft > xBoundsLeft)
        {
            do {
                pTmpRange--;
            } while ((pTmpRange + 1)->xLeft == pTmpRange->xLeft);
        }
        else
        {
            pTmpScan = pScan;

            if (iDir == CD_LEFTDOWN)
            {
                if (pTmpScan->yBottom >= yBoundsBottom)
                    return(FALSE);

                pTmpScan = pSpNextScan(pTmpScan);
            }
            else
            {
                ASSERTGDI(iDir == CD_LEFTUP, "Unexpected iDir");

                if (pTmpScan->yTop <= yBoundsTop)
                    return(FALSE);

                pTmpScan = pSpPreviousScan(pTmpScan);
            }

            pScan = pTmpScan;

            yTop      = max(pTmpScan->yTop,    yBoundsTop);
            yBottom   = min(pTmpScan->yBottom, yBoundsBottom);
            pTmpRange = pSpLastRange(pTmpScan);

            while (pTmpRange->xLeft >= xBoundsRight)
                pTmpRange--;
        }
    }

    pRange = pTmpRange;
    return(TRUE);
}

/******************************Public*Routine******************************\
* ENUMUNCOVERED::ENUMUNCOVERED
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ENUMUNCOVERED::ENUMUNCOVERED(
SPRITESTATE* pState)
{
    if (!pState->bValidRange)
    {
        vSpComputeSpriteRanges(pState);
    }

    yBoundsBottom = pState->rclScreen.bottom;
    pScan = pState->pRange;
    pRange = &pScan->aRange[0] - 1;
    pNextScan = pSpNextScan(pScan);
}

/******************************Public*Routine******************************\
* BOOL ENUMUNCOVERED::bEnum
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL ENUMUNCOVERED::bEnum(
RECTL* prclUncovered)
{
    SPRITESCAN*  pTmpScan  = pScan;
    SPRITERANGE* pTmpRange = pRange;

    do {
        pTmpRange++;
        if (pTmpRange >= (SPRITERANGE*) pNextScan)
        {
            if (pTmpScan->yBottom >= yBoundsBottom)
                return(FALSE);

            pTmpScan  = pNextScan;
            pNextScan = pSpNextScan(pNextScan);
            pTmpRange = &pTmpScan->aRange[0];
        }
    } while (pTmpRange->pSprite != NULL);

    prclUncovered->top    = pTmpScan->yTop;
    prclUncovered->bottom = pTmpScan->yBottom;
    prclUncovered->left   = pTmpRange->xLeft;
    prclUncovered->right  = pTmpRange->xRight;

    pScan  = pTmpScan;
    pRange = pTmpRange;

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL ENUMAREAS::bEnumLayers
*
* This routine may be called only after 'bEnum' is called, and lists
* the sprites that overlay the 'bEnum' rectangle, bottom-most to top-most.
*
* Returns TRUE if the returned 'ppSprite' is a valid layer.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL ENUMAREAS::bEnumLayers(
SPRITE**    ppSprite)
{
    BOOL bRet = FALSE;

    if ((iDir & 1) == 0)            // Left-to-right
    {
        if ((pRangeLayer < pSpLastRange(pScanLayer)) &&
            ((pRangeLayer + 1)->xLeft == pRangeLayer->xLeft))
        {
            pRangeLayer++;
            bRet = TRUE;
        }
    }
    else                            // Right-to-left
    {
        if ((pRangeLayer > &pScanLayer->aRange[0]) &&
            ((pRangeLayer - 1)->xLeft == pRangeLayer->xLeft))
        {
            pRangeLayer--;
            bRet = TRUE;
        }
    }

    *ppSprite = pRangeLayer->pSprite;
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL ENUMAREAS::bAdvanceToTopMostOpaqueLayer
*
* This routine may be called only after 'bEnum' is called, and advances
* to the top-most, unclipped opaque layer for this range.
*
* Returns TRUE if there was an opaque layer; FALSE if not.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL ENUMAREAS::bAdvanceToTopMostOpaqueLayer(
SPRITE**    ppSprite)
{
    SPRITERANGE*    pThis;
    SPRITERANGE*    pLast;
    SPRITERANGE*    pOpaque;
    SPRITE*         pSprite;
    REGION*         prgnClip;
    BOOL            bRet;

    ASSERTGDI((iDir & 1) == 0, "Can use only when enumerating left-to-right");

    pLast   = pSpLastRange(pScanLayer);
    pThis   = pRangeLayer;
    pOpaque = NULL;

    // We can't do the opaque trick if any WNDOBJs are present on the screen,
    // because we rely on the background repainting to refresh any sprites
    // unveiled when a WNDOBJ moves.

    if (gpto != NULL)
    {
        while (TRUE)
        {
            pSprite = pThis->pSprite;
            if (pSprite->fl & SPRITE_FLAG_EFFECTIVELY_OPAQUE)
            {
                // Do a quick check to make sure this opaque sprite isn't
                // clipped for this range.

                prgnClip = pSprite->prgnClip;
                if ((prgnClip == NULL) ||
                    ((prgnClip->sizeRgn <= SINGLE_REGION_SIZE) &&
                     (prgnClip->rcl.left   <= pThis->xLeft)    &&
                     (prgnClip->rcl.right  >= pThis->xRight)   &&
                     (prgnClip->rcl.top    <= yTop)            &&
                     (prgnClip->rcl.bottom >= yBottom)))
                {
                    pOpaque = pThis;
                }
            }

            if ((pThis >= pLast) || ((pThis + 1)->xLeft != pThis->xLeft))
                break;

            pThis++;
        }
    }

    bRet = FALSE;
    if (pOpaque)
    {
        pRangeLayer = pOpaque;
        bRet = TRUE;
    }

    *ppSprite = pRangeLayer->pSprite;
    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vSpReadFromScreen
*
* All reads from the screen should be routed through this call so that
* we can:
*
*   1.  Exclude any DirectDraw locked regions;
*   2.  Respect any WNDOBJ boundaries.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpReadFromScreen(
SPRITESTATE*    pState,
POINTL*         pOffDst,
SURFOBJ*        psoDst,
RECTL*          prclDst)
{
    ECLIPOBJ    ecoUnlocked;
    ECLIPOBJ*   pcoUnlocked;

    pcoUnlocked = NULL;
    if (pState->prgnUnlocked != NULL)
    {
        ecoUnlocked.vSetup(pState->prgnUnlocked, *(ERECTL*)prclDst);
        if (ecoUnlocked.erclExclude().bEmpty())
            return;             // ======>

        pcoUnlocked = &ecoUnlocked;
    }

    XLATEOBJ* pxlo     = NULL;
    SURFOBJ*  psoSrc   = pState->psoScreen;
    PSURFACE  pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);
    EXLATEOBJ xloParent;
    POINTL*   pOffSrc  = &gptlZero;

    PFN_DrvCopyBits pfnCopyBits;

    PDEVOBJ pdoSrc(pSurfSrc->hdev());

    // If source is mirror driver, redirect the call to DDML.

    if (pSurfSrc->bMirrorSurface() &&
        (pdoSrc.hdev() != pdoSrc.hdevParent()))
    {
        pOffSrc = pdoSrc.pptlOrigin();
        PDEVOBJ pdoParent(pdoSrc.hdevParent());
        SURFREF srParent((HSURF)pSurfSrc->hMirrorParent);
        if (!srParent.bValid()) return;
        if (xloParent.bInitXlateObj(
                      NULL,DC_ICM_OFF,
                      pdoParent.ppalSurf(), pdoSrc.ppalSurf(),
                      ppalDefault, ppalDefault,
                      0L,0L,0L, XLATE_USE_SURFACE_PAL))
            pxlo = xloParent.pxlo();
        else
            return;

        psoSrc      = srParent.ps->pSurfobj();
        pfnCopyBits = PPFNDRV(pdoParent, CopyBits);
    }
    else if (!(SURFOBJ_TO_SURFACE_NOT_NULL(psoDst)->flags() & HOOK_CopyBits) &&
              (psoSrc->hdev))
    {
        pfnCopyBits = PPFNDIRECT(psoSrc, CopyBits);
    }
    else
    {
        pfnCopyBits = PPFNDIRECT(psoDst, CopyBits);
    }

    // WINBUG #440135 10-02-2001 kchiu  
    // Instead of always passing &gptlZero for pOffSrc. We now pass in pdoSrc->pptlOrigin() whenever 
    // the source is mirror driver. We do this for mirror driver only and not for secondary drivers 
    // with non-zero origin because the coords are already offset correctly in the case of a secondary 
    // driver, but not in the case of the mirror driver.  
    
    OffCopyBits(pfnCopyBits,
                pOffDst,
                psoDst,
                pOffSrc,
                psoSrc,
                pcoUnlocked,
                pxlo,
                prclDst,
                (POINTL*) prclDst);
}

/******************************Public*Routine******************************\
* VOID vSpWriteToScreen
*
* All writes to the screen should be routed through this call so that
* we can:
*
*   1.  Exclude any DirectDraw locked regions;
*   2.  Respect any WNDOBJ boundaries.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpWriteToScreen(
SPRITESTATE*    pState,
POINTL*         pOffSrc,
SURFOBJ*        psoSrc,
RECTL*          prclSrc)
{
    GDIFunctionID(vSpWriteToScreen);

    ECLIPOBJ    ecoUnlocked;
    ECLIPOBJ*   pcoUnlocked;

    pcoUnlocked = NULL;
    if (pState->prgnUnlocked != NULL)
    {
        ecoUnlocked.vSetup(pState->prgnUnlocked, *(ERECTL*)prclSrc);
        if (ecoUnlocked.erclExclude().bEmpty())
            return;             // ======>

        pcoUnlocked = &ecoUnlocked;
    }

    // Mark the source surface to indicate that it shouldn't be cached,
    // as it's pretty much guaranteed that we won't be blting the bitmap
    // with exactly the same contents again.
    //
    // Note that this has to be in addition to any BMF_DONTCACHE flag
    // that might have been set, as the TShare driver ignores the
    // BMF_DONTCACHE flag.

    psoSrc->iUniq = 0;

    ASSERTGDI((pState->psoScreen->iType == pState->iOriginalType) &&
              (SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen)->flags() == pState->flOriginalSurfFlags),
              "Writing to screen without restoring orignal surface settings.");

    OFFCOPYBITS(&gptlZero,
                pState->psoScreen,
                pOffSrc,
                psoSrc,
                pcoUnlocked,
                NULL,
                prclSrc,
                (POINTL*) prclSrc);
}

/******************************Public*Routine******************************\
* VOID vSpDrawCursor
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDrawCursor(
SPRITE*     pSprite,
POINTL*     pOffComposite,
SURFOBJ*    psoComposite,
RECTL*      prclEnum,
POINTL*     pptlSrc)
{
    SPRITESTATE*    pState;
    POINTL          ptlSrc;
    SURFOBJ*        psoShape;
    POINTL*         pOffShape;
    XLATEOBJ*       pxlo;

    // A NULL mask means that the shape couldn't be allocated:

    if (pSprite->psoMask == NULL)
        return;

    pState = pSprite->pState;

    EXLATEOBJ xloMono;
    XEPALOBJ  palMono(ppalMono);
    XEPALOBJ  palScreen(SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen)->ppal());
    XEPALOBJ  palDefault(ppalDefault);

    // The XLATEOBJ should always be in the cache, so this should be pretty
    // cheap most of the time:

    if (xloMono.bInitXlateObj(NULL, DC_ICM_OFF, palMono, palScreen, palDefault,
                              palDefault, 0, 0xffffff, 0))
    {
        OFFBITBLT(pOffComposite, psoComposite, &gptlZero, pSprite->psoMask,
                  NULL, NULL, xloMono.pxlo(), prclEnum, pptlSrc, NULL,
                  NULL, NULL, 0x8888);      // SRCAND

        if (pSprite->psoShape == NULL)
        {
            ptlSrc.x  = pptlSrc->x;
            ptlSrc.y  = pptlSrc->y + (pSprite->psoMask->sizlBitmap.cy >> 1);
            psoShape  = pSprite->psoMask;
            pOffShape = &gptlZero;
            pxlo      = xloMono.pxlo();
        }
        else
        {
            ptlSrc.x  = pptlSrc->x;
            ptlSrc.y  = pptlSrc->y;
            psoShape  = pSprite->psoShape;
            pOffShape = &pSprite->OffShape;
            pxlo      = NULL;
        }

        OFFBITBLT(pOffComposite, psoComposite, pOffShape, psoShape, NULL,
                  NULL, pxlo, prclEnum, &ptlSrc, NULL, NULL, NULL,
                  0x6666);      // SRCINVERT
    }
}

/******************************Public*Routine******************************\
* VOID vSpComposite
*
* Draws the specified sprite into the composition buffer.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpComposite(
SPRITE*     pSprite,
POINTL*     pOffComposite,
SURFOBJ*    psoComposite,
RECTL*      prclEnum)
{
    SPRITESTATE*    pState;
    POINTL          ptlSrc;
    CLIPOBJ*        pco;
    DWORD           dwShape;
    ECLIPOBJ        ecoClip;
    CLIPOBJ*        pcoClip;
    SURFOBJ*        psoNull = NULL;

    // First, calculate the clipping:

    pcoClip = NULL;
    if (pSprite->prgnClip != NULL)
    {
        pcoClip = &ecoClip;

        ecoClip.vSetup(pSprite->prgnClip, *((ERECTL*) prclEnum));

        if ((ecoClip.rclBounds.left >= ecoClip.rclBounds.right) ||
            (ecoClip.rclBounds.top >= ecoClip.rclBounds.bottom))
        {
            // It's completely clipped, so we're outta here:

            return;
        }
    }

    pState = pSprite->pState;

    ASSERTGDI(pState->bInsideDriverCall, "Must have sprite lock");

    dwShape = pSprite->dwShape;
    if (pSprite->fl & SPRITE_FLAG_EFFECTIVELY_OPAQUE)
        dwShape = ULW_OPAQUE;

    ptlSrc.x = pSprite->rclSrc.left + (prclEnum->left - pSprite->ptlDst.x);
    ptlSrc.y = pSprite->rclSrc.top  + (prclEnum->top - pSprite->ptlDst.y);

    XEPALOBJ palScreen(SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen)->ppal());
    XEPALOBJ palSprite(pSprite->ppalShape);
    XEPALOBJ palDefault(ppalDefault);
    XEPALOBJ palRGB(gppalRGB);
    EXLATEOBJ xloSpriteToDst;

    // If the current color depth is the same as the color depth in which
    // the sprite was originally created, we don't need an XLATEOBJ.
    // Otherwise, create one now:

    if (((pSprite->iModeFormat == pState->iModeFormat) &&
         (pSprite->flModeMasks == pState->flModeMasks)) ||
        (xloSpriteToDst.bInitXlateObj(NULL, DC_ICM_OFF, palSprite, palScreen,
                                      palDefault, palDefault, 0, 0, 0)))
    {
        if (dwShape != ULW_ALPHA)
        {
            if (dwShape == ULW_OPAQUE)
            {
                if (pSprite->psoShape)
                {
                    OFFCOPYBITS(pOffComposite,
                                psoComposite,
                                &pSprite->OffShape,
                                pSprite->psoShape,
                                pcoClip,
                                xloSpriteToDst.pxlo(),
                                prclEnum,
                                &ptlSrc);
                }
            }
            else if (dwShape == ULW_COLORKEY)
            {
                if (pSprite->psoShape)
                {
                    ERECTL rclSrc(ptlSrc.x,
                                  ptlSrc.y,
                                  ptlSrc.x + (prclEnum->right - prclEnum->left),
                                  ptlSrc.y + (prclEnum->bottom - prclEnum->top));

                    OffTransparentBlt(PPFNDIRECT(psoComposite, TransparentBlt),
                                  pOffComposite,
                                  psoComposite,
                                  &pSprite->OffShape,
                                  pSprite->psoShape,
                                  pcoClip,
                                  xloSpriteToDst.pxlo(),
                                  prclEnum,
                                  &rclSrc,
                                  pSprite->iTransparent,
                                  0);
                }
            }
            else if (dwShape == ULW_CURSOR)
            {
                vSpDrawCursor(pSprite,
                              pOffComposite,
                              psoComposite,
                              prclEnum,
                              &ptlSrc);
            }
            else
            {
                ASSERTGDI(dwShape == ULW_DRAGRECT, "Unexpected shape");

                PDEVOBJ po(pState->hdev);

                OFFBITBLT(pOffComposite, psoComposite, NULL, psoNull, NULL, NULL,
                          NULL, prclEnum, NULL, NULL, po.pbo(), &gptlZero,
                          0x5a5a);
            }
        }
        else
        {
            ASSERTGDI(dwShape == ULW_ALPHA, "Unexpected case");

            if (pSprite->psoShape)
            {
                EBLENDOBJ eBlendObj;
                EXLATEOBJ xloSpriteTo32;
                EXLATEOBJ xloScreenTo32;
                EXLATEOBJ xlo32ToScreen;

                ERECTL rclSrc(ptlSrc.x,
                              ptlSrc.y,
                              ptlSrc.x + (prclEnum->right - prclEnum->left),
                              ptlSrc.y + (prclEnum->bottom - prclEnum->top));

                if ((xloSpriteTo32.bInitXlateObj(NULL, DC_ICM_OFF, palSprite, palRGB,
                                                 palDefault, palDefault, 0, 0, 0)) &&
                    (xloScreenTo32.bInitXlateObj(NULL, DC_ICM_OFF, palScreen, palRGB,
                                                 palDefault, palDefault, 0, 0, 0)) &&
                    (xlo32ToScreen.bInitXlateObj(NULL, DC_ICM_OFF, palRGB, palScreen,
                                                 palDefault, palDefault, 0, 0, 0)))
                {
                    eBlendObj.BlendFunction = pSprite->BlendFunction;
                    eBlendObj.pxloSrcTo32   = xloSpriteTo32.pxlo();
                    eBlendObj.pxloDstTo32   = xloScreenTo32.pxlo();
                    eBlendObj.pxlo32ToDst   = xlo32ToScreen.pxlo();

                    OffAlphaBlend(PPFNDIRECT(psoComposite, AlphaBlend),
                                  pOffComposite,
                                  psoComposite,
                                  &pSprite->OffShape,
                                  pSprite->psoShape,
                                  pcoClip,
                                  xloSpriteToDst.pxlo(),
                                  prclEnum,
                                  &rclSrc,
                                  &eBlendObj);
                }
            }
        }
    }
}

/******************************Public*Routine******************************\
* SURFOBJ* psoSpGetComposite
*
* Returns a surface to be used for compositing.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

SURFOBJ* psoSpGetComposite(
SPRITESTATE*    pState,
RECTL*          prcl)
{
    SURFOBJ*    psoComposite;
    LONG        cxMax;
    LONG        cyMax;
    LONG        cMaxArea;
    LONG        cx;
    LONG        cy;
    LONG        cArea;
    BOOL        bWantSystemMemory;
    SPRITE*     pSprite;
    SPRITE*     pBiggest;

    psoComposite = pState->psoComposite;
    if ((psoComposite == NULL) ||
        (psoComposite->sizlBitmap.cx < (prcl->right - prcl->left)) ||
        (psoComposite->sizlBitmap.cy < (prcl->bottom - prcl->top)))
    {
        vSpDeleteSurface(psoComposite); // Handles NULL case

        cMaxArea = 0;
        cxMax    = 0;
        cyMax    = 0;

        // Find the minimum dimensions needed to accomodate every sprite:

        for (pSprite = pState->pListZ;
             pSprite != NULL;
             pSprite = pSprite->pNextZ)
        {
            cx = pSprite->rclSprite.right - pSprite->rclSprite.left;
            if (cx > cxMax)
                cxMax = cx;

            cy = pSprite->rclSprite.bottom - pSprite->rclSprite.top;
            if (cy > cyMax)
                cyMax = cy;

            cArea = cx * cy;
            if (cArea > cMaxArea)
            {
                cMaxArea = cArea;
                pBiggest = pSprite;
            }
        }

        ASSERTGDI((cxMax > 0) && (cyMax > 0), "Expected a non-zero sprite");

        bWantSystemMemory = FALSE;
        if (pBiggest->dwShape == ULW_ALPHA)
        {
            PDEVOBJ po(pState->hdev);

            if (pBiggest->BlendFunction.AlphaFormat & AC_SRC_ALPHA)
            {
                if (!(po.flAccelerated() & ACCELERATED_PIXEL_ALPHA))
                {
                    bWantSystemMemory = TRUE;
                }
            }
            else
            {
                if (!(po.flAccelerated() & ACCELERATED_CONSTANT_ALPHA))
                {
                    bWantSystemMemory = TRUE;
                }
            }
        }

        // The compositing surface should always be in video-memory, unless
        // there is a big alpha sprite somewhere, and the hardware doesn't
        // accelerate alpha:

        psoComposite = psoSpCreateSurface(pState,
                                          0,
                                          cxMax,
                                          cyMax,
                                          bWantSystemMemory);

    #if DEBUG_SPRITES
        KdPrint(("psoComposite: %p\n", psoComposite));
    #endif

        pState->psoComposite = psoComposite;

        // Mark the surface as uncacheable, so that we won't pollute the
        // cache of the TShare driver, and the like:

        if (psoComposite != NULL)
        {
            psoComposite->fjBitmap |= BMF_DONTCACHE;

            // BMF_SPRITE appears to be unused.  We are temporarily removing
            // support to see if 3DLabs complains.
            // psoComposite->fjBitmap |= BMF_SPRITE;
        }
}

    return(psoComposite);
}

/******************************Public*Routine******************************\
* VOID vSpRedrawArea
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpRedrawArea(
SPRITESTATE*    pState,
RECTL*          prclBounds,
BOOL            bMustRedraw = FALSE)
{
    SPRITE*     pSprite;
    RECTL       rclEnum;
    SURFOBJ*    psoComposite;
    POINTL      OffComposite;
    BOOL        bMore;
    BOOL        hHasOpaqueLayer;

    PDEVOBJ po(pState->hdev);
    if (po.bDisabled())
        return;

    ASSERTGDI(pState->bInsideDriverCall, "Must have sprite lock");

    ENUMAREAS Enum(pState, prclBounds);

    do {
        bMore = Enum.bEnum(&pSprite, &rclEnum);

        ASSERTGDI((rclEnum.left   >= pState->rclScreen.left)  &&
                  (rclEnum.top    >= pState->rclScreen.top)   &&
                  (rclEnum.right  <= pState->rclScreen.right) &&
                  (rclEnum.bottom <= pState->rclScreen.bottom),
            "Enumerated rectangle exceeds screen bounds");

        if (pSprite != NULL)
        {
            // We always draw bottom-to-top, but we don't have to
            // bother drawing any layers that are below the top-most
            // opaque layer:

            hHasOpaqueLayer = Enum.bAdvanceToTopMostOpaqueLayer(&pSprite);

            // If something was drawn under this layer region, and
            // there was any opaque layer, we can early-out because
            // we know we won't have to update the screen:

            if ((!hHasOpaqueLayer) || (bMustRedraw))
            {
                // Create the compositing surface:

                psoComposite = psoSpGetComposite(pState, &rclEnum);
                if (psoComposite == NULL)
                    return;                             // ======>

                // Set the composite buffer's origin for ease of use:

                OffComposite.x = -rclEnum.left;
                OffComposite.y = -rclEnum.top;

                // Okay, we have to do things the slow way.  First, copy
                // the underlay to the composite buffer:

                OFFCOPYBITS(&OffComposite,
                            psoComposite,
                            &pSprite->OffUnderlay,
                            pSprite->psoUnderlay,
                            NULL,
                            NULL,
                            &rclEnum,
                            (POINTL*) &rclEnum);

                // Now composite each sprite:

                do {
                    vSpComposite(pSprite,
                                 &OffComposite,
                                 psoComposite,
                                 &rclEnum);

                } while (Enum.bEnumLayers(&pSprite));

                // Now copy the final composited result back to the screen:

                vSpWriteToScreen(pState,
                                 &OffComposite,
                                 psoComposite,
                                 &rclEnum);
            }
        }
    } while (bMore);
}

/******************************Public*Routine******************************\
* SPRITE* pSpFindInZ
*
* Finds the next sprite in the list that intersects with the specified
* rectangle.
*
* This function's entire raison d'etre is for speed.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

SPRITE* FASTCALL pSpFindInZ(
SPRITE* pSprite,
RECTL*  prcl)
{
    LONG xLeft   = prcl->left;
    LONG yTop    = prcl->top;
    LONG xRight  = prcl->right;
    LONG yBottom = prcl->bottom;

    while (pSprite != NULL)
    {
        if ((pSprite->rclSprite.left   < xRight)  &&
            (pSprite->rclSprite.top    < yBottom) &&
            (pSprite->rclSprite.right  > xLeft)   &&
            (pSprite->rclSprite.bottom > yTop))
        {
            return(pSprite);
        }

        pSprite = pSprite->pNextZ;
    }

    return(pSprite);
}

/******************************Public*Routine******************************\
* VOID  vSpRedrawSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpRedrawSprite(
SPRITE*     pSprite)
{
    GDIFunctionID(vSpRedrawSprite);

    SPRITESTATE*    pState;
    SURFOBJ*        psoComposite;
    POINTL          OffComposite;
    SPRITE*         pIntersect;
    RECTL           rclIntersect;

    pState = pSprite->pState;

    // There's nothing to redraw if we're full-screen:

    PDEVOBJ po(pState->hdev);
    if (po.bDisabled())
        return;

    ASSERTGDI(pState->bInsideDriverCall,
        "SPRITELOCK should be held");

    if (pSprite->fl & SPRITE_FLAG_VISIBLE)
    {
        ASSERTGDI((pSprite->rclSprite.left < pSprite->rclSprite.right) &&
                  (pSprite->rclSprite.top < pSprite->rclSprite.bottom),
            "Badly ordered rclSprite");

        psoComposite = psoSpGetComposite(pState, &pSprite->rclSprite);
        if (psoComposite == NULL)
            return;

        // Set the composite buffer's origin for ease of use:

        OffComposite.x = -pSprite->rclSprite.left;
        OffComposite.y = -pSprite->rclSprite.top;

        // First, copy the underlay to the composite buffer:

        OFFCOPYBITS(&OffComposite,
                    psoComposite,
                    &pSprite->OffUnderlay,
                    pSprite->psoUnderlay,
                    NULL,
                    NULL,
                    &pSprite->rclSprite,
                    (POINTL*) &pSprite->rclSprite);

        // Now composite each sprite:

        pIntersect = pSpFindInZ(pState->pListZ, &pSprite->rclSprite);
        while (pIntersect != NULL)
        {
            if (bIntersect(&pIntersect->rclSprite,
                           &pSprite->rclSprite,
                           &rclIntersect))
            {
                vSpComposite(pIntersect,
                             &OffComposite,
                             psoComposite,
                             &rclIntersect);
            }

            pIntersect = pSpFindInZ(pIntersect->pNextZ, &pSprite->rclSprite);
        }

        // Now copy the final composited result back to the screen:

        vSpWriteToScreen(pState,
                         &OffComposite,
                         psoComposite,
                         &pSprite->rclSprite);

        // set time stamp

        pSprite->ulTimeStamp = NtGetTickCount();

    }
}

/******************************Public*Routine******************************\
* ULONG cSpSubtract
*
* Simple little routine that returns back the list of rectangles that
* make up the area defined by 'prclA' minus 'prclB'.
*
* Returns the number and values of the resulting rectangles, which will
* be no more than four.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ULONG FASTCALL cSpSubtract(
CONST RECTL*    prclA,      // Computes A - B
CONST RECTL*    prclB,
RECTL*          arcl)
{
    RECTL   rcl;
    RECTL*  prcl;

    prcl = arcl;

    rcl.left   = LONG_MIN;
    rcl.top    = LONG_MIN;
    rcl.right  = LONG_MAX;
    rcl.bottom = prclB->top;

    if (bIntersect(&rcl, prclA, prcl))
        prcl++;

    rcl.top    = prclB->top;
    rcl.right  = prclB->left;
    rcl.bottom = prclB->bottom;

    if (bIntersect(&rcl, prclA, prcl))
        prcl++;

    rcl.left  = prclB->right;
    rcl.right = LONG_MAX;

    if (bIntersect(&rcl, prclA, prcl))
        prcl++;

    rcl.left   = LONG_MIN;
    rcl.top    = prclB->bottom;
    rcl.bottom = LONG_MAX;

    if (bIntersect(&rcl, prclA, prcl))
        prcl++;

    return((ULONG) (prcl - arcl));
}

/******************************Public*Routine******************************\
* VOID vSpRedrawUncoveredArea
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpRedrawUncoveredArea(
SPRITE*     pSprite,
RECTL*      prclNew)
{
    SPRITESTATE*    pState;
    RECTL           arclUncovered[4];
    RECTL           rclTmp;
    ULONG           crclUncovered;
    SURFOBJ*        psoComposite;
    POINTL          OffComposite;
    SPRITE*         pTmp;
    BOOL            bHit;
    ULONG           i;
    ULONG           j;

    pState = pSprite->pState;

    // There's nothing to redraw if we're full-screen:

    PDEVOBJ po(pState->hdev);
    if (po.bDisabled())
        return;

    ASSERTGDI(pState->bInsideDriverCall,
        "SPRITELOCK should be held");

    crclUncovered = cSpSubtract(&pSprite->rclSprite, prclNew, &arclUncovered[0]);
    if (crclUncovered)
    {
        bHit = FALSE;

        psoComposite = psoSpGetComposite(pState, &pSprite->rclSprite);
        if (psoComposite == NULL)
            return;

        // Set the composite buffer's origin for ease of use:

        OffComposite.x = -pSprite->rclSprite.left;
        OffComposite.y = -pSprite->rclSprite.top;

        pTmp = pSpFindInZ(pState->pListZ, &pSprite->rclSprite);
        while (pTmp != NULL)
        {
            if (pTmp != pSprite)
            {
                for (i = 0; i < crclUncovered; i++)
                {
                    if (bIntersect(&arclUncovered[i], &pTmp->rclSprite, &rclTmp))
                    {
                        if (!bHit)
                        {
                            for (j = 0; j < crclUncovered; j++)
                            {
                                OFFCOPYBITS(&OffComposite,
                                            psoComposite,
                                            &pSprite->OffUnderlay,
                                            pSprite->psoUnderlay,
                                            NULL,
                                            NULL,
                                            &arclUncovered[j],
                                            (POINTL*) &arclUncovered[j]);
                            }

                            bHit = TRUE;
                        }

                        vSpComposite(pTmp,
                                     &OffComposite,
                                     psoComposite,
                                     &rclTmp);
                    }
                }
            }

            pTmp = pSpFindInZ(pTmp->pNextZ, &pSprite->rclSprite);
        }

        for (i = 0; i < crclUncovered; i++)
        {
            if (bHit)
            {
                vSpWriteToScreen(pState,
                                 &OffComposite,
                                 psoComposite,
                                 &arclUncovered[i]);
            }
            else
            {
                vSpWriteToScreen(pState,
                                 &pSprite->OffUnderlay,
                                 pSprite->psoUnderlay,
                                 &arclUncovered[i]);
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID vSpSmallUnderlayCopy
*
* Updates the underlay bits of a sprite without forcing a re-compute
* of the sprite-range data structure.
*
* Copies a rectangle from the screen to the specified underlay surface.
* We update the underlay surface by first copying the entire rectangle
* straight from the frame buffer (which may include bits of other sprites),
* and then looping through the sprite list copying their underlays whereever
* they intersect.
*
* Note that if multiple sprites overlap, we'll be overwriting portions of
* the sprite many times.  Overdrawing pixels like this is always inefficient,
* but if the sprite size is small it won't be too bad.  On the other hand,
* if there are many sprites, the computation of the sprite range structure
* will be *very* expensive.
*
* So for small sprites, it's often faster to over-draw pixels than to
* re-compute the sprite range structure.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

// The 'SMALL_SPRITE_DIMENSION' is the maximum pixel dimension for which
// a sprite move will be done without recomputing the sprite ranges.

#define SMALL_SPRITE_DIMENSION  128

VOID vSpSmallUnderlayCopy(
SPRITE*     pSprite,
POINTL*     pOffDst,
SURFOBJ*    psoDst,
POINTL*     pOffSrc,
SURFOBJ*    psoSrc,
LONG        dx,
LONG        dy,
RECTL*      prclNew,
RECTL*      prclOld)
{
    SPRITESTATE*    pState;
    RECTL           rclSrc;
    RECTL           rclDst;
    ULONG           crcl;
    RECTL           arcl[4];
    ULONG           i;
    SPRITE*         pTmp;
    RECTL           rclTmp;

    pState = pSprite->pState;

    // There's nothing to redraw if we're full-screen:

    PDEVOBJ po(pState->hdev);
    if (po.bDisabled())
        return;

    ASSERTGDI(pState->bInsideDriverCall,
        "SPRITELOCK should be held");

    if (bIntersect(prclOld, prclNew, &rclDst))
    {
        rclSrc.left   = dx + rclDst.left;
        rclSrc.right  = dx + rclDst.right;
        rclSrc.top    = dy + rclDst.top;
        rclSrc.bottom = dy + rclDst.bottom;

        OFFCOPYBITS(pOffDst,
                    psoDst,
                    pOffSrc,
                    psoSrc,
                    NULL,
                    NULL,
                    &rclDst,
                    (POINTL*) &rclSrc);
    }

    crcl = cSpSubtract(prclNew, prclOld, arcl);

    ASSERTGDI(crcl != 0, "Shouldn't have an empty source");

    i = 0;
    do {
        vSpReadFromScreen(pState, pOffDst, psoDst, &arcl[i]);

    } while (++i != crcl);

    pTmp = pSpFindInZ(pState->pListZ, prclNew);
    while (pTmp != NULL)
    {
        if (pTmp != pSprite)
        {
            i = 0;
            do {
                if (bIntersect(&arcl[i], &pTmp->rclSprite, &rclTmp))
                {
                    OFFCOPYBITS(pOffDst,
                                psoDst,
                                &pTmp->OffUnderlay,
                                pTmp->psoUnderlay,
                                NULL,
                                NULL,
                                &rclTmp,
                                (POINTL*) &rclTmp);
                }
            } while (++i != crcl);
        }

        pTmp = pSpFindInZ(pTmp->pNextZ, prclNew);
    }
}

/******************************Public*Routine******************************\
* VOID vSpBigUnderlayCopy
*
* Reads a (future underlay) buffer from the screen, automatically excluding
* any sprites that may be in the way.
*
* This routine will be slow if the area is small, there are a large number
* of sprites, and  ENUMAREAS forces the sprite ranges to be re-calculated;
* it will be fast if the buffer to be read is large.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpBigUnderlayCopy(
SPRITESTATE*    pState,
POINTL*         pOffUnderlay,
SURFOBJ*        psoUnderlay,
RECTL*          prcl)
{
    SPRITE* pSprite;
    RECTL   rclEnum;
    BOOL    bMore;

    // There's nothing to redraw if we're full-screen:

    PDEVOBJ po(pState->hdev);
    if (po.bDisabled())
        return;

    ASSERTGDI(pState->bInsideDriverCall,
        "SPRITELOCK should be held");

    ENUMAREAS Enum(pState, prcl);

    do {
        bMore = Enum.bEnum(&pSprite, &rclEnum);

        if (pSprite == NULL)
        {
            vSpReadFromScreen(pState, pOffUnderlay, psoUnderlay, &rclEnum);
        }
        else
        {
            OFFCOPYBITS(pOffUnderlay,
                        psoUnderlay,
                        &pSprite->OffUnderlay,
                        pSprite->psoUnderlay,
                        NULL,
                        NULL,
                        &rclEnum,
                        (POINTL*) &rclEnum);
        }
    } while (bMore);
}

/******************************Public*Routine******************************\
* VOID vSpUpdateLockedScreenAreas
*
* When a screen-to-screen blt occurs, the screen-to-screen blt may occur
* under an area of the screen that is both locked by DirectDraw and covered
* by a sprite.  Normally, we never update the locked area under the sprite,
* but in this case we do, to reflect the moved contents.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpUpdateLockedScreenAreas(
SPRITESTATE*    pState,
POINTL*         pOffDst,
RECTL*          prclDst,
CLIPOBJ*        pco,
BOOL            bReadFromScreen)
{
    SPRITE*         pSprite;
    BOOL            bMore;
    RECTL           rclEnum;
    RECTL           rclArea;
    REGION*         prgnIntersect;
    ECLIPOBJ        ecoIntersect;
    RGNOBJ*         proClip;
    RGNMEMOBJTMP    rmoIntersect;
    RGNMEMOBJTMP    rmoScreen;

    ASSERTGDI(pState->prgnUnlocked != NULL,
        "Should really be called only when a DirectDraw lock is extant");

    PDEVOBJ po(pState->hdev);
    SPRITELOCK slock(po);

    prgnIntersect = NULL;

    if (rmoIntersect.bValid() &&
        rmoScreen.bValid() &&
        bIntersect(prclDst, &pState->rclScreen, &rclArea))
    {
        ENUMAREAS Enum(pState, &rclArea);

        do {
            bMore = Enum.bEnum(&pSprite, &rclEnum);

            if (pSprite != NULL)
            {
                if (prgnIntersect == NULL)
                {
                    proClip = (ECLIPOBJ*) pco;
                    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                    {
                        rmoScreen.vSet(&pState->rclScreen);
                        proClip = &rmoScreen;
                    }

                    // Intersect the clip object supplied by the drawing
                    // routine with the not of region representing the
                    // 'unlocked' portions of the screen.

                    RGNOBJ roUnlocked(pState->prgnUnlocked);
                    if (!rmoIntersect.bMerge(*proClip,
                                        roUnlocked,
                                        gafjRgnOp[RGN_DIFF]))
                    {
                        rmoIntersect.vSet();
                    }
                    prgnIntersect = rmoIntersect.prgnGet();
                }

                ecoIntersect.vSetup(prgnIntersect, *(ERECTL*) &rclEnum);
                if (!ecoIntersect.erclExclude().bEmpty())
                {
                    do {
                        if (bReadFromScreen)
                        {
                            OFFCOPYBITS(&pSprite->OffUnderlay,
                                        pSprite->psoUnderlay,
                                        pOffDst,
                                        pState->psoScreen,
                                        &ecoIntersect,
                                        NULL,
                                        &rclEnum,
                                        (POINTL*) &rclEnum);
                        }
                        else
                        {
                            OFFCOPYBITS(pOffDst,
                                        pState->psoScreen,
                                        &pSprite->OffUnderlay,
                                        pSprite->psoUnderlay,
                                        &ecoIntersect,
                                        NULL,
                                        &rclEnum,
                                        (POINTL*) &rclEnum);
                        }
                    } while ((bReadFromScreen) && (Enum.bEnumLayers(&pSprite)));
                }
            }
        } while (bMore);
    }
}



/******************************Public*Routine******************************\
* ENUMUNDERLAYS::ENUMUNDERLAYS
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ENUMUNDERLAYS::ENUMUNDERLAYS(
SURFOBJ*    pso,
CLIPOBJ*    pco,
RECTL*      prclDraw)
{
    PDEVOBJ po(pso->hdev);
    BOOL    bRclNotEmpty = TRUE;

    bDone           = FALSE;
    bSpriteTouched  = FALSE;
    bResetSurfFlag  = FALSE;
    pCurrentSprite  = NULL;
    pcoOriginal     = pco;
    psoOriginal     = pso;

    // This extra 'if' was added for GetPixel:

    if (po.bValid())
    {
        pState = po.pSpriteState();

        if ((pso == pState->psoScreen) && !(pState->bInsideDriverCall))
        {
            ASSERTGDI(!po.bDisabled(),
                "Mustn't be called when PDEV disabled");
            ASSERTGDI((pState->flOriginalSurfFlags & ~HOOK_FLAGS)
                == (SURFOBJ_TO_SURFACE(pso)->SurfFlags & ~HOOK_FLAGS),
                "SurfFlags was modified, but we're about to save over it!");

            SURFOBJ_TO_SURFACE_NOT_NULL(pso)->flags(pState->flOriginalSurfFlags);
            SURFOBJ_TO_SURFACE_NOT_NULL(pso)->iType(pState->iOriginalType);
            pState->bInsideDriverCall = TRUE;
            bResetSurfFlag = TRUE;

            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                rclBounds = *prclDraw;
                pcoClip   = &pState->coRectangular;
            }
            else
            {
                rclSaveBounds = pco->rclBounds;
                bRclNotEmpty = bIntersect(prclDraw, &pco->rclBounds, &rclBounds);
                pcoClip = pco;
            }

            // Find intersecting sprite if we have non-empty bounds;
            // otherwise, leave pCurrentSprite = NULL.
            if (bRclNotEmpty)
            {
                pCurrentSprite = pSpFindInZ(pState->pListZ, &rclBounds);
            }
        }
    }
}

/******************************Public*Routine******************************\
* ENUMUNDERLAYS::bEnum
*
* This routine is a helper function for drawing primitives that handles
* the drawing of the primitive to various sprite underlay and screen
* surfaces.  It takes the form of an enumeration function in order to
* return back the appropriate surface and clip objects that should be
* drawn on by the caller.
*
* Returns: TRUE if the caller should draw using the returned values;
*          FALSE if no more drawing needs to be done.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL ENUMUNDERLAYS::bEnum(
SURFOBJ**   ppso,
POINTL*     pOff,
CLIPOBJ**   ppco)
{
    RECTL   rclTmp;

    // We first draw to the underlay surfaces of any sprites that
    // intersect with our area of interest.  See if there is
    // another sprite that intersects, and if so return that:

    while (pCurrentSprite != NULL)
    {
        if (bIntersect(&pCurrentSprite->rclSprite, &rclBounds, &rclTmp))
        {
            ASSERTGDI(pcoClip->iDComplexity != DC_TRIVIAL,
                "Expected non-trivial clipping when drawing to sprite");

            bSpriteTouched = TRUE;
            pcoClip->rclBounds = rclTmp;

            *ppco = pcoClip;
            *ppso = pCurrentSprite->psoUnderlay;
            *pOff = pCurrentSprite->OffUnderlay;

            pCurrentSprite = pCurrentSprite->pNextZ;
            return(TRUE);
        }

        pCurrentSprite = pSpFindInZ(pCurrentSprite->pNextZ, &rclBounds);
    }

    if (!bDone)
    {
        if (!bSpriteTouched)
        {
            // No sprites intersected with the region of drawing, so we
            // can simply return back the original clipping and surface
            // object:

            bDone   = TRUE;
            *ppco   = pcoOriginal;
            *ppso   = psoOriginal;
            pOff->x = 0;
            pOff->y = 0;
            return(TRUE);
        }

        // Okay, at this point we have work to do.  We have to 'cut out'
        // of the original clip objects any areas that were covered
        // by the sprites.

        if (!pState->bValidRange)
        {
            vSpComputeSpriteRanges(pState);
        }

        if (pcoClip->iDComplexity != DC_COMPLEX)
        {
            // Oh good, we can use our already-constructed complex region
            // describing the uncovered parts of the screen.
            //
            // Use CLIP_FORCE to ensure that 'rclBounds' is always respected
            // as the bounds, so that we don't revert to DC_TRIVIAL clipping
            // when in fact the original call came in clipped:

            pState->coTmp.vSetup(pState->prgnUncovered,
                                 *((ERECTL*)&rclBounds),
                                 CLIP_FORCE);
        }
        else
        {
            // Okay, we've got some work to do.  We have to subtract each of
            // the sprite rectangles from the drawing call's clip object.

            RGNOBJ roUncovered(pState->prgnUncovered);
            RGNOBJ roTmp(pState->prgnTmp);

            // Find the intersection of the two regions. If the bMerge fails,
            // we'll draw wrong, but we won't crash.

            if (!roTmp.bMerge(*((XCLIPOBJ*)pcoClip), roUncovered, gafjRgnOp[RGN_AND]))
            {
                roTmp.vSet();
            }

            // Compute the resulting clip object:

            pState->prgnTmp = roTmp.prgnGet();
            pState->coTmp.vSetup(pState->prgnTmp,
                                 *((ERECTL*)&rclBounds),
                                 CLIP_FORCE);
        }

        // Note that this 'bIntersect' test handles the empty case for
        // 'coTmp.rclBounds':

        if (bIntersect(&pState->coTmp.rclBounds, &rclBounds))
        {
            ASSERTGDI((pState->prgnUnlocked != NULL) ||
                      (pState->coTmp.iDComplexity != DC_TRIVIAL),
                "If sprite was touched, expect clipping on uncovered portion!");

            bDone   = TRUE;
            *ppco   = &pState->coTmp;
            *ppso   = psoOriginal;
            pOff->x = 0;
            pOff->y = 0;
            return(TRUE);
        }
    }

    // We're all done, update the screen underneath the sprites if need be:

    if (bResetSurfFlag)
    {
        if (bSpriteTouched)
        {
            // One problem that is visible with sprites, particularly when
            // using a software cursor, is that when drawing a single
            // primitive, there is sometimes a noticeable temporal gap between
            // the time that the area around the sprite is drawn, and the area
            // underneath the sprite is updated.
            //
            // I used to update the area underneath the sprite before
            // doing the drawing that occurs around the sprite, reasoning that
            // people tend to be looking exactly at the cursor sprite and would
            // benefit most from that area being updated as soon as possible,
            // before the surrounding area.
            //
            // But I've changed my mind, and think the opposite is better.
            // This is partly because drawing operations with complex clipping
            // often need longer setup time than it does to update the sprite,
            // so the time difference between the two is lessened if the
            // sprite is updated *after* the complex clipped drawing is done.
            //
            // (I'll add that I also tried updating in chunks from top to
            // bottom, but the resulting tearing was far worse.)

            vSpRedrawArea(pState, &rclBounds);
        }

        ASSERTGDI((pState->flOriginalSurfFlags & ~HOOK_FLAGS)
            == (SURFOBJ_TO_SURFACE(psoOriginal)->SurfFlags & ~HOOK_FLAGS),
            "SurfFlags was modified, but we're about to restore over it!");

        SURFOBJ_TO_SURFACE_NOT_NULL(psoOriginal)->flags(pState->flSpriteSurfFlags);
        SURFOBJ_TO_SURFACE_NOT_NULL(psoOriginal)->iType(pState->iSpriteType);
        pState->bInsideDriverCall = FALSE;

        // This restores the original clip object's bounds if need be (or it
        // overwrites 'coRectangular.rclBounds', which is also fine):

        pcoClip->rclBounds = rclSaveBounds;
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL SpStrokePath
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxlo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    BOOL        bRet = TRUE;
    BOOL        bThis;
    FLOAT_LONG  elStyleState;
    POINTL      Offset;

    ASSERTGDI(pco != NULL, "Drivers always expect non-NULL pco's for this call");

    elStyleState = pla->elStyleState;

    ENUMUNDERLAYS Enum(pso, pco, &pco->rclBounds);
    while (Enum.bEnum(&pso, &Offset, &pco))
    {
        // We have to reset the style state every time we call StrokePath,
        // otherwise it incorrectly accumulates.  Also reset the path enumeration.

        pla->elStyleState = elStyleState;
        PATHOBJ_vEnumStart(ppo);

        bThis = OffStrokePath(PPFNDIRECT(pso, StrokePath), &Offset, pso,
                              ppo, pco, pxlo, pbo, pptlBrush, pla, mix);

        // Drivers can return TRUE, FALSE, or DDI_ERROR from this call.  We
        // should have caught any FALSE cases lower down, so permute them
        // to failures should they have actually occurred:

        if (!bThis)
            bRet = DDI_ERROR;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpFillPath
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix,
FLONG     flOptions)
{
    BOOL    bRet = TRUE;
    BOOL    bThis;
    POINTL  Offset;

    ASSERTGDI(pco != NULL, "Drivers always expect non-NULL pco's for this call");

    ENUMUNDERLAYS Enum(pso, pco, &pco->rclBounds);
    while (Enum.bEnum(&pso, &Offset, &pco))
    {
        // Reset the path enumeration
        PATHOBJ_vEnumStart(ppo);

        bThis = OffFillPath(PPFNDIRECT(pso, FillPath), &Offset, pso, ppo, pco,
                            pbo, pptlBrush, mix, flOptions);

        // Drivers can return TRUE, FALSE, or DDI_ERROR from this call.  We
        // should have caught any FALSE cases lower down, so permute them
        // to failures should they have actually occurred:

        if (!bThis)
            bRet = DDI_ERROR;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bSpBltScreenToScreen
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpBltScreenToScreen(
SURFOBJ*    pso,
SURFOBJ*    psoIgnore,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    SPRITESTATE*    pState;
    LONG            dx;
    LONG            dy;
    ULONG           iDirection;
    POINTL          Offset;
    RECTL           rclIntersect;
    RECTL           rclSrc;
    RECTL           rclDst;
    RECTL           rclSubSrc;
    RECTL           rclSubDst;
    POINTL          ptlSubMsk;
    POINTL          ptlPreviousDst;
    SPRITE*         pSpriteDst;
    SPRITE*         pSpriteSrc;
    SPRITE*         pSpriteTmp;
    SURFOBJ*        psoSrc;
    SURFOBJ*        psoDst;
    RECTL           rclBounds;
    BOOL            bMore;
    BOOL            bSubMore;
    POINTL*         pOffDst;
    POINTL*         pOffSrc;

    PDEVOBJ po(pso->hdev);

    pState = po.pSpriteState();

    // Restore the surface's original attributes.

    SPRITELOCK slock(po);

    dx = prclDst->left - pptlSrc->x;
    dy = prclDst->top  - pptlSrc->y;

    if (dx > 0)
        iDirection = (dy > 0) ? CD_LEFTUP : CD_LEFTDOWN;
    else
        iDirection = (dy > 0) ? CD_RIGHTUP : CD_RIGHTDOWN;

    if (pco != NULL)
    {
        if (pco->iDComplexity == DC_TRIVIAL)
            pco = NULL;
        else
            rclBounds = pco->rclBounds;
    }

    // If parts of the screen are locked by DirectDraw, update our underlay
    // buffers for the portions covered by both the source rectangle and
    // the destination rectangle and intersect with the locked portion of
    // of the screen.  (This case handles a screen-to-screen blt where
    // a DirectDraw lock sits right in the middle of both.)

    if (pState->prgnUnlocked != NULL)
    {
        rclSrc.left   = prclDst->left   - dx;
        rclSrc.right  = prclDst->right  - dx;
        rclSrc.top    = prclDst->top    - dy;
        rclSrc.bottom = prclDst->bottom - dy;

        if (bIntersect(prclDst, &rclSrc, &rclIntersect))
        {
            vSpUpdateLockedScreenAreas(pState, &gptlZero, &rclIntersect, pco, TRUE);
        }
    }

    ENUMAREAS Enum(pState, prclDst, iDirection);

    // Only check ENUMAREAS::bValid because of the nested ENUMAREAS call below
    // (in the failure case, proceeding is bad because the nested call might
    // succeed in recomputing the sprite ranges and leave us with bad
    // pointers).

    if (Enum.bValid())
    {
        do {
            bMore = Enum.bEnum(&pSpriteDst, &rclDst);

            rclSrc.left   = rclDst.left   - dx;
            rclSrc.right  = rclDst.right  - dx;
            rclSrc.top    = rclDst.top    - dy;
            rclSrc.bottom = rclDst.bottom - dy;

            // For rectangles that intersect multiple sprites, I had thought
            // about simply composing the one overlay for that rectangle, and
            // then copying that to the others.  The problem I saw with that
            // was that if that 'master' underlay is in video memory, but the
            // rest are in system memory, that will actually be slower.

            do {
                if (pSpriteDst == NULL)
                {
                    psoDst  = pso;
                    pOffDst = &gptlZero;
                }
                else
                {
                    psoDst  = pSpriteDst->psoUnderlay;
                    pOffDst = &pSpriteDst->OffUnderlay;
                }

                ENUMAREAS SubEnum(pState, &rclSrc, iDirection);

                do {
                    bSubMore = SubEnum.bEnum(&pSpriteSrc, &rclSubSrc);

                    // We have to be sure to use as the source the last layered
                    // underlay in the list, because we may be traversing
                    // through the same list to find the destination surfaces --
                    // and we don't want to modify our source before we've copied
                    // it to all the other surfaces!  This bug took me an
                    // embarrassingly long time to fix, because it would only
                    // mis-draw when screen-to-screen blts occurred under
                    // actively moving sprites that overlayed each other.

                    while (SubEnum.bEnumLayers(&pSpriteTmp))
                    {
                        pSpriteSrc = pSpriteTmp;
                    }

                    if (pSpriteSrc == NULL)
                    {
                        psoSrc  = pso;
                        pOffSrc = &gptlZero;
                    }
                    else
                    {
                        psoSrc  = pSpriteSrc->psoUnderlay;
                        pOffSrc = &pSpriteSrc->OffUnderlay;
                    }

                    rclSubDst.left   = rclSubSrc.left   + dx;
                    rclSubDst.right  = rclSubSrc.right  + dx;
                    rclSubDst.top    = rclSubSrc.top    + dy;
                    rclSubDst.bottom = rclSubSrc.bottom + dy;

                    ASSERTGDI((rclSubDst.left   >= pState->rclScreen.left) &&
                              (rclSubDst.top    >= pState->rclScreen.top) &&
                              (rclSubDst.right  <= pState->rclScreen.right) &&
                              (rclSubDst.bottom <= pState->rclScreen.bottom),
                        "Enumerated area out of bounds");

                    // We must ensure that for DrvBitBlt, pco->rclBounds intersects
                    // with prclDst, otherwise drivers like the VGA will crash in
                    // their DC_COMPLEX code because they don't check for
                    // intersection:

                    if ((pco == NULL) ||
                        bIntersect(&rclSubDst, &rclBounds, &pco->rclBounds))
                    {
                        if (rop4 == 0xcccc)
                        {
                            OFFCOPYBITS(pOffDst, psoDst, pOffSrc, psoSrc,
                                        pco, pxlo, &rclSubDst, (POINTL*) &rclSubSrc);
                        }
                        else
                        {
                            if (pptlMsk)
                            {
                                ptlSubMsk.x
                                    = pptlMsk->x + (rclSubDst.left - prclDst->left);
                                ptlSubMsk.y
                                    = pptlMsk->y + (rclSubDst.top - prclDst->top);
                            }

                            OFFBITBLT(pOffDst, psoDst, pOffSrc, psoSrc,
                                      psoMsk, pco, pxlo, &rclSubDst,
                                      (POINTL*) &rclSubSrc, &ptlSubMsk, pbo,
                                      pptlBrush, rop4);
                        }
                    }
                } while (bSubMore);
            } while (Enum.bEnumLayers(&pSpriteDst));

            // We recomposite here as we do every sprite, instead of one big
            // 'vSpRedrawArea(pState, prclDst)' at the end, to reduce the visible
            // tearing:

            if (pSpriteDst != NULL)
                vSpRedrawArea(pState, &rclDst);

        } while (bMore);
    }

    // Restore the clip object's original bounds, which we mucked with:

    if (pco != NULL)
        pco->rclBounds = rclBounds;

    // If parts of the screen are locked by DirectDraw, we may also have to
    // update the area in the locked area, which we didn't do above:

    if (pState->prgnUnlocked != NULL)
        vSpUpdateLockedScreenAreas(pState, &gptlZero, prclDst, pco, FALSE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bSpBltFromScreen
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpBltFromScreen(
SURFOBJ*    psoDst,         // Might be a sprite underlay surface, used
                            //   by vSpUpdate for moving a sprite
SURFOBJ*    psoSrc,         // Always the primary screen
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    SPRITESTATE*    pState;
    LONG            dx;
    LONG            dy;
    POINTL          Offset;
    ULONG           iDirection;
    RECTL           rclSrc;
    RECTL           rclDst;
    POINTL          ptlMsk;
    SPRITE*         pSpriteSrc;
    RECTL*          prclBounds;
    BYTE            iDComplexity;
    RECTL           rclBounds;
    BOOL            bMore;
    POINTL*         pOffSrc;

    PDEVOBJ po(psoSrc->hdev);

    pState = po.pSpriteState();

    // To allow software cursors to work, we have to respect the
    // 'bInsideDriverCall' flag to allow the simulations to read
    // directly from the screen.  We also have to be sure that
    // CopyBits calls get sent to CopyBits, otherwise the VGA
    // driver (and possibly others) will crash.

    // Also, if the 'IncludeSprites' flag is set in the destination surface,
    // this is a signal GreStretchBltInternal that we should do a direct blt.
    // (i.e. the ROP passed to StretchBlt/BitBlt had the CAPTUREBLT flag
    // set.) [Bug #278291]

    if ((pState->bInsideDriverCall) ||
        (SURFOBJ_TO_SURFACE(psoDst)->bIncludeSprites()))
    {
        // Grab the sprite lock (needed for the CAPTUREBLT case).

        SPRITELOCK slock(po);

        if (rop4 == 0xcccc)
        {
            return(OFFCOPYBITS(&gptlZero, psoDst, &gptlZero, psoSrc, pco,
                               pxlo, prclDst, pptlSrc));
        }
        else
        {
            return(OFFBITBLT(&gptlZero, psoDst, &gptlZero, psoSrc, psoMsk,
                             pco, pxlo, prclDst, pptlSrc, pptlMsk, pbo,
                             pptlBrush, rop4));
        }
    }

    // Restore the surface's original attributes.

    SPRITELOCK slock(po);

    dx = prclDst->left - pptlSrc->x;
    dy = prclDst->top  - pptlSrc->y;

    rclSrc.left   = pptlSrc->x;
    rclSrc.top    = pptlSrc->y;
    rclSrc.right  = prclDst->right  - dx;
    rclSrc.bottom = prclDst->bottom - dy;

    // If parts of the screen are locked by DirectDraw, update our underlay
    // buffers for the portion read by the blt:

    if (pState->prgnUnlocked != NULL)
    {
        Offset.x = -dx;
        Offset.y = -dy;

        vSpUpdateLockedScreenAreas(pState, &Offset, prclDst, pco, TRUE);
    }

    // We have to enumerate the rectangles according to the blt direction
    // because vSpUpdate may call us with a sprite underlay surface as
    // 'psoDst' in order to move a sprite.

    if (dx > 0)
        iDirection = (dy > 0) ? CD_LEFTUP : CD_LEFTDOWN;
    else
        iDirection = (dy > 0) ? CD_RIGHTUP : CD_RIGHTDOWN;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;
    if (iDComplexity != DC_TRIVIAL)
        rclBounds = pco->rclBounds;

    ENUMAREAS Enum(pState, &rclSrc, iDirection);

    do {
        bMore = Enum.bEnum(&pSpriteSrc, &rclSrc);

        rclDst.left   = rclSrc.left   + dx;
        rclDst.right  = rclSrc.right  + dx;
        rclDst.top    = rclSrc.top    + dy;
        rclDst.bottom = rclSrc.bottom + dy;

        // We must ensure that for DrvBitBlt, pco->rclBounds intersects
        // with prclDst, otherwise drivers like the VGA will crash in
        // their DC_COMPLEX code because they don't check for
        // intersection:

        if ((iDComplexity == DC_TRIVIAL) ||
            bIntersect(&rclDst, &rclBounds, &pco->rclBounds))
        {
            if (pSpriteSrc == NULL)
            {
                psoSrc  = pState->psoScreen;
                pOffSrc = &gptlZero;
            }
            else
            {
                psoSrc  = pSpriteSrc->psoUnderlay;
                pOffSrc = &pSpriteSrc->OffUnderlay;
            }

            if (rop4 == 0xcccc)
            {
                OFFCOPYBITS(&gptlZero, psoDst, pOffSrc, psoSrc, pco,
                            pxlo, &rclDst, (POINTL*) &rclSrc);
            }
            else
            {
                if (pptlMsk)
                {
                    ptlMsk.x = pptlMsk->x + (rclDst.left - prclDst->left);
                    ptlMsk.y = pptlMsk->y + (rclDst.top - prclDst->top);
                }

                OFFBITBLT(&gptlZero, psoDst, pOffSrc, psoSrc, psoMsk,
                          pco, pxlo, &rclDst, (POINTL*) &rclSrc, &ptlMsk, pbo,
                          pptlBrush, rop4);
            }
        }
    } while (bMore);

    // Restore the clip object's original bounds, which we mucked with:

    if (iDComplexity != DC_TRIVIAL)
        pco->rclBounds = rclBounds;

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL SpBitBlt
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMsk,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMsk,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    SPRITESTATE*    pState;
    PFN_DrvBitBlt   pfnBitBlt;
    RECTL           rclDstOriginal;
    POINTL          OffDst;
    RECTL           rclDst;
    POINTL          ptlSrc;
    POINTL          ptlMsk;
    LONG            dx;
    LONG            dy;
    BOOL            bRet = TRUE;

    PDEVOBJ poSrc((psoSrc != NULL) ? psoSrc->hdev : NULL);

    // Handle the hard cases with specific routines:

    if ((poSrc.bValid()) && (psoSrc == poSrc.pSpriteState()->psoScreen))
    {
        pfnBitBlt = (psoDst == psoSrc) ? bSpBltScreenToScreen : bSpBltFromScreen;

        bRet = pfnBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc,
                         pptlMsk, pbo, pptlBrush, rop4);
    }
    else
    {
        // Watch out for calls that point 'prclDst' to 'pco->rclBounds', which
        // we'll be modifying:

        rclDstOriginal = *prclDst;

        ENUMUNDERLAYS Enum(psoDst, pco, prclDst);
        while (Enum.bEnum(&psoDst, &OffDst, &pco))
        {
            if (rop4 == 0xcccc)
            {
                bRet &= OFFCOPYBITS(&OffDst, psoDst, &gptlZero, psoSrc,
                                    pco, pxlo, &rclDstOriginal, pptlSrc);
            }
            else if ((rop4 & 0xff) == (rop4 >> 8))
            {
                bRet &= OFFBITBLT(&OffDst, psoDst, &gptlZero, psoSrc,
                                  psoMsk, pco, pxlo, &rclDstOriginal, pptlSrc,
                                  pptlMsk, pbo, pptlBrush, rop4);
            }
            else
            {
                // A lot of drivers don't properly handle adjusting 'pptlMsk'
                // in their DrvBitBlt 'punt' code when *prclDst is larger than
                // pco->rclBounds.  So what we'll do here is muck with the
                // parameters to ensure that *prclDst is not larger than
                // pco->rclBounds.
                //
                // Note that this problem does not typically appear without
                // sprites, as NtGdiMaskBlt automatically does this before
                // calling DrvBitBlt.  It's only our ENUMUNDERLAYS code above
                // which generates this sort of clipping.

                rclDst = rclDstOriginal;
                if ((!pco) ||   // If pco is NULL, don't call bIntersect
                    bIntersect(&pco->rclBounds, &rclDstOriginal, &rclDst))
                {
                    dx = rclDst.left - rclDstOriginal.left;
                    dy = rclDst.top - rclDstOriginal.top;

                    POINTL* ptlSrcAdjusted = NULL;

                    if (pptlSrc)
                    {
                        ptlSrc.x = pptlSrc->x + dx;
                        ptlSrc.y = pptlSrc->y + dy;
                        ptlSrcAdjusted = &ptlSrc;
                    }

                    POINTL* ptlMskAdjusted = NULL;

                    if (pptlMsk)
                    {
                        ptlMsk.x = pptlMsk->x + dx;
                        ptlMsk.y = pptlMsk->y + dy;
                        ptlMskAdjusted = &ptlMsk;
                    }

                    bRet &= OFFBITBLT(&OffDst, psoDst, &gptlZero, psoSrc,
                                      psoMsk, pco, pxlo, &rclDst, ptlSrcAdjusted,
                                      ptlMskAdjusted, pbo, pptlBrush, rop4);
                }
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpCopyBits
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    return(SpBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, NULL,
                    NULL, NULL, 0xcccc));
}

/******************************Public*Routine******************************\
* BOOL SpStretchBlt
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpStretchBlt(              // Is this call really needed?
SURFOBJ*         psoDst,
SURFOBJ*         psoSrc,
SURFOBJ*         psoMsk,
CLIPOBJ*         pco,
XLATEOBJ*        pxlo,
COLORADJUSTMENT* pca,
POINTL*          pptlHTOrg,
RECTL*           prclDst,
RECTL*           prclSrc,
POINTL*          pptlMsk,
ULONG            iMode)
{
    BOOL    bRet = TRUE;
    ERECTL  erclDraw;
    POINTL  Offset;

    // The source rectangle should not exceed the bounds
    // of the surface - that should have been handled by GDI.
    // (bug 77102 - see EngStretchBlt)

    ASSERTGDI((prclSrc->left >= 0) &&
              (prclSrc->top  >= 0) &&
              (prclSrc->right  <= psoSrc->sizlBitmap.cx) &&
              (prclSrc->bottom <= psoSrc->sizlBitmap.cy),
              "Source rectangle exceeds source surface");

    // I can't be bothered to handle the code that Stretchblt's when the
    // source is the screen.  To handle those cases, we would have to
    // exclude all the sprites on the read, just as bSpBltFromScreen does.
    // Fortunately, we've marked the screen surface as STYPE_DEVICE and
    // so the Eng function will punt via SpCopyBits, which does do the
    // right thing:

    PDEVOBJ poSrc(psoSrc->hdev);
    if ((poSrc.bValid()) && (poSrc.pSpriteState()->psoScreen == psoSrc))
    {
        return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca,
                             pptlHTOrg, prclDst, prclSrc, pptlMsk, iMode));
    }

    // The destination rectangle on a stretch will be poorly ordered when
    // inverting or mirroring:

    erclDraw = *prclDst;
    erclDraw.vOrder();

    ENUMUNDERLAYS Enum(psoDst, pco, &erclDraw);
    while (Enum.bEnum(&psoDst, &Offset, &pco))
    {
        bRet &= OffStretchBlt(PPFNDIRECT(psoDst, StretchBlt), &Offset, psoDst,
                              &gptlZero, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                              prclDst, prclSrc, pptlMsk, iMode);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpStretchBltROP
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpStretchBltROP(
SURFOBJ*         psoDst,
SURFOBJ*         psoSrc,
SURFOBJ*         psoMsk,
CLIPOBJ*         pco,
XLATEOBJ*        pxlo,
COLORADJUSTMENT* pca,
POINTL*          pptlHTOrg,
RECTL*           prclDst,
RECTL*           prclSrc,
POINTL*          pptlMsk,
ULONG            iMode,
BRUSHOBJ*        pbo,
DWORD            rop4)
{
    BOOL    bRet = TRUE;
    ERECTL  erclDraw;
    POINTL  Offset;

    // The source rectangle should not exceed the bounds
    // of the surface - that should have been handled by GDI.
    // (bug 77102 - see EngStretchBlt)

    ASSERTGDI((prclSrc->left >= 0) &&
              (prclSrc->top  >= 0) &&
              (prclSrc->right  <= psoSrc->sizlBitmap.cx) &&
              (prclSrc->bottom <= psoSrc->sizlBitmap.cy),
              "Source rectangle exceeds source surface");

    // I can't be bothered to handle the code that Stretchblt's when the
    // source is the screen.  To handle those cases, we would have to
    // exclude all the sprites on the read, just as bSpBltFromScreen does.
    // Fortunately, we've marked the screen surface as STYPE_DEVICE and
    // so the Eng function will punt via SpCopyBits, which does do the
    // right thing:

    PDEVOBJ poSrc(psoSrc->hdev);
    if ((poSrc.bValid()) && (poSrc.pSpriteState()->psoScreen == psoSrc))
    {
        return(EngStretchBltROP(psoDst, psoSrc, psoMsk, pco, pxlo, pca,
                                pptlHTOrg, prclDst, prclSrc, pptlMsk, iMode,
                                pbo, rop4));
    }
    // The destination rectangle on a stretch will be poorly ordered when
    // inverting or mirroring:

    erclDraw = *prclDst;
    erclDraw.vOrder();

    ENUMUNDERLAYS Enum(psoDst, pco, &erclDraw);
    while (Enum.bEnum(&psoDst, &Offset, &pco))
    {
        bRet &= OffStretchBltROP(PPFNDIRECT(psoDst, StretchBltROP), &Offset,
                                 psoDst, &gptlZero, psoSrc, psoMsk, pco, pxlo, pca,
                                 pptlHTOrg, prclDst, prclSrc, pptlMsk, iMode,
                                 pbo, rop4);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpTextOut
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpTextOut(
SURFOBJ*    pso,
STROBJ*     pstro,
FONTOBJ*    pfo,
CLIPOBJ*    pco,
RECTL*      prclExtra,
RECTL*      prclOpaque,
BRUSHOBJ*   pboFore,
BRUSHOBJ*   pboOpaque,
POINTL*     pptlOrg,
MIX         mix)
{
    BOOL            bRet = TRUE;
    RECTL*          prclBounds;
    POINTL          Offset;
    ULONG           cgposCopied;
    BOOL            bEngTextOutOnly;
    PFN_DrvTextOut  pfnTextOut;

    // Some drivers can't handle antialiased text, so in those cases don't
    // try to call the driver.  Note that we are calling 'SpTextOut' in the
    // first place for these cases to allow 'EngTextOut' to draw directly on 
    // the bits if the surface is an STYPE_BITMAP surface, even if a sprite
    // is on the screen.

    bEngTextOutOnly = FALSE;
    if (pfo->flFontType & FO_GRAY16)
    {
        PDEVOBJ po(pso->hdev);
        if (!(po.flGraphicsCapsNotDynamic() & GCAPS_GRAY16) || (pfo->flFontType & FO_CLEARTYPE_X))
        {
            bEngTextOutOnly = TRUE;
        }
    }

    cgposCopied = ((ESTROBJ*)pstro)->cgposCopied;

    prclBounds = (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround;

    ENUMUNDERLAYS Enum(pso, pco, prclBounds);
    while (Enum.bEnum(&pso, &Offset, &pco))
    {
        ((ESTROBJ*)pstro)->cgposCopied = cgposCopied;

        pfnTextOut = (bEngTextOutOnly) ? EngTextOut : PPFNDIRECT(pso, TextOut);

        bRet &= OffTextOut(pfnTextOut, &Offset, pso, pstro, pfo,
                           pco, prclExtra, prclOpaque, pboFore, pboOpaque,
                           pptlOrg, mix);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpLineTo
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpLineTo(
SURFOBJ   *pso,
CLIPOBJ   *pco,
BRUSHOBJ  *pbo,
LONG       x1,
LONG       y1,
LONG       x2,
LONG       y2,
RECTL     *prclBounds,
MIX        mix)
{
    BOOL    bRet = TRUE;
    POINTL  Offset;

    ENUMUNDERLAYS Enum(pso, pco, prclBounds);
    while (Enum.bEnum(&pso, &Offset, &pco))
    {
        bRet &= OffLineTo(PPFNDIRECT(pso, LineTo), &Offset, pso, pco, pbo,
                          x1, y1, x2, y2, prclBounds, mix);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpDrawStream
*
*  1-27-2001 bhouse
* Wrote it.
\**************************************************************************/

BOOL SpDrawStream(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
PRECTL    prclDstBounds,
PPOINTL   pptlDstOffset,
ULONG     ulIn,
PVOID     pvIn,
DSSTATE*  pdss)
{
    BOOL    bRet = TRUE;
    POINTL  Offset;

//    DbgPrint("SpDrawStream entered\n");

    // source can't be the screen

    PDEVOBJ poSrc(psoSrc->hdev);
    
    if ((poSrc.bValid()) && (poSrc.pSpriteState()->psoScreen == psoSrc))
    {
        DbgPrint("SpDrawStream: source is the screen, this should never happen\n");
        return bRet;
    }

    // The source is not the screen.  Only need to worry about enumerating
    // the sprites overlaying the destination.

    ENUMUNDERLAYS Enum(psoDst, pco, prclDstBounds);

    while (Enum.bEnum(&psoDst, &Offset, &pco))
    {
        bRet &= OffDrawStream(PPFNDIRECTENG(psoDst, DrawStream), &Offset,
                                  psoDst, psoSrc, pco, pxlo, prclDstBounds,
                                  pptlDstOffset,
                                  ulIn, pvIn, pdss);
    }

//    DbgPrint("SpDrawStream returning\n");
    
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpTransparentBlt
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpTransparentBlt(
SURFOBJ         *psoDst,
SURFOBJ         *psoSrc,
CLIPOBJ         *pco,
XLATEOBJ        *pxlo,
RECTL           *prclDst,
RECTL           *prclSrc,
ULONG           iTransColor,
ULONG           ulReserved)
{
    BOOL    bRet = TRUE;
    POINTL  Offset;

    // I can't be bothered to handle the code that TransparentBlt's when the
    // source is the screen.  To handle those cases, we would have to
    // exclude all the sprites on the read, just as bSpBltFromScreen does.
    // Fortunately, we've marked the screen surface as STYPE_DEVICE and
    // so the Eng function will punt via SpCopyBits, which does do the
    // right thing:

    PDEVOBJ poSrc(psoSrc->hdev);
    if ((poSrc.bValid()) && (poSrc.pSpriteState()->psoScreen == psoSrc))
    {
        return(EngTransparentBlt(psoDst, psoSrc, pco, pxlo, prclDst,
                                 prclSrc, iTransColor, ulReserved));
    }

    // The source is not the screen.  Only need to worry about enumerating
    // the sprites overlaying the destination.

    ENUMUNDERLAYS Enum(psoDst, pco, prclDst);
    while (Enum.bEnum(&psoDst, &Offset, &pco))
    {
        bRet &= OffTransparentBlt(PPFNDIRECT(psoDst, TransparentBlt), &Offset,
                                  psoDst, &gptlZero, psoSrc, pco, pxlo, prclDst,
                                  prclSrc, iTransColor, ulReserved);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpAlphaBlend
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpAlphaBlend(
SURFOBJ       *psoDst,
SURFOBJ       *psoSrc,
CLIPOBJ       *pco,
XLATEOBJ      *pxlo,
RECTL         *prclDst,
RECTL         *prclSrc,
BLENDOBJ      *pBlendObj)
{
    BOOL    bRet = TRUE;
    POINTL  Offset;

    // I can't be bothered to handle the code that AlphaBlend's when the
    // source is the screen.  To handle those cases, we would have to
    // exclude all the sprites on the read, just as bSpBltFromScreen does.
    // Fortunately, we've marked the screen surface as STYPE_DEVICE and
    // so the Eng function will punt via SpCopyBits, which does do the
    // right thing:

    PDEVOBJ poSrc(psoSrc->hdev);
    if ((poSrc.bValid()) && (poSrc.pSpriteState()->psoScreen == psoSrc))
    {
        return(EngAlphaBlend(psoDst, psoSrc, pco, pxlo, prclDst,
                             prclSrc, pBlendObj));
    }

    // The source is not the screen.  Only need to worry about enumerating
    // the sprites overlaying the destination.

    ENUMUNDERLAYS Enum(psoDst, pco, prclDst);
    while (Enum.bEnum(&psoDst, &Offset, &pco))
    {
        bRet &= OffAlphaBlend(PPFNDIRECT(psoDst, AlphaBlend), &Offset, psoDst,
                              &gptlZero, psoSrc, pco, pxlo,
                              prclDst, prclSrc, pBlendObj);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpPlgBlt
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpPlgBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlBrush,
POINTFIX*           pptfx,
RECTL*              prcl,
POINTL*             pptl,
ULONG               iMode)
{
    RECTL   rclDraw;
    BOOL    bRet = TRUE;
    LONG    iLeft = (pptfx[1].x > pptfx[0].x) == (pptfx[1].x > pptfx[3].x);
    LONG    iTop  = (pptfx[1].y > pptfx[0].y) == (pptfx[1].y > pptfx[3].y);
    POINTL  Offset;

    // I can't be bothered to handle the code that PlgBlt's when the
    // source is the screen.  To handle those cases, we would have to
    // exclude all the sprites on the read, just as bSpBltFromScreen does.
    // Fortunately, we've marked the screen surface as STYPE_DEVICE and
    // so the Eng function will punt via SpCopyBits, which does do the
    // right thing:

    PDEVOBJ poSrc(psoSrc->hdev);
    if ((poSrc.bValid()) && (poSrc.pSpriteState()->psoScreen == psoSrc))
    {
        return(EngPlgBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca,
                         pptlBrush, pptfx, prcl, pptl, iMode));
    }

    if (pptfx[iLeft].x > pptfx[iLeft ^ 3].x)
    {
        iLeft ^= 3;
    }

    if (pptfx[iTop].y > pptfx[iTop ^ 3].y)
    {
        iTop ^= 3;
    }

    rclDraw.left   = LONG_FLOOR_OF_FIX(pptfx[iLeft].x) - 1;
    rclDraw.top    = LONG_FLOOR_OF_FIX(pptfx[iTop].y) - 1;
    rclDraw.right  = LONG_CEIL_OF_FIX(pptfx[iLeft ^ 3].x) + 1;
    rclDraw.bottom = LONG_CEIL_OF_FIX(pptfx[iTop ^ 3].y) + 1;

    ASSERTGDI((rclDraw.left < rclDraw.right) && (rclDraw.top < rclDraw.bottom),
        "Messed up bound calculation");

    ENUMUNDERLAYS Enum(psoDst, pco, &rclDraw);
    while (Enum.bEnum(&psoDst, &Offset, &pco))
    {
        bRet &= OffPlgBlt(PPFNDIRECT(psoDst, PlgBlt), &Offset, psoDst,
                          &gptlZero, psoSrc, psoMsk, pco, pxlo, pca, pptlBrush,
                          pptfx, prcl, pptl, iMode);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpGradientFill
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpGradientFill(
SURFOBJ*    pso,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
TRIVERTEX*  pVertex,
ULONG       nVertex,
PVOID       pMesh,
ULONG       nMesh,
RECTL*      prclExtents,
POINTL*     pptlDitherOrg,
ULONG       ulMode)
{
    BOOL    bRet = TRUE;
    POINTL  Offset;

    ENUMUNDERLAYS Enum(pso, pco, prclExtents);
    while (Enum.bEnum(&pso, &Offset, &pco))
    {
        bRet &= OffGradientFill(PPFNDIRECT(pso, GradientFill), &Offset, pso,
                                pco, pxlo, pVertex, nVertex, pMesh, nMesh,
                                prclExtents, pptlDitherOrg, ulMode);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpSaveScreenBits
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ULONG_PTR SpSaveScreenBits(
SURFOBJ*    pso,
ULONG       iMode,
ULONG_PTR   ident,
RECTL*      prclSave)
{
    SPRITESTATE*    pState;
    SURFACE*        pSurface;
    PTRACKOBJ       pto;
    PEWNDOBJ        pwo;
    BOOL            bIntersectsFunkyFormat;
    BOOL            bUnTearDown;
    DEVEXCLUDERECT  dxo;

    PDEVOBJ po(pso->hdev);
    po.vAssertDevLock();

    pState = po.pSpriteState();
    pSurface = SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen);

    // For the most part, SaveScreenBits is completely redundant and
    // handled perfectly fine by USER creating a compatible bitmap to
    // hold the backing bits.  However, there is one useful scenario
    // for SaveScreenBits: when it occurs on top of a funky pixel-format
    // window as used by some OpenGL hardware.  In that case, the window
    // format is not the same as the display, so information would be
    // lost if the bits weren't saved in the original format, which is
    // handled by the driver in DrvSaveScreenBits.
    //
    // So...  We expect funky pixel format WNDOBJs to have the NOSPRITES
    // attribute set, meaning we're not supposed to draw any sprites on
    // them.

    if ((pState->pfnSaveScreenBits == NULL) || (gpto == NULL))
        return(0);

    if (iMode == SS_SAVE)
    {
        // We must be holding the WNDOBJ semaphore before mucking
        // with any WNDOBJs.

        SEMOBJ so(ghsemWndobj);

        // See if any funky format WNDOBJ intersects with the requested
        // rectangle.

        bIntersectsFunkyFormat = FALSE;

        for (pto = gpto;
             (pto != NULL) && !bIntersectsFunkyFormat;
             pto = pto->ptoNext)
        {
            for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
            {
                // The WNDOBJ coordinates must be device-relative so
                // use UNDO:

                UNDODESKTOPCOORD udc(pwo, pState);

                if ((pwo->fl & WO_NOSPRITES) &&
                    bIntersect(&pwo->rclBounds, prclSave) &&
                    pwo->bInside(prclSave) == REGION_RECT_INTERSECT)
                {
                    bIntersectsFunkyFormat = TRUE;
                    break;
                }
            }
        }

        // If the requested save rectangle doesn't intersect with any
        // funky WNDOBJ, we can tell USER to revert to the sprite-friendly
        // comaptible-bitmap save-bits method by returning 0.

        if (!bIntersectsFunkyFormat)
            return(0);
    }

    // Tear down any sprites that may overlap the area.  This handles the
    // case where the requested save rectangle isn't entirely contained
    // within the WNDOBJ.

    if (iMode != SS_FREE)
        dxo.vExclude(pso->hdev, prclSave);

    return(pState->pfnSaveScreenBits(pso, iMode, ident, prclSave));
}

/******************************Public*Routine******************************\
* BOOL vSpHook
*
* Hooks into the DDI between GDI and the display driver to add an
* additional layer.  This only needs to be done when a sprite is
* visible on the screen (and we take advantage of this to unhook
* whenever possible, for better performance).
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpHook(
SPRITESTATE*    pState)
{
    PDEVOBJ     po(pState->hdev);
    PDEV*       ppdev = po.ppdev;
    SURFACE*    psurf = po.pSurface();

    ASSERTGDI(!pState->bHooked,
        "Should hook only if already unhooked");
    ASSERTGDI(pState->bInsideDriverCall,
        "SPRITELOCK should be held");

    // Note that the surface's 'iType' and 'flSurfFlags' fields won't
    // be modified to reflect the new state until the SPRITELOCK destructor.

    pState->iSpriteType = STYPE_DEVICE;

    // First, remove all HOOK_ flags for any drawing calls.  We do this
    // by removing all HOOK_FLAGS except HOOK_MOVEPANNING and HOOK_SYNCHRONIZE,
    // which aren't really drawing calls:

    pState->flSpriteSurfFlags = psurf->flags() & (~HOOK_FLAGS      |
                                                  HOOK_MOVEPANNING |
                                                  HOOK_SYNCHRONIZE);

    // Now add in all the flags for those drawing functions hooked by the
    // sprite layer.  Note that for performance reasons HOOK_STROKEANDFILLPATH
    // is not one of these (since no drivers hook DrvStrokeAndFillPath,
    // and EngStrokeAndFillPath isn't smart enough to call DrvStrokePath
    // and DrvFillPath separately, and so we would get no accelerated drawing):

    pState->flSpriteSurfFlags  |= (HOOK_BITBLT           |
                                   HOOK_STRETCHBLT       |
                                   HOOK_PLGBLT           |
                                   HOOK_TEXTOUT          |
                                   HOOK_STROKEPATH       |
                                   HOOK_FILLPATH         |
                                   HOOK_LINETO           |
                                   HOOK_COPYBITS         |
                                   HOOK_STRETCHBLTROP    |
                                   HOOK_TRANSPARENTBLT   |
                                   HOOK_ALPHABLEND       |
                                   HOOK_GRADIENTFILL);

    ppdev->apfn[INDEX_DrvStrokePath]        = (PFN) SpStrokePath;
    ppdev->apfn[INDEX_DrvFillPath]          = (PFN) SpFillPath;
    ppdev->apfn[INDEX_DrvBitBlt]            = (PFN) SpBitBlt;
    ppdev->apfn[INDEX_DrvCopyBits]          = (PFN) SpCopyBits;
    ppdev->apfn[INDEX_DrvStretchBlt]        = (PFN) SpStretchBlt;
    ppdev->apfn[INDEX_DrvTextOut]           = (PFN) SpTextOut;
    ppdev->apfn[INDEX_DrvLineTo]            = (PFN) SpLineTo;
    ppdev->apfn[INDEX_DrvTransparentBlt]    = (PFN) SpTransparentBlt;
    ppdev->apfn[INDEX_DrvAlphaBlend]        = (PFN) SpAlphaBlend;
    ppdev->apfn[INDEX_DrvPlgBlt]            = (PFN) SpPlgBlt;
    ppdev->apfn[INDEX_DrvGradientFill]      = (PFN) SpGradientFill;
    ppdev->apfn[INDEX_DrvDrawStream]        = (PFN) SpDrawStream;
    ppdev->apfn[INDEX_DrvStretchBltROP]     = (PFN) SpStretchBltROP;
    ppdev->apfn[INDEX_DrvSaveScreenBits]    = (PFN) SpSaveScreenBits;

    pState->bHooked = TRUE;

    // Calculate the regions of the screen that shouldn't be drawn upon:

    vSpComputeUnlockedRegion(pState);
}

/******************************Public*Routine******************************\
* BOOL vSpUnhook
*
* If there are no visible sprites, unhook from the DDI for better
* performance.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpUnhook(
SPRITESTATE*    pState)
{
    PDEVOBJ     po(pState->hdev);
    PDEV*       ppdev = po.ppdev;
    SURFACE*    psurf = po.pSurface();

    ASSERTGDI(pState->bHooked,
        "Should unhook only if already hooked");
    ASSERTGDI(pState->bInsideDriverCall,
        "SPRITELOCK should be held");

    // Note that the surface's 'iType' and 'flSurfFlags' fields won't
    // be modified to reflect the new state until the SPRITELOCK destructor.

    pState->iSpriteType       = pState->iOriginalType;
    pState->flSpriteSurfFlags = pState->flOriginalSurfFlags;

    ppdev->apfn[INDEX_DrvStrokePath]        = (PFN) pState->pfnStrokePath;
    ppdev->apfn[INDEX_DrvFillPath]          = (PFN) pState->pfnFillPath;
    ppdev->apfn[INDEX_DrvBitBlt]            = (PFN) pState->pfnBitBlt;
    ppdev->apfn[INDEX_DrvCopyBits]          = (PFN) pState->pfnCopyBits;
    ppdev->apfn[INDEX_DrvStretchBlt]        = (PFN) pState->pfnStretchBlt;
    ppdev->apfn[INDEX_DrvTextOut]           = (PFN) pState->pfnTextOut;
    ppdev->apfn[INDEX_DrvLineTo]            = (PFN) pState->pfnLineTo;
    ppdev->apfn[INDEX_DrvTransparentBlt]    = (PFN) pState->pfnTransparentBlt;
    ppdev->apfn[INDEX_DrvAlphaBlend]        = (PFN) pState->pfnAlphaBlend;
    ppdev->apfn[INDEX_DrvPlgBlt]            = (PFN) pState->pfnPlgBlt;
    ppdev->apfn[INDEX_DrvGradientFill]      = (PFN) pState->pfnGradientFill;
    ppdev->apfn[INDEX_DrvStretchBltROP]     = (PFN) pState->pfnStretchBltROP;
    ppdev->apfn[INDEX_DrvSaveScreenBits]    = (PFN) pState->pfnSaveScreenBits;
    ppdev->apfn[INDEX_DrvDrawStream]        = (PFN) pState->pfnDrawStream;

    pState->bHooked = FALSE;
}

/******************************Public*Routine******************************\
* BOOL bSpIsSystemMemory
*
* Simple little routine that returns TRUE if the surface is definitely
* in system memory; FALSE if it's likely in video memory.  (Video memory
* is slow when we have to read the surface, because reads over the bus
* are very painful.)
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline BOOL bSpIsSystemMemory(
SURFOBJ* pso)
{
    return((pso->iType == STYPE_BITMAP) && !(pso->fjBitmap & BMF_NOTSYSMEM));
}

/******************************Public*Routine******************************\
* VOID vSpCreateShape
*
* Allocates (if necessary) a new bitmap for the sprite, and copies it.
*
* Note: pSprite->psoShape will be NULL if this function fails!
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpCreateShape(
SPRITE*     pSprite,
POINTL*     pOffSrc,    // Offset associated with 'psoSrc'
SURFOBJ*    psoSrc,
XLATEOBJ*   pxlo,
RECTL*      prcl,
PALETTE*    ppalSrc,
ULONG       iFormat = 0,// May be '0' to select current screen format
ULONG       bWantSystemMemory = TRUE,
RECTL*      prclDirty = NULL)
                        // Requested type, STYPE_DEVBITMAP or STYPE_BITMAP.
{
    SURFOBJ*        psoShape;
    LONG            cxSrc;
    LONG            cySrc;
    POINTL          ptlSrc;
    PFN_DrvCopyBits pfnCopyBits;

    // First, handle the palette references:

    XEPALOBJ palNew(ppalSrc);
    XEPALOBJ palOld(pSprite->ppalShape);

    palNew.vRefPalette();
    palOld.vUnrefPalette();

    pSprite->ppalShape = ppalSrc;

    // Now, handle the bitmap:

    cxSrc = prcl->right - prcl->left;
    cySrc = prcl->bottom - prcl->top;

    if (iFormat == 0)
        iFormat = pSprite->pState->psoScreen->iBitmapFormat;

    // Note that we don't try to create a bitmap of type STYPE_DEVBITMAP
    // if we already have a perfectly satisfactory STYPE_BITMAP sitting
    // around.  We do this for the case where we might be low on video
    // memory, so that we don't keep re-allocating on every shape change.

    psoShape = pSprite->psoShape;
    if ((psoShape == NULL)                                    ||
        (!bSpIsSystemMemory(psoShape) && (bWantSystemMemory)) ||
        (psoShape->iBitmapFormat != iFormat)                  ||
        (psoShape->sizlBitmap.cx < cxSrc)                     ||
        (psoShape->sizlBitmap.cy < cySrc))
    {
        // Max thing again?  Or maybe hint?

        vSpDeleteSurface(psoShape);

        psoShape = psoSpCreateSurface(pSprite->pState,
                                      iFormat,
                                      cxSrc,
                                      cySrc,
                                      bWantSystemMemory);

        pSprite->psoShape = psoShape;
    }

    if (psoShape != NULL)
    {
        pSprite->OffShape.x  = -prcl->left;
        pSprite->OffShape.y  = -prcl->top;
        pSprite->iModeFormat = iFormat;
        pSprite->flModeMasks = palNew.flRed() | palNew.flBlu();

        // If they passed us a dirty rectangle, only copy bits on that rectangle
        ERECTL erclDirty = (ERECTL) *prcl;
        if (prclDirty)
        {
            erclDirty *= (*prclDirty);
        }

        if (!erclDirty.bEmpty())
        {
            // Calculate required source rectangle
            ERECTL erclSrc(erclDirty);
            erclSrc += *pOffSrc;
    
            MULTISURF   mSrc(psoSrc, &erclSrc);
    
            // Be sure to go through the DDI hooks and not directly to the Offset
            // functions so that we can read the surface from the multi-mon screen
            // and the like:
    
            if (SURFOBJ_TO_SURFACE_NOT_NULL(psoShape)->flags() & HOOK_CopyBits)
            {
                PDEVOBJ     poShape(psoShape->hdev);

                // WINBUG #415010 06-12-2001 jasonha  Properly fail shape update
                // If bLoadSource fails, we can not guarentee a cross-device
                // copy will succeed. Return failure by setting psoShape = NULL.

                if (!mSrc.bLoadSource(poShape.hdev()))
                {
                    vSpDeleteSurface(pSprite->psoShape);
                    pSprite->psoShape = NULL;
                    return;
                }
                else
                {
                    pfnCopyBits = PPFNDRV(poShape,CopyBits);
                }
            }
            else
            {
                PDEVOBJ poSrc(psoSrc->hdev);
                pfnCopyBits = PPFNGET(poSrc,
                                      CopyBits,
                                      SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc)->flags());
            }

            OffCopyBits(pfnCopyBits, &pSprite->OffShape, psoShape, &gptlZero, mSrc.pso,
                        NULL, pxlo, (RECTL*) &erclDirty, mSrc.pptl());
        }
    }
}

/******************************Public*Routine******************************\
* VOID vSpDeleteShape
*
* Deletes any shape surfaces associated with the sprite.  Note that this
* does NOT delete the sprite itself.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDeleteShape(
SPRITE* pSprite)
{
    if (pSprite->ppalShape != NULL)
    {
        XEPALOBJ palShape(pSprite->ppalShape);
        palShape.vUnrefPalette();
        pSprite->ppalShape = NULL;
    }
    if (pSprite->psoShape != NULL)
    {
        vSpDeleteSurface(pSprite->psoShape);
        pSprite->psoShape = NULL;
    }
}

/******************************Public*Routine******************************\
* BOOL bSpUpdateAlpha
*
* Parses the BLENDFUNCTION parameter passed in, to ensure that it is
* consistent with the type that the sprite originally was created as.
*
* Returns FALSE if the specified BLENDFUNCTION cannot be allowed, because
* of an improper flag or because it's not consistent with the sprite type.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpUpdateAlpha(
SPRITE*         pSprite,
BLENDFUNCTION*  pblend,
BOOL            bUpdateOnlyAlpha)
{
    BOOL bRet = FALSE;

    // Note that we don't allow the AC_SRC_ALPHA status to be different
    // from the previous AC_SRC_ALPHA status.

    if ((pblend->BlendOp != AC_SRC_OVER)                  ||
             (pblend->BlendFlags != 0)                    ||
             ((pblend->AlphaFormat & ~AC_SRC_ALPHA) != 0))
    {
        WARNING("bSpUpdateAlpha: Invalid alpha");
    }
    else if (((pSprite->dwShape & ULW_ALPHA) == 0) &&
             (pSprite->psoShape != NULL))
    {
        WARNING("bSpUpdateAlpha:  dwShape must be ULW_ALPHA");
    }
    else
    {
        bRet = TRUE;

        if (bUpdateOnlyAlpha)
            pSprite->BlendFunction.SourceConstantAlpha =
                pblend->SourceConstantAlpha;
        else
            pSprite->BlendFunction = *pblend;

        pSprite->dwShape &= ~ULW_OPAQUE;
        pSprite->dwShape |= ULW_ALPHA;

        // When trying to display a sprite at 8bpp, always render
        // it opaque.  It beats displaying a crappy image slowly.

        if ((pSprite->pState->iModeFormat <= BMF_8BPP) ||
            (!(pblend->AlphaFormat & AC_SRC_ALPHA) &&
             (pblend->SourceConstantAlpha == 0xff)))
        {
            pSprite->fl |= SPRITE_FLAG_EFFECTIVELY_OPAQUE;
        }
        else
        {
            pSprite->fl &= ~SPRITE_FLAG_EFFECTIVELY_OPAQUE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vSpUpdatePerPixelAlphaFromColorKey
*
* Given a 32bpp surface, turns every pixel matching the transparent
* color transparent, and turns every pixel not matching the transparent
* color opaque.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpUpdatePerPixelAlphaFromColorKey(
SURFOBJ*    pso,
ULONG       rgbTransparent,
RECTL*      prclDirty)
{
    LONG    i;
    LONG    j;
    BYTE*   pScan;
    ULONG*  pul;
    ULONG   ulTransparent;
    LONG    lDelta;
    LONG    cx, cy;

    ASSERTGDI((pso->iBitmapFormat == BMF_32BPP) && (pso->iType == STYPE_BITMAP),
        "Expected readable 32bpp ARGB surface only");

    ulTransparent = ((rgbTransparent & 0xff0000) >> 16)
                  | ((rgbTransparent & 0x00ff00))
                  | ((rgbTransparent & 0x0000ff) << 16);

    ERECTL erectlDirty(0, 0, pso->sizlBitmap.cx, pso->sizlBitmap.cy);

    if (prclDirty)
    {
        // If the caller gives us a dirty rectangle, intersect it with the
        // surface rectangle.

        erectlDirty *= (*prclDirty);
    }

    lDelta = pso->lDelta;
    cx = erectlDirty.right  - erectlDirty.left;
    cy = erectlDirty.bottom - erectlDirty.top;

    for (j = cy, pScan = ((BYTE*) pso->pvScan0) + erectlDirty.top * lDelta +
                                                + erectlDirty.left * sizeof(ULONG);
         j != 0;
         j--, pScan += lDelta)
    {
        for (i = cx, pul = (ULONG*) pScan;
             i != 0;
             i--, pul++)
        {
            if (*pul == ulTransparent)
            {
                // Write a pre-multiplied value of 0:

                *pul = 0;
            }
            else
            {
                // Where the bitmap is not the transparent color, change
                // the alpha value to opaque:

                ((RGBQUAD*) pul)->rgbReserved = 0xff;
            }
        }
    }
}

/******************************Public*Routine******************************\
* BOOL bSpUpdateShape
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpUpdateShape(
SPRITE*         pSprite,
DWORD           dwShape,
HDC             hdcDst,
HDC             hdcSrc,
COLORREF        crKey,
BLENDFUNCTION*  pblend,
POINTL*         pptlSrc,
SIZEL*          psizl,
RECTL*          prclDirty)
{
    BOOL            bStatus = FALSE;        // Assume failure
    SPRITESTATE*    pState;
    SURFACE*        psurfSrc;
    RECTL           rclSrc;
    PALETTE*        ppalDst;
    PALETTE*        ppalDstDC;
    ULONG           iFormat;
    ULONG           crTextClr;
    ULONG           crBackClr;
    LONG            lIcmMode;
    BOOL            bWantVideoMemory;
    BOOL            bColorKeyAlpha;
    ULONG           iSrcTransparent;
    BLENDFUNCTION   blend;

    pState = pSprite->pState;
    PDEVOBJ po(pState->hdev);

    // Note that only kerne-mode callers can specify ULW_DRAGRECT, so we
    // don't have to be as paranoid about checking parameters for this
    // case.

    if (dwShape == ULW_DRAGRECT)
    {
        // Note that there's not really a source surface, so this is a
        // little faked.

        pSprite->dwShape       = dwShape;
        pSprite->rclSrc.left   = 0;
        pSprite->rclSrc.right  = psizl->cx;
        pSprite->rclSrc.top    = 0;
        pSprite->rclSrc.bottom = psizl->cy;
        pSprite->iModeFormat   = pState->iModeFormat;
        pSprite->flModeMasks   = pState->flModeMasks;

        return(TRUE);
    }

    if (dwShape == 0)
    {
       dwShape = pSprite->dwShape;
       pblend = &pSprite->BlendFunction;
    }

    if ((pptlSrc == NULL) ||
        (psizl == NULL)   ||
        ((pblend == NULL) && (dwShape & ULW_ALPHA)))
    {
        WARNING("bSpUpdateShape: Invalid NULL parameter");
        return(bStatus);
    }

    // The supplied source DC has to either belong to the same PDEV as the
    // sprite, or it has to belong to the multi-monitor meta-PDEV.  This is
    // because we do not support the S3 driver reading a device bitmap owned
    // by the MGA driver, for example.

    DCOBJ dcoSrc(hdcSrc);
    if (!dcoSrc.bValid() ||
        dcoSrc.bFullScreen() ||
        ((dcoSrc.hdev() != pState->hdev) && (dcoSrc.hdev() != po.hdevParent())))
    {
        WARNING("bSpUpdateShape: Invalid source DC");
        return(bStatus);
    }

    if (hdcDst == 0)
    {
        // Supply some default information for the palette:

        ppalDstDC = ppalDefault;
        crTextClr = 0x00ffffff;
        crBackClr = 0;
        lIcmMode  = 0;
    }
    else
    {
        // Note that with multi-mon, the destination DC may be for a separate
        // PDEV than our own PDEV.  That is, the destination DC may be
        // associated with the meta-PDEV while we're drawing to a specific
        // PDEV.  This is okay.  All we'll be pulling out of the source DC
        // is some palette information.

        DCOBJ dcoDst(hdcDst);
        if (!dcoDst.bValid()                 ||
            (dcoDst.hdev() != dcoSrc.hdev()) ||
            ((dcoDst.hdev() != pState->hdev) && (dcoDst.hdev() != po.hdevParent())))
        {
            WARNING("bSpUpdateShape: Invalid destination DC");
            return(bStatus);
        }

        ppalDstDC = dcoDst.ppal();
        crTextClr = dcoDst.pdc->crTextClr();
        crBackClr = dcoDst.pdc->crBackClr();
        lIcmMode  = dcoDst.pdc->lIcmMode();
    }

    rclSrc.left   = pptlSrc->x;
    rclSrc.right  = pptlSrc->x + psizl->cx;
    rclSrc.top    = pptlSrc->y;
    rclSrc.bottom = pptlSrc->y + psizl->cy;

    psurfSrc = dcoSrc.pSurface();
    if ((psurfSrc != NULL)                     &&
        (rclSrc.left   >= 0)                   &&
        (rclSrc.top    >= 0)                   &&
        (rclSrc.left    < rclSrc.right)        &&
        (rclSrc.top     < rclSrc.bottom)       &&
        (rclSrc.right  <= psurfSrc->sizl().cx) &&
        (rclSrc.bottom <= psurfSrc->sizl().cy))
    {
        // Clip prclDirty to the source surface
        if (prclDirty)
        {
            (*((ERECTL *) prclDirty)) *=
                ERECTL(0, 0, psurfSrc->sizl().cx, psurfSrc->sizl().cy);
        }

        EXLATEOBJ   xlo;
        XEPALOBJ    palSrcDC(dcoSrc.ppal());
        XEPALOBJ    palSrc(psurfSrc->ppal());
        XEPALOBJ    palRGB(gppalRGB);

        // If both ULW_ALPHA and ULW_COLORKEY are specified, then any
        // pixels that match the color-key are completely transparent,
        // and all other pixels have an alpha value of the global alpha
        // specified.
        //
        // Since we don't have any low-level color-keyed-alpha-code, we
        // simply convert this case to using per-pixel alpha.

        bColorKeyAlpha = ((dwShape == (ULW_ALPHA | ULW_COLORKEY)) &&
                          (pblend->AlphaFormat == 0));

        if (bColorKeyAlpha)
        {
            blend = *pblend;
            blend.AlphaFormat = AC_SRC_ALPHA;
            pblend = &blend;
            dwShape = ULW_ALPHA;

            bColorKeyAlpha = TRUE;

            iSrcTransparent = rgbFromColorref(palRGB,
                                              palSrcDC,
                                              crKey);
        }

        // See whether we should make the sprite 32bpp, or convert it to
        // being the same format as the screen:

        if ((dwShape == ULW_ALPHA) && (pblend->AlphaFormat & AC_SRC_ALPHA))
        {
            iFormat   = BMF_32BPP;
            ppalDst   = gppalRGB;
            ppalDstDC = ppalDefault;
        }
        else
        {
            iFormat = 0;
            ppalDst = po.ppalSurf();    // Don't use dcoDst.ppal() because
                                        //   with multimon, this may be the
        }                               //   wrong PDEV

        XEPALOBJ palDstDC(ppalDstDC);
        XEPALOBJ palDst(ppalDst);

        if (xlo.bInitXlateObj(NULL,
                              lIcmMode,
                              palSrc,
                              palDst,
                              palSrcDC,
                              palDstDC,
                              crTextClr,
                              crBackClr,
                              0))
        {
            bStatus = TRUE;

            pSprite->dwShape = dwShape;
            pSprite->rclSrc  = rclSrc;

            if (dwShape == ULW_OPAQUE)
            {
                pSprite->fl   |= SPRITE_FLAG_EFFECTIVELY_OPAQUE;
                bWantVideoMemory = TRUE;
            }
            else if (dwShape == ULW_COLORKEY)
            {
                // Transparency is of course specified using the
                // source DC palette.

                iSrcTransparent = ulGetNearestIndexFromColorref(
                                        palSrc,
                                        palSrcDC,
                                        crKey);

                // ...but we're about to copy the source bitmap to a
                // format that is the same as the screen.  So we have
                // to pipe the transparency color through the same
                // conversion that the pixels on the blt go through.
                //
                // Note that this is NOT equivalent to doing:
                //
                //     iTransparent = ulGetNearestIndexFromColorref(
                //                          palDst,
                //                          palDstDC,
                //                          crKey)
                //
                // Converting to a compatible bitmap may cause us to
                // increase the transparency color gamut (think of a
                // 24bpp color wash being blt'd with a transparency
                // key to 4bpp).  But we do this for two reasons:
                //
                // 1. The shape bitmap is always stored in the same
                //    format as the screen, and so may be kept by the
                //    driver in off-screen memory and thus be accelerated;
                // 2. On dynamic mode changes, we don't have to keep
                //    the source DC palette and source surface palette
                //    around to re-compute the proper translate.

                pSprite->iTransparent = XLATEOBJ_iXlate(xlo.pxlo(),
                                                        iSrcTransparent);

                pSprite->fl &= ~SPRITE_FLAG_EFFECTIVELY_OPAQUE;

                bWantVideoMemory
                    = (po.flAccelerated() & ACCELERATED_TRANSPARENT_BLT);
            }
            else if (dwShape == ULW_ALPHA)
            {
                if (!bSpUpdateAlpha(pSprite, pblend, FALSE))
                {
                    bStatus = FALSE;
                }
                else if ((pblend->AlphaFormat & AC_SRC_ALPHA) &&
                         !bIsSourceBGRA(psurfSrc) &&
                         !bColorKeyAlpha)
                {
                    bStatus = FALSE;
                }
                else if (bColorKeyAlpha)
                {
                    // We need to be able to directly muck on the bits,
                    // so we don't want video memory:

                    bWantVideoMemory = FALSE;
                }
                else if (pblend->AlphaFormat & AC_SRC_ALPHA)
                {
                    bWantVideoMemory
                        = (po.flAccelerated() & ACCELERATED_PIXEL_ALPHA);
                }
                else
                {
                    // There's no per-pixel alpha, so we should convert the
                    // bitmap to the video card's preferred format (namely,
                    // whatever the format of the primary is).

                    bWantVideoMemory
                        = (po.flAccelerated() & ACCELERATED_CONSTANT_ALPHA);
                }
            }
            else
            {
                WARNING("bSpUpdateShape: Bad shape");
                bStatus = FALSE;
            }

            if (bStatus)
            {
                // For multi-mon, if the source is the meta-screen, we
                // can't blt to a device surface because the two surfaces
                // would belong to different PDEVs.  Since I'm lazy, I'll
                // simply enforce that one of the surfaces is not a device
                // surface, when multi-mon:

#if 0           // WINBUG 315863/320834: We are leaving this old code till fixes for these bugs bake. We will remove these once the new code has baked,
                if ((psurfSrc->iType() == STYPE_DEVICE) &&
                    (po.hdevParent() != po.hdev()))   // Child PDEV
                {
                    bWantVideoMemory = FALSE;
                }
                else if ((psurfSrc->iType() == STYPE_DEVBITMAP) &&
                         (po.hdevParent() != po.hdev()) &&
                         (po.flGraphicsCaps() & GCAPS_LAYERED))
                {
                    // We are given a meta dfb as source and want to update
                    // the shape for a mirrored device sprite. Use the meta
                    // dfb's corresponding mirror dev bitmap as source.
                   
                    PSURFACE psurfSrcTmp;
                    psurfSrcTmp = MulGetDevBitmapFromMasterDFB(psurfSrc,po.hdev());
                    if (psurfSrcTmp)
                        psurfSrc = psurfSrcTmp;
                    else
                    {
                        // We dont have a mirror dev bitmap. Use the master meta
                        // dfb after uncloaking it:

                        mSrc.vUnCloak(psurfSrc->pSurfobj());
                    }
                }
#endif

                // If the requested operation isn't accelerated, we convert
                // the source bitmap to a true DIB.  We do this on the
                // assumption that the application is animating, and will
                // soon call us again with the same bitmap:

                if ((!bWantVideoMemory) && !bSpIsSystemMemory(psurfSrc->pSurfobj()))
                {
                    // We don't care if the operation fails, as it was only a
                    // performance hint:

                    bConvertDfbDcToDib(&dcoSrc);

                    psurfSrc = dcoSrc.pSurface();
                }

                if (bStatus)
                {
                    // We temporarily reset the 'bInsideDriverCall' flag for the
                    // duration of 'vSpCreateShape' so that the read from the source
                    // will be correctly handled if the source is actually the
                    // screen.  We do this so that we don't capture the contents of
                    // other sprites when this happens.

                    ASSERTGDI(pState->bInsideDriverCall, "Expected sprite lock held");

                    vSpDirectDriverAccess(pState, FALSE);

                    vSpCreateShape(pSprite,
                                   &gptlZero,
                                   psurfSrc->pSurfobj(),
                                   xlo.pxlo(),
                                   &rclSrc,
                                   ppalDst,
                                   iFormat,
                                   !bWantVideoMemory,
                                   prclDirty);

                    // Restore the direct driver access state:

                    vSpDirectDriverAccess(pState, TRUE);
                }
            }

            if ((bStatus) && (pSprite->psoShape != NULL))
            {
                // Oh happy times, we succeeded.

                if (bColorKeyAlpha)
                {
                    // Anywhere the color-key is, convert it to transparent.
                    // Anywhere the color-key isn't, make it opaque:

                    vSpUpdatePerPixelAlphaFromColorKey(pSprite->psoShape,
                                                       iSrcTransparent,
                                                       prclDirty);
                }
            }
            else
            {
                // Uh oh, something failed.  We have to delete the sprite
                // now because we may have partially wacked some of our
                // pSprite state.

                vSpDeleteShape(pSprite);
                pSprite->dwShape = ULW_OPAQUE; // reset dwShape to
                                               // something innocuous
                bStatus = FALSE;
            }
        }
    }
    else
    {
        WARNING("bSpUpdateShape: Bad DCs or rectangles");
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* VOID vSpTransferShape
*
* Creates a shape for a new sprite that is a copy of the old.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpTransferShape(
SPRITE* pSpriteNew,
SPRITE* pSpriteOld)
{
    ASSERTGDI(pSpriteNew->psoShape == NULL,
        "Expected new sprite to have no resources");

    // Transfer HIDDEN state to the new sprite
    pSpriteNew->fl |= pSpriteOld->fl & SPRITE_FLAG_HIDDEN;

    if (pSpriteOld->psoShape != NULL)
    {
        // This will allocate a new sprite bitmap and copy it.  Why not
        // simply transfer 'psoShape' from the old sprite to the new?
        // Because it may be a device bitmap!

        vSpCreateShape(pSpriteNew,
                       &pSpriteOld->OffShape,
                       pSpriteOld->psoShape,
                       NULL,
                       &pSpriteOld->rclSrc,
                       pSpriteOld->ppalShape,
                       pSpriteOld->psoShape->iBitmapFormat,
                       TRUE);   // TRUE because by storing the sprite in
                                // system memory, we avoid the 'Both surfaces
                                // are unreadable and owned by different
                                // PDEVs" assert in vSpCreateShape

        pSpriteNew->dwShape       = pSpriteOld->dwShape;
        pSpriteNew->rclSrc        = pSpriteOld->rclSrc;
        pSpriteNew->iTransparent  = pSpriteOld->iTransparent;
        pSpriteNew->BlendFunction = pSpriteOld->BlendFunction;
    }

    // Transfer the cached attributes to the new sprite
    pSpriteNew->cachedAttributes  = pSpriteOld->cachedAttributes;
}

/******************************Public*Routine******************************\
* BOOL SpUpdatePosition
*
* NOTE: pSprite->psoShape may very well be NULL when entering this
*       function!
*
* NOTE: This function must never fail when hiding the sprite (because
*       that's used for cleanup and error handling)
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpUpdatePosition(
SPRITE*         pSprite,
POINTL*         pptlDst,                        // May be NULL
BOOL            bLeaveBits = FALSE)
{
    GDIFunctionID(bSpUpdatePosition);

    BOOL            bStatus = TRUE;             // Assume success
    SPRITESTATE*    pState;
    ERECTL          rclSprite;
    RECTL*          prcl;
    ULONG           crcl;
    LONG            cxSprite;
    LONG            cySprite;
    SURFOBJ*        psoUnderlay;
    SURFOBJ*        psoShape;
    LONG            dx;
    LONG            dy;
    RECTL           rclExclude;
    POINTL          OffUnderlay;
    BOOL            bWantSystemMemory;
    RECTL           rclOldSprite;
    POINTL          lastDst;
    FLONG           flNewVisibility;
     
    pState = pSprite->pState;

    lastDst = pSprite->ptlDst;

    if (pptlDst == NULL)
    {
        rclSprite.bottom = LONG_MIN;
    }
    else
    {
        // Remember the original position for later.

        pSprite->ptlDst.x = pptlDst->x;
        pSprite->ptlDst.y = pptlDst->y;

        // Note that our handy 'bIntersect' routine will handle the
        // cases where 'pptlDst' is too big, causing these adds to
        // overflow.

        rclSprite.left   = pptlDst->x;
        rclSprite.top    = pptlDst->y;
        rclSprite.right  = pptlDst->x
                         + (pSprite->rclSrc.right - pSprite->rclSrc.left);
        rclSprite.bottom = pptlDst->y
                         + (pSprite->rclSrc.bottom - pSprite->rclSrc.top);
    }

    // Non-visible sprites have a sprite rectangle of (LONG_MIN, LONG_MIN,
    // LONG_MIN, LONG_MIN), which  is depended upon by
    // vSpComputeSpriteRanges:

    if ((pSprite->fl & (SPRITE_FLAG_CLIPPING_OBSCURED | SPRITE_FLAG_HIDDEN)) ||
        !bIntersect(&pState->rclScreen, &rclSprite, &rclSprite)
        )
    {
        rclSprite.left   = LONG_MIN;
        rclSprite.top    = LONG_MIN;
        rclSprite.right  = LONG_MIN;
        rclSprite.bottom = LONG_MIN;
        flNewVisibility    = 0;
    }
    else
    {
        flNewVisibility    = SPRITE_FLAG_VISIBLE;
    }

    // WINBUG #368282 05-12-2001 jasonha  Correctly maintain cVisible count
    //   If an invisible sprite was to be made visible, but the creation
    //   of the underlay failed, then it would be included in the cVisible
    //   count during the first bSpUpdatePosition call, but not removed
    //   during the recursive call to hide the sprite since
    //   pSprite->rclSprite would still be empty at all LONG_MIN's.
    //  SPRITE_FLAG_VISIBLE is used to represent inclusion in cVisible.

    // If the uncovered region has changed, handle the underlay buffer:

    if ((flNewVisibility  != (pSprite->fl & SPRITE_FLAG_VISIBLE)) ||
        (rclSprite.left   != pSprite->rclSprite.left  ) ||
        (rclSprite.top    != pSprite->rclSprite.top   ) ||
        (rclSprite.right  != pSprite->rclSprite.right ) ||
        (rclSprite.bottom != pSprite->rclSprite.bottom))
    {
        // If the old sprite was visible, decrement the visible sprite
        // count:

        if (pSprite->fl & SPRITE_FLAG_VISIBLE)
        {
            ASSERTGDI(pState->cVisible != 0, "Messed up cVisible count");
            pState->cVisible--;
            pSprite->fl &= ~SPRITE_FLAG_VISIBLE;
#if DEBUG_SPRITES
            {
                ASSERTGDI(pState->pListVisible != NULL, "Invalid visible sprite list: pState->pListVisible == NULL when removing sprite.\n");

                if (pState->cVisible == 0)
                {
                    ASSERTGDI(pState->pListVisible == pSprite, "Invalid visible sprite list: pState->pListVisible != pSprite when removing last sprite.\n");
                    ASSERTGDI(pSprite->pNextVisible == NULL, "Invalid visible sprite list: pSprite->pNextVisible != NULL when removing last sprite.\n");
                    pState->pListVisible = pSprite->pNextVisible;
                }
                else
                {
                    if (pState->pListVisible == pSprite)
                    {
                        pState->pListVisible = pSprite->pNextVisible;
                    }
                    else
                    {
                        SPRITE *pPrevSprite = pState->pListVisible;

                        while (pPrevSprite->pNextVisible != pSprite)
                        {
                            ASSERTGDI(pPrevSprite->pNextVisible != NULL, "Invalid visible sprite list: didn't find sprite in list.\n");
                            pPrevSprite = pPrevSprite->pNextVisible;
                        }

                        pPrevSprite->pNextVisible = pSprite->pNextVisible;
                    }

                    ASSERTGDI(pState->pListVisible != NULL, "Invalid visible sprite list: pState->pListVisible == NULL after removing non-last sprite.\n");

                    pSprite->pNextVisible = NULL;
                }
            }
#endif
        }

        // If we're shrinking this sprite in any dimension, redraw the newly
        // unobscured portions.  Be sure to watch for the failure case where
        // 'psoUnderlay' might not have been allocated:

        if ((pSprite->psoUnderlay) && (!bLeaveBits))
        {
            vSpRedrawUncoveredArea(pSprite, &rclSprite);
        }
        else if (bLeaveBits)
        {
            // Otherwise we should blit the sprite bits onto its position
            // which will have the effect of updating the underlay bits
            // for the overlapping sprites.  See bug #252464.

            CLIPOBJ* pco;
            ECLIPOBJ eco;

            if (pSprite->prgnClip)
            {
                eco.vSetup(pSprite->prgnClip, *((ERECTL *) &pSprite->rclSprite));
                pco = &eco;
            }
            else
            {
                pco = NULL;
            }

            // Disable direct driver access for the duration of the
            // SpCopyBits call so that we will be able to enumerate
            // the sprites (see ENUMUNDERLAYS constructor).

            ASSERTGDI(pState->bInsideDriverCall, "Expected sprite lock held");
            vSpDirectDriverAccess(pState, FALSE);

            if((!pco || (!eco.erclExclude().bEmpty())) &&
               (pSprite->psoShape))
            {
                // Let's not worry about setting up a color translation because
                // the format of the sprite and the screen should be the same
                // (only exception is for per pixel alpha sprites, but these
                // shouldn't be using the ULW_NOREPAINT flag).  However,
                // it won't hurt to check here anyway and if not true no big deal
                // if we don't update the underlay bits.

                if(pState->psoScreen->iBitmapFormat ==
                   pSprite->psoShape->iBitmapFormat)
                {
                    POINTL   pt;

                    // WINFIX #96696 bhouse 4-14-2000
                    // Use the correct source point, rclSprite may have been
                    // clipped.

                    pt.x = pSprite->rclSprite.left - lastDst.x;
                    pt.y = pSprite->rclSprite.top - lastDst.y;

                    SpCopyBits(pState->psoScreen,
                               pSprite->psoShape,
                               pco,
                               NULL,
                               &pSprite->rclSprite,
                               &pt);
                }
                else
                {
                    WARNING("bSpUpdatePosition: not updating underlay bits");
                }
            }

            // Restore direct driver access

            vSpDirectDriverAccess(pState, TRUE);
        }

        cxSprite = rclSprite.right - rclSprite.left;
        cySprite = rclSprite.bottom - rclSprite.top;

        if (cxSprite == 0)
        {
            // The sprite is not visible, which may have been caused by
            // disabling the sprite.  Check to see if there are no other
            // sprites on the screen, which would allow us to unhook the
            // DDI:

            if ((pState->cVisible == 0) && (pState->bHooked))
                vSpUnhook(pState);
        }
        else
        {
            ASSERTGDI(cySprite != 0, "If cxSprite is 0, expected cySprite is 0");

            // Since the new sprite is visible, increment the visible sprite
            // count:

            ASSERTGDI(!(pSprite->fl & SPRITE_FLAG_VISIBLE), "Invalid sprite visible state: making visible again.\n");
            pSprite->fl |= SPRITE_FLAG_VISIBLE;
            pState->cVisible++;
#if DEBUG_SPRITES
            {
                ASSERTGDI(pSprite->pNextVisible == NULL, "Invalid visible sprite list: pSprite->pNextVisible != NULL when adding to visible list.\n");

                if (pState->cVisible == 1)
                {
                    ASSERTGDI(pState->pListVisible == NULL, "Invalid visible sprite list: pState->pListVisible != NULL when adding first sprite.\n");
                }
                else
                {
                    ASSERTGDI(pState->pListVisible != NULL, "Invalid visible sprite list: pState->pListVisible == NULL when adding non-first sprite.\n");
                }

                pSprite->pNextVisible = pState->pListVisible;
                pState->pListVisible = pSprite;
            }
#endif

            // If the DDI isn't already hooked, do it now.  This has to
            // occur before we update the shape on the screen, because
            // it recalculates prgnUnlocked, which must be respected
            // whenever we write to the screen.

            if (!pState->bHooked)
                vSpHook(pState);

            // Check to see if the old underlay buffer will do.

            psoUnderlay = pSprite->psoUnderlay;
            if ((psoUnderlay == NULL)                   ||
                (cxSprite > psoUnderlay->sizlBitmap.cx) ||
                (cySprite > psoUnderlay->sizlBitmap.cy))
            {
                // There is no old underlay surface, or it's not large
                // enough, so allocate a new underlay structure.
                //
                // Note that we don't free the old underlay surface yet,
                // because we need it for the 'bSpBltFromScreen' we're
                // about to do!

            #if DEBUG_SPRITES

                if (psoUnderlay != NULL)
                    KdPrint(("Growing psoUnderlay: %p  Old: (%li, %li)  New: (%li, %li)\n",
                         psoUnderlay, psoUnderlay->sizlBitmap.cx, psoUnderlay->sizlBitmap.cy,
                         cxSprite, cySprite));

            #endif

                // Because alphablends require read-modify-write operations
                // on the destination, it's a horrible performance penalty
                // if we create the compositing surface in video memory and
                // the device doesn't support accelerated alpha.  Similarly,
                // we don't want to have the underlay surface in video memory
                // if the compositing surface is in system memory.  So check
                // here if alpha isn't accelerated, and simply create the
                // underlay in system memory.

                bWantSystemMemory = FALSE;
                if (pSprite->dwShape == ULW_ALPHA)
                {
                    PDEVOBJ po(pState->hdev);

                    if (pSprite->BlendFunction.AlphaFormat & AC_SRC_ALPHA)
                    {
                        if (!(po.flAccelerated() & ACCELERATED_PIXEL_ALPHA))
                        {
                            bWantSystemMemory = TRUE;
                        }
                    }
                    else
                    {
                        if (!(po.flAccelerated() & ACCELERATED_CONSTANT_ALPHA))
                        {
                            bWantSystemMemory = TRUE;
                        }
                    }
                }

                {
                    PDEVOBJ po(pState->hdev);
                    if (po.flGraphicsCaps() & GCAPS_LAYERED)
                        bWantSystemMemory = TRUE;
                }

                psoUnderlay = psoSpCreateSurface(
                                    pState,
                                    0,
                                    max(cxSprite, pSprite->sizlHint.cx),
                                    max(cySprite, pSprite->sizlHint.cy),
                                    bWantSystemMemory);
                if (!psoUnderlay)
                {
                    // Uh oh, we couldn't allocate the underlay buffer, so
                    // we won't be able to show the sprite.  We'll handle this
                    // by simply marking the sprite as invisible later on:

                    bStatus = FALSE;
                }
                else
                {
                    psoUnderlay->fjBitmap |= BMF_DONTCACHE;

                    // We have turned off BMF_SPRITE support (it appears to
                    // be unused)
                    // psoUnderlay->fjBitmap |= BMF_SPRITE;


                    OffUnderlay.x = -rclSprite.left;
                    OffUnderlay.y = -rclSprite.top;

                    // Get the bits underneath where the sprite will appear:

                    if (((cxSprite <= SMALL_SPRITE_DIMENSION) &&
                         (cySprite <= SMALL_SPRITE_DIMENSION)))
                    {
                        vSpSmallUnderlayCopy(pSprite,
                                             &OffUnderlay,
                                             psoUnderlay,
                                             &pSprite->OffUnderlay,
                                             pSprite->psoUnderlay,
                                             0,
                                             0,
                                             &rclSprite,
                                             &pSprite->rclSprite);
                   }
                    else
                    {
                        vSpBigUnderlayCopy(pState,
                                           &OffUnderlay,
                                           psoUnderlay,
                                           &rclSprite);
                    }

                    // Okay, we can now safely delete the old underlay:

                    vSpDeleteSurface(pSprite->psoUnderlay);
                    pSprite->psoUnderlay = psoUnderlay;
                    pSprite->OffUnderlay = OffUnderlay;

                    pSprite->rclUnderlay.left   = rclSprite.left;
                    pSprite->rclUnderlay.top    = rclSprite.top;
                    pSprite->rclUnderlay.right  = rclSprite.left
                                                + psoUnderlay->sizlBitmap.cx;
                    pSprite->rclUnderlay.bottom = rclSprite.top
                                                + psoUnderlay->sizlBitmap.cy;
                }
            }
            else
            {
                // Okay, we know the old underlay surface was already big
                // enough.  See if we have to read some bits from the screen
                // to update the underlay, either because the sprite moved
                // or because it got larger:

                if ((rclSprite.left   < pSprite->rclSprite.left  ) ||
                    (rclSprite.top    < pSprite->rclSprite.top   ) ||
                    (rclSprite.right  > pSprite->rclSprite.right ) ||
                    (rclSprite.bottom > pSprite->rclSprite.bottom))
                {
                    dx = 0;
                    dy = 0;

                    if (rclSprite.left < pSprite->rclUnderlay.left)
                        dx = rclSprite.left - pSprite->rclUnderlay.left;
                    else if (rclSprite.right > pSprite->rclUnderlay.right)
                        dx = rclSprite.right - pSprite->rclUnderlay.right;

                    if (rclSprite.top < pSprite->rclUnderlay.top)
                        dy = rclSprite.top - pSprite->rclUnderlay.top;
                    else if (rclSprite.bottom > pSprite->rclUnderlay.bottom)
                        dy = rclSprite.bottom - pSprite->rclUnderlay.bottom;

                    // Note that 'dx' and 'dy' may still both be zero.

                    pSprite->rclUnderlay.left   += dx;
                    pSprite->rclUnderlay.right  += dx;
                    pSprite->rclUnderlay.top    += dy;
                    pSprite->rclUnderlay.bottom += dy;

                    ASSERTGDI(
                        (pSprite->rclUnderlay.left   <= rclSprite.left) &&
                        (pSprite->rclUnderlay.top    <= rclSprite.top) &&
                        (pSprite->rclUnderlay.right  >= rclSprite.right) &&
                        (pSprite->rclUnderlay.bottom >= rclSprite.bottom),
                            "Improper rclUnderlay");

                    // I figure that on a move, the delta will typically be
                    // fairly small, so we'll always call 'vSpSmallUnderlayCopy'
                    // instead of 'bSpBltFromScreen' for this case.

                    pSprite->OffUnderlay.x = -pSprite->rclUnderlay.left;
                    pSprite->OffUnderlay.y = -pSprite->rclUnderlay.top;

                    vSpSmallUnderlayCopy(pSprite,
                                         &pSprite->OffUnderlay,
                                         pSprite->psoUnderlay,
                                         &pSprite->OffUnderlay,
                                         pSprite->psoUnderlay,
                                         dx,
                                         dy,
                                         &rclSprite,
                                         &pSprite->rclSprite);
                }
            }
        }

        if (bStatus)
        {
            rclOldSprite = pSprite->rclSprite;

            // Finally, update the sprite rectangle and mark the range cache
            // as being invalid.  Note that we do this only in the case when we
            // can display the sprite.

            pSprite->rclSprite = rclSprite;
            pState->bValidRange = FALSE;

            vSpOrderInY(pSprite);

            // If either a DirectDraw Lock is active, or there are any active
            // WNDOBJs, we have to do some more work to handle repercussions:

            if (gpto != NULL)
            {
                vSpCheckForWndobjOverlap(pState, &rclSprite, &rclOldSprite);
            }
        }
        else
        {
            // If we couldn't display the sprite, then hide it.  Note that
            // there's no chance that this will infinitely recurse.

            ASSERTGDI(pptlDst != NULL,
                      "bSpUpdatePosition: Must never fail a hide");
            bSpUpdatePosition(pSprite, NULL);
        }
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* VOID vSpFreeClipResources
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpFreeClipResources(
SPRITE* pSprite)
{
    RGNOBJ ro(pSprite->prgnClip);
    ro.vDeleteRGNOBJ();
    pSprite->prgnClip = NULL;
}

/******************************Public*Routine******************************\
* BOOL bSpUpdateSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpUpdateSprite(
SPRITE*         pSprite,
HDC             hdcDst,
POINTL*         pptlDst,
SIZEL*          psizl,
HDC             hdcSrc,
POINTL*         pptlSrc,
COLORREF        crKey,
BLENDFUNCTION*  pblend,
DWORD           dwShape,
RECTL*          prclDirty)
{
    BOOL            bStatus;
    SPRITESTATE*    pState;
    BLENDFUNCTION   blend;

    if (!pSprite)
    {
        return FALSE;
    }

    bStatus = FALSE;                     // Assume failure

    pState = pSprite->pState;

    PDEVOBJ po(pState->hdev);

    DEVLOCKOBJ dlo(po);
    SPRITELOCK slock(po);

    if (dwShape & ULW_NEW_ATTRIBUTES)
    {
        // Take out this instructions flag to avoid future confusion

        dwShape &= ~ULW_NEW_ATTRIBUTES;

        // Cache new attributes in the sprite

        pSprite->cachedAttributes.dwShape =  dwShape;
        pSprite->cachedAttributes.bf      =  *pblend;
        pSprite->cachedAttributes.crKey   =  (ULONG) crKey;

        // If sprite hasn't been created yet, don't proceed so that a black
        // sprite won't get painted on the screen.  This is the case where
        // we're called for the first time from _UpdateLayeredWindow, where
        // user chooses to not pass us hdcSrc yet.

        if (!hdcSrc)
        {
            return TRUE;
        }
    }
    else if (dwShape == ULW_DEFAULT_ATTRIBUTES)
    {
        // Retrieve arguments from cached values

        dwShape = pSprite->cachedAttributes.dwShape;
        crKey   = pSprite->cachedAttributes.crKey;
        blend   = pSprite->cachedAttributes.bf; // Better to point to a local
                                                // variable in case this gets
                                                // changed later.
        pblend  = &blend;
    }

    if ((hdcDst) || (psizl) || (hdcSrc) || (pptlSrc) || (crKey))
    {
        bStatus = bSpUpdateShape(pSprite, dwShape, hdcDst, hdcSrc,
                                 crKey, pblend, pptlSrc, psizl, prclDirty);
        if (bStatus)
        {
            // Use the last position we were given if no position was specified on
            // this call.

            bStatus &= bSpUpdatePosition(
                            pSprite,
                            (pptlDst != NULL) ? pptlDst : &pSprite->ptlDst);
        }
    }
    else if (((dwShape == ULW_ALPHA) || (dwShape == (ULW_ALPHA | ULW_COLORKEY))) &&
             (pblend != NULL) &&
             (pptlDst == NULL))
    {
        bStatus = bSpUpdateAlpha(pSprite, pblend, TRUE);
    }
    else if (((dwShape == 0) || (dwShape == ULW_NOREPAINT)) && (pblend == NULL))
    {
        // Note that pptlDst may be either NULL or non-NULL.

        bStatus = bSpUpdatePosition(pSprite, pptlDst, dwShape & ULW_NOREPAINT);
    }
    else
    {
        WARNING("bSpUpdateSprite: Unexpected argument");
    }

    // Finally, redraw the sprite:

    if (prclDirty)
    {
        // Only redraw the dirty rectangle

        ERECTL erclDirty(*prclDirty);
        erclDirty += pSprite->ptlDst; // Offset by origin of sprite window
                                      // because the rectangle needs to
                                      // be in screen coordinates
        erclDirty *= pSprite->rclSprite; // To be safe, intersect with sprite
                                         // rectangle

        if (!erclDirty.bEmpty())
        {
            // Only redraw if intersection is not empty

            vSpRedrawArea(pSprite->pState, (RECTL*) &erclDirty);
        }
    }
    else
    {
        // Must redraw the whole sprite

        vSpRedrawSprite(pSprite);

        // synchrnize on output surface to ensure frame is rendered

        if (!po.bDisabled())
        {
            po.vSync(po.pSurface()->pSurfobj(), NULL, 0);
        }
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* VOID vSpRenumberZOrder
*
* Renumbers the sprites according to z-order, after the z-order is changed.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpRenumberZOrder(
SPRITESTATE* pState)
{
    SPRITE* pSprite;
    ULONG   z = 0;

    // The sprite numbers are assigned starting at 0 with the back-most sprite:

    for (pSprite = pState->pListZ; pSprite != NULL; pSprite = pSprite->pNextZ)
    {
        pSprite->z = z++;
    }

}

/******************************Public*Routine******************************\
* VOID vSpDeleteSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDeleteSprite(
SPRITE* pSprite)
{
    SPRITESTATE*    pState;
    BOOL            bRet;
    SPRITE*         pTmp;
    SPRITE*         pNext;
    SPRITE*         pPrevious;

    if (pSprite == NULL)
        return;

    pState = pSprite->pState;

    PDEVOBJ po(pState->hdev);

    DEVLOCKOBJ dlo(po);
    SPRITELOCK slock(po);

    // Hide the sprite:

    bRet = bSpUpdatePosition(pSprite, NULL);

    ASSERTGDI(bRet, "vSpDeleteSprite: hide failed");

#if DEBUG_SPRITES
    vSpValidateVisibleSprites(pState);
#endif

    // Remove the sprite from the z-sorted linked list:

    if (pState->pListZ == pSprite)
    {
        pState->pListZ = pSprite->pNextZ;
    }
    else
    {
        for (pTmp = pState->pListZ; pTmp != NULL; pTmp = pTmp->pNextZ)
        {
            if (pTmp->pNextZ == pSprite)
            {
                pTmp->pNextZ = pSprite->pNextZ;
                break;
            }
        }
    }

    // Delete the sprite from the Y-sorted linked list:

    pPrevious = pSprite->pPreviousY;
    pNext = pSprite->pNextY;

    if (pNext)
        pNext->pPreviousY = pPrevious;

    if (pPrevious)
        pPrevious->pNextY = pNext;
    else
    {
        ASSERTGDI(pState->pListY == pSprite, "Expected top of list");
        pState->pListY = pNext;
    }

    // Free all allocated data associated with this sprite:

    vSpFreeClipResources(pSprite);
    vSpDeleteShape(pSprite);
    vSpDeleteSurface(pSprite->psoUnderlay);

    if (pSprite->psoMask != NULL)
    {
        bDeleteSurface(pSprite->psoMask->hsurf);
        pSprite->psoMask = NULL;
    }

    // Take this as an opportunity to free the compositing surface:

    vSpDeleteSurface(pState->psoComposite);
    pState->psoComposite = NULL;

    // We're all done with this object, so free the memory and
    // leave:

    VFREEMEM(pSprite);
}

/******************************Public*Routine******************************\
* SPRITE* pSpCreateSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

SPRITE* pSpCreateSprite(
HDEV    hdev,
RECTL*  prcl,
HWND    hwnd,
POINTL* pptlDstInit=NULL)
{
    SPRITE* pSprite;
    SPRITE* pPrevious;
    SPRITE* pNext;
    SPRITE* pTarget;

    pSprite = NULL;         // Assume failure

    PDEVOBJ po(hdev);

    if (po.bDisplayPDEV())
    {
        DEVLOCKOBJ dlo(po);
        SPRITELOCK slock(po);

        SPRITESTATE* pState = po.pSpriteState();

        pSprite = (SPRITE*) PALLOCMEM(sizeof(SPRITE), ' psG');
        if (pSprite != NULL)
        {
            if (prcl != NULL)
            {
                pSprite->sizlHint.cx  = prcl->right - prcl->left;
                pSprite->sizlHint.cy  = prcl->bottom - prcl->top;
                pSprite->ptlDst.x     =
                    pptlDstInit ? pptlDstInit->x : prcl->left;
                pSprite->ptlDst.y     =
                    pptlDstInit ? pptlDstInit->y : prcl->top;
            }
            else
            {
                pSprite->sizlHint.cx  = 0;
                pSprite->sizlHint.cy  = 0;
                pSprite->ptlDst.x     = LONG_MIN;
                pSprite->ptlDst.y     = LONG_MIN;
            }

            pSprite->fl               = 0;
            pSprite->pState           = pState;
            pSprite->dwShape          = ULW_OPAQUE;
            pSprite->rclSprite.top    = LONG_MIN;
            pSprite->rclSprite.left   = LONG_MIN;
            pSprite->rclSprite.bottom = LONG_MIN;
            pSprite->rclSprite.right  = LONG_MIN;
#if DEBUG_SPRITES
            pSprite->pNextVisible     = NULL;
#endif

            // Add this sprite to the end of the z-list, meaning that
            // it will be top-most.  Well, top-most except for the
            // cursor sprites:

            pTarget = pState->pBottomCursor;
            
            if (pState->pListZ == pTarget)
            {
                pSprite->pNextZ = pTarget;
                pState->pListZ = pSprite;
            }
            else
            {
                for (pPrevious = pState->pListZ;
                     pPrevious->pNextZ != pTarget;
                     pPrevious = pPrevious->pNextZ)
                    ;

                pSprite->pNextZ = pTarget;
                pPrevious->pNextZ = pSprite;
            }

            vSpRenumberZOrder(pState);

            // Add this sprite to the front of the y-list.
            // pSprite->pPreviousY was already zero-initialized:

            pNext = pState->pListY;
            pState->pListY = pSprite;
            pSprite->pNextY = pNext;
            if (pNext)
                pNext->pPreviousY = pSprite;
            pSprite->hwnd = hwnd;

            vSpOrderInY(pSprite);
        }
    }

    return(pSprite);
}

/******************************Public*Routine******************************\
* BOOL bSpEnableSprites
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpEnableSprites(
HDEV hdev)
{
    SPRITESTATE*    pState;
    CLIPOBJ*        pco;
    SPRITESCAN*     pRange;
    SIZEL           sizl;
    HSURF           hsurf;
    SURFACE*        psurfScreen;
    SURFOBJ*        psoHitTest;

    PDEVOBJ po(hdev);
    if (!po.bDisplayPDEV())
        return(TRUE);

    psurfScreen = SURFOBJ_TO_SURFACE_NOT_NULL(po.pSurface()->pSurfobj());

    pState = po.pSpriteState();

    // Remember some information about the current mode:

    pState->hdev                = hdev;
    pState->psoScreen           = psurfScreen->pSurfobj();
    pState->iModeFormat         = psurfScreen->iFormat();
    pState->iOriginalType       = psurfScreen->iType();
    pState->flOriginalSurfFlags = psurfScreen->flags();

    pState->iSpriteType         = pState->iOriginalType;
    pState->flSpriteSurfFlags   = pState->flOriginalSurfFlags;

    XEPALOBJ pal(psurfScreen->ppal());
    pState->flModeMasks = pal.flRed() | pal.flBlu();

    // Initialize the screen size:

    pState->rclScreen.left   = 0;
    pState->rclScreen.right  = psurfScreen->sizl().cx;
    pState->rclScreen.top    = 0;
    pState->rclScreen.bottom = psurfScreen->sizl().cy;

    // Now allocate some regions that we'll use later:

    RGNMEMOBJ rmoUncovered;
    RGNMEMOBJ rmoTmp;
    RGNMEMOBJ rmoRectangular;

    if (rmoUncovered.bValid() && rmoTmp.bValid() && rmoRectangular.bValid())
    {
        pRange = (SPRITESCAN*) PALLOCMEM(sizeof(SPRITESCAN), 'rpsG');
        if (pRange)
        {
            // TRUE to denote that we want an STYPE_BITMAP surface, because
            // we have to be able to access the bits directly for hit testing:

            psoHitTest = psoSpCreateSurface(pState, 0, 1, 1, TRUE);
            if (psoHitTest)
            {
                // Mark the surface, so that it can be special-cased by
                // the dynamic mode change code:

                vSpSetNullRange(pState, pRange);

                pState->psoHitTest = psoHitTest;

                // We need a DC_RECT clip object:

                rmoRectangular.vSet(&pState->rclScreen);

                pState->prgnRectangular = rmoRectangular.prgnGet();
                pState->coRectangular.vSetup(rmoRectangular.prgnGet(),
                                             *((ERECTL*) &pState->rclScreen),
                                             CLIP_FORCE);

                pState->prgnUncovered  = rmoUncovered.prgnGet();
                pState->prgnUncovered->vStamp();
                pState->prgnTmp        = rmoTmp.prgnGet();
                pState->hrgn           = GreCreateRectRgn(0, 0, 0, 0);

                // Save some hook state:

                pState->pfnStrokePath        = PPFNDRV(po, StrokePath);
                pState->pfnFillPath          = PPFNDRV(po, FillPath);
                pState->pfnBitBlt            = PPFNDRV(po, BitBlt);
                pState->pfnCopyBits          = PPFNDRV(po, CopyBits);
                pState->pfnStretchBlt        = PPFNDRV(po, StretchBlt);
                pState->pfnTextOut           = PPFNDRV(po, TextOut);
                pState->pfnLineTo            = PPFNDRV(po, LineTo);
                pState->pfnTransparentBlt    = PPFNDRV(po, TransparentBlt);
                pState->pfnAlphaBlend        = PPFNDRV(po, AlphaBlend);
                pState->pfnPlgBlt            = PPFNDRV(po, PlgBlt);
                pState->pfnGradientFill      = PPFNDRV(po, GradientFill);
                pState->pfnStretchBltROP     = PPFNDRV(po, StretchBltROP);
                pState->pfnSaveScreenBits    = PPFNDRV(po, SaveScreenBits);
                pState->pfnDrawStream        = PPFNDRV(po, DrawStream);

                return(TRUE);
            }

            VFREEMEM(pRange);
        }
    }

    WARNING("bSpEnableSprites: Failed!");

    rmoUncovered.vDeleteRGNOBJ();
    rmoTmp.vDeleteRGNOBJ();
    rmoRectangular.vDeleteRGNOBJ();

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vSpDisableSprites
*
* Called when the device's surface is about to be destroyed.
*
* Note: This function may be called without bDdEnableSprites having
*       first been called!
*
* Note that this may be called for printers and the like.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDisableSprites(
HDEV        hdev,
CLEANUPTYPE cutype)
{
    SPRITESTATE* pState;

    PDEVOBJ po(hdev);

    pState = po.pSpriteState();

    SPRITE* pSprite = pState->pBottomCursor;

    while(pSprite != NULL)
    {
        SPRITE* pNextSprite = pSprite->pNextZ;
        vSpDeleteSprite(pSprite);
        pSprite = pNextSprite;
    }

    pState->pTopCursor = NULL;
    pState->pBottomCursor = NULL;
    pState->ulNumCursors = 0;

    ASSERTGDI(pState->pListZ == NULL, "Expected to have 0 sprites");
    ASSERTGDI(pState->psoComposite == NULL, "Expected no composite surface");

    // During session cleanup (i.e., hydra shutdown), surfaces are
    // deleted as part of the HMGR object cleanup.  So we can skip
    // this for CLEANUP_SESSION:

    if (cutype != CLEANUP_SESSION)
    {
        vSpDeleteSurface(pState->psoHitTest);
    }

    // These regions, on the other hand, are not in the HMGR so
    // must be cleaned up always:

    RGNOBJ roUncovered(pState->prgnUncovered);
    RGNOBJ roTmp(pState->prgnTmp);
    RGNOBJ roRectangular(pState->prgnRectangular);

    roUncovered.vDeleteRGNOBJ();
    roTmp.vDeleteRGNOBJ();
    roRectangular.vDeleteRGNOBJ();

    // Since we are referencing this region by handle, it is safe
    // to do even during session cleanup:

    GreDeleteObject(pState->hrgn);

    if (pState->pRange)
    {
        VFREEMEM(pState->pRange);
    }

    if (pState->ahdevMultiMon)
    {
        EngFreeMem(pState->ahdevMultiMon);
    }

    if (pState->prgnUnlocked != NULL)
    {
        pState->prgnUnlocked->vDeleteREGION();
    }

    // Leave the sprite state in the PDEV in a newly initialized state:

    RtlZeroMemory(pState, sizeof(*pState));
}

/******************************Public*Routine******************************\
* VOID vSpEnableMultiMon
*
* This routine is called by the multi-mon code to let us know the children
* of a multi-mon meta PDEV.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpEnableMultiMon(
HDEV    hdev,
ULONG   c,
HDEV*   ahdev)          // Must be allocated by the caller and freed
{                       //   by calling vSpDisableMultiMon
    SPRITESTATE*    pState;

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    pState->cMultiMon = c;
    pState->ahdevMultiMon = ahdev;
}

/******************************Public*Routine******************************\
* VOID vSpDisableMultiMon
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDisableMultiMon(
HDEV    hdev)
{
    SPRITESTATE*    pState;

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    if (pState->ahdevMultiMon)
    {
        VFREEMEM(pState->ahdevMultiMon);
    }

    pState->cMultiMon = 0;
    pState->ahdevMultiMon = NULL;

    ASSERTGDI(pState->pListMeta == NULL, "Expected no meta-sprites");
}

/******************************Public*Routine******************************\
* VOID vSpHideSprites
*
* Hides or unhides all sprites on a PDEV and all of its child PDEVs.
*
*  1-Mar-2001 -by- Jason Hartman [jasonha]
* Wrote it.
\**************************************************************************/

VOID
vSpHideSprites(
    HDEV hdev,
    BOOL bHide
    )
{
    GDIFunctionID(vSpHideSprites);

    PDEVOBJ     po(hdev);
    SPRITELOCK  slock(po);
    SPRITESTATE* pState;

    pState = po.pSpriteState();

    if (pState->cMultiMon)
    {
        ULONG   i;

        for (i = 0; i < pState->cMultiMon; i++)
        {
            vSpHideSprites(pState->ahdevMultiMon[i], bHide);
        }
    }
    else
    {
        SPRITE* pSprite = pState->pListZ;

        while (pSprite != NULL)
        {
            SPRITE* pNextSprite = pSprite->pNextZ;

            if (bHide)
            {
                ASSERTGDI((pSprite->fl & SPRITE_FLAG_HIDDEN) == 0, "Sprite is already hidden.");

                pSprite->fl |= SPRITE_FLAG_HIDDEN;
            }
            else
            {
                ASSERTGDI((pSprite->fl & SPRITE_FLAG_HIDDEN) != 0, "Sprite is not hidden.");

                pSprite->fl &= ~SPRITE_FLAG_HIDDEN;
            }

            bSpUpdatePosition(pSprite, &pSprite->ptlDst);

            pSprite = pNextSprite;
        }

    }

    if (bHide)
    {
        ASSERTGDI(pState->cVisible == 0, "Sprites remain visible after we hid them all.");
        ASSERTGDI(!pState->bHooked, "Sprite layer remains hooked after we hid all sprites.");
    }
}

/******************************Public*Routine******************************\
* SPRITE* pSpTransferSprite
*
* Transfers a sprite to a new PDEV by creating a new sprite that copies
* the contents of the old, and then deleting the old sprite.
*
* NOTE: pSpriteOld is freed by this function, so it must not be accessed
*       after calling!
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

SPRITE* pSpTransferSprite(
HDEV    hdevNew,
SPRITE* pSpriteOld)
{
    SPRITE* pSpriteNew;
    POINTL  ptlZero;

    pSpriteNew = NULL;

    if (pSpriteOld->hwnd == NULL)
    {
        // There shouldn't be any non-hwnd associated sprites at this point.

        ASSERTGDI(FALSE,
                  "pSpTransferSprite:  pSpriteOld is not hwnd associated!");
    }
    else
    {
        pSpriteNew = pSpCreateSprite(hdevNew,
                                     NULL,
                                     pSpriteOld->hwnd);
        if (pSpriteNew)
        {
            vSpTransferShape(pSpriteNew, pSpriteOld);
            if (!bSpUpdatePosition(pSpriteNew,
                                   &pSpriteOld->ptlDst))
            {
                vSpDeleteSprite(pSpriteNew);
                pSpriteNew = NULL;
            }
            else
            {
                // If this sprite is a part of Meta Sprite,
                // update Meta Sprite, too.

                if (pSpriteOld->pMetaSprite != NULL)
                {
                    METASPRITE *pMetaSprite = pSpriteOld->pMetaSprite;
                    BOOL bSpriteInMeta = FALSE;

                    for (ULONG i = 0; i < pMetaSprite->chSprite; i++)
                    {
                        if (pMetaSprite->apSprite[i] == pSpriteOld)
                        {
                            pMetaSprite->apSprite[i] = pSpriteNew;
                            pSpriteNew->pMetaSprite = pMetaSprite;

                            if (bSpriteInMeta)
                            {
                                WARNING("pSpTransferSprite: Sprite in meta multiple times!");
                            }
                            bSpriteInMeta = TRUE;
                        }
                    }

                    if (!bSpriteInMeta)
                    {
                        WARNING("pSpTransferSprite: No sprite in meta!");
                    }
                }
            }
        }
    }

    // If new sprite could not be created, the metasprite is still pointing
    // to the old sprite which we are about to delete.

    if (!pSpriteNew && (pSpriteOld->pMetaSprite != NULL))
    {
        METASPRITE *pMetaSprite = pSpriteOld->pMetaSprite;

        // Mark the meta sprite for deletion.  This is because the call to
        // UserRemoveRedirectionBitmap will unset the layered flag on the
        // window and so user will not attempt to delete the sprite in the
        // futue (i.e. if we don't do this we will leak memory).  The actual
        // deletion will happen in pSpTransferMetaSprite.

        pMetaSprite->fl |= SPRITE_FLAG_NO_WINDOW;

        for (ULONG i = 0; i < pMetaSprite->chSprite; i++)
        {
            if (pMetaSprite->apSprite[i] == pSpriteOld)
            {
                pMetaSprite->apSprite[i] = NULL;
            }
        }
    }

    vSpDeleteSprite(pSpriteOld);

    return(pSpriteNew);
}

/******************************Public*Routine******************************\
* VOID vSpCorrectHdevReferences
*
* On a dynamic mode change, sprite state is transferred between the two
* PDEVs along with the rest of the driver state.  As such, we have to
* go back through and correct any references to the old HDEV.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpCorrectHdevReferences(
SPRITESTATE*    pState,
HDEV            hdev)
{
    SPRITE*     pSprite;

    pState->hdev = hdev;

    // Note that any surfaces created by psoSpCreateSurface are tagged
    // as sprite surfaces, and left alone by bDynamicModeChange, so that
    // we can handle them here.

    if (pState->psoComposite != NULL)
        pState->psoComposite->hdev = hdev;

    if (pState->psoHitTest != NULL)
        pState->psoHitTest->hdev = hdev;

    for (pSprite = pState->pListZ;
         pSprite != NULL;
         pSprite = pSprite->pNextZ)
    {
        pSprite->pState = pState;

        if (pSprite->psoShape != NULL)
        {
            ASSERTGDI(pSprite->psoShape->hdev != 0,
                "Didn't expect NULL shape hdev");

            pSprite->psoShape->hdev = hdev;
        }
        if (pSprite->psoUnderlay != NULL)
        {
            ASSERTGDI(pSprite->psoUnderlay->hdev != 0,
                "Didn't expect NULL shape hdev");

            pSprite->psoUnderlay->hdev = hdev;
        }
    }
}

/******************************Public*Routine******************************\
* METASPRITE* pSpConvertSpriteToMeta
*
* On a dynamic mode change, sprite state is transferred between the meta-PDEV
* and device PDEV along with the rest of the driver state.  As such, we have
* to convert "sprite" to "meta sprite" when 1 monitor to multi-monitors mode
* change
*
*  2-Jul-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

METASPRITE* pSpConvertSpriteToMeta(
HDEV    hdevMetaNew,
HDEV    hdevDevOld,
SPRITE* pSpriteOld)
{
    METASPRITE  *pMetaSpriteNew;
    SPRITE      *pSpriteNew;
    SPRITESTATE *pState;
    BOOL         bError = FALSE;

    pMetaSpriteNew = NULL;

    if (pSpriteOld->hwnd == NULL)
    {
        // There shouldn't be any non-hwnd associated sprites at this point.

        ASSERTGDI(FALSE,
                  "pSpConvertSpriteToMeta:  pSpriteOld is not hwnd associated!");
    }
    else
    {
        PDEVOBJ poMeta(hdevMetaNew);

        // When running multi-mon, handle the creation of the meta sprite:

        pState = poMeta.pSpriteState();

        if (pState->cMultiMon)
        {
            // Create MetaSprites and 'real' sprites for children.

            ULONG cjAlloc = sizeof(METASPRITE)
                          + pState->cMultiMon
                          * sizeof(pMetaSpriteNew->apSprite[0]);

            pMetaSpriteNew = (METASPRITE*) PALLOCNOZ(cjAlloc, 'mpsG');
            if (pMetaSpriteNew)
            {
                for (ULONG i = 0; i < pState->cMultiMon; i++)
                {
                    PDEVOBJ    poDevice(pState->ahdevMultiMon[i]);
                    SPRITELOCK slock(poDevice);

                    pSpriteNew = pSpCreateSprite(poDevice.hdev(),
                                                 NULL,
                                                 pSpriteOld->hwnd);
                    if (pSpriteNew)
                    {
                        POINTL ptlDst;

                        PDEVOBJ poDevOld(hdevDevOld);

                        // Transfer the information from old sprite
                        // to new sprite.

                        vSpTransferShape(pSpriteNew, pSpriteOld);

                        // The sprite position need to be adjusted based on
                        // poDevice origin, since we switch to multi-monitor
                        // system, and then poDevice origion might not be equal
                        // poDevOld.

                        // poDevOld coordinate to meta coordinate

                        ptlDst.x =
                            pSpriteOld->ptlDst.x + poDevOld.pptlOrigin()->x;
                        ptlDst.y =
                            pSpriteOld->ptlDst.y + poDevOld.pptlOrigin()->y;

                        // meta coordinate to poDevice coordinate

                        ptlDst.x -= poDevice.pptlOrigin()->x;
                        ptlDst.y -= poDevice.pptlOrigin()->y;

                        if (bSpUpdatePosition(pSpriteNew, &ptlDst))
                        {
                            pMetaSpriteNew->apSprite[i] = pSpriteNew;
                            pSpriteNew->pMetaSprite     = pMetaSpriteNew;
                        }
                        else
                        {
                            vSpDeleteSprite(pSpriteNew);
                            bError = TRUE;
                            break;
                        }
                    }
                    else
                    {
                        bError = TRUE;
                        break;
                    }
                }

                if (bError)
                {
                    for (; i > 0; i--)
                    {
                        vSpDeleteSprite(pMetaSpriteNew->apSprite[i - 1]);
                    }

                    VFREEMEM(pMetaSpriteNew);
                    // Set this to NULL so we don't write on it later.
                    // This fixes the logic below
                    pMetaSpriteNew = NULL;
                }
                else
                {
                    pMetaSpriteNew->hwnd     = pSpriteOld->hwnd;
                    pMetaSpriteNew->chSprite = pState->cMultiMon;
                    pMetaSpriteNew->fl       = 0;

                    // Add this node to the head of the meta-sprite list:

                    pMetaSpriteNew->pNext    = pState->pListMeta;
                    pState->pListMeta        = pMetaSpriteNew;
                }
            }
        }
        else
        {
            WARNING("pSpConvertSpriteToMeta(): cMultiMon is 0\n");
        }
    }

    // Delete old sprite

    vSpDeleteSprite(pSpriteOld);

    return(pMetaSpriteNew);
}

/******************************Public*Routine******************************\
* SPRITE* pSpConvertSpriteFromMeta
*
* On a dynamic mode change, sprite state is transferred between the meta-PDEV
* and device PDEV along with the rest of the driver state.  As such, we have
* to convert "meta sprite" to "sprite" when multi-monitors to 1 monitor mode
* change
*
*  2-Jul-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

SPRITE* pSpConvertSpriteFromMeta(
HDEV        hdevDevNew,
HDEV        hdevMetaOld,
METASPRITE* pMetaSpriteOld)
{
    SPRITE*      pSpriteNew;
    SPRITE*      pSpriteOld;
    SPRITESTATE *pStateMeta;
    ULONG        i;

    PDEVOBJ poMeta(hdevMetaOld);

    pSpriteNew = NULL;

    pStateMeta = poMeta.pSpriteState();

    if (pMetaSpriteOld->hwnd == NULL)
    {
        // There shouldn't be any non-hwnd associated sprites at this point.

        ASSERTGDI(FALSE,
                  "pSpConvertSpriteFromMeta:  pSpriteOld is not hwnd associated!");
    }
    else
    {
        pSpriteOld = NULL;

        // Find a the sprite lives in PDEV which has highest color
        // depth, remember this for transfering shape for new
        // sprite.

        ULONG iDitherHighest = 0;

        for (i = 0; i < pMetaSpriteOld->chSprite; i++)
        {
            SPRITE* pSpriteTmp = pMetaSpriteOld->apSprite[i];

            if (pSpriteTmp)
            {
                PDEVOBJ poTmp(pSpriteTmp->pState->hdev);

                if (iDitherHighest < poTmp.iDitherFormat())
                {
                    pSpriteOld = pSpriteTmp;
                    iDitherHighest = poTmp.iDitherFormat();
                }
            }
        }

        // Convert sprite on old hdev to new hdev.

        if (pSpriteOld)
        {
            pSpriteNew = pSpCreateSprite(hdevDevNew,
                                         NULL,
                                         pMetaSpriteOld->hwnd);
            if (pSpriteNew)
            {
                vSpTransferShape(pSpriteNew, pSpriteOld);

                // The sprite position needs to be adjusted based on
                // origin of the old PDEV

                PDEVOBJ poOld(pSpriteOld->pState->hdev);
                EPOINTL ptlSpritePos = pSpriteOld->ptlDst;
                ptlSpritePos += *(poOld.pptlOrigin());

                if (!bSpUpdatePosition(pSpriteNew,
                                       &ptlSpritePos))
                {
                    vSpDeleteSprite(pSpriteNew);
                    pSpriteNew = NULL;
                }
            }
        }
    }

    // Delete old sprites on meta sprite.

    for (i = 0; i < pMetaSpriteOld->chSprite; i++)
    {
        vSpDeleteSprite(pMetaSpriteOld->apSprite[i]);
    }

    // Remove this meta sprite from the linked list :

    if (pStateMeta->pListMeta == pMetaSpriteOld)
    {
        pStateMeta->pListMeta = pMetaSpriteOld->pNext;
    }
    else
    {
        for (METASPRITE *pTmp = pStateMeta->pListMeta;
                         pTmp->pNext != pMetaSpriteOld;
                         pTmp = pTmp->pNext)
            ;

        pTmp->pNext = pMetaSpriteOld->pNext;
    }

    // Delete meta sprite.

    VFREEMEM(pMetaSpriteOld);

    return(pSpriteNew);
}

/******************************Public*Routine******************************\
* METASPRITE* pSpMoveSpriteFromMeta
*
*  1-Sep-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

SPRITE* pSpMoveSpriteFromMeta(
HDEV        hdevDevNew,
HDEV        hdevMetaOld,
METASPRITE* pMetaSpriteOld,
ULONG       ulIndex)
{
    ULONG        i;
    SPRITE*      pSpriteOrg;
    SPRITE*      pSpriteNew = NULL;
    SPRITESTATE* pStateMeta;

    PDEVOBJ poDev(hdevDevNew);
    PDEVOBJ poMeta(hdevMetaOld);

    pStateMeta = poMeta.pSpriteState();

    // Pick up the sprite we may reuse.

    pSpriteOrg = pMetaSpriteOld->apSprite[ulIndex];

    if (pSpriteOrg)
    {
        // Make sure the sprite belonging to device specific HDEV,
        // actually under DDI. the sprite already lives this DHPDEV.

        ASSERTGDI(pSpriteOrg->pState == poDev.pSpriteState(),
                  "ERROR: pState does not points device PDEV");

        // And this sprite no longer has meta sprite, the meta sprite
        // will be deleted in below.

        pSpriteOrg->pMetaSprite = NULL;
    }

    if (pMetaSpriteOld->hwnd == NULL)
    {
        // There shouldn't be any non-hwnd associated sprites at this point.

        ASSERTGDI(FALSE,
                  "pSpMoveSpriteFromMeta:  pSpriteOld is not hwnd associated!");
    }
    else
    {
        pSpriteNew = pSpriteOrg;
    }

    // Delete old sprites on meta sprite.

    for (i = 0; i < pMetaSpriteOld->chSprite; i++)
    {
        if ((i != ulIndex) || (pSpriteNew == NULL))
        {
            vSpDeleteSprite(pMetaSpriteOld->apSprite[i]);
        }
    }

    // Remove this meta sprite from the linked list :

    if (pStateMeta->pListMeta == pMetaSpriteOld)
    {
        pStateMeta->pListMeta = pMetaSpriteOld->pNext;
    }
    else
    {
        for (METASPRITE *pTmp = pStateMeta->pListMeta;
                         pTmp->pNext != pMetaSpriteOld;
                         pTmp = pTmp->pNext)
            ;

        pTmp->pNext = pMetaSpriteOld->pNext;
    }

    // Delete meta sprite.

    VFREEMEM(pMetaSpriteOld);

    return(pSpriteNew);
}

/******************************Public*Routine******************************\
* METASPRITE* pSpTransferMetaSprite
*
*  30-Aug-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

METASPRITE* pSpTransferMetaSprite(
HDEV        hdevNew,
HDEV        hdevOld,
METASPRITE* pMetaSpriteOld)
{
    SPRITESTATE* pStateNew;
    SPRITESTATE* pStateOld;
    METASPRITE*  pMetaSpriteNew;
    SPRITE*      pSprite;
    ULONG        i, j;
    BOOL         bError = FALSE;

    PDEVOBJ poNew(hdevNew);
    PDEVOBJ poOld(hdevOld);

    pStateNew = poNew.pSpriteState();
    pStateOld = poOld.pSpriteState();

    if (pMetaSpriteOld->hwnd == NULL)
    {
        // There shouldn't be any non-hwnd associated sprites at this point.

        ASSERTGDI(FALSE,
                  "pSpTransferMetaSprite:  pSpriteOld is not hwnd associated!");
    }
    else
    {
        // Create METASPRITE on new hdev.

        ULONG cjAlloc = sizeof(METASPRITE)
                      + pStateNew->cMultiMon
                      * sizeof(pMetaSpriteNew->apSprite[0]);

        if (pMetaSpriteOld->fl & SPRITE_FLAG_NO_WINDOW)
        {
            // If the metasprite is marked for deletion, don't reallocate a new
            // metasprite.  The cleanup code below will make sure the old
            // metasprite and its child sprites are deleted.

            pMetaSpriteNew = NULL;
        }
        else
        {
            pMetaSpriteNew = (METASPRITE*) PALLOCMEM(cjAlloc, 'mpsG');
        }

        if (pMetaSpriteNew)
        {
            SPRITE *pSpriteBest = NULL;
            HDEV    hdevBest = NULL;
            ULONG   iFormatBest = 0;

            // Transfer sprite from old meta to new as much as possible.

            for (i = 0 ; i < pStateNew->cMultiMon ; i++)
            {
                for (j = 0; j < pMetaSpriteOld->chSprite ; j++)
                {
                    pSprite = pMetaSpriteOld->apSprite[j];

                    if (pSprite)
                    {
                        PDEVOBJ poTmp(pSprite->pState->hdev);

                        // if pointer to pState is same, we can transfer
                        // to new pdev.

                        if (pStateNew == pSprite->pState)
                        {
                            // move this sprite to new meta sprite from old.

                            pMetaSpriteNew->apSprite[i] = pSprite;
                            pMetaSpriteOld->apSprite[j] = NULL;

                            pSprite->pMetaSprite = pMetaSpriteNew;
                        }

                        // if the sprite lives in PDEV which has higher color
                        // depth, remember this for transfering shape for new
                        // sprite

                        if (iFormatBest < poTmp.iDitherFormat())
                        {
                            pSpriteBest = pSprite;
                            hdevBest    = poTmp.hdev();
                            iFormatBest = poTmp.iDitherFormat();
                        }
                    }
                }
            }

            // fill up other meta sprite fields

            pMetaSpriteNew->hwnd     = pMetaSpriteOld->hwnd;
            pMetaSpriteNew->chSprite = pStateNew->cMultiMon;
            pMetaSpriteNew->fl       = 0;

            // if there is any sprite which can not be trasnferred from old,
            // create them

            for (i = 0 ; i < pMetaSpriteNew->chSprite ; i++)
            {
                if (pMetaSpriteNew->apSprite[i] == NULL)
                {
                    PDEVOBJ poDevice(pStateNew->ahdevMultiMon[i]);
                    SPRITELOCK slockDevice(poDevice);

                    pSprite= pSpCreateSprite(poDevice.hdev(),
                                             NULL,
                                             pMetaSpriteOld->hwnd);

                    if (pSprite)
                    {
                        PDEVOBJ poBestHdev(hdevBest);
                        SPRITELOCK slockBest(poBestHdev);
                        POINTL  ptlDst;

                        // copy sprite shape from best existing sprite.

                        vSpTransferShape(pSprite, pSpriteBest);

                        // The sprite position need to be adjusted based on
                        // poDevice origin. need to convert from hdevBest
                        // coordinate.

                        // poBestHdev coordinate to meta coordinate

                        ptlDst.x =
                            pSpriteBest->ptlDst.x + poBestHdev.pptlOrigin()->x;
                        ptlDst.y =
                            pSpriteBest->ptlDst.y + poBestHdev.pptlOrigin()->y;

                        // meta coordinate to poDevice coordinate

                        ptlDst.x -= poDevice.pptlOrigin()->x;
                        ptlDst.y -= poDevice.pptlOrigin()->y;

                        if (bSpUpdatePosition(pSprite, &ptlDst))
                        {
                            // Put the sprite into meta sprite.

                            pMetaSpriteNew->apSprite[i] = pSprite;
                            pSprite->pMetaSprite = pMetaSpriteNew;
                        }
                        else
                        {
                            vSpDeleteSprite(pSprite);
                            bError = TRUE;
                        }
                    }
                    else
                    {
                        bError = TRUE;
                    }
                }

                if (bError)
                {
                    // if there is any error, stop looping, no more creation.

                    break;
                }
            }

            if (!bError)
            {
                // Add this node to the head of the meta-sprite list:

                pMetaSpriteNew->pNext    = pStateNew->pListMeta;
                pStateNew->pListMeta     = pMetaSpriteNew;
            }
        }
    }

    // check any sprite left in old meta, if so delete them.

    for (i = 0; i < pMetaSpriteOld->chSprite ; i++)
    {
        if (pMetaSpriteOld->apSprite[i] != NULL)
        {
            vSpDeleteSprite(pMetaSpriteOld->apSprite[i]);
        }
    }

    // Remove old meta sprite from the linked list :

    if (pStateOld->pListMeta == pMetaSpriteOld)
    {
        pStateOld->pListMeta = pMetaSpriteOld->pNext;
    }
    else
    {
        for (METASPRITE *pTmp = pStateOld->pListMeta;
                         pTmp->pNext != pMetaSpriteOld;
                         pTmp = pTmp->pNext)
            ;

        pTmp->pNext = pMetaSpriteOld->pNext;
    }

    if (bError)
    {
        // Delete new meta sprite.

        for (i = 0; i < pMetaSpriteNew->chSprite ; i++)
        {
            if (pMetaSpriteNew->apSprite[i] != NULL)
            {
                vSpDeleteSprite(pMetaSpriteNew->apSprite[i]);
            }
        }

        VFREEMEM(pMetaSpriteNew);

        pMetaSpriteNew = NULL;
    }

    // Delete meta sprite.

    VFREEMEM(pMetaSpriteOld);

    return(pMetaSpriteNew);
}


/******************************Public*Routine******************************\
* VOID vSpDynamicModeChange
*
* This function transfers all layered-window sprites from one PDEV to the
* other.
*
* Note that it transfers only layered-window sprites.  Sprites that don't
* have an associated hwnd are left with the old PDEV.
*
*   2-Jul-1998 -by- Hideyuki Nagase [hideyukn]
* DDML (meta) mode change support.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDynamicModeChange(
HDEV    hdevA,
HDEV    hdevB)
{
    SPRITESTATE     StateTmp;
    SPRITESTATE*    pStateA;
    SPRITESTATE*    pStateB;
    ULONG           ulTmp;
    SPRITE*         pSprite;
    SPRITE*         pSpriteNext;
    SPRITE*         pSpriteNew;
    METASPRITE*     pMetaSprite;
    METASPRITE*     pMetaSpriteNew;
    METASPRITE*     pMetaSpriteNext;
    UINT            i, j;

    PDEVOBJ poA(hdevA);
    PDEVOBJ poB(hdevB);

    // Sprite state, being 'below the DDI level', is device specific.
    // As such, it is tranferred along with the rest of the device
    // specific state on the dynamic mode change.
    //
    // Do that now:

    pStateA = poA.pSpriteState();
    pStateB = poB.pSpriteState();

    StateTmp = *pStateA;
    *pStateA = *pStateB;
    *pStateB = StateTmp;

    // Swap back the drag-rect width:

    ulTmp = pStateA->ulDragDimension;
    pStateA->ulDragDimension = pStateB->ulDragDimension;
    pStateB->ulDragDimension = ulTmp;

    // Now find any 'hdev' references and correct them:

    vSpCorrectHdevReferences(pStateA, hdevA);
    vSpCorrectHdevReferences(pStateB, hdevB);

    // Now that we've transferred the state, grab the locks:

    SPRITELOCK slockA(poA);
    SPRITELOCK slockB(poB);

    pSprite = pStateA->pBottomCursor;

    while(pSprite != NULL)
    {
        SPRITE* pNextSprite = pSprite->pNextZ;
        vSpDeleteSprite(pSprite);
        pSprite = pNextSprite;
    }

    pStateA->pTopCursor = NULL;
    pStateA->pBottomCursor = NULL;
    pStateA->ulNumCursors = 0;
    
    pSprite = pStateB->pBottomCursor;

    while(pSprite != NULL)
    {
        SPRITE* pNextSprite = pSprite->pNextZ;
        vSpDeleteSprite(pSprite);
        pSprite = pNextSprite;
    }

    pStateB->pTopCursor = NULL;
    pStateB->pBottomCursor = NULL;
    pStateB->ulNumCursors = 0;
    
    // But the sprites themselves logically stay with the old PDEV
    // and shouldn't be transferred in the first place.  So
    // now that we've transferred the broad state, we have to go
    // back through and individually transfer every sprites back
    // to their original PDEV, accounting for the new display
    // format at the same time.

    if (poA.bMetaDriver() && poB.bMetaDriver())
    {
        // Exchange all Meta sprites between meta PDEVs.

        pMetaSprite = pStateA->pListMeta;
        while (pMetaSprite != NULL)
        {
            // Grab the 'next' pointer while we can, because we're about
            // to delete 'pMetaSprite'!

            pMetaSpriteNext = pMetaSprite->pNext;

            pMetaSpriteNew = pSpTransferMetaSprite(hdevB, hdevA, pMetaSprite);
            if (pMetaSpriteNew != NULL)
            {
                // Mark the new sprites in 'B's list as being just
                // of transferring:

                pMetaSpriteNew->fl |= SPRITE_FLAG_JUST_TRANSFERRED;
            }

            pMetaSprite = pMetaSpriteNext;
        }

        // Transfer all the sprites that now live in 'B' back to 'A',
        // skipping the ones we just transferred:

        pMetaSprite = pStateB->pListMeta;
        while (pMetaSprite != NULL)
        {
            // Grab the 'next' pointer while we can, because we're about
            // to delete 'pMetaSprite'!

            pMetaSpriteNext = pMetaSprite->pNext;

            // The 'just-transferred' flag is so that we don't transfer
            // back to A sprites we just transferred to B:

            if (!(pMetaSprite->fl & SPRITE_FLAG_JUST_TRANSFERRED))
            {
                pMetaSpriteNew = pSpTransferMetaSprite(hdevA, hdevB, pMetaSprite);
            }
            else
            {
                pMetaSprite->fl &= ~SPRITE_FLAG_JUST_TRANSFERRED;
            }

            pMetaSprite = pMetaSpriteNext;
        }
    }
    else if (!poA.bMetaDriver() && !poB.bMetaDriver())
    {
        pSprite = pStateA->pListZ;
        while (pSprite != NULL)
        {
            // Grab the 'next' pointer while we can, because we're about
            // to delete 'pSprite'!

            pSpriteNext = pSprite->pNextZ;

            pSpriteNew = pSpTransferSprite(hdevB, pSprite);
            if (pSpriteNew != NULL)
            {
                // Mark the new sprites in 'B's list as being just
                // of transferring:

                pSpriteNew->fl |= SPRITE_FLAG_JUST_TRANSFERRED;
            }

            pSprite = pSpriteNext;
        }

        // Transfer all the sprites that now live in 'B' back to 'A',
        // skipping the ones we just transferred:

        pSprite = pStateB->pListZ;
        while (pSprite != NULL)
        {
            // Grab the 'next' pointer while we can, because we're about
            // to delete 'pSprite'!

            pSpriteNext = pSprite->pNextZ;

            // The 'just-transferred' flag is so that we don't transfer
            // back to A sprites we just transferred to B:

            if (!(pSprite->fl & SPRITE_FLAG_JUST_TRANSFERRED))
            {
                pSpriteNew = pSpTransferSprite(hdevA, pSprite);
            }
            else
            {
                pSprite->fl &= ~SPRITE_FLAG_JUST_TRANSFERRED;
            }

            pSprite = pSpriteNext;
        }
    }
    else
    {
        PDEVOBJ poMeta(poA.bMetaDriver() ? hdevA : hdevB);
        PDEVOBJ poDev(poA.bMetaDriver()  ? hdevB : hdevA);

        SPRITESTATE* pStateMeta = poMeta.pSpriteState();
        SPRITESTATE* pStateDev  = poDev.pSpriteState();

        BOOL bModeChgBtwnChildAndParent = FALSE;

        for (ULONG iIndex = 0; iIndex < pStateMeta->cMultiMon; iIndex++)
        {
            // Find poMeta.hdev() (= originally this hdev *WAS* child device)

            if (pStateMeta->ahdevMultiMon[iIndex] == poMeta.hdev())
            {
                bModeChgBtwnChildAndParent = TRUE;

                // Put a device PDEV.

                pStateMeta->ahdevMultiMon[iIndex] = poDev.hdev();
                break;
            }
        }

        if (bModeChgBtwnChildAndParent)
        {
            // This must be only happened when 2 to 1 mode change occured.

            ASSERTGDI(poA.hdev() == poDev.hdev(),"hdevA must be device PDEV");
            ASSERTGDI(poB.hdev() == poMeta.hdev(),"hdevB must be meta PDEV");

            // Only scan meta sprite to delete meta sprite and delete it's
            // child sprites which we will not use anymore.

            pMetaSprite = pStateMeta->pListMeta;
            while (pMetaSprite != NULL)
            {
                // Grab the 'next' pointer while we can, because we're about
                // to delete 'pMetaSprite'!

                pMetaSpriteNext = pMetaSprite->pNext;

                // Get sprite from MetaSprite.

                pSpMoveSpriteFromMeta(poDev.hdev(), poMeta.hdev(),
                                     pMetaSprite, iIndex);

                pMetaSprite = pMetaSpriteNext;
            }
        }
        else
        {
            // First, convert sprites in poDev to meta sprites into poMeta

            pSprite = pStateDev->pListZ;
            while (pSprite != NULL)
            {
                // Grab the 'next' pointer while we can, because we're about
                // to delete 'pSprite'!

                pSpriteNext = pSprite->pNextZ;

                // Convert to meta sprite. "pSprite" in parameter, will be
                // deleted inside pSpConvertSpriteToMeta().

                pMetaSpriteNew = pSpConvertSpriteToMeta(poMeta.hdev(),
                                                        poDev.hdev(),
                                                        pSprite);

                if (pMetaSpriteNew != NULL)
                {
                    // Mark the new sprites in 'B's list as being just
                    // of transferring:

                    pMetaSpriteNew->fl |= SPRITE_FLAG_JUST_TRANSFERRED;
                }

                pSprite = pSpriteNext;
            }

            // Second, convert sprites in poMeta to regular sprites into poDev.

            pMetaSprite = pStateMeta->pListMeta;
            while (pMetaSprite != NULL)
            {
                // Grab the 'next' pointer while we can, because we're about
                // to delete 'pMetaSprite'!

                pMetaSpriteNext = pMetaSprite->pNext;

                // The 'just-transferred' flag is so that we don't convert
                // back to regular sprites we just converted to meta.

                if (!(pMetaSprite->fl & SPRITE_FLAG_JUST_TRANSFERRED))
                {
                    // Convert from meta sprite. "pMetaSprite" in parameter, will
                    // be deleted inside pSpConvertSpriteFromMeta().

                    pSpriteNew = pSpConvertSpriteFromMeta(poDev.hdev(),
                                                          poMeta.hdev(),
                                                          pMetaSprite);
                }
                else
                {
                    pMetaSprite->fl &= ~SPRITE_FLAG_JUST_TRANSFERRED;
                }

                pMetaSprite = pMetaSpriteNext;
            }
        }
    }
}

/***************************************************************************\
* pSpGetSprite
*
* Returns the pointer to the associated sprite, given either a sprite
* handle or a window handle.
*
*  8-Oct-1997 -by- Vadim Gorokhovsky [vadimg]
* Wrote it.
\***************************************************************************/

SPRITE* pSpGetSprite(
SPRITESTATE*    pState,
HWND            hwnd,
HANDLE          hSprite = NULL)
{
    SPRITE* pSprite;

    pSprite = (SPRITE*) hSprite;
    if ((pSprite == NULL) && (hwnd != NULL))
    {
        for (pSprite = pState->pListZ;
             pSprite != NULL;
             pSprite = pSprite->pNextZ)
        {
            if (pSprite->hwnd == hwnd)
                break;
        }
    }

    return(pSprite);
}

/***************************************************************************\
* pSpGetMetaSprite
*
* Returns the pointer to the associated meta-sprite, given either a
* meta-sprite handle or a window handle.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

METASPRITE* pSpGetMetaSprite(
SPRITESTATE*    pState,
HWND            hwnd,
HANDLE          hSprite = NULL)
{
    METASPRITE* pMetaSprite;

    ASSERTGDI((hwnd != NULL) || (hSprite != NULL),
        "Expected a non-NULL handle");

    pMetaSprite = (METASPRITE*) hSprite;
    if ((pMetaSprite == NULL) && (hwnd != NULL))
    {
        for (pMetaSprite = pState->pListMeta;
             pMetaSprite != NULL;
             pMetaSprite = pMetaSprite->pNext)
        {
            if (pMetaSprite->hwnd == hwnd)
                break;
        }
    }

    return(pMetaSprite);
}

/***************************************************************************\
* VOID vSpZorderSprite
*
* Re-arranges the sprite z-order, which goes from bottom-most to top-most.
*
*  8-Oct-1997 -by- Vadim Gorokhovsky [vadimg]
* Wrote it.
\***************************************************************************/

VOID vSpZorderSprite(
HDEV    hdev,
SPRITE* pSprite,                // May be NULL
SPRITE* pSpriteInsertAfter)     // May be NULL to make sprite bottom-most
{
    SPRITESTATE*    pState;
    SPRITE*         pTmp;

    PDEVOBJ po(hdev);

    pState = po.pSpriteState();

    DEVLOCKOBJ dlo(po);
    SPRITELOCK slock(po);

    pTmp = pState->pListZ;
    if ((pSprite == NULL) || (pTmp == NULL))
    {
        return;
    }

    // First, unlink pSprite from the list.  Setting pSprite->pNextZ
    // to NULL is mostly for debug purposes.

    if (pTmp == pSprite)
    {
        pState->pListZ = pTmp->pNextZ;
        pTmp->pNextZ = NULL;
    }
    else
    {
        SPRITE* pSpritePrev;

        do {

            if (pTmp == pSprite)
            {
                pSpritePrev->pNextZ = pTmp->pNextZ;
                pTmp->pNextZ = NULL;
                break;
            }

            pSpritePrev = pTmp;
            pTmp = pTmp->pNextZ;

        } while (pTmp != NULL);
    }

    // This would be bad, we probably didn't find it in the list:

    if (pSprite->pNextZ != NULL)
    {
        WARNING("vSpZorderSprite: sprite not unlinked!");
        return;
    }

    if (pSpriteInsertAfter == NULL)
    {
        // Insert pSprite as the bottom-most one, i.e. first in the list:

        pSprite->pNextZ = pState->pListZ;
        pState->pListZ = pSprite;
    }
    else
    {
        pSprite->pNextZ = pSpriteInsertAfter->pNextZ;
        pSpriteInsertAfter->pNextZ = pSprite;
    }

    vSpRenumberZOrder(pState);

    pState->bValidRange = FALSE;

    vSpRedrawSprite(pSprite);
}

/***************************************************************************\
* BOOL bSpPtInSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

BOOL bSpPtInSprite(
SPRITE* pSprite,
int     x,
int     y)
{
    BOOL            bRet = FALSE;           // Assume failure
    SPRITESTATE*    pState;
    SURFOBJ*        psoHitTest;
    POINTL          OffHitTest;
    RECTL           rclPoint;
    ULONG*          pulPixel;
    FLONG           flModeMasks;

    if (!pSprite)
    {
        return FALSE;
    }

    pState = pSprite->pState;

    PDEVOBJ po(pState->hdev);

    DEVLOCKOBJ dlo(po);                     // Needed to access 'pState'
    SPRITELOCK slock(po);

    psoHitTest = pState->psoHitTest;

    rclPoint.left   = x;
    rclPoint.top    = y;
    rclPoint.right  = x + 1;
    rclPoint.bottom = y + 1;

    // Compute the mode masks.  Hit surface has same format as the screen.

    XEPALOBJ palHitTest(
        SURFOBJ_TO_SURFACE_NOT_NULL(pSprite->pState->psoScreen)->ppal());

    if (palHitTest.bIsBitfields())
    {
        // Bug 280033: Make sure we only check to see if bits contained in
        // one of bitfields below have been modified.  If we don't do this,
        // then we would get the wrong answer in some cases, such as 16bpp
        // at 5-5-5 where the alphablend code would zero out the 16th bit,
        // which doesn't mean that the sprite is visible because the value
        // of that bit is undefined in this particular color resolution.

        flModeMasks = palHitTest.flRed() |
                      palHitTest.flGre() |
                      palHitTest.flBlu();
    }
    else
    {
        // Doesn't matter what we put here because bits that don't belong to
        // the color won't be modified by the alphablend code.

        flModeMasks = 0xffffffff;
    }


    // First, see if the point intersects the sprite's bounds.
    // If not, we're done.

    if (bIntersect(&pSprite->rclSprite, &rclPoint))
    {
        OffHitTest.x = -x;
        OffHitTest.y = -y;

        pulPixel = (ULONG*) psoHitTest->pvScan0;

        ASSERTGDI(psoHitTest->iType == STYPE_BITMAP,
            "Hit-test surface must be STYPE_BITMAP!");

        // Okay, now let's narrow it down.  To deal with
        // alpha, transparency, and funky transforms, we
        // accomplish the hit testing by setting a pixel to
        // a specific value, asking the sprite to redraw that
        // pixel, and then checking to see if the value
        // changed.
        //
        // We actually don't have to do this for rectangular,
        // non-rotated opaque sprites...

        *pulPixel = 0L;
        vSpComposite(pSprite, &OffHitTest, psoHitTest, &rclPoint);
        if (((*pulPixel) & flModeMasks) != 0)
        {
            bRet = TRUE;
        }
        else
        {
            // Unfortunately, the sprite may have chosen to draw in
            // the colour that we used to do the check.  So to make
            // sure, try again using a different colour:

            *pulPixel = ~0L;
            vSpComposite(pSprite, &OffHitTest, psoHitTest, &rclPoint);

            bRet = (((*pulPixel) & flModeMasks) != flModeMasks);
        }
    }

    return(bRet);
}

/***************************************************************************\
* VOID vSpUpdateSpriteVisRgn
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

VOID vSpUpdateSpriteVisRgn(
HDEV    hdev)
{
    SPRITESTATE*    pState;
    SPRITE*         pSprite;
    POINTL          Offset;
    BOOL            bMore;
    BOOL            bEqual;
    REGION*         prgnOld;
    REGION*         prgnNew;
    CLIPENUMRECT    ClipOld;
    CLIPENUMRECT    ClipNew;
    BOOL            bOldMore;
    BOOL            bNewMore;
    ULONG           i;

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    pSprite = pState->pListZ;
    if (pSprite == NULL)
        return;

    for (pSprite = pState->pListZ;
         pSprite != NULL;
         pSprite = pSprite->pNextZ)
    {
        if (pSprite->hwnd != NULL)
        {
            UserVisrgnFromHwnd(&pState->hrgn, pSprite->hwnd);

            RGNMEMOBJ rmoNew;
            RGNOBJAPI roClip(pState->hrgn, FALSE);

            if (!roClip.bValid() || !rmoNew.bValid() || !rmoNew.bCopy(roClip))
            {
                rmoNew.vDeleteRGNOBJ();
            }
            else
            {
                // Adjust for this device's multi-mon offset:

                Offset.x = -po.pptlOrigin()->x;
                Offset.y = -po.pptlOrigin()->y;

                rmoNew.bOffset(&Offset);

                // Assume that the two regions will be equal:

                bEqual = TRUE;

                // Now check to see if the two clip regions really are equal:

                prgnNew = rmoNew.prgnGet();
                prgnOld = pSprite->prgnClip;

                if (prgnOld == NULL)
                {
                    // There was no old region.  Let's assume the new one
                    // doesn't have trivial clipping:

                    bEqual = FALSE;
                }
                else
                {
                    ECLIPOBJ ecoOld;
                    ECLIPOBJ ecoNew;
                    ERECTL   erclUnclipped;

                    // If the sprite was not visible due to clipping,
                    // bSpUpdatePosition leaves 'rclSprite' as empty.
                    // Consequently, we can't use 'rclSprite' to determine
                    // the clip object complexity.  Re-derive the
                    // unclipped sprite bounds:

                    erclUnclipped.left   = pSprite->ptlDst.x;
                    erclUnclipped.top    = pSprite->ptlDst.y;
                    erclUnclipped.right  = erclUnclipped.left
                        + (pSprite->rclSrc.right - pSprite->rclSrc.left);
                    erclUnclipped.bottom = erclUnclipped.top
                        + (pSprite->rclSrc.bottom - pSprite->rclSrc.top);

                    ecoOld.vSetup(prgnOld, erclUnclipped);
                    ecoNew.vSetup(prgnNew, erclUnclipped);

                    if (ecoOld.erclExclude().bEmpty() ^
                        ecoNew.erclExclude().bEmpty())
                    {
                        // One or the other (but not both) are empty, so are
                        // unequal:

                        bEqual = FALSE;
                    }
                    else if ((ecoOld.iDComplexity == DC_TRIVIAL) &&
                             (ecoNew.iDComplexity == DC_TRIVIAL))
                    {
                        // Both are trivially clipped, so are equal.
                    }
                    else if (ecoOld.iDComplexity != ecoNew.iDComplexity)
                    {
                        // The clipping complexity is different, so the regions are
                        // unequal:

                        bEqual = FALSE;
                    }
                    else
                    {
                        // Okay, we've got work to do.  We want to see if the
                        // regions are any different where it intersects with the
                        // sprite.  We do this by constructing and enumerating
                        // corresponding clip objects:

                        ecoOld.cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);
                        ecoNew.cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

                        bOldMore = TRUE;
                        bNewMore = TRUE;

                        do {
                            ClipOld.c = 0;
                            ClipNew.c = 0;

                            if (bOldMore)
                                bOldMore = ecoOld.bEnum(sizeof(ClipOld), &ClipOld);
                            if (bNewMore)
                                bNewMore = ecoNew.bEnum(sizeof(ClipNew), &ClipNew);

                            if (ClipOld.c != ClipNew.c)
                            {
                                bEqual = FALSE;
                                break;
                            }

                            for (i = 0; i < ClipOld.c; i++)
                            {
                                if ((ClipNew.arcl[i].left
                                        != ClipOld.arcl[i].left)  ||
                                    (ClipNew.arcl[i].top
                                        != ClipOld.arcl[i].top)   ||
                                    (ClipNew.arcl[i].right
                                        != ClipOld.arcl[i].right) ||
                                    (ClipNew.arcl[i].bottom
                                        != ClipOld.arcl[i].bottom))
                                {
                                    bEqual   = FALSE;
                                    bOldMore = FALSE;
                                    bNewMore = FALSE;
                                    break;
                                }
                            }
                        } while (bOldMore || bNewMore);
                    }
                }

                // Free the old region (if any) and set the new one:

                vSpFreeClipResources(pSprite);
                pSprite->prgnClip = prgnNew;
                pSprite->prgnClip->vStamp();

                // Grab some locks we need for drawing.

                PDEVOBJ po(pState->hdev);

                DEVLOCKOBJ dlo(po);
                SPRITELOCK slock(po);

                // We detect the case when the sprite has an empty VisRgn
                // primarily for DirectDraw, so that we can unhook sprites
                // and get out of its way when it goes full-screen.
                //
                // Note that we have to do this obscured check even if 'bEqual'
                // is true because 'bEqual' applies only to the intersection
                // with the current sprite rectangle, and the obscuring flag is
                // independent of the sprite size or location.

                pSprite->fl &= ~SPRITE_FLAG_CLIPPING_OBSCURED;
                if (rmoNew.bInside(&pState->rclScreen) != REGION_RECT_INTERSECT)
                    pSprite->fl |= SPRITE_FLAG_CLIPPING_OBSCURED;

                bSpUpdatePosition(pSprite, &pSprite->ptlDst);

                if (gpto != NULL)
                {
                    vSpCheckForWndobjOverlap(pState,
                                             &pSprite->rclSprite,
                                             &pSprite->rclSprite);
                }

                // Only if the regions, intersected with the sprite, are unequal
                // do we do the repaint.  We do this because we get called
                // constantly when any window is moving, even if none of the
                // movement intersects with the sprite.

                if (!bEqual)
                {
                    // Note that we could go further and just redraw the
                    // difference in the regions.  At this point, I can't
                    // be bothered.  We'll redraw the whole thing.

                    vSpRedrawSprite(pSprite);
                }
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// Window Manager callable functions
/////////////////////////////////////////////////////////////////////////////

/***************************************************************************\
* BOOL GreCreateSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

HANDLE GreCreateSprite(
HDEV    hdev,
HWND    hwnd,
RECT*   prc)
{
    SPRITESTATE*    pState;
    METASPRITE*     pMetaSprite;
    SPRITE*         pSprite;
    ULONG           cjAlloc;
    ULONG           i;
    HANDLE          pRet = NULL;

    PDEVOBJ po(hdev);

    pState = po.pSpriteState();

    // When running multi-mon, handle the creation of the meta sprite:

    if (pState->cMultiMon)
    {
        cjAlloc = sizeof(METASPRITE)
                + pState->cMultiMon * sizeof(pMetaSprite->apSprite[0]);

        pMetaSprite = (METASPRITE*) PALLOCNOZ(cjAlloc, 'mpsG');
        if (pMetaSprite)
        {
            for (i = 0; i < pState->cMultiMon; i++)
            {
                PDEVOBJ poMon(pState->ahdevMultiMon[i]);

                POINTL *pptlDstInit = NULL;
                POINTL ptlDstInit;

                if (prc)
                {
                    ptlDstInit.x = prc->left - poMon.pptlOrigin()->x;
                    ptlDstInit.y = prc->top  - poMon.pptlOrigin()->y;
                    pptlDstInit = &ptlDstInit;
                }

                pSprite = pSpCreateSprite(pState->ahdevMultiMon[i],
                                          (RECTL*) prc,
                                          hwnd,
                                          pptlDstInit);
                if (pSprite == NULL)
                {
                    for (; i > 0; i--)
                    {
                        vSpDeleteSprite(pMetaSprite->apSprite[i - 1]);
                    }

                    VFREEMEM(pMetaSprite);
                    return(pRet);
                }

                pMetaSprite->apSprite[i] = pSprite;
                pSprite->pMetaSprite = pMetaSprite;
            }

            pMetaSprite->hwnd     = hwnd;
            pMetaSprite->chSprite = pState->cMultiMon;
            pMetaSprite->fl       = 0;

            // Add this node to the head of the meta-sprite list:

            pMetaSprite->pNext = pState->pListMeta;
            pState->pListMeta  = pMetaSprite;

            pRet = pMetaSprite;
        }
    }
    else
    {
        // Note that USER doesn't actually need the pointer to the sprite
        // since it uses pSpGetSprite to reference the sprite.

        pRet = pSpCreateSprite(hdev, (RECTL*) prc, hwnd);
    }

    return(pRet);
}

/***************************************************************************\
* BOOL GreDeleteSprite
*
*  8-Oct-1997 -by- Vadim Gorokhovsky [vadimg]
* Wrote it.
\***************************************************************************/

BOOL GreDeleteSprite(
HDEV    hdev,
HWND    hwnd,
HANDLE  hSprite)
{
    SPRITESTATE*    pState;
    METASPRITE*     pMetaSprite;
    METASPRITE*     pTmp;
    SPRITE*         pSprite;
    ULONG           i;
    BOOL            bRet = FALSE;

    PDEVOBJ po(hdev);

    pState = po.pSpriteState();
    if (pState->cMultiMon)
    {
        pMetaSprite = pSpGetMetaSprite(pState, hwnd, hSprite);
        if (pMetaSprite)
        {
            for (i = 0; i < pState->cMultiMon; i++)
            {
                vSpDeleteSprite(pMetaSprite->apSprite[i]);
            }

            // Remove this sprite from the linked list:

            if (pState->pListMeta == pMetaSprite)
            {
                pState->pListMeta = pMetaSprite->pNext;
            }
            else
            {
                for (pTmp = pState->pListMeta;
                     pTmp->pNext != pMetaSprite;
                     pTmp = pTmp->pNext)
                    ;

                pTmp->pNext = pMetaSprite->pNext;
            }

            VFREEMEM(pMetaSprite);

            bRet = TRUE;
        }
    }
    else
    {
        pSprite = pSpGetSprite(pState, hwnd, hSprite);
        if (pSprite)
        {
            vSpDeleteSprite(pSprite);
            bRet = TRUE;
        }
    }

    return(bRet);
}

/***************************************************************************\
* BOOL GreGetSpriteAttributes
*
*  14-Mar-2000 -by- Jeff Stall [jstall]
* Wrote it.
\***************************************************************************/

BOOL GreGetSpriteAttributes(
HDEV            hdev,
HWND            hwnd,
HANDLE          hSprite,
COLORREF*       lpcrKey,
BLENDFUNCTION*  pblend,
DWORD*          pdwFlags)
{
    SPRITESTATE*    pState;
    SPRITE*         pSprite = NULL;
    BOOL            bRet = FALSE;
    PDEVOBJ po(hdev);

    ASSERTGDI(lpcrKey != NULL, "Ensure valid pointer");
    ASSERTGDI(pblend != NULL, "Ensure valid pointer");
    ASSERTGDI(pdwFlags != NULL, "Ensure valid pointer");

    //
    // Get the sprite object.
    //

    pState = po.pSpriteState();
    if (pState->cMultiMon)
    {
        //
        // On a multimon system, query the values from the first sprite.
        //

        METASPRITE * pMetaSprite = pSpGetMetaSprite(pState, hwnd, hSprite);
        if (pMetaSprite != NULL)
        {
            pSprite = pMetaSprite->apSprite[0];
            ASSERTGDI(pSprite != NULL, "Sprite should exist");
        }
    }
    else
    {
        pSprite = pSpGetSprite(pState, hwnd, hSprite);
    }


    //
    // Query the data from the sprite.
    //

    if (pSprite != NULL)
    {
        bRet = TRUE;

        *lpcrKey = pSprite->cachedAttributes.crKey;
        *pblend = pSprite->cachedAttributes.bf;
        *pdwFlags = pSprite->cachedAttributes.dwShape;
    }

    return(bRet);
}


/***************************************************************************\
* BOOL GreUpdateSprite
*
*  8-Oct-1997 -by- Vadim Gorokhovsky [vadimg]
* Wrote it.
\***************************************************************************/

BOOL GreUpdateSprite(
HDEV            hdev,
HWND            hwnd,
HANDLE          hSprite,
HDC             hdcDst,
POINT*          pptDst,
SIZE*           psize,
HDC             hdcSrc,
POINT*          pptSrc,
COLORREF        crKey,
BLENDFUNCTION*  pblend,
DWORD           dwShape,
RECT*           prcDirty)
{
    SPRITESTATE*    pState;
    METASPRITE*     pMetaSprite;
    SPRITE*         pSprite;
    ULONG           i;
    POINTL*         pptlDstTmp;
    POINTL          ptlDstTmp;
    BOOL            bRet = FALSE;
    ERECTL          erclDirty;

    if (prcDirty)
    {
        // Let's make sure we don't modify the caller memory pointed to by
        // prcldirty

        erclDirty = *((ERECTL *) prcDirty);
        prcDirty = (RECT *) &erclDirty;
    }

    PDEVOBJ po(hdev);

    if (po.bDisabled())
        return bRet;

    pState = po.pSpriteState();
    if (pState->cMultiMon)
    {
        pMetaSprite = pSpGetMetaSprite(pState, hwnd, hSprite);
        if (pMetaSprite)
        {
            bRet = TRUE; // This allows us to record single monitor
                         // failures by ANDing bRet with the return
                         // value from bSpUpdateSprite

            for (i = 0; i < pState->cMultiMon; i++)
            {
                PDEVOBJ po(pState->ahdevMultiMon[i]);

                pptlDstTmp = NULL;
                if (pptDst != NULL)
                {
                    ptlDstTmp.x = pptDst->x - po.pptlOrigin()->x;
                    ptlDstTmp.y = pptDst->y - po.pptlOrigin()->y;
                    pptlDstTmp = &ptlDstTmp;
                }

                bRet &= bSpUpdateSprite(pMetaSprite->apSprite[i],
                                        hdcDst,
                                        pptlDstTmp,
                                        psize,
                                        hdcSrc,
                                        (POINTL*) pptSrc,
                                        crKey,
                                        pblend,
                                        dwShape,
                                        (RECTL*)prcDirty);
            }
        }
    }
    else
    {
        pSprite = pSpGetSprite(pState, hwnd, hSprite);
        if (pSprite)
        {
            bRet = bSpUpdateSprite(pSprite,
                                   hdcDst,
                                   (POINTL*) pptDst,
                                   psize,
                                   hdcSrc,
                                   (POINTL*) pptSrc,
                                   crKey,
                                   pblend,
                                   dwShape,
                                   (RECTL*) prcDirty);
        }
    }

    return(bRet);
}

/***************************************************************************\
* BOOL GrePtInSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

BOOL APIENTRY GrePtInSprite(
HDEV    hdev,
HWND    hwnd,
int     x,
int     y)
{
    SPRITESTATE*    pState;
    METASPRITE*     pMetaSprite;
    SPRITE*         pSprite;
    ULONG           i;
    BOOL            bRet = FALSE;

    PDEVOBJ po(hdev);

    pState = po.pSpriteState();
    if (pState->cMultiMon)
    {
        pMetaSprite = pSpGetMetaSprite(pState, hwnd);
        if (pMetaSprite)
        {
            for (i = 0; i < pState->cMultiMon; i++)
            {
                PDEVOBJ po(pState->ahdevMultiMon[i]);

                if (bSpPtInSprite(pMetaSprite->apSprite[i],
                                  x - po.pptlOrigin()->x,
                                  y - po.pptlOrigin()->y))
                {
                    bRet = TRUE;
                    break;
                }
            }
        }
    }
    else
    {
        pSprite = pSpGetSprite(pState, hwnd);
        if (pSprite)
        {
            bRet = bSpPtInSprite(pSprite, x, y);
        }
    }

    return(bRet);
}

/***************************************************************************\
* BOOL GreUpdateSpriteVisRgn
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

VOID APIENTRY GreUpdateSpriteVisRgn(
HDEV    hdev)
{
    ULONG           i;
    SPRITESTATE*    pState;
    BOOL            bRet = TRUE;

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    if (pState->cMultiMon)
    {
        for (i = 0; i < pState->cMultiMon; i++)
        {
            vSpUpdateSpriteVisRgn(pState->ahdevMultiMon[i]);
        }
    }
    else
    {
        vSpUpdateSpriteVisRgn(pState->hdev);
    }
}

/***************************************************************************\
* BOOL GreZorderSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

VOID APIENTRY GreZorderSprite(
HDEV    hdev,
HWND    hwnd,
HWND    hwndInsertAfter)
{
    SPRITESTATE*    pState;
    ULONG           i;

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    if (pState->cMultiMon)
    {
        for (i = 0; i < pState->cMultiMon; i++)
        {
            HDEV hdevSingle = pState->ahdevMultiMon[i];
            PDEVOBJ poSingle(hdevSingle);
            SPRITESTATE *pSpriteStateSingle = poSingle.pSpriteState();

            vSpZorderSprite(hdevSingle,
                            pSpGetSprite(pSpriteStateSingle, hwnd),
                            pSpGetSprite(pSpriteStateSingle, hwndInsertAfter));
        }
    }
    else
    {
        vSpZorderSprite(pState->hdev,
                        pSpGetSprite(pState, hwnd),
                        pSpGetSprite(pState, hwndInsertAfter));
    }
}

/////////////////////////////////////////////////////////////////////////////
// Software Cursors
/////////////////////////////////////////////////////////////////////////////

/******************************Public*Routine******************************\
* BOOL SpUpdateCursor
*
* Updates the shape for a cursor.
*
* Returns FALSE if the function fails, and sets both 'pSprite->psoMask'
* and 'pSprite->psoShape' to NULL.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpUpdateCursor(
SPRITE*         pSprite,
SURFOBJ*        psoMono,
SURFOBJ*        psoColor,
XLATEOBJ*       pxlo,
RECTL*          prclBounds)         // Defines the parts of 'psoMono' and
                                    //   'psoColor' to be used
{
    BOOL            bRet = FALSE;   // Assume failure
    SPRITESTATE*    pState;
    RECTL           rclSrc;
    SURFOBJ*        psoMask;
    DEVBITMAPINFO   dbmi;
    SURFMEM         SurfDimo;

    pState = pSprite->pState;

    PDEVOBJ po(pState->hdev);

    // Initialize some state for the sprite:

    pSprite->rclSrc = *prclBounds;

    if (psoMono == NULL)
    {
        // Handle the alpha cursor case:

        ASSERTGDI((psoColor != NULL) &&  (psoColor->iBitmapFormat == BMF_32BPP),
            "Expected BGRA surface");
        ASSERTGDI((prclBounds->right  <= (psoColor->sizlBitmap.cx)) &&
                  (prclBounds->bottom <= (psoColor->sizlBitmap.cy)),
            "Bounds out of bounds");

        // Mark this as an 'alpha' sprite:

        pSprite->dwShape                           = ULW_ALPHA;
        pSprite->BlendFunction.AlphaFormat         = AC_SRC_ALPHA;
        pSprite->BlendFunction.BlendOp             = AC_SRC_OVER;
        pSprite->BlendFunction.BlendFlags          = 0;
        pSprite->BlendFunction.SourceConstantAlpha = 0xff;

        vSpCreateShape(pSprite,
                       &gptlZero,
                       psoColor,
                       NULL,
                       prclBounds,
                       gppalRGB,
                       BMF_32BPP,
                       TRUE);    // Allocate from system memory because the
                                 // Alpha Blending will most likely be done by
                                 // the CPU, and it's expensive to transfer the
                                 // cursor bitmap across the bus every time

        bRet = (pSprite->psoShape != NULL);
    }
    else
    {
        // Handle the non-alpha cursor case:

        ASSERTGDI((prclBounds->right  <= (psoMono->sizlBitmap.cx)) &&
                  (prclBounds->bottom <= (psoMono->sizlBitmap.cy >> 1)),
            "Bounds out of bounds");

        psoMask = pSprite->psoMask;
        if (psoMask != NULL)
        {
            // If the new mask is different sized than the old cached mask,
            // free up the old cached mask:

            if ((psoMask->sizlBitmap.cx != psoMono->sizlBitmap.cx) ||
                (psoMask->sizlBitmap.cy != psoMono->sizlBitmap.cy))
            {
                bDeleteSurface(psoMask->hsurf);
                psoMask = NULL;
            }
        }

        // Create a surface to hold a copy of the mask:

        if (psoMask == NULL)
        {
            dbmi.iFormat  = BMF_1BPP;
            dbmi.cxBitmap = psoMono->sizlBitmap.cx;
            dbmi.cyBitmap = psoMono->sizlBitmap.cy;
            dbmi.fl       = BMF_TOPDOWN;
            dbmi.hpal     = NULL;

            if (SurfDimo.bCreateDIB(&dbmi, NULL))
            {
                psoMask = SurfDimo.pSurfobj();
                SurfDimo.vKeepIt();
                SurfDimo.vSetPID(OBJECT_OWNER_PUBLIC);
            }
        }

        // Copy the mask:

        pSprite->psoMask = psoMask;
        if (psoMask != NULL)
        {
            // Use the given bounds for the copy, adjusting 'bottom' so that
            // we can copy both the 'AND' parts and the 'OR' parts in one blt:

            rclSrc = *prclBounds;
            rclSrc.bottom += (psoMask->sizlBitmap.cy >> 1);

            EngCopyBits(psoMask, psoMono, NULL, NULL, &rclSrc, (POINTL*) &rclSrc);
        }

        // Now account for the color surface, if there is one:

        if (psoColor == NULL)
        {
            vSpDeleteShape(pSprite);

            bRet = TRUE;
        }
        else
        {
            vSpCreateShape(pSprite,
                           &gptlZero,
                           psoColor,
                           pxlo,
                           prclBounds,
                           po.ppalSurf(),
                           0,
                           FALSE);    // Allocate from video memory if
                                      // possible, because the blit can be
                                      // done entirely on the video card, and
                                      // it's faster when the cursor bitmap is
                                      // already there.

            bRet = (pSprite->psoShape != NULL);
        }

        // Finally, mark this as a non-alpha 'cursor' sprite, and update some of
        // the sprite fields that would normally be updated by vSpCreateShape:

        pSprite->dwShape     = ULW_CURSOR;
        pSprite->flModeMasks = pState->flModeMasks;
        pSprite->iModeFormat = pState->iModeFormat;
    }

    return(bRet);
}

/***************************************************************************\
* ULONG EngMovePointer
*
* Move the engine managed pointer on the device.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

VOID EngMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)       // Ignored
{
    GDIFunctionID(EngMovePointer);

    SPRITESTATE*    pState;
    SPRITE*         pSprite;
    POINTL          ptlDst;

    PDEVOBJ po(pso->hdev);

    pState = po.pSpriteState();

    if (pState->pTopCursor != NULL)
    {
        SPRITELOCK slock(po);

        if(pState->pBottomCursor != pState->pTopCursor)
        {
            // rotate cursors if enough time has past

            ULONG tickCount = NtGetTickCount();
            ULONG elapsedTicks = tickCount - pState->ulTrailTimeStamp;

            if(elapsedTicks >= pState->ulTrailPeriod)
            {
                // trial maintenance time ... either spawn off a new trail cursor
                // or hide the oldest

                // find the first trail cursor (cursor before top)

                pSprite = pState->pBottomCursor;
                while(pSprite->pNextZ != pState->pTopCursor) pSprite = pSprite->pNextZ;

                // if it does not coincide with top cursor then spawn off another

                if(pSprite->rclSprite.left != pState->pTopCursor->rclSprite.left ||
                   pSprite->rclSprite.top != pState->pTopCursor->rclSprite.top)
                {
                    // hide the bottom most cursor

                    pSprite = pState->pBottomCursor;
        
                    bSpUpdatePosition(pSprite, NULL);
                    // rotate hidden cursor to front most
                    pState->pBottomCursor = pSprite->pNextZ;
        
                    // Reorder sprites
        
                    vSpZorderSprite(pso->hdev, pSprite, pState->pTopCursor);
        
                    pState->pTopCursor = pSprite;
        
                }
                else
                {
                    // otherwise hide oldest visible trail
                    
                    pSprite = pState->pBottomCursor;
                    while(pSprite != pState->pTopCursor)
                    {
                        if (pSprite->fl & SPRITE_FLAG_VISIBLE)
                        {
                            ASSERTGDI(pSprite->rclSprite.left != pSprite->rclSprite.right, "Invalid rclSprite for visible sprite.\n");
                            bSpUpdatePosition(pSprite, NULL);
                            break;
                        }
                        pSprite = pSprite->pNextZ;
                    }

                }

                // update time stamp
                pState->ulTrailTimeStamp = tickCount;

            }


        }
        
        if (x == -1)
        {
            // hide all cursors

            ptlDst.x = LONG_MAX;
            ptlDst.y = LONG_MAX;

            pSprite = pState->pBottomCursor;
            
            while(pSprite != NULL)
            {
                bSpUpdatePosition(pSprite, &ptlDst, FALSE);

                pSprite = pSprite->pNextZ;
            }
        }
        else
        {
            ptlDst.x = x - pState->xHotCursor;
            ptlDst.y = y - pState->yHotCursor;

            // update the position of the top most cursor

            pSprite = pState->pTopCursor;

            bSpUpdatePosition(pSprite, &ptlDst);
            vSpRedrawSprite(pSprite);
        }

        // Nothing is more irritating than having a cursor that 'lags'.  If
        // the driver is a DDI batching driver (meaning that it updates the
        // screen only occassionally unless we explicitly call DrvSynchronize),
        // let's force it to update the screen now:

        if (po.flGraphicsCaps2() & GCAPS2_SYNCTIMER)
        {
            po.vSync(po.pSurface()->pSurfobj(), NULL, DSS_TIMER_EVENT);
        }
    }
}

/***************************************************************************\
* ULONG EngSetPointerShape
*
* Sets the pointer shape for the GDI pointer simulations.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

ULONG EngSetPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMask,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prclBounds,
FLONG       fl)
{
    HDEV            hdev;
    SPRITESTATE*    pState;
    SPRITE*         pSprite;
    ULONG           ulRet = SPS_ACCEPT_NOEXCLUDE;
    ULONG           numCursors = ((fl & SPS_LENGTHMASK) >> 8) + 1;
    ULONG           ulFreq = (fl & SPS_FREQMASK) >> 12;
    ULONG           ulTrailPeriod = (ulFreq == 0 ? 0 : 1000 / ulFreq);

    hdev = pso->hdev;

    PDEVOBJ po(hdev);

    pState = po.pSpriteState();

    // Handle the hide case.  We take the opportunity to delete the sprite,
    // so that we can start out fresh the next time.

    if ((psoMask == NULL) && (psoColor == NULL))
    {

        pSprite = pState->pBottomCursor;

        while(pSprite != NULL)
        {
            SPRITE*         pNextSprite = pSprite->pNextZ;
            vSpDeleteSprite(pSprite);
            pSprite = pNextSprite;
        }

        pState->pTopCursor = NULL;
        pState->pBottomCursor = NULL;
        pState->ulNumCursors = 0;

        return(SPS_ACCEPT_NOEXCLUDE);
    }

    // adjust the number of cursors

    while (pState->ulNumCursors < numCursors)
    {
        pSprite = pSpCreateSprite(hdev, NULL, 0);

        if(pSprite == NULL)
            break;
         
        if(pState->pTopCursor == NULL)
        {
            pState->pTopCursor = pSprite;
        }

        pState->pBottomCursor = pSprite;

        pState->ulNumCursors++;
    }

    while(pState->ulNumCursors > numCursors)
    {
        pSprite = pState->pBottomCursor;
        pState->pBottomCursor = pSprite->pNextZ;
        vSpDeleteSprite(pSprite);
        pState->ulNumCursors--;
    }

    pState->ulTrailPeriod = ulTrailPeriod;

    // Handle the show case.
    if (pState->pTopCursor != NULL)
    {
        // hide and update the shape of all cursors

        pSprite = pState->pBottomCursor;

        // hide cursors
        {
            SPRITELOCK slock(po);
    
            while(pSprite != NULL)
            {
    
                bSpUpdatePosition(pSprite, NULL, FALSE);
                vSpRedrawSprite(pSprite);
    
    
                pSprite = pSprite->pNextZ;
            }
        }

        // update the shapes

        pSprite = pState->pBottomCursor;

        while(pSprite != NULL)
        {

            if (!bSpUpdateCursor(pSprite, psoMask, psoColor, pxlo, prclBounds))
            {
                ulRet = SPS_ERROR;
                break;
            }

            pSprite = pSprite->pNextZ;
        }

        // Remember the hot spot and force EngMovePointer to redraw:

        pState->xHotCursor = xHot - prclBounds->left;
        pState->yHotCursor = yHot - prclBounds->top;
    }

    // Draw the cursor.  Note that it's okay if 'pSpriteCursor' is NULL:

    EngMovePointer(pso, x, y, NULL);

    return(ulRet);
}

/******************************Public*Routine******************************\
* ULONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
* History:
*  3-Apr-1996 -by- J. Andrew Goossen andrewgo
* Wrote it.
\**************************************************************************/

ULONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    ULONG   cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}

/******************************Public*Routine******************************\
* BOOL bMoveDevDragRect
*
* Called by USER to move the drag rect on the screen.
*
* Note: Devlock must already have been acquired.
*
* History:
*  3-Apr-1996 -by- J. Andrew Goossen andrewgo
* Wrote it.
\**************************************************************************/

BOOL bMoveDevDragRect(
HDEV   hdev,                // Note that this may be a multi-mon meta-PDEV
RECTL *prclNew)
{
    SPRITESTATE*    pState;
    ULONG           ulDimension;
    ULONG           crclTemp;
    ULONG           i;
    RECTL           arclTemp[4];
    SIZE            siz;

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    po.vAssertDevLock();

    ulDimension = pState->ulDragDimension;

    arclTemp[0].left   = prclNew->left;
    arclTemp[0].right  = prclNew->left   + ulDimension;
    arclTemp[0].top    = prclNew->top;
    arclTemp[0].bottom = prclNew->bottom;

    arclTemp[1].left   = prclNew->right  - ulDimension;
    arclTemp[1].right  = prclNew->right;
    arclTemp[1].top    = prclNew->top;
    arclTemp[1].bottom = prclNew->bottom;

    arclTemp[2].left   = prclNew->left   + ulDimension;
    arclTemp[2].right  = prclNew->right  - ulDimension;
    arclTemp[2].top    = prclNew->top;
    arclTemp[2].bottom = prclNew->top    + ulDimension;

    arclTemp[3].left   = prclNew->left   + ulDimension;
    arclTemp[3].right  = prclNew->right  - ulDimension;
    arclTemp[3].top    = prclNew->bottom - ulDimension;
    arclTemp[3].bottom = prclNew->bottom;

    // We have to clip to the specified rectangle in order to handle
    // chip-window drag-rects for MDI applications.

    crclTemp = cIntersect(&pState->rclDragClip, &arclTemp[0], 4);

    for (i = 0; i < crclTemp; i++)
    {
        siz.cx = arclTemp[i].right - arclTemp[i].left;
        siz.cy = arclTemp[i].bottom - arclTemp[i].top;

        if (pState->ahDragSprite[i])
        {
            GreUpdateSprite(hdev,
                            NULL,
                            pState->ahDragSprite[i],
                            NULL,
                            (POINT*) &arclTemp[i],
                            &siz,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            ULW_DRAGRECT,
                            NULL);
        }
    }

    for (; i < 4; i++)
    {
        if (pState->ahDragSprite[i])
        {
            GreUpdateSprite(hdev, NULL, pState->ahDragSprite[i], NULL, NULL,
                            NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            }
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bSetDevDragRect
*
* Called by USER to slap the drag rect on the screen, or to tear it back
* down.
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
* Converted drag rects to use sprites.
\**************************************************************************/

BOOL bSetDevDragRect(
HDEV   hdev,                    // Note that this may be a multi-mon meta-PDEV
RECTL* prclDrag,
RECTL* prclClip)
{
    SPRITESTATE*    pState;
    RECTL           rclScreen;
    RECTL           arclDrag[4];
    ULONG           crclDrag;
    HANDLE          hSprite;
    ULONG           i;
    BOOL            bRet = TRUE;        // Assume success

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    DEVLOCKOBJ dlo(po);

    pState->bHaveDragRect = FALSE;

    // Create 4 sprites to handle each of the sides of the drag rectangle.

    if (prclDrag != NULL)
    {
        ASSERTGDI(!pState->bHaveDragRect, "Expected not to have a drag rectangle");
        ASSERTGDI(prclClip != NULL, "Expected to have a clip rectangle");

        bRet = TRUE;
        for (i = 0; i < 4; i++)
        {
            hSprite = GreCreateSprite(hdev, NULL, NULL);
            pState->ahDragSprite[i] = hSprite;

            if (!hSprite)
                bRet = FALSE;
        }

        if (bRet)
        {
            pState->bHaveDragRect = TRUE;
            pState->rclDragClip = *prclClip;

            bMoveDevDragRect(hdev, prclDrag);
        }
    }

    // If we don't have a drag rectangle, delete any drag rectangle
    // sprites we may have laying around.

    if (!pState->bHaveDragRect)
    {
        for (i = 0; i < 4; i++)
        {
            if (pState->ahDragSprite[i] != NULL)
            {
                GreDeleteSprite(hdev, NULL, pState->ahDragSprite[i]);
                pState->ahDragSprite[i] = NULL;
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bSetDevDragWidth
*
* Called by USER to tell us how wide the drag rectangle should be.
*
*  24-Aug-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL bSetDevDragWidth(
HDEV    hdev,
ULONG   ulWidth)
{
    PDEVOBJ po(hdev);

    DEVLOCKOBJ dlo(po);

    SPRITESTATE* pState = po.pSpriteState();

    pState->ulDragDimension = ulWidth;

    return(TRUE);
}

/******************************Public*Routine******************************\
* UNDODESKTOPCOORD
*
* Temporariliy convert the WNDOBJ from desktop coordinates to device-
* relative coordinates.
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
\**************************************************************************/

UNDODESKTOPCOORD::UNDODESKTOPCOORD(
EWNDOBJ*     pwo,
SPRITESTATE* pState)
{
    pwoUndo = NULL;
    if ((pwo != NULL) && (pwo->fl & WO_RGN_DESKTOP_COORD))
    {
        PDEVOBJ po(pState->hdev);
        po.vAssertDevLock();

        pwoUndo = pwo;
        xUndo = po.pptlOrigin()->x;
        yUndo = po.pptlOrigin()->y;

        pwo->vOffset(-xUndo, -yUndo);
        pwo->fl &= ~WO_RGN_DESKTOP_COORD;
    }
}

/******************************Public*Routine******************************\
* VOID vSpDeviceControlSprites
*
* Undo our temporary conversion of a WNDOBJ to device-relative coordinates.
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
\**************************************************************************/

UNDODESKTOPCOORD::~UNDODESKTOPCOORD()
{
    if (pwoUndo)
    {
        pwoUndo->vOffset(xUndo, yUndo);
        pwoUndo->fl |= WO_RGN_DESKTOP_COORD;
    }
}

/******************************Public*Routine******************************\
* VOID vSpDeviceControlSprites
*
* Function callable from the driver to control the exclusion of sprites
* from on top of a WNDOBJ window.
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
\**************************************************************************/

VOID vSpDeviceControlSprites(
HDEV     hdev,
EWNDOBJ* pwo,
FLONG    fl)
{
    SPRITESTATE*    pState;
    BOOL            bMore;
    SPRITE*         pSprite;
    RECTL           rclEnum;
    RECTL           rclBounds;

    PDEVOBJ po(hdev);

    po.vAssertDevLock();
    SPRITELOCK slock(po);

    pState = po.pSpriteState();

    // The WNDOBJ coordinates must be device-relative, so
    // use UNDO:

    UNDODESKTOPCOORD udc(pwo, pState);

    if (fl == ECS_TEARDOWN)
    {
        pwo->fl |= WO_NOSPRITES;

        // We only have to do some work if a sprite overlaps the
        // window:

        if ((pwo->fl & WO_SPRITE_OVERLAP) &&
            bIntersect(&pwo->rclBounds, &pState->rclScreen, &rclBounds))
        {
            // Tear down all sprites:

            ENUMAREAS Enum(pState, &rclBounds);

            do {
                bMore = Enum.bEnum(&pSprite, &rclEnum);

                if (pSprite != NULL)
                {
                    OFFCOPYBITS(&gptlZero,
                                pState->psoScreen,
                                &pSprite->OffUnderlay,
                                pSprite->psoUnderlay,
                                pwo,
                                NULL,
                                &rclEnum,
                                (POINTL*) &rclEnum);
                }
            } while (bMore);
        }

        // Now that we're done tearing down, re-compute the
        // unlocked region, to account for the newly locked
        // area.

        vSpComputeUnlockedRegion(pState);
    }
    else
    {
        // Note that it's perfectly fine to call 'redraw' without having
        // first done 'teardown' (this is useful for OpenGL windows when
        // hardware double buffering, in order to prevent the cursor from
        // flickering).

        pwo->fl &= ~WO_NOSPRITES;

        // Re-compute the unlocked region, to account for the changed
        // state.

        vSpComputeUnlockedRegion(pState);

        if ((pwo->fl & WO_SPRITE_OVERLAP) &&
            bIntersect(&pwo->rclBounds, &pState->rclScreen, &rclBounds))
        {
            // First, get the new underlay bits:

            ENUMAREAS Enum(pState, &rclBounds);

            do {
                bMore = Enum.bEnum(&pSprite, &rclEnum);

                if (pSprite != NULL)
                {
                    // All underlays which overlap with this area must be
                    // updated, which explains the following 'bEnumLayers':

                    do {
                        OFFCOPYBITS(&pSprite->OffUnderlay,
                                    pSprite->psoUnderlay,
                                    &gptlZero,
                                    pState->psoScreen,
                                    pwo,
                                    NULL,
                                    &rclEnum,
                                    (POINTL*) &rclEnum);

                    } while (Enum.bEnumLayers(&pSprite));
                }
            } while (bMore);

            // Now draw the sprites:

            vSpRedrawArea(pState, &rclBounds, TRUE);
        }
    }
}

/******************************Public*Routine******************************\
* BOOL EngControlSprites
*
* Multi-mon aware function that's callable from the driver to control the
* exclusion of sprites from on top of a WNDOBJ window.
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
\**************************************************************************/

BOOL EngControlSprites(
WNDOBJ* pwo,
FLONG   fl)
{
    SPRITESTATE*    pState;
    ULONG           i;

    if ((fl != ECS_TEARDOWN) && (fl != ECS_REDRAW))
        return(FALSE);

    PDEVOBJ po(((EWNDOBJ*) pwo)->pto->pSurface->hdev());
    PDEVOBJ poParent(po.hdevParent());

    DEVLOCKOBJ dlo(po);

    pState = poParent.pSpriteState();

    if (pState->cMultiMon)
    {
        for (i = 0; i < pState->cMultiMon; i++)
        {
            vSpDeviceControlSprites(pState->ahdevMultiMon[i], (EWNDOBJ*) pwo, fl);
        }
    }
    else
    {
        vSpDeviceControlSprites(po.hdev(), (EWNDOBJ*) pwo, fl);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vSpComputeUnlockedRegion
*
* Compute the region that describes the area on which sprites are free
* to draw (which does not include DirectDraw locked areas, or WNDOBJ
* areas that have the WO_NOSPRITES flag set).
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
\**************************************************************************/

VOID vSpComputeUnlockedRegion(
SPRITESTATE*    pState)
{
    RECTL                   rcl;
    SURFACE*                pSurface;
    TRACKOBJ*               pto;
    EWNDOBJ*                pwo;

    PDEVOBJ po(pState->hdev);
    po.vAssertDevLock();

    // Get rid of the old region:

    if (pState->prgnUnlocked != NULL)
    {
        pState->prgnUnlocked->vDeleteREGION();
        pState->prgnUnlocked = NULL;
    }

    pSurface = SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen);

    // We have to to work if either a DirectDraw lock is active, or if a
    // WNDOBJ is active.

    if ((DxDdGetSurfaceLock(po.hdev()) || gpto != NULL))
    {
        // Calculate the new region:

        RGNMEMOBJ rmoUnlocked((BOOL) FALSE);
        if (rmoUnlocked.bValid())
        {
            rcl.left   = 0;
            rcl.top    = 0;
            rcl.right  = po.sizl().cx;
            rcl.bottom = po.sizl().cy;

            rmoUnlocked.vSet(&rcl);

            RGNMEMOBJTMP rmoRect((BOOL) FALSE);
            RGNMEMOBJTMP rmoTmp((BOOL) FALSE);

            if (rmoRect.bValid() && rmoTmp.bValid())
            {
                // Loop through the list of DirectDraw locked surfaces and
                // remove their locked rectangles from the inclusion region:
 
                RECTL rclDdLocked;

                PVOID pvDdSurface = DxDdEnumLockedSurfaceRect(po.hdev(),NULL,&rclDdLocked);

                while (pvDdSurface)
                {
                    // We don't check the return code on 'bCopy' because it
                    // guarantees that it will maintain valid region constructs
                    // -- even if the contents are incorrect.  And if we fail
                    // here because we're low on memory, it's guaranteed that
                    // there will already be plenty of incorrect drawing,
                    // so we don't care if our inclusion region is
                    // invalid:

                    rmoRect.vSet(&rclDdLocked);
                    rmoTmp.bCopy(rmoUnlocked);
                    if (!rmoUnlocked.bMerge(rmoTmp, rmoRect, gafjRgnOp[RGN_DIFF]))
                    {
                        rmoUnlocked.vSet();
                    }

                    // Move on to next surface.

                    pvDdSurface = DxDdEnumLockedSurfaceRect(po.hdev(),pvDdSurface,&rclDdLocked);
                }

                // We must be holding the WNDOBJ semaphore before mucking
                // with any WNDOBJs.

                SEMOBJ so(ghsemWndobj);

                // Now loop through the list of WNDOBJs, and subtract their
                // regions.

                for (pto = gpto; pto; pto = pto->ptoNext)
                {
                    for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
                    {
                        // The WNDOBJ coordinates must be device-relative, so
                        // use UNDO:

                        UNDODESKTOPCOORD udc(pwo, pState);

                        if (pwo->fl & WO_NOSPRITES)
                        {
                            rmoTmp.bCopy(rmoUnlocked);
                            if (!rmoUnlocked.bMerge(rmoTmp,
                                               *pwo,
                                               gafjRgnOp[RGN_DIFF]))
                            {
                                rmoUnlocked.vSet();
                            }
                        }
                    }
                }
            }

            rmoUnlocked.vStamp();
            pState->prgnUnlocked = rmoUnlocked.prgnGet();
        }
    }

    // Finally, mark the range cache as invalid so that 'prgnUncovered'
    // gets recomputed to incorporate 'prgnUnlocked':

    pState->bValidRange = FALSE;
}

/******************************Public*Routine******************************\
* VOID vSpUpdateWndobjOverlap
*
* Recalculate whether any sprites overlap a WNDOBJ area, and notify the
* driver if that state has changed.
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
\**************************************************************************/

VOID vSpUpdateWndobjOverlap(
SPRITESTATE*    pState,
EWNDOBJ*        pwo)
{
    BOOL    bSpriteOverlap;
    SPRITE* pSprite;

    PDEVOBJ po(pState->hdev);

    po.vAssertDevLock();

    ASSERTGDI(!(pwo->fl & WO_RGN_DESKTOP_COORD), "Use UNDODESKTOPCOORD");

    // Ah ha.  Recalculate total number of intersections for
    // this WNDOBJ.

    bSpriteOverlap = FALSE;

    for (pSprite = pState->pListZ;
         pSprite != NULL;
         pSprite = pSprite->pNextZ)
    {
        if (bIntersect(&pwo->rclBounds, &pSprite->rclSprite))
        {
            if (pwo->bInside(&pSprite->rclSprite) == REGION_RECT_INTERSECT)
            {
                RGNOBJ roClip(pSprite->prgnClip);

                if (!roClip.bValid() ||
                    (roClip.bInside(&pwo->rclBounds) == REGION_RECT_INTERSECT))
                {
                    bSpriteOverlap = TRUE;

                    break;
                }
            }
        }
    }

    // Inform the driver if the overlap state for this window
    // has changed.

    if ((bSpriteOverlap) && !(pwo->fl & WO_SPRITE_OVERLAP))
    {
        pwo->fl |= WO_SPRITE_OVERLAP;

        if (pwo->fl & WO_SPRITE_NOTIFY)
            pwo->pto->vUpdateDrv(pwo, WOC_SPRITE_OVERLAP);
    }
    else if ((!bSpriteOverlap) && (pwo->fl & WO_SPRITE_OVERLAP))
    {
        pwo->fl &= ~WO_SPRITE_OVERLAP;

        if (pwo->fl & WO_SPRITE_NOTIFY)
            pwo->pto->vUpdateDrv(pwo, WOC_SPRITE_NO_OVERLAP);
    }
}

/******************************Public*Routine******************************\
* VOID vSpCheckForWndobjOverlap
*
* Go through all the WNDOBJs and see if either the old or the new sprite
* position may have changed the sprite overlap state.
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
\**************************************************************************/

VOID vSpCheckForWndobjOverlap(
SPRITESTATE*    pState,
RECTL*          prclNew,
RECTL*          prclOld)
{
    SURFACE*    pSurface;
    TRACKOBJ*   pto;
    EWNDOBJ*    pwo;

    PDEVOBJ po(pState->hdev);

    po.vAssertDevLock();

    pSurface = SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen);

    // Hold the WNDOBJ semaphore before mucking with any WNDOBJs.

    SEMOBJ so(ghsemWndobj);

    for (pto = gpto; pto; pto = pto->ptoNext)
    {
        for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
        {
            // The WNDOBJ coordinates must be device-relative, so use UNDO:

            UNDODESKTOPCOORD udc(pwo, pState);

            // Note that this cannot be an 'XOR' test, because we're
            // only testing the bounds at this point.

            if (bIntersect(&pwo->rclBounds, prclNew) ||
                bIntersect(&pwo->rclBounds, prclOld))
            {
                vSpUpdateWndobjOverlap(pState, pwo);
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID vSpDeviceWndobjChange
*
* Routine to inform the sprite code when a WNDOBJ has changed.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDeviceWndobjChange(
HDEV        hdev,
EWNDOBJ*    pwo)
{
    SPRITESTATE*    pState;

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    // The WNDOBJ coordinates must be device-relative, so use UNDO:

    UNDODESKTOPCOORD udc(pwo, pState);

    po.vAssertDevLock();

    if (pwo != NULL)
    {
        vSpUpdateWndobjOverlap(pState, pwo);
    }

    // Technically, we only have to recompute the regions when a WO_NOSPRITE
    // WNDOBJ has been created, destroyed, or moved.  But it won't hurt
    // anything if we do it for any WNDOBJ.

    vSpComputeUnlockedRegion(pState);
}

/******************************Public*Routine******************************\
* VOID vSpWndobjChange
*
* Routine to inform the sprite code when a WNDOBJ has changed.  This
* routine is multi-mon aware.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpWndobjChange(
HDEV        hdev,
EWNDOBJ*    pwo)
{
    SPRITESTATE*    pState;
    ULONG           i;

    PDEVOBJ po(hdev);

    DEVLOCKOBJ dlo(po);

    pState = po.pSpriteState();

    if (pState->cMultiMon)
    {
        for (i = 0; i < pState->cMultiMon; i++)
        {
            vSpDeviceWndobjChange(pState->ahdevMultiMon[i], pwo);
        }
    }
    else
    {
        vSpDeviceWndobjChange(hdev, pwo);
    }
}

/******************************Public*Routine******************************\
* BOOL bSpTearDownSprites
*
* This routine tears-down any sprites in the specified rectangle.
*
* Returns: TRUE if any sprites were torn down (and so need to be re-drawn
*          later), FALSE if no sprites were torn down.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpTearDownSprites(
HDEV    hdev,
RECTL*  prclExclude,
BOOL    bDirectDrawLock)        // TRUE if we're being called by the DirectDraw
                                //   Lock function.  FALSE if we're being called
                                //   from a routine which wants to just
                                //   momentarily tear down the sprite
{
    SPRITESTATE*    pState;
    RECTL           rclEnum;
    BOOL            bTearDown;
    BOOL            bMore;
    SPRITE*         pSprite;
    RECTL           rclExclude;

    PDEVOBJ po(hdev);

    // No sprites to tear down on printers

    if (!po.bDisplayPDEV())
    {
        return FALSE;
    }

    po.vAssertDevLock();
    pState = po.pSpriteState();

    SPRITELOCK slock(po);

    bTearDown = FALSE;

    // We only need to do any actual work if any sprites are up on
    // the screen:

    if (pState->cVisible != 0)
    {
        if (bIntersect(prclExclude, &pState->rclScreen, &rclExclude))
        {
            // Tear down all sprites:

            ENUMAREAS Enum(pState, &rclExclude);

            do {
                bMore = Enum.bEnum(&pSprite, &rclEnum);

                if (pSprite != NULL)
                {
                    bTearDown = TRUE;

                    vSpWriteToScreen(pState,
                                     &pSprite->OffUnderlay,
                                     pSprite->psoUnderlay,
                                     &rclEnum);
                }
            } while (bMore);

            if (bDirectDrawLock)
            {
                // Now compute the new unlocked region:

                vSpComputeUnlockedRegion(pState);
            }
        }
    }

    return(bTearDown);
}

/******************************Public*Routine******************************\
* VOID vSpUnTearDownSprites
*
* This routine redraws any sprites in the specified rectangle.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpUnTearDownSprites(
HDEV    hdev,
RECTL*  prclExclude,
BOOL    bDirectDrawUnlock)
{
    SPRITESTATE*    pState;
    RECTL           rclEnum;
    BOOL            bMore;
    SPRITE*         pSprite;
    RECTL           rclExclude;

    PDEVOBJ po(hdev);

    ASSERTGDI(po.bDisplayPDEV(), "vSpUnTearDownSprites:  not a display pdev");

    po.vAssertDevLock();
    pState = po.pSpriteState();

    // We only need to do any actual work if any sprites are up on
    // the screen:

    if (pState->cVisible != 0)
    {
        if (bIntersect(prclExclude, &pState->rclScreen, &rclExclude))
        {
            SPRITELOCK slock(po);

            if (bDirectDrawUnlock)
            {
                // Now compute the new unlocked region:

                vSpComputeUnlockedRegion(pState);
            }

            // Reload the underlays:

            ENUMAREAS Enum(pState, &rclExclude);

            do {
                // We know that we already excluded any sprites from the
                // 'prclExclude' area, so it's safe to update the underlays
                // directly from the screen since we know we won't pick up
                // any sprite images.

                bMore = Enum.bEnum(&pSprite, &rclEnum);

                if (pSprite != NULL)
                {
                    do {
                        vSpReadFromScreen(pState,
                                          &pSprite->OffUnderlay,
                                          pSprite->psoUnderlay,
                                          &rclEnum);

                    } while (Enum.bEnumLayers(&pSprite));
                }
            } while (bMore);

            // Redraw the affected area:

            vSpRedrawArea(pState, &rclExclude, TRUE);
        }
    }
}

/******************************Public*Routine******************************\
* BOOL bSpSpritesVisible
*
* Returns TRUE if any emulated sprites are currently visible.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpSpritesVisible(
HDEV    hdev)
{
    SPRITESTATE* pState;

    PDEVOBJ po(hdev);
    po.vAssertDevLock();
    pState = po.pSpriteState();

    return(pState->cVisible != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\sources.inc ===
MAJORCOMP=windows

TARGETTYPE=LIBRARY

MINORCOMP=gre
TARGETNAME=gre
TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

INCLUDES=..;                             \
         ..\..\inc;                      \
         $(WINCORE_PATH)\dxkernel\inc;   \
         $(WINCORE_PATH)\w32inc;         \
         $(BASE_INC_PATH);               \
         $(DDK_INC_PATH);                \
         $(DRIVERS_INC_PATH);            \
         $(MULTIMEDIA_INC_PATH);         \

## Hydra
INCLUDES=$(INCLUDES);                    \
         $(TERMSRV_INC_PATH)

C_DEFINES=$(C_DEFINES) -DNTOS_KERNEL_RUNTIME=1 -D_NTDRIVER_ -D_HYDRA_
C_DEFINES=$(C_DEFINES) -DNO_INTERLOCKED_INTRINSICS=1 -DFE_SB -DLANGPACK -D_NTSYSTEM_DRIVER_ -DUSE_MIRRORING -DDS_ENABLE_OLD_STUFF=0

## Hydra
C_DEFINES=$(C_DEFINES) -D_HYDRA_

## OpenGL with multi monitor
C_DEFINES=$(C_DEFINES) -DOPENGL_MM

## Watchdog
C_DEFINES=$(C_DEFINES) -DDDI_WATCHDOG

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

ASM_DEFINES=$(ASM_DEFINES) -DFE_SB

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

SOURCES=$(SOURCES)         \
        ..\globals.c       \
        ..\guids.c         \
        ..\mapfile.c       \
        ..\ntgdi.c         \
        ..\textxl.c        \
        ..\w32kevnt.c      \
        ..\aatext.cxx      \
        ..\alphablt.cxx    \
        ..\alphaimg.cxx    \
        ..\alphatran.cxx   \
        ..\atmstub.c       \
        ..\bbddi.cxx       \
        ..\bltlnk.cxx      \
        ..\bltlnkfn.cxx    \
        ..\brushapi.cxx    \
        ..\brushddi.cxx    \
        ..\brushobj.cxx    \
        ..\cache.cxx       \
        ..\cleanup.cxx     \
        ..\clipline.cxx    \
        ..\clipobj.cxx     \
        ..\cpanel.cxx      \
        ..\curseng.cxx     \
        ..\dcgdi.cxx       \
        ..\dcobj.cxx       \
        ..\dcrgn.cxx       \
        ..\dda.cxx         \
        ..\debugko.cxx     \
        ..\dibapi.cxx      \
        ..\dither.cxx      \
        ..\drawattr.cxx    \
        ..\draweng.cxx     \
        ..\drawgdi.cxx     \
        ..\drawstream.cxx  \
        ..\drvobj.cxx      \
        ..\drvsup.cxx      \
        ..\engbrush.cxx    \
        ..\engline.cxx     \
        ..\engstrps.cxx    \
        ..\engstrok.cxx    \
        ..\enumgdi.cxx     \
        ..\fastfill.cxx    \
        ..\fillddi.cxx     \
        ..\flinkgdi.cxx    \
        ..\floodgdi.cxx    \
        ..\fntassoc.cxx    \
        ..\fntcache.cxx    \
        ..\fntxform.cxx    \
        ..\fontddi.cxx     \
        ..\fontgdi.cxx     \
        ..\fontgdip.cxx    \
        ..\fontmap.cxx     \
        ..\fontsub.cxx     \
        ..\fontsup.cxx     \
        ..\gradfill.cxx    \
        ..\hmgrapi.cxx     \
        ..\htblt.cxx       \
        ..\icmapi.cxx      \
        ..\icmobj.cxx      \
        ..\init.cxx        \
        ..\invcmap.cxx     \
        ..\lfntobj.cxx     \
        ..\mapfile2.cxx    \
        ..\maskblt.cxx     \
        ..\meta.cxx        \
        ..\misceudc.cxx    \
        ..\miscgdi.cxx     \
        ..\multi.cxx       \
        ..\opendc.cxx      \
        ..\os.cxx          \
        ..\paintddi.cxx    \
        ..\palddi.cxx      \
        ..\paleng.cxx      \
        ..\palgdi.cxx      \
        ..\palobj.cxx      \
        ..\panning.cxx     \
        ..\patblt.cxx      \
        ..\pathclip.cxx    \
        ..\pathflat.cxx    \
        ..\pathgdi.cxx     \
        ..\pathobj.cxx     \
        ..\pathwide.cxx    \
        ..\pattern.cxx     \
        ..\pdevobj.cxx     \
        ..\pfeobj.cxx      \
        ..\pffobj.cxx      \
        ..\pftobj.cxx      \
        ..\pixelapi.cxx    \
        ..\pixelfmt.cxx    \
        ..\plgblt.cxx      \
        ..\print.cxx       \
        ..\rfntobj.cxx     \
        ..\rfntxlat.cxx    \
        ..\rgn2path.cxx    \
        ..\rgngdi.cxx      \
        ..\rgnobj.cxx      \
        ..\rle4blt.cxx     \
        ..\rle8blt.cxx     \
        ..\rotate.cxx      \
        ..\solid.cxx       \
        ..\solline.cxx     \
        ..\sort.cxx        \
        ..\spool.cxx       \
        ..\sprite.cxx      \
        ..\srcalign.cxx    \
        ..\srcblt1.cxx     \
        ..\srcblt4.cxx     \
        ..\srcblt8.cxx     \
        ..\srcblt16.cxx    \
        ..\srcblt24.cxx    \
        ..\srcblt32.cxx    \
        ..\stockfnt.cxx    \
        ..\strchblt.cxx    \
        ..\strdir.cxx      \
        ..\stretch.cxx     \
        ..\surfddi.cxx     \
        ..\surfeng.cxx     \
        ..\surfgdi.cxx     \
        ..\surfobj.cxx     \
        ..\textddi.cxx     \
        ..\textgdi.cxx     \
        ..\textobj.cxx     \
        ..\timer.cxx       \
        ..\tranblt.cxx     \
        ..\trig.cxx        \
        ..\trimesh.cxx     \
        ..\trivblt.cxx     \
        ..\ttgdi.cxx       \
        ..\umpd.cxx        \
        ..\umpdobj.cxx     \
        ..\umpddrv.cxx     \
        ..\umpdeng.cxx     \
        ..\usersrv.cxx     \
        ..\verifier.cxx    \
        ..\watchdog.cxx    \
        ..\wndobj.cxx      \
        ..\xformddi.cxx    \
        ..\xformgdi.cxx    \
        ..\xformobj.cxx    \
        ..\ylateddi.cxx    \
        ..\ylateobj.cxx

## Hydra
SOURCES=$(SOURCES)         \
        ..\misc.cxx        \
        ..\helpers.cxx     \
        ..\muclean.cxx     \
        ..\muio.c

## DirectDraw and Direct3D
SOURCES=$(SOURCES)         \
       ..\ddsup.cxx

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\sort.cxx ===
/******************************Module*Header*******************************\
* Module Name: sort.c
*
*
* Created: 20-Mar-1995 09:52:19
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993-1999 Microsoft Corporation
*
*
\**************************************************************************/

#include "precomp.hxx"

typedef struct _SORTSTACK
{
    ULONG iStart;
    ULONG c;
} SORTSTACK;

#define MAXSORT 20

typedef struct _SORTDATA
{
    PBYTE     pjBuf;
    ULONG     iStack;
    ULONG     cjElem;
    SORTCOMP  pfnComp;
    SORTSTACK sStack[MAXSORT];

} SORTDATA;

/******************************Public*Routine******************************\
* vSortSwap()
*
*   Swap the data pointed to by pj1 and pj2, each containing cj bytes.
*
*   Note: this assumes cj is a multiple of 4.
*
*   NOTE: vSortSwap should be inline.
*
* History:
*  18-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSortSwap(
    PBYTE pj1,
    PBYTE pj2,
    ULONG cj)
{
    PLONG pl1 = (PLONG)pj1;
    PLONG pl2 = (PLONG)pj2;

    do
    {
        LONG l;

        l    = *pl1;
        *pl1++ = *pl2;
        *pl2++ = l;

    } while (cj -= 4);
}

/******************************Public*Routine******************************\
* vSortPush()
*
*   Add a range to the stack to be sorted.
*
*   If there are 0 or 1 elements, just return, sorting done.
*   If there are 2, 3, 4, or 5 elements, just do a bubble sort. sorting done.
*   If the stack is full, just do a bubble sort. sorting done.
*   Otherwise, add a new range to the stack.
*
* History:
*  18-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSortPush(
    SORTDATA *psd,
    ULONG    iStart,
    ULONG    c)
{
    PBYTE  pj   = psd->pjBuf + iStart;

#if DBGSORT
    DbgPrintf("vSortPush - iStack = %ld, iStart = %ld, c = %ld\n",psd->iStack,iStart,c);
#endif

    if (c > psd->cjElem)
    {
        ULONG i,j;
        ULONG cjElem = psd->cjElem;

        //for (i = 0; i < (c - cjElem); i += cjElem)
        {
        //    if ((*psd->pfnComp)(&pj[i],&pj[i+cjElem]) > 0)
            {
                if ((c <= (4 * psd->cjElem)) || (psd->iStack == MAXSORT))
                {
                    // we have 4 or fewer elements.  Just do a buble sort.  With 4 elements
                    // this will be a 6 compares and upto 6 swaps.
                    // We make c-1 passes over then entire array.  Each pass guarantees that
                    // the next smallest element is shifted to location i.  After the first pass
                    // the smallest element is in location 0.  After the second pass the second
                    // smallest element is in location 1. etc.


                #if DBGSORT
                    if (c > (4 * cjElem))
                        DbgPrintf("******* Stack too deep: c = %ld\n",c / cjElem);
                #endif

                    for (i = 0; i < (c - cjElem); i += cjElem)
                        for (j = c - cjElem; j > i; j -= cjElem)
                            if ((*psd->pfnComp)(&pj[j-cjElem],&pj[j]) > 0)
                                vSortSwap(&pj[j-cjElem],&pj[j],cjElem);
                }
                else
                {
                    psd->sStack[psd->iStack].iStart = iStart;
                    psd->sStack[psd->iStack].c      = c;
                    psd->iStack++;
                }
        //        break;
            }
        }
    }
}

/******************************Public*Routine******************************\
* EngSort()
*
*   This is an implementation of the c-runtime qsort.
*
* History:
*  18-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

extern "C" VOID EngSort(
    PBYTE pjBuf,
    ULONG c,
    ULONG cjElem,
    SORTCOMP pfnComp)
{
    SORTDATA sd;

#if DBGSORT
    ULONG cOrg = c;
    ULONG i;

    DbgPrintf("\n\nvDrvSort - c = %d\n",c);

#endif

    ASSERTGDI((cjElem & 0x3) == 0,"EngSort not dword aligned");

    if (cjElem & 3)
        return;

    sd.pjBuf   = pjBuf;
    sd.iStack  = 0;
    sd.pfnComp = pfnComp;
    sd.cjElem  = cjElem;

    vSortPush(&sd,0,c * cjElem);

    while (sd.iStack)
    {
        PBYTE pj;
        ULONG iStart;
        ULONG iLow;
        ULONG iHi;

        --sd.iStack;
        iStart = sd.sStack[sd.iStack].iStart;
        pj     = &pjBuf[iStart];
        c      = sd.sStack[sd.iStack].c;

    #if DBGSORT

        for (i = 0; i < cOrg;++i)
            vPrintElem(&pjBuf[i * cjElem]);
        DbgPrintf("\n");

        DbgPrintf("iStart = %ld, c = %ld, iStack = %lx - ",iStart/cjElem,c/cjElem,sd.iStack);

        for (i = 0; i < c;i += cjElem)
            vPrintElem(&pj[i]);
        DbgPrintf("\n");

    #endif

        // pick a random value to use for dividing.  Don't use the first since this
        // will reduce the chances of worst case if the list is sorted in reverse order.

        vSortSwap(&pj[0],&pj[(c / cjElem) / 2 * cjElem],cjElem);

        // initialize the starting and ending indexes.  Note that all operations
        // use cjElem as the increment instead of 1.

        iLow = 0;
        iHi  = c - cjElem;

        // divide the array into two pieces, all elements <= before current one

        for (;;)
        {
            // while (pj[iHi] > pj[0]))

            while ((iHi > iLow) && ((*pfnComp)(&pj[iHi],&pj[0]) >= 0))
                iHi -= cjElem;

            // while (pj[iLow] <= pj[0]))

            while ((iLow < iHi) && ((*pfnComp)(&pj[iLow],&pj[0]) <= 0))
                iLow += cjElem;

            if (iHi == iLow)
                break;

            vSortSwap(&pj[iLow],&pj[iHi],cjElem);

            iHi -= cjElem;
            //if (iLow < iHi)
            //    iLow += cjElem;

        #if DBGSORT
            DbgPrintf("\tiLow = %ld, iHi = %ld\n",iLow/cjElem,iHi/cjElem);
        #endif
        }

        // now add the two pieces to stack
        // 0 -> (iLow - 1), (iLow + 1) -> (c - 1)

        if (iLow != 0)
        {
            vSortSwap(&pj[0],&pj[iLow],cjElem);
            if (iLow > 1)
                vSortPush(&sd,iStart,iLow);
        }

        c = c - iLow - cjElem;
        if (c > 1)
            vSortPush(&sd,iStart + iLow + cjElem,c);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\srcblt1.cxx ===
/******************************Module*Header*******************************\
* Module Name: srcblt1.cxx
*
* This contains the bitmap simulation functions that blt to a 1 bit/pel
* DIB surface.
*
* Created: 07-Feb-1991 19:27:49
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/*******************Public*Routine*****************\
* vSrcCopyS1D1LtoR
*
* There are three main loops in this function.
*
* The first loop deals with the full bytes part of
* the Dst while fetching/shifting the matching 8 bits
* from the Src.
*
* The second loop deals with the left most strip
* of the partial bytes.
*
* The third loop deals with the right most strip
* of the partial bytes.
*
* Special case:
* when the Src and Dst are aligned, we enter
* a different loop to use rltcopymem to avoid
* shifting
*
* History:
* 17-Oct-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.
*
\**************************************************/


VOID vSrcCopyS1D1LtoR(PBLTINFO psb)
{
    BYTE  jSrc;     // holds a source byte
    BYTE  jDst;     // holds a dest byte
    INT   iSrc;     // bit position in the first Src byte
    INT   iDst;     // bit position in the first Dst byte
    INT   ixlate;   // set flag to indicate if it is
                    // source invert, source copy or
                    // all 0's or all 1's
    PBYTE pjDst;    // pointer to the Src bytes
    PBYTE pjSrc;    // pointer to the Dst bytes
    PBYTE pjLDst;   // pointer to the last Dst byte
    LONG  xSrcEnd = psb->xSrcEnd;
    LONG  cy;       // number of pixels
    LONG  cx;       // number of rows
    BYTE  jAlignL;  // alignment bits to the left
    BYTE  jAlignR;  // alignment bits to the right
    BYTE  jMask;    // Masks used for shifting
    BYTE  jEndMask;
    LONG  cFullBytes;  //number of full bytes to deal with
    BOOL  bNextByte;
    LONG  xDstEnd;
    LONG  lDeltaDst;
    LONG  lDeltaSrc;
    BOOL  bNextSrc = TRUE;

    // We assume we are doing left to right top to bottom blting
    ASSERTGDI(psb->xDir == 1, "vSrcCopyS1D1LtoR - direction not left to right");
    ASSERTGDI(psb->cy != 0, "ERROR: Src Move cy == 0");

    //DbgPrint ("vsrccopys1d1ltor\n");

    // if ixlate is 0x00, all 0's
    // if ixlate is 0x01, src copy
    // if ixlate is 0x10, src invert
    // if ixlate is 0x11, all 1's

    ixlate = (psb->pxlo->pulXlate[0]<<1) | psb->pxlo->pulXlate[1];

    //Get Src and Dst start positions
    iSrc = psb->xSrcStart & 0x0007;
    iDst = psb->xDstStart & 0x0007;

    // Checking alignment

    // If Src starting point is ahead of Dst
    if (iSrc < iDst)
        jAlignL = 8 - (iDst - iSrc);
    // If Dst starting point is ahead of Src
    else
        jAlignL = iSrc - iDst;

    //jAlignR = (8 - jAlignL) & 0x07;
    jAlignR = 8 - jAlignL;

    cx=psb->cx;

    xDstEnd = psb->xDstStart + cx;

    lDeltaDst = psb->lDeltaDst;
    lDeltaSrc = psb->lDeltaSrc;

    //check if there is a next byte
    bNextByte = !((xDstEnd>>3) ==
                 (psb->xDstStart>>3));

    // The following loop is the inner loop part
    // where we deals with a byte at a time
    // when this main part is done, we deal
    // with the begin and end partial bytes
    //
    // if Src and Dst are aligned, use a separete loop
    // to obtain better performance;
    // If not, we shift the Src bytes to match with
    // the Dst byte one at a time

    if (bNextByte)
    {
        long iStrideSrc;
        long iStrideDst;
        PBYTE pjSrcEnd;

        //Get first Dst full byte
        pjDst = psb->pjDst + ((psb->xDstStart+7)>>3);

        //Get the Src byte that matches the first Dst
        // full byte
        pjSrc = psb->pjSrc + ((psb->xSrcStart+((8-iDst)&0x07)) >> 3);

        //Get last full byte
        pjLDst = psb->pjDst + (xDstEnd>>3);

        //Get the number of full bytes

        // Sundown: xSrcStart and xSrcEnd are both LONG, safe to truncate

        cFullBytes = (ULONG)(pjLDst - pjDst);

        //the increment to the full byte on the next scan line

        iStrideDst = lDeltaDst - cFullBytes;
        iStrideSrc = lDeltaSrc - cFullBytes;

        // deal with our special case
        cy = psb->cy;

        if (!jAlignL || (ixlate == 0) || (ixlate == 3))
        {
            BYTE jConstant;

            switch (ixlate)
            {
            case 0:
            case 3:
                jConstant = (!ixlate)?0:0xFF;

                while (cy--)
                {
                    int i;

                    i = cFullBytes;

                    while (i--)
                        *pjDst++ = jConstant;

                    //move to the beginning full byte
                    // on the next scan line

                    pjDst += iStrideDst;
                    pjSrc += iStrideSrc;
                };
                break;
            case 1:
                while (cy--)
                {
                    RtlCopyMemory(pjDst,pjSrc,cFullBytes);

                    // move to the beginning full byte
                    // on the next scan line

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                };
                break;

            case 2:
                while (cy--)
                {
                    int i;

                    i = cFullBytes;

                    while (i--)
                        *pjDst++ = ~*pjSrc++;

                    //move to the beginning full byte
                    // on the next scan line

                    pjDst += iStrideDst;
                    pjSrc += iStrideSrc;
                };
                break;


            default:;
            } //switch
        }   //end of if (!jAlignL)

        else
        // if neither aligned nor all 0's or all 1's
        {
            BYTE jRem; //remainder

            switch (ixlate)
            {
            case 1:
                while (cy--)
                {
                    jRem = *pjSrc << jAlignL;

                    pjSrcEnd = pjSrc+cFullBytes;

                    while (pjSrc != pjSrcEnd)
                    {
                        jSrc = *(++pjSrc);
                        jDst = (jSrc>>jAlignR) | jRem;
                        *pjDst++ = jDst;

                        //next remainder
                        jRem = jSrc << jAlignL;
                    }

                    // go to the beginging full byte of
                    // next scan line
                    pjDst += iStrideDst;
                    pjSrc += iStrideSrc;

                };
                break;

            case 2:
                while (cy--)
                {
                    jRem = *pjSrc << jAlignL;

                    pjSrcEnd = pjSrc+cFullBytes;

                    while (pjSrc != pjSrcEnd)
                    {
                        jSrc = *(++pjSrc);
                        jDst = (jSrc>>jAlignR) | jRem;
                        *pjDst++ = ~jDst;

                        //next remainder
                        jRem = jSrc << jAlignL;
                    }

                    // go to the beginging full byte of
                    // next scan line
                    pjDst += iStrideDst;
                    pjSrc += iStrideSrc;

                }; //while
                break;

            default: ;
            } //switch
        } //else
    } //if
    // End of our dealing with the full bytes

    //build our masks
    jMask = 0xFF >> iDst;

    // if there are only one partial left byte,
    // the mask is special
    // for example, when we have 00111000 for
    // Dst
    if (!bNextByte)
    {
        jEndMask = 0XFF << (8-(xDstEnd & 0x0007));

        jMask = jMask & jEndMask;

        bNextSrc = ((iSrc + cx) > 8);

    }

    // Begin dealing with the left strip of the first
    // partial byte
    // First check if there are any partial
    // left byte.  Otherwise don't bother
    if (iDst | !bNextByte)
    {
        pjDst = psb->pjDst + (psb->xDstStart>>3);
        pjSrc = psb->pjSrc + (psb->xSrcStart>>3);

        cy = psb->cy;

        switch (ixlate)
        {
        case 0:
            while (cy--)
            {
                *pjDst = *pjDst & ~jMask;

                pjDst += lDeltaDst;
            }
            break;

        case 1:
            if (iSrc > iDst)
            {
                if (bNextSrc)
                    while (cy--)
                    {
                        jSrc = *pjSrc << jAlignL;
                        jSrc |= *(pjSrc+1) >> jAlignR;

                        jSrc &= jMask;

                        *pjDst = (*pjDst & (~jMask)) | jSrc;

                        pjDst += lDeltaDst;
                        pjSrc += lDeltaSrc;

                    }
               else //if !bNextSrc
                   while (cy--)
                    {
                        jSrc = *pjSrc << jAlignL;

                        jSrc &= jMask;

                        *pjDst = (*pjDst & (~jMask)) | jSrc;

                        pjDst += lDeltaDst;
                        pjSrc += lDeltaSrc;

                    }

            }
            else if (iSrc < iDst)
            {
                while (cy--)
                {
                    jSrc = *pjSrc >> jAlignR;

                    jSrc &= jMask;

                    *pjDst = (*pjDst & (~jMask)) | jSrc;

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }

            }
            else   // iSrc = iDst
            {
                while (cy--)
                {
                    jSrc = *pjSrc;

                    jSrc &= jMask;

                    *pjDst = (*pjDst & (~jMask)) | jSrc;

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }

            }

            break;

        case 2:
            if (iSrc > iDst)
            {
                while (cy--)
                {
                    jSrc = *pjSrc << jAlignL;
                    jSrc |= *(pjSrc+1) >> jAlignR;

                    jSrc = ~jSrc & jMask;

                    *pjDst = (*pjDst & (~jMask)) | jSrc;

                    //go to next scan line
                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;

                }
            }
            else if (iSrc < iDst)
            {
                while (cy--)
                {
                    jSrc = *pjSrc >> jAlignR;

                    jSrc = ~jSrc & jMask;

                    *pjDst = (*pjDst & (~jMask)) | jSrc;

                    //go to next scan line
                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }
            else   // iSrc = iDst
            {
                while (cy--)
                {
                    jSrc = *pjSrc;

                    jSrc = ~jSrc & jMask;

                    *pjDst = (*pjDst & (~jMask)) | jSrc;

                    //go to next scan line
                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }
            break;

        case 3:
            while (cy--)
            {
                *pjDst = *pjDst | jMask;

                pjDst += lDeltaDst;
            }
            break;

        default: ;
        } //switch
   } //if

   // Begin dealing with the right edge
   // of partial bytes

   jMask = 0xFF >> ((BYTE)(psb->xDstStart+cx) & 0x0007);

   // first check if there is any partial
   // byte left
   // and has next byte

   if ((xDstEnd & 0x0007)
       && bNextByte)
   {
        // Get the last partial bytes on the
        // scan line

        pjDst = pjLDst;

        // Get the Src byte that matches the
        // right partial Dst byte
        // since xSrcEnd always point one
        // pixel after the last pixel, minus 1
        // from it
        pjSrc = psb->pjSrc + ((psb->xSrcEnd-1) >>3);

        // Get the ending position in the last
        // Src and Dst bytes
        iSrc = (psb->xSrcEnd-1) & 0x0007;
        iDst = (xDstEnd-1) & 0x0007;

        cy = psb->cy;

        switch (ixlate)
        {
        case 0:
            while (cy--)
            {
                *pjDst &= jMask;

                pjDst += lDeltaDst;
            }
            break;

        case 1:
            if (iSrc > iDst)
            {
                while (cy--)
                {
                    jSrc = *pjSrc << jAlignL;

                    jSrc &= ~jMask;

                    *pjDst = (*pjDst & jMask) | jSrc;

                     //go to next scan line

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;

                }
            }
            else if (iSrc < iDst)
            {
                while (cy--)
                {
                    jSrc = *(pjSrc-1) << jAlignL;

                    jSrc |= *pjSrc >> jAlignR;

                    jSrc &= ~jMask;

                    *pjDst = (*pjDst & jMask) | jSrc;

                     //go to next scan line

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }
            else   // iSrc = iDst
            {
                while (cy--)
                {
                    jSrc = *pjSrc;

                    jSrc &= ~jMask;

                    *pjDst = (*pjDst & jMask) | jSrc;

                     //go to next scan line

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;

                 }
             }
             break;

        case 2:
            if (iSrc > iDst)
            {
                while (cy--)
                {
                    jSrc = *pjSrc << jAlignL;

                    jSrc = ~jSrc & ~jMask;

                    *pjDst = (*pjDst & jMask) | jSrc;

                    //go to next scan line

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;

                }
            }
            else if (iSrc < iDst)
            {
                while (cy--)
                {
                    jSrc = *(pjSrc-1) << jAlignL;
                    jSrc |= *pjSrc >> jAlignR;

                    jSrc = ~jSrc & ~jMask;

                    *pjDst = (*pjDst & jMask) | jSrc;

                    //go to next scan line

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;

                }
            }
            else   // iSrc = iDst
            {
                while (cy--)
                {
                    jSrc = *pjSrc;

                    jSrc = ~jSrc & ~jMask;

                    *pjDst = (*pjDst & jMask) | jSrc;

                    //go to next scan line

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }
            break;

       case 3:
            while (cy--)
            {
                *pjDst = *pjDst | ~jMask;

                pjDst += lDeltaDst;
            }
            break;

       default: ;
       } //switch
   } //if
}

/*******************Public*Routine*****************\
* vSrcCopyS1D1RtoL
*
* this function is only called when copy to the
* same surface and has overlapping.
*
* There are three main loops in this function.
*
* The first loop deals with the starting pixels on the
* right most partial bytes.  This must
* come first because it is Right to Left and overlapping.
*
* The second loop deals with the full bytes part of
* the Dst while fetching/shifting the matching 8 bits
* from the Src.
*
* The third loop deals with the ending pixles on the
* left most partial bytes.
*
* Special case:
* when the Src and Dst are aligned, we enter
* a different loop to use RltMoveMem to avoid
* shifting.  RltMoveMemory gurantee the overlapping
* parts to be correct.
*
* History:
* 26-Oct-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.

\**************************************************/



VOID vSrcCopyS1D1RtoL(PBLTINFO psb)
{
    BYTE  jSrc;     // holds a source byte
    BYTE  jDst;     // holds a dest byte
    INT   iSrc;     // bit position in the first Src byte
    INT   iDst;     // bit position in the first Dst byte
    PBYTE pjDst;    // pointer to the Src bytes
    PBYTE pjSrc;    // pointer to the Dst bytes
    PBYTE pjLDst;   // pointer to the last Dst byte
    LONG  xSrcEnd = psb->xSrcEnd;
    LONG  cy;       // number of pixels
    LONG  cx;       // number of rows
    BYTE  jAlignL;  // alignment bits to the left
    BYTE  jAlignR;  // alignment bits to the right
    BYTE  jMask;    // Masks used for shifting
    BYTE  jEndMask;
    LONG  cFullBytes;  //number of full bytes to deal with
    BOOL  bNextByte;
    LONG  xDstEnd;
    LONG  lDeltaDst;
    LONG  lDeltaSrc;
    BOOL  bNextSrc = TRUE;

    // We assume we are doing right to left top to bottom blting
    ASSERTGDI(psb->xDir == -1, "vSrcCopyS1D1RtoL - direction not right to left");
    ASSERTGDI(psb->cy != 0, "ERROR: Src Move cy == 0");
    ASSERTGDI (psb->pxlo->pulXlate[0] == 0, "vSrcCopyS1D1RtoL - should be straight copy");
    ASSERTGDI (psb->pxlo->pulXlate[1] == 1, "vSrcCopyS1D1RtoL - should be straight copy");

    //DbgPrint ("vsrccopys1d1rtol\n");

    //Get Src and Dst start positions
    iSrc = psb->xSrcStart & 0x0007;
    iDst = psb->xDstStart & 0x0007;

    // Checking alignment

    // If Src starting point is ahead of Dst
    if (iSrc < iDst)
        jAlignL = 8-(iDst - iSrc);
    // If Dst starting point is ahead of Src
    else
        jAlignL = iSrc - iDst;

    jAlignR = 8 - jAlignL;

    cx=psb->cx;

    xDstEnd = psb->xDstStart - cx;

    lDeltaDst = psb->lDeltaDst;
    lDeltaSrc = psb->lDeltaSrc;

    //check if there is a next byte
    bNextByte = !((xDstEnd>>3) ==
                 (psb->xDstStart>>3));

    // prepare our mask for the beggining
    // partial bytes (this is on the right
    // hand side)
    jMask = 0xFF << (7-(psb->xDstStart&0x07));

    // if there are only one partial byte, the
    // mask is special, for example, when
    // we have 00111000 for dst.
    if (!bNextByte)
    {
        jEndMask = 0XFF >> ((1+xDstEnd) & 0x0007);

        jMask = jMask & jEndMask;

        // test if src needs to go to 1 byte left
        // for example, iSrc == 0, cx==1, does
        // not need to fetch the byte to the left
        if (iSrc < iDst)
            bNextSrc = ((iSrc-cx) < -1);

    }
    // Dealing with the starting pixels
    // first,  since we are doing right
    // to left.

    if (((iDst+1)&0x07) | !bNextByte)
    {

        pjDst = psb->pjDst + (psb->xDstStart>>3);
        pjSrc = psb->pjSrc + (psb->xSrcStart>>3);

        cy = psb->cy;

        if (iSrc > iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << jAlignL;

                jSrc = jSrc & jMask;

                *pjDst = (*pjDst & (~jMask)) | jSrc;

                //go to next scan line
                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;

            }
        }
        else if (iSrc < iDst)
        {
            if (bNextSrc)
                while (cy--)
                {
                    jSrc = *pjSrc >> jAlignR;
                    jSrc |= *(pjSrc-1) << jAlignL;

                    jSrc = jSrc & jMask;

                    *pjDst = (*pjDst & (~jMask)) | jSrc;

                    //go to next scan line
                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            else
            // if there is no next src byte,
            // accessing pjSrc-1 will cause
            // access violation.
            // this only happens on the starting
            // partial byte when bNextByte is False
                while (cy--)
                {
                    jSrc = *pjSrc >> jAlignR;

                    jSrc = jSrc & jMask;

                    *pjDst = (*pjDst & (~jMask)) | jSrc;

                    //go to next scan line
                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }

        }
        else   // iSrc = iDst
        {
            while (cy--)
            {
                jSrc = *pjSrc;

                jSrc = jSrc & jMask;

                *pjDst = (*pjDst & (~jMask)) | jSrc;

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
   }


    // The following loop is the inner loop part
    // where we deals with a byte at a time
    // when this main part is done, we deal
    // with the begin and end partial bytes
    //
    if (bNextByte)
    {
        long iStrideSrc;
        long iStrideDst;
        PBYTE pjSrcEnd;

        //Get first Dst full byte
        pjDst = psb->pjDst + ((psb->xDstStart-7)>>3);

        //Get the Src byte that matches the first Dst
        // full byte
        pjSrc = psb->pjSrc + ((psb->xSrcStart-((iDst+1)&0x07))>>3);

        //Get last byte
        pjLDst = psb->pjDst + (xDstEnd>>3);

        //Get the number of full bytes

        // Sundown safe truncation
        cFullBytes = (ULONG)(pjDst - pjLDst);

        //the increment to the full byte on the next scan line
        iStrideDst = lDeltaDst + cFullBytes;
        iStrideSrc = lDeltaSrc + cFullBytes;

        // deal with our special case
        cy = psb->cy;

        if (!jAlignL)
        {
            while (cy--)
            {
                RtlMoveMemory(pjDst-(cFullBytes-1),pjSrc-(cFullBytes-1),cFullBytes);

                // move to the beginning full byte
                // on the next scan line

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }   //end of if (!jAlignL)
        else
        {
            BYTE jRem;

            while (cy--)
            {
                    jRem = *pjSrc >> jAlignR;

                    pjSrcEnd = pjSrc-cFullBytes;

                    while (pjSrc != pjSrcEnd)
                    {
                        jSrc = *(--pjSrc);

                        jDst = (jSrc<<jAlignL) | jRem;

                        *pjDst-- = jDst;

                        //next remainder
                        jRem = jSrc >> jAlignR;
                    }

                    // go to the beginging full byte of
                    // next scan line
                    pjDst += iStrideDst;
                    pjSrc += iStrideSrc;

            }
        }
    } //if

       // Begin dealing with the ending pixels

   jMask = 0xFF << (8-((1+xDstEnd) & 0x0007));

   // first check if there is any partial
   // byte left
   // and has next byte

   if (((1+xDstEnd) & 0x0007)
       && bNextByte)
   {
        // Get the last partial bytes on the
        // scan line
        pjDst = pjLDst;

        // Get the Src byte that matches the
        // right partial Dst byte
        //
        pjSrc = psb->pjSrc + ((psb->xSrcEnd+1) >>3);

        // Get the ending position in the last
        // Src and Dst bytes
        iSrc = (psb->xSrcEnd+1) & 0x0007;
        iDst = (xDstEnd + 1)& 0x0007;

        cy = psb->cy;

        if (iSrc > iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << jAlignL;
                jSrc |= *(pjSrc+1) >> jAlignR;

                jSrc &= ~jMask;

                *pjDst = (*pjDst & jMask) | jSrc;

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;

            }
        }
        else if (iSrc < iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc >> jAlignR;

                jSrc &= ~jMask;

                *pjDst = (*pjDst & jMask) | jSrc;

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
        else   // iSrc = iDst
        {
            while (cy--)
            {
                jSrc = *pjSrc;

                jSrc &= ~jMask;

                *pjDst = (*pjDst & jMask) | jSrc;

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;

           }
         }
   } //if
}


/******************************Public*Routine******************************\
* vSrcCopyS4D1
*
* Note we use pxlo to translate rather than looking at the foreground
* or background color.  This is to keep the PM/Windows differences
* transparent to the blt code.
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS4D1(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS4D1 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS4D1 - direction not up to down");

    BYTE  jSrc;
    BYTE  jDst;
    LONG  iSrc;
    LONG  iDst;
    PBYTE pjDstTemp;
    PBYTE pjSrcTemp;
    PBYTE pjDst = psb->pjDst + (psb->xDstStart >> 3);
    PBYTE pjSrc = psb->pjSrc + (psb->xSrcStart >> 1);
    ULONG cy = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
    // Initialize all the variables

        pjDstTemp  = pjDst;
        pjSrcTemp  = pjSrc;

        iSrc = psb->xSrcStart;
        iDst = psb->xDstStart;

    // Set up the Src. Left to Right.

        if (iSrc & 0x00000001)
            jSrc = *(pjSrcTemp++);

    // Set up the Dst.  We just keep adding bits to the right and
    // shifting left.

        if (iDst & 0x00000007)
        {
        // We're gonna need some bits from the 1st byte of Dst.

            jDst = (BYTE) ( ((ULONG) (*pjDstTemp)) >> (8 - (iDst & 0x00000007)) );
        }

    // Do the inner loop on a scanline

        while(iSrc != psb->xSrcEnd)
        {
            jDst <<= 1;

            if (iSrc & 0x00000001)
            {
                if (pulXlate[(jSrc & 0x0F)])
                    jDst |= 0x01;
            }
            else
            {
                jSrc = *(pjSrcTemp++);

                if (pulXlate[((jSrc & 0xF0) >> 4)])
                    jDst |= 0x01;
            }

            iDst++;
            iSrc++;

            if (!(iDst & 0x07))
                *(pjDstTemp++) = jDst;
        }

    // Clean up after the inner loop

        if (iDst & 0x00000007)
        {
        // We need to build up the last pel correctly.

            jSrc = (BYTE) (0x000000FF >> (iDst & 0x00000007));

            jDst = (BYTE) (jDst << (8 - (iDst & 0x00000007)));

	    *pjDstTemp = (BYTE) ((*pjDstTemp & jSrc) | (jDst & ~jSrc));
        }

    // Check if we have anymore scanlines to do

        if (--cy)
        {
            pjSrc += psb->lDeltaSrc;
            pjDst += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS8D1
*
* Note we use pxlo to translate rather than looking at the foreground
* or background color.  This is to keep the PM/Windows differences
* transparent to the blt code.
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D1(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS8D1 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS8D1 - direction not up to down");

    BYTE  jDst;
    LONG  iDst;
    PBYTE pjDstTemp;
    PBYTE pjSrcTemp;
    LONG  xDstEnd = psb->xDstStart + psb->cx;
    PULONG pulXlate = psb->pxlo->pulXlate;
    PBYTE pjDst = psb->pjDst + (psb->xDstStart >> 3);
    PBYTE pjSrc = psb->pjSrc + psb->xSrcStart;
    ULONG cy = psb->cy;
    BYTE jMask;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
    // Initialize the variables

        pjDstTemp  = pjDst;
        pjSrcTemp  = pjSrc;
        iDst = psb->xDstStart;

    // Set up jDst.  We just keep adding bits to the right and
    // shifting left.

        if (iDst & 0x00000007)
        {
        // We're gonna need some bits from the 1st byte of Dst.

            jDst = (BYTE) ( ((ULONG) (*pjDstTemp)) >> (8 - (iDst & 0x00000007)) );
        }

    // Do the inner loop on a scanline

        while(iDst != xDstEnd)
        {
            jDst <<= 1;

            if (pulXlate[(*(pjSrcTemp++))])
               jDst |= 0x01;

            iDst++;

            if (!(iDst & 0x07))
                *(pjDstTemp++) = jDst;
        }

    // Clean up after the inner loop

        if (iDst & 0x00000007)
        {
        // We need to build up the last pel correctly.

            jMask = (BYTE) (0x000000FF >> (iDst & 0x00000007));

            jDst = (BYTE) (jDst << (8 - (iDst & 0x00000007)));

	    *pjDstTemp = (BYTE) ((*pjDstTemp & jMask) | (jDst & ~jMask));
        }

    // Check if we have anymore scanlines to do

        if (--cy)
        {
            pjSrc += psb->lDeltaSrc;
            pjDst += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS16D1
*
* Note we use pxlo to translate rather than looking at the foreground
* or background color.  This is to keep the PM/Windows differences
* transparent to the blt code.
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS16D1(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D1 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D1 - direction not up to down");

    BYTE  jDst;
    LONG  iDst;
    PBYTE pjDstTemp;
    PUSHORT pusSrcTemp;
    LONG  xDstEnd = psb->xDstStart + psb->cx;
    XLATE *pxlo = (XLATE *) psb->pxlo;
    PBYTE pjDst = psb->pjDst + (psb->xDstStart >> 3);
    PUSHORT pusSrc = (PUSHORT) (psb->pjSrc + (psb->xSrcStart << 1));
    ULONG cy = psb->cy;
    BYTE jMask;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
    // Initialize the variables

        pjDstTemp = pjDst;
        pusSrcTemp = pusSrc;
        iDst = psb->xDstStart;

    // Set up jDst.  We just keep adding bits to the right and
    // shifting left.

        if (iDst & 0x00000007)
        {
        // We're gonna need some bits from the 1st byte of Dst.

            jDst = (BYTE) ( ((ULONG) (*pjDstTemp)) >> (8 - (iDst & 0x00000007)) );
        }

    // Do the inner loop on a scanline

        while(iDst != xDstEnd)
        {
            jDst <<= 1;

            if (pxlo->ulTranslate(*(pusSrcTemp++)))
               jDst |= 0x01;

            iDst++;

            if (!(iDst & 0x07))
                *(pjDstTemp++) = jDst;
        }

    // Clean up after the inner loop

        if (iDst & 0x00000007)
        {
        // We need to build up the last pel correctly.

            jMask = (BYTE) (0x000000FF >> (iDst & 0x00000007));

            jDst = (BYTE) (jDst << (8 - (iDst & 0x00000007)));

	    *pjDstTemp = (BYTE) ((*pjDstTemp & jMask) | (jDst & ~jMask));
        }

    // Check if we have anymore scanlines to do

        if (--cy)
        {
	    pusSrc = (PUSHORT) (((PBYTE) pusSrc) + psb->lDeltaSrc);
            pjDst += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS24D1
*
* Note we use pxlo to translate rather than looking at the foreground
* or background color.  This is to keep the PM/Windows differences
* transparent to the blt code.
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS24D1(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D1 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D1 - direction not up to down");

    BYTE  jDst;
    LONG  iDst;
    ULONG ulDink;     // variable to dink around with bytes
    PBYTE pjDstTemp;
    PBYTE pjSrcTemp;
    LONG  xDstEnd = psb->xDstStart + psb->cx;
    XLATE *pxlo = (XLATE *) psb->pxlo;
    PBYTE pjDst = psb->pjDst + (psb->xDstStart >> 3);
    PBYTE pjSrc = psb->pjSrc + (psb->xSrcStart * 3);
    ULONG cy = psb->cy;
    BYTE jMask;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
    // Initialize the variables

        pjDstTemp  = pjDst;
        pjSrcTemp  = pjSrc;
        iDst = psb->xDstStart;

    // Set up jDst.  We just keep adding bits to the right and
    // shifting left.

        if (iDst & 0x00000007)
        {
        // We're gonna need some bits from the 1st byte of Dst.

            jDst = (BYTE) ( ((ULONG) (*pjDstTemp)) >> (8 - (iDst & 0x00000007)) );
        }

    // Do the inner loop on a scanline

        while(iDst != xDstEnd)
        {
            jDst <<= 1;

            ulDink = *(pjSrcTemp + 2);
            ulDink = ulDink << 8;
            ulDink |= (ULONG) *(pjSrcTemp + 1);
            ulDink = ulDink << 8;
            ulDink |= (ULONG) *pjSrcTemp;
            pjSrcTemp += 3;

            if (pxlo->ulTranslate(ulDink))
               jDst |= 0x01;

            iDst++;

            if (!(iDst & 0x07))
                *(pjDstTemp++) = jDst;
        }

    // Clean up after the inner loop

        if (iDst & 0x00000007)
        {
        // We need to build up the last pel correctly.

            jMask = (BYTE) (0x000000FF >> (iDst & 0x00000007));

            jDst = (BYTE) (jDst << (8 - (iDst & 0x00000007)));

	    *pjDstTemp = (BYTE) ((*pjDstTemp & jMask) | (jDst & ~jMask));
        }

    // Check if we have anymore scanlines to do

        if (--cy)
        {
            pjSrc += psb->lDeltaSrc;
            pjDst += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS32D1
*
* Note we use pxlo to translate rather than looking at the foreground
* or background color.  This is to keep the PM/Windows differences
* transparent to the blt code.
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS32D1(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D1 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D1 - direction not up to down");

    BYTE  jDst;
    LONG  iDst;
    PBYTE pjDstTemp;
    PULONG pulSrcTemp;
    LONG  xDstEnd = psb->xDstStart + psb->cx;
    XLATE *pxlo = (XLATE *) psb->pxlo;
    PBYTE pjDst = psb->pjDst + (psb->xDstStart >> 3);
    PULONG pulSrc = (PULONG) (psb->pjSrc + (psb->xSrcStart << 2));
    ULONG cy = psb->cy;
    BYTE jMask;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
    // Initialize the variables

        pjDstTemp  = pjDst;
        pulSrcTemp  = pulSrc;
        iDst = psb->xDstStart;

    // Set up jDst.  We just keep adding bits to the right and
    // shifting left.

        if (iDst & 0x00000007)
        {
        // We're gonna need some bits from the 1st byte of Dst.

            jDst = (BYTE) ( ((ULONG) (*pjDstTemp)) >> (8 - (iDst & 0x00000007)) );
        }

    // Do the inner loop on a scanline

        while(iDst != xDstEnd)
        {
            jDst <<= 1;

            if (pxlo->ulTranslate(*(pulSrcTemp++)))
               jDst |= 0x01;

            iDst++;

            if (!(iDst & 0x07))
                *(pjDstTemp++) = jDst;
        }

    // Clean up after the inner loop

        if (iDst & 0x00000007)
        {
        // We need to build up the last pel correctly.

            jMask = (BYTE) (0x000000FF >> (iDst & 0x00000007));

            jDst = (BYTE) (jDst << (8 - (iDst & 0x00000007)));

	    *pjDstTemp = (BYTE) ((*pjDstTemp & jMask) | (jDst & ~jMask));
        }

    // Check if we have anymore scanlines to do

        if (--cy)
        {
	    pulSrc = (PULONG) (((PBYTE) pulSrc) + psb->lDeltaSrc);
            pjDst += psb->lDeltaDst;
        }
        else
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\srcblt16.cxx ===
/******************************Module*Header*******************************\
* Module Name: srcblt16.cxx
*
* This contains the bitmap simulation functions that blt to a 16 bit/pel
* DIB surface.
*
* Created: 07-Feb-1991 19:27:49
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// Turn off validations
#if 1

    // On free builds, don't call any verification code:

    #define VERIFYS16D16(psb)
    #define VERIFYS24D16(psb)
    #define VERIFYS32D16(psb)

#else

    // On checked builds, verify the RGB conversions:

    VOID VERIFYS16D16(PBLTINFO psb)
    {
    // We assume we are doing left to right top to bottom blting
    // If it was on the same surface it would be the identity case.

        ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D16 - direction not left to right");
        ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D16 - direction not up to down");

    // These are our holding variables

        PUSHORT pusSrcTemp;
        PUSHORT pusDstTemp;
        ULONG  cxTemp;
        PUSHORT pusSrc  = (PUSHORT) (psb->pjSrc + (2 * psb->xSrcStart));
        PUSHORT pusDst  = (PUSHORT) (psb->pjDst + (2 * psb->xDstStart));
        ULONG cx     = psb->cx;
        ULONG cy     = psb->cy;
        XLATE *pxlo = psb->pxlo;

        ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

        while(1)
        {
            pusSrcTemp  = pusSrc;
            pusDstTemp  = pusDst;
            cxTemp     = cx;

            while(cxTemp--)
            {
                if (*(pusDstTemp++) != (USHORT) (pxlo->ulTranslate((ULONG) *(pusSrcTemp++))))
                    RIP("RGB mis-match");
            }

            if (--cy)
            {
                pusSrc = (PUSHORT) (((PBYTE) pusSrc) + psb->lDeltaSrc);
                pusDst = (PUSHORT) (((PBYTE) pusDst) + psb->lDeltaDst);
            }
            else
                break;
        }
    }

    VOID VERIFYS24D16(PBLTINFO psb)
    {
    // We assume we are doing left to right top to bottom blting

        ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D16 - direction not left to right");
        ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D16 - direction not up to down");

    // These are our holding variables

        ULONG ulDink;          // variable to dink around with the bytes in
        PBYTE pjSrcTemp;
        PUSHORT pusDstTemp;
        ULONG  cxTemp;
        PBYTE pjSrc  = psb->pjSrc + (3 * psb->xSrcStart);
        PUSHORT pusDst  = (PUSHORT) (psb->pjDst + (2 * psb->xDstStart));
        ULONG cx     = psb->cx;
        ULONG cy     = psb->cy;
        XLATE *pxlo = psb->pxlo;

        ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

        while(1)
        {

            pjSrcTemp  = pjSrc;
            pusDstTemp  = pusDst;
            cxTemp     = cx;

            while(cxTemp--)
            {
                ulDink = *(pjSrcTemp + 2);
                ulDink = ulDink << 8;
                ulDink |= (ULONG) *(pjSrcTemp + 1);
                ulDink = ulDink << 8;
                ulDink |= (ULONG) *pjSrcTemp;

                if (*pusDstTemp != (USHORT) (pxlo->ulTranslate(ulDink)))
                    RIP("RGB mis-match");

                pusDstTemp++;
                pjSrcTemp += 3;
            }

            if (--cy)
            {
                pjSrc += psb->lDeltaSrc;
                pusDst = (PUSHORT) (((PBYTE) pusDst) + psb->lDeltaDst);
            }
            else
                break;
        }
    }

    VOID VERIFYS32D16(PBLTINFO psb)
    {
    // We assume we are doing left to right top to bottom blting.

        ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D16 - direction not left to right");
        ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D16 - direction not up to down");

    // These are our holding variables

        PULONG pulSrcTemp;
        PUSHORT pusDstTemp;
        ULONG  cxTemp;
        PULONG pulSrc  = (PULONG) (psb->pjSrc + (4 * psb->xSrcStart));
        PUSHORT pusDst  = (PUSHORT) (psb->pjDst + (2 * psb->xDstStart));
        ULONG cx     = psb->cx;
        ULONG cy     = psb->cy;
        XLATE *pxlo = psb->pxlo;
        ULONG  ulLastSrcPel;
        USHORT usLastDstPel;

        ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

        usLastDstPel = (USHORT) (pxlo->ulTranslate(ulLastSrcPel = *pulSrc));

        while(1)
        {

            pulSrcTemp  = pulSrc;
            pusDstTemp  = pusDst;
            cxTemp     = cx;

            while(cxTemp--)
            {
                ULONG ulTemp;

                if ((ulTemp = *(pulSrcTemp)) != ulLastSrcPel)
                {
                    ulLastSrcPel = ulTemp;
                    usLastDstPel = (USHORT) (pxlo->ulTranslate(ulLastSrcPel));
                }

                if (*pusDstTemp++ != usLastDstPel)
                    RIP("RGB mis-match");

                pulSrcTemp++;
            }

            if (--cy)
            {
                pulSrc = (PULONG) (((PBYTE) pulSrc) + psb->lDeltaSrc);
                pusDst = (PUSHORT) (((PBYTE) pusDst) + psb->lDeltaDst);
            }
            else
                break;
        }
    }

#endif

/*******************Public*Routine*****************\
* vSrcCopyS1D16
*
* There are three main loops in this function.
*
* The first loop deals with the full byte part mapping
* the Dst while fetching/shifting the matching 8 bits
* from the Src.
*
* The second loop deals with the left starting
* pixels.
*
* The third loop deals with the ending pixels.
*
* For the full bytes, we walk thru Src one byte at a time
* and expand to Dst 8 words at a time.  Dst is
* DWORD aligned.
*
* We expand the starting/ending pixels one bit
* at a time.
*
* History:
* 17-Oct-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.
*
\**************************************************/
VOID vSrcCopyS1D16(PBLTINFO psb)
{
    BYTE  jSrc;    // holds a source byte
    INT   iDst;    // Position in the first 8 Dst words
    INT   iSrc;    // bit position in the first Src byte
    PBYTE pjDst;   // pointer to the Src bytes
    PBYTE pjSrc;   // pointer to the Dst bytes
    LONG  xSrcEnd = psb->xSrcEnd;
    LONG  cy;      // number of rows
    LONG  cx;      // number of pixels
    BYTE  alignL;  // alignment bits to the left
    BYTE  alignR;  // alignment bits to the right
    LONG  cibytes;  //number of full 8 bytes dealed with
    BOOL  bNextByte;
    LONG  xDstEnd = psb->xDstStart+psb->cx;
    LONG  lDeltaDst;
    LONG  lDeltaSrc;
    USHORT ausTable[2];
    ULONG ulB = (ULONG)(psb->pxlo->pulXlate[0]);
    ULONG uF = (ULONG)(psb->pxlo->pulXlate[1]);
    USHORT usB = (USHORT)(psb->pxlo->pulXlate[0]);
    USHORT usF = (USHORT)(psb->pxlo->pulXlate[1]);
    ULONG aulTable[4];
    INT   count;
    BOOL  bNextSrc = TRUE;

    // We assume we are doing left to right top to bottom blting
    ASSERTGDI(psb->xDir == 1, "vSrcCopyS1D16 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS1D16 - direction not up to down");

    ASSERTGDI(psb->cy != 0, "ERROR: Src Move cy == 0");

    //DbgPrint ("vsrccopys1d16\n");

    // Generate aulTable. 4 entries.
    // Each 2 bits will be an index to the aulTable
    // which translates to a 32 bit ULONG
    ULONG ulValB = ulB;
    ULONG ulValF = uF;

    ulValB = (ulValB << 16) | ulValB;
    ulValF = (ulValF << 16) | ulValF;

    aulTable[0] = ulValB;         //0 0
    aulTable[1] = (ulValF<<16) | (ulValB>>16);         //1 0
    aulTable[2] = (ulValB<<16) | (ulValF>>16);         //0 1
    aulTable[3] =  ulValF ;         //1 1

    // Generate ausTable.
    // Two entries.  This table used when dealing
    // with begin and end parts.
    ausTable[0] = usB;
    ausTable[1] = usF;

    //Get Src and Dst start positions
    iSrc = psb->xSrcStart & 0x0007;
    iDst = psb->xDstStart & 0x0007;

    if (iSrc < iDst)
        alignL = 8 - (iDst - iSrc);
    else
        alignL = iSrc - iDst;

    alignR = 8 - alignL;

    cx=psb->cx;

    lDeltaDst = psb->lDeltaDst;
    lDeltaSrc = psb->lDeltaSrc;

    // if there is a next 8 words
    bNextByte = !((xDstEnd>>3) ==
                 (psb->xDstStart>>3));

    // if Src and Dst are aligned, use a separete loop
    // to obtain better performance;
    // If not, we shift the Src bytes to match with
    // the Dst 8 bytes (2 dwords) one at a time

    if (bNextByte)
    {
        long iStrideSrc;
        long iStrideDst;
        PBYTE pjSrcEnd;

        // Get first Dst full 8 words
        pjDst = psb->pjDst + 2*((psb->xDstStart+7)&~0x07);

        // Get the Src byte that matches the first Dst
        // full 8 bytes
        pjSrc = psb->pjSrc + ((psb->xSrcStart+((8-iDst)&0x07)) >> 3);

        //Get the number of full 8 words
        cibytes = (xDstEnd>>3)-((psb->xDstStart+7)>>3);

        //the increment to the full byte on the next scan line
        iStrideDst = lDeltaDst - cibytes*16;
        iStrideSrc = lDeltaSrc - cibytes;

        // deal with our special case
        cy = psb->cy;

        if (!alignL)
        {
            while (cy--)
            {
                pjSrcEnd = pjSrc + cibytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = *pjSrc++;

                    *(PULONG) (pjDst + 0) = aulTable[(jSrc >> 6) & 0x03];
                    *(PULONG) (pjDst + 4) = aulTable[(jSrc >> 4) & 0x03];
                    *(PULONG) (pjDst + 8) = aulTable[(jSrc >> 2)& 0x03];
                    *(PULONG) (pjDst + 12) = aulTable[jSrc & 0x03];

                    pjDst +=16;
                }

                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }

        }   //end of if (!alignL)

        // Here comes our general case for the main full
        // bytes part

        else  // if not aligned
        {
            BYTE jRem; //remainder

            while (cy--)
            {
                jRem = *pjSrc << alignL;

                pjSrcEnd = pjSrc + cibytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = ((*(++pjSrc))>>alignR) | jRem;

                    *(PULONG) (pjDst + 0) = aulTable[(jSrc >> 6) & 0x03];
                    *(PULONG) (pjDst + 4) = aulTable[(jSrc >> 4) & 0x03];
                    *(PULONG) (pjDst + 8) = aulTable[(jSrc >> 2)& 0x03];
                    *(PULONG) (pjDst + 12) = aulTable[jSrc & 0x03];

                    pjDst +=16;

                    //next remainder
                    jRem = *pjSrc << alignL;
                }

                // go to the beginging full byte of
                // next scan line
                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }
        } //else
    } //if
    // End of our dealing with the full bytes

    //Deal with the starting pixels
    if (!bNextByte)
    {
        count = cx;
        bNextSrc = ((iSrc+cx) > 8);
    }
    else
        count = 8-iDst;

    if (iDst | !bNextByte)
    {
        PBYTE pjDstTemp;
        PBYTE pjDstEnd;

        pjDst = psb->pjDst + 2*psb->xDstStart;
        pjSrc = psb->pjSrc + (psb->xSrcStart>>3);

        cy = psb->cy;

        if (iSrc > iDst)
        {
            if (bNextSrc)
            {
                while (cy--)
                {
                    jSrc = *pjSrc << alignL;
                    jSrc |= *(pjSrc+1) >> alignR;

                    jSrc <<= iDst;

                    pjDstTemp = pjDst;
                    pjDstEnd = pjDst + count*2;

                    while (pjDstTemp != pjDstEnd)
                    {
                        *(PUSHORT) pjDstTemp = ausTable[(jSrc&0x80)>>7];

                        jSrc <<= 1;
                        pjDstTemp +=  2;
                    }

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }
            else
            {
                 while (cy--)
                {
                    jSrc = *pjSrc << alignL;

                    jSrc <<= iDst;

                    pjDstTemp = pjDst;
                    pjDstEnd = pjDst + count*2;

                    while (pjDstTemp != pjDstEnd)
                    {
                        *(PUSHORT) pjDstTemp = ausTable[(jSrc&0x80)>>7];

                        jSrc <<= 1;
                        pjDstTemp +=  2;
                    }

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }
        }
        else //if (iSrc < iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << iSrc;

                pjDstTemp = pjDst;
                pjDstEnd = pjDst + 2*count;

                while (pjDstTemp != pjDstEnd)
                {
                    *(PUSHORT) pjDstTemp = ausTable[(jSrc&0x80)>>7];

                    jSrc <<= 1;
                    pjDstTemp +=  2;
                }

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }

        }

   } //if

   // Deal with the ending pixels
   if ((xDstEnd & 0x0007)
       && bNextByte)
   {
        PBYTE pjDstTemp;
        PBYTE pjDstEnd;

        // Get the last partial bytes on the
        // scan line
        pjDst = psb->pjDst+2*(xDstEnd&~0x07);

        // Get the Src byte that matches the
        // right partial Dst 8 bytes
        pjSrc = psb->pjSrc + ((psb->xSrcEnd-1) >>3);

        // Get the ending position in the last
        // Src and Dst bytes
        iSrc = (psb->xSrcEnd-1) & 0x0007;
        iDst = (xDstEnd-1) & 0x0007;

        count = iDst+1;

        cy = psb->cy;

        if (iSrc >= iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << alignL;

                pjDstTemp = pjDst;
                pjDstEnd = pjDst + 2*count;

                while (pjDstTemp != pjDstEnd)
                {
                    *(PUSHORT) pjDstTemp = ausTable[(jSrc&0x80)>>7];

                    jSrc <<= 1;
                    pjDstTemp +=  2;
                }

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
        else if (iSrc < iDst)
        {
            while (cy--)
            {
                 jSrc = *(pjSrc-1) << alignL;

                 jSrc |= *pjSrc >> alignR;

                 pjDstTemp = pjDst;

                 pjDstEnd = pjDst + 2*count;

                 while (pjDstTemp != pjDstEnd)
                 {
                    *(PUSHORT) pjDstTemp = ausTable[(jSrc&0x80)>>7];

                    jSrc <<= 1;
                    pjDstTemp +=  2;
                 }

                 pjDst += lDeltaDst;
                 pjSrc += lDeltaSrc;
            }
        }
     } //if
}


/******************************Public*Routine******************************\
* vSrcCopyS4D16
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS4D16(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS4D16 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS4D16 - direction not up to down");

    BYTE  jSrc;
    LONG  i;
    PUSHORT pusDst;
    PBYTE pjSrc;
    PUSHORT pusDstHolder  = (PUSHORT) (psb->pjDst + (2 * psb->xDstStart));
    PBYTE pjSrcHolder  = psb->pjSrc + (psb->xSrcStart >> 1);
    ULONG cy = psb->cy;
    XLATE *pxlo = psb->pxlo;
    PULONG pulXlate = psb->pxlo->pulXlate;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
        pusDst  = pusDstHolder;
        pjSrc  = pjSrcHolder;

        i = psb->xSrcStart;

        if (i & 0x00000001)
            jSrc = *(pjSrc++);

        while(i != psb->xSrcEnd)
        {
            if (i & 0x00000001)
                *(pusDst++) = (USHORT) pulXlate[jSrc & 0x0F];
            else
            {
            // We need a new byte

                jSrc = *(pjSrc++);
                *(pusDst++) = (USHORT) pulXlate[((ULONG) (jSrc & 0xF0)) >> 4];
            }

            ++i;
        }

        if (--cy)
        {
            pjSrcHolder += psb->lDeltaSrc;
            pusDstHolder = (PUSHORT) (((PBYTE) pusDstHolder) + psb->lDeltaDst);
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS8D16
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D16(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS8D16 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS8D16 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + psb->xSrcStart;
    PBYTE pjDst  = psb->pjDst + (2 * psb->xDstStart);
    LONG cx     = psb->cx;
    LONG cy     = psb->cy;
    XLATE *pxlo = psb->pxlo;
    PULONG pulXlate = psb->pxlo->pulXlate;
    LONG lSrcSkip = psb->lDeltaSrc - cx;
    LONG lDstSkip = psb->lDeltaDst - (cx * 2);
    LONG i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
        i = cx;

        // Get 'dword' alignment on the destination:

        if (((ULONG_PTR) pjDst) & 2)
        {
            *((USHORT*) pjDst) = (USHORT) pulXlate[*pjSrc];
            pjDst += 2;
            pjSrc += 1;
            i--;
        }

        // Now write pixels a dword at a time.  This is almost a 2x win
        // over doing word writes if we're writing to frame buffer memory
        // over the PCI bus on Pentium class systems, because the PCI
        // write throughput is so slow:

        while(1)
        {
            i -=2;
            if (i < 0)
                break;

            *((ULONG*) pjDst) = (pulXlate[*(pjSrc)])
                              | (pulXlate[*(pjSrc + 1)] << 16);
            pjDst += 4;
            pjSrc += 2;
        }

        // Take care of the end alignment:

        if (i & 1)
        {
            *((USHORT*) pjDst) = (USHORT) pulXlate[*pjSrc];
            pjDst += 2;
            pjSrc += 1;
        }

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS16D16
*
*
* History:
*  07-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/
VOID vSrcCopyS16D16(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting
// If it was on the same surface it would be the identity case.

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D16 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D16 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + (2 * psb->xSrcStart);
    PBYTE pjDst  = psb->pjDst + (2 * psb->xDstStart);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    XLATE *pxlo = psb->pxlo;
    XEPALOBJ palSrc(pxlo->ppalSrc);
    XEPALOBJ palDst(pxlo->ppalDst);
    LONG lSrcSkip = psb->lDeltaSrc - (cx * 2);
    LONG lDstSkip = psb->lDeltaDst - (cx * 2);
    PFN_pfnXlate pfnXlate;
    LONG i;
    USHORT us;
    ULONG ul;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

// Optimize 5-5-5 to 5-6-5.

    if (palSrc.bIs555() && palDst.bIs565())
    {
        while (1)
        {
            i = cx;

            if (((ULONG_PTR) pjDst) & 2)
            {
                us = *((USHORT*) pjSrc);

                *((USHORT*) pjDst) = ((us) & 0x001f)
                                   | ((us << 1) & 0xffc0)
                                   | ((us >> 4) & 0x0020);
                pjDst += 2;
                pjSrc += 2;
                i--;
            }

            while(1)
            {
                i -=2;
                if (i < 0)
                    break;

                ul = *(UNALIGNED_DWORD_POINTER(pjSrc));

                *((ULONG*) pjDst) = ((ul) & 0x001f001f)
                                  | ((ul << 1) & 0xffc0ffc0)
                                  | ((ul >> 4) & 0x00200020);
                pjDst += 4;
                pjSrc += 4;
            }

            if (i & 1)
            {
                us = *((USHORT*) pjSrc);

                *((USHORT*) pjDst) = ((us) & 0x001f)
                                   | ((us << 1) & 0xffc0)
                                   | ((us >> 4) & 0x0020);
                pjDst += 2;
                pjSrc += 2;
            }

            if (--cy == 0)
                break;

            pjSrc += lSrcSkip;
            pjDst += lDstSkip;
        }

        VERIFYS16D16(psb);
        return;
    }

// Optimize 5-6-5 to 5-5-5.

    if (palSrc.bIs565() && palDst.bIs555())
    {
        while (1)
        {
            i = cx;

            if (((ULONG_PTR) pjDst) & 2)
            {
                us = *((USHORT*) pjSrc);

                *((USHORT*) pjDst) = ((us) & 0x001f)
                                   | ((us >> 1) & 0x7fe0);
                pjDst += 2;
                pjSrc += 2;
                i--;
            }

            while(1)
            {
                i -=2;
                if (i < 0)
                    break;

                ul = *(UNALIGNED_DWORD_POINTER(pjSrc));

                *((ULONG*) pjDst) = ((ul) & 0x001f001f)
                                  | ((ul >> 1) & 0x7fe07fe0);
                pjDst += 4;
                pjSrc += 4;
            }

            if (i & 1)
            {
                us = *((USHORT*) pjSrc);

                *((USHORT*) pjDst) = ((us) & 0x001f)
                                   | ((us >> 1) & 0x7fe0);
                pjDst += 2;
                pjSrc += 2;
            }

            if (--cy == 0)
                break;

            pjSrc += lSrcSkip;
            pjDst += lDstSkip;
        }

        VERIFYS16D16(psb);
        return;
    }

// Finally, fall back to the generic case:

    pfnXlate = pxlo->pfnXlateBetweenBitfields();

    while (1)
    {
        i = cx;

        do {
            *((USHORT*) pjDst) = (USHORT) pfnXlate(pxlo, *((USHORT*) pjSrc));
            pjDst += 2;
            pjSrc += 2;

        } while (--i != 0);

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    VERIFYS16D16(psb);
}

/******************************Public*Routine******************************\
* vSrcCopyS16D16Identity
*
* This is the special case no translate blting.  All the SmDn should have
* them if m==n.  Identity xlates only occur amoung matching format bitmaps.
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS16D16Identity(PBLTINFO psb)
{
// These are our holding variables

    PUSHORT pusSrc  = (PUSHORT) (psb->pjSrc + (2 * psb->xSrcStart));
    PUSHORT pusDst  = (PUSHORT) (psb->pjDst + (2 * psb->xDstStart));
    ULONG  cx     = psb->cx;
    ULONG  cy     = psb->cy;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    if (psb->xDir < 0)
    {
        pusSrc -= (cx - 1);
        pusDst -= (cx - 1);
    }

    cx = cx << 1;

    while(1)
    {
        if(psb->fSrcAlignedRd)
            vSrcAlignCopyMemory((PBYTE)pusDst,(PBYTE)pusSrc,cx);
        else
            RtlMoveMemory((PVOID)pusDst, (PVOID)pusSrc, cx);

        if (--cy)
        {
            pusSrc = (PUSHORT) (((PBYTE) pusSrc) + psb->lDeltaSrc);
            pusDst = (PUSHORT) (((PBYTE) pusDst) + psb->lDeltaDst);
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS24D16
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS24D16(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D16 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D16 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + (3 * psb->xSrcStart);
    PBYTE pjDst  = psb->pjDst + (2 * psb->xDstStart);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    LONG lSrcSkip = psb->lDeltaSrc - (cx * 3);
    LONG lDstSkip = psb->lDeltaDst - (cx * 2);
    XLATE *pxlo = psb->pxlo;
    XEPALOBJ palSrc(pxlo->ppalSrc);
    XEPALOBJ palDst(pxlo->ppalDst);
    PFN_pfnXlate pfnXlate;
    ULONG ul;
    ULONG ul0;
    ULONG ul1;
    LONG i;

    ASSERTGDI(cy != 0,
        "ERROR: Src Move cy == 0");
    ASSERTGDI(((pxlo->flXlate & (XO_TABLE | XO_TO_MONO)) == 0)
              && ((pxlo->flPrivate & XLATE_PAL_MANAGED) == 0),
        "ERROR: flXlate != 0 or flPrivate != 0");
    ASSERTGDI(((XEPALOBJ) pxlo->ppalDst).cEntries() == 0,
        "ERROR: cEntries != 0");
    ASSERTGDI(palDst.bIsBitfields(),
        "ERROR: destination not bitfields");

    if (palSrc.bIsBGR())
    {

    // First, try to optimize BGR to 5-6-5:

        if (palDst.bIs565())
        {
            while (1)
            {
                i = cx;

                if (((ULONG_PTR) pjDst) & 2)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 3) & 0x07e0)
                       | ((*(pjSrc + 2) << 8) & 0xf800);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 3;
                    i--;
                }

                #if defined(_X86_)

                    _asm {

                        mov   esi, pjSrc
                        mov   edi, pjDst
                        sub   i, 2
                        js    Done_565_Loop

                    Middle_565_Loop:

                        movzx eax, byte ptr [esi]
                        movzx ebx, byte ptr [esi+1]
                        shr   eax, 3
                        shl   ebx, 3
                        movzx edx, byte ptr [esi+2]
                        movzx ecx, byte ptr [esi+3]
                        shl   edx, 8
                        shl   ecx, 13
                        or    eax, edx
                        or    ebx, ecx
                        movzx edx, byte ptr [esi+4]
                        movzx ecx, byte ptr [esi+5]
                        shl   edx, 19
                        shl   ecx, 24
                        or    eax, edx
                        or    ebx, ecx
                        and   eax, 0x07e0f81f
                        and   ebx, 0xf81f07e0
                        or    eax, ebx
                        add   esi, 6
                        mov   [edi], eax
                        add   edi, 4
                        sub   i, 2
                        jns   Middle_565_Loop

                    Done_565_Loop:

                        mov   pjSrc, esi
                        mov   pjDst, edi
                    }

                #else

                    while (1)
                    {
                        i -= 2;
                        if (i < 0)
                            break;

                        ul0 = (*(pjSrc) >> 3)
                            | (*(pjSrc + 2) << 8)
                            | (*(pjSrc + 4) << 19);
                        ul1 = (*(pjSrc + 1) << 3)
                            | (*(pjSrc + 3) << 13)
                            | (*(pjSrc + 5) << 24);

                        *((ULONG*) pjDst) = (ul0 & 0x07e0f81f)
                                          | (ul1 & 0xf81f07e0);

                        pjDst += 4;
                        pjSrc += 6;
                    }

                #endif

                if (i & 1)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 3) & 0x07e0)
                       | ((*(pjSrc + 2) << 8) & 0xf800);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 3;
                }

                if (--cy == 0)
                    break;

                pjSrc += lSrcSkip;
                pjDst += lDstSkip;
            }

            VERIFYS24D16(psb);
            return;
        }

    // Next, try to optimize BGR to 5-5-5:

        if (palDst.bIs555())
        {
            while (1)
            {
                i = cx;

                if (((ULONG_PTR) pjDst) & 2)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 2) & 0x03e0)
                       | ((*(pjSrc + 2) << 7) & 0x7c00);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 3;
                    i--;
                }

                #if defined(_X86_)

                    _asm {

                        mov   esi, pjSrc
                        mov   edi, pjDst
                        sub   i, 2
                        js    Done_555_Loop

                    Middle_555_Loop:

                        movzx eax, byte ptr [esi]
                        movzx ebx, byte ptr [esi+1]
                        shr   eax, 3
                        shl   ebx, 2
                        movzx edx, byte ptr [esi+2]
                        movzx ecx, byte ptr [esi+3]
                        shl   edx, 7
                        shl   ecx, 13
                        or    eax, edx
                        or    ebx, ecx
                        movzx edx, byte ptr [esi+4]
                        movzx ecx, byte ptr [esi+5]
                        shl   edx, 18
                        shl   ecx, 23
                        or    eax, edx
                        or    ebx, ecx
                        and   eax, 0x03e07c1f
                        and   ebx, 0x7c1f03e0
                        or    eax, ebx
                        add   esi, 6
                        mov   [edi], eax
                        add   edi, 4
                        sub   i, 2
                        jns   Middle_555_Loop

                    Done_555_Loop:

                        mov   pjSrc, esi
                        mov   pjDst, edi
                    }

                #else

                    while (1)
                    {
                        i -= 2;
                        if (i < 0)
                            break;

                        ul0 = (*(pjSrc) >> 3)
                            | (*(pjSrc + 2) << 7)
                            | (*(pjSrc + 4) << 18);
                        ul1 = (*(pjSrc + 1) << 2)
                            | (*(pjSrc + 3) << 13)
                            | (*(pjSrc + 5) << 23);

                        *((ULONG*) pjDst) = (ul0 & 0x03e07c1f)
                                          | (ul1 & 0x7c1f03e0);

                        pjDst += 4;
                        pjSrc += 6;
                    }

                #endif

                if (i & 1)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 2) & 0x03e0)
                       | ((*(pjSrc + 2) << 7) & 0x7c00);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 3;
                }

                if (--cy == 0)
                    break;

                pjSrc += lSrcSkip;
                pjDst += lDstSkip;
            }

            VERIFYS24D16(psb);
            return;
        }
    }

// Finally, fall back to the generic case:

    pfnXlate = pxlo->pfnXlateBetweenBitfields();

    while (1)
    {
        i = cx;

        do {
            ul = ((ULONG) *(pjSrc))
               | ((ULONG) *(pjSrc + 1) << 8)
               | ((ULONG) *(pjSrc + 2) << 16);

            *((USHORT*) pjDst) = (USHORT) pfnXlate(pxlo, ul);
            pjDst += 2;
            pjSrc += 3;

        } while (--i != 0);

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    VERIFYS24D16(psb);
}

/******************************Public*Routine******************************\
* vSrcCopyS32D16
*
*
* History:
*  07-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS32D16(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting.

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D16 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D16 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + (4 * psb->xSrcStart);
    PBYTE pjDst  = psb->pjDst + (2 * psb->xDstStart);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    LONG lSrcSkip = psb->lDeltaSrc - (cx * 4);
    LONG lDstSkip = psb->lDeltaDst - (cx * 2);
    XLATE *pxlo = psb->pxlo;
    XEPALOBJ palSrc(pxlo->ppalSrc);
    XEPALOBJ palDst(pxlo->ppalDst);
    PFN_pfnXlate pfnXlate;
    ULONG ul;
    ULONG ul0;
    ULONG ul1;
    LONG i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    if (palSrc.bIsBGR())
    {

    // First, try to optimize BGR to 5-6-5:

        if (palDst.bIs565())
        {
            while (1)
            {
                i = cx;

                if (((ULONG_PTR) pjDst) & 2)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 3) & 0x07e0)
                       | ((*(pjSrc + 2) << 8) & 0xf800);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 4;
                    i--;
                }

                #if defined(_X86_)

                    _asm {

                        mov   esi, pjSrc
                        mov   edi, pjDst
                        sub   i, 2
                        js    Done_565_Loop

                    Middle_565_Loop:

                        movzx eax, byte ptr [esi]
                        movzx ebx, byte ptr [esi+1]
                        shr   eax, 3
                        shl   ebx, 3
                        movzx edx, byte ptr [esi+2]
                        movzx ecx, byte ptr [esi+4]
                        shl   edx, 8
                        shl   ecx, 13
                        or    eax, edx
                        or    ebx, ecx
                        movzx edx, byte ptr [esi+5]
                        movzx ecx, byte ptr [esi+6]
                        shl   edx, 19
                        shl   ecx, 24
                        or    eax, edx
                        or    ebx, ecx
                        and   eax, 0x07e0f81f
                        and   ebx, 0xf81f07e0
                        or    eax, ebx
                        add   esi, 8
                        mov   [edi], eax
                        add   edi, 4
                        sub   i, 2
                        jns   Middle_565_Loop

                    Done_565_Loop:

                        mov   pjSrc, esi
                        mov   pjDst, edi
                    }

                #else

                    while (1)
                    {
                        i -= 2;
                        if (i < 0)
                            break;

                        ul0 = (*(pjSrc) >> 3)
                            | (*(pjSrc + 2) << 8)
                            | (*(pjSrc + 5) << 19);
                        ul1 = (*(pjSrc + 1) << 3)
                            | (*(pjSrc + 4) << 13)
                            | (*(pjSrc + 6) << 24);

                        *((ULONG*) pjDst) = (ul0 & 0x07e0f81f)
                                          | (ul1 & 0xf81f07e0);

                        pjDst += 4;
                        pjSrc += 8;
                    }

                #endif

                if (i & 1)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 3) & 0x07e0)
                       | ((*(pjSrc + 2) << 8) & 0xf800);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 4;
                }

                if (--cy == 0)
                    break;

                pjSrc += lSrcSkip;
                pjDst += lDstSkip;
            }

            VERIFYS32D16(psb);
            return;
        }

    // Next, try to optimize BGR to 5-5-5:

        if (palDst.bIs555())
        {
            while (1)
            {
                i = cx;

                if (((ULONG_PTR) pjDst) & 2)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 2) & 0x03e0)
                       | ((*(pjSrc + 2) << 7) & 0x7c00);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 4;
                    i--;
                }

                #if defined(_X86_)

                    _asm {

                        mov   esi, pjSrc
                        mov   edi, pjDst
                        sub   i, 2
                        js    Done_555_Loop

                    Middle_555_Loop:

                        movzx eax, byte ptr [esi]
                        movzx ebx, byte ptr [esi+1]
                        shr   eax, 3
                        shl   ebx, 2
                        movzx edx, byte ptr [esi+2]
                        movzx ecx, byte ptr [esi+4]
                        shl   edx, 7
                        shl   ecx, 13
                        or    eax, edx
                        or    ebx, ecx
                        movzx edx, byte ptr [esi+5]
                        movzx ecx, byte ptr [esi+6]
                        shl   edx, 18
                        shl   ecx, 23
                        or    eax, edx
                        or    ebx, ecx
                        and   eax, 0x03e07c1f
                        and   ebx, 0x7c1f03e0
                        or    eax, ebx
                        add   esi, 8
                        mov   [edi], eax
                        add   edi, 4
                        sub   i, 2
                        jns   Middle_555_Loop

                    Done_555_Loop:

                        mov   pjSrc, esi
                        mov   pjDst, edi
                    }

                #else

                    while (1)
                    {
                        i -= 2;
                        if (i < 0)
                            break;

                        ul0 = (*(pjSrc) >> 3)
                            | (*(pjSrc + 2) << 7)
                            | (*(pjSrc + 5) << 18);
                        ul1 = (*(pjSrc + 1) << 2)
                            | (*(pjSrc + 4) << 13)
                            | (*(pjSrc + 6) << 23);

                        *((ULONG*) pjDst) = (ul0 & 0x03e07c1f)
                                          | (ul1 & 0x7c1f03e0);

                        pjDst += 4;
                        pjSrc += 8;
                    }

                #endif

                if (i & 1)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 2) & 0x03e0)
                       | ((*(pjSrc + 2) << 7) & 0x7c00);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 4;
                }

                if (--cy == 0)
                    break;

                pjSrc += lSrcSkip;
                pjDst += lDstSkip;
            }

            VERIFYS32D16(psb);
            return;
        }
    }

// Finally, fall back to the generic case:

    pfnXlate = pxlo->pfnXlateBetweenBitfields();

    while (1)
    {
        i = cx;

        do {
            *((USHORT*) pjDst) = (USHORT) pfnXlate(pxlo, *((ULONG*) pjSrc));
            pjDst += 2;
            pjSrc += 4;

        } while (--i != 0);

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    VERIFYS32D16(psb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\spool.cxx ===
/******************************Module*Header*******************************\
* Module Name: spool.cxx
*
* Created: 21-Feb-1995 10:13:18
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"



DWORD DriverInfo1Offsets[]={offsetof(DRIVER_INFO_1W, pName),
                            0xFFFFFFFF};

DWORD DriverInfo2Offsets[]={offsetof(DRIVER_INFO_2W, pName),
                            offsetof(DRIVER_INFO_2W, pEnvironment),
                            offsetof(DRIVER_INFO_2W, pDriverPath),
                            offsetof(DRIVER_INFO_2W, pDataFile),
                            offsetof(DRIVER_INFO_2W, pConfigFile),
                            0xFFFFFFFF};
DWORD DriverInfo3Offsets[]={offsetof(DRIVER_INFO_3W, pName),
                            offsetof(DRIVER_INFO_3W, pEnvironment),
                            offsetof(DRIVER_INFO_3W, pDriverPath),
                            offsetof(DRIVER_INFO_3W, pDataFile),
                            offsetof(DRIVER_INFO_3W, pConfigFile),
                            offsetof(DRIVER_INFO_3W, pHelpFile),
                            offsetof(DRIVER_INFO_3W, pDependentFiles),
                            offsetof(DRIVER_INFO_3W, pMonitorName),
                            offsetof(DRIVER_INFO_3W, pDefaultDataType),
                            0xFFFFFFFF};

DWORD DriverInfo1Strings[]={offsetof(DRIVER_INFO_1W, pName),
                            0xFFFFFFFF};

DWORD DriverInfo2Strings[]={offsetof(DRIVER_INFO_2W, pName),
                            offsetof(DRIVER_INFO_2W, pEnvironment),
                            offsetof(DRIVER_INFO_2W, pDriverPath),
                            offsetof(DRIVER_INFO_2W, pDataFile),
                            offsetof(DRIVER_INFO_2W, pConfigFile),
                            0xFFFFFFFF};
DWORD DriverInfo3Strings[]={offsetof(DRIVER_INFO_3W, pName),
                            offsetof(DRIVER_INFO_3W, pEnvironment),
                            offsetof(DRIVER_INFO_3W, pDriverPath),
                            offsetof(DRIVER_INFO_3W, pDataFile),
                            offsetof(DRIVER_INFO_3W, pConfigFile),
                            offsetof(DRIVER_INFO_3W, pHelpFile),
                            offsetof(DRIVER_INFO_3W, pMonitorName),
                            offsetof(DRIVER_INFO_3W, pDefaultDataType),
                            0xFFFFFFFF};


DWORD FormInfo1Offsets[] = {    offsetof(FORM_INFO_1W, pName),
                                0xFFFFFFFF};


DWORD PrinterInfo1Offsets[]={offsetof(PRINTER_INFO_1W, pDescription),
                             offsetof(PRINTER_INFO_1W, pName),
                             offsetof(PRINTER_INFO_1W, pComment),
                             0xFFFFFFFF};

DWORD PrinterInfo2Offsets[]={offsetof(PRINTER_INFO_2W, pServerName),
                             offsetof(PRINTER_INFO_2W, pPrinterName),
                             offsetof(PRINTER_INFO_2W, pShareName),
                             offsetof(PRINTER_INFO_2W, pPortName),
                             offsetof(PRINTER_INFO_2W, pDriverName),
                             offsetof(PRINTER_INFO_2W, pComment),
                             offsetof(PRINTER_INFO_2W, pLocation),
                             offsetof(PRINTER_INFO_2W, pDevMode),
                             offsetof(PRINTER_INFO_2W, pSepFile),
                             offsetof(PRINTER_INFO_2W, pPrintProcessor),
                             offsetof(PRINTER_INFO_2W, pDatatype),
                             offsetof(PRINTER_INFO_2W, pParameters),
                             offsetof(PRINTER_INFO_2W, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo3Offsets[]={offsetof(PRINTER_INFO_3, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo4Offsets[]={offsetof(PRINTER_INFO_4W, pPrinterName),
                             offsetof(PRINTER_INFO_4W, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo5Offsets[]={offsetof(PRINTER_INFO_5W, pPrinterName),
                             offsetof(PRINTER_INFO_5W, pPortName),
                             0xFFFFFFFF};






/*********************************Class************************************\
* SPOOLMSG
*
*   structure containg a message waiting to be grabbed by a spooler thread.
*   This is a private structure to communicate between the applications thread
*   and the spoolers thread
*
* History:
*  27-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

#define SPOOLMSG_DELETE_INBUF   0x00000002
#define SPOOLMSG_MAXINPUT_BUF   4
#define NO_CLIENT               1
#define NON_SPOOL_INSTANCE      ((DWORD) -1)
#define MIN_DEVMODE_SIZE        72      // Win 3.1 DevMode size.  Also hard-coded in yspool

typedef struct _SPOOLMSG
{
    ULONG     cj;
    ULONG     iMsg;
    ULONG     fl;

    HSPOOLOBJ hso;
    PETHREAD  pthreadClient;
    SECURITY_CLIENT_CONTEXT sccSecurity;

    // in order to avoid extra copying into a single buffer, there are multiple
    // input buffers.  For example, WritePrinter uses a header buffer on the
    // stack with a second buffer containing the output data.

    ULONG     cjIn;                         // combined size of input buffers
    ULONG     cBuf;                         // number of input buffers
    PULONG    apulIn[SPOOLMSG_MAXINPUT_BUF];// input buffers
    ULONG     acjIn[SPOOLMSG_MAXINPUT_BUF];

    PULONG    pulOut;       // location to put output data
    ULONG     cjOut;        // size of output

    ULONG     ulRet;        // return value
    ULONG     ulErr;        // transfer last error from spooler thread to client

    struct _SPOOLMSG *pNext;

} SPOOLMSG, *PSPOOLMSG;


/*********************************Class************************************\
* SPOOLOBJ : public OBJECT
*
* a SPOOLOBJ is GDI's internal spooler object containing data need to access
* the spooler for a particular print job.
*
* Public Interface:
*
* History:
*  21-Jun-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

class SPOOLOBJ : public OBJECT
{
public:

    KEVENT  *pkevent;
    HANDLE  hSpool;
    PVOID   pvMsg;
    SPOOLMSG sm;
    DWORD   dwFlags;
    DWORD   dwSpoolInstance;
    GREWRITEPRINTER WritePrinter;
    DWORD   dwWritePrinterReturn;
};
typedef SPOOLOBJ *PSPOOLOBJ;


/**************************************************************************\
 *
\**************************************************************************/

BOOL        gbInitSpool = FALSE;        // set/cleared as the spooler comes and goes
PW32PROCESS gpidSpool = 0;              // process ID of the spooler
PEPROCESS   gpeSpool = 0;               // process pointer of the spooler

PKEVENT     gpeventGdiSpool;            // spooler lock
PKEVENT     gpeventSpoolerTermination;  // signals spooler termination so client threads in spooler process can exit

DWORD       gdwSpoolInstance = 0;     // Keeps track of the spooler instance

LONG        gpInfiniteWait = TRUE;      // LONG used to ensure we have one spooler thread waiting with INFINITE timeoue

// there is a queue of spool messages.  Elements are removed from the head
// and added to the tail

PSPOOLMSG gpsmSpoolHead     = NULL;
PSPOOLMSG gpsmSpoolTail     = NULL;

int       gcSpoolMsg        = 0;
int       gcSpoolMsgCurrent = 0;
int       gcSpoolMsgMax     = 0;


#define LOCKSPOOLER   GreAcquireSemaphore(ghsemGdiSpool)
#define UNLOCKSPOOLER GreReleaseSemaphore(ghsemGdiSpool)

#define POFFSET(pBase,pCur) ((PBYTE)(pCur) - (PBYTE)(pBase))


/*********************************Class************************************\
* class SPOOLREF
*
* Public Interface:
*
* History:
*  22-May-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

class SPOOLREF
{
public:

    PSPOOLOBJ pso;

    SPOOLREF()                  {}
    SPOOLREF(HANDLE hspool)
    {
        pso = (PSPOOLOBJ)HmgLock((HOBJ)hspool,SPOOL_TYPE);
    }


   ~SPOOLREF()
    {
        if (bValid())
        {
            DEC_EXCLUSIVE_REF_CNT(pso);
            pso = NULL;
        }
    }

    BOOL bDelete();
    BOOL GreEscapeSpool();

    BOOL bValid()               {return(pso != NULL); }
    HSPOOLOBJ hGet()            {return((HSPOOLOBJ)pso->hGet());}
    PSPOOLMSG psm()             {return(&pso->sm);          }

    // we need to know the lock count for cleanup so we don't free up a message
    // when it still may be accessed.

    ULONG cAltLock()
    {
        return(((POBJ) (pso))->ulShareCount);
    }
};


class SPOOLALTREF : public SPOOLREF
{
public:

    SPOOLALTREF(HANDLE hspool)
    {
        pso = (PSPOOLOBJ)HmgShareLock((HOBJ)hspool,SPOOL_TYPE);
    }

   ~SPOOLALTREF()
    {
        if (bValid())
        {
            DEC_SHARE_REF_CNT(pso);
            pso = NULL;
        }
    }
};

typedef SPOOLALTREF *PSPOOLALTREF;



class SPOOLMEMOBJ : public SPOOLREF
{
public:

    SPOOLMEMOBJ();
   ~SPOOLMEMOBJ()   {}
};


ULONG
ulFinishMessage(
    PSPOOLMSG psm,
    PSPOOLESC psesc,
    PSPOOLALTREF sr,
    PBYTE pjEscData,
    ULONG cjEscData
    );

BOOL AddMessage2Q(
    PSPOOLMSG psm,
    DWORD     dwSpoolInstance
    );

VOID SubtractMessageFromQ(PSPOOLMSG psmIn);


/******************************Public*Routine******************************\
*
*
* History:
*  22-May-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

SPOOLMEMOBJ::SPOOLMEMOBJ()
{
    KEVENT *pkevent = (PKEVENT) GdiAllocPoolNonPagedNS(
                                                      sizeof(KEVENT), 'lpsG');

    if (pkevent == NULL)
    {
        pso = NULL;
    }
    else
    {
        pso = (PSPOOLOBJ)HmgAlloc(sizeof(SPOOLOBJ),SPOOL_TYPE, HMGR_ALLOC_LOCK);

        if (bValid())
        {

LOCKSPOOLER;
            pso->dwSpoolInstance = gdwSpoolInstance;
UNLOCKSPOOLER;

            pso->pkevent = pkevent;

            KeInitializeEvent(
                            pso->pkevent,
                            SynchronizationEvent,
                            FALSE);
        }
        else
        {
            VFREEMEM(pkevent);
        }
    }
}

/******************************Public*Routine******************************\
*
*
* History:
*  22-May-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL SPOOLREF::bDelete()
{
    if (bValid())
    {
        VFREEMEM(pso->pkevent);

        HmgFree((HOBJ)hGet());

        pso = NULL;
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* bIsProcessLocalSystem()
*
* History:
*  19-Jun-2001 -by-  Barton House [bhouse]
* Wrote it.
\**************************************************************************/

static BOOL bIsProcessLocalSystem(void)
{
    BOOL                        bResult = FALSE;
    PEPROCESS                   peprocess;
    PACCESS_TOKEN               paccessToken;
    NTSTATUS                    status;
    PTOKEN_USER                 ptu;

    peprocess = PsGetCurrentProcess();

    paccessToken = PsReferencePrimaryToken(peprocess);

    status = SeQueryInformationToken(paccessToken, TokenUser, (PVOID *) &ptu);

    PsDereferencePrimaryToken(paccessToken);

    if (NT_SUCCESS(status) == TRUE)
    {
        bResult = RtlEqualSid(SeExports->SeLocalSystemSid, ptu->User.Sid);
        ExFreePool(ptu);
    }

    return bResult;
}

/******************************Public*Routine******************************\
* GreInitSpool()
*
* History:
*  21-Feb-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL NtGdiInitSpool()
{
    BOOL bRet = FALSE;

    LOCKSPOOLER;

    if (gbInitSpool)
    {
        EngSetLastError(ERROR_INVALID_ACCESS);
        WARNING("GreInitSpool - already called\n");
    }
    else if(!bIsProcessLocalSystem())
    {
        EngSetLastError(ERROR_INVALID_ACCESS);
        WARNING("GreInitSpool - caller is not system\n");
    }
    else
    {
        NTSTATUS status;

        // intialize the spooler events

        gpeventGdiSpool = (PKEVENT) GdiAllocPoolNonPagedNS(
                                       sizeof(KEVENT), 'gdis');

        gpeventSpoolerTermination = (PKEVENT) GdiAllocPoolNonPagedNS(
                                       sizeof(KEVENT), 'gdis');

        if (gpeventGdiSpool && gpeventSpoolerTermination)
        {
            KeInitializeEvent(
                        gpeventGdiSpool,
                        SynchronizationEvent,
                        FALSE);

            KeInitializeEvent(
                        gpeventSpoolerTermination,
                        NotificationEvent,
                        FALSE);

            gbInitSpool = TRUE;
            bRet = TRUE;
            gpeSpool = PsGetCurrentProcess();

        }
        else
        {
            EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);

            if (gpeventGdiSpool)
            {
                VFREEMEM(gpeventGdiSpool);
                gpeventGdiSpool = NULL;
            }

            if (gpeventSpoolerTermination)
            {
                VFREEMEM(gpeventSpoolerTermination);
                gpeventSpoolerTermination = NULL;
            }
        }

        gpidSpool = W32GetCurrentProcess();

        if (++gdwSpoolInstance == NON_SPOOL_INSTANCE)
            ++gdwSpoolInstance;
    }

    UNLOCKSPOOLER;

    return(bRet);
}

/******************************Public*Routine******************************\
*
*
* History:
*  01-Jun-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vCleanupSpool()
{
    if (gpidSpool == W32GetCurrentProcess())
    {
        //DbgPrint("vCleanupSpool() - cleaning up the spooler process\n");

        LOCKSPOOLER;

        if (gbInitSpool == TRUE)
        {

            while (gpsmSpoolHead != NULL)
            {
                //DbgPrint("vCleanupSpool() - got another\n");

                PSPOOLMSG psm = gpsmSpoolHead;

                gpsmSpoolHead = psm->pNext;

                // and some stats

                ASSERTGDI(gcSpoolMsgCurrent > 0, "GreGetSpoolMsg - invalid count\n");
                gcSpoolMsgCurrent--;

                SPOOLALTREF sr(psm->hso);

                if (sr.bValid())
                {
                    KeSetEvent(sr.pso->pkevent,0,FALSE);
                }
            }

            gpsmSpoolTail = NULL;


            VFREEMEM(gpeventGdiSpool);
            VFREEMEM(gpeventSpoolerTermination);

            gpeventGdiSpool = NULL;
            gpeventSpoolerTermination = NULL;
            gbInitSpool = FALSE;
            gpeSpool = NULL;

            gcSpoolMsg = 0;
            gcSpoolMsgCurrent = 0;
            gcSpoolMsgMax = 0;

            gpidSpool = NULL;

            //DbgPrint("Done cleaning up spooler for this thread\n");
        }

        UNLOCKSPOOLER;
    }
}

/******************************Public*Routine******************************\
* GreGetSpoolMessage()
*
* This is intended to be called from the spooler process (GdiGetSpoolMessage)
* to get the next spooler message out of the kernel.
*
*
*   if (output buffer exists)
*       copy out output buffer
*
*   wait for next message
*
*   copy in input buffer
*
* input:
*
*   psesc  - buffer to place message
*   cjmsg  - size of message buffer
*   pulOut - buffer containing data to be copied to output buffer
*   cjOut  - size of output buffer
*
*
* returns:
*
*   size of data placed in psesc.
*
*
* Note: the output buffer is filled by the calling routine before calling
*       this function again.
*
* History:
*  21-Feb-1995 -by-  Eric Kutter [erick]
*
*  6-Aug-1995 - Added Input buffer growing (Steve Wilson [swilson])
*
* Wrote it.
\**************************************************************************/

SECURITY_QUALITY_OF_SERVICE Sqos =
{
    sizeof(SECURITY_QUALITY_OF_SERVICE),
    SecurityImpersonation,
    SECURITY_DYNAMIC_TRACKING,
    FALSE
};

ULONG GreGetSpoolMessage(
    PSPOOLESC psesc,
    PBYTE     pjEscData,    // this must only be accessed under a try/except
    ULONG     cjEscData,
    PULONG    pulOut,
    ULONG     cjOut
    )
{
    ULONG     ulRet = 0;
    NTSTATUS status;
    LONG lState;

    //DbgPrint("Entered GreGetSpoolMessage\n");

    if (!gbInitSpool)
    {
        WARNING("GreGetSpoolMessage - not initialized\n");
    }
    else if (gpidSpool != W32GetCurrentProcess())
    {
        WARNING("GreGetSpoolMessage - called from non-spooler process\n");
    }
    else
    {
        KEVENT *pkevent = NULL;

        // see if we need to copy any data out

        if (psesc->hso)
        {
            SPOOLALTREF sr(psesc->hso);

            if (sr.bValid())
            {

                // we have found the spool obj.  Now see if we really have
                // an output buffer and need to copy anything.

                PSPOOLMSG psm = (PSPOOLMSG)sr.pso->pvMsg;

                // if we asked the spooler to grow the buffer and it succeeded
                // finish copying the message and return.  If it failed, we still
                // need to cleanup this message and release the thread.

                if (psesc->iMsg == GDISPOOL_INPUT2SMALL)
                {
                    if (psesc->ulRet && psm)
                    {
                        return(ulFinishMessage(psm, psesc,  &sr, pjEscData, cjEscData));
                    }

                    pulOut       = NULL;
                    psesc->ulRet = 0;
                }

                // if we actualy have a message, we need to copy out the data
                // if there is any and remember the event in order to let the
                // client continue.

                if (psm)
                {
                    // if we are still impersonating the client, undo it

                    if (psm->pthreadClient)
                    {
                        SeStopImpersonatingClient();
                        SeDeleteClientSecurity(&psm->sccSecurity);
                        psm->pthreadClient = NULL;
                    }

                    // see if we have anything to copy out

                    if (pulOut && psm->pulOut)
                    {
                        if (cjOut > psm->cjOut)
                            cjOut = psm->cjOut;

                        __try
                        {
                            // this is the only place that pulOut is validated

                            ProbeForRead(pulOut,cjOut,sizeof(ULONG));

                            RtlCopyMemory(psm->pulOut,pulOut,cjOut);

                            psm->cjOut = cjOut;
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            psm->cjOut = 0;
                        }
                    }
                    else
                    {
                        psm->cjOut = 0;
                    }

                    psm->ulRet = psesc->ulRet;
                    psm->ulErr = EngGetLastError();

                    // Since to have output the message must have been synchronous,
                    // we need to let the other thread go now.

                    pkevent = sr.pso->pkevent;
                }


                // the spool obj is now done with this message

                sr.pso->pvMsg = NULL;
            }
            else
            {
                WARNING("GreGetSpoolMessage - hso but no pso\n");
            }
        }

        // the release of the other thread needs to be done once the SPOOLOBJ has
        // been unlocked.

        if (pkevent)
        {
            lState = KeSetEvent(pkevent,0,FALSE);

            ASSERTGDI(lState == 0,"GreGetSpoolMessage - lState not 0, a\n");
        }

        // done with the last message.  Wait for the next message.

        PSPOOLMSG psm = NULL;
        BOOL bDone;
        LARGE_INTEGER Timeout;

        // 600/(100*10(-9)) : negative value is interval, positive is absolute
        Timeout.QuadPart = (LONGLONG) -6000000000;    // Timeout is in 100 nsec, so 6,000,000,000 == 10 min

        do
        {
            BOOL bGrabIt = TRUE;
            bDone = TRUE;

            if (gpsmSpoolHead == NULL)
            {
                LONG    bInfiniteWait = InterlockedExchange(&gpInfiniteWait, FALSE);

                //DbgPrint("\nGDISPOOL(%lx): waiting for message\n",psesc);
                status = KeWaitForSingleObject(
                                gpeventGdiSpool,
                                (KWAIT_REASON)WrExecutive,
                                UserMode,
                                FALSE,
                                (bInfiniteWait ? NULL : &Timeout));

                if(bInfiniteWait)
                    InterlockedExchange(&gpInfiniteWait, TRUE);

                if (status == STATUS_TIMEOUT)
                {
                    SendSimpleMessage(0, GDISPOOL_TERMINATETHREAD, NON_SPOOL_INSTANCE);
                }
                else if (status == STATUS_USER_APC)   // Upon this return, User mode spooler does not execute
                {
                    KeSetEvent(gpeventSpoolerTermination,0,FALSE);
                    return (ULONG) -1;
                }
                else if (!NT_SUCCESS(status))
                {
                    WARNING("GDISPOOL: wait error\n");
                    bGrabIt = FALSE;
                }
            }
            else
            {
                //DbgPrint("\nGDISPOOL(%lx): message already there\n",psesc);
            }

            if (bGrabIt)
            {
                // now find the message and the spoolobj

                LOCKSPOOLER;

                if (gpsmSpoolHead == NULL)
                {
                    bDone = FALSE;
                }
                else
                {
                    psm = gpsmSpoolHead;
                    gpsmSpoolHead = psm->pNext;

                    if (gpsmSpoolHead == NULL)
                        gpsmSpoolTail = NULL;

                    // and some stats

                    ASSERTGDI(gcSpoolMsgCurrent > 0, "GreGetSpoolMsg - invalid count\n");
                    gcSpoolMsgCurrent--;
                    //DbgPrint("    got a message(%lx), hso = %lx - count = %ld\n",psesc,psm->hso,gcSpoolMsgCurrent);
                }

                UNLOCKSPOOLER;
            }

        } while ((psm == NULL) && !bDone);

        // did we get a message?

        if (psm != NULL)
        {
            if (psm->iMsg == GDISPOOL_TERMINATETHREAD || psm->iMsg == GDISPOOL_CLOSEPRINTER)
            {
                // going to terminate the thread so just get out.

                ulRet         = sizeof(SPOOLESC);
                psesc->cj     = sizeof(SPOOLESC);
                psesc->iMsg   = psm->iMsg;
                psesc->hso    = psm->hso;

                if (psm->iMsg & GDISPOOL_API)    // Let API messages have a spool handle
                {
                    psesc->hSpool = psm->hso;

                    if (psm->iMsg & GDISPOOL_CLOSEPRINTER)
                    {
                        psesc->hso = NULL;
                    }
                }

                psesc->cjOut  = 0;
                VFREEMEM(psm);
            }
            else  // Got a non-null, non-TERMINATETHREAD message to send to spooler
            {
                SPOOLALTREF sr(psm->hso);

                if (sr.bValid())
                {
                    if (cjEscData < psm->cjIn)
                    {
                        // set up the header

                        ulRet = offsetof(SPOOLESC, ajData);

                        psesc->cj     = sizeof(SPOOLESC);
                        psesc->iMsg   = GDISPOOL_INPUT2SMALL;
                        psesc->hSpool = sr.pso->hSpool;
                        psesc->hso    = psm->hso;
                        sr.pso->pvMsg = (PVOID)psm;

                        // required message buffer size

                        psesc->cjOut  = psm->cjIn + offsetof(SPOOLESC,ajData);
                    }
                    else
                    {
                        ulRet = ulFinishMessage(psm, psesc, &sr, pjEscData, cjEscData);
                    }
                }
            }
        }
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* ulFinishMessage()
*
* Fills in psesc structure and impersonates client
*
*
* History:
*  8-Aug-95 -by-  Steve Wilson [swilson]
* Wrote it.
\**************************************************************************/

ULONG
ulFinishMessage(
    PSPOOLMSG    psm,
    PSPOOLESC    psesc,  // this must only be accessed under a try/except
    PSPOOLALTREF psr,
    PBYTE        pjEscData,
    ULONG        cjEscDAta
    )
{
    NTSTATUS status;
    ULONG    ulRet;

    // impersonate the client

    status = SeCreateClientSecurity(
                    psm->pthreadClient,
                    &Sqos,
                    FALSE,
                    &psm->sccSecurity);

    if (NT_SUCCESS(status))
    {
        status = SeImpersonateClientEx(&psm->sccSecurity,NULL);
    }

    if (!NT_SUCCESS(status))
    {
        WARNING("FinishMessage - CreateClientSecurity failed\n");
        psm->pthreadClient = NULL;
    }

    // copy the data

    ulRet = 0;

    if (psm->cjIn)
    {
        __try
        {
            // copy all the buffers into the input buffer

            ulRet = 0;

            for (DWORD i = 0; i < psm->cBuf; ++i)
            {
                RtlCopyMemory(pjEscData+ulRet,psm->apulIn[i],psm->acjIn[i]);
                ulRet     += psm->acjIn[i];
            }

            ASSERTGDI(ulRet == psm->cjIn,"ulFinishMessage - invalid size\n");
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            ulRet = 0;
        }
    }

    // if the input buffer was only temporary, delete it.

    if (psm->fl & SPOOLMSG_DELETE_INBUF)
    {
        ASSERTGDI(psm->cBuf == 1,"ulFinishMessage - delete more than 1\n");

        VFREEMEM(psm->apulIn[0]);
        psm->apulIn[0] = NULL;
    }

    // set up the header

    ulRet += offsetof(SPOOLESC,ajData);

    psesc->iMsg   = psm->iMsg;
    psesc->cj     = ulRet;
    psesc->hSpool = psr->pso->hSpool;
    psesc->cjOut  = psm->cjOut;

    psesc->hso    = psm->hso;
    psr->pso->pvMsg = (PVOID)psm;

    return(ulRet);
}

/******************************Public*Routine******************************\
* GreEscapeSpool()
*
* given a spool message, add it to the queue and notify the spooler thread
*
*
* History:
*  21-Feb-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL SPOOLREF::GreEscapeSpool()
{
    BOOL bRet = FALSE;
    NTSTATUS status;

    ASSERTGDI(psm()->iMsg != GDISPOOL_TERMINATETHREAD,"GreEscapeSpool - GDISPOOL_TERMINATETHREAD\n");
    ASSERTGDI(psm()->iMsg != GDISPOOL_CLOSEPRINTER,"GreEscapeSpool - GDISPOOL_CLOSEPRINTER\n");
    ASSERTGDI(psm() != NULL,"GreEscapeSpool - null\n");

    //DbgPrint("Entered GreEscapeSpool\n");

    if (!gbInitSpool)
    {
        EngSetLastError(ERROR_NOT_READY);
        WARNING("GreEscapeSpool - not initialized\n");
    }
    else if (pso->dwFlags & NO_CLIENT)
    {
        //DbgPrint(" GreEscapeSpool: NO_CLIENT, message received: %x\n",psm()->iMsg);
        EngSetLastError(ERROR_PROCESS_ABORTED);
    }
    else
    { // add the message to the queue

        //NOTE: we may want to reference count this in the future
        psm()->pthreadClient = PsGetCurrentThread();
        if (AddMessage2Q(psm(), pso->dwSpoolInstance))
        {

            PVOID  pEvent[3];

            pEvent[0] = gpeSpool;
            pEvent[1] = pso->pkevent;
            pEvent[2] = gpeventSpoolerTermination;

            status = KeWaitForMultipleObjects(  3,
                                                pEvent,
                                                WaitAny,
                                                (KWAIT_REASON)0,
                                                UserMode,
                                                FALSE,
                                                0,
                                                NULL);

            switch (status)
            {
                case 0:                 // Spooler terminated
                    SubtractMessageFromQ(psm());
                    EngSetLastError(ERROR_PROCESS_ABORTED);

                    ASSERTGDI(cAltLock() == 0,"GreEscapeSpool - invalid lock 0\n");
                    bRet = FALSE;
                    break;

                case 1:                 // Spooler returned
                    bRet = TRUE;
                    EngSetLastError(psm()->ulErr);

                    ASSERTGDI(cAltLock() == 0,"GreEscapeSpool - invalid lock 1\n");

                    break;

                case STATUS_USER_APC:   // Client terminated
                case 2:                 // Spooler terminated, this client may be the spooler

                    // Stress Failure Note:
                    // AddMessage2Q is called above here to add a message to the message queue.
                    // After the message is in the queue, we leave the spooler lock and set
                    // gpeventGdiSpool, which wakes up the spooler thread.  The spooler thread
                    // then grabs the message and removes it from the message queue inside the spooler
                    // lock.  It then returns to user mode and creates a new message thread.  All this
                    // typically works fine.
                    //
                    // Now suppose just after AddMessage2Q adds a new message and before gpeventGdiSpool
                    // is set, the spooler shuts down.  When the spooler shuts down, STATUS_USER_APC is
                    // returned from the gpeventGdiSpool Wait and all spooler messaging threads will set
                    // gpeventSpoolerTermination, which is case 2 in this switch statement.  This wakes
                    // up the client thread, which proceeds to terminate and frees the psm before exiting.
                    // Meanwhile, the spooler is down to its very last thread and calls vCleanupSpool, which
                    // traverses and frees the psm queue.  vCleanupSpool will AV when it hits one of the freed
                    // messages in the queue.
                    //
                    // The problem was rarely encountered because it would only occur if the spooler shut down
                    // after a message was entered in the queue and before the gpeventGdiSpool event was seen.
                    //
                    // Removing the message from the queue when the spooler or client terminates should solve
                    // the problem.  Note that this was always done for the STATUS_USER_APC case, and has now
                    // been added to case 0 and case 2.
                    //
                    // Steve Wilson (NT)
                    //
                    SubtractMessageFromQ(psm());

                    WARNING("Win32K spool: Client is dying!\n");

                    pso->dwFlags |= NO_CLIENT;
                    EngSetLastError(ERROR_PROCESS_ABORTED);
                    bRet = FALSE;

                    // we need to make sure there is no alt lock

                    pso->pvMsg = NULL;

                    while (cAltLock())
                        KeDelayExecutionThread(KernelMode,FALSE,gpLockShortDelay);

                    break;

                default:
#if 1
                    DbgPrint("GreEscapeSpool - WaitForSingleObject failed w/ status 0x%lx\n", status);
                    DbgBreakPoint();
#else
                    WARNING("GreEscapeSpool - WaitForSingleObject failed\n");
#endif
                    break;
            }
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* SendSimpleMessage()
*
*   allow a client app to send a spool message
*
*
* History:
*  21-Feb-1995 -by-  Eric Kutter [erick]
*  7-Jun-1996 - Steve Wilson [SWilson] - Changed from NtGdiSpoolEsc to SendSimpleMessage
*
\**************************************************************************/

ULONG SendSimpleMessage(
    HANDLE hSpool,
    ULONG iMsg,
    DWORD dwSpoolInstance)
{
    ULONG ulRet = 0;

    if (!gbInitSpool)
    {
        WARNING("GreEscapeSpool - not initialized\n");
    }
    else if (iMsg == GDISPOOL_TERMINATETHREAD || iMsg == GDISPOOL_CLOSEPRINTER)
    {
        PSPOOLMSG psm = (PSPOOLMSG) PALLOCMEM(sizeof(SPOOLMSG),'lpsG');

        if (psm)
        {
            psm->cj = sizeof(SPOOLMSG);
            psm->iMsg = iMsg;
            psm->hso = (HSPOOLOBJ) hSpool;              // This is Spooler's handle, not kernel handle

            ulRet = AddMessage2Q(psm, dwSpoolInstance);
            if (ulRet == FALSE)
                VFREEMEM(psm);
        }
    }

    return ulRet;
}


/*****************************
    SubtractMessageFromQ()
*****************************/

VOID SubtractMessageFromQ(PSPOOLMSG psmIn)
{
    PSPOOLMSG psm;
    PSPOOLMSG psmPrev = NULL;

    //DbgPrint("Enter SubtractMessageFromQ\n");

    LOCKSPOOLER;

    for (psm = gpsmSpoolHead ; psm ; psmPrev = psm , psm = psm->pNext)
    {
        if (psm == psmIn)
        {
            if (psmPrev)
            {
                psmPrev->pNext = psm->pNext;

                if (!psmPrev->pNext)
                {
                    ASSERTGDI(psm == gpsmSpoolTail,"SubtractMessageFromQ: Bad gpsmSpoolTail!\n");
                    gpsmSpoolTail = psmPrev;
                }
            }
            else
            {
                gpsmSpoolHead = psm->pNext;

                if (!gpsmSpoolHead)
                {
                    ASSERTGDI(psm == gpsmSpoolTail,"SubtractMessageFromQ: Bad gpsmSpoolTail!\n");
                    gpsmSpoolTail = gpsmSpoolHead;
                }
            }

            // gcSpool stuff is for debug purposes only
            gcSpoolMsgCurrent--;

            break;
        }
    }

    UNLOCKSPOOLER;
}


/******************************Public*Routine******************************\
* BOOL AddMessage2Q (PSPOOLMSG psm)
*
* History:
*  6-Aug-1995 -by-  Steve Wilson [swilson]
*
\**************************************************************************/

BOOL AddMessage2Q(PSPOOLMSG psm, DWORD dwSpoolInstance)
{
    BOOL bRet = FALSE;

    // add the message to the queue

    LOCKSPOOLER;

    if (psm == NULL)
    {
        bRet = FALSE;
    }
    else if ((dwSpoolInstance != gdwSpoolInstance) && (dwSpoolInstance != NON_SPOOL_INSTANCE))
    {
        EngSetLastError(ERROR_INVALID_HANDLE);
        bRet = FALSE;
    }
    else
    {
        if (gpsmSpoolTail)
        {
            // list isn't empty, so add it to the list

            ASSERTGDI(gpsmSpoolHead != NULL,"GreEscapeSpool - head is null\n");

            gpsmSpoolTail->pNext = psm;
        }
        else
        {
            ASSERTGDI(gpsmSpoolHead == NULL,"GreEscapeSpool - head not null\n");
            gpsmSpoolHead = psm;
        }

        // the tail now always points to the new element

        gpsmSpoolTail = psm;
        psm->pNext = NULL;

        // and some stats

        gcSpoolMsg++;
        gcSpoolMsgCurrent++;
        if (gcSpoolMsgCurrent > gcSpoolMsgMax)
            gcSpoolMsgMax = gcSpoolMsgCurrent;

        bRet = TRUE;
    }

    UNLOCKSPOOLER;

    // notify the spooler that there is a message ready
    if (bRet == TRUE)
    {
        KeSetEvent(gpeventGdiSpool,0,FALSE);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GreOpenPrinterW()
*
* History:
*  28-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
WINAPI
GreOpenPrinterW(
   GREOPENPRINTER *pOpenPrinter,
   LPHANDLE  phPrinter)
{
    ULONG bRet;
    ULONG ul;

    SPOOLMEMOBJ spmo;           // Creates (PSPOOLOBJ) spmo.pso, containing pkevent, hSpool, pvMsg

    //DbgPrint("Enter GreOpenPrinterW\n");

    if (spmo.bValid())
    {
        // setup the message

        PSPOOLMSG psm = spmo.psm();

        psm->cj       = sizeof(SPOOLMSG);
        psm->iMsg     = GDISPOOL_OPENPRINTER;
        psm->fl       = 0;
        psm->cBuf     = 1;
        psm->cjIn     = pOpenPrinter->cj;
        psm->acjIn[0] = pOpenPrinter->cj;
        psm->apulIn[0]= (PULONG)pOpenPrinter;
        psm->pulOut   = (PULONG)&spmo.pso->hSpool;

        psm->cjOut    = sizeof(*phPrinter);

        psm->hso      = spmo.hGet();            // returns ((HSPOOLOBJ) pso)

        if (spmo.GreEscapeSpool() && psm->ulRet)
        {
            *phPrinter = (HANDLE)spmo.hGet();

            bRet = TRUE;
        }
        else
        {
            spmo.bDelete();
            bRet = FALSE;
        }
    }
    else
    {
       bRet = FALSE;
    }

    return(bRet);
}


/*****************************************************************************
*  GreEnumFormsW
*
*  History:
*   25/7/95 by Steve Wilson [swilson]
*  Wrote it.
*******************************************************************************/

BOOL
WINAPI
GreEnumFormsW(
   HANDLE hSpool,
   GREENUMFORMS *pEnumForms,
   GREENUMFORMS *pEnumFormsReturn,
   LONG cjOut )
{
    ULONG bRet = FALSE;
    SPOOLREF sr(hSpool);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();

        //DbgPrint("Enter GreEnumFormsW\n");

        // setup the message

        psm->cj       = sizeof(SPOOLMSG);
        psm->iMsg     = GDISPOOL_ENUMFORMS;
        psm->fl       = 0;
        psm->cBuf     = 1;
        psm->cjIn     = pEnumForms->cj;
        psm->acjIn[0] = pEnumForms->cj;
        psm->apulIn[0]= (PULONG) pEnumForms;
        psm->pulOut   = (PULONG) pEnumFormsReturn;
        psm->cjOut    = cjOut;
        psm->hso      = (HSPOOLOBJ) hSpool;

        bRet = sr.GreEscapeSpool() ? psm->ulRet : FALSE;
    }

    return bRet;
}

/*****************************************************************************
*  GreGenericW
*
*  History:
*   25-Jul-95 by Steve Wilson [swilson]
*  Wrote it.
*******************************************************************************/

BOOL
GreGenericW(
    HANDLE hSpool,
    PULONG pX,
    PULONG pXReturn,
    LONG   cjOut,
    LONG   MessageID,
    ULONG  ulFlag )
{
    ULONG bRet = FALSE;
    SPOOLREF sr(hSpool);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();

        //DbgPrint("Enter GreGenericW\n");

        // setup the message

        psm->cj       = sizeof(SPOOLMSG);
        psm->iMsg     = MessageID;
        psm->fl       = ulFlag;
        psm->cBuf     = 1;
        psm->cjIn     = pX ? *(PULONG) pX : 0;    // Must be sure first element of pX is LONG cj: (pX->cj)
        psm->acjIn[0] = pX ? *(PULONG) pX : 0;    // Must be sure first element of pX is LONG cj: (pX->cj)
        psm->apulIn[0]= (PULONG) pX;
        psm->pulOut   = (PULONG) pXReturn;
        psm->cjOut    = cjOut;
        psm->hso      = (HSPOOLOBJ) hSpool;

        bRet = sr.GreEscapeSpool() ? psm->ulRet : FALSE;
    }

    return bRet;
}

/*****************************************************************************\
*  GrePrinterDriverUnloadW
*
*  This function is used to a send a message to the spooler when a printer
*  driver is unloaded (i.e the DC count on the driver goes to zero)
*  On receipt of this message, the spooler attempts to upgrade the driver if
*  neccesary.
*
*  History:
*   11/17/97 by Ramanathan N Venkatapathy
*  Wrote it.
\*****************************************************************************/

BOOL GrePrinterDriverUnloadW(
    LPWSTR  pDriverName
    )
{
    BOOL      bRet = FALSE;
    ULONG     cbDriverName;
    LPWSTR    pDriverFile = NULL;

    SPOOLMEMOBJ spmo;

    // Check for invalid printer driver names.
    if (!pDriverName || !*pDriverName)
    {
        return bRet;
    }

    // Copy the driver name into another buffer.
    cbDriverName = (wcslen(pDriverName) + 1) * sizeof(WCHAR);
    pDriverFile  = (LPWSTR) PALLOCMEM(cbDriverName, 'lpsG');

    if (spmo.bValid() && pDriverFile)
    {
        PSPOOLMSG psm = spmo.psm();

        memcpy(pDriverFile, pDriverName, cbDriverName);

        psm->cj        = sizeof(SPOOLMSG);
        psm->iMsg      = GDISPOOL_UNLOADDRIVER_COMPLETE;
        psm->fl        = 0;

        psm->cBuf      = 1;
        psm->cjIn      = cbDriverName;
        psm->apulIn[0] = (PULONG) pDriverFile;
        psm->acjIn[0]  = cbDriverName;

        psm->pulOut    = NULL;
        psm->cjOut     = 0;

        psm->hso       = spmo.hGet();

        bRet           = spmo.GreEscapeSpool() && psm->ulRet;

        spmo.bDelete();
    }

    if (pDriverFile) {
        VFREEMEM(pDriverFile);
    }

    return bRet;
}

/*****************************************************************************
*  GreGetPrinterDriverW
*
*  History:
*   4/14/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*******************************************************************************/

BOOL WINAPI GreGetPrinterDriverW(
   HANDLE hSpool,
   GREGETPRINTERDRIVER *pGetPrinterDriver,
   GREGETPRINTERDRIVER *pGetPrinterDriverReturn,
   LONG cjOut
   )
{
    ULONG bRet = FALSE;
    SPOOLREF sr(hSpool);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();

        //DbgPrint("Enter GreGetPrinterDriverW\n");

        // setup the message

        psm->cj       = sizeof(SPOOLMSG);
        psm->iMsg     = GDISPOOL_GETPRINTERDRIVER;
        psm->fl       = 0;
        psm->cBuf     = 1;
        psm->cjIn     = pGetPrinterDriver->cj;
        psm->acjIn[0] = pGetPrinterDriver->cj;
        psm->apulIn[0]= (PULONG) pGetPrinterDriver;
        psm->pulOut   = (PULONG)pGetPrinterDriverReturn;
        psm->cjOut    = cjOut;
        psm->hso      = (HSPOOLOBJ)hSpool;

        if( sr.GreEscapeSpool() )
        {
            bRet = psm->ulRet;
        }
        else
        {
            bRet = FALSE;
        }
    }

    return(bRet);
}

/****************************************************************************
*  BOOL StartPagePrinter( HANDLE hPrinter )
*
*  History:
*   4/28/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

BOOL
WINAPI
StartPagePrinter(
    HANDLE hSpool
    )
{
    BOOL bRet = FALSE;
    SPOOLREF sr(hSpool);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();

        //DbgPrint("Enter StartPagePrinter\n");

        psm->cj      = sizeof(SPOOLMSG);
        psm->iMsg    = GDISPOOL_STARTPAGEPRINTER;
        psm->fl      = 0;
        psm->cBuf    = 0;
        psm->cjIn    = 0;
        psm->pulOut  = NULL;
        psm->cjOut   = 0;
        psm->hso     = (HSPOOLOBJ)hSpool;

        if( sr.GreEscapeSpool() )
        {
            bRet = psm->ulRet;
        }
    }

    return(bRet);
}


/****************************************************************************
*  BOOL EndPagePrinter( HANDLE hPrinter )
*
*  History:
*   4/28/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

BOOL
WINAPI
EndPagePrinter(
    HANDLE hSpool
    )
{
    BOOL bRet = FALSE;
    SPOOLREF sr(hSpool);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();

        //DbgPrint("Enter EndPagePrinter\n");

        psm->cj      = sizeof(SPOOLMSG);
        psm->iMsg    = GDISPOOL_ENDPAGEPRINTER;
        psm->fl      = 0;
        psm->cBuf    = 0;
        psm->cjIn    = 0;
        psm->pulOut  = NULL;
        psm->cjOut   = 0;
        psm->hso     = (HSPOOLOBJ)hSpool;

        if(sr.GreEscapeSpool())
        {
            bRet = psm->ulRet;
        }
    }

    return(bRet);

}


/****************************************************************************
*  BOOL EndDocPrinter( HANDLE hPrinter )
*
*  History:
*   4/28/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

BOOL
WINAPI
EndDocPrinter(
    HANDLE hSpool
    )
{
    BOOL bRet = FALSE;
    SPOOLREF sr(hSpool);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();


        //DbgPrint("Enter EndDocPrinter\n");

        psm->cj      = sizeof(SPOOLMSG);
        psm->iMsg    = GDISPOOL_ENDDOCPRINTER;
        psm->fl      = 0;
        psm->cBuf    = 0;
        psm->cjIn    = 0;
        psm->pulOut  = NULL;
        psm->cjOut   = 0;
        psm->hso     = (HSPOOLOBJ)hSpool;

        if( sr.GreEscapeSpool() )
        {
            bRet = (DWORD) psm->ulRet;
        }
    }

    return(bRet);

}


/****************************************************************************
*  ClosePrinter( HANDLE hPrinter )
*
*  History:
*   12-Feb-1996 -by- Steve Wilson (swilson)
*  Wrote it.
*****************************************************************************/

BOOL
WINAPI
ClosePrinter(
    HANDLE hSpool
    )
{
    SPOOLREF sr(hSpool);

    if (sr.bValid())
    {
        //DbgPrint("Enter ClosePrinter: %d\n", sr.pso->hSpool);

        SendSimpleMessage(sr.pso->hSpool, GDISPOOL_CLOSEPRINTER, sr.pso->dwSpoolInstance);

        sr.bDelete();
    }

    return TRUE;
}


/******************************Public*Routine******************************\
* AbortPrinter()
*
* History:
*  18-Jul-1995 -by-  Steve Wilson (swilson)
* Wrote it.
\**************************************************************************/

BOOL
WINAPI
AbortPrinter(
    HANDLE   hPrinter)
{
    BOOL bRet = FALSE;
    SPOOLREF sr(hPrinter);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();


        //DbgPrint("Enter AbortPrinter\n");

        psm->cj      = sizeof(SPOOLMSG);
        psm->iMsg    = GDISPOOL_ABORTPRINTER;
        psm->fl      = 0;
        psm->cBuf    = 0;
        psm->cjIn    = 0;
        psm->pulOut  = NULL;
        psm->cjOut   = 0;
        psm->hso     = (HSPOOLOBJ)hPrinter;

        if( sr.GreEscapeSpool() )
        {
            bRet = (DWORD) psm->ulRet;
        }
    }

    return(bRet);
}



/****************************************************************************
* StartDocPrinter()
*
*  History:
*   4/28/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

DWORD
WINAPI
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  lpbDocInfo
   )
{
    LONG cj = offsetof(GRESTARTDOCPRINTER,alData);
    LONG cjDocName = 0;
    LONG cjOutputFile = 0;
    LONG cjDatatype = 0;
    DOC_INFO_1W* pDocInfo = (DOC_INFO_1W*) lpbDocInfo;
    DWORD ret = 0;

    //DbgPrint("Enter StartDocPrinterW\n");

    ASSERTGDI( dwLevel == 1, "StartDocPrinter: dwLevel != 1\n" );
    ASSERTGDI( lpbDocInfo != NULL, "StarDocPrinter lpbDocInfo is NULL\n");

    // first we need to compute the sizes.

    if (pDocInfo->pDocName)
    {
        cjDocName = (wcslen(pDocInfo->pDocName) + 1) * sizeof(WCHAR);

        cj += cjDocName;
        cj = (cj + 3) & ~3;
    }

    if (pDocInfo->pOutputFile)
    {
        cjOutputFile = (wcslen(pDocInfo->pOutputFile) + 1) * sizeof(WCHAR);

        cj += cjOutputFile;
        cj = (cj + 3) & ~3;
    }

    if (pDocInfo->pDatatype)
    {
        cjDatatype = (wcslen(pDocInfo->pDatatype) + 1) * sizeof(WCHAR);

        cj += cjDatatype;
        cj = (cj + 3) & ~3;
    }


    SPOOLREF sr(hPrinter);

    if (sr.bValid())
    {
        PLONG plData;

        GRESTARTDOCPRINTER *pStartDocPrinter;
        pStartDocPrinter = (GRESTARTDOCPRINTER*)PALLOCNOZ(cj,'lpsG');

        if (pStartDocPrinter)
        {
            PSPOOLMSG psm = sr.psm();

            // we got memory, now copy the stuff in

            pStartDocPrinter->cj = cj;
            plData = pStartDocPrinter->alData;

            pStartDocPrinter->cjDocName  = (cjDocName     + 3) & ~3;
            pStartDocPrinter->cjOutputFile = (cjOutputFile + 3) & ~3;
            pStartDocPrinter->cjDatatype  = (cjDatatype  + 3) & ~3;

            if (pDocInfo->pDocName)
            {
                memcpy(plData,pDocInfo->pDocName,cjDocName);
                plData += (cjDocName+3)/4;
            }

            if (pDocInfo->pOutputFile)
            {
                memcpy(plData,pDocInfo->pOutputFile,cjOutputFile);
                plData += (cjOutputFile+3)/4;
            }

            if (pDocInfo->pDatatype)
            {
                memcpy(plData,pDocInfo->pDatatype,cjDatatype);
                plData += (cjDatatype+3)/4;
            }

            ASSERTGDI(POFFSET(pStartDocPrinter,plData) == cj,
                        "EngStartDocPrinter - sizes are wrong\n");

            // pStartDocPrinter now contains all needed data, call out
            // setup the message

            psm->cj       = sizeof(SPOOLMSG);
            psm->iMsg     = GDISPOOL_STARTDOCPRINTER;
            psm->fl       = 0;
            psm->cBuf     = 1;
            psm->cjIn     = pStartDocPrinter->cj;
            psm->acjIn[0] = pStartDocPrinter->cj;
            psm->apulIn[0]= (PULONG)pStartDocPrinter;
            psm->pulOut   = NULL;
            psm->cjOut    = 0;
            psm->hso      = (HSPOOLOBJ)hPrinter;

            if( sr.GreEscapeSpool() )
            {
                ret = (DWORD) psm->ulRet;
            }

            VFREEMEM(pStartDocPrinter);
        }
    }

    return(ret);

}



/******************************Public*Routine******************************\
* OpenPrinterW()
*
* History:
*  05-Apr-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
WINAPI
OpenPrinterW(
   LPWSTR    pPrinterName,
   LPHANDLE  phPrinter,
   LPPRINTER_DEFAULTSW pDefault)
{
    LONG cjName     = 0;
    LONG cjDatatype = 0;
    LONG cjDevMode  = 0;
    LONG cj         = offsetof(GREOPENPRINTER,alData);
    BOOL bRet       = FALSE;

    PLONG plData;

    GREOPENPRINTER  *pOpenPrinter;

    //DbgPrint("Enter OpenPrinterW\n");

    // first we need to compute the sizes.

    if (pPrinterName)
    {
        cjName = (wcslen(pPrinterName) + 1) * sizeof(WCHAR);

        cj += cjName;
        cj = (cj + 3) & ~3;
    }

    if (pDefault)
    {
        if (pDefault->pDatatype)
        {
            cjDatatype = (wcslen(pDefault->pDatatype) + 1) * sizeof(WCHAR);

            cj += cjDatatype;
            cj = (cj + 3) & ~3;
        }

        if (pDefault->pDevMode)
        {

            //DbgPrint("cjMinDevmode = %d, dmSize = %d, dmDriverExtra = %d\n", MIN_DEVMODE_SIZE, pDefault->pDevMode->dmSize, pDefault->pDevMode->dmDriverExtra);

            cjDevMode = pDefault->pDevMode->dmSize + pDefault->pDevMode->dmDriverExtra;

            if (cjDevMode < MIN_DEVMODE_SIZE)
            {
                EngSetLastError(ERROR_INVALID_PARAMETER);
                return bRet;
            }

            cj += cjDevMode;
            cj = (cj + 3) & ~3;
        }

    }

    // allocate the memory

    pOpenPrinter = (GREOPENPRINTER*)PALLOCNOZ(cj,'lpsG');

    if (pOpenPrinter)
    {
        // we got memory, now copy the stuff in

        pOpenPrinter->cj = cj;
        pOpenPrinter->pd = *pDefault;
        plData = pOpenPrinter->alData;

        pOpenPrinter->cjName     = (cjName     + 3) & ~3;
        pOpenPrinter->cjDatatype = (cjDatatype + 3) & ~3;
        pOpenPrinter->cjDevMode  = (cjDevMode  + 3) & ~3;

        if (pPrinterName)
        {
            memcpy(plData,pPrinterName,cjName);
            plData += (cjName+3)/4;
        }

        if (pDefault)
        {
            if (pDefault->pDatatype)
            {
                pOpenPrinter->pd.pDatatype = (WCHAR*)POFFSET(pOpenPrinter,plData);
                memcpy(plData,pDefault->pDatatype,cjDatatype);
                plData += (cjDatatype+3)/4;
            }

            if (pDefault->pDevMode)
            {
                pOpenPrinter->pd.pDevMode = (PDEVMODEW)POFFSET(pOpenPrinter,plData);
                memcpy(plData,pDefault->pDevMode,cjDevMode);
                plData += (cjDevMode+3)/4;
            }
        }

        ASSERTGDI(POFFSET(pOpenPrinter,plData) == cj,
                    "EngOpenPrinter - sizes are wrong\n");

        // pOpenPrinter now contains all needed data, call out

        bRet = GreOpenPrinterW(pOpenPrinter,phPrinter);


        VFREEMEM(pOpenPrinter);
    }

    return(bRet);
}

/*******************************************************************************
*  void MarshallUpStructure( LPBYTE  lpStructure, LPDWORD lpOffsets )
*
*  This routine does pointer adjustment to offsets within the buffer
*
*  History:
*   6/30/1995 by Muhunthan Sivapragasam (MuhuntS)
*  Got from spoolss code
*******************************************************************************/

void
MarshallUpStructure(
    LPBYTE  lpStructure,
    LPDWORD lpOffsets
    )
{
   register DWORD       i=0;

   while (lpOffsets[i] != -1) {

      if ((*(LPBYTE *)(lpStructure+lpOffsets[i]))) {
         (*(LPBYTE *)(lpStructure+lpOffsets[i]))+=(ULONG_PTR)lpStructure;
      }

      i++;
   }
}

/*******************************************************************************
*  BOOL ValidateString( LPWSTR pString, PBYTE pBuffer, LONG cjLength )
*
*  This routine validates a LPWSTR to make sure that it really lies inside of a buffer.
*
*  History:
*   4/19/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*******************************************************************************/

BOOL
ValidateString(
    LPWSTR pString,
    PBYTE pBuffer,
    LONG cjLength )
{
    LPWSTR pEnd = (LPWSTR) ( pBuffer + cjLength );

    if( pString > pEnd || pString < (LPWSTR) pBuffer )
    {
        return(FALSE);
    }

    while( pString < pEnd && *pString)
    {
        pString++;
    }

    return( pString < pEnd );

}

/*******************************************************************************
*  BOOL ValidateStrings( LPBYTE  lpStructure, LPDWORD lpOffsets, LONG cjLength )
*
*  This routine validates all the strings in the structure to make sure they really lie inside of a buffer.
*
*  History:
*   6/30/1995 by Muhunthan Sivapragasam (MuhuntS)
*  Wrote it.
*******************************************************************************/
BOOL
ValidateStrings(
    LPBYTE  lpStructure,
    LPDWORD lpOffsets,
    LONG    cjLength
    )
{
   register DWORD       i=0;

   while (lpOffsets[i] != -1)
   {

        if ( (*(LPWSTR *) (lpStructure+lpOffsets[i])) &&
             !ValidateString(*(LPWSTR *) (lpStructure+lpOffsets[i]),
                             lpStructure,
                             cjLength) )
        {
            return FALSE;
        }

      i++;
   }

   return TRUE;
}

/*******************************************************************************
*  BOOL ValidateDependentFiles( LPWSTR pString, PBYTE pBuffer, LONG cjLength )
*
*  This routine validates DependentFiles field (which is a list of strings
*  up to \0\0) to make sure that it really lies inside of a buffer.
*
*  History:
*   6/30/1995 by Muhunthan Sivapragasam
*  Wrote it.
*******************************************************************************/

BOOL
ValidateDependentFiles(
    LPWSTR pString,
    PBYTE pBuffer,
    LONG cjLength )
{
    LPWSTR pEnd = (LPWSTR) (pBuffer + cjLength) - 1; 

    if (pString < (LPWSTR) pBuffer)
    {
        return(FALSE);
    }  

    while (pString < pEnd)
    {
        if (*pString==0 && *(pString+1)==0) return TRUE;
        pString++;
    } 

    return (FALSE);
}

/*******************************************************************************
* EngEnumForms()
*
*  History:
*  7/24/1995 by Steve Wilson [swilson]
*  Wrote it.
*******************************************************************************/

BOOL
WINAPI
EngEnumForms(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  lpbForms,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned
)
{
    LONG cj;
    DWORD cjReturn;
    BOOL bRet = FALSE;
    GREENUMFORMS *pEnumForms, *pEnumFormsReturn;

    //DbgPrint("Enter EngEnumFormsW\n");

    if(!pcbNeeded || !pcbReturned)
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    cj = sizeof(GREENUMFORMS);

    // Allocate TO buffer
    pEnumForms = (GREENUMFORMS *) PALLOCMEM(cj, 'lpsG');

    // Marshall TO buffer
    if (pEnumForms) {

        pEnumForms->cj = cj;
        pEnumForms->cjData = cbBuf;
        pEnumForms->dwLevel = dwLevel;

        // Allocate RETURN buffer
        pEnumFormsReturn = (GREENUMFORMS *) PALLOCNOZ(cjReturn = sizeof(GREENUMFORMS) + cbBuf, 'lpsG');

        // SEND MESSAGE
        if (pEnumFormsReturn) {
            bRet = GreEnumFormsW(hPrinter, pEnumForms, pEnumFormsReturn, cjReturn);

            // Fill in return sizes
            *pcbNeeded = pEnumFormsReturn->cjData;          // # return data bytes
            *pcbReturned = pEnumFormsReturn->nForms;        // # forms in return data

            // UnMarshall Message
            if (bRet) {

                ASSERTGDI(*pcbNeeded <= cbBuf,"EnumFormsW - error\n");

                if (lpbForms && *pcbNeeded <= cbBuf) {
                    // Copy returned data into supplied FORM_INFO_1 structure
                    memcpy(lpbForms, pEnumFormsReturn->alData, pEnumFormsReturn->cjData);

                    DWORD   i;

                    for (i = 0 ; i < *pcbReturned ; ++i, lpbForms += sizeof(FORM_INFO_1W)) {
                        MarshallUpStructure(lpbForms, FormInfo1Offsets);
                    }
                }
            }
            VFREEMEM(pEnumFormsReturn);
        }
        VFREEMEM(pEnumForms);
    }
    return bRet;
}

/*******************************************************************************
* EngGetPrinter()
*
*  History:
*  9/30/1995 by Steve Wilson [swilson]
*  Wrote it.
*******************************************************************************/
BOOL
WINAPI
EngGetPrinter(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    LONG cj;
    DWORD cjReturn;
    BOOL bRet = FALSE;
    GREGETPRINTER *pGetPrinter, *pGetPrinterReturn;

    DWORD   *pOffsets;


    //DbgPrint("Enter EngGetPrinter\n");

    if (!pcbNeeded)
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    switch (dwLevel)
    {
        case 1:
            pOffsets = PrinterInfo1Offsets;
            break;

        case 2:
            pOffsets = PrinterInfo2Offsets;
            break;

        case 3:
            pOffsets = PrinterInfo3Offsets;
            break;

        case 4:
            pOffsets = PrinterInfo4Offsets;
            break;

        case 5:
            pOffsets = PrinterInfo5Offsets;
            break;

        default:
            EngSetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
    }


    cj = sizeof(GREGETPRINTER);

    // Allocate TO buffer
    pGetPrinter = (GREGETPRINTER *) PALLOCMEM(cj, 'lpsG');

    // Marshall TO buffer
    if (pGetPrinter)
    {

        pGetPrinter->cj = cj;
        pGetPrinter->cjData = cbBuf;
        pGetPrinter->dwLevel = dwLevel;

        // Allocate RETURN buffer
        pGetPrinterReturn = (GREGETPRINTER *) PALLOCNOZ(cjReturn = sizeof(GREGETPRINTER) + cbBuf, 'lpsG');

        // SEND MESSAGE
        if (pGetPrinterReturn)
        {
            bRet = GreGenericW(hPrinter, (PULONG) pGetPrinter, (PULONG) pGetPrinterReturn, cjReturn, GDISPOOL_GETPRINTER, 0);

            // Fill in return size
            *pcbNeeded = pGetPrinterReturn->cjData;

            // UnMarshall Message
            if (bRet)
            {
                ASSERTGDI(*pcbNeeded <= cbBuf,"EngGetPrinter - error\n");

                if (pPrinter && *pcbNeeded <= cbBuf)
                {
                    memcpy(pPrinter, pGetPrinterReturn->alData, pGetPrinterReturn->cjData);
                    MarshallUpStructure(pPrinter, pOffsets);
                }
            }
            VFREEMEM(pGetPrinterReturn);
        }
        VFREEMEM(pGetPrinter);
    }
    return bRet;
}

/*******************************************************************************
* EngGetForm()
*
*  History:
*  7/24/1995 by Steve Wilson [swilson]
*  Wrote it.
*******************************************************************************/

BOOL
WINAPI
EngGetForm(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   dwLevel,
    LPBYTE  lpbForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    LONG cj, cjFormName;
    DWORD cjReturn;
    BOOL bRet = FALSE;
    GREGETFORM    *pGetForm, *pGetFormReturn;

    //DbgPrint("Enter EngGetForm\n");

    if (!pcbNeeded)
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Accumulate sizes of base struct plus strings
    cj = sizeof(GREGETFORM);
    cj += (cjFormName = pFormName ? (wcslen(pFormName) + 1)*sizeof *pFormName : 0);

    // Allocate TO buffer
    pGetForm = (GREGETFORM *) PALLOCMEM(cj, 'lpsG');

    // Marshall TO buffer
    if (pGetForm)
    {
        pGetForm->cj = cj;
        pGetForm->cjData = cbBuf;
        pGetForm->dwLevel = dwLevel;

        if (pFormName)
        {
            memcpy(pGetForm->alData,pFormName,cjFormName);
        }

        // Allocate RETURN buffer
        pGetFormReturn = (GREGETFORM *) PALLOCNOZ(cjReturn = sizeof(GREGETFORM) + cbBuf, 'lpsG');

        // SEND MESSAGE
        if (pGetFormReturn)
        {
            bRet = GreGenericW(hPrinter, (PULONG) pGetForm, (PULONG) pGetFormReturn, cjReturn, GDISPOOL_GETFORM, 0);

            if (bRet)
            {

                // Fill in return sizes
                *pcbNeeded = pGetFormReturn->cjData;          // # return data bytes

                // UnMarshall Message
                if (lpbForm && bRet)
                {

                    if (*pcbNeeded <= cbBuf)
                        memcpy(lpbForm, pGetFormReturn->alData, pGetFormReturn->cjData);
                    else
                        ASSERTGDI(*pcbNeeded <= cbBuf,"GetFormW - error\n");

                    MarshallUpStructure(lpbForm, FormInfo1Offsets);

                }
            }
            VFREEMEM(pGetFormReturn);
        }
        VFREEMEM(pGetForm);
    }
    return bRet;

}

/*******************************************************************************
* GetPrinterDriverW()
*
*  History:
*   4/19/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*******************************************************************************/

BOOL WINAPI GetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   dwLevel,
    LPBYTE  lpbDrvInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL bRet = FALSE;
    LONG cj, cjEnvironment;
    DWORD *pOffsets, *pStrings;

    //DbgPrint("Enter GetPrinterDriverW\n");

    if (!pcbNeeded)
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    cj = sizeof(GREGETPRINTERDRIVER);
    cjEnvironment = 0;

    *pcbNeeded = 0;

    if( pEnvironment )
    {
        cjEnvironment += (wcslen(pEnvironment) + 1) * sizeof(WCHAR);
    }

    cj += cjEnvironment;

    GREGETPRINTERDRIVER *pGetPrinterDriver;

    pGetPrinterDriver = (GREGETPRINTERDRIVER*)PALLOCMEM(cj, 'lpsG');

    if( pGetPrinterDriver )
    {
        pGetPrinterDriver->cj      = cj;
        pGetPrinterDriver->cjData  = cbBuf;
        pGetPrinterDriver->dwLevel = dwLevel;

        if( pEnvironment )
        {
            memcpy(pGetPrinterDriver->alData,pEnvironment,cjEnvironment);
        }

        GREGETPRINTERDRIVER *pGetPrinterDriverReturn = NULL;
        UINT cjSize = cbBuf + sizeof(GREGETPRINTERDRIVER);

        pGetPrinterDriverReturn = (GREGETPRINTERDRIVER*) PALLOCNOZ(cjSize, 'lpsG');

        if( pGetPrinterDriverReturn )
        {
            bRet = GreGetPrinterDriverW(hPrinter,pGetPrinterDriver, pGetPrinterDriverReturn, cjSize );

            DWORD cjData = pGetPrinterDriverReturn->cjData;

            if (bRet == FALSE)
            {
                if (cjData > cbBuf)
                {
                    // need to return the size needed.

                    *pcbNeeded = pGetPrinterDriverReturn->cjData;
                }
            }
            else
            {
                ASSERTGDI(cjData <= cbBuf,"GetPrinterDriverW - error\n");

                // return the size needed whether everything fits or not

                *pcbNeeded = cjData;

                // only copy data and return success if everything fits
                switch (dwLevel) {
                    case 1:
                        pOffsets = DriverInfo1Offsets;
                        pStrings = DriverInfo1Strings;
                        break;

                    case 2:
                        pOffsets = DriverInfo2Offsets;
                        pStrings = DriverInfo2Strings;
                        break;

                    case 3:
                        pOffsets = DriverInfo3Offsets;
                        pStrings = DriverInfo3Strings;
                        break;

                    default:
                        // We should not get here
                        ASSERTGDI(0, "GetPrinterDriverW invalid level\n");
                }

                if (lpbDrvInfo)
                {
                    memcpy( lpbDrvInfo, pGetPrinterDriverReturn->alData, cjData );
                    MarshallUpStructure((LPBYTE)lpbDrvInfo, pOffsets);
                    if ( !ValidateStrings((LPBYTE)lpbDrvInfo, pStrings, cjData) ||
                         (dwLevel == 3 &&
                          ((PDRIVER_INFO_3W) lpbDrvInfo)->pDependentFiles &&
                          !ValidateDependentFiles(((PDRIVER_INFO_3W) lpbDrvInfo)->pDependentFiles,
                                                  (LPBYTE)lpbDrvInfo, cjData) ) ) {
                        WARNING("GetPrinterDriverW: String does not fit in buffer\n");
                        bRet = FALSE;
                    }
                }
            }

            VFREEMEM(pGetPrinterDriverReturn);
        }

        VFREEMEM(pGetPrinterDriver);
    }
    return(bRet);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   EngGetPrinterDriver
*
* Routine Description:
*
* Arguments:
*
* Called by:
*
* Return Value:
*
\**************************************************************************/

extern "C" BOOL APIENTRY EngGetPrinterDriver(
    HANDLE  hPrinter
  , LPWSTR  pEnvironment
  , DWORD   dwLevel
  , BYTE   *lpbDrvInfo
  , DWORD   cbBuf
  , DWORD  *pcbNeeded
    )
{
    BOOL ReturnValue;
    ReturnValue = GetPrinterDriverW(
                      hPrinter
                    , pEnvironment
                    , dwLevel
                    , lpbDrvInfo
                    , cbBuf
                    , pcbNeeded
                      );
    return( ReturnValue );
}


/*******************************************************************************
* EngGetPrinterDataW()
*
*  History:
*   25-Jul-95 by Steve Wilson [swilson]
*  Wrote it.
*******************************************************************************/

DWORD
WINAPI
EngGetPrinterData(
   HANDLE   hPrinter,       // IN
   LPWSTR   pValueName,     // IN
   LPDWORD  pType,          // OUT -- may be NULL
   LPBYTE   lpbData,        // OUT
   DWORD    cbBuf,          // IN
   LPDWORD  pcbNeeded       // OUT
)
{
    LONG cj, cjValueName;
    DWORD cjReturn;
    DWORD dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    GREGETPRINTERDATA    *pX, *pXReturn;

    //DbgPrint("Enter EngGetPrinterData\n");

    if (!pcbNeeded)
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }

    // Accumulate sizes of base struct plus strings
    cj = sizeof *pX;
    cj += (cjValueName = pValueName ? (wcslen(pValueName) + 1)*sizeof *pValueName : 0);

    // Allocate TO buffer
    pX = (GREGETPRINTERDATA *) PALLOCMEM(cj, 'lpsG');

    // Marshall TO buffer
    if (pX)
    {

        pX->cj = cj;
        pX->cjData = cbBuf;        // Client's buffer size

        // Write strings at end of GRE struct
        if (pValueName) {
            memcpy(pX->alData,pValueName,cjValueName);
            pX->cjValueName = cjValueName;
        }

        // Allocate RETURN buffer
        pXReturn = (GREGETPRINTERDATA *) PALLOCNOZ(cjReturn = sizeof *pX + cbBuf, 'lpsG');

        // SEND MESSAGE
        if (pXReturn)
        {
            // GreGenericW return value indicates success or failure of GreEscapeSpool() and KMGetPrinterData()
            GreGenericW( hPrinter,
                        (PULONG) pX,
                        (PULONG) pXReturn,
                        cjReturn,
                        (LONG) GDISPOOL_GETPRINTERDATA, 0);

            dwLastError = EngGetLastError();

            // return from GreGenericW may be 0, meaning any number of things, including ERROR_MORE_DATA
            if (dwLastError != ERROR_PROCESS_ABORTED)
            {
                // Fill in return sizes
                if (pcbNeeded)
                {
                   *pcbNeeded = pXReturn->dwNeeded;          // # return data bytes

                    //DbgPrint("EngGetPrinterData *pcbNeeded = %d\n", *pcbNeeded);
                }

                if (pType)
                    *pType = pXReturn->dwType;

                if (dwLastError == ERROR_SUCCESS)
                {
                    // Copy returned data into supplied structure
                    if (lpbData)
                    {
                        if ((DWORD) pXReturn->cjData <= cbBuf)
                            memcpy(lpbData, pXReturn->alData, pXReturn->cjData);
                        else
                            ASSERTGDI((DWORD) pXReturn->cjData <= cbBuf, "GetPrinterDataW - Bad spooler buffer size\n");
                    }
                }
            }

            VFREEMEM(pXReturn);
        }
        VFREEMEM(pX);
    }

    //DbgPrint("GetPrinterData return: %d\n", dwLastError);

    return dwLastError;
}



/*******************************************************************************
* EngSetPrinterData()
*
*  History:
*   25-Oct-95 by Steve Wilson [swilson]
*  Wrote it.
*******************************************************************************/

DWORD
WINAPI
EngSetPrinterData(
   HANDLE   hPrinter,           // IN
   LPWSTR   pType,              // IN
   DWORD    dwType,             // IN
   LPBYTE   lpbPrinterData,     // IN
   DWORD    cjPrinterData       // IN
)
{
    LONG cj, cjType;
    DWORD cjReturn;
    DWORD dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    GRESETPRINTERDATA    *pTo, *pFrom;

    //DbgPrint("Enter EngSetPrinterData\n");

    // Accumulate sizes of base struct plus strings
    cj = sizeof *pTo;
    cj += (cjType = pType ? (wcslen(pType) + 1)*sizeof *pType : 0);
    cj += lpbPrinterData ? cjPrinterData : 0;

    // Allocate TO buffer
    pTo = (GRESETPRINTERDATA *) PALLOCMEM(cj, 'lpsG');

    // Marshall TO buffer
    if (pTo)
    {

        pTo->cj = cj;

        // Write incoming data at end of GRE struct
        if (pType) {
            memcpy(pTo->alData,pType,cjType);
            pTo->cjType = cjType;
        }

        if (lpbPrinterData) {
            memcpy((BYTE *)pTo->alData + cjType,lpbPrinterData,cjPrinterData);
            pTo->cjPrinterData = cjPrinterData;
        }


        // Allocate RETURN buffer
        cjReturn = sizeof *pTo;
        pFrom = (GRESETPRINTERDATA *) PALLOCNOZ(cjReturn, 'lpsG');

        // SEND MESSAGE
        if (pFrom)
        {
            pTo->dwType = dwType;

            // GreGenericW return value indicates success or failure of GreEscapeSpool() and KMGetPrinterData()
            GreGenericW( hPrinter,
                        (PULONG) pTo,
                        (PULONG) pFrom,
                        cjReturn,
                        (LONG) GDISPOOL_SETPRINTERDATA, 0);

            dwLastError = EngGetLastError();

            VFREEMEM(pFrom);
        }
        VFREEMEM(pTo);
    }

    //DbgPrint("GetPrinterData return: %d\n", dwLastError);

    return dwLastError;
}




/******************************Public*Routine******************************\
*
*
* History:
*  27-Feb-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
WINAPI
EngWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    DWORD ulRet = 0;
    SPOOLREF sr(hPrinter);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();
        LPVOID pKmBuf = NULL;

        GREWRITEPRINTER *wp = &sr.pso->WritePrinter;

        //DbgPrint("Enter EngWritePrinter\n");

        wp->cj = offsetof(GREWRITEPRINTER,alData) + cbBuf;
        wp->cjData = cbBuf;

        if (gpeSpool == PsGetCurrentProcess() &&
            pBuf <= MM_HIGHEST_USER_ADDRESS &&
            pBuf >= MM_LOWEST_USER_ADDRESS)
        {
            wp->pUserModeData = (PULONG) pBuf;
            wp->cjUserModeData = cbBuf;
            psm->cBuf = 1;
            psm->cjIn = offsetof(GREWRITEPRINTER, alData);
        }
        else
        {
            //
            // if we recevie a user mode buffer, make a kernel copy.
            // This is to patch PSCRIPT 4 driver running on NT5.
            //

            if (pBuf <= MM_HIGHEST_USER_ADDRESS &&
                pBuf >= MM_LOWEST_USER_ADDRESS)
            {
                if (pKmBuf = PALLOCNOZ(cbBuf,'lpsG'))
                {
                   __try
                   {
                       ProbeAndReadBuffer(pKmBuf,pBuf,cbBuf);
                   }
                   __except(EXCEPTION_EXECUTE_HANDLER)
                   {
                       VFREEMEM(pKmBuf);
                       return (FALSE);
                   }

                   pBuf = pKmBuf;
                }
                else
                {
                   WARNING ("failed to allocate memory in EngWritePrinter\n");
                   return (FALSE);
                }
            }

            wp->pUserModeData = NULL;
            wp->cjUserModeData = 0;
            psm->cBuf = 2;
            psm->apulIn[1]= (PULONG)pBuf;
            psm->acjIn[1] = cbBuf;
            psm->cjIn = wp->cj;
        }


        // setup the message

        psm->cj       = sizeof(SPOOLMSG);
        psm->iMsg     = GDISPOOL_WRITE;
        psm->fl       = 0;

        // there are two buffers, one for the GREWRITEPRINTER header and one
        // for the data.

        psm->apulIn[0]= (PULONG)wp;
        psm->acjIn[0] = offsetof(GREWRITEPRINTER,alData);

        // place the return value in ulRet

        psm->pulOut   = &sr.pso->dwWritePrinterReturn;
        psm->cjOut    = sizeof(sr.pso->dwWritePrinterReturn);
        psm->hso      = (HSPOOLOBJ)hPrinter;

        if (!sr.GreEscapeSpool())
        {
            ulRet = 0;
        }
        else
        {
            ulRet = sr.pso->dwWritePrinterReturn;
        }

        if (pcWritten)
            *pcWritten = ulRet;

        if (pKmBuf)
        {
            VFREEMEM(pKmBuf);
        }
    }

    // return TRUE or FALSE

    return(!!ulRet);
}

/*******************************************************************************
 * BOOL GetFontPathName( WCHAR *pFullPath, WCHAR *pFileName )
 *
 * Goes to the spooler and does a search path in the font path to find the
 * full path given a font file name.  We expect pFullName and pFileName to
 * point to the same piece of memory although we don't require this to be the case.
 *
 * History
 *   7-31-95 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *
 *******************************************************************************/

BOOL GetFontPathName( WCHAR *pFullPath, WCHAR *pFileName )
{
    BOOL bRet = FALSE;
    SPOOLMEMOBJ spmo;

    if (spmo.bValid())
    {
        PSPOOLMSG psm = spmo.psm();

        psm->cj        = sizeof(SPOOLMSG);
        psm->iMsg      = GDISPOOL_GETPATHNAME;
        psm->fl        = 0;

        psm->cBuf      = 1;
        psm->cjIn      = (wcslen(pFileName) + 1) * sizeof(WCHAR);
        psm->apulIn[0] = (PULONG) pFileName;
        psm->acjIn[0]  = psm->cjIn;

        psm->pulOut    = (PULONG) pFullPath;
        psm->cjOut     = sizeof(WCHAR) * (MAX_PATH+1);

        psm->hso       = spmo.hGet();

        bRet           = spmo.GreEscapeSpool() && psm->ulRet;

        spmo.bDelete();
    }

    return(bRet);

}

/******************************Public*Routine******************************\
* EngEscape()
*
* History:
*  18-Sep-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

ULONG APIENTRY EngEscape(
    HANDLE   hPrinter,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut)
{
    BOOL ulRet = FALSE;
    SPOOLREF sr(hPrinter);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();

        psm->cj       = sizeof(SPOOLMSG);
        psm->iMsg     = GDISPOOL_ENDDOCPRINTER;
        psm->fl       = 0;

        psm->cBuf     = 2;
        psm->cjIn     = sizeof(ULONG)+cjIn;

        psm->apulIn[0]= &iEsc;
        psm->acjIn[0] = sizeof(ULONG);

        psm->apulIn[1]= (PULONG)pvIn;
        psm->acjIn[1] = cjIn;

        psm->pulOut   = (PULONG)pvOut;
        psm->cjOut    = cjOut;

        psm->hso      = (HSPOOLOBJ)hPrinter;

        if( sr.GreEscapeSpool() )
        {
            ulRet = (DWORD) psm->ulRet;
        }
    }

    return(ulRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\srcblt24.cxx ===
/******************************Module*Header*******************************\
* Module Name: srcblt24.cxx
*
* This contains the bitmap simulation functions that blt to a 24 bit/pel
* DIB surface.
*
* Created: 07-Feb-1991 19:27:49
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// Turn off validations
#if 1

    // On free builds, don't call any verification code:

    #define VERIFYS16D24(psb)
    #define VERIFYS32D24(psb)

#else

    // On checked builds, verify the RGB conversions:

    VOID VERIFYS16D24(PBLTINFO psb)
    {
    // We assume we are doing left to right top to bottom blting

        ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D24 - direction not left to right");
        ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D24 - direction not up to down");

    // These are our holding variables

        ULONG ulDst;
        PUSHORT pusSrcTemp;
        PBYTE pjDstTemp;
        ULONG  cxTemp;
        PUSHORT pusSrc  = (PUSHORT) (psb->pjSrc + (2 * psb->xSrcStart));
        PBYTE pjDst  = psb->pjDst + (psb->xDstStart * 3);
        ULONG cx     = psb->cx;
        ULONG cy     = psb->cy;
        XLATE *pxlo = psb->pxlo;

        ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

        while(1)
        {
            pusSrcTemp  = pusSrc;
            pjDstTemp  = pjDst;
            cxTemp     = cx;

            while(cxTemp--)
            {
                ulDst = pxlo->ulTranslate((ULONG) *(pusSrcTemp++));

                if (*(pjDstTemp++) != (BYTE) ulDst)
                    RIP("RGB mis-match");
                if (*(pjDstTemp++) != (BYTE) (ulDst >> 8))
                    RIP("RGB mis-match");
                if (*(pjDstTemp++) != (BYTE) (ulDst >> 16))
                    RIP("RGB mis-match");
            }

            if (--cy)
            {
                pusSrc = (PUSHORT) (((PBYTE) pusSrc) + psb->lDeltaSrc);
                pjDst += psb->lDeltaDst;
            }
            else
                break;
        }
    }

    VOID VERIFYS32D24(PBLTINFO psb)
    {
    // We assume we are doing left to right top to bottom blting

        ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D24 - direction not left to right");
        ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D24 - direction not up to down");

    // These are our holding variables

        ULONG ulDst;
        PULONG pulSrcTemp;
        PBYTE pjDstTemp;
        ULONG  cxTemp;
        PULONG pulSrc  = (PULONG) (psb->pjSrc + (4 * psb->xSrcStart));
        PBYTE pjDst  = psb->pjDst + (psb->xDstStart * 3);
        ULONG cx     = psb->cx;
        ULONG cy     = psb->cy;
        XLATE *pxlo = psb->pxlo;

        ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

        while(1)
        {

            pulSrcTemp  = pulSrc;
            pjDstTemp  = pjDst;
            cxTemp     = cx;

            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                while(cxTemp--)
                {
                    ulDst = *(pulSrcTemp++);

                    if (*(pjDstTemp++) != (BYTE) ulDst)
                        RIP("RGB mis-match");
                    if (*(pjDstTemp++) != (BYTE) (ulDst >> 8))
                        RIP("RGB mis-match");
                    if (*(pjDstTemp++) != (BYTE) (ulDst >> 16))
                        RIP("RGB mis-match");
                }
            }
            else
            {
                while(cxTemp--)
                {
                    ulDst = pxlo->ulTranslate(*(pulSrcTemp++));

                    if (*(pjDstTemp++) != (BYTE) ulDst)
                        RIP("RGB mis-match");
                    if (*(pjDstTemp++) != (BYTE) (ulDst >> 8))
                        RIP("RGB mis-match");
                    if (*(pjDstTemp++) != (BYTE) (ulDst >> 16))
                        RIP("RGB mis-match");
                }
            }

            if (--cy)
            {
                pulSrc = (PULONG) (((PBYTE) pulSrc) + psb->lDeltaSrc);
                pjDst += psb->lDeltaDst;
            }
            else
                break;
        }
    }



#endif

/*******************Public*Routine*****************\
* vSrcCopyS1D24
*
* There are three main loops in this function.
*
* The first loop deals with the full byte part mapping
* the Dst while fetching/shifting the matching 8 bits
* from the Src.
*
* The second loop deals with the left starting
* pixels.
*
* The third loop deals with the ending pixels.
*
* For the full bytes, we walk thru Src one byte at a time
* and expand to Dst.
*
* We expand the starting/ending pixels one bit
* at a time.
*
* History:
* 17-Oct-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************/

VOID vSrcCopyS1D24(PBLTINFO psb)
{
    // We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS1D24 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS1D24 - direction not up to down");

    BYTE  jSrc;    // holds a source byte
    INT   iDst;    // Position in the first 8 Dst units
    INT   iSrc;    // bit position in the first Src byte
    PBYTE pjDst;
    PBYTE pjSrc;   // pointer to the Dst bytes
    LONG  xSrcEnd = psb->xSrcEnd;
    LONG  cy;      // number of rows
    LONG  cx;      // number of pixels
    BYTE  jAlignL;  // alignment bits to the left
    BYTE  jAlignR;  // alignment bits to the right
    LONG  cFullBytes;  //number of full 8 bytes dealed with
    BOOL  bNextByte;
    LONG  xDstEnd = psb->xDstStart+psb->cx;
    LONG  lDeltaDst;
    LONG  lDeltaSrc;
    ULONG ulB = (ULONG)(psb->pxlo->pulXlate[0]);
    ULONG ulF = (ULONG)(psb->pxlo->pulXlate[1]);
    UCHAR aucTable[8];
    INT   count;
    PBYTE pjTable;
    BOOL  bNextSrc=TRUE;

    ASSERTGDI(psb->cy != 0, "ERROR: Src Move cy == 0");

    //DbgPrint ("vsrccopys1d24\n");

    // Generate ulTable. 2 entries.
    ULONG ulValB = ulB;
    ULONG ulValF = ulF;

    *(PULONG) aucTable = ulValB;
    *(PULONG) (aucTable+4) = ulValF;

    //Get Src and Dst start positions
    iSrc = psb->xSrcStart & 0x0007;
    iDst = psb->xDstStart & 0x0007;

    if (iSrc < iDst)
        jAlignL = 8 - (iDst - iSrc);
    // If Dst starting point is ahead of Src
    else
        jAlignL = iSrc - iDst;

    jAlignR = 8 - jAlignL;

    cx=psb->cx;

    lDeltaDst = psb->lDeltaDst;
    lDeltaSrc = psb->lDeltaSrc;

    // if there is a next 8 dwords
    bNextByte = !((xDstEnd>>3) ==
                 (psb->xDstStart>>3));

    // if Src and Dst are aligned, use a separete loop
    // to obtain better performance;
    // If not, we shift the Src bytes to match with
    // the Dst - 1 bit expand to 3 bytes

    if (bNextByte)
    {
        long iStrideSrc;
        long iStrideDst;
        PBYTE pjSrcEnd;

        // Get first Dst full 8 dwords
        pjDst = psb->pjDst + 3*((psb->xDstStart+7)&~0x07);

        // Get the Src byte that matches the first Dst
        // full 8 bytes
        pjSrc = psb->pjSrc + ((psb->xSrcStart+((8-iDst)&0x07)) >> 3);

        //Get the number of full bytes to expand
        cFullBytes = (xDstEnd>>3)-((psb->xDstStart+7)>>3);

        //the increment to the full byte on the next scan line
        iStrideDst = lDeltaDst - cFullBytes*8*3;
        iStrideSrc = lDeltaSrc - cFullBytes;

        // deal with our special case
        cy = psb->cy;

        if (!jAlignL)
        {
            while (cy--)
            {
                pjSrcEnd = pjSrc + cFullBytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = *pjSrc++;

                    pjTable = aucTable + ((jSrc & 0x80) >> (7-2));

                    *(pjDst + 0) = *pjTable;
                    *(pjDst + 1) = *(pjTable+1);
                    *(pjDst + 2) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x40) >> (6-2));

                    *(pjDst + 3) = *pjTable;
                    *(pjDst + 4) = *(pjTable+1);
                    *(pjDst + 5) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x20) >> (5-2));

                    *(pjDst + 6) = *pjTable;
                    *(pjDst + 7) = *(pjTable+1);
                    *(pjDst + 8) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x10) >> (4-2));

                    *(pjDst + 9) = *pjTable;
                    *(pjDst + 10) = *(pjTable+1);
                    *(pjDst + 11) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x08) >> (3-2));

                    *(pjDst + 12) = *pjTable;
                    *(pjDst + 13) = *(pjTable+1);
                    *(pjDst + 14) = *(pjTable+2);

                    pjTable = aucTable + (jSrc & 0x04);

                    *(pjDst + 15) = *pjTable;
                    *(pjDst + 16) = *(pjTable+1);
                    *(pjDst + 17) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x02) << 1);

                    *(pjDst + 18) = *pjTable;
                    *(pjDst + 19) = *(pjTable+1);
                    *(pjDst + 20) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x01) << 2);

                    *(pjDst + 21) = *pjTable;
                    *(pjDst + 22) = *(pjTable+1);
                    *(pjDst + 23) = *(pjTable+2);

                    pjDst +=3*8;
                }

                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }

        }   //end of if (!jAlignL)

        else  // if not aligned
        // Here comes our general case for the main full
        // bytes part
        {
            BYTE jRem; //remainder

            while (cy--)
            {
                jRem = *pjSrc << jAlignL;

                pjSrcEnd = pjSrc + cFullBytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = ((*(++pjSrc))>>jAlignR) | jRem;

                    pjTable = aucTable + ((jSrc & 0x80) >> (7-2));

                    *(pjDst + 0) = *pjTable;
                    *(pjDst + 1) = *(pjTable+1);
                    *(pjDst + 2) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x40) >> (6-2));

                    *(pjDst + 3) = *pjTable;
                    *(pjDst + 4) = *(pjTable+1);
                    *(pjDst + 5) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x20) >> (5-2));

                    *(pjDst + 6) = *pjTable;
                    *(pjDst + 7) = *(pjTable+1);
                    *(pjDst + 8) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x10) >> (4-2));

                    *(pjDst + 9) = *pjTable;
                    *(pjDst + 10) = *(pjTable+1);
                    *(pjDst + 11) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x08) >> (3-2));

                    *(pjDst + 12) = *pjTable;
                    *(pjDst + 13) = *(pjTable+1);
                    *(pjDst + 14) = *(pjTable+2);

                    pjTable = aucTable + (jSrc & 0x04);

                    *(pjDst + 15) = *pjTable;
                    *(pjDst + 16) = *(pjTable+1);
                    *(pjDst + 17) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x02) << 1);

                    *(pjDst + 18) = *pjTable;
                    *(pjDst + 19) = *(pjTable+1);
                    *(pjDst + 20) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x01) << 2);

                    *(pjDst + 21) = *pjTable;
                    *(pjDst + 22) = *(pjTable+1);
                    *(pjDst + 23) = *(pjTable+2);

                    pjDst +=3*8;

                    //next remainder
                    jRem = *pjSrc << jAlignL;
                }

                // go to the beginging full byte of
                // next scan line
                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }
        } //else
    } //if
    // End of our dealing with the full bytes

    // Begin dealing with the left strip of the
    // starting pixels

    if (!bNextByte)
    {
        count = cx;
        bNextSrc = ((iSrc+cx) > 8);
    }
    else
        count = 8-iDst;

    if (iDst | !bNextByte)
    {
        PBYTE pjDstTemp;
        PBYTE pjDstEnd;

        pjDst = psb->pjDst + 3*psb->xDstStart;
        pjSrc = psb->pjSrc + (psb->xSrcStart>>3);

        cy = psb->cy;

        if (iSrc > iDst)
        {
            if (bNextSrc)
            {
                while (cy--)
                {
                    jSrc = *pjSrc << jAlignL;
                    jSrc |= *(pjSrc+1) >> jAlignR;

                    jSrc <<= iDst;

                    pjDstTemp = pjDst;
                    pjDstEnd = pjDst + 3*count;

                    while (pjDstTemp != pjDstEnd)
                    {
                        pjTable = aucTable + ((jSrc & 0x80) >> (7-2));

                        *(pjDstTemp + 0) = *pjTable;
                        *(pjDstTemp + 1) = *(pjTable+1);
                        *(pjDstTemp + 2) = *(pjTable+2);

                        jSrc <<= 1;
                        pjDstTemp += 3;
                    }

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }
            else
            {
                while (cy--)
                {
                    jSrc = *pjSrc << jAlignL;

                    jSrc <<= iDst;

                    pjDstTemp = pjDst;
                    pjDstEnd = pjDst + 3*count;

                    while (pjDstTemp != pjDstEnd)
                    {
                        pjTable = aucTable + ((jSrc & 0x80) >> (7-2));

                        *(pjDstTemp + 0) = *pjTable;
                        *(pjDstTemp + 1) = *(pjTable+1);
                        *(pjDstTemp + 2) = *(pjTable+2);

                        jSrc <<= 1;
                        pjDstTemp += 3;
                    }

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }

        }
        else //if (iSrc <= iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << iSrc;

                pjDstTemp = pjDst;
                pjDstEnd = pjDst + 3*count;

                while (pjDstTemp != pjDstEnd)
                {
                    pjTable = aucTable + ((jSrc & 0x80) >> (7-2));

                    *(pjDstTemp + 0) = *pjTable;
                    *(pjDstTemp + 1) = *(pjTable+1);
                    *(pjDstTemp + 2) = *(pjTable+2);

                    jSrc <<= 1;
                    pjDstTemp += 3;

                }

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }

        }

   } //if

   // Begin dealing with the right edge
   // of partial 8 bytes
   // first check if there is any partial
   // byte left
   // and has next 8 bytes

   if ((xDstEnd & 0x0007)
       && bNextByte)
   {
        PBYTE pjDstTemp;
        PBYTE pjDstEnd;

        // Get the last partial bytes on the
        // scan line
        pjDst = psb->pjDst+ 3*(xDstEnd&~0x07);

        // Get the Src byte that matches the
        // right partial Dst 8 bytes
        pjSrc = psb->pjSrc + ((psb->xSrcEnd-1) >>3);

        // Get the ending position in the last
        // Src and Dst bytes
        iSrc = (psb->xSrcEnd-1) & 0x0007;
        iDst = (xDstEnd-1) & 0x0007;

        count = iDst+1;

        cy = psb->cy;

        if (iSrc >= iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << jAlignL;

                pjDstTemp = pjDst;
                pjDstEnd = pjDst + 3*count;

                while (pjDstTemp != pjDstEnd)
                {
                    pjTable = aucTable + ((jSrc & 0x80) >> (7-2));

                    *(pjDstTemp + 0) = *pjTable;
                    *(pjDstTemp + 1) = *(pjTable+1);
                    *(pjDstTemp + 2) = *(pjTable+2);

                    jSrc <<= 1;
                    pjDstTemp += 3;

                }

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
        else //if (iSrc < iDst)
        {
            while (cy--)
            {
                 jSrc = *(pjSrc-1) << jAlignL;

                 jSrc |= *pjSrc >> jAlignR;

                 pjDstTemp = pjDst;
                 pjDstEnd = pjDst + 3*count;

                 while (pjDstTemp != pjDstEnd)
                 {
                     pjTable = aucTable + ((jSrc & 0x80) >> (7-2));

                     *(pjDstTemp + 0) = *pjTable;
                     *(pjDstTemp + 1) = *(pjTable+1);
                     *(pjDstTemp + 2) = *(pjTable+2);

                     jSrc <<= 1;
                     pjDstTemp += 3;

                 }

                 pjDst += lDeltaDst;
                 pjSrc += lDeltaSrc;
            }
        }
    } //if
}


/******************************Public*Routine******************************\
* vSrcCopyS4D24
*
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS4D24(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting.
// If it was on the same surface we would be doing the identity case.

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS8D24 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS8D24 - direction not up to down");

// These are our holding variables

#if MESSAGE_BLT
    DbgPrint("Now entering vSrcCopyS8D24\n");
#endif

    PBYTE pjSrc  = psb->pjSrc + (psb->xSrcStart >> 1);
    PBYTE pjDst  = psb->pjDst + (psb->xDstStart * 3);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;
    PBYTE pjDstTemp;
    PBYTE pjSrcTemp;
    ULONG cStartPixels;
    ULONG cMiddlePixels;
    ULONG cEndPixels;
    ULONG i,j;
    ULONG ul;
    ULONG ul0, ul1,ul2,ul3;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    // 'cStartPixels' is the minimum number of 3-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((ULONG_PTR) pjDst) & 3;

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    while(1)
    {
        // Write pixels a byte at a time until we're 'dword' aligned on
        // the destination:

        j = psb->xSrcStart;

        pjDstTemp  = pjDst;
        pjSrcTemp  = pjSrc;

        for (i = cStartPixels; i != 0; i--)
        {
            if (j & 0x00000001)
            {
                ul = pulXlate[*pjSrcTemp & 0x0F];
                pjSrcTemp++;
            }
            else
            {
               ul = pulXlate[(((ULONG) (*pjSrcTemp & 0xF0)) >> 4)];
            }

            *(pjDstTemp)     = (BYTE) ul;
            *(pjDstTemp + 1) = (BYTE) (ul >> 8);
            *(pjDstTemp + 2) = (BYTE) (ul >> 16);

            j++;
            pjDstTemp += 3;
        }

        //
        // grab 4 pixles at a time
        //

        for (i = cMiddlePixels; i != 0; i--)
        {
            if (j & 0x00000001)
            {
                ul0 = pulXlate[(*pjSrcTemp & 0x0F)];
                pjSrcTemp++;
                ul1 = pulXlate[(((ULONG) (*pjSrcTemp & 0xF0)) >> 4)];
                ul2 = pulXlate[((ULONG) (*pjSrcTemp & 0x0F))];
                pjSrcTemp++;
                ul3 = pulXlate[((ULONG) (*pjSrcTemp & 0xF0)) >> 4];
            }
            else
            {
                ul0 = pulXlate[(((ULONG) (*pjSrcTemp & 0xF0)) >> 4)];
                ul1 = pulXlate[((ULONG) (*pjSrcTemp & 0x0F))];
                pjSrcTemp++;
                ul2 = pulXlate[(((ULONG) (*pjSrcTemp & 0xF0)) >> 4)];
                ul3 = pulXlate[((ULONG) (*pjSrcTemp & 0x0F))];
                pjSrcTemp++;

            }

            *((ULONG*) (pjDstTemp)) = ul0 | (ul1 << 24);
            *((ULONG*) (pjDstTemp + 4)) = (ul1 >> 8) | (ul2 << 16);
            *((ULONG*) (pjDstTemp + 8)) = (ul3 << 8) | (ul2 >> 16);

            j += 4;
            pjDstTemp += 12;
        }

        // Take care of the end alignment:

        for (i = cEndPixels; i != 0; i--)
        {
            if (j & 0x00000001)
            {
                ul = pulXlate[*pjSrcTemp & 0x0F];
                pjSrcTemp++;
            }
            else
            {
                ul = pulXlate[(((ULONG) (*pjSrcTemp & 0xF0)) >> 4)];
            }

            *(pjDstTemp)     = (BYTE) ul;
            *(pjDstTemp + 1) = (BYTE) (ul >> 8);
            *(pjDstTemp + 2) = (BYTE) (ul >> 16);

            j++;
            pjDstTemp += 3;
        }

        if (--cy == 0)
            break;

        pjSrc += psb->lDeltaSrc;
        pjDst += psb->lDeltaDst;
    }
}


/******************************Public*Routine******************************\
* vSrcCopyS8D24
*
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D24(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting.
// If it was on the same surface we would be doing the identity case.

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS8D24 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS8D24 - direction not up to down");

// These are our holding variables

#if MESSAGE_BLT
    DbgPrint("Now entering vSrcCopyS8D24\n");
#endif

    PBYTE pjSrc  = psb->pjSrc + psb->xSrcStart;
    PBYTE pjDst  = psb->pjDst + (psb->xDstStart * 3);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;
    LONG lSrcSkip = psb->lDeltaSrc - cx;
    LONG lDstSkip = psb->lDeltaDst - (cx * 3);
    ULONG cStartPixels;
    ULONG cMiddlePixels;
    ULONG cEndPixels;
    ULONG i;
    ULONG ul;
    ULONG ul0;
    ULONG ul1;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    // 'cStartPixels' is the minimum number of 3-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((ULONG_PTR) pjDst) & 3;

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    while(1)
    {
        // Write pixels a byte at a time until we're 'dword' aligned on
        // the destination:

        for (i = cStartPixels; i != 0; i--)
        {
            ul = pulXlate[*pjSrc];

            *(pjDst)     = (BYTE) ul;
            *(pjDst + 1) = (BYTE) (ul >> 8);
            *(pjDst + 2) = (BYTE) (ul >> 16);

            pjSrc += 1;
            pjDst += 3;
        }

        // Now write pixels a dword at a time.  This is almost a 4x win
        // over doing byte writes if we're writing to frame buffer memory
        // over the PCI bus on Pentium class systems, because the PCI
        // write throughput is so slow:

        for (i = cMiddlePixels; i != 0; i--)
        {
            ul0  = (pulXlate[*(pjSrc)]);
            ul1  = (pulXlate[*(pjSrc + 1)]);

            *((ULONG*) (pjDst)) = ul0 | (ul1 << 24);

            ul0  = (pulXlate[*(pjSrc + 2)]);

            *((ULONG*) (pjDst + 4)) = (ul1 >> 8) | (ul0 << 16);

            ul1  = (pulXlate[*(pjSrc + 3)]);

            *((ULONG*) (pjDst + 8)) = (ul1 << 8) | (ul0 >> 16);

            pjSrc += 4;
            pjDst += 12;
        }

        // Take care of the end alignment:

        for (i = cEndPixels; i != 0; i--)
        {
            ul = pulXlate[*pjSrc];

            *(pjDst)     = (BYTE) ul;
            *(pjDst + 1) = (BYTE) (ul >> 8);
            *(pjDst + 2) = (BYTE) (ul >> 16);

            pjSrc += 1;
            pjDst += 3;
        }

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS16D24
*
*
* History:
*  07-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/
VOID vSrcCopyS16D24(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D24 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D24 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + (2 * psb->xSrcStart);
    PBYTE pjDst  = psb->pjDst + (3 * psb->xDstStart);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    XLATE *pxlo = psb->pxlo;
    LONG lSrcSkip = psb->lDeltaSrc - (cx * 2);
    LONG lDstSkip = psb->lDeltaDst - (cx * 3);
    PFN_pfnXlate pfnXlate = pxlo->pfnXlateBetweenBitfields();
    ULONG cStartPixels;
    ULONG cMiddlePixels;
    ULONG cEndPixels;
    ULONG ul;
    ULONG ul0;
    ULONG ul1;
    LONG i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    // 'cStartPixels' is the minimum number of 3-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((ULONG_PTR) pjDst) & 3;

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    while (1)
    {
        for (i = cStartPixels; i != 0; i--)
        {
            ul = pfnXlate(pxlo, *((USHORT*) pjSrc));

            *(pjDst)     = (BYTE) (ul);
            *(pjDst + 1) = (BYTE) (ul >> 8);
            *(pjDst + 2) = (BYTE) (ul >> 16);

            pjSrc += 2;
            pjDst += 3;
        }

        for (i = cMiddlePixels; i != 0; i--)
        {
            ul0 = pfnXlate(pxlo, *((USHORT*) (pjSrc)));
            ul1 = pfnXlate(pxlo, *((USHORT*) (pjSrc + 2)));

            *((ULONG*) (pjDst)) = ul0 | (ul1 << 24);

            ul0 = pfnXlate(pxlo, *((USHORT*) (pjSrc + 4)));

            *((ULONG*) (pjDst + 4)) = (ul1 >> 8) | (ul0 << 16);

            ul1 = pfnXlate(pxlo, *((USHORT*) (pjSrc + 6)));

            *((ULONG*) (pjDst + 8)) = (ul1 << 8) | (ul0 >> 16);

            pjSrc += 8;
            pjDst += 12;
        }

        for (i = cEndPixels; i != 0; i--)
        {
            ul = pfnXlate(pxlo, *((USHORT*) pjSrc));

            *(pjDst)     = (BYTE) (ul);
            *(pjDst + 1) = (BYTE) (ul >> 8);
            *(pjDst + 2) = (BYTE) (ul >> 16);

            pjSrc += 2;
            pjDst += 3;
        }

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    VERIFYS16D24(psb);
}

/******************************Public*Routine******************************\
* vSrcCopyS24D24
*
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS24D24(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D24 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D24 - direction not up to down");

// These are our holding variables

#if MESSAGE_BLT
    DbgPrint("Now entering vSrcCopyS8D24\n");
#endif

    PBYTE pjSrcTemp;
    PBYTE pjDstTemp;
    PBYTE pjSrc  = psb->pjSrc + (psb->xSrcStart * 3);
    PBYTE pjDst  = psb->pjDst + (psb->xDstStart * 3);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    XLATE *pxlo = psb->pxlo;
    ULONG cStartPixels;
    ULONG cMiddlePixels;
    ULONG cEndPixels;
    ULONG i,j;
    ULONG ul;
    ULONG ul0,ul1,ul2,ul3;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    // 'cStartPixels' is the minimum number of 3-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((ULONG_PTR) pjDst) & 3;

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    while(1)
    {
        // Write pixels a byte at a time until we're 'dword' aligned on
        // the destination:

        j = psb->xSrcStart;

        pjDstTemp  = pjDst;
        pjSrcTemp  = pjSrc;

        for (i = cStartPixels; i != 0; i--)
        {
            ul = (ULONG) *(pjSrcTemp + 2);
            ul = ul << 8;
            ul |= (ULONG) *(pjSrcTemp + 1);
            ul = ul << 8;
            ul |= (ULONG) *pjSrcTemp;

            ul = pxlo->ulTranslate(ul);

            *(pjDstTemp++) = (BYTE) ul;
            *(pjDstTemp++) = (BYTE) (ul >> 8);
            *(pjDstTemp++) = (BYTE) (ul >> 16);

            pjSrcTemp += 3;
        }

        //
        // grab 4 pixles at a time
        //
        for (i = cMiddlePixels; i != 0; i--)
        {
            ul0 = (ULONG) *(pjSrcTemp + 2);
            ul0 = ul0 << 8;
            ul0 |= (ULONG) *(pjSrcTemp + 1);
            ul0 = ul0 << 8;
            ul0 |= (ULONG) *pjSrcTemp;
            ul0 = pxlo->ulTranslate(ul0);

            pjSrcTemp += 3;

            ul1 = (ULONG) *(pjSrcTemp + 2);
            ul1 = ul1 << 8;
            ul1 |= (ULONG) *(pjSrcTemp + 1);
            ul1 = ul1 << 8;
            ul1 |= (ULONG) *pjSrcTemp;
            ul1 = pxlo->ulTranslate(ul1);

            pjSrcTemp += 3;

            ul2 = (ULONG) *(pjSrcTemp + 2);
            ul2 = ul2 << 8;
            ul2 |= (ULONG) *(pjSrcTemp + 1);
            ul2 = ul2 << 8;
            ul2 |= (ULONG) *pjSrcTemp;
            ul2 = pxlo->ulTranslate(ul2);

            pjSrcTemp += 3;

            ul3 = (ULONG) *(pjSrcTemp + 2);
            ul3 = ul3 << 8;
            ul3 |= (ULONG) *(pjSrcTemp + 1);
            ul3 = ul3 << 8;
            ul3 |= (ULONG) *pjSrcTemp;
            ul3 = pxlo->ulTranslate(ul3);

            pjSrcTemp += 3;

            *((ULONG*) (pjDstTemp)) = ul0 | (ul1 << 24);
            *((ULONG*) (pjDstTemp + 4)) = (ul1 >> 8) | (ul2 << 16);
            *((ULONG*) (pjDstTemp + 8)) = (ul3 << 8) | (ul2 >> 16);

            pjDstTemp += 12;
        }

        // Take care of the end alignment:

        for (i = cEndPixels; i != 0; i--)
        {
            ul = (ULONG) *(pjSrcTemp + 2);
            ul = ul << 8;
            ul |= (ULONG) *(pjSrcTemp + 1);
            ul = ul << 8;
            ul |= (ULONG) *pjSrcTemp;

            ul = pxlo->ulTranslate(ul);

            *(pjDstTemp++) = (BYTE) ul;
            *(pjDstTemp++) = (BYTE) (ul >> 8);
            *(pjDstTemp++) = (BYTE) (ul >> 16);

            pjSrcTemp += 3;

        }

        if (--cy == 0)
            break;

        pjSrc += psb->lDeltaSrc;
        pjDst += psb->lDeltaDst;
    }
}
/******************************Public*Routine******************************\
* vSrcCopyS24D24Identity
*
* This is the special case no translate blting.  All the SmDn should have
* them if m==n.  Identity xlates only occur amoung matching format bitmaps
* and screens.
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS24D24Identity(PBLTINFO psb)
{
    PBYTE pjSrc  = psb->pjSrc + (psb->xSrcStart * 3);
    PBYTE pjDst  = psb->pjDst + (psb->xDstStart * 3);
    ULONG cx     = psb->cx * 3;
    ULONG cy     = psb->cy;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

#if MESSAGE_BLT
    DbgPrint("xdir: %ld  cy: %lu  xSrcStart %lu  xDstStart %lu xSrcEnd %lu cx %lu\n",
             psb->xDir, cy, psb->xSrcStart, psb->xDstStart, psb->xSrcEnd, cx);
#endif

    if (psb->xDir < 0)
    {
        pjSrc -= (cx - 3);
        pjDst -= (cx - 3);
    }

    while(1)
    {
        if(psb->fSrcAlignedRd)
            vSrcAlignCopyMemory(pjDst, pjSrc, cx);
        else
            RtlMoveMemory((PVOID)pjDst, (PVOID)pjSrc, cx);

        if (--cy)
        {
            pjSrc += psb->lDeltaSrc;
            pjDst += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS32D24
*
*
* History:
*  07-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/
VOID vSrcCopyS32D24(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D24 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D24 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + (4 * psb->xSrcStart);
    PBYTE pjDst  = psb->pjDst + (3 * psb->xDstStart);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    XLATE *pxlo = psb->pxlo;
    XEPALOBJ palSrc(pxlo->ppalSrc);
    XEPALOBJ palDst(pxlo->ppalDst);
    LONG lSrcSkip = psb->lDeltaSrc - (cx * 4);
    LONG lDstSkip = psb->lDeltaDst - (cx * 3);
    PFN_pfnXlate pfnXlate;
    ULONG cStartPixels;
    ULONG cMiddlePixels;
    ULONG cEndPixels;
    ULONG ul;
    ULONG ul0;
    ULONG ul1;
    LONG i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    if (palSrc.bIsBGR() && palDst.bIsBGR())
    {
        // 'cStartPixels' is the minimum number of 3-byte pixels we'll have to
        // write before we have dword alignment on the destination:

        cStartPixels = (ULONG)((ULONG_PTR) pjDst) & 3;

        if (cStartPixels > cx)
        {
            cStartPixels = cx;
        }
        cx -= cStartPixels;

        cMiddlePixels = cx >> 2;
        cEndPixels = cx & 3;

        while (1)
        {
            for (i = cStartPixels; i != 0; i--)
            {
                *(pjDst)     = *(pjSrc);
                *(pjDst + 1) = *(pjSrc + 1);
                *(pjDst + 2) = *(pjSrc + 2);

                pjSrc += 4;
                pjDst += 3;
            }

            for (i = cMiddlePixels; i != 0; i--)
            {
                ul0 = *((ULONG *) (pjSrc));
                ul1 = *((ULONG *) (pjSrc + 4));

                *((ULONG*) (pjDst)) = (ul0 & 0xffffff) | (ul1 << 24);

                ul0 = *((ULONG *) (pjSrc + 8));

                *((ULONG*) (pjDst + 4)) = ((ul1 >> 8) & 0xffff) | (ul0 << 16);

                ul1 = *((ULONG *) (pjSrc + 12));

                *((ULONG*) (pjDst + 8)) = (ul1 << 8) | ((ul0 >> 16) & 0xff);

                pjSrc += 16;
                pjDst += 12;
            }

            for (i = cEndPixels; i != 0; i--)
            {
                *(pjDst)     = *(pjSrc);
                *(pjDst + 1) = *(pjSrc + 1);
                *(pjDst + 2) = *(pjSrc + 2);

                pjSrc += 4;
                pjDst += 3;
            }

            if (--cy == 0)
                break;

            pjSrc += lSrcSkip;
            pjDst += lDstSkip;
        }

        VERIFYS32D24(psb);
        return;
    }

    pfnXlate = pxlo->pfnXlateBetweenBitfields();

    while (1)
    {
        i = cx;
        do {
            ul = pfnXlate(pxlo, *((ULONG*) pjSrc));

            *(pjDst)     = (BYTE) (ul);
            *(pjDst + 1) = (BYTE) (ul >> 8);
            *(pjDst + 2) = (BYTE) (ul >> 16);

            pjSrc += 4;
            pjDst += 3;

        } while (--i != 0);

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    VERIFYS32D24(psb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\srcblt4.cxx ===
/******************************Module*Header*******************************\
* Module Name: srcblt4.cxx
*
* This contains the bitmap simulation functions that blt to a 4 bit/pel
* DIB surface.
*
* Created: 07-Feb-1991 19:27:49
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/*******************Public*Routine*****************\
* vSrcCopyS1D4
*
* There are three main loops in this function.
*
* The first loop deals with the full bytes part of
* the Dst while fetching/shifting the matching 8 bits
* from the Src.
*
* The second loop deals with the starting pixels
* We use a dword mask here.
*
* The third loop deals with the Ending pixels
* We use a dword mask here.
*
* We use a 4 entry dword table to expand the
* Src bits.  We walk thru Src one byte at a time
* and expand the byte to 1 dword
*
* History:
* 17-Oct-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.
*
\**************************************************/


VOID vSrcCopyS1D4(PBLTINFO psb)
{
    BYTE  jSrc;    // holds a source byte
    BYTE  jDst;    // holds a dest byte
    INT   iSrc;    // bit position in the first Src byte
    INT   iDst;    // bit position in the first 8 Dst nibbles
    PBYTE pjDst;   // pointer to the Src bytes
    PBYTE pjSrc;   // pointer to the Dst bytes
    LONG  xSrcEnd = psb->xSrcEnd;
    LONG  cy;      // number of rows
    LONG  cx;      // number of pixels
    BYTE  jAlignL;  // alignment bits to the left
    BYTE  jAlignR;  // alignment bits to the right
    LONG  cFullBytes;  //number of full 8 bytes dealed with
    BOOL  bNextByte;
    LONG  xDstEnd;
    LONG  lDeltaDst;
    LONG  lDeltaSrc;
    BYTE  jB = (BYTE) (psb->pxlo->pulXlate[0]);
    BYTE  jF = (BYTE) (psb->pxlo->pulXlate[1]);
    BYTE  ajExpTable[4];
    INT   count;
    INT   i;
    BYTE  ajSrc[4];
    static ULONG aulStartMask[8] = {0XFFFFFFFF, 0XFFFFFF0F, 0XFFFFFF00,
                                 0XFFFF0F00, 0XFFFF0000, 0XFF0F0000,
                                 0XFF000000, 0X0F000000};
    static ULONG aulEndMask[8] = {0X00000000, 0X000000F0, 0X000000FF,
                               0X0000F0FF, 0X0000FFFF, 0X00F0FFFF,
                               0X00FFFFFF, 0XF0FFFFFF};
    ULONG ulMask;
    BOOL  bNextSrc=TRUE;

    // We assume we are doing left to right top to bottom blting
    ASSERTGDI(psb->xDir == 1, "vSrcCopyS1D4 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS1D4 - direction not up to down");
    ASSERTGDI(psb->cy != 0, "ERROR: Src Move cy == 0");

    //DbgPrint ("vsrccopys1d4\n");

    // Build table
    ajExpTable[0] = jB | (jB << 4);           // 0 0
    ajExpTable[1] = jF | (jB << 4);           // 0 1
    ajExpTable[2] = jB | (jF << 4);           // 1 0
    ajExpTable[3] = jF | (jF << 4);            //1 1

    //Get Src and Dst start positions
    iSrc = psb->xSrcStart & 0x0007;
    iDst = psb->xDstStart & 0x0007;

    // Checking alignment
    // If Src starting point is ahead of Dst
    if (iSrc < iDst)
        jAlignL = 8 - (iDst - iSrc);
    else
    // If Dst starting point is ahead of Src
        jAlignL = iSrc - iDst;

    jAlignR = 8 - jAlignL;

    cx=psb->cx;

    xDstEnd = psb->xDstStart + cx;

    lDeltaDst = psb->lDeltaDst;
    lDeltaSrc = psb->lDeltaSrc;

    // check if there is a next 8 nibbles
    bNextByte = !((xDstEnd>>3) ==
                 (psb->xDstStart>>3));

    if (bNextByte)
    {
        long iStrideSrc;
        long iStrideDst;
        PBYTE pjSrcEnd;  //pointer to the Last full Src byte

        // Get first Dst full 8 nibbles (1 dword expanding from
        // 1 Src byte)
        pjDst = psb->pjDst + (((psb->xDstStart+7)&~0x07)>>1);

        // Get the Src byte that matches the first Dst
        // full 8 nibbles
        pjSrc = psb->pjSrc + ((psb->xSrcStart+((8-iDst)&0x07)) >> 3);

        //Get the number of full bytes
        cFullBytes = (xDstEnd>>3)-((psb->xDstStart+7)>>3);

        //the increment to the full byte on the next scan line
        iStrideDst = lDeltaDst - cFullBytes*4;
        iStrideSrc = lDeltaSrc - cFullBytes;

        // deal with our special case
        cy = psb->cy;

        if (!jAlignL)
        {
            while (cy--)
            {
                pjSrcEnd = pjSrc+cFullBytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = *pjSrc++;

                    *pjDst = ajExpTable[(jSrc&0xC0)>>6];
                    *(pjDst+1) = ajExpTable[(jSrc&0x30)>>4];
                    *(pjDst+2) = ajExpTable[(jSrc&0x0C)>>2];
                    *(pjDst+3) = ajExpTable[jSrc&0x03];

                    pjDst +=4;
                }

                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }

        }   //end of if (!jAlignL)


        else  // if not aligned
        {
            BYTE jRem;     //remainder

            while (cy--)
            {
                jRem = *pjSrc << jAlignL;

                pjSrcEnd = pjSrc+cFullBytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = ((*(++pjSrc))>>jAlignR) | jRem;

                    *pjDst = ajExpTable[(jSrc&0xC0)>>6];
                    *(pjDst+1) = ajExpTable[(jSrc&0x30)>>4];
                    *(pjDst+2) = ajExpTable[(jSrc&0x0C)>>2];
                    *(pjDst+3) = ajExpTable[jSrc&0x03];

                    pjDst +=4;

                    //next remainder
                    jRem = *pjSrc << jAlignL;
                }

                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }
        } //else
    } //if
    // End of our dealing with the full bytes

    //Deal with the starting pixels
    if (iDst | !bNextByte)
    {
        //build our masks
        ulMask = aulStartMask[iDst];

        // if there are only one partial left byte,
        // the mask is special
        // for example, when we have 00111000 for
        // Dst
        if (!bNextByte)
        {
             ulMask &= aulEndMask[xDstEnd&0x0007];
        }

        bNextSrc = ((iSrc+cx)>8);

        pjDst = psb->pjDst + ((psb->xDstStart&~0x07)>>1);

        pjSrc = psb->pjSrc + (psb->xSrcStart>>3);

        cy = psb->cy;

        if (iSrc >= iDst)
        {
            if (bNextSrc)
            {
                 while (cy--)
                 {
                     jSrc = *pjSrc << jAlignL;
                     jSrc |= *(pjSrc+1) >> jAlignR;

                     ajSrc[0] = ajExpTable[(jSrc&0xC0)>>6];
                     ajSrc[1] = ajExpTable[(jSrc&0x30)>>4];
                     ajSrc[2] = ajExpTable[(jSrc&0x0C)>>2];
                     ajSrc[3] = ajExpTable[jSrc&0x03];

                     *(PULONG) ajSrc &= ulMask;

                     *(PULONG) pjDst = (*(PULONG)pjDst & ~ulMask) | *(PULONG) ajSrc;

                     pjDst += lDeltaDst;
                     pjSrc += lDeltaSrc;
                 }
             }
             else
             {
                 while (cy--)
                 {
                     jSrc = *pjSrc << jAlignL;

                     ajSrc[0] = ajExpTable[(jSrc&0xC0)>>6];
                     ajSrc[1] = ajExpTable[(jSrc&0x30)>>4];
                     ajSrc[2] = ajExpTable[(jSrc&0x0C)>>2];
                     ajSrc[3] = ajExpTable[jSrc&0x03];

                     *(PULONG) ajSrc &= ulMask;

                     *(PULONG) pjDst = (*(PULONG)pjDst & ~ulMask) | *(PULONG) ajSrc;

                     pjDst += lDeltaDst;
                     pjSrc += lDeltaSrc;
                 }
             }
        }
        else //if (iSrc < iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc >> jAlignR;

                ajSrc[0] = ajExpTable[(jSrc&0xC0)>>6];
                ajSrc[1] = ajExpTable[(jSrc&0x30)>>4];
                ajSrc[2] = ajExpTable[(jSrc&0x0C)>>2];
                ajSrc[3] = ajExpTable[jSrc&0x03];

                *(PULONG) ajSrc &= ulMask;

                *(PULONG) pjDst = (*(PULONG)pjDst & ~ulMask) | *(PULONG) ajSrc;

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
    }

    // Dealing with Ending pixels

    if ((xDstEnd & 0x0007)
        && bNextByte)
    {
        ulMask = aulEndMask[xDstEnd & 0x0007];

        pjDst = psb->pjDst + ((xDstEnd&~0x07)>>1);
        pjSrc = psb->pjSrc + ((psb->xSrcEnd-1) >>3);

        iSrc = (xSrcEnd-1) & 0x0007;
        iDst = (xDstEnd-1) & 0x0007;

        cy = psb->cy;

        if (iSrc >= iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << jAlignL;

                ajSrc[0] = ajExpTable[(jSrc&0xC0)>>6];
                ajSrc[1] = ajExpTable[(jSrc&0x30)>>4];
                ajSrc[2] = ajExpTable[(jSrc&0x0C)>>2];
                ajSrc[3] = ajExpTable[jSrc&0x03];

                *(PULONG) ajSrc &= ulMask;

                *(PULONG) pjDst = (*(PULONG) pjDst & ~ulMask) | *(PULONG) ajSrc;

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
        else //if (iSrc < iDst)
        {
            while (cy--)
            {
                jSrc = *(pjSrc-1) << jAlignL;

                jSrc |= *pjSrc >> jAlignR;

                ajSrc[0] = ajExpTable[(jSrc&0xC0)>>6];
                ajSrc[1] = ajExpTable[(jSrc&0x30)>>4];
                ajSrc[2] = ajExpTable[(jSrc&0x0C)>>2];
                ajSrc[3] = ajExpTable[jSrc&0x03];

                *(PULONG) ajSrc &= ulMask;

                *(PULONG) pjDst = (*(PULONG) pjDst & ~ulMask) | *(PULONG) ajSrc;

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
    }

}

/******************************Public*Routine******************************\
* vSrcCopyS4D4
*
* History:
*  09-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS4D4(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting
// Otherwise we would be in vSrcCopyS4D4Identity.

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS4D4 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS4D4 - direction not up to down");

    BYTE  jSrc;
    BYTE  jDst;
    LONG  iSrc;
    LONG  iDst;
    PBYTE pjDst;
    PBYTE pjSrc;
    PBYTE pjDstHolder  = psb->pjDst + (psb->xDstStart >> 1);
    PBYTE pjSrcHolder  = psb->pjSrc + (psb->xSrcStart >> 1);
    ULONG cy = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
    // Initialize all the variables

        pjDst  = pjDstHolder;
        pjSrc  = pjSrcHolder;

        iSrc = psb->xSrcStart;
        iDst = psb->xDstStart;

        {
            // If source and dest are not aligned we have to do
            // this the hard way
            //
            if ((iSrc ^ iDst) & 1)
            {
                LONG iCnt;
                iSrc = psb->xSrcEnd - iSrc;

                // if blt starts on odd nibble we need to update it
                //
                if ((iDst & 1) && iSrc)
                {
                    *pjDst = (*pjDst & 0xf0) | (BYTE)pulXlate[((*pjSrc >> 4) & 0x0f)];
                    pjDst++;
                    iSrc--;
                }
                // loop once per output byte (2 pixels)
                //
                iCnt = iSrc >> 1;
                while (--iCnt >= 0)
                {
                    *pjDst++ = ((BYTE)pulXlate[*pjSrc & 0x0f] << 4) |
                                (BYTE)pulXlate[(pjSrc[1] >> 4) & 0x0f];
                    pjSrc++;
                }
                // test if blt ends on odd nibble
                //
                if (iSrc & 1)
                    *pjDst = (*pjDst & 0x0f) | ((BYTE)pulXlate[*pjSrc & 0x0f] << 4);
            }
            // Source and Dest are aligned
            //
            else
            {
                LONG iCnt;
                iSrc = psb->xSrcEnd - iSrc;

                // if blt starts on odd nibble we need to update it
                //
                if ((iDst & 1) && iSrc)
                {
                    *pjDst = (*pjDst & 0xf0) | (BYTE)pulXlate[*pjSrc++ & 0x0f];
                    pjDst++;
                    iSrc--;
                }
                // loop once per output byte (2 pixels)
                //
                iCnt = iSrc >> 1;
                while (--iCnt >= 0)
                {
                    *pjDst++ = (BYTE)pulXlate[*pjSrc & 0x0f] |
                            ((BYTE)pulXlate[(*pjSrc & 0xf0) >> 4] << 4);
                    pjSrc++;
                }
                // test if blt ends on odd nibble
                //
                if (iSrc & 1)
                    *pjDst = (*pjDst & 0x0f) | ((BYTE)pulXlate[(*pjSrc >> 4) & 0x0f] << 4);
            }
        }

    // Check if we have anymore scanlines to do

        if (--cy)
        {
            pjSrcHolder += psb->lDeltaSrc;
            pjDstHolder += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS4D4Identity
*
* History:
*  09-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS4D4Identity(PBLTINFO psb)
{
    BYTE  jSrc;
    BYTE  jDst;
    LONG  iSrc;
    LONG  iDst;
    PBYTE pjDst;
    PBYTE pjSrc;
    PBYTE pjDstHolder = psb->pjDst + ((psb->xDstStart) >> 1);
    PBYTE pjSrcHolder = psb->pjSrc + ((psb->xSrcStart) >> 1);
    ULONG cy = psb->cy;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

#if MESSAGE_BLT
    DbgPrint("Now entering vSrcCopyS4D4Identity\n");
    DbgPrint("xdir: %ld  cy: %lu  xSrcStart %lu  xDstStart %lu xSrcEnd %lu \n",
             psb->xDir, cy, psb->xSrcStart, psb->xDstStart, psb->xSrcEnd);
#endif

    if (psb->xDir > 0)
    {
    // We're going left to right.

        while(1)
        {
        // Initialize all the variables

            pjDst  = pjDstHolder;
            pjSrc  = pjSrcHolder;

            iSrc = psb->xSrcStart;
            iDst = psb->xDstStart;
            // If source and dest are not aligned we have to do
            // this the hard way
            //
            if ((iSrc ^ iDst) & 1)
            {
                LONG iCnt;
                iSrc = psb->xSrcEnd - iSrc;

                // if blt starts on odd nibble we need to update it
                //
                if ((iDst & 1) && iSrc)
                {
                    *pjDst = (*pjDst & 0xf0) | ((*pjSrc >> 4) & 0x0f);
                    pjDst++;
                    iSrc--;
                }
                // loop once per output byte (2 pixels)
                //
                iCnt = iSrc >> 1;
                while (--iCnt >= 0)
                {
                    BYTE jSrc = *pjSrc++ << 4;
                    *pjDst++ = jSrc | ((*pjSrc >> 4) & 0x0f);
                }
                // test if blt ends on odd nibble
                //
                if (iSrc & 1)
                    *pjDst = (*pjDst & 0x0f) | (*pjSrc << 4);
            }
            // Source and Dest are aligned
            //
            else
            {
                iSrc = psb->xSrcEnd - iSrc;

                // if blt starts on odd nibble we need to update it
                //
                if ((iDst & 1) && iSrc)
                {
                    *pjDst = (*pjDst & 0xf0) | (*pjSrc++ & 0x0f);
                    pjDst++;
                    iSrc--;
                }
                // loop once per output byte (2 pixels)
                //
                RtlMoveMemory(pjDst,pjSrc,iSrc >> 1);

                // test if blt ends on odd nibble
                //
                if (iSrc & 1)
                {
                    iSrc >>= 1;
                    pjDst[iSrc] = (pjDst[iSrc] & 0x0f) | (pjSrc[iSrc] & 0xf0);
                }
            }
        // Check if we have anymore scanlines to do

            if (--cy)
            {
                pjSrcHolder += psb->lDeltaSrc;
                pjDstHolder += psb->lDeltaDst;
            }
            else
                break;
        }
    }
    else
    {
    // We're going right to left.  It must be on the same hsurf,
    // therefore must be an identity translation.

        ASSERTGDI(psb->pxlo->bIsIdentity(), "Error: S4D4 -xDir, non-ident xlate");

        while(1)
        {
        // Initialize all the variables

            pjDst  = pjDstHolder;
            pjSrc  = pjSrcHolder;

            iSrc = psb->xSrcStart;
            iDst = psb->xDstStart;

            if (!(iSrc & 0x00000001))
            {
                jSrc = *pjSrc;
                pjSrc--;
            }

            if (iDst & 0x00000001)
            {
                jDst = 0;
            }
            else
            {
            // We're gonna need the low nibble from the first byte

                jDst = *pjDst;
		        jDst = (BYTE) (jDst & 0x0F);
            }

        // Do the inner loop on a scanline

            while(iSrc != psb->xSrcEnd)
            {
                if (iSrc & 0x00000001)
                {
                // We need a new source byte

                    jSrc = *pjSrc;
                    pjSrc--;

                    if (iDst & 0x00000001)
                    {
                    // jDst must be 0 right now.

                        ASSERTGDI(jDst == (BYTE) 0, "ERROR in vSrcCopyS4D4 srcblt logic");

                        jDst |= (BYTE) (jSrc & 0x0F);
                    }
                    else
                    {
                        jDst |= (BYTE) (((ULONG) (jSrc & 0x0F)) << 4);
                        *pjDst = jDst;
                        pjDst--;
                        jDst = 0;
                    }
                }
                else
                {
                    if (iDst & 0x00000001)
                    {
                    // jDst must be 0 right now.

                        ASSERTGDI(jDst == (BYTE) 0, "ERROR in vSrcCopyS4D4 srcblt logic");

                        jDst |= (BYTE) ((jSrc & 0xF0) >> 4);
                    }
                    else
                    {
                        jDst |= (BYTE) (jSrc & 0xF0);
                        *pjDst = jDst;
                        pjDst--;
                        jDst = 0;
                    }
                }

                iSrc--;
                iDst--;
            }

        // Clean up after the inner loop.  We are going right to left.

            if (!(iDst & 0x00000001))
            {
            // The last pel was the low nibble, we need to get the high
            // nibble out of the bitmap and write then write the byte in.

		*pjDst = (BYTE) (jDst | (*pjDst & 0xF0));
            }

        // Check if we have anymore scanlines to do

            if (--cy)
            {
                pjSrcHolder += psb->lDeltaSrc;
                pjDstHolder += psb->lDeltaDst;
            }
            else
                break;
        }
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS8D4
*
*
* History:
*  Wed 23-Oct-1991 -by- Patrick Haluptzok [patrickh]
* optimize color translation
*
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D4(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS8D4 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS8D4 - direction not up to down");

    LONG  iDst;
    PBYTE pjSrc;
    PBYTE pjDst;
    LONG  iDstEnd = psb->xDstStart + psb->cx;
    PBYTE pjDstHolder  = psb->pjDst + (psb->xDstStart >> 1);
    PBYTE pjSrcHolder  = psb->pjSrc + psb->xSrcStart;
    ULONG cy = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
        pjDst  = pjDstHolder;
        pjSrc  = pjSrcHolder;

        iDst = psb->xDstStart;

        if (iDst & 0x00000001)
        {
        // Do the first byte if it's misaligned.

	    *pjDst = (BYTE) ((*pjDst) & 0xF0) | ((BYTE) pulXlate[*(pjSrc++)]);
            pjDst++;
            iDst++;
        }

        while(1)
        {
            if ((iDst + 1) < iDstEnd)
            {
            // Do a whole byte.

		*(pjDst++) = (BYTE) (pulXlate[*(pjSrc + 1)] |
				    (pulXlate[*pjSrc] << 4));

                pjSrc += 2;
                iDst += 2;
            }
            else
            {
            // Check and see if we have a byte left to do.

                if (iDst < iDstEnd)
                {
                // This is our last byte.  Save low nibble from Dst.

		    *pjDst = (BYTE) (((*pjDst) & 0x0F) |
			     ((BYTE) (pulXlate[*pjSrc] << 4)));
                }

                break;
            }
        }

        if (--cy)
        {
            pjSrcHolder += psb->lDeltaSrc;
            pjDstHolder += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS16D4
*
*
* History:
*  Sun 10-Feb-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS16D4(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D4 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D4 - direction not up to down");

    LONG  iDst;
    PUSHORT pusSrc;
    PBYTE pjDst;
    LONG  iDstEnd = psb->xDstStart + psb->cx;
    PBYTE pjDstHolder  = psb->pjDst + (psb->xDstStart >> 1);
    PUSHORT pusSrcHolder  = (PUSHORT) (psb->pjSrc + (psb->xSrcStart << 1));
    ULONG cy = psb->cy;
    XLATE *pxlo = psb->pxlo;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
        pjDst  = pjDstHolder;
        pusSrc  = pusSrcHolder;

        iDst = psb->xDstStart;

        if (iDst & 0x00000001)
        {
        // Do the first byte if it's misaligned.

	    *pjDst = (BYTE) ((*pjDst) & 0xF0) | ((BYTE) pxlo->ulTranslate(*(pusSrc++)));
            pjDst++;
            iDst++;
        }

        while(1)
        {
            if ((iDst + 1) < iDstEnd)
            {
            // Do a whole byte.

                *(pjDst++) = (BYTE) (pxlo->ulTranslate(*(pusSrc + 1)) |
                                    (pxlo->ulTranslate(*pusSrc) << 4));

                pusSrc += 2;
                iDst += 2;
            }
            else
            {
            // Check and see if we have a byte left to do.

                if (iDst < iDstEnd)
                {
                // This is our last byte.  Save low nibble from Dst.

		    *pjDst = (BYTE) ((*pjDst) & 0x0F) |
                             ((BYTE) (pxlo->ulTranslate(*pusSrc) << 4));
                }

                break;
            }
        }

        if (--cy)
        {
	    pusSrcHolder = (PUSHORT) (((PBYTE) pusSrcHolder) + psb->lDeltaSrc);
            pjDstHolder += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS24D4
*
*
* History:
*  Wed 23-Oct-1991 -by- Patrick Haluptzok [patrickh]
* optimize color translation
*
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

#define Translate32to4(ulPelTemp) ((ulPelLast == ulPelTemp) ? jPelLast : (jPelLast = (BYTE) pxlo->ulTranslate(ulPelLast = ulPelTemp)))

VOID vSrcCopyS24D4(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D4 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D4 - direction not up to down");

    LONG  iDst;
    ULONG ulPelTemp;   // variable to build src RGB's in.
    PBYTE pjSrc;
    PBYTE pjDst;
    LONG  iDstEnd = psb->xDstStart + psb->cx;
    PBYTE pjDstHolder  = psb->pjDst + (psb->xDstStart >> 1);
    PBYTE pjSrcHolder  = psb->pjSrc + (psb->xSrcStart * 3);
    ULONG cy = psb->cy;
    XLATE *pxlo = psb->pxlo;
    ULONG ulPelLast;  // This is the last pel in the src.
    BYTE  jPelLast;   // This is the last pel in the dst.
    BYTE  jDstTmp;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

// Initialize the cache

    ulPelLast = *(pjSrcHolder + 2);
    ulPelLast = ulPelLast << 8;
    ulPelLast |= (ULONG) *(pjSrcHolder + 1);
    ulPelLast = ulPelLast << 8;
    ulPelLast |= (ULONG) *pjSrcHolder;
    jPelLast = (BYTE) (pxlo->ulTranslate(ulPelLast));

// Just do it

    while(1)
    {
        pjDst  = pjDstHolder;
        pjSrc  = pjSrcHolder;

        iDst = psb->xDstStart;

        if (iDst & 0x00000001)
        {
        // Do the first byte if it's misaligned.

	    ulPelTemp = *(pjSrc + 2);
	    ulPelTemp = ulPelTemp << 8;
	    ulPelTemp |= (ULONG) *(pjSrc + 1);
	    ulPelTemp = ulPelTemp << 8;
	    ulPelTemp |= (ULONG) *pjSrc;

	    Translate32to4(ulPelTemp);
	    *pjDst = (BYTE) ((*pjDst) & 0xF0) | jPelLast;
            pjDst++;
	    iDst++;
            pjSrc += 3;
        }

        while(1)
        {
            if ((iDst + 1) < iDstEnd)
            {
            // Do a whole byte.

		ulPelTemp = (ULONG) *(pjSrc + 2);
		ulPelTemp = ulPelTemp << 8;
		ulPelTemp |= (ULONG) *(pjSrc + 1);
		ulPelTemp = ulPelTemp << 8;
		ulPelTemp |= (ULONG) *pjSrc;
		jDstTmp = Translate32to4(ulPelTemp);
		pjSrc += 3;

		ulPelTemp = (ULONG) *(pjSrc + 2);
		ulPelTemp = ulPelTemp << 8;
		ulPelTemp |= (ULONG) *(pjSrc + 1);
		ulPelTemp = ulPelTemp << 8;
		ulPelTemp |= (ULONG) *pjSrc;
		Translate32to4(ulPelTemp);

		*(pjDst++) = (BYTE) (jPelLast |
				    (jDstTmp << 4));

		pjSrc += 3;
                iDst += 2;
            }
            else
            {
            // Check and see if we have a byte left to do.

                if (iDst < iDstEnd)
                {
                // This is our last byte.  Save low nibble from Dst.

		    ulPelTemp = (ULONG) *(pjSrc + 2);
		    ulPelTemp = ulPelTemp << 8;
		    ulPelTemp |= (ULONG) *(pjSrc + 1);
		    ulPelTemp = ulPelTemp << 8;
		    ulPelTemp |= (ULONG) *pjSrc;

		    Translate32to4(ulPelTemp);

		    *pjDst = (BYTE) ((*pjDst) & 0x0F) |
				     ((BYTE) (jPelLast << 4));
                }

            // We are done with this scan

                break;
            }
        }

        if (--cy)
        {
            pjSrcHolder += psb->lDeltaSrc;
            pjDstHolder += psb->lDeltaDst;
        }
        else
            break;
    }
}


/******************************Public*Routine******************************\
* vSrcCopyS32D4
*
*
* History:
*  Wed 23-Oct-1991 -by- Patrick Haluptzok [patrickh]
* optimize color translation
*
*  Sun 10-Feb-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS32D4(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D4 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D4 - direction not up to down");

    LONG  iDst;
    PULONG pulSrc;
    PBYTE pjDst;
    LONG  iDstEnd = psb->xDstStart + psb->cx;
    PBYTE pjDstHolder  = psb->pjDst + (psb->xDstStart >> 1);
    PULONG pulSrcHolder  = (PULONG) (psb->pjSrc + (psb->xSrcStart << 2));
    ULONG cy = psb->cy;
    XLATE *pxlo = psb->pxlo;
    ULONG ulPelTemp;
    ULONG ulPelLast;  // This is the last pel in the src.
    BYTE  jPelLast;   // This is the last pel in the dst.
    BYTE  jDstTmp;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

// Initialize the cache

    ulPelLast = *pulSrcHolder;
    jPelLast = (BYTE) (pxlo->ulTranslate(ulPelLast));

// Just do it

    while(1)
    {
        pjDst  = pjDstHolder;
        pulSrc  = pulSrcHolder;

        iDst = psb->xDstStart;

        if (iDst & 0x00000001)
        {
	// Do the first byte if it's misaligned.

	    ulPelTemp = *(pulSrc++);
	    Translate32to4(ulPelTemp);
	    *pjDst = (BYTE) ((*pjDst) & 0xF0) | jPelLast;
            pjDst++;
            iDst++;
        }

        while(1)
        {
            if ((iDst + 1) < iDstEnd)
            {
	    // Do a whole byte.

		ulPelTemp = *(pulSrc++);
		jDstTmp = Translate32to4(ulPelTemp);
		ulPelTemp = *(pulSrc++);
		Translate32to4(ulPelTemp);

		*(pjDst++) = (BYTE) (jPelLast |
				    (jDstTmp << 4));

                iDst += 2;
            }
            else
            {
            // Check and see if we have a byte left to do.

                if (iDst < iDstEnd)
                {
                // This is our last byte.  Save low nibble from Dst.

		    ulPelTemp = *pulSrc;
		    Translate32to4(ulPelTemp);

		    *pjDst = (BYTE) ((*pjDst) & 0x0F) |
				     ((BYTE) (jPelLast << 4));
                }

                break;
            }
        }

        if (--cy)
        {
	    pulSrcHolder = (PULONG) (((PBYTE) pulSrcHolder) + psb->lDeltaSrc);
            pjDstHolder += psb->lDeltaDst;
        }
        else
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\srcblt32.cxx ===
/******************************Module*Header*******************************\
* Module Name: srcblt32.cxx
*
* This contains the bitmap simulation functions that blt to a 32 bit/pel
* DIB surface.
*
* Created: 07-Feb-1991 19:27:49
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/
#include "precomp.hxx"

// Turn off validations
#if 1

    // On free builds, don't call any verification code:

    #define VERIFYS16D32(psb)
    #define VERIFYS24D32(psb)

#else

    // On checked builds, verify the RGB conversions:

    VOID VERIFYS16D32(PBLTINFO psb)
    {
    // We assume we are doing left to right top to bottom blting

        ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D32 - direction not left to right");
        ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D32 - direction not up to down");

    // These are our holding variables

        PUSHORT pusSrcTemp;
        PULONG pulDstTemp;
        ULONG  cxTemp;
        PUSHORT pusSrc  = (PUSHORT) (psb->pjSrc + (2 * psb->xSrcStart));
        PULONG pulDst  = (PULONG) (psb->pjDst + (4 * psb->xDstStart));
        ULONG cx     = psb->cx;
        ULONG cy     = psb->cy;
        XLATE *pxlo = psb->pxlo;

        ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

        while(1)
        {
            pusSrcTemp  = pusSrc;
            pulDstTemp  = pulDst;
            cxTemp     = cx;

            while(cxTemp--)
            {
                if (*(pulDstTemp++) != pxlo->ulTranslate((ULONG) *(pusSrcTemp++)))
                    RIP("RGB mis-match");
            }

            if (--cy)
            {
                pusSrc = (PUSHORT) (((PBYTE) pusSrc) + psb->lDeltaSrc);
                pulDst = (PULONG) (((PBYTE) pulDst) + psb->lDeltaDst);
            }
            else
                break;
        }
    }

    VOID VERIFYS24D32(PBLTINFO psb)
    {
    // We assume we are doing left to right top to bottom blting

        ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D32 - direction not left to right");
        ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D32 - direction not up to down");

    // These are our holding variables

        ULONG ulDink;          // variable to dink around with the bytes in
        PBYTE pjSrcTemp;
        PULONG pulDstTemp;
        ULONG  cxTemp;
        PBYTE pjSrc  = psb->pjSrc + (3 * psb->xSrcStart);
        PULONG pulDst  = (PULONG) (psb->pjDst + (4 * psb->xDstStart));
        ULONG cx     = psb->cx;
        ULONG cy     = psb->cy;
        XLATE *pxlo = psb->pxlo;

        ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

        while(1)
        {

            pjSrcTemp  = pjSrc;
            pulDstTemp  = pulDst;
            cxTemp     = cx;

            while(cxTemp--)
            {
                ulDink = *(pjSrcTemp + 2);
                ulDink = ulDink << 8;
                ulDink |= (ULONG) *(pjSrcTemp + 1);
                ulDink = ulDink << 8;
                ulDink |= (ULONG) *pjSrcTemp;

                if (*pulDstTemp != pxlo->ulTranslate(ulDink))
                    RIP("RGB mis-match");
                pulDstTemp++;
                pjSrcTemp += 3;
            }

            if (--cy)
            {
                pjSrc += psb->lDeltaSrc;
                pulDst = (PULONG) (((PBYTE) pulDst) + psb->lDeltaDst);
            }
            else
                break;
        }
    }


#endif

/*******************Public*Routine*****************\
* vSrcCopyS1D32
*
* This function loops through all the lines copying
* each one in three phases according to source
* alignment. The outer loop in x loops through
* the bits in the incomplete bytes (which might
* happen in the begining or the end of the sequence).
* When it comes to the first full byte, it
* goes into an internal x loop that copies 8
* bytes at a time, avoiding some branches, and
* allowing the processor to paraleliza these
* instructions, since there are no dependencies.
*
*
* History:
* 17-Nov-1998 -by- Andre Matos [amatos]
* Wrote it.
*
\**************************************************/

VOID vSrcCopyS1D32(PBLTINFO psb)
{
    PBYTE  pjSrc;
    PBYTE  pjDst;
    ULONG  cx     = psb->cx;
    ULONG  cy     = psb->cy;
    PBYTE  pjSrcTemp;
    PULONG pjDstTemp;
    ULONG  cxTemp;
    BYTE   jSrc;
    ULONG  aulTable[2];
    BYTE   iPosSrc;

    // We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS1D32 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS1D32 - direction not up to down");

    // We shouldn't be called with an empty rectangle

    ASSERTGDI( cx != 0 && cy != 0, "vSrcCopyS1D32 - called with an empty rectangle");

    // Generate aulTable. 2 entries.

    aulTable[0] = (ULONG)(psb->pxlo->pulXlate[0]);
    aulTable[1] = (ULONG)(psb->pxlo->pulXlate[1]);

    pjSrc = psb->pjSrc + (psb->xSrcStart >> 3);
    pjDst = psb->pjDst + 4*psb->xDstStart;

    while(cy--)
    {
        pjSrcTemp  = pjSrc;
        pjDstTemp  = (PULONG)pjDst;
        cxTemp     = cx;

        iPosSrc    = (BYTE)(psb->xSrcStart & 0x07);

        if( !iPosSrc )
        {
            // Decrement this since it will be
            // incremented up front ahead
            pjSrcTemp--;
        }
        else
        {
            jSrc = *pjSrcTemp << iPosSrc;
        }

        while (cxTemp)
        {
            if (!iPosSrc)
            {
                pjSrcTemp++;
                if (cxTemp>=8)
                {
                    while(cxTemp>= 8)
                    {
                        jSrc = *pjSrcTemp;

                        pjDstTemp[0] = aulTable[jSrc >> 7];
                        pjDstTemp[1] = aulTable[(jSrc >> 6) & 1];
                        pjDstTemp[2] = aulTable[(jSrc >> 5) & 1];
                        pjDstTemp[3] = aulTable[(jSrc >> 4) & 1];
                        pjDstTemp[4] = aulTable[(jSrc >> 3) & 1];
                        pjDstTemp[5] = aulTable[(jSrc >> 2) & 1];
                        pjDstTemp[6] = aulTable[(jSrc >> 1) & 1];
                        pjDstTemp[7] = aulTable[(jSrc & 1)];

                        pjSrcTemp++;
                        pjDstTemp += 8;
                        cxTemp -= 8;
                    }
                    pjSrcTemp--;
                    continue;
                }
                else
                {
                    jSrc = *pjSrcTemp;
                }
            }


            *pjDstTemp = aulTable[(jSrc >> 7) & 1];

            jSrc <<= 1;
            iPosSrc++;
            iPosSrc &= 7;
            pjDstTemp++;
            cxTemp--;
        }

        pjSrc = pjSrc + psb->lDeltaSrc;
        pjDst = pjDst + psb->lDeltaDst;

    }

}

/******************************Public*Routine******************************\
* vSrcCopyS4D32
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS4D32(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS4D32 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS4D32 - direction not up to down");

    BYTE  jSrc;
    LONG  i;
    PULONG pulDst;
    PBYTE pjSrc;
    PULONG pulDstHolder  = (PULONG) (psb->pjDst + (4 * psb->xDstStart));
    PBYTE pjSrcHolder  = psb->pjSrc + (psb->xSrcStart >> 1);
    ULONG cy = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
        pulDst  = pulDstHolder;
        pjSrc  = pjSrcHolder;

        i = psb->xSrcStart;

        if (i & 0x00000001)
            jSrc = *(pjSrc++);

        while(i != psb->xSrcEnd)
        {
            if (i & 0x00000001)
                *(pulDst++) = pulXlate[jSrc & 0x0F];
            else
            {
            // We need a new byte

                jSrc = *(pjSrc++);
                *(pulDst++) = pulXlate[(((ULONG) (jSrc & 0xF0)) >> 4)];
            }

            ++i;
        }

        if (--cy)
        {
            pjSrcHolder += psb->lDeltaSrc;
            pulDstHolder = (PULONG) (((PBYTE) pulDstHolder) + psb->lDeltaDst);
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS8D32
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D32(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS8D32 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS8D32 - direction not up to down");

// These are our holding variables

    PBYTE pjSrcTemp;
    PULONG pulDstTemp;
    ULONG  cxTemp;
    PBYTE pjSrc  = psb->pjSrc + psb->xSrcStart;
    PULONG pulDst  = (PULONG) (psb->pjDst + (4 * psb->xDstStart));
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {

        pjSrcTemp  = pjSrc;
        pulDstTemp  = pulDst;
        cxTemp     = cx;

        while(cxTemp--)
        {
            *(pulDstTemp++) = pulXlate[((ULONG) *(pjSrcTemp++))];
        }

        if (--cy)
        {
            pjSrc += psb->lDeltaSrc;
            pulDst = (PULONG) (((PBYTE) pulDst) + psb->lDeltaDst);
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS16D32
*
*
* History:
*  07-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/
VOID vSrcCopyS16D32(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D32 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D32 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc = psb->pjSrc + (2 * psb->xSrcStart);
    PBYTE pjDst = psb->pjDst + (4 * psb->xDstStart);
    ULONG cx    = psb->cx;
    ULONG cy    = psb->cy;
    LONG lSrcSkip = psb->lDeltaSrc - (cx * 2);
    LONG lDstSkip = psb->lDeltaDst - (cx * 4);
    XLATE *pxlo = psb->pxlo;
    XEPALOBJ palSrc(pxlo->ppalSrc);
    XEPALOBJ palDst(pxlo->ppalDst);
    ULONG ul;
    ULONG ul0;
    ULONG ul1;
    LONG i;

    ASSERTGDI(cy != 0,
        "ERROR: Src Move cy == 0");
    ASSERTGDI(palSrc.bIsBitfields(),
        "ERROR: destination not bitfields");

// First, try to optimize 5-6-5 to BGR:

    if ((palSrc.flBlu() == 0x001f) &&
        (palSrc.flGre() == 0x07e0) &&
        (palSrc.flRed() == 0xf800) &&
        (palDst.bIsBGR()))
    {
        while (1)
        {
            i = cx;
            do {
                ul = *((USHORT*) pjSrc);

                *((ULONG*) pjDst) = ((ul << 8) & 0xf80000)
                                  | ((ul << 3) & 0x070000)
                                  | ((ul << 5) & 0x00fc00)
                                  | ((ul >> 1) & 0x000300)
                                  | ((ul << 3) & 0x0000f8)
                                  | ((ul >> 2) & 0x000007);

                pjSrc += 2;
                pjDst += 4;

            } while (--i != 0);

            if (--cy == 0)
                break;

            pjSrc += lSrcSkip;
            pjDst += lDstSkip;
        }

        VERIFYS16D32(psb);
        return;
    }

// Next, try to optimize 5-5-5 to BGR:

    if ((palSrc.flBlu() == 0x001f) &&
        (palSrc.flGre() == 0x03e0) &&
        (palSrc.flRed() == 0x7c00) &&
        (palDst.bIsBGR()))
    {
        while (1)
        {
            i = cx;
            do {
                ul = *((USHORT*) pjSrc);

                *((ULONG*) pjDst) = ((ul << 9) & 0xf80000)
                                  | ((ul << 4) & 0x070000)
                                  | ((ul << 6) & 0x00f800)
                                  | ((ul << 1) & 0x000700)
                                  | ((ul << 3) & 0x0000f8)
                                  | ((ul >> 2) & 0x000007);
                pjSrc += 2;
                pjDst += 4;

            } while (--i != 0);

            if (--cy == 0)
                break;

            pjSrc += lSrcSkip;
            pjDst += lDstSkip;
        }

        VERIFYS16D32(psb);
        return;
    }

// Finally, fall back to the generic case:

    while (1)
    {
        i = cx;
        do {
            *((ULONG*) pjDst) = pxlo->ulTranslate(*((USHORT*) pjSrc));
            pjSrc += 2;
            pjDst += 4;

        } while (--i != 0);

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    VERIFYS16D32(psb);
}

/******************************Public*Routine******************************\
* vSrcCopyS24D32
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS24D32(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D32 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D32 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + (3 * psb->xSrcStart);
    PBYTE pjDst  = psb->pjDst + (4 * psb->xDstStart);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    LONG lSrcSkip = psb->lDeltaSrc - (cx * 3);
    LONG lDstSkip = psb->lDeltaDst - (cx * 4);
    PFN_pfnXlate pfnXlate;
    XLATE *pxlo = psb->pxlo;
    XEPALOBJ palSrc(pxlo->ppalSrc);
    XEPALOBJ palDst(pxlo->ppalDst);
    ULONG ul;
    LONG i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

// Try to optimize BGR to BGR:

    if (palSrc.bIsBGR() && palDst.bIsBGR())
    {
        while (1)
        {
            i = cx;
            do {
                *((ULONG*) pjDst) = (*(pjSrc))
                                  | (*(pjSrc + 1) << 8)
                                  | (*(pjSrc + 2) << 16);
                pjDst += 4;
                pjSrc += 3;

            } while (--i != 0);

            if (--cy == 0)
                break;

            pjSrc += lSrcSkip;
            pjDst += lDstSkip;
        }

        VERIFYS24D32(psb);
        return;
    }

// Fall back to the generic case:

    pfnXlate = pxlo->pfnXlateBetweenBitfields();

    while (1)
    {
        i = cx;

        do {
            ul = ((ULONG) *(pjSrc))
               | ((ULONG) *(pjSrc + 1) << 8)
               | ((ULONG) *(pjSrc + 2) << 16);

            *((ULONG*) pjDst) = pfnXlate(pxlo, ul);
            pjDst += 4;
            pjSrc += 3;

        } while (--i != 0);

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    VERIFYS24D32(psb);
}

/******************************Public*Routine******************************\
* vSrcCopyS32D32
*
*
* History:
*  07-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/
VOID vSrcCopyS32D32(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting.
// If it was on the same surface it would be the identity case.

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D32 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D32 - direction not up to down");

// These are our holding variables

    PULONG pulSrcTemp;
    PULONG pulDstTemp;
    ULONG  cxTemp;
    PULONG pulSrc  = (PULONG) (psb->pjSrc + (4 * psb->xSrcStart));
    PULONG pulDst  = (PULONG) (psb->pjDst + (4 * psb->xDstStart));
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    XLATE *pxlo = psb->pxlo;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {

        pulSrcTemp  = pulSrc;
        pulDstTemp  = pulDst;
        cxTemp     = cx;

        while(cxTemp--)
        {
            *(pulDstTemp++) = pxlo->ulTranslate(*(pulSrcTemp++));
        }

        if (--cy)
        {
            pulSrc = (PULONG) (((PBYTE) pulSrc) + psb->lDeltaSrc);
            pulDst = (PULONG) (((PBYTE) pulDst) + psb->lDeltaDst);
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS32D32Identity
*
* This is the special case no translate blting.  All the SmDn should have
* them if m==n.  Identity xlates only occur amoung matching format bitmaps.
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS32D32Identity(PBLTINFO psb)
{
// These are our holding variables

    PULONG pulSrc  = (PULONG) (psb->pjSrc + (4 * psb->xSrcStart));
    PULONG pulDst  = (PULONG) (psb->pjDst + (4 * psb->xDstStart));
    ULONG  cx      = psb->cx;
    ULONG  cy      = psb->cy;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    if (psb->xDir < 0)
    {
        pulSrc -= (cx - 1);
        pulDst -= (cx - 1);
    }

    cx = cx << 2;

    while(1)
    {
        if(psb->fSrcAlignedRd)
            vSrcAlignCopyMemory((PBYTE)pulDst, (PBYTE)pulSrc, cx);
        else
            RtlMoveMemory((PVOID)pulDst, (PVOID)pulSrc, cx);

        if (--cy)
        {
            pulSrc = (PULONG) (((PBYTE) pulSrc) + psb->lDeltaSrc);
            pulDst = (PULONG) (((PBYTE) pulDst) + psb->lDeltaDst);
        }
        else
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\stretch.cxx ===
/******************************Module*Header*******************************\
* Module Name: stretch.cxx
*
* Internal DDAs for EngStretchBlt
*
* Created: 16-Feb-1993 15:35:02
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "stretch.hxx"

#ifdef DBG_STRBLT
extern BOOL gflStrBlt;
#endif

static VOID STR_DIV(
DIV_T *pdt,
LONG   lNum,
LONG   lDen)
{
    if (lNum < 0)
    {
        lNum = - (lNum + 1);
        pdt->lQuo = lNum / lDen;
        pdt->lRem = lNum % lDen;
        pdt->lQuo = - (pdt->lQuo + 1);
        pdt->lRem = lDen - pdt->lRem - 1;
    }
    else
    {
        pdt->lQuo = lNum / lDen;
        pdt->lRem = lNum % lDen;
    }

#ifdef DBG_STRBLT
    if (gflStrBlt & STRBLT_SHOW_INIT)
    DbgPrint("%ld / %ld = %ld R %ld\n", lNum, lDen, pdt->lQuo, pdt->lRem);
#endif
}

/******************************Public*Routine******************************\
* VOID vInitStrDDA(pdda, prclScan, prclSrc, prclTrg)
*
* Initialize the DDA
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vInitStrDDA(
STRDDA *pdda,
RECTL  *prclScan,
RECTL  *prclSrc,
RECTL  *prclTrg)
{
    RECTL   rclScan;
    RECTL   rclSrc;

// If the source surface does not have a 0,0 origin, deal with it here.

    if ((prclSrc->left != 0) || (prclSrc->top != 0))
    {
        rclScan.left   = prclScan->left   - prclSrc->left;
        rclScan.top    = prclScan->top    - prclSrc->top;
        rclScan.right  = prclScan->right  - prclSrc->left;
        rclScan.bottom = prclScan->bottom - prclSrc->top;
    prclScan = &rclScan;

        rclSrc.left   = 0;
        rclSrc.top    = 0;
        rclSrc.right  = prclSrc->right - prclSrc->left;
        rclSrc.bottom = prclSrc->bottom - prclSrc->top;
        prclSrc = &rclSrc;
    }

#ifdef DBG_STRBLT
    if (gflStrBlt & STRBLT_SHOW_INIT)
    {
    DbgPrint("prclScan = [(%ld,%ld) (%ld,%ld)]\n",
          prclScan->left, prclScan->top, prclScan->right, prclScan->bottom);

        DbgPrint("prclSrc = [(%ld,%ld) (%ld,%ld)]\n",
                  prclSrc->left, prclSrc->top, prclSrc->right, prclSrc->bottom);

        DbgPrint("prclTrg = [(%ld,%ld) (%ld,%ld)]\n",
                  prclTrg->left, prclTrg->top, prclTrg->right, prclTrg->bottom);
    }
#endif

    pdda->plYStep = &pdda->al[prclSrc->right];

    DDA_STEP dQnext;    // increment on position of next pixel image
    DIV_T    Qnext;     // starting position of next pixel image
    LONG     lQ;        // current positon
    LONG     iLoop;
    LONG     j;


//
// x-coordinates
//

    STR_DIV(&dQnext.dt, prclTrg->right - prclTrg->left, prclSrc->right);
    dQnext.lDen = prclSrc->right;

    Qnext.lQuo = dQnext.dt.lQuo;
    Qnext.lRem = dQnext.dt.lRem + ((dQnext.lDen - 1)>>1);
    if (Qnext.lRem >= dQnext.lDen)
    {
        Qnext.lQuo += 1;
        Qnext.lRem -= dQnext.lDen;
    }

    for (lQ = 0, iLoop = 0; iLoop < prclScan->left; iLoop++)
    {
        lQ = Qnext.lQuo;
        DDA(&Qnext, &dQnext);
    }

    pdda->rcl.left = lQ + prclTrg->left;
    for (j = 0; iLoop < prclScan->right; iLoop++, j++)
    {
        pdda->al[j] = Qnext.lQuo - lQ;
        lQ = Qnext.lQuo;
        DDA(&Qnext, &dQnext);
    }
    pdda->rcl.right = lQ + prclTrg->left;

//
// y-coordinates
//
    STR_DIV(&dQnext.dt, prclTrg->bottom - prclTrg->top, prclSrc->bottom);
    dQnext.lDen = prclSrc->bottom;

    Qnext.lQuo = dQnext.dt.lQuo;
    Qnext.lRem = dQnext.dt.lRem + ((dQnext.lDen - 1)>>1);
    if (Qnext.lRem >= dQnext.lDen)
    {
        Qnext.lQuo += 1;
        Qnext.lRem -= dQnext.lDen;
    }

    for (lQ = 0, iLoop = 0; iLoop < prclScan->top; iLoop++)
    {
        lQ = Qnext.lQuo;
        DDA(&Qnext, &dQnext);
    }

    pdda->rcl.top = lQ + prclTrg->top;
    for (j = 0; iLoop < prclScan->bottom; iLoop++, j++)
    {
        pdda->plYStep[j] = Qnext.lQuo - lQ;
        lQ = Qnext.lQuo;
        DDA(&Qnext, &dQnext);
    }
    pdda->rcl.bottom = lQ + prclTrg->top;

#ifdef DBG_STRBLT
    if (gflStrBlt & STRBLT_SHOW_INIT)
        DbgPrint("XStep @%08lx, YStep @%08lx\n", (ULONG) pdda->al, (ULONG) pdda->plYStep);
#endif
}

/******************************Public*Routine******************************\
* VOID vInitBuffer(prun, ercl, iMode)
*
* Initialize the run buffer for overwrite modes
*
* History:
*  27-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vInitBuffer(
STRRUN *prun,
RECTL  *prcl,
ULONG   iOver)
{
    prun->xrl.xPos = prcl->left;
    prun->xrl.cRun = prcl->right - prcl->left;

    RtlFillMemoryUlong((VOID *) &prun->xrl.aul[0], prun->xrl.cRun << 2, iOver);
}

static ULONG gaulMaskEdge[] =
{
    0xFFFFFFFF, 0xFFFFFF7F, 0xFFFFFF3F, 0xFFFFFF1F,
    0xFFFFFF0F, 0xFFFFFF07, 0xFFFFFF03, 0xFFFFFF01,
    0xFFFFFF00, 0xFFFF7F00, 0xFFFF3F00, 0xFFFF1F00,
    0xFFFF0F00, 0xFFFF0700, 0xFFFF0300, 0xFFFF0100,
    0xFFFF0000, 0xFF7F0000, 0xFF3F0000, 0xFF1F0000,
    0xFF0F0000, 0xFF070000, 0xFF030000, 0xFF010000,
    0xFF000000, 0x7F000000, 0x3F000000, 0x1F000000,
    0x0F000000, 0x07000000, 0x03000000, 0x01000000
};

static ULONG gaulMaskMono[] =
{
    0x00000080, 0x00000040, 0x00000020, 0x00000010,
    0x00000008, 0x00000004, 0x00000002, 0x00000001,
    0x00008000, 0x00004000, 0x00002000, 0x00001000,
    0x00000800, 0x00000400, 0x00000200, 0x00000100,
    0x00800000, 0x00400000, 0x00200000, 0x00100000,
    0x00080000, 0x00040000, 0x00020000, 0x00010000,
    0x80000000, 0x40000000, 0x20000000, 0x10000000,
    0x08000000, 0x04000000, 0x02000000, 0x01000000
};

static ULONG gaulShftMono[] =
{
    0x00000007, 0x00000006, 0x00000005, 0x00000004,
    0x00000003, 0x00000002, 0x00000001, 0x00000000,
    0x0000000F, 0x0000000E, 0x0000000D, 0x0000000C,
    0x0000000B, 0x0000000A, 0x00000009, 0x00000008,
    0x00000017, 0x00000016, 0x00000015, 0x00000014,
    0x00000013, 0x00000012, 0x00000011, 0x00000010,
    0x0000001F, 0x0000001E, 0x0000001D, 0x0000001C,
    0x0000001B, 0x0000001A, 0x00000019, 0x00000018
};

static ULONG gaulMaskQuad[] =
{
    0x000000F0, 0x0000000F, 0x0000F000, 0x00000F00,
    0x00F00000, 0x000F0000, 0xF0000000, 0x0F000000
};

static ULONG gaulShftQuad[] =
{
    0x00000004, 0x00000000, 0x0000000C, 0x00000008,
    0x00000014, 0x00000010, 0x0000001C, 0x00000018
};

/******************************Public*Routine******************************\
* VOID vStrMirror01(pSurf)
*
* Mirror the 1BPP surface in X.
*
* History:
*  08-Mar-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrMirror01(SURFACE *pSurf)
{
    ULONG  *pulBase;
    ULONG  *pulSrc;
    ULONG  *pulTrg;
    ULONG   ulSrc;
    ULONG   ulTrg;
    ULONG   ulSwp;
    ULONG   ulTmp;
    LONG    cFlip;
    LONG    cLeft;
    LONG    cRght;
    LONG    iLeft;
    LONG    iRght;
    LONG    x;
    LONG    y;

    pulBase = (ULONG *) pSurf->pvScan0();
    cFlip   = pSurf->sizl().cx / 2;

    for (y = 0; y < pSurf->sizl().cy; y++)
    {
        iLeft  = 0;
        cLeft  = 0;
        iRght  = pSurf->sizl().cx - 1;
        cRght  = iRght >> 5;
        iRght &= 31;

        pulSrc = pulBase;
        pulTrg = pulSrc + cRght;

        ulSrc  = *pulSrc;
        ulTrg  = *pulTrg;

        for (x = 0; x < cFlip; x++)
        {
            if (cLeft == cRght)
            {
                ulSwp = (ulSrc & gaulMaskMono[iLeft]) >> gaulShftMono[iLeft];
                ulTmp = (ulSrc & gaulMaskMono[iRght]) >> gaulShftMono[iRght];
                ulSrc = (ulSrc & ~gaulMaskMono[iLeft]) | (ulTmp << gaulShftMono[iLeft]);
                ulSrc = (ulSrc & ~gaulMaskMono[iRght]) | (ulSwp << gaulShftMono[iRght]);
            }
            else
            {
                ulSwp = (ulSrc & gaulMaskMono[iLeft]) >> gaulShftMono[iLeft];
                ulTmp = (ulTrg & gaulMaskMono[iRght]) >> gaulShftMono[iRght];
                ulSrc = (ulSrc & ~gaulMaskMono[iLeft]) | (ulTmp << gaulShftMono[iLeft]);
                ulTrg = (ulTrg & ~gaulMaskMono[iRght]) | (ulSwp << gaulShftMono[iRght]);
            }

            iLeft++;
            iRght--;

            if (iLeft & 32)
            {
               *pulSrc = ulSrc;
                pulSrc++;
                cLeft++;

                if (cLeft == cRght)
                   *pulTrg = ulTrg;

                ulSrc = *pulSrc;
                iLeft = 0;
            }

            if (iRght < 0)
            {
               *pulTrg = ulTrg;
                pulTrg--;
                cRght--;

                if (cRght == cLeft)
                   *pulSrc = ulSrc;
                else
                    ulTrg = *pulTrg;

                iRght = 31;
            }
    }

       *pulSrc = ulSrc;

    if (cLeft != cRght)
       *pulTrg = ulTrg;

        pulBase = (ULONG *) (((BYTE *) pulBase) + pSurf->lDelta());
    }
}

/******************************Public*Routine******************************\
* VOID vStrMirror04(pSurf)
*
* Mirror the 4BPP surface in X.
*
* History:
*  08-Mar-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrMirror04(SURFACE *pSurf)
{
    ULONG  *pulBase;
    ULONG  *pulSrc;
    ULONG  *pulTrg;
    ULONG   ulSrc;
    ULONG   ulTrg;
    ULONG   ulSwp;
    ULONG   ulTmp;
    LONG    cFlip;
    LONG    cLeft;
    LONG    cRght;
    LONG    iLeft;
    LONG    iRght;
    LONG    x;
    LONG    y;

    pulBase = (ULONG *) pSurf->pvScan0();
    cFlip   = pSurf->sizl().cx / 2;

    for (y = 0; y < pSurf->sizl().cy; y++)
    {
        iLeft  = 0;
        cLeft  = 0;
        iRght  = pSurf->sizl().cx - 1;
        cRght  = iRght >> 3;
        iRght &= 7;

        pulSrc = pulBase;
        pulTrg = pulSrc + cRght;

        ulSrc  = *pulSrc;
        ulTrg  = *pulTrg;

        for (x = 0; x < cFlip; x++)
        {
            if (cLeft == cRght)
            {
                ulSwp = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];
                ulTmp = (ulSrc & gaulMaskQuad[iRght]) >> gaulShftQuad[iRght];
                ulSrc = (ulSrc & ~gaulMaskQuad[iLeft]) | (ulTmp << gaulShftQuad[iLeft]);
                ulSrc = (ulSrc & ~gaulMaskQuad[iRght]) | (ulSwp << gaulShftQuad[iRght]);
            }
            else
            {
                ulSwp = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];
                ulTmp = (ulTrg & gaulMaskQuad[iRght]) >> gaulShftQuad[iRght];
                ulSrc = (ulSrc & ~gaulMaskQuad[iLeft]) | (ulTmp << gaulShftQuad[iLeft]);
                ulTrg = (ulTrg & ~gaulMaskQuad[iRght]) | (ulSwp << gaulShftQuad[iRght]);
            }

            iLeft++;
            iRght--;

            if (iLeft & 8)
            {
               *pulSrc = ulSrc;
                pulSrc++;
                cLeft++;

                if (cLeft == cRght)
                   *pulTrg = ulTrg;

                ulSrc = *pulSrc;
                iLeft = 0;
            }

            if (iRght < 0)
            {
               *pulTrg = ulTrg;
                pulTrg--;
                cRght--;

                if (cRght == cLeft)
                   *pulSrc = ulSrc;
                else
                    ulTrg = *pulTrg;

                iRght = 7;
        }

       *pulSrc = ulSrc;

    if (cLeft != cRght)
       *pulTrg = ulTrg;

    }

        pulBase = (ULONG *) (((BYTE *) pulBase) + pSurf->lDelta());
    }
}

/******************************Public*Routine******************************\
* VOID vStrMirror08(pSurf)
*
* Mirror the 8BPP surface in X.
*
* History:
*  08-Mar-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrMirror08(SURFACE *pSurf)
{
    BYTE   *pjSrc;
    BYTE   *pjTrg;
    BYTE   *pjBase;
    BYTE    jTemp;
    LONG    cFlip;
    LONG    x;
    LONG    y;

    pjBase = (BYTE *) pSurf->pvScan0();
    cFlip  = pSurf->sizl().cx / 2;

    for (y = 0; y < pSurf->sizl().cy; y++)
    {
        pjSrc = pjBase;
        pjTrg = pjSrc + pSurf->sizl().cx - 1;

        for (x = 0; x < cFlip; x++)
        {
            jTemp = *pjSrc;
           *pjSrc = *pjTrg;
           *pjTrg =  jTemp;
            pjSrc++;
            pjTrg--;
        }

        pjBase += pSurf->lDelta();
    }
}

/******************************Public*Routine******************************\
* VOID vStrMirror16(pSurf)
*
* Mirror the 16BPP surface in X.
*
* History:
*  08-Mar-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrMirror16(SURFACE *pSurf)
{
    WORD   *pwSrc;
    WORD   *pwTrg;
    WORD   *pwBase;
    WORD    wTemp;
    LONG    cFlip;
    LONG    x;
    LONG    y;

    pwBase = (WORD *) pSurf->pvScan0();
    cFlip  = pSurf->sizl().cx / 2;

    for (y = 0; y < pSurf->sizl().cy; y++)
    {
        pwSrc = pwBase;
        pwTrg = pwSrc + pSurf->sizl().cx - 1;

        for (x = 0; x < cFlip; x++)
        {
            wTemp = *pwSrc;
           *pwSrc = *pwTrg;
           *pwTrg =  wTemp;
            pwSrc++;
            pwTrg--;
        }

        pwBase = (WORD *) (((BYTE *) pwBase) + pSurf->lDelta());
    }
}

/******************************Public*Routine******************************\
* VOID vStrMirror24(pSurf)
*
* Mirror the 24BPP surface in X.
*
* History:
*  08-Mar-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrMirror24(SURFACE *pSurf)
{
    RGBTRIPLE  *prgbSrc;
    RGBTRIPLE  *prgbTrg;
    RGBTRIPLE  *prgbBase;
    RGBTRIPLE   rgbTemp;
    LONG        cFlip;
    LONG        x;
    LONG        y;

    prgbBase = (RGBTRIPLE *) pSurf->pvScan0();
    cFlip    = pSurf->sizl().cx / 2;

    for (y = 0; y < pSurf->sizl().cy; y++)
    {
        prgbSrc = prgbBase;
        prgbTrg = prgbSrc + pSurf->sizl().cx - 1;

        for (x = 0; x < cFlip; x++)
        {
            rgbTemp = *prgbSrc;
           *prgbSrc = *prgbTrg;
           *prgbTrg =  rgbTemp;
            prgbSrc++;
            prgbTrg--;
        }

        prgbBase = (RGBTRIPLE *) (((BYTE *) prgbBase) + pSurf->lDelta());
    }
}

/******************************Public*Routine******************************\
* VOID vStrMirror32(pSurf)
*
* Mirror the 32BPP surface in X.
*
* History:
*  08-Mar-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrMirror32(SURFACE *pSurf)
{
    DWORD  *pdwSrc;
    DWORD  *pdwTrg;
    DWORD  *pdwBase;
    DWORD   dwTemp;
    LONG    cFlip;
    LONG    x;
    LONG    y;

    pdwBase = (DWORD *) pSurf->pvScan0();
    cFlip   = pSurf->sizl().cx / 2;

    for (y = 0; y < pSurf->sizl().cy; y++)
    {
        pdwSrc = pdwBase;
        pdwTrg = pdwSrc + pSurf->sizl().cx - 1;

        for (x = 0; x < cFlip; x++)
        {
            dwTemp = *pdwSrc;
           *pdwSrc = *pdwTrg;
           *pdwTrg =  dwTemp;
            pdwSrc++;
            pdwTrg--;
        }

        pdwBase = (DWORD *) (((BYTE *) pdwBase) + pSurf->lDelta());
    }
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead01AND(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, AND the pels and produce a run
* list for a row of a 1BPP surface.
*
* History:
*  27-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead01AND(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    ULONG   *pulSrc;
    ULONG    ulSrc;
    ULONG    iBlack;
    ULONG    iWhite;
    LONG     cLeft;
    LONG     iLeft;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    cLeft = xLeft >> 5;             // Index of leftmost DWORD
    iLeft = xLeft & 31;             // Bits used in leftmost DWORD
    pulSrc = ((DWORD *) pjSrc) + cLeft;     // Adjust base address

// To prevent derefences of the XLATE, do it upfront.  We can easily do
// this on monochrome bitmaps.

    if (pxlo == NULL)
    {
    iBlack = 0;
    iWhite = 1;
    }
    else
    {
    iBlack = pxlo->pulXlate[0];
    iWhite = pxlo->pulXlate[1];
    }

    i = 0;
    j = 0;
    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pxrl->xPos;
    ulSrc = *pulSrc;

    if (xLeft < xRght)
    {
        while (TRUE)
        {
            if (!(ulSrc & gaulMaskMono[iLeft]))
            {
                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] &= iBlack;
                else
                    while (cnt--)
                        pxrl->aul[j++] &= iBlack;
            }
            else
            {
                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] &= iWhite;
                else
                    while (cnt--)
                        pxrl->aul[j++] &= iWhite;
            }

            xLeft++;
            iLeft++;

            if (xLeft >= xRght)
                break;

            if (iLeft & 32)
            {
                pulSrc++;
                ulSrc = *pulSrc;
                iLeft = 0;
            }
        }
    }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead04AND(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, AND the pels and produce a run
* list for a row of a 4BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead04AND(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    ULONG   *pulSrc;
    ULONG    ulSrc;
    ULONG    iColor;
    LONG     cLeft;
    LONG     iLeft;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    cLeft  =  xLeft >> 3;                   // Index of leftmost DWORD
    iLeft  =  xLeft & 7;                    // Nybbles used in leftmost DWORD
    pulSrc =  ((DWORD *) pjSrc) + cLeft;    // Adjust base address
    ulSrc  = *pulSrc;

    i = 0;
    j = 0;
    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pxrl->xPos;

    if (pxlo == NULL)
    {
        if (xLeft < xRght)
        {
            while (TRUE)
            {
                iColor = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];

                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] &= iColor;
                else
                    while (cnt--)
                        pxrl->aul[j++] &= iColor;

                xLeft++;
                iLeft++;

                if (xLeft >= xRght)
                    break;

                if (iLeft & 8)
                {
                    pulSrc++;
                    ulSrc = *pulSrc;
                    iLeft = 0;
                }
            }
        }
    }
    else
    {
        if (xLeft < xRght)
        {
            while (TRUE)
            {
                iColor = pxlo->pulXlate[(ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft]];

                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] &= iColor;
                else
                    while (cnt--)
                        pxrl->aul[j++] &= iColor;

                xLeft++;
                iLeft++;

                if (xLeft >= xRght)
                    break;

                if (iLeft & 8)
                {
                    pulSrc++;
                    ulSrc = *pulSrc;
                    iLeft = 0;
                }
        }
    }
    }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead08AND(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, AND the pels and produce a run
* list for a row of a 8BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead08AND(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    pjSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo == NULL)
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] &= *pjSrc;
        else
        while (cnt--)
            pxrl->aul[j++] &= *pjSrc;

            pjSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
    {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] &= pxlo->pulXlate[*pjSrc];
        else
        while (cnt--)
            pxrl->aul[j++] &= pxlo->pulXlate[*pjSrc];

            pjSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead16AND(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, AND the pels and produce a run
* list for a row of a 16BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead16AND(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    WORD    *pwSrc = (WORD *) pjSrc;
    ULONG    ulTmp;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    pwSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo == NULL)
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] &= *pwSrc;
        else
        while (cnt--)
            pxrl->aul[j++] &= *pwSrc;

        pwSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
        {
        cnt   = pdda->al[i++];
            ulTmp = ((XLATE *) pxlo)->ulTranslate((ULONG) *pwSrc);

        if (!cnt)
        pxrl->aul[j] &= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] &= ulTmp;


            pwSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead24AND(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, AND the pels and produce a run
* list for a row of a 24BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead24AND(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN   *pxrl = &prun->xrl;
    RGBTRIPLE *prgbSrc = (RGBTRIPLE *) pjSrc;
    ULONG      ulTmp = 0;
    LONG       cnt;
    LONG       i;
    LONG       j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    prgbSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo == NULL)
        while (xLeft != xRght)
        {
            *((RGBTRIPLE *) &ulTmp) = *prgbSrc;

        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] &= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] &= ulTmp;

            prgbSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        *((RGBTRIPLE *) &ulTmp) = *prgbSrc;
            ulTmp = ((XLATE *) pxlo)->ulTranslate(ulTmp);

        if (!cnt)
        pxrl->aul[j] &= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] &= ulTmp;

        prgbSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead32AND(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, AND the pels and produce a run
* list for a row of a 32BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead32AND(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    DWORD   *pdwSrc = (DWORD *) pjSrc;
    ULONG    ulTmp;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    pdwSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo == NULL)
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] &= *pdwSrc;
        else
        while (cnt--)
            pxrl->aul[j++] &= *pdwSrc;

            pdwSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
        {
            cnt = pdda->al[i++];
            ulTmp = ((XLATE *) pxlo)->ulTranslate((ULONG) *pdwSrc);

        if (!cnt)
        pxrl->aul[j] &= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] &= ulTmp;

        pdwSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead01OR(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, OR the pels and produce a run
* list for a row of a 1BPP surface.
*
* History:
*  27-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead01OR(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    ULONG   *pulSrc;
    ULONG    ulSrc;
    ULONG    iBlack;
    ULONG    iWhite;
    LONG     cLeft;
    LONG     iLeft;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    cLeft = xLeft >> 5;             // Index of leftmost DWORD
    iLeft = xLeft & 31;             // Bits used in leftmost DWORD
    pulSrc = ((DWORD *) pjSrc) + cLeft;     // Adjust base address

// To prevent derefences of the XLATE, do it upfront.  We can easily do
// this on monochrome bitmaps.

    if (pxlo ==  NULL)
    {
    iBlack = 0;
    iWhite = 1;
    }
    else
    {
    iBlack = pxlo->pulXlate[0];
    iWhite = pxlo->pulXlate[1];
    }

    i = 0;
    j = 0;
    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pxrl->xPos;
    ulSrc = *pulSrc;

    if (xLeft < xRght)
    {
        while (TRUE)
        {
            if (!(ulSrc & gaulMaskMono[iLeft]))
            {
                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] |= iBlack;
                else
                    while (cnt--)
                        pxrl->aul[j++] |= iBlack;
            }
            else
            {
                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] |= iWhite;
                else
                    while (cnt--)
                        pxrl->aul[j++] |= iWhite;
            }

            xLeft++;
            iLeft++;

            if (xLeft >= xRght)
                break;

            if (iLeft & 32)
            {
                pulSrc++;
                ulSrc = *pulSrc;
                iLeft = 0;
            }
        }
    }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead04OR(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, OR the pels and produce a run
* list for a row of a 4BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead04OR(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    ULONG   *pulSrc;
    ULONG    ulSrc;
    ULONG    iColor;
    LONG     cLeft;
    LONG     iLeft;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    cLeft  =  xLeft >> 3;                   // Index of leftmost DWORD
    iLeft  =  xLeft & 7;                    // Nybbles used in leftmost DWORD
    pulSrc =  ((DWORD *) pjSrc) + cLeft;    // Adjust base address
    ulSrc  = *pulSrc;

    i = 0;
    j = 0;
    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pxrl->xPos;

    if (pxlo == NULL)
    {
        if (xLeft < xRght)
        {
            while (TRUE)
            {
                iColor = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];

                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] |= iColor;
                else
                    while (cnt--)
                        pxrl->aul[j++] |= iColor;

                xLeft++;
                iLeft++;

                if (xLeft >= xRght)
                    break;

                if (iLeft & 8)
                {
                    pulSrc++;
                    ulSrc = *pulSrc;
                    iLeft = 0;
                }
            }
        }
    }
    else
    {
        if (xLeft < xRght)
        {
            while (TRUE)
            {
                iColor = pxlo->pulXlate[(ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft]];

                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] |= iColor;
                else
                    while (cnt--)
                        pxrl->aul[j++] |= iColor;

                xLeft++;
                iLeft++;

                if (xLeft >= xRght)
                    break;

                if (iLeft & 8)
                {
                    pulSrc++;
                    ulSrc = *pulSrc;
                    iLeft = 0;
                }
            }
        }
    }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead08OR(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, OR the pels and produce a run
* list for a row of a 8BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead08OR(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    pjSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo == NULL)
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] |= *pjSrc;
        else
        while (cnt--)
            pxrl->aul[j++] |= *pjSrc;

            pjSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
    {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] |= pxlo->pulXlate[*pjSrc];
        else
        while (cnt--)
            pxrl->aul[j++] |= pxlo->pulXlate[*pjSrc];

            pjSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead16OR(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, OR the pels and produce a run
* list for a row of a 16BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead16OR(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    WORD    *pwSrc = (WORD *) pjSrc;
    ULONG    ulTmp;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    pwSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo == NULL)
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] |= *pwSrc;
        else
        while (cnt--)
            pxrl->aul[j++] |= *pwSrc;

        pwSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
        {
        cnt   = pdda->al[i++];
            ulTmp = ((XLATE *) pxlo)->ulTranslate((ULONG) *pwSrc);

        if (!cnt)
        pxrl->aul[j] |= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] |= ulTmp;


            pwSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead24OR(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, OR the pels and produce a run
* list for a row of a 24BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead24OR(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN   *pxrl = &prun->xrl;
    RGBTRIPLE *prgbSrc = (RGBTRIPLE *) pjSrc;
    ULONG      ulTmp = 0;
    LONG       cnt;
    LONG       i;
    LONG       j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    prgbSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo ==  NULL)
        while (xLeft != xRght)
        {
            *((RGBTRIPLE *) &ulTmp) = *prgbSrc;

        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] |= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] |= ulTmp;

            prgbSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        *((RGBTRIPLE *) &ulTmp) = *prgbSrc;
            ulTmp = ((XLATE *) pxlo)->ulTranslate(ulTmp);

        if (!cnt)
        pxrl->aul[j] |= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] |= ulTmp;

        prgbSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead32OR(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, OR the pels and produce a run
* list for a row of a 32BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead32OR(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    DWORD   *pdwSrc = (DWORD *) pjSrc;
    ULONG    ulTmp;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    pdwSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo == NULL)
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] |= *pdwSrc;
        else
        while (cnt--)
            pxrl->aul[j++] |= *pdwSrc;

            pdwSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
        {
            cnt = pdda->al[i++];
            ulTmp = ((XLATE *) pxlo)->ulTranslate((ULONG) *pdwSrc);

        if (!cnt)
        pxrl->aul[j] |= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] |= ulTmp;

        pdwSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead01(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 1BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead01(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    ULONG   *pulMsk;
    ULONG   *pulSrc;
    ULONG    ulMsk;
    ULONG    ulSrc;
    ULONG    iBlack;
    ULONG    iWhite;
    LONG     xPos;
    LONG     cLeft;
    LONG     iLeft;
    LONG     iMask;
    LONG     cnt;
    LONG     i;
    LONG     j;

    cLeft  =  xLeft >> 5;                   // Index of leftmost DWORD
    iLeft  =  xLeft & 31;                   // Bits used in leftmost DWORD
    pulSrc =  ((DWORD *) pjSrc) + cLeft;    // Adjust base address
    ulSrc  = *pulSrc;

// To prevent derefences of the XLATE, do it upfront.  We can easily do
// this on monochrome bitmaps.

    if (pxlo == NULL)
    {
    iBlack = 0;
    iWhite = 1;
    }
    else
    {
    iBlack = pxlo->pulXlate[0];
    iWhite = pxlo->pulXlate[1];
    }

    if (pjMask == (BYTE *) NULL)
    {
    i = 0;
    j = 0;
        pxrl->xPos = pdda->rcl.left;
        pxrl->cRun = pdda->rcl.right - pxrl->xPos;

        if (xLeft < xRght)
        {
            while (TRUE)
            {
                if (ulSrc & gaulMaskMono[iLeft])
                    for (cnt = pdda->al[i++]; cnt; cnt--)
                        prun->xrl.aul[j++] = iWhite;
                else
                    for (cnt = pdda->al[i++]; cnt; cnt--)
                        prun->xrl.aul[j++] = iBlack;

                xLeft++;
                iLeft++;

                if (xLeft >= xRght)
                    break;

                if (iLeft & 32)
                {
                    pulSrc++;
                    ulSrc = *pulSrc;
                    iLeft = 0;
                }
            }
        }

        return((XRUNLEN *) &pxrl->aul[j]);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    xPos   =  pdda->rcl.left;
    ulMsk  = *pulMsk;
    i = 0;
    j = 0;

    if (xLeft < xRght)
    {
        while (TRUE)
        {
            if (ulMsk & gaulMaskMono[iMask])
            {
                if (ulSrc & gaulMaskMono[iLeft])
                    for (cnt = pdda->al[i]; cnt; cnt--)
                        pxrl->aul[j++] = iWhite;
                else
                    for (cnt = pdda->al[i]; cnt; cnt--)
                        pxrl->aul[j++] = iBlack;
            }
            else
            {
                if (j > 0)
                {
                    pxrl->xPos = xPos;
                    pxrl->cRun = j;
                    pxrl = (XRUNLEN *) &pxrl->aul[j];
                    xPos += j;
                    j = 0;
                }

                xPos += pdda->al[i];
            }

            xLeft++;
            iLeft++;
            iMask++;
            i++;

            if (xLeft >= xRght)
                break;

            if (iLeft & 32)
            {
                pulSrc++;
                ulSrc = *pulSrc;
                iLeft = 0;
            }

            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    if (j > 0)
    {
        pxrl->xPos = xPos;
        pxrl->cRun = j;
        pxrl = (XRUNLEN *) &pxrl->aul[j];
    }

    return(pxrl);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead04(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 4BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead04(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    ULONG   *pulMsk;
    ULONG   *pulSrc;
    ULONG    ulMsk;
    ULONG    ulSrc;
    ULONG    iColor;
    LONG     xPos;
    LONG     cLeft;
    LONG     iLeft;
    LONG     iMask;
    LONG     cnt;
    LONG     i;
    LONG     j;

    cLeft  =  xLeft >> 3;                   // Index of leftmost DWORD
    iLeft  =  xLeft & 7;                    // Nybbles used in leftmost DWORD
    pulSrc =  ((DWORD *) pjSrc) + cLeft;    // Adjust base address
    ulSrc  = *pulSrc;

    if (pjMask == (BYTE *) NULL)
    {
    i = 0;
    j = 0;
        pxrl->xPos = pdda->rcl.left;
        pxrl->cRun = pdda->rcl.right - pxrl->xPos;

        if (pxlo == NULL)
    {
            if (xLeft < xRght)
            {
                while (TRUE)
                {
                    iColor = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];
                    for (cnt = pdda->al[i++]; cnt; cnt--)
                        pxrl->aul[j++] = iColor;

                    xLeft++;
                    iLeft++;

                    if (xLeft >= xRght)
                        break;

                    if (iLeft & 8)
                    {
                        pulSrc++;
                        ulSrc = *pulSrc;
                        iLeft = 0;
                    }
                }
            }
    }
    else
    {
            if (xLeft < xRght)
            {
                while (TRUE)
                {
                    iColor = pxlo->pulXlate[(ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft]];
                    for (cnt = pdda->al[i++]; cnt; cnt--)
                        pxrl->aul[j++] = iColor;

                    xLeft++;
                    iLeft++;

                    if (xLeft >= xRght)
                        break;

                    if (iLeft & 8)
                    {
                        pulSrc++;
                        ulSrc = *pulSrc;
                        iLeft = 0;
                    }
                }
        }
    }

        return((XRUNLEN *) &pxrl->aul[j]);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    xPos   =  pdda->rcl.left;
    ulMsk  = *pulMsk;
    i = 0;
    j = 0;

    if (xLeft < xRght)
    {
        while (TRUE)
        {
            iColor = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];
            if (pxlo != NULL)
                iColor = pxlo->pulXlate[iColor];

            if (ulMsk & gaulMaskMono[iMask])
            {
                for (cnt = pdda->al[i]; cnt; cnt--)
                    pxrl->aul[j++] = iColor;
            }
            else
            {
                if (j > 0)
                {
                    pxrl->xPos = xPos;
                    pxrl->cRun = j;
                    pxrl = (XRUNLEN *) &pxrl->aul[j];
                    xPos += j;
                    j = 0;
                }

                xPos += pdda->al[i];
            }

            xLeft++;
            iLeft++;
            iMask++;
            i++;

            if (xLeft >= xRght)
                break;

            if (iLeft & 8)
            {
                pulSrc++;
                ulSrc = *pulSrc;
                iLeft = 0;
            }

            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    if (j > 0)
    {
        pxrl->xPos = xPos;
        pxrl->cRun = j;
        pxrl = (XRUNLEN *) &pxrl->aul[j];
    }

    return(pxrl);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead08(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 8BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead08(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    ULONG   *pulMsk;
    ULONG    ulMsk;
    ULONG    iColor;
    LONG     xPos;
    LONG     iMask;
    LONG     cnt;
    LONG     i;
    LONG     j;

    pjSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        pxrl->xPos = pdda->rcl.left;
        pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
        i = 0;
        j = 0;

        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                for (cnt = pdda->al[i++]; cnt; cnt--)
                    pxrl->aul[j++] = *pjSrc;

                pjSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                for (cnt = pdda->al[i++]; cnt; cnt--)
                    pxrl->aul[j++] = pxlo->pulXlate[*pjSrc];
                pjSrc++;
                xLeft++;
            }

        return((XRUNLEN *) &pxrl->aul[j]);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    xPos   =  pdda->rcl.left;
    ulMsk  = *pulMsk;
    i = 0;
    j = 0;


    if (xLeft < xRght)
    {
        while(TRUE) 
        {
            iColor = (DWORD) *pjSrc++;
            if (pxlo != NULL)
                iColor = pxlo->pulXlate[iColor];
    
            if (ulMsk & gaulMaskMono[iMask])
            {
                for (cnt = pdda->al[i]; cnt; cnt--)
                    pxrl->aul[j++] = iColor;
            }
            else
            {
                if (j > 0)
                {
                    pxrl->xPos = xPos;
                    pxrl->cRun = j;
                    pxrl = (XRUNLEN *) &pxrl->aul[j];
                    xPos += j;
                    j = 0;
                }
    
                xPos += pdda->al[i];
            }
    
            xLeft++;
            iMask++;
            i++;
            
            if(xLeft >= xRght) 
              break;
    
            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    if (j > 0)
    {
        pxrl->xPos = xPos;
        pxrl->cRun = j;
        pxrl = (XRUNLEN *) &pxrl->aul[j];
    }

    return(pxrl);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead16(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 16BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead16(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    WORD    *pwSrc = (WORD *) pjSrc;
    ULONG   *pulMsk;
    ULONG    ulMsk;
    ULONG    ulTmp;
    ULONG    iColor;
    LONG     xPos;
    LONG     iMask;
    LONG     cnt;
    LONG     i;
    LONG     j;

    pwSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        pxrl->xPos = pdda->rcl.left;
        pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
        i = 0;
        j = 0;

        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                for (cnt = pdda->al[i++]; cnt; cnt--)
                    pxrl->aul[j++] = *pwSrc;

                pwSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                cnt = pdda->al[i++];

                if (cnt)
                {
                    ulTmp = ((XLATE *) pxlo)->ulTranslate((ULONG) *pwSrc);

                    while (cnt--)
                        pxrl->aul[j++] = ulTmp;
                }

                pwSrc++;
                xLeft++;
            }

        return((XRUNLEN *) &pxrl->aul[j]);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    xPos   =  pdda->rcl.left;
    ulMsk  = *pulMsk;
    i = 0;
    j = 0;

    if (xLeft < xRght)
    {
        while(TRUE)
        {
            iColor = (DWORD) *pwSrc++;
            if (pxlo != NULL)
                iColor = ((XLATE *) pxlo)->ulTranslate(iColor);
    
            if (ulMsk & gaulMaskMono[iMask])
            {
                for (cnt = pdda->al[i]; cnt; cnt--)
                    pxrl->aul[j++] = iColor;
            }
            else
            {
                if (j > 0)
                {
                    pxrl->xPos = xPos;
                    pxrl->cRun = j;
                    pxrl = (XRUNLEN *) &pxrl->aul[j];
                    xPos += j;
                    j = 0;
                }
    
                xPos += pdda->al[i];
            }
    
            xLeft++;
            iMask++;
            i++;
    
            if (xLeft >= xRght) 
              break;
    
            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    if (j > 0)
    {
        pxrl->xPos = xPos;
        pxrl->cRun = j;
        pxrl = (XRUNLEN *) &pxrl->aul[j];
    }

    return(pxrl);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead24(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 24BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead24(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN   *pxrl = &prun->xrl;
    RGBTRIPLE *prgbSrc = (RGBTRIPLE *) pjSrc;
    ULONG     *pulMsk;
    ULONG      ulTmp = 0;
    ULONG      ulMsk;
    ULONG      iColor = 0;
    LONG       iMask;
    LONG       xPos;
    LONG       cnt;
    LONG       i;
    LONG       j;

    prgbSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        pxrl->xPos = pdda->rcl.left;
        pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
        i = 0;
        j = 0;

        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                *((RGBTRIPLE *) &ulTmp) = *prgbSrc;

                for (cnt = pdda->al[i++]; cnt; cnt--)
                    pxrl->aul[j++] = ulTmp;

                prgbSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                cnt = pdda->al[i++];

                if (cnt)
                {
                    *((RGBTRIPLE *) &ulTmp) = *prgbSrc;
                    ulTmp = ((XLATE *) pxlo)->ulTranslate(ulTmp);

                    while (cnt--)
                        pxrl->aul[j++] = ulTmp;
                }

                prgbSrc++;
                xLeft++;
            }

        return((XRUNLEN *) &pxrl->aul[j]);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    xPos   =  pdda->rcl.left;
    ulMsk  = *pulMsk;
    i = 0;
    j = 0;

    if (xLeft < xRght)
    {
        while (TRUE) 
        {
            *((RGBTRIPLE *) &iColor) = *prgbSrc++;
            if (pxlo != NULL)
                iColor = ((XLATE *) pxlo)->ulTranslate(iColor);
    
            if (ulMsk & gaulMaskMono[iMask])
            {
                for (cnt = pdda->al[i]; cnt; cnt--)
                    pxrl->aul[j++] = iColor;
            }
            else
            {
                if (j > 0)
                {
                    pxrl->xPos = xPos;
                    pxrl->cRun = j;
                    pxrl = (XRUNLEN *) &pxrl->aul[j];
                    xPos += j;
                    j = 0;
                }
    
                xPos += pdda->al[i];
            }
    
            xLeft++;
            iMask++;
            i++;
    
            if (xLeft >= xRght) 
              break;
    
            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    if (j > 0)
    {
        pxrl->xPos = xPos;
        pxrl->cRun = j;
        pxrl = (XRUNLEN *) &pxrl->aul[j];
    }

    return(pxrl);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead32(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 32BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead32(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    DWORD   *pdwSrc = (DWORD *) pjSrc;
    ULONG   *pulMsk;
    ULONG    ulTmp;
    ULONG    ulMsk;
    ULONG    iColor;
    LONG     xPos;
    LONG     iMask;
    LONG     cnt;
    LONG     i;
    LONG     j;

    pdwSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        pxrl->xPos = pdda->rcl.left;
        pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
        i = 0;
        j = 0;

        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                for (cnt = pdda->al[i++]; cnt; cnt--)
                    pxrl->aul[j++] = *pdwSrc;

                pdwSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                cnt = pdda->al[i++];

                if (cnt)
                {
                    ulTmp = ((XLATE *) pxlo)->ulTranslate((ULONG) *pdwSrc);

                    while (cnt--)
                        pxrl->aul[j++] = ulTmp;
                }

                pdwSrc++;
                xLeft++;
            }

        return((XRUNLEN *) &pxrl->aul[j]);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    xPos   =  pdda->rcl.left;
    ulMsk  = *pulMsk;
    i = 0;
    j = 0;

    if (xLeft < xRght)
    {
        while (TRUE)
        {
            iColor = *pdwSrc++;
            if (pxlo != NULL)
                iColor = ((XLATE *) pxlo)->ulTranslate(iColor);
    
            if (ulMsk & gaulMaskMono[iMask])
            {
                for (cnt = pdda->al[i]; cnt; cnt--)
                    pxrl->aul[j++] = iColor;
            }
            else
            {
                if (j > 0)
                {
                    pxrl->xPos = xPos;
                    pxrl->cRun = j;
                    pxrl = (XRUNLEN *) &pxrl->aul[j];
                    xPos += j;
                    j = 0;
                }
    
                xPos += pdda->al[i];
            }
    
            xLeft++;
            iMask++;
            i++;
    
            if (xLeft >= xRght) 
              break;
    
            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    if (j > 0)
    {
        pxrl->xPos = xPos;
        pxrl->cRun = j;
        pxrl = (XRUNLEN *) &pxrl->aul[j];
    }

    return(pxrl);
}

/******************************Public*Routine******************************\
* VOID vStrWrite01(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 1BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrWrite01(
STRRUN  *prun,
XRUNLEN *pxrlEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    XRUNLEN *pxrl = &prun->xrl;
    DWORD   *pjBase;
    DWORD   *pjCurr;
    DWORD   *pjDraw;
    ULONG    ulTemp;
    ULONG    ulMask;
    LONG     xLeft;
    LONG     xRght;
    LONG     yCurr;
    LONG     cLeft;
    LONG     cRght;
    LONG     cByte;
    LONG     iMask;
    LONG     iLeft;
    LONG     iRght;
    LONG     iRep;
    LONG     jDraw;
    BOOL     bValid;

// There maybe no clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
        pjBase = (DWORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * prun->yPos);
        jDraw = 0;

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;

            pjDraw = pjCurr = pjBase + (xLeft >> 5);
         iMask = xLeft & 31;
            ulTemp = *pjDraw;

            if (xLeft < xRght)
            {
                while (TRUE)
                {
                    if (pxrl->aul[jDraw++])
                        ulTemp |=  gaulMaskMono[iMask];
                    else
                        ulTemp &= ~gaulMaskMono[iMask];

                    iMask++;
                    xLeft++;

                    if (xLeft >= xRght)
                        break;

                    if (iMask & 32)
                    {
                       *pjDraw = ulTemp;
                        pjDraw++;
                        ulTemp = *pjDraw;
                        iMask  = 0;
                    }
                }
            }

           *pjDraw = ulTemp;

            if (prun->cRep > 1)
            {
                iLeft = pxrl->xPos;
                iRght = pxrl->cRun + iLeft;
                cLeft = iLeft >> 5;
                cRght = iRght >> 5;
        iLeft &= 31;
                iRght &= 31;

                if (cLeft == cRght)
                {
                    ulMask = gaulMaskEdge[iLeft] & ~gaulMaskEdge[iRght];

                    for (iRep = 1; iRep < prun->cRep; iRep++)
                    {
                        pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                       *pjDraw = (*pjCurr & ulMask) | (*pjDraw & ~ulMask);
                        pjCurr = pjDraw;
                    }
                }
                else
                {
                    if (iLeft)
                    {
                        ulMask = ~gaulMaskEdge[iLeft];
                        ulTemp = *pjCurr & ~ulMask;

                        for (iRep = 1; iRep < prun->cRep; iRep++)
                        {
                            pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                           *pjDraw = ulTemp | (*pjDraw & ulMask);
                            pjCurr = pjDraw;
                        }

                        cLeft++;
                    }

                    if (cLeft != cRght)
                    {
                        pjCurr = pjBase + cLeft;
                        cByte = (cRght - cLeft) << 2;

                        for (iRep = 1; iRep < prun->cRep; iRep++)
                        {
                            pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                            RtlCopyMemory(pjDraw, pjCurr, cByte);
                            pjCurr = pjDraw;
                        }
                    }

                    if (iRght)
                    {
                        pjCurr = pjBase + cRght;
            ulMask = gaulMaskEdge[iRght];
                        ulTemp = *pjCurr & ~ulMask;

                        for (iRep = 1; iRep < prun->cRep; iRep++)
                        {
                            pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                           *pjDraw = ulTemp | (*pjDraw & ulMask);
                            pjCurr = pjDraw;
                        }
                    }
                }
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
            jDraw = 0;
        }

        return;
    }

// Setup the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL   rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    yCurr = prun->yPos;
    iRep  = prun->cRep;
    ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    pjBase = (DWORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr);

    while (iRep--)
    {
        if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
        {
            jDraw = 0;

            while (pxrl != pxrlEnd)
            {
                xLeft = pxrl->xPos;
                xRght = pxrl->cRun + xLeft;

                pjDraw = pjBase + (xLeft >> 5);
         iMask = xLeft & 31;

                bValid = ((xLeft >= 0) && (xLeft < pSurf->sizl().cx));
                ulTemp  = bValid ? *pjDraw : (ULONG) 0;

                while (xLeft < xRght)
                {
                    if ((xLeft < rclClip.left) || (xLeft >= rclClip.right))
                        ((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xLeft, yCurr);

                    if ((xLeft >= rclClip.left) && (xLeft < rclClip.right))
                    {
                        if (pxrl->aul[jDraw])
                            ulTemp |=  gaulMaskMono[iMask];
                        else
                            ulTemp &= ~gaulMaskMono[iMask];
                    }

            iMask++;
                    xLeft++;
                    jDraw++;

            if (iMask & 32)
            {
            if (bValid)
                           *pjDraw = ulTemp;

            pjDraw++;
            iMask = 0;

                        bValid = ((xLeft >= 0) && (xLeft < pSurf->sizl().cx));
                        ulTemp = bValid ? *pjDraw : (ULONG) 0;
            }
                }

                if (bValid)
                   *pjDraw = ulTemp;

                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                jDraw = 0;
            }

            pxrl = &prun->xrl;
        }

        pjBase = (DWORD *) ((BYTE *) pjBase + pSurf->lDelta());
        yCurr++;

        if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
            ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    }
}

/******************************Public*Routine******************************\
* VOID vStrWrite04(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 4BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrWrite04(
STRRUN  *prun,
XRUNLEN *pxrlEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    XRUNLEN *pxrl = &prun->xrl;
    DWORD   *pjBase;
    DWORD   *pjCurr;
    DWORD   *pjDraw;
    ULONG    ulTemp;
    ULONG    ulMask;
    ULONG    ulShft;
    LONG     xLeft;
    LONG     xRght;
    LONG     yCurr;
    LONG     cLeft;
    LONG     cRght;
    LONG     cByte;
    LONG     iMask;
    LONG     iLeft;
    LONG     iRght;
    LONG     iRep;
    LONG     jDraw;
    BOOL     bValid;

// There maybe no clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
        pjBase = (DWORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * prun->yPos);
        jDraw = 0;

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;

        pjDraw = pjCurr = pjBase + (xLeft >> 3);
            ulTemp = *pjDraw;
         iMask = xLeft & 7;

            if (xLeft < xRght)
            {
                while (TRUE)
                {
                    ulShft = gaulShftQuad[iMask];
                    ulMask = gaulMaskQuad[iMask];

                    ulTemp = (ULONG) ((ulTemp & ~ulMask) |
                                      ((pxrl->aul[jDraw++] << ulShft) & ulMask));

                    iMask++;
                    xLeft++;

                    if (xLeft >= xRght)
                        break;

                    if (iMask & 8)
                    {
                       *pjDraw = ulTemp;
                        pjDraw++;
                        ulTemp = *pjDraw;
                        iMask  = 0;
                    }
                }
            }

           *pjDraw = ulTemp;

            if (prun->cRep > 1)
            {
                iLeft = pxrl->xPos;
                iRght = pxrl->cRun + iLeft;
                cLeft = iLeft >> 3;
                cRght = iRght >> 3;
        iLeft = (iLeft & 7) << 2;
                iRght = (iRght & 7) << 2;

                if (cLeft == cRght)
                {
                    ulMask = gaulMaskEdge[iLeft] & ~gaulMaskEdge[iRght];

                    for (iRep = 1; iRep < prun->cRep; iRep++)
                    {
                        pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                       *pjDraw = (*pjCurr & ulMask) | (*pjDraw & ~ulMask);
                        pjCurr = pjDraw;
                    }
                }
                else
                {
                    if (iLeft)
                    {
                        ulMask = ~gaulMaskEdge[iLeft];
                        ulTemp = *pjCurr & ~ulMask;

                        for (iRep = 1; iRep < prun->cRep; iRep++)
                        {
                            pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                           *pjDraw = ulTemp | (*pjDraw & ulMask);
                            pjCurr = pjDraw;
                        }

                        cLeft++;
                    }

                    if (cLeft != cRght)
                    {
                        pjCurr = pjBase + cLeft;
                        cByte = (cRght - cLeft) << 2;

                        for (iRep = 1; iRep < prun->cRep; iRep++)
                        {
                            pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                            RtlCopyMemory(pjDraw, pjCurr, cByte);
                            pjCurr = pjDraw;
                        }
                    }

                    if (iRght)
                    {
                        pjCurr = pjBase + cRght;
            ulMask = gaulMaskEdge[iRght];
                        ulTemp = *pjCurr & ~ulMask;

                        for (iRep = 1; iRep < prun->cRep; iRep++)
                        {
                            pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                           *pjDraw = ulTemp | (*pjDraw & ulMask);
                            pjCurr = pjDraw;
                        }
                    }
                }
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
            jDraw = 0;
        }

        return;
    }

// Setup the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL   rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    yCurr = prun->yPos;
    iRep  = prun->cRep;
    ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    pjBase = (DWORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr);

    while (iRep--)
    {
        if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
        {
            jDraw = 0;

            while (pxrl != pxrlEnd)
            {
                xLeft = pxrl->xPos;
                xRght = pxrl->cRun + xLeft;

                pjDraw = pjBase + (xLeft >> 3);
         iMask = xLeft & 7;

                bValid = ((xLeft >= 0) && (xLeft < pSurf->sizl().cx));
                ulTemp  = bValid ? *pjDraw : (ULONG) 0;

                while (xLeft < xRght)
                {
                    if ((xLeft < rclClip.left) || (xLeft >= rclClip.right))
                        ((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xLeft, yCurr);

                    if ((xLeft >= rclClip.left) && (xLeft < rclClip.right))
                    {
                        ulMask = gaulMaskQuad[iMask];
                        ulShft = gaulShftQuad[iMask];

                        ulTemp = (ULONG) ((ulTemp & ~ulMask) |
                                          ((pxrl->aul[jDraw] << ulShft) & ulMask));
                    }

            iMask++;
                    xLeft++;
                    jDraw++;

            if (iMask & 8)
            {
            if (bValid)
               *pjDraw = ulTemp;

            pjDraw++;
            iMask = 0;

                        bValid = ((xLeft >= 0) && (xLeft < pSurf->sizl().cx));
                        ulTemp = bValid ? *pjDraw : (ULONG) 0;
            }
                }

                if (bValid)
                   *pjDraw = ulTemp;

                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                jDraw = 0;
            }

            pxrl = &prun->xrl;
        }

        pjBase = (DWORD *) ((BYTE *) pjBase + pSurf->lDelta());
        yCurr++;

        if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
            ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    }
}

/******************************Public*Routine******************************\
* VOID vStrWrite08(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 8BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrWrite08(
STRRUN  *prun,
XRUNLEN *pxrlEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    XRUNLEN *pxrl = &prun->xrl;
    BYTE    *pjBase;
    BYTE    *pjCurr;
    BYTE    *pjDraw;
    LONG     xLeft;
    LONG     xRght;
    LONG     yCurr;
    LONG     iTop;
    LONG     iBot;
    LONG     iRep;
    LONG     jLeft;
    LONG     jRght;
    LONG     jDraw;
    LONG     jByte;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
        pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * prun->yPos;

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;
            jDraw = 0;

            pjDraw = pjCurr = pjBase + xLeft;

            while (xLeft < xRght)
            {
               *pjDraw++ = (BYTE) pxrl->aul[jDraw++];
                xLeft++;
            }

            for (jDraw = 1; jDraw < prun->cRep; jDraw++)
            {
                RtlCopyMemory(pjCurr + pSurf->lDelta(), pjCurr, pxrl->cRun);
                pjCurr += pSurf->lDelta();
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }
        return;
    }

    RECTL   rclClip;

    if (pco->iDComplexity == DC_RECT)
    {
        rclClip = pco->rclBounds;

        iTop = prun->yPos;
        iBot = prun->yPos + prun->cRep;

        if ((iTop >= rclClip.bottom) || (iBot <= rclClip.top))
            return;

        iTop = iTop >= rclClip.top ? iTop : rclClip.top;
        iBot = iBot < rclClip.bottom ? iBot : rclClip.bottom;
        iRep = iBot - iTop;

        pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * iTop;

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;

            if (xRght < rclClip.left)
            {
                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                continue;
            }

            if (xLeft >= rclClip.right)
                return;

            jLeft = xLeft >= rclClip.left ? xLeft : rclClip.left;
            jRght = xRght < rclClip.right ? xRght : rclClip.right;
            jByte = jRght - jLeft;

            pjDraw = pjCurr = pjBase + jLeft;
            jDraw  = jLeft - xLeft;

            while (jLeft < jRght)
            {
               *pjDraw++ = (BYTE) pxrl->aul[jDraw++];
                jLeft++;
            }

            for (jDraw = 1; jDraw < iRep; jDraw++)
            {
                RtlCopyMemory(pjCurr + pSurf->lDelta(), pjCurr, jByte);
                pjCurr += pSurf->lDelta();
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }

        return;
    }

// There is complex clipping.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    yCurr = prun->yPos;
    iRep  = prun->cRep;
    ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;

    while (iRep--)
    {
        if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
        {
            jDraw = 0;

            while (pxrl != pxrlEnd)
            {
                xLeft = pxrl->xPos;
                xRght = pxrl->cRun + xLeft;

                pjDraw = pjCurr = pjBase + xLeft;

                while (xLeft < xRght)
                {
                    if ((xLeft < rclClip.left) || (xLeft >= rclClip.right))
                        ((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xLeft, yCurr);

                    if ((xLeft >= rclClip.left) && (xLeft < rclClip.right))
                       *pjDraw = (BYTE) pxrl->aul[jDraw];

                    pjDraw++;
                    jDraw++;
                    xLeft++;
                }

                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                jDraw = 0;
            }

            pxrl = &prun->xrl;
        }

        pjBase += pSurf->lDelta();
        yCurr++;

        if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
            ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    }
}

/******************************Public*Routine******************************\
* VOID vStrWrite16(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 16BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrWrite16(
STRRUN  *prun,
XRUNLEN *pxrlEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    XRUNLEN *pxrl = &prun->xrl;
    WORD    *pjBase;
    WORD    *pjCurr;
    WORD    *pjDraw;
    LONG     xLeft;
    LONG     xRght;
    LONG     yCurr;
    LONG     iTop;
    LONG     iBot;
    LONG     iRep;
    LONG     jLeft;
    LONG     jRght;
    LONG     jDraw;
    LONG     jByte;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
        pjBase = (WORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * prun->yPos);

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;
            jDraw = 0;

            pjDraw = pjCurr = pjBase + xLeft;

            while (xLeft < xRght)
            {
               *pjDraw++ = (WORD) pxrl->aul[jDraw++];
                xLeft++;
            }

            for (jDraw = 1; jDraw < prun->cRep; jDraw++)
            {
                pjDraw = (WORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                RtlCopyMemory(pjDraw, pjCurr, pxrl->cRun * 2);
                pjCurr = pjDraw;
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }
        return;
    }

    RECTL   rclClip;

    if (pco->iDComplexity == DC_RECT)
    {
        rclClip = pco->rclBounds;

        iTop = prun->yPos;
        iBot = prun->yPos + prun->cRep;

        if ((iTop >= rclClip.bottom) || (iBot <= rclClip.top))
            return;

        iTop = iTop >= rclClip.top ? iTop : rclClip.top;
        iBot = iBot < rclClip.bottom ? iBot : rclClip.bottom;
        iRep = iBot - iTop;

        pjBase = (WORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * iTop);

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;

            if (xRght < rclClip.left)
            {
                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                continue;
            }

            if (xLeft >= rclClip.right)
                return;

            jLeft = xLeft >= rclClip.left ? xLeft : rclClip.left;
            jRght = xRght < rclClip.right ? xRght : rclClip.right;
            jByte = jRght - jLeft;

            pjDraw = pjCurr = pjBase + jLeft;
            jDraw  = jLeft - xLeft;

            while (jLeft < jRght)
            {
               *pjDraw++ = (WORD) pxrl->aul[jDraw++];
                jLeft++;
            }

            for (jDraw = 1; jDraw < iRep; jDraw++)
            {
                pjDraw = (WORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                RtlCopyMemory(pjDraw, pjCurr, jByte * 2);
                pjCurr = pjDraw;
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }

        return;
    }

// There is complex clipping.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    yCurr = prun->yPos;
    iRep  = prun->cRep;
    ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    pjBase = (WORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr);

    while (iRep--)
    {
        if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
        {
            jDraw = 0;

            while (pxrl != pxrlEnd)
            {
                xLeft = pxrl->xPos;
                xRght = pxrl->cRun + xLeft;

                pjDraw = pjCurr = pjBase + xLeft;

                while (xLeft < xRght)
                {
                    if ((xLeft < rclClip.left) || (xLeft >= rclClip.right))
                        ((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xLeft, yCurr);

                    if ((xLeft >= rclClip.left) && (xLeft < rclClip.right))
                       *pjDraw = (WORD) pxrl->aul[jDraw];

                    pjDraw++;
                    jDraw++;
                    xLeft++;
                }

                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                jDraw = 0;
            }

            pxrl = &prun->xrl;
        }

        pjBase = (WORD *) ((BYTE *) pjBase + pSurf->lDelta());
        yCurr++;

        if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
            ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    }
}

/******************************Public*Routine******************************\
* VOID vStrWrite24(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 24BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrWrite24(
STRRUN  *prun,
XRUNLEN *pxrlEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    XRUNLEN   *pxrl = &prun->xrl;
    RGBTRIPLE *pjBase;
    RGBTRIPLE *pjCurr;
    RGBTRIPLE *pjDraw;
    LONG       xLeft;
    LONG       xRght;
    LONG       yCurr;
    LONG       iTop;
    LONG       iBot;
    LONG       iRep;
    LONG       jLeft;
    LONG       jRght;
    LONG       jDraw;
    LONG       jByte;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
        pjBase = (RGBTRIPLE *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * prun->yPos);

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;
            jDraw = 0;

            pjDraw = pjCurr = pjBase + xLeft;

            while (xLeft < xRght)
            {
               *pjDraw++ = *((RGBTRIPLE *) &pxrl->aul[jDraw++]);
                xLeft++;
            }

            for (jDraw = 1; jDraw < prun->cRep; jDraw++)
            {
                pjDraw = (RGBTRIPLE *) ((BYTE *) pjCurr + pSurf->lDelta());
                RtlCopyMemory(pjDraw, pjCurr, pxrl->cRun * 3);
                pjCurr = pjDraw;
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }
        return;
    }

    RECTL   rclClip;

    if (pco->iDComplexity == DC_RECT)
    {
        rclClip = pco->rclBounds;

        iTop = prun->yPos;
        iBot = prun->yPos + prun->cRep;

        if ((iTop >= rclClip.bottom) || (iBot <= rclClip.top))
            return;

        iTop = iTop >= rclClip.top ? iTop : rclClip.top;
        iBot = iBot < rclClip.bottom ? iBot : rclClip.bottom;
        iRep = iBot - iTop;

        pjBase = (RGBTRIPLE *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * iTop);

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;

            if (xRght < rclClip.left)
            {
                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                continue;
            }

            if (xLeft >= rclClip.right)
                return;

            jLeft = xLeft >= rclClip.left ? xLeft : rclClip.left;
            jRght = xRght < rclClip.right ? xRght : rclClip.right;
            jByte = jRght - jLeft;

            pjDraw = pjCurr = pjBase + jLeft;
            jDraw  = jLeft - xLeft;

            while (jLeft < jRght)
            {
               *pjDraw++ = *((RGBTRIPLE *) &pxrl->aul[jDraw++]);
                jLeft++;
            }

            for (jDraw = 1; jDraw < iRep; jDraw++)
            {
                pjDraw = (RGBTRIPLE *) ((BYTE *) pjCurr + pSurf->lDelta());
                RtlCopyMemory(pjDraw, pjCurr, jByte * 3);
                pjCurr = pjDraw;
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }

        return;
    }

// There is complex clipping.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    yCurr = prun->yPos;
    iRep  = prun->cRep;
    ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    pjBase = (RGBTRIPLE *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr);

    while (iRep--)
    {
        if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
        {
            jDraw = 0;

            while (pxrl != pxrlEnd)
            {
                xLeft = pxrl->xPos;
                xRght = pxrl->cRun + xLeft;

                pjDraw = pjCurr = pjBase + xLeft;

                while (xLeft < xRght)
                {
                    if ((xLeft < rclClip.left) || (xLeft >= rclClip.right))
                        ((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xLeft, yCurr);

                    if ((xLeft >= rclClip.left) && (xLeft < rclClip.right))
                       *pjDraw = *((RGBTRIPLE *) &pxrl->aul[jDraw]);

                    pjDraw++;
                    jDraw++;
                    xLeft++;
                }

                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                jDraw = 0;
            }

            pxrl = &prun->xrl;
        }

        pjBase = (RGBTRIPLE *) ((BYTE *) pjBase + pSurf->lDelta());
        yCurr++;

        if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
            ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    }
}

/******************************Public*Routine******************************\
* VOID vStrWrite32(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 32BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrWrite32(
STRRUN  *prun,
XRUNLEN *pxrlEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    XRUNLEN *pxrl = &prun->xrl;
    DWORD   *pjBase;
    DWORD   *pjCurr;
    DWORD   *pjDraw;
    LONG     xLeft;
    LONG     xRght;
    LONG     yCurr;
    LONG     iTop;
    LONG     iBot;
    LONG     iRep;
    LONG     jLeft;
    LONG     jRght;
    LONG     jDraw;
    LONG     jByte;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
        pjBase = (DWORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * prun->yPos);

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;
            jDraw = 0;

            pjDraw = pjCurr = pjBase + xLeft;

            while (xLeft < xRght)
            {
               *pjDraw++ = (DWORD) pxrl->aul[jDraw++];
                xLeft++;
            }

            for (jDraw = 1; jDraw < prun->cRep; jDraw++)
            {
                pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                RtlCopyMemory(pjDraw, pjCurr, pxrl->cRun * 4);
                pjCurr = pjDraw;
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }
        return;
    }

    RECTL   rclClip;

    if (pco->iDComplexity == DC_RECT)
    {
        rclClip = pco->rclBounds;

        iTop = prun->yPos;
        iBot = prun->yPos + prun->cRep;

        if ((iTop >= rclClip.bottom) || (iBot <= rclClip.top))
            return;

        iTop = iTop >= rclClip.top ? iTop : rclClip.top;
        iBot = iBot < rclClip.bottom ? iBot : rclClip.bottom;
        iRep = iBot - iTop;

        pjBase = (DWORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * iTop);

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;

            if (xRght < rclClip.left)
            {
                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                continue;
            }

            if (xLeft >= rclClip.right)
                return;

            jLeft = xLeft >= rclClip.left ? xLeft : rclClip.left;
            jRght = xRght < rclClip.right ? xRght : rclClip.right;
            jByte = jRght - jLeft;

            pjDraw = pjCurr = pjBase + jLeft;
            jDraw  = jLeft - xLeft;

            while (jLeft < jRght)
            {
               *pjDraw++ = (DWORD) pxrl->aul[jDraw++];
                jLeft++;
            }

            for (jDraw = 1; jDraw < iRep; jDraw++)
            {
                pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                RtlCopyMemory(pjDraw, pjCurr, jByte * 4);
                pjCurr = pjDraw;
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }

        return;
    }

// There is complex clipping.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    yCurr = prun->yPos;
    iRep  = prun->cRep;
    ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    pjBase = (DWORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr);

    while (iRep--)
    {
        if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
        {
            jDraw = 0;

            while (pxrl != pxrlEnd)
            {
                xLeft = pxrl->xPos;
                xRght = pxrl->cRun + xLeft;

                pjDraw = pjCurr = pjBase + xLeft;

                while (xLeft < xRght)
                {
                    if ((xLeft < rclClip.left) || (xLeft >= rclClip.right))
                        ((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xLeft, yCurr);

                    if ((xLeft >= rclClip.left) && (xLeft < rclClip.right))
                       *pjDraw = (DWORD) pxrl->aul[jDraw];

                    pjDraw++;
                    jDraw++;
                    xLeft++;
                }

                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                jDraw = 0;
            }

            pxrl = &prun->xrl;
        }

        pjBase = (DWORD *) ((BYTE *) pjBase + pSurf->lDelta());
        yCurr++;

        if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
            ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\strdir.cxx ===
/*++

Copyright (c) 1994-1999 Microsoft Corporation

Module Name:

    str.c

Abstract:

    stretch blt routines

Author:

   Mark Enstrom  (marke)

Environment:

    C

Revision History:

   08-26-92     Initial version

--*/


#include "precomp.hxx"
#include "stretch.hxx"

#define STRETCH_MAX_WIDTH 32767

#ifdef DBG_STRDIR

ULONG   DbgStrBlt=0;

#endif

PFN_DIRSTRETCH
pfnStrArray[] = {
                    vDirectStretchError,        // 0
                    vDirectStretchError,        // 1
                    vDirectStretchError,        // 4
                    vDirectStretch8,            // 8
                    vDirectStretch16,           // 16
                    vDirectStretchError,        // 24
                    vDirectStretch32,           // 32
                    vDirectStretchError,        // 0  Narrow
                    vDirectStretchError,        // 0  Narrow
                    vDirectStretchError,        // 1  Narrow
                    vDirectStretchError,        // 4  Narrow
                    vDirectStretch8Narrow,      // 8  Narrow
                    vDirectStretch16,           // 16 Narrow
                    vDirectStretchError,        // 24 Narrow
                    vDirectStretch32,           // 32 Narrow
                    vDirectStretchError         // 0  Narrow
                };



/******************************Public*Routine******************************\
*
* Routine Description:
*
*   StretchBlt using integer math. Must be from one surface to another
*   surface of the same format. Currently only 8,16 and 32 bit per pixel
*   are supported
*
* Arguments:
*
*   pvDst           -   Pointer to start of dst bitmap
*   lDeltaDst       -   Bytes from start of dst scan line to start of next
*   DstCx           -   Width of Dst Bitmap in pixels
*   DstCy           -   Height of Dst Bitmap in pixels
*   prclDst         -   Pointer to rectangle of Dst extents
*   pvSrc           -   Pointer to start of Src bitmap
*   lDeltaSrc       -   Bytes from start of Src scan line to start of next
*   SrcCx           -   Width of Src Bitmap in pixels
*   SrcCy           -   Height of Src Bitmap in pixels
*   prclSrc         -   Pointer to rectangle of Src extents
*   prclTrim        -   Return dst extents trimmed by clipping in this rect
*   prclSClip       -   Clip Dest to this rect
*   iBitmapFormat   -   Format of Src and Dst bitmaps
*
* Return Value:
*
*   Status
*
* Revision History:
*
*   10-07-94      Initial code
*
\**************************************************************************/


BOOL
StretchDIBDirect(
    PVOID   pvDst,
    LONG    lDeltaDst,
    ULONG   DstCx,
    ULONG   DstCy,
    PRECTL  prclDst,
    PVOID   pvSrc,
    LONG    lDeltaSrc,
    ULONG   SrcCx,
    ULONG   SrcCy,
    PRECTL  prclSrc,
    PRECTL  prclTrim,
    PRECTL  prclClip,
    ULONG   iBitmapFormat
    )
{

    //
    // validate parameters, then determine src to dst mapping
    //

    ASSERTGDI(pvDst != (PVOID)NULL,"Bad destination bitmap pointer");
    ASSERTGDI(pvSrc != (PVOID)NULL,"Bad source bitmap pointer");
    ASSERTGDI(prclDst != (PRECTL)NULL,"Bad destination rectangle");
    ASSERTGDI(prclSrc != (PRECTL)NULL,"Bad source rectangle");

    STR_BLT StrBlt;


#ifdef DBG_STRDIR
    if (DbgStrBlt >= 3) {
        DbgPrint("\n-----------------------------------------------------------");
        DbgPrint("StretchBlt\n");
        DbgPrint("rclDst = [0x%8lx,0x%8lx] to [0x%8lx,0x%8lx]\n",prclDst->left,prclDst->top,prclDst->right,prclDst->bottom);
        DbgPrint("rclSrc = [0x%8lx,0x%8lx] to [0x%8lx,0x%8lx]\n",prclSrc->left,prclSrc->top,prclSrc->right,prclSrc->bottom);
    }
#endif

    LONG    WidthDst  = prclDst->right  - prclDst->left;
    LONG    HeightDst = prclDst->bottom - prclDst->top;
    LONG    WidthSrc  = prclSrc->right  - prclSrc->left;
    LONG    HeightSrc = prclSrc->bottom - prclSrc->top;

    ULONG   XSrcToDstIntFloor;
    ULONG   XSrcToDstFracFloor;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   YSrcToDstIntFloor;
    ULONG   YSrcToDstFracFloor;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    LONG    SrcIntScan;
    LONG    DstDeltaScanEnd;

    //
    // calculate EXCLUSIVE start and end points
    //

    LONG    XSrcStart = prclSrc->left;
    LONG    XSrcEnd   = prclSrc->right;
    LONG    XDstStart = prclDst->left;
    LONG    XDstEnd   = prclDst->right;
    LONG    YSrcStart = prclSrc->top;
    LONG    YSrcEnd   = prclSrc->bottom;
    LONG    YDstStart = prclDst->top;
    LONG    YDstEnd   = prclDst->bottom;

    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;

    BOOL    bXSrcClipped = FALSE;
    BOOL    bYSrcClipped = FALSE;
    RECTL   rclDefClip;
    PRECTL  prclBounds = prclClip;
    LONG    LeftClipDistance;
    LONG    TopClipDistance;

    PFN_DIRSTRETCH pfnStr;

    //
    // check for quick-out NULL RECTs. SrcWidth and SrcHeight must be
    // positive here. Mirroring is taken care of earlier.
    //

    if (
        (WidthDst <= 0)  ||
        (HeightDst <= 0) ||
        (WidthSrc <= 0)  ||
        (HeightSrc <= 0)
       )
    {
        return(TRUE);
    }

    //
    // make sure extents fit with the limits of 32 bit integer
    // arithmatic
    //

    if (
        (WidthDst  > STRETCH_MAX_WIDTH) ||
        (HeightDst > STRETCH_MAX_WIDTH) ||
        (WidthSrc  > STRETCH_MAX_WIDTH) ||
        (HeightSrc > STRETCH_MAX_WIDTH)
       )
    {
        return(FALSE);
    }

    //
    // if prclClip is null, then make bounds point to a
    // default clip region of the entire dst rect
    //

    if (prclClip == (PRECTL)NULL) {
        prclBounds = &rclDefClip;
        rclDefClip.left   = 0;
        rclDefClip.right  = DstCx;
        rclDefClip.top    = 0;
        rclDefClip.bottom = DstCy;
    }

    //
    // Calculate X Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*WidthSrc)/WidthDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*WidthSrc -1) / WidthDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {

        LARGE_INTEGER   liWidthSrc;
        LARGE_INTEGER   liQuo;
        ULONG           ulTemp;

        liWidthSrc.LowPart  = (ULONG)-1;
        liWidthSrc.HighPart = WidthSrc-1;

        liQuo = RtlExtendedLargeIntegerDivide(liWidthSrc,(ULONG)WidthDst,(PULONG)NULL);

        ulXDstToSrcIntCeil  = liQuo.HighPart;
        ulXDstToSrcFracCeil = liQuo.LowPart;

        //
        // now add 1, use fake carry
        //

        ulTemp = ulXDstToSrcFracCeil + 1;

        ulXDstToSrcIntCeil += (ulTemp < ulXDstToSrcFracCeil);
        ulXDstToSrcFracCeil = ulTemp;

    }

    //
    // Calculate Y Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*HeightSrc)/HeightDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*HeightSrc -1) / HeightDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {

        LARGE_INTEGER  liHeightSrc;
        LARGE_INTEGER  liQuo;
        ULONG          ulTemp;

        liHeightSrc.LowPart  = (ULONG) -1;
        liHeightSrc.HighPart = HeightSrc-1;

        liQuo = RtlExtendedLargeIntegerDivide(liHeightSrc,HeightDst,NULL);

        ulYDstToSrcIntCeil  = (ULONG)liQuo.HighPart;
        ulYDstToSrcFracCeil = liQuo.LowPart;

        //
        // now add 1, use fake carry
        //

        ulTemp = ulYDstToSrcFracCeil + 1;

        ulYDstToSrcIntCeil += (ulTemp < ulYDstToSrcFracCeil);
        ulYDstToSrcFracCeil = ulTemp;

    }

    //
    // Check for a x clipped src
    //

    if ((XSrcStart < 0)  || (XSrcEnd > (LONG)SrcCx)) {

        bXSrcClipped = TRUE;

        //
        // src is x clipped.
        // calculate Src to Dst mapping, then calculate
        // new XDstStart and/or XDstEnd based on clipped src
        //
        // Calculate X Src to Dst mapping
        //
        // Src->Dst =  ( FLOOR( (2k*WidthDst)/WidthSrc) ) / 2k
        //
        // where 2k = 2 ^ 32
        //

        LARGE_INTEGER   liHalfk = {0x7fffffff,0x00000000};
        LARGE_INTEGER   liWidthDst;
        LARGE_INTEGER   liQuo;
        ULONG           ulTemp;

        bXSrcClipped        = TRUE;

        liWidthDst.HighPart = WidthDst;;
        liWidthDst.LowPart  = 0;

        liQuo = RtlExtendedLargeIntegerDivide(liWidthDst,(ULONG)WidthSrc,(PULONG)NULL);

        XSrcToDstIntFloor  = (ULONG)liQuo.HighPart;
        XSrcToDstFracFloor = liQuo.LowPart;

        //
        // is src left clipped
        //

        if (XSrcStart < 0)
        {

            //
            // clip left Ad = FLOOR[ N * As + (2^(k-1) -1)]/2^k
            //

            LONG            SrcClipped   = -(LONG)XSrcStart;
            ULONG           DeltaDstInt;
            LARGE_INTEGER   liDeltaDstFrac;
            LONG            NewWidthSrc = WidthSrc;

            NewWidthSrc        -= SrcClipped;

            if (NewWidthSrc <= 0)
            {
                return(TRUE);
            }

            //
            // calc fraction N * As
            //

            DeltaDstInt    = (ULONG)SrcClipped * XSrcToDstIntFloor;
            liDeltaDstFrac = RtlEnlargedUnsignedMultiply((ULONG)SrcClipped,XSrcToDstFracFloor);

            liDeltaDstFrac.HighPart += (LONG)DeltaDstInt;

            //
            //   add in 2^(k-1) - 1  = 0x00000000 0x7fffffff
            //

            liDeltaDstFrac = RtlLargeIntegerAdd(liDeltaDstFrac,liHalfk);

            XSrcStart = 0;
            XDstStart += liDeltaDstFrac.HighPart;

        }

        if (XSrcEnd > (LONG)SrcCx)
        {

            //
            // clip right edge, calc src offset from XSrcStart (SrcClipped)
            //
            // clip left Bd = FLOOR[ N * Bs + (2^(k-1) -1)]/2^k
            //
            // Note: use original value of WidthSrc, not value reduced by
            // left clipping.
            //

            LONG             SrcClipped  = XSrcEnd - SrcCx;
            ULONG            DeltaDstInt;
            LARGE_INTEGER   liDstWidth;

            WidthSrc    = WidthSrc - SrcClipped;

            //
            // check for totally src clipped
            //

            if (WidthSrc <= 0)
            {
                return(TRUE);
            }

            //
            // calc N * Bs
            //

            DeltaDstInt = (ULONG)WidthSrc * (ULONG)XSrcToDstIntFloor;
            liDstWidth = RtlEnlargedUnsignedMultiply((ULONG)WidthSrc,XSrcToDstFracFloor);

            liDstWidth.HighPart += (LONG)DeltaDstInt;

            //
            // add in (2^(k-1) -1)
            //

            liDstWidth = RtlLargeIntegerAdd(liDstWidth,liHalfk);

            XSrcEnd = SrcCx;
            XDstEnd = prclDst->left + liDstWidth.HighPart;

        }
    }

    //
    // Now clip Dst in X, and/or calc src clipping effect on dst
    //
    // adjust left and right edges if needed, record
    // distance adjusted for fixing the src
    //

    if (XDstStart < prclBounds->left)
    {
        XDstStart = prclBounds->left;
    }

    if (XDstEnd > prclBounds->right)
    {
        XDstEnd = prclBounds->right;
    }

    //
    // check for totally clipped out dst
    //

    if (XDstEnd <= XDstStart)
    {
        return(TRUE);
    }

    LeftClipDistance = XDstStart - prclDst->left;

    if (!bXSrcClipped && (LeftClipDistance == 0))
    {

        ULONG   ulTempInt,ulTempFrac;

        //
        // calc displacement for .5 in dst and add
        //

        ulTempFrac = (ulXDstToSrcFracCeil >> 1) | (ulXDstToSrcIntCeil << 31);
        ulTempInt  = ulXDstToSrcIntCeil >> 1;

        XSrcStart  += (LONG)ulTempInt;
        ulXFracAccumulator = ulTempFrac;

    } else {

        //
        // calc new src start
        //

        LARGE_INTEGER  liMulResult;
        LARGE_INTEGER  liHalfDest;
        ULONG          ulIntResult;

        //
        // calculate starting XSrc based on LeftClipDistance.
        //

        liMulResult = RtlEnlargedUnsignedMultiply((ULONG)LeftClipDistance,ulXDstToSrcIntCeil);
        ulIntResult = liMulResult.LowPart;

        liMulResult = RtlEnlargedUnsignedMultiply((ULONG)LeftClipDistance,ulXDstToSrcFracCeil);
        liMulResult.HighPart += ulIntResult;

        //
        // calculate change in Src for .5 change in dst. This is just 1/2 INT:FRAC
        //

        liHalfDest.LowPart  = (ulXDstToSrcFracCeil >> 1) | (ulXDstToSrcIntCeil << 31);
        liHalfDest.HighPart = ulXDstToSrcIntCeil >> 1;

        //
        // add changed together for final XSrcStart
        //

        liMulResult = RtlLargeIntegerAdd(liMulResult,liHalfDest);

        //
        // separate int portion and fractional portion
        //

        XSrcStart          = prclSrc->left + liMulResult.HighPart;
        ulXFracAccumulator = liMulResult.LowPart;
    }


    //
    // now check for src and dst clipping in Y
    //
    // Check for a Y clipped src
    //

    if ((YSrcStart < 0)  || (YSrcEnd > (LONG)SrcCy))
    {

        bYSrcClipped = TRUE;

        //
        // src is y clipped.
        // calculate Src to Dst mapping, then calculate
        // new YDstStart and/or YDstEnd based on clipped src
        //
        // Calculate Y Src to Dst mapping
        //
        // Src->Dst =  ( FLOOR( (2k*HeightDst)/HeightSrc) ) / 2k
        //
        // where 2k = 2 ^ 32
        //

        LARGE_INTEGER  liHalfk = {0x7fffffff,0x00000000};
        LARGE_INTEGER  liHeightDst;
        LARGE_INTEGER  liQuo;
        ULONG          ulTemp;

        bYSrcClipped        = TRUE;

        liHeightDst.HighPart = HeightDst;
        liHeightDst.LowPart  = 0;

        liQuo = RtlExtendedLargeIntegerDivide(liHeightDst,(LONG)HeightSrc,(PULONG)NULL);

        YSrcToDstIntFloor  = (ULONG)liQuo.HighPart;
        YSrcToDstFracFloor = liQuo.LowPart;

        //
        // is src top clipped
        //

        if (YSrcStart < 0)
        {

            //
            // clip top
            // clip left Ad = FLOOR[ d/s * As - liHalfK] + 1
            //

            LONG            SrcClipped   = -(LONG)YSrcStart;
            LONG            DeltaDstInt;
            LARGE_INTEGER   liDeltaDst;
            LONG            NewHeightSrc = HeightSrc;

            NewHeightSrc -= SrcClipped;

            if (NewHeightSrc <= 0)
            {
                return(TRUE);
            }

            DeltaDstInt  = SrcClipped * (LONG)YSrcToDstIntFloor;
            liDeltaDst   = RtlEnlargedUnsignedMultiply((ULONG)SrcClipped,YSrcToDstFracFloor);

            liDeltaDst.HighPart += DeltaDstInt;

            //
            // add in (2^(k-1) -1)   "liHalfk"
            //

            liDeltaDst = RtlLargeIntegerAdd(liDeltaDst,liHalfk);

            YSrcStart = 0;
            YDstStart += liDeltaDst.HighPart;

        }

        if (YSrcEnd > (LONG)SrcCy)
        {

            //
            // clip bottom edge, calc src offset from YSrcStart (SrcClipped)
            // clip left Bd = FLOOR[ d/s * Bs + liHalfK]
            //
            // Note: use original value of HeightSrc, not value reduced
            // by top clipping
            //

            LONG            SrcClipped = YSrcEnd - SrcCy;
            ULONG           DeltaDstInt;
            LARGE_INTEGER   liDeltaDstFrac;

            HeightSrc   = HeightSrc - SrcClipped;

            //
            // check for totally src clipped
            //

            if (HeightSrc <= 0)
            {
                return(TRUE);
            }

            DeltaDstInt = (ULONG)HeightSrc * YSrcToDstIntFloor;
            liDeltaDstFrac = RtlEnlargedUnsignedMultiply(HeightSrc,YSrcToDstFracFloor);

            liDeltaDstFrac.HighPart += DeltaDstInt;

            //
            // add in (2^(k-1) -1)   "liHalfk"
            //

            liDeltaDstFrac = RtlLargeIntegerAdd(liDeltaDstFrac,liHalfk);

            YSrcEnd = SrcCy;
            YDstEnd = prclDst->top + liDeltaDstFrac.HighPart;


        }
    }

    //
    // Now clip Dst in Y, and/or calc src clipping effect on dst
    //
    // adjust top and bottom edges if needed, record
    // distance adjusted for fixing the src
    //

    if (YDstStart < prclBounds->top)
    {
        YDstStart = prclBounds->top;
    }

    if (YDstEnd > prclBounds->bottom)
    {
        YDstEnd = prclBounds->bottom;
    }

    //
    // check for totally clipped out dst
    //

    if (YDstEnd <= YDstStart)
    {
        return(TRUE);
    }

    TopClipDistance = YDstStart - prclDst->top;

    if (!bYSrcClipped && (TopClipDistance == 0))
    {

        ULONG   ulTempInt,ulTempFrac;

        //
        // calc displacement for .5 in dst and add
        //

        ulTempFrac = (ulYDstToSrcFracCeil >> 1) | (ulYDstToSrcIntCeil << 31);
        ulTempInt  = ulYDstToSrcIntCeil >> 1;

        YSrcStart  += (LONG)ulTempInt;
        ulYFracAccumulator = ulTempFrac;

    } else {

        //
        // calc new src start
        //

        LARGE_INTEGER  liMulResult;
        LARGE_INTEGER  liHalfDest;
        ULONG          ulIntResult;

        //
        // calculate Src offset for clipping offset in Dst
        //

        liMulResult = RtlEnlargedUnsignedMultiply((ULONG)TopClipDistance,ulYDstToSrcIntCeil);
        ulIntResult = liMulResult.LowPart;

        liMulResult = RtlEnlargedUnsignedMultiply(TopClipDistance,ulYDstToSrcFracCeil);
        liMulResult.HighPart += ulIntResult;

        //
        // calculate change in Src for .5 change in dst. This is just 1/2 INT:FRAC
        //

        liHalfDest.LowPart  = (ulYDstToSrcFracCeil >> 1) | (ulYDstToSrcIntCeil << 31);
        liHalfDest.HighPart = ulYDstToSrcIntCeil >> 1;

        //
        // add changed together for final YSrcStart
        //

        liMulResult = RtlLargeIntegerAdd(liMulResult,liHalfDest);

        //
        // separate int and frac portions
        //

        YSrcStart          = prclSrc->top + liMulResult.HighPart;
        ulYFracAccumulator = liMulResult.LowPart;
    }

    //
    // fill out blt structure, then call format specific stretch code
    //


#ifdef DBG_STRDIR

    if (DbgStrBlt >= 2) {

        DbgPrint("StretchBlt:\n");
        DbgPrint("XSrcStart = %li\n",XSrcStart);
        DbgPrint("YSrcStart = %li\n",YSrcStart);
        DbgPrint("XDstStart,XDstEnd  = %li to %li\n",XDstStart,XDstEnd);
        DbgPrint("YDstStart,YDstEnd  = %li to %li\n",YDstStart,YDstEnd);
    }
#endif

    //
    // caclulate starting scan line address, since the inner loop
    // routines are format dependent, they must add XDstStart/XSrcStart
    // to pjDstScan/pjSrcScan to get the actual starting pixel address
    //

    StrBlt.pjSrcScan            = (PBYTE)pvSrc + (YSrcStart * lDeltaSrc);
    StrBlt.pjDstScan            = (PBYTE)pvDst + (YDstStart * lDeltaDst);

    StrBlt.lDeltaSrc            = lDeltaSrc;
    StrBlt.XSrcStart            = XSrcStart;
    StrBlt.XDstStart            = XDstStart;
    StrBlt.lDeltaDst            = lDeltaDst;
    StrBlt.XDstEnd              = XDstEnd;
    StrBlt.YDstCount            = YDstEnd - YDstStart;
    StrBlt.ulXDstToSrcIntCeil   = ulXDstToSrcIntCeil;
    StrBlt.ulXDstToSrcFracCeil  = ulXDstToSrcFracCeil;
    StrBlt.ulYDstToSrcIntCeil   = ulYDstToSrcIntCeil;
    StrBlt.ulYDstToSrcFracCeil  = ulYDstToSrcFracCeil;
    StrBlt.ulXFracAccumulator   = ulXFracAccumulator;
    StrBlt.ulYFracAccumulator   = ulYFracAccumulator;

    pfnStr = pfnStrArray[ (((XDstEnd - XDstStart) < 7) << 3)  | iBitmapFormat];

    (*pfnStr)(&StrBlt);

    //
    // save clipped dst in prclTrim
    //

    prclTrim->left   = XDstStart;
    prclTrim->right  = XDstEnd;
    prclTrim->top    = YDstStart;
    prclTrim->bottom = YDstEnd;

    return(TRUE);
}



#if !defined (_MIPS_)
#if !defined (_X86_)

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8
*
* Routine Description:
*
*   Stretch blt 8->8
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID
vDirectStretch8(
    PSTR_BLT pStrBlt
    )
{

    LONG    xDst      = pStrBlt->XDstStart;
    LONG    xSrc      = pStrBlt->XSrcStart;

    PBYTE   pjSrcScan = pStrBlt->pjSrcScan + xSrc;
    PBYTE   pjSrc;
    PBYTE   pjDst     = pStrBlt->pjDstScan + xDst;
    PBYTE   pjDstEnd;

    LONG    yCount    = pStrBlt->YDstCount;
    ULONG   StartAln  = (ULONG)((ULONG_PTR)pjDst & 0x03);
    LONG    WidthX    = pStrBlt->XDstEnd - xDst;
    LONG    WidthXAln;
    ULONG   EndAln    = (ULONG)((ULONG_PTR)(pjDst + WidthX) & 0x03);

    ULONG   ulDst;
    BOOL    bExpand   = (pStrBlt->ulYDstToSrcIntCeil == 0);

    ULONG   xAccum;
    ULONG   xInt   = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac  = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   xTmp;

    ULONG   yAccum = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac  = pStrBlt->ulYDstToSrcFracCeil;
    LONG    yInt   = 0;
    ULONG   yTmp;
    LONG    lDstStride = pStrBlt->lDeltaDst - WidthX;

    WidthXAln = WidthX - EndAln - ((4-StartAln) & 0x03);

    if (yCount <= 0)
    {
        return;
    }

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (!bExpand)
    {
        yInt = pStrBlt->lDeltaSrc * (LONG)pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // loop drawing each scan line
    //
    //
    // at least 7 wide (DST) blt
    //

    do {

        BYTE    jSrc0,jSrc1,jSrc2,jSrc3;
        ULONG   yTmp     = yAccum + yFrac;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        switch (StartAln) {
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        }

        pjDstEnd  = pjDst + WidthXAln;

        while (pjDst != pjDstEnd)
        {

            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc1 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            jSrc2 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc3 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            ulDst = (jSrc3 << 24) | (jSrc2 << 16) | (jSrc1 << 8) | jSrc0;

            *(PULONG)pjDst = ulDst;
            pjDst += 4;
        }

        switch (EndAln) {
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
        }

        pjSrcScan += yInt;

        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }

        yAccum = yTmp;

        pjDst     += lDstStride;

    } while (--yCount);
}

#endif
#endif



/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8Narrow
*
* Routine Description:
*
*   Stretch blt 8->8 when the width is 7 or less
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID
vDirectStretch8Narrow(
    PSTR_BLT pStrBlt
    )
{

    LONG    xDst      = pStrBlt->XDstStart;
    LONG    xSrc      = pStrBlt->XSrcStart;

    PBYTE   pjSrcScan = pStrBlt->pjSrcScan + xSrc;
    PBYTE   pjSrc;
    PBYTE   pjDst     = pStrBlt->pjDstScan + xDst;
    PBYTE   pjDstEnd;

    LONG    yCount    = pStrBlt->YDstCount;
    LONG    WidthX    = pStrBlt->XDstEnd - xDst;

    ULONG   ulDst;

    ULONG   xAccum;
    ULONG   xInt   = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac  = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   xTmp;

    ULONG   yAccum = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac  = pStrBlt->ulYDstToSrcFracCeil;
    LONG    yInt   = 0;
    ULONG   yTmp;
    LONG    lDstStride = pStrBlt->lDeltaDst - WidthX;

    if (yCount <= 0)
    {
        return;
    }

    yInt = pStrBlt->lDeltaSrc * (LONG)pStrBlt->ulYDstToSrcIntCeil;

    //
    // Narrow blt
    //

    do {

        ULONG  yTmp = yAccum + yFrac;
        BYTE   jSrc0;
        PBYTE  pjDstEndNarrow = pjDst + WidthX;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        do {
            jSrc0    = *pjSrc;
            xTmp     = xAccum + xFrac;
            pjSrc    = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum   = xTmp;
        } while (pjDst != pjDstEndNarrow);

        pjSrcScan += yInt;

        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }

        yAccum = yTmp;
        pjDst     += lDstStride;

    } while (--yCount);

}



/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch16
*
* Routine Description:
*
*   Stretch blt 16->16
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID
vDirectStretch16(
    PSTR_BLT pStrBlt
    )
{

    LONG    xDst      = pStrBlt->XDstStart;
    LONG    xSrc      = pStrBlt->XSrcStart;

    PUSHORT pusSrcScan = (PUSHORT)(pStrBlt->pjSrcScan) + xSrc;
    PUSHORT pusSrc;
    PUSHORT pusDst     = (PUSHORT)(pStrBlt->pjDstScan) + xDst;
    PUSHORT pusDstEnd;

    LONG    yCount    = pStrBlt->YDstCount;
    ULONG   StartAln  = ((ULONG)(ULONG_PTR)pusDst & 0x02) >> 1;
    LONG    WidthX    = pStrBlt->XDstEnd - xDst;
    LONG    WidthXAln;
    ULONG   EndAln    = ((ULONG)(ULONG_PTR)(pusDst + WidthX) & 0x02) >> 1;

    ULONG   ulDst;
    BOOL    bExpand   = (pStrBlt->ulYDstToSrcIntCeil == 0);

    ULONG   xAccum;
    ULONG   xInt   = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac  = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   xTmp;

    ULONG   yAccum = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac  = pStrBlt->ulYDstToSrcFracCeil;
    LONG    yInt   = 0;
    ULONG   yTmp;
    LONG    lDstStride = pStrBlt->lDeltaDst - 2*WidthX;

    WidthXAln = WidthX - EndAln - StartAln;

    if (yCount <= 0)
    {
        return;
    }

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (!bExpand)
    {
        yInt = pStrBlt->lDeltaSrc * (LONG)pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // Loop stretching each scan line
    //

    do {

        USHORT  usSrc0,usSrc1;
        ULONG   yTmp = yAccum + yFrac;

        pusSrc  = pusSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        if (StartAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
            xAccum    = xTmp;
        }

        pusDstEnd  = pusDst + WidthXAln;

        while (pusDst != pusDstEnd)
        {

            usSrc0 = *pusSrc;
            xTmp   = xAccum + xFrac;
            pusSrc = pusSrc + xInt + (xTmp < xAccum);

            usSrc1 = *pusSrc;
            xAccum = xTmp + xFrac;
            pusSrc = pusSrc + xInt + (xAccum < xTmp);

            ulDst = (ULONG)((usSrc1 << 16) | usSrc0);

            *(PULONG)pusDst = ulDst;
            pusDst+=2;
        }

        if (EndAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
        }

        pusSrcScan = (PUSHORT)((PBYTE)pusSrcScan + yInt);

        if (yTmp < yAccum)
        {
            pusSrcScan = (PUSHORT)((PBYTE)pusSrcScan + pStrBlt->lDeltaSrc);
        }

        yAccum = yTmp;

        pusDst = (PUSHORT)((PBYTE)pusDst + lDstStride);

    } while (--yCount);
}



/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch32
*
* Routine Description:
*
*   Stretch blt 32->32
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID
vDirectStretch32(
    PSTR_BLT pStrBlt
    )
{

    LONG    xDst      = pStrBlt->XDstStart;
    LONG    xSrc      = pStrBlt->XSrcStart;

    PULONG  pulSrcScan = (PULONG)(pStrBlt->pjSrcScan) + xSrc;
    PULONG  pulSrc;
    PULONG  pulDst     = (PULONG)(pStrBlt->pjDstScan) + xDst;
    PULONG  pulDstEnd;

    LONG    yCount    = pStrBlt->YDstCount;
    LONG    WidthX    = pStrBlt->XDstEnd - xDst;

    ULONG   ulDst;
    BOOL    bExpand   = (pStrBlt->ulYDstToSrcIntCeil == 0);

    ULONG   xAccum;
    ULONG   xInt   = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac  = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   xTmp;

    ULONG   yAccum = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac  = pStrBlt->ulYDstToSrcFracCeil;
    LONG    yInt   = 0;
    ULONG   yTmp;
    LONG    lDstStride = pStrBlt->lDeltaDst - 4*WidthX;

    if (yCount <= 0)
    {
        return;
    }

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (!bExpand)
    {
        yInt = pStrBlt->lDeltaSrc * (LONG)pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // general
    //

    do {

        ULONG   ulSrc;
        ULONG   yTmp     = yAccum + yFrac;

        pulSrc  = pulSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        pulDstEnd  = pulDst + WidthX;

        while (pulDst != pulDstEnd)
        {

            ulSrc  = *pulSrc;
            xTmp   = xAccum + xFrac;
            pulSrc = pulSrc + xInt + (xTmp < xAccum);
            *(PULONG)pulDst = ulSrc;
            pulDst++;
            xAccum = xTmp;
        }

        pulSrcScan = (PULONG)((PBYTE)pulSrcScan + yInt);

        if (yTmp < yAccum)
        {
            pulSrcScan = (PULONG)((PBYTE)pulSrcScan + pStrBlt->lDeltaSrc);
        }

        yAccum = yTmp;

        pulDst = (PULONG)((PBYTE)pulDst + lDstStride);

    } while (--yCount);
}

VOID vDirectStretchError(
    PSTR_BLT pstr
    )
{
#ifdef DBG_STRDIR
    DbgPrint("Illegal stretch blt acceleration called\n");
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\strchblt.cxx ===
/******************************Module*Header*******************************\
* Module Name: strchblt.cxx
*
* This contains the API and DDI entry points to the graphics engine
* for StretchBlt and EngStretchBlt.
*
* Created: 04-Apr-1991 10:57:37
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "stretch.hxx"

//the limit of our coordinate systems (2^27)
#define MAX_STRETCH_COOR 128000000L

ULONG gaulMonoExpand[] = {
    0x00000000,     //
    0x00000001,     // BMF_1BPP
    0x0000000F,     // BMF_4BPP
    0x000000FF,     // BMF_8BPP
    0x0000FFFF,     // BMF_16BPP
    0x00FFFFFF,     // BMF_24BPP
    0xFFFFFFFF      // BMF_32BPP
 };

/******************************Public*Routine******************************\
* GreStretchBlt
*
* Stretches the source image to the destination.
*
* Returns: TRUE if successful, FALSE for failure.
*
* History:
*  Thu Mar-05-1998 -by- Samer Arafeh [samera]
* Support LAYOUT_BITMAPORIENTATIONPRESERVED. Make sure
* to exit thru one of the RETURN_XXX labels if you are writing
* code past the layout code (see comments below).
*
*  Tue 02-Jun-1992 -by- Patrick Haluptzok [patrickh]
* Fix clipping bugs
*
*  21-Mar-1992 -by- Donald Sidoroff [donalds]
* Rewrote it.
*
*  15-Jan-1992 -by- Patrick Haluptzok patrickh
* add mask support
*
*  Thu 19-Sep-1991 -by- Patrick Haluptzok [patrickh]
* add support for rops
*
*  07-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL GreStretchBlt(
HDC     hdcTrg,
int     x,
int     y,
int     cx,
int     cy,
HDC     hdcSrc,
int     xSrc,
int     ySrc,
int     cxSrc,
int     cySrc,
DWORD   rop4,
DWORD   crBackColor
)
{
    GDITraceHandle2(GreStretchBlt, "(%X, %d, %d, %d, %d, %X, %d, %d, %d, %d, %X, %X)\n", (va_list)&hdcTrg, hdcTrg, hdcSrc);
    return (GreStretchBltInternal(
                hdcTrg, x, y, cx, cy,
                hdcSrc, xSrc, ySrc, cxSrc, cySrc,
                rop4, crBackColor, 0));
}

BOOL GreStretchBltInternal(
HDC     hdcTrg,
int     x,
int     y,
int     cx,
int     cy,
HDC     hdcSrc,
int     xSrc,
int     ySrc,
int     cxSrc,
int     cySrc,
DWORD   rop4,
DWORD   crBackColor,
FLONG   ulFlags
)
{
    BLTRECORD   blt;
    BOOL bRet;
    POINTL ptOrgDst;
    DWORD  OrgRop4 = rop4, dwOldLayout;

    rop4 = rop4 & ~NOMIRRORBITMAP;

// [Bug #278291] - CAPTUREBLT
// The CAPTUREBLT rop flag is used for screen capture. When it's set, we bypass
// the sprite code which normally hides the sprites, so that the caller gets
// an exact copy of what's on the screen (except for the cursor).

    BOOL bCaptureBlt = 0;
    if (rop4 & CAPTUREBLT)
    {
        bCaptureBlt = 1;
        rop4 = rop4 & ~CAPTUREBLT;
    }

// Initialize the blt record

    blt.rop((rop4 | (rop4 & 0x00ff0000) << 8) >> 16);

// Convert the rop into something useful.

    ULONG ulAvec  = ((ULONG) gajRop3[blt.ropFore()]) |
                    ((ULONG) gajRop3[blt.ropBack()]);

// See if we can special case this operation

    if (!(ulAvec & AVEC_NEED_SOURCE))
    {
    // We can't require a mask, since one can't be passed.

        if (blt.ropFore() == blt.ropBack())
            return(NtGdiPatBlt(hdcTrg, x, y, cx, cy, rop4));
    }

// Lock the DC's, no optimization is made for same surface

    DCOBJ   dcoTrg(hdcTrg);
    DCOBJ   dcoSrc(hdcSrc);

    if (dcoTrg.bValid() && !dcoTrg.bStockBitmap())
    {
        ULONG ulDirty = dcoTrg.pdc->ulDirty();

        if ( ulDirty & DC_BRUSH_DIRTY)
        {
           GreDCSelectBrush (dcoTrg.pdc, dcoTrg.pdc->hbrush());
        }
    }

    if (!dcoTrg.bValid() ||
         dcoTrg.bStockBitmap() ||
        (!dcoSrc.bValid() && (ulAvec & AVEC_NEED_SOURCE)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(!(ulAvec & AVEC_NEED_SOURCE) || dcoSrc.bValid());
    }

// Lock the relevant surfaces

    DEVLOCKBLTOBJ dlo;

    if (ulAvec & AVEC_NEED_SOURCE)
        dlo.bLock(dcoTrg, dcoSrc);
    else
        dlo.bLock(dcoTrg);

    if (!dlo.bValid())
    {
        return(dcoTrg.bFullScreen());
    }

    if (!dcoTrg.bValidSurf() || !dcoSrc.bValidSurf() || !dcoSrc.pSurface()->bReadable())
    {
        if ((dcoTrg.dctp() == DCTYPE_INFO) || !dcoSrc.bValidSurf())
        {
            if (dcoTrg.fjAccum())
            {
                EXFORMOBJ   exo(dcoTrg, WORLD_TO_DEVICE);
                ERECTL      ercl(x, y, x + cx, y + cy);

                if (exo.bXform(ercl))
                {
                    ercl.vOrder();
                    dcoTrg.vAccumulate(ercl);
                }
            }

            // if we need a source and the source isn't valid, return failure

            return(TRUE);
        }

    // Do the security test on SCREEN to MEMORY blits.

        if (dcoSrc.bDisplay() && !dcoTrg.bDisplay())
        {
            if (!UserScreenAccessCheck())
            {
                SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
                return(FALSE);
            }
        }

    // If the source isn't a DISPLAY we should exit

        if (!dcoSrc.bDisplay())
            return(FALSE);
    }

    if(dcoTrg.bDisplay() && !dcoTrg.bRedirection() && dcoSrc.bValidSurf() && !dcoSrc.bDisplay() && !UserScreenAccessCheck())
    {
        SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
        return(FALSE);
    }

// We can't require a mask, since one can't be passed.

    if (blt.ropFore() != blt.ropBack())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    // ATTENTION: Please pay attention here
    //
    // Any code you are going to write past the following
    // section of code (mirroring code below that changes the
    // windows origin of the DC) should exit (return) -if it needs-
    // through either RETURN_FAIL, RETURN_FAIL_ONLY or RETURN_STATUS
    // labels by doing a goto statement to them. The reason for this
    // is to restore the DC's window origin by executing
    // the code located at the RETURN_STATUS label (see end of fn). [samera]

    //
    // Let's preserve the bitmap shape if the target DC
    // is a mirrored one. [samera]
    //
    if ( (((OrgRop4 & NOMIRRORBITMAP) && MIRRORED_DC(dcoTrg.pdc) ) ||
           MIRRORED_DC_NO_BITMAP_FLIP(dcoTrg.pdc)) &&
          (hdcSrc != hdcTrg) ) {
        dcoTrg.pdc->vGet_ptlWindowOrg( &ptOrgDst );
        dwOldLayout = dcoTrg.pdc->dwSetLayout(-1, 0);
        x = ptOrgDst.x - x - cx;

        // Restore the DC if the flag is in the DC and not part
        // of the Rops. [samera]
        //
        OrgRop4 = NOMIRRORBITMAP;
    } else {
        OrgRop4 = 0;
    }

    HANDLE hcmXform = NULL;

    // Don't put any goto's before here.
    //
    // [Bug #278291] - CAPTUREBLT
    // If we're doing a screen capture, hide the cursor, and set a
    // flag in the destination surface, to notify the sprite code.

    SURFACE *pSurfTrg = dcoTrg.pSurfaceEff();
    SURFACE *pSurfSrc = dcoSrc.pSurfaceEff();
    PDEVOBJ pdoSrc(pSurfSrc->hdev());
    POINTL pointerPos;

    if (bCaptureBlt)
    {
        if (dcoSrc.bDisplay()  &&
            !dcoSrc.bPrinter() &&
            (dcoSrc.hdev() == dcoTrg.hdev()))
        {
            ASSERTGDI(pSurfTrg, "Null destination surface");
            ASSERTGDI(pSurfSrc, "Null source surface");

            // Because the sprites are going to be visible, we must explicitly
            // hide the cursor (since it may be a sprite).

            // Grab the pointer semaphore to ensure that no-one else moves
            // the pointer until we restore it.

            GreAcquireSemaphoreEx(pdoSrc.hsemPointer(), SEMORDER_POINTER, dcoSrc.hsemDcDevLock());

            pointerPos = pdoSrc.ptlPointer();

            //
            // Don't make this a procedural mouse move for TS otherwise during
            // scenarios like magnifier with a lot of stretchblits the client
            // gets repeated programmatic mouse moves (with delay) that cause
            // it to get a jerky mouse. See bug#450927
            //
            GreMovePointer(pSurfSrc->hdev(), -1, -1, MP_NORMAL);

            // Set the 'IncludeSprites' flag in the destination surface. This tells
            // bSpBltFromScreen to include the sprites.

            pSurfTrg->vSetIncludeSprites();
        }
        else
        {
            // Clear bCaptureBlt, to bypass the cleanup code at the end.

            bCaptureBlt = 0;
        }
    }

// Fill the BLTRECORD

    blt.pxoTrg()->vInit(dcoTrg,WORLD_TO_DEVICE);
    blt.pSurfTrg(dcoTrg.pSurfaceEff());
    blt.ppoTrg()->ppalSet(blt.pSurfTrg()->ppal());
    blt.ppoTrgDC()->ppalSet(dcoTrg.ppal());

    blt.pxoSrc()->vInit(dcoSrc,WORLD_TO_DEVICE);
    blt.pSurfSrc(dcoSrc.pSurfaceEff());
    blt.ppoSrc()->ppalSet(blt.pSurfSrc()->ppal());
    blt.ppoSrcDC()->ppalSet(dcoSrc.ppal());

    if (crBackColor == (COLORREF)-1)
        crBackColor = dcoSrc.pdc->ulBackClr();

// Initialize the color translation object.
//
// No ICM with StretchBlt() so pass NULL color transform to XLATEOBJ.

    if (ulFlags & STRETCHBLT_ENABLE_ICM)
    {
        hcmXform = dcoTrg.pdc->hcmXform();
    }

    if (!blt.pexlo()->bInitXlateObj(hcmXform,               // hColorTransform
                                    dcoTrg.pdc->lIcmMode(), // ICM mode
                                   *blt.ppoSrc(),
                                   *blt.ppoTrg(),
                                   *blt.ppoSrcDC(),
                                   *blt.ppoTrgDC(),
                                    dcoTrg.pdc->crTextClr(),
                                    dcoTrg.pdc->crBackClr(),
                                    crBackColor))
    {
        WARNING("bInitXlateObj failed in StretchBlt\n");
        goto RETURN_FAIL_ONLY;
    }

    blt.flSet(BLTREC_PXLO);

    if (ulAvec & AVEC_NEED_PATTERN)
    {
        // Set up the brush if necesary.
        blt.pbo(dcoTrg.peboFill());

        if ((dcoTrg.ulDirty() & DIRTY_FILL) || (dcoTrg.pdc->flbrush() & DIRTY_FILL))
        {
            dcoTrg.ulDirtySub(DIRTY_FILL);
            dcoTrg.pdc->flbrushSub(DIRTY_FILL);

            blt.pbo()->vInitBrush(
                                dcoTrg.pdc,
                                dcoTrg.pdc->pbrushFill(),
                               *((XEPALOBJ *) blt.ppoTrgDC()),
                               *((XEPALOBJ *) blt.ppoTrg()),
                                blt.pSurfTrg());
        }

        blt.Brush(dcoTrg.pdc->ptlFillOrigin());
    }
    else
    {
        blt.pbo (NULL);
    }

// Initialize some stuff for DDI.

    blt.pSurfMsk((SURFACE  *) NULL);

// Set the source rectangle

    if (blt.pxoSrc()->bRotation() || !blt.Src(xSrc, ySrc, cxSrc, cySrc))
    {
        goto RETURN_FAIL;
    }

// Don't call the driver with an empty source rectangle.

    if((ulAvec & AVEC_NEED_SOURCE) &&
       (blt.perclSrc()->bEmpty()))
    {
        // We really should fail here, but return TRUE in order to maintain
        // backward compatibility.
        bRet = TRUE;
        goto RETURN_STATUS;
    }

// Now all the essential information has been collected.  We now
// need to check for promotion or demotion and call the appropriate
// method to finish the blt.  If we rotate we must send the call away.

    if (blt.pxoTrg()->bRotation())
    {
        blt.TrgPlg(x, y, cx, cy);
        bRet = blt.bRotate(dcoTrg, dcoSrc, ulAvec,  dcoTrg.pdc->jStretchBltMode());
        goto RETURN_STATUS;
    }

// We can now set the target rectangle

    if (!blt.Trg(x, y, cx, cy))
    {
        goto RETURN_FAIL;
    }

// If we are halftoning or the extents aren't equal, call bStretch

    if (( dcoTrg.pdc->jStretchBltMode() == HALFTONE) || !blt.bEqualExtents()) {
        bRet = blt.bStretch(dcoTrg, dcoSrc, ulAvec,  dcoTrg.pdc->jStretchBltMode() );
        goto RETURN_STATUS;
    }

// Since there can't be a mask, call bBitBlt.

    bRet = blt.bBitBlt(dcoTrg, dcoSrc, ulAvec);
    goto RETURN_STATUS;


RETURN_FAIL:

    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);

RETURN_FAIL_ONLY:

    bRet = FALSE;

RETURN_STATUS:
    if (OrgRop4 & NOMIRRORBITMAP) {
        dcoTrg.pdc->dwSetLayout(-1, dwOldLayout);
    }

    // [Bug #278291] - CAPTUREBLT
    // Undo what was done above

    if (bCaptureBlt)
    {
        // Clear the flag

        pSurfTrg->vClearIncludeSprites();

        // Restore the cursor

        GreMovePointer(pSurfSrc->hdev(),
                       pointerPos.x,
                       pointerPos.y,
                       MP_NORMAL);
            
        GreReleaseSemaphoreEx(pdoSrc.hsemPointer());

    }

    return bRet;
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bStretch(dcoTrg, dcoSrc, ulAvec, jMode)
*
* Do a stretch blt from the blt record
*
* History:
*  21-Mar-1992 -by- Donald Sidoroff [donalds]
* Rewrote it.
\**************************************************************************/

BOOL BLTRECORD::bStretch(
DCOBJ&  dcoTrg,
DCOBJ&  dcoSrc,
ULONG   ulAvec,
BYTE    jMode)
{
// Make the target rectangle well ordered and remember flips.

    vOrderStupid(perclTrg());

// before we do a pattern only blt.  The mask will be replaced in the
// BLTRECORD and its offset correctly adjusted.

    if (!(ulAvec & AVEC_NEED_SOURCE))
    {
        vOrderStupid(perclMask());

    // Before we call to the driver, validate that the mask will actually
    // cover the entire target.

        if (pSurfMskOut() != (SURFACE *) NULL)
        {
            if ((aptlMask[0].x < 0) ||
                (aptlMask[0].y < 0) ||
                (aptlMask[1].x > pSurfMsk()->sizl().cx) ||
                (aptlMask[1].y > pSurfMsk()->sizl().cy))
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }
        }

        SURFMEM   dimoMask;

        if ((ulAvec & AVEC_NEED_MASK) && !bStretch(dimoMask, (ULONG) jMode))
            return(FALSE);

    // Now, we need to fake out the source extents for the mask

        aptlSrc[1].x = aptlSrc[0].x + (aptlTrg[1].x - aptlTrg[0].x);
        aptlSrc[1].y = aptlSrc[0].y + (aptlTrg[1].y - aptlTrg[0].y);

        return(bBitBlt(dcoTrg, dcoTrg, ulAvec));
    }

    PDEVOBJ pdoTrg(pSurfTrg()->hdev());

    // WINBUG #298689 4-4-2001 jasonha  Handle any device stretch to Meta
    BOOL bTrgMetaDriver = (dcoTrg.bSynchronizeAccess() && pdoTrg.bValid() && pdoTrg.bMetaDriver());

    // If the devices are on different PDEV's and we are not targeting a meta driver
    // we can only call driver if the Engine manages one or both of the surfaces.
    // Check for this.

    // WINBUG #256643 12-13-2000 bhouse Need to review handling of cross device operatons
    // We need to review this logic.  This check and others like it are spread
    // throughout GDI and are in some cases now outdated.  For example, there
    // is no reason not to call the multi-mon driver as a target.
    // We are fixing this case now but we should examine this check in light
    // of other possible cases.

    if (dcoTrg.hdev() != dcoSrc.hdev())
    {
        if (!bTrgMetaDriver)
        {
            if(((dcoTrg.pSurfaceEff()->iType() != STYPE_BITMAP)
             || (dcoTrg.pSurfaceEff()->dhsurf() != NULL)) &&
            ((dcoSrc.pSurfaceEff()->iType() != STYPE_BITMAP)
             || (dcoSrc.pSurfaceEff()->dhsurf() != NULL)))
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }
        }
    }


// Before we get too involved, validate that the mask will actually
// cover the entire source.

    if (pSurfMskOut() != (SURFACE *) NULL)
    {
        if ((aptlMask[0].x < 0) ||
            (aptlMask[0].y < 0) ||
            (aptlMask[1].x > pSurfMsk()->sizl().cx) ||
            (aptlMask[1].y > pSurfMsk()->sizl().cy))
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }
    }

// Make the source rectangle well ordered and remember flips.

    vOrderStupid(perclSrc());
    vOrderAmnesia(perclMask());

// Win 3.1 has a lovely little 'feature' where they decide
// you called StretchBlt but you really didn't mean it.  This
// ludicrous behaviour needs to be supported forever because
// some pinhead applications have grown to rely on this act
// of insanity.  Flips cancel this, since EngBitBlt can't
// handle negative extents. Also note that we can't fail to
// call DanielC if HALFTONE has been requested. [donalds]

    if ((jMode != HALFTONE) &&
        (dcoTrg.pdc->iGraphicsMode() != GM_ADVANCED) &&
        (pSurfMskOut() == (SURFACE *) NULL) &&
        !(flState & (BLTREC_MIRROR_X | BLTREC_MIRROR_Y)))
    {
        LONG    lHStr = (perclTrg()->right - perclTrg()->left) -
                        (perclSrc()->right - perclSrc()->left);

        LONG    lVStr = (perclTrg()->bottom - perclTrg()->top) -
                        (perclSrc()->bottom - perclSrc()->top);

        if ((lHStr >= -1) && (lHStr <= 1) &&
            (lVStr >= -1) && (lVStr <= 1))
            return(bBitBlt(dcoTrg, dcoSrc, ulAvec, lHStr, lVStr));
    }


// Accumulate bounds.  We can do this before knowing if the operation is
// successful because bounds can be loose.

    if (dcoTrg.fjAccum())
        dcoTrg.vAccumulate(*perclTrg());

// With a fixed DC origin we can change the rectangles to SCREEN coordinates.

    *perclTrg() += dcoTrg.eptlOrigin();
    *perclSrc() += dcoSrc.eptlOrigin();

// Compute the clipping complexity and maybe reduce the exclusion rectangle.

    ECLIPOBJ eco(dcoTrg.prgnEffRao(), *perclTrg());

// Check the destination which is reduced by clipping.

    if (eco.erclExclude().bEmpty())
        return(TRUE);

// Compute the exclusion rectangle.

    ERECTL erclExclude = eco.erclExclude();

// If we are going to the same source, prevent bad overlap situations

    if (dcoSrc.pSurface() == dcoTrg.pSurface())
    {
        if (perclSrc()->left   < erclExclude.left)
            erclExclude.left   = perclSrc()->left;

        if (perclSrc()->top    < erclExclude.top)
            erclExclude.top    = perclSrc()->top;

        if (perclSrc()->right  > erclExclude.right)
            erclExclude.right  = perclSrc()->right;

        if (perclSrc()->bottom > erclExclude.bottom)
            erclExclude.bottom = perclSrc()->bottom;
    }

// We might have to exclude the source or the target, get ready to do either.

    DEVEXCLUDEOBJ dxo;

    PDEVOBJ pdoSrc(pSurfSrc()->hdev());

// They can't both be display

    if (dcoSrc.bDisplay())
    {
        ERECTL ercl(0,0,pSurfSrc()->sizl().cx,pSurfSrc()->sizl().cy);

        if (dcoSrc.pSurface() == dcoTrg.pSurface())
            ercl *= erclExclude;
        else
            ercl *= *perclSrc();

        dxo.vExclude(dcoSrc.hdev(),&ercl,NULL);
    }
    else if (dcoTrg.bDisplay())
        dxo.vExclude(dcoTrg.hdev(),&erclExclude,&eco);

// Dispatch the call.

    PFN_DrvStretchBltROP pfn = PPFNGET(pdoTrg, StretchBltROP, pSurfTrg()->flags());

    if (!bTrgMetaDriver)
    {
        if (jMode == HALFTONE)
        {
            // Don't call the driver if it doesn't do halftone.
            if (!(pdoTrg.flGraphicsCapsNotDynamic() & GCAPS_HALFTONE))
                pfn = (PFN_DrvStretchBltROP)EngStretchBltROP;
        }

        // WINBUG #95246 3-17-2000 jasonha GDI: StretchBlt optimizations: Let drivers handle more cases
        // Don't call the driver if the source rectangle exceeds the source
        // surface. Some drivers punt using a duplicate of the source
        // SURFOBJ, but without preserving its sizlBitmap member.

        BOOL bSrcExceeds = FALSE;

        if(pSurfSrc()->iType() == STYPE_DEVICE && pdoSrc.bValid() && pdoSrc.bMetaDriver())
        {
            if((perclSrc()->left < pdoSrc.pptlOrigin()->x ) ||
               (perclSrc()->top  < pdoSrc.pptlOrigin()->y ) ||
               (perclSrc()->right > pdoSrc.pptlOrigin()->x + pSurfSrc()->sizl().cx) ||
               (perclSrc()->bottom > pdoSrc.pptlOrigin()->y + pSurfSrc()->sizl().cy))
            {
                bSrcExceeds = TRUE;
            }

        }
        else
        {
            if((perclSrc()->left < 0) ||
               (perclSrc()->top  < 0) ||
               (perclSrc()->right  > pSurfSrc()->sizl().cx) ||
               (perclSrc()->bottom > pSurfSrc()->sizl().cy))
            {
                bSrcExceeds = TRUE;
            }
        }

        if( bSrcExceeds )
        {
            pfn = (PFN_DrvStretchBltROP)EngStretchBltROP;
        }

        // WINBUG #95246 3-17-2000 jasonha GDI: StretchBlt optimizations: Let drivers handle more cases
        // Don't call the driver if the source overlaps the destination.
        // Some drivers don't handle this case.
        
        if ((pSurfTrg() == pSurfSrc()) &&
            bIntersect(perclSrc(), perclTrg()))
        {
            pfn = (PFN_DrvStretchBltROP)EngStretchBltROP;
        }
    }

// Deal with target mirroring

    vMirror(perclTrg());

// Inc the target surface uniqueness

    INC_SURF_UNIQ(pSurfTrg());

    return((*pfn)(pSurfTrg()->pSurfobj(),
               pSurfSrc()->pSurfobj(),
               (rop4 == 0x0000CCCC) ? (SURFOBJ *) NULL : pSurfMskOut()->pSurfobj(),
               &eco,
               pexlo()->pxlo(),
               (dcoTrg.pColorAdjustment()->caFlags & CA_DEFAULT) ?
                   (PCOLORADJUSTMENT)NULL : dcoTrg.pColorAdjustment(),
               &dcoTrg.pdc->ptlFillOrigin(),
               perclTrg(),
               perclSrc(),
               aptlMask,
               jMode,
               pbo(),
               rop4));
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bStretch(dimo, iMode)
*
* Stretch just the mask.
*
* History:
*  23-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL BLTRECORD::bStretch(
SURFMEM& dimo,
ULONG    iMode)
{
// Use the ordered target extents for the size

    DEVBITMAPINFO   dbmi;

    dbmi.iFormat  = BMF_1BPP;
    dbmi.cxBitmap = aptlTrg[1].x - aptlTrg[0].x;
    dbmi.cyBitmap = aptlTrg[1].y - aptlTrg[0].y;
    dbmi.hpal     = (HPALETTE) 0;
    dbmi.fl       = pSurfMskOut()->bUMPD() ? UMPD_SURFACE : 0;

// Build a shadow rectangle.

    ERECTL  erclTrg(0, 0, dbmi.cxBitmap, dbmi.cyBitmap);

// Take care of mirroring.

    vMirror(&erclTrg);

    dimo.bCreateDIB(&dbmi, (VOID *) NULL);

    if (!dimo.bValid())
        return(FALSE);

// Call EngStretchBlt to stretch the mask.

    EPOINTL ptl(0,0);

    if (!EngStretchBlt(dimo.pSurfobj(),
                        pSurfMskOut()->pSurfobj(),
                        (SURFOBJ *) NULL,
                        (CLIPOBJ *) NULL,
                        NULL,
                        NULL,
                        (POINTL *)&ptl,
                        &erclTrg,
                        perclMask(),
                        (POINTL *) NULL,
                        iMode))
        {
            return(FALSE);
        }

// Adjust the mask origin.

    aptlMask[0].x = 0;
    aptlMask[0].y = 0;

// Release the previous pSurfMask, tell ~BLTRECORD its gone and put the
// new DIB in its place.

    flState &= ~BLTREC_MASK_LOCKED;
    pSurfMsk()->vAltUnlockFast();
    pSurfMsk((SURFACE  *) dimo.ps);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bStretch(dcoSrc, dimoShadow, dimoMask, ulAvec)
*
* Stretch the shadow and mask.
*
* History:
*  24-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL BLTRECORD::bStretch(
DCOBJ&     dcoSrc,
SURFMEM&   dimoShadow,
SURFMEM&   dimoMask,
ULONG      ulAvec,
ULONG      iMode)
{
// If there is a mask, stretch it.

    if ((ulAvec & AVEC_NEED_MASK) && !bStretch(dimoMask, iMode))
        return(FALSE);

// Use the ordered target extents for the size

    DEVBITMAPINFO   dbmi;

    dbmi.cxBitmap = aptlTrg[1].x - aptlTrg[0].x;
    dbmi.cyBitmap = aptlTrg[1].y - aptlTrg[0].y;
    dbmi.hpal     = 0;
    dbmi.iFormat  = pSurfSrc()->iFormat();
    dbmi.fl       = pSurfSrc()->bUMPD() ? UMPD_SURFACE : 0;

// Build a shadow rectangle.

    ERECTL  erclTrg(0, 0, dbmi.cxBitmap, dbmi.cyBitmap);

// Take care of mirroring.

    vMirror(&erclTrg);

    dimoShadow.bCreateDIB(&dbmi, (VOID *) NULL);

    if (!dimoShadow.bValid())
        return(FALSE);

// Now comes the tricky part.  The source may be a display.  While it may
// be somewhat faster to assume it isn't, code would be much more complex.

    {
    // Adjust the source rectangle.

        *perclSrc() += dcoSrc.eptlOrigin();

    // Exclude the pointer.

        ERECTL ercl(0,0,pSurfSrc()->sizl().cx,pSurfSrc()->sizl().cy);
        ercl *= *perclSrc();

        DEVEXCLUDEOBJ dxo(dcoSrc, &ercl);

        EPOINTL ptl(0,0);

    // Stretch the bits to the DIB.

        if (!EngStretchBlt(dimoShadow.pSurfobj(),
                           pSurfSrc()->pSurfobj(),
                           (SURFOBJ *) NULL,
                           (CLIPOBJ *) NULL,
                           NULL,
                           NULL,
                           (POINTL *)&ptl,
                           &erclTrg,
                           perclSrc(),
                           (POINTL *) NULL,
                           iMode))
        {
            return(FALSE);
        }

    // Update the source surface and origin.

        pSurfSrc((SURFACE  *) dimoShadow.ps);

        perclSrc()->left   = -dcoSrc.eptlOrigin().x;
        perclSrc()->top    = -dcoSrc.eptlOrigin().y;
        perclSrc()->right  = dbmi.cxBitmap - dcoSrc.eptlOrigin().x;
        perclSrc()->bottom = dbmi.cyBitmap - dcoSrc.eptlOrigin().y;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID BLTRECORD::vOrder(percl)
*
* Make the rectangle well ordered, remembering how we flipped.
*
* History:
*  23-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID BLTRECORD::vOrder(ERECTL *percl)
{
    LONG    l;

    if (percl->left > percl->right)
    {
        l = percl->left, percl->left = percl->right, percl->right = l;

        flState ^= BLTREC_MIRROR_X;
    }

    if (percl->top > percl->bottom)
    {
        l = percl->top, percl->top = percl->bottom, percl->bottom = l;

        flState ^= BLTREC_MIRROR_Y;
    }
}

/******************************Public*Routine******************************\
* VOID BLTRECORD::vOrderStupid(percl)
*
* Make the rectangle well ordered, remembering how we flipped.  Uses the
* Win3.1 compatible swap method.
*
* History:
*  23-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID BLTRECORD::vOrderStupid(ERECTL *percl)
{
    LONG    l;

    if (percl->left > percl->right)
    {
        l = percl->left, percl->left = percl->right, percl->right = l;

        percl->left++;
        percl->right++;

        flState ^= BLTREC_MIRROR_X;
    }

    if (percl->top > percl->bottom)
    {
        l = percl->top, percl->top = percl->bottom, percl->bottom = l;

        percl->top++;
        percl->bottom++;

        flState ^= BLTREC_MIRROR_Y;
    }
}

/******************************Public*Routine******************************\
* VOID BLTRECORD::vOrderAmnesia(percl)
*
* Make the rectangle well ordered.  Uses the Win 3.1 compatible swap
* method.
*
* History:
*  23-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID BLTRECORD::vOrderAmnesia(ERECTL *percl)
{
    LONG    l;

    if (percl->left > percl->right)
    {
        l = percl->left, percl->left = percl->right, percl->right = l;

        percl->left++;
        percl->right++;
    }

    if (percl->top > percl->bottom)
    {
        l = percl->top, percl->top = percl->bottom, percl->bottom = l;

        percl->top++;
        percl->bottom++;
    }
}

/******************************Public*Routine******************************\
* VOID BLTRECORD::vMirror(percl)
*
* Flip the rectangle according to the mirroring flags
*
* History:
*  24-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID BLTRECORD::vMirror(ERECTL *percl)
{
    LONG    l;

    if (flState & BLTREC_MIRROR_X)
        l = percl->left, percl->left = percl->right, percl->right = l;

    if (flState & BLTREC_MIRROR_Y)
        l = percl->top, percl->top = percl->bottom, percl->bottom = l;
}


/******************************Public*Routine******************************\
* VOID BLTRECORD::bBitBlt(dcoTrg, dcoSrc, ul, lH, lV)
*
* Do a near-miss ???BitBlt instead of ???StretchBlt.
*
* History:
*  12-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

#define PUT_RECTS  erclTrg = *perclTrg(); erclSrc = *perclSrc()
#define GET_RECTS  *perclSrc() = erclSrc; *perclTrg() = erclTrg

BOOL BLTRECORD::bBitBlt(
DCOBJ& dcoTrg,
DCOBJ& dcoSrc,
ULONG  ulAvec,
LONG   lHStr,
LONG   lVStr)
{
    ERECTL  erclTrg;
    ERECTL  erclSrc;
    BOOL    bHack;

    switch (lHStr)
    {
    case -1:
        perclSrc()->right--;

        if (lVStr == 1)
        {
            perclTrg()->bottom--;

            PUT_RECTS;
            bHack = bBitBlt(dcoTrg, dcoSrc, ulAvec);
            GET_RECTS;

            perclTrg()->top = perclTrg()->bottom;
            perclTrg()->bottom++;
            perclSrc()->top = perclSrc()->bottom - 1;

            return(bHack & bBitBlt(dcoTrg, dcoSrc, ulAvec));
        }
        else
        {
            perclSrc()->bottom += lVStr;

            return(bBitBlt(dcoTrg, dcoSrc, ulAvec));
        }
        break;

    case 0:
        if (lVStr == 1)
        {
            perclTrg()->bottom--;

            PUT_RECTS;
            bHack = bBitBlt(dcoTrg, dcoSrc, ulAvec);
            GET_RECTS;

            perclTrg()->top = perclTrg()->bottom;
            perclTrg()->bottom++;
            perclSrc()->top = perclSrc()->bottom - 1;

            return(bHack & bBitBlt(dcoTrg, dcoSrc, ulAvec));
        }
        else
        {
            perclSrc()->bottom += lVStr;

            return(bBitBlt(dcoTrg, dcoSrc, ulAvec));
        }
        break;

    case 1:
        perclTrg()->right--;

        if (lVStr == 1)
        {
            perclTrg()->bottom--;

            PUT_RECTS;
            bHack = bBitBlt(dcoTrg, dcoSrc, ulAvec);
            GET_RECTS;

            perclTrg()->left = perclTrg()->right;
            perclTrg()->right++;
            perclSrc()->left = perclSrc()->right - 1;

            bHack &= bBitBlt(dcoTrg, dcoSrc, ulAvec);
            GET_RECTS;

            perclTrg()->top = perclTrg()->bottom;
            perclTrg()->bottom++;
            perclSrc()->top = perclSrc()->bottom - 1;

            bHack &= bBitBlt(dcoTrg, dcoSrc, ulAvec);
            GET_RECTS;

            perclTrg()->top = perclTrg()->bottom;
            perclTrg()->bottom++;
            perclSrc()->top = perclSrc()->bottom - 1;
            perclTrg()->left = perclTrg()->right;
            perclTrg()->right++;
            perclSrc()->left = perclSrc()->right - 1;

            return(bHack & bBitBlt(dcoTrg, dcoSrc, ulAvec));
        }
        else
        {
            perclSrc()->bottom += lVStr;

            PUT_RECTS;
            bHack = bBitBlt(dcoTrg, dcoSrc, ulAvec);
            GET_RECTS;

            perclTrg()->left = perclTrg()->right;
            perclTrg()->right++;
            perclSrc()->left = perclSrc()->right - 1;

            return(bHack & bBitBlt(dcoTrg, dcoSrc, ulAvec));
        }
        break;

    default:
        break;
    }
    return FALSE;
}

#ifdef  DBG_STRBLT
LONG gflStrBlt = 0;

VOID vShowRect(
CHAR  *psz,
RECTL *prcl)
{
    if (gflStrBlt & STRBLT_RECTS)
        DbgPrint("%s [(%ld,%ld) (%ld,%ld)]\n",
                  psz, prcl->left, prcl->top, prcl->right, prcl->bottom);
}
#endif

/******************************Public*Routine******************************\
* EngStretchBlt
*
* This does stretched bltting.  The source rectangle is stretched to fit
* the target rectangle.
*
* NOTE! The source rectangle MUST BE WELL ORDERED IN DEVICE SPACE.
*
* This call returns TRUE for success, FALSE for ERROR.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote.
\**************************************************************************/

BOOL EngStretchBlt(
SURFOBJ         *psoTrg,
SURFOBJ         *psoSrc,
SURFOBJ         *psoMask,
CLIPOBJ         *pco,
XLATEOBJ        *pxlo,
COLORADJUSTMENT *pca,
POINTL          *pptlBrushOrg,
RECTL           *prclTrg,
RECTL           *prclSrc,
POINTL          *pptlMask,
ULONG            iMode)
{
    //
    // Prevent bad driver call backs
    //

    if ((iMode == 0) || (iMode > MAXSTRETCHBLTMODE))
    {
        WARNING1("EngStretchBlt: Unsupported iMode\n");
        return(FALSE);
    }

    PSURFACE pSurfTrg  = SURFOBJ_TO_SURFACE(psoTrg);
    PSURFACE pSurfSrc  = SURFOBJ_TO_SURFACE(psoSrc);
    PSURFACE pSurfMask = SURFOBJ_TO_SURFACE(psoMask);

    //
    // Can't StretchBlt to an RLE
    // Can't StretchBlt to/from a JPEG or PNG
    //

    if ((pSurfTrg->iFormat() == BMF_4RLE) ||
        (pSurfTrg->iFormat() == BMF_8RLE) ||
        (pSurfTrg->iFormat() == BMF_JPEG) ||
        (pSurfSrc->iFormat() == BMF_JPEG) ||
        (pSurfTrg->iFormat() == BMF_PNG ) ||
        (pSurfSrc->iFormat() == BMF_PNG ))
    {
        WARNING1("EngStretchBlt: Unsupported source/target\n");
        return(FALSE);
    }

    //
    // If the source or target rectangles are empty, don't bother.
    //

    if ((prclSrc->left == prclSrc->right) || (prclSrc->top == prclSrc->bottom) ||
        (prclTrg->left == prclTrg->right) || (prclTrg->top == prclTrg->bottom))
        return(TRUE);

    //
    // Get the LDEV for the target and source surfaces
    //

    PDEVOBJ   pdoTrg( pSurfTrg->hdev());
    PDEVOBJ   pdoSrc( pSurfSrc->hdev());

    //
    // We should have gone to the Mul layer if the destination
    // is a meta.
    //

    ASSERTGDI( !( psoTrg->iType != STYPE_BITMAP && pdoTrg.bValid()
        && pdoTrg.bMetaDriver()),
        "EngStretchBlt called with a destination meta device" );

    //
    // We cannot handle cases where the source is a meta,
    // so make a copy in this case.
    //

    SURFMEM  srcCopy;
    RECTL    rclCopy = *prclSrc;

    if( psoSrc->iType == STYPE_DEVICE && pdoSrc.bValid() &&
       pdoSrc.bMetaDriver())
    {
        if(!MulCopyDeviceToDIB( psoSrc, &srcCopy, &rclCopy ))
            return FALSE;

        if(srcCopy.ps == NULL )
        {
            // We didn't get to the point of creating the surface
            // becasue the rect was out of bounds.
            return TRUE;
        }

        prclSrc = &rclCopy;
        psoSrc   = srcCopy.pSurfobj();
        pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);
        pdoSrc.vInit(pSurfSrc->hdev());
    }

    //
    // CMYK based source bitmap support.
    //
    // limilation:
    //  - Source surface must be STYPE_BITMAP, since we can't read CMYK surface from device.
    //  - Target surface must be STYPE_DEVICE, since other Eng function can't handle.
    //  - Source surface must not be same as target surface.
    //  - No mask surface.
    //  - No halftone mode, since EngHTBlt can't handle.
    //

    BOOL bSrcCMYKColor = (pxlo && (pxlo->flXlate & XO_FROM_CMYK)) ? TRUE : FALSE;

    if (bSrcCMYKColor)
    {
        WARNING("EngStretchBlt called with XO_FROM_CMYK - limited support");

        // source surface must be STYPE_BITMAP.
        // target surface must be STYPE_DEVICE.
        // Must be no mask

        if ((psoSrc->iType != STYPE_BITMAP) ||
            (psoTrg->iType != STYPE_DEVICE) ||
            (psoMask != NULL))
        {
            return (FALSE);
        }
    }

    //
    // Send Halftoning to DanielC.
    //

    if (iMode == HALFTONE)
    {
        //
        // If source bitmap is CMYK, EngHTBlt can't handle.
        //

        if (bSrcCMYKColor)
        {
            return (FALSE);
        }

        int iRet = EngHTBlt(psoTrg,
                           psoSrc,
                           psoMask,
                           pco,
                           pxlo,
                           pca,
                           pptlBrushOrg,
                           prclTrg,
                           prclSrc,
                           pptlMask,
                           0,
                           NULL);

        switch (iRet)
        {
        case HTBLT_ERROR:
            return(FALSE);

        case HTBLT_SUCCESS:
            return(TRUE);

        case HTBLT_NOTSUPPORTED:
            iMode = COLORONCOLOR;
            break;
        };
    }

#ifdef  DBG_STRBLT
    if (!(gflStrBlt & STRBLT_ENABLE))
    {
        POINTFIX    aptfx[3];

        aptfx[0].x = FIX_FROM_LONG(prclTrg->left);
        aptfx[0].y = FIX_FROM_LONG(prclTrg->top);
        aptfx[1].x = FIX_FROM_LONG(prclTrg->right);
        aptfx[1].y = FIX_FROM_LONG(prclTrg->top);
        aptfx[2].x = FIX_FROM_LONG(prclTrg->left);
        aptfx[2].y = FIX_FROM_LONG(prclTrg->bottom);

        return(EngPlgBlt(psoTrg,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     pca,
                     pptlBrushOrg,
                     aptfx,
                     prclSrc,
                     pptlMask,
                     iMode));
    }

    if (gflStrBlt & STRBLT_FORMAT)
    {
        LONG foo[] = { 0, 1, 4, 8, 16, 24, 32 };

        DbgPrint("Target = %2ldBPP, Source = %2ldBPP\n",
                  foo[pSurfTrg->iFormat()],
                  foo[pSurfSrc->iFormat()]);

    }
#endif

    //
    // We may have to 'mirror'.
    //

    FLONG   flMirror = 0;

    if (prclTrg->bottom < prclTrg->top)
    {
        LONG lTemp = prclTrg->top;
        prclTrg->top = prclTrg->bottom;
        prclTrg->bottom = lTemp;

        flMirror |= STRBLT_MIRROR_Y;
    }

    if (prclTrg->right < prclTrg->left)
    {
        LONG lTemp = prclTrg->left;
        prclTrg->left = prclTrg->right;
        prclTrg->right = lTemp;

        flMirror |= STRBLT_MIRROR_X;
    }

    //
    // We may need to do a WHITEONBLACK or BLACKONWHITE from a monochrome source.
    // Find out and set the bogusity flag.
    //

    BOOL bBogus = ((iMode < COLORONCOLOR) &&
                   (pSurfMask == (SURFACE *) NULL));

    //
    // Bogusity mode only applies on shrinking blts.  Test the dx/dy for source
    // and targets and see if it still applies.
    //

    if (bBogus)
    {
        if (((prclTrg->right - prclTrg->left) >= (prclSrc->right - prclSrc->left)) &&
            ((prclTrg->bottom - prclTrg->top) >= (prclSrc->bottom - prclSrc->top)))
            bBogus = FALSE;
    }

    //
    // If we don't need bogusity, eliminate it.
    //

    if ((!bBogus) && (iMode < COLORONCOLOR))
        iMode = COLORONCOLOR;

    //
    // Many display drivers have fast-paths for stretches that handle only
    // source formats that are the same as the destination format, and only
    // with identity translates.  They also typically handle only STYPE_BITMAP
    // formats.
    //
    // So we will consider making a copy of the source bitmap up-front to
    // remove any translations and also to convert non-STYPE_BITMAP formats.
    //
    // Note that this isn't terribly efficient when clipping is involved,
    // but that will be a later optimization...
    //

    if (!pSurfTrg->bUMPD() &&
        (((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL)) ||
         (psoSrc->iType != STYPE_BITMAP)))
    {
        //
        // To go any further, the driver must of course hook StretchBlt.
        //
        // In addition, we'll add some further restrictions here to make
        // our life easier.  The driver's fast paths typically handle only
        // stretches that are non-inverting, don't involve a mask, and don't
        // have source clipping, and we'll do the same (otherwise we'd have
        // to add more code):
        //
        // Note that some drivers (specifically the Weitek driver) have a
        // bug where they set "psoDst = ppdev->psoPunt" and then call
        // EngStretchBlt on that.  This would work fine, except that they
        // had also called EngAssociateSurface on the surface and said they
        // hooked STRETCHBLT for that punt surface -- which is a lie because
        // they fall over if we call DrvStretchBlt on that punt surface!
        // (They don't really expect their DrvStretchBlt routine to be called
        // for an engine-managed surface, even though that's what they're
        // saying they support via the EngAssociateSurface call.)  So
        // we add a (pSurfTrg->iType() != STYPE_BITMAP) check and don't
        // execute this fast-path at all for engine-managed surfaces, and
        // thus we avoid driver bugs like the Weitek's.
        //

        //
        // WINBUG #95246 3-17-2000 jasonha GDI: StretchBlt optimizations: Let drivers handle more cases
        //
        // Actually, we must NEVER call the driver if there is source
        // clipping. Some drivers punt using a duplicate of the source
        // SURFOBJ, but without preserving its sizlBitmap member.
        //

        if ((pSurfTrg->iType() != STYPE_BITMAP)         &&
            (pSurfTrg->flags() & HOOK_STRETCHBLT)       &&
            (flMirror == 0)                             &&
            (psoMask == NULL)                           &&
            (prclSrc->left >= 0)                        &&
            (prclSrc->top >= 0)                         &&
            (prclSrc->right <= psoSrc->sizlBitmap.cx)   &&
            (prclSrc->bottom <= psoSrc->sizlBitmap.cy))
        {
            SIZEL      sizlNewSrc;
            HSURF       hsurfNewSrc;
            SURFOBJ    *psoNewSrc;
            RECTL       rclNew;
            BOOL        bRet;

            sizlNewSrc.cx = prclSrc->right - prclSrc->left;
            sizlNewSrc.cy = prclSrc->bottom - prclSrc->top;

            if ((sizlNewSrc.cx <= (prclTrg->right - prclTrg->left)) &&
                (sizlNewSrc.cy <= (prclTrg->bottom - prclTrg->top)))
            {
                hsurfNewSrc = (HSURF) EngCreateBitmap(sizlNewSrc,
                                                      0,
                                                      psoTrg->iBitmapFormat,
                                                      0,
                                                      NULL);

                psoNewSrc = EngLockSurface(hsurfNewSrc);

                if (psoNewSrc)
                {
                    //
                    // Bug #69739
                    //
                    // Set uniqueness to zero so that the driver does not bother
                    // trying to cache the temporary bitmap.
                    //
                    psoNewSrc->iUniq = 0;

                    rclNew.left   = 0;
                    rclNew.top    = 0;
                    rclNew.right  = sizlNewSrc.cx;
                    rclNew.bottom = sizlNewSrc.cy;

                    bRet = (PPFNGET(pdoSrc, CopyBits, pSurfSrc->flags())
                                                       (psoNewSrc,
                                                        psoSrc,
                                                        NULL,
                                                        pxlo,
                                                        &rclNew,
                                                        (POINTL*) prclSrc))
                        && (PPFNDRV(pdoTrg, StretchBlt)(psoTrg,
                                                        psoNewSrc,
                                                        psoMask,
                                                        pco,
                                                        NULL,
                                                        pca,
                                                        pptlBrushOrg,
                                                        prclTrg,
                                                        &rclNew,
                                                        pptlMask,
                                                        iMode));

                    EngUnlockSurface(psoNewSrc);
                    EngDeleteSurface(hsurfNewSrc);

                    return(bRet);
                }
            }
        }
    }

    //
    // Set up frame variables for possible switch to temporary output surface
    //

    SURFMEM     dimoOut;
    SURFACE    *pSurfOut;
    RECTL       rclOut;
    RECTL      *prclOut;
    ECLIPOBJ    ecoOut;
    CLIPOBJ    *pcoOut;
    ERECTL      erclDev;
    EPOINTL     eptlDev;
    ERECTL      erclTrim(0, 0, pSurfSrc->sizl().cx, pSurfSrc->sizl().cy);
    RECTL       rclTrim;
    RGNMEMOBJTMP rmoOut;

    //
    // If the target is not a DIB, or the target and source are on the same
    // surface and the extents overlap, create a target DIB of the needed
    // size and format.
    //

    if ((pSurfTrg->iType() == STYPE_BITMAP) &&
        (pSurfTrg->hsurf() !=  pSurfSrc->hsurf()))
    {
        pSurfOut   = pSurfTrg;
        prclOut  = prclTrg;
        pcoOut   = pco;
    }
    else
    {
        rclOut = *prclTrg;

        erclDev.left   = rclOut.left - 1;
        erclDev.top    = rclOut.top - 1;
        erclDev.right  = rclOut.right + 1;
        erclDev.bottom = rclOut.bottom + 1;

        //
        // Trim to the target surface.
        //

        ERECTL  erclTrg(0, 0, pSurfTrg->sizl().cx, pSurfTrg->sizl().cy);

#ifdef DBG_STRBLT
        vShowRect("Trg Rect", (RECTL *) &erclDev);
        vShowRect("Trg Surf", (RECTL *) &erclTrg);
#endif

        erclDev *= erclTrg;

        //
        // If we have nothing left, we're done.
        //

        if (erclDev.bEmpty())
            return(TRUE);

#ifdef DBG_STRBLT
        vShowRect("Trg Surf & Rect", (RECTL *) &erclDev);
#endif

        //
        // If we are only here on possible overlap, test for misses
        //

        if (( pSurfTrg->iType() == STYPE_BITMAP) &&
            ((erclDev.left > prclSrc->right) || (erclDev.right < prclSrc->left) ||
             (erclDev.top > prclSrc->bottom) || (erclDev.bottom < prclSrc->top)))
        {
            pSurfOut   = pSurfTrg;
            prclOut  = prclTrg;
            pcoOut   = pco;
        }
        else
        {
            //
            // Compute the adjusted rectangle in the temporary surface.
            //

            rclOut.left   -= erclDev.left;
            rclOut.top    -= erclDev.top;
            rclOut.right  -= erclDev.left;
            rclOut.bottom -= erclDev.top;

            DEVBITMAPINFO   dbmi;

            dbmi.cxBitmap = erclDev.right - erclDev.left + 1;
            dbmi.cyBitmap = erclDev.bottom - erclDev.top + 1;
            dbmi.hpal     = (HPALETTE) 0;
            if (bSrcCMYKColor)
            {
                //
                // On CMYK color mode, create temporary surface based on source surface.
                //
                dbmi.iFormat = pSurfSrc->iFormat();
            }
            else
            {
                dbmi.iFormat = pSurfTrg->iFormat();
            }
            dbmi.fl       = pSurfTrg->bUMPD() ? UMPD_SURFACE : 0;

#ifdef DBG_STRBLT
            if (gflStrBlt & STRBLT_ALLOC)
            {
                DbgPrint("Allocating temporary target\n");
                DbgPrint("Size (%lx, %lx)\n", dbmi.cxBitmap, dbmi.cyBitmap);
                DbgPrint("Format = %lx\n", dbmi.iFormat);
            }
#endif

            dimoOut.bCreateDIB(&dbmi, (VOID *) NULL);

            if (!dimoOut.bValid())
                return(FALSE);

            //
            // What point in the target surface is 0,0 in temporary surface.
            //

            eptlDev = *((EPOINTL *) &erclDev);

            //
            // Build a CLIPOBJ for the new surface.
            //

            if (!rmoOut.bValid())
                return(FALSE);

            erclDev.left    = 0;
            erclDev.top     = 0;
            erclDev.right  -= eptlDev.x;
            erclDev.bottom -= eptlDev.y;

#ifdef DBG_STRBLT
            vShowRect("Trg Clip", (RECTL *) &erclDev);
#endif
            rmoOut.vSet((RECTL *) &erclDev);

            ecoOut.vSetup(rmoOut.prgnGet(), erclDev, CLIP_FORCE);

            //
            // Synchronize with the device driver before touching the device surface.
            //

            {
                PDEVOBJ po( pSurfTrg->hdev());
                po.vSync(pSurfTrg->pSurfobj(),NULL,0);
            }

            //
            // If there is a mask, copy the actual target to the temporary.
            //

            if (pSurfMask != (SURFACE *) NULL)
            {
                (*PPFNGET(pdoTrg,CopyBits,  pSurfTrg->flags()))(
                          dimoOut.pSurfobj(),
                          pSurfTrg->pSurfobj(),
                          (CLIPOBJ *) NULL,
                          &xloIdent,
                          &erclDev,
                          &eptlDev);
            }

            //
            // Point to the new target.
            //

            pSurfOut = dimoOut.ps;
            prclOut  = &rclOut;
            pcoOut   = &ecoOut;
        }
    }

    //
    // Synchronize with the device driver before touching the device surface.
    //

    {
        PDEVOBJ po( pSurfSrc->hdev());
        po.vSync(psoSrc,NULL,0);
    }

    //
    // Compute what area of the source surface will actually be used.  We do
    // this so we never read off the end of the surface and fault or worse,
    // write bad pixels onto the target. Trim the source rectangle to the
    // source surface.
    //

#ifdef DBG_STRBLT
    vShowRect("Src Surf", (RECTL *) &erclTrim);
    vShowRect("Src Rect", prclSrc);
#endif

    erclTrim *= *prclSrc;

#ifdef DBG_STRBLT
    vShowRect("Src Surf & Src Rect", (RECTL *) &erclTrim);
#endif

    //
    // If we have nothing left, we're done.
    //

    if (erclTrim.bEmpty())
        return(TRUE);

    //
    // Now we must worry about the source surface.  Its possible we are blitting
    // from an RLE to the VGA for instance.  We convert the surface to the same
    // bitmap format as the target for convience.
    //

    SURFMEM     dimoIn;
    SURFACE    *pSurfIn;
    RECTL       rclIn;
    RECTL      *prclIn;
    XLATEOBJ   *pxloIn;

    if ((flMirror == 0) &&
        ( pSurfSrc->iType() == STYPE_BITMAP)    &&
        ( pSurfSrc->iFormat() != BMF_4RLE)      &&
        ( pSurfSrc->iFormat() != BMF_8RLE))
    {
        pSurfIn  = pSurfSrc;
        if (bSrcCMYKColor)
        {
            //
            // The surface will be kept as compatible as source, so no translation at this point.
            //
            pxloIn = NULL;
        }
        else
        {
            pxloIn = pxlo;
        }
        prclIn = prclSrc;
    }
    else
    {
        DEVBITMAPINFO   dbmi;

        dbmi.cxBitmap = erclTrim.right - erclTrim.left;
        dbmi.cyBitmap = erclTrim.bottom - erclTrim.top;
        dbmi.hpal     = (HPALETTE) 0;
        if (bSrcCMYKColor)
        {
            //
            // On CMYK color mode, create temporary surface based on source surface.
            //
            dbmi.iFormat = pSurfSrc->iFormat();
        }
        else
        {
            dbmi.iFormat = pSurfOut->iFormat();
        }
        dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;

#ifdef DBG_STRBLT
            if (gflStrBlt & STRBLT_ALLOC)
            {
                DbgPrint("Allocating temporary source\n");
                DbgPrint("Size (%lx, %lx)\n", dbmi.cxBitmap, dbmi.cyBitmap);
                DbgPrint("Format = %lx\n", dbmi.iFormat);
            }
#endif

        dimoIn.bCreateDIB(&dbmi, (VOID *) NULL);

        if (!dimoIn.bValid())
            return(FALSE);

        //
        // The cursor should already be excluded at this point, so just copy
        // to the DIB.
        //

        rclIn.left   = 0;
        rclIn.top    = 0;
        rclIn.right  = erclTrim.right - erclTrim.left;
        rclIn.bottom = erclTrim.bottom - erclTrim.top;

        (*PPFNGET(pdoSrc,CopyBits,  pSurfSrc->flags()))(
                  dimoIn.pSurfobj(),
                  pSurfSrc->pSurfobj(),
                  (CLIPOBJ *) NULL,
                  (bSrcCMYKColor ? NULL : pxlo),
                  &rclIn,
                  (POINTL *) &erclTrim);

        //
        // Point at the new source
        //

        rclIn.left   = prclSrc->left   - erclTrim.left;
        rclIn.top    = prclSrc->top    - erclTrim.top;
        rclIn.right  = prclSrc->right  - erclTrim.left;
        rclIn.bottom = prclSrc->bottom - erclTrim.top;

        pSurfIn  = dimoIn.ps;
        prclIn   = &rclIn;
        pxloIn   = NULL;

        //
        // Adjust the trimmed source origin and extent
        //

        erclTrim.right  -= erclTrim.left;
        erclTrim.bottom -= erclTrim.top;
        erclTrim.left = 0;
        erclTrim.top  = 0;

        //
        // If we needed to, do mirroring. Y mirroring is easy.
        //

        if (flMirror & STRBLT_MIRROR_Y)
        {
            if (dimoIn.ps->lDelta() > 0)
                dimoIn.ps->pvScan0(((BYTE *) dimoIn.ps->pvBits()) + dimoIn.ps->lDelta() * (erclTrim.bottom - 1));
            else
                dimoIn.ps->pvScan0(dimoIn.ps->pvBits());

            dimoIn.ps->lDelta(-dimoIn.ps->lDelta());
        }

        //
        // X mirroring is not.
        //

        if (flMirror & STRBLT_MIRROR_X)
            (*apfnMirror[dimoIn.ps->iFormat()])(dimoIn.ps);
    }

    //
    // Synchronize with the device driver before touching the device surface.
    //

    {
        PDEVOBJ po( pSurfOut->hdev());
        po.vSync(pSurfOut->pSurfobj(),NULL, 0);
    }

    //
    // Compute the space needed for the DDA to see if we can do it on the frame.
    // Clip it to the limit of our coordinate systems (2^27) to avoid math
    // overflow in the subsequent calculations.
    //

    if (((prclIn->right - prclIn->left) >= MAX_STRETCH_COOR) ||
        ((prclIn->bottom - prclIn->top) >= MAX_STRETCH_COOR))
    {
        return(FALSE);
    }

    if (((prclOut->right - prclOut->left) >= MAX_STRETCH_COOR) ||
        ((prclOut->bottom - prclOut->top) >= MAX_STRETCH_COOR) ||
        ((prclOut->right - prclOut->left) <= -MAX_STRETCH_COOR) ||
        ((prclOut->bottom - prclOut->top) <= -MAX_STRETCH_COOR))
    {
        return(FALSE);
    }

    //
    //  Special acceleration case:
    //
    //      SrcFormat and Destination format are the same
    //      Color translation is NULL
    //      Src width and height and less than 2 ^ 30
    //

    if  (
         (iMode == COLORONCOLOR) &&
         (psoMask == (SURFOBJ *) NULL) &&
         ((pxloIn == (XLATEOBJ *)NULL) || ((XLATE *)pxloIn)->bIsIdentity()) &&
         (pSurfOut->iFormat() == pSurfIn->iFormat()) &&
         (
            (pSurfIn->iFormat()  == BMF_8BPP)  ||
            (pSurfIn->iFormat()  == BMF_16BPP) ||
            (pSurfIn->iFormat()  == BMF_32BPP)
         )
        )
    {
        if((pcoOut == (CLIPOBJ *)NULL) ||
           (pcoOut->iDComplexity != DC_COMPLEX))
        {
            //
            // Case for no clip region (DC_TRIVIAL) or single rectangle 
            // clipping (DC_RECT).      
            //

            //
            // set clipping for DC_RECT case only, otherwise
            // use dst rectangle
            //
    
            PRECTL   prclClipOut = prclOut;
    
            //
            // StretchDIBDirect has early out cases which leave erclTrim 
            // uninitialized. This line of code is left commented out because
            // nobody has found a bug caused by this.
            //
            // erclTrim.left = erclTrim.right = erclTrim.top = erclTrim.bottom = 0;
            //

            if ((pcoOut != (CLIPOBJ *)NULL) && 
                (pcoOut->iDComplexity == DC_RECT)) 
            {
                prclClipOut = &(pcoOut->rclBounds);
            }
    
            //
            // call stretch blt accelerator
            //
    
            StretchDIBDirect(
               pSurfOut->pvScan0(),
               pSurfOut->lDelta(),
               pSurfOut->sizl().cx,
               pSurfOut->sizl().cy,
               prclOut,
               pSurfIn->pvScan0(),
               pSurfIn->lDelta(),
               pSurfIn->sizl().cx,
               pSurfIn->sizl().cy,
               prclIn,
               &erclTrim,
               prclClipOut,
               pSurfOut->iFormat()
            );
        } 
        else 
        {
            //
            // Handle the complex CLIPOBJ case (DC_COMPLEX)
            //
            
            //
            // Temp storage for individual trim sub-rectangles
            //

            ERECTL erclTrimTmp(0,0,0,0);

            //
            // Initialize erclTrim for accumulation using the += operator below
            // Setting everything to zero ensures the first RECTL is copied.
            // Theoretically we could just set left=right for this to work.
            //

            erclTrim.left = erclTrim.right = erclTrim.top = erclTrim.bottom = 0;

            BOOL bMore;
            ENUMRECTS arclComplexEnum;
            
            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
  
            //
            // Point this at the RECTL location and then the loop code below
            // will slide each successive RECTL under this pointer.
            //

            PRECTL prclClipOut=&arclComplexEnum.arcl[0];

            do {

                //
                // Enumerate each rectangle one-by-one in any order.
                //

                bMore = CLIPOBJ_bEnum(pco, sizeof(arclComplexEnum), (ULONG*) &arclComplexEnum);
  
                //
                // Call the stretch blt accelerator for this RECTL
                //

                if(arclComplexEnum.c > 0) 
                {
                    StretchDIBDirect(
                       pSurfOut->pvScan0(),
                       pSurfOut->lDelta(),
                       pSurfOut->sizl().cx,
                       pSurfOut->sizl().cy,
                       prclOut,
                       pSurfIn->pvScan0(),
                       pSurfIn->lDelta(),
                       pSurfIn->sizl().cx,
                       pSurfIn->sizl().cy,
                       prclIn,
                       &erclTrimTmp,
                       prclClipOut,
                       pSurfOut->iFormat()
                    );                 

                    //
                    // Accumulate the Trim rectangle
                    //
                    
                    erclTrim += erclTrimTmp;
                }
            } while (bMore);
        }
        
        //
        // save reduced target rectangle for use in CopyBits
        // to write a temp DIB to the target
        //

        rclTrim.left    = erclTrim.left;
        rclTrim.right   = erclTrim.right;
        rclTrim.top     = erclTrim.top;
        rclTrim.bottom  = erclTrim.bottom;
    }
    else
    {
        //
        // Initialize the DDA
        //

        STRDDA *pdda;

        LONG cjSpace = sizeof(STRDDA) +
                       (sizeof(LONG) * (prclIn->right - prclIn->left +
                                        prclIn->bottom - prclIn->top));

        pdda = (STRDDA *) PALLOCNOZ(cjSpace, 'htsG');
        if (pdda == (STRDDA *) NULL)
        {
            return(FALSE);
        }

    #ifdef DBG_STRBLT
        if (gflStrBlt & STRBLT_ALLOC)
        {
            DbgPrint("Need %ld bytes for DDA\n", cjSpace);
            DbgPrint("DDA @%08lx\n", (ULONG) pdda);
        }
    #endif

        vInitStrDDA(pdda, (RECTL *) &erclTrim, prclIn, prclOut);

        //
        // Save the reduced target rectangle.
        //

        rclTrim = pdda->rcl;

        //
        // See if we can accelerate anything.
        //

        if ((pxloIn != NULL) && (pxloIn->flXlate & XO_TRIVIAL))
        {
            pxloIn = NULL;
        }

        if ((pcoOut != (CLIPOBJ *) NULL) &&
            (pcoOut->iDComplexity == DC_TRIVIAL))
        {
            pcoOut = (CLIPOBJ *) NULL;
        }

        PFN_STRREAD   pfnRead;
        PFN_STRWRITE  pfnWrite = apfnWrite[pSurfOut->iFormat()];

        if (bBogus)
        {
            pdda->iColor = (iMode == BLACKONWHITE) ? ~0L : 0L;
        }

        pfnRead = apfnRead[pSurfIn->iFormat()][iMode - BLACKONWHITE];

        STRRUN *prun;

        //
        // Now compute the space needed for the stretch buffers
        //

        if ((prclIn->right - prclIn->left) > (prclOut->right - prclOut->left))
        {
            //
            // Shrink case -- even though shrinking the mask may cause
            // separate runs to merge together, the low-level stretch code
            // does not handle this.  Therefore, may have a run for every
            // single pixel.
            //

            cjSpace = sizeof(STRRUN) +
                      (sizeof(XRUNLEN) * (rclTrim.right - rclTrim.left)) +
                      sizeof(DWORD);
        }
        else
        {
            //
            // Stretch case -- worse case: every other pixel is masked, so
            // number of runs is 1/2 the number of pixels.
            //

            cjSpace = sizeof(STRRUN) + sizeof(XRUNLEN) *
                       ((rclTrim.right - rclTrim.left + 3) / 2) + sizeof(DWORD);
        }

        if ( ((rclTrim.right - rclTrim.left) > 100000000L) ||
             ((prun = (STRRUN *) AllocFreeTmpBuffer(cjSpace)) == NULL) )
        {
            VFREEMEM(pdda);
            return(FALSE);
        }

    #ifdef DBG_STRBLT
        if (gflStrBlt & STRBLT_ALLOC)
        {
            DbgPrint("Need %ld bytes for buffer\n", cjSpace);
            DbgPrint("Buffer @%08lx\n", (ULONG) prun);
        }
    #endif

        BYTE    *pjSrc = (BYTE *) pSurfIn->pvScan0() + pSurfIn->lDelta() * erclTrim.top;
        BYTE    *pjMask;
        POINTL   ptlMask;
        LONG     yRow;
        LONG     yCnt;

        if (psoMask == (SURFOBJ *) NULL)
        {
            pjMask = (BYTE *) NULL;
        }
        else
        {
            ptlMask.x = erclTrim.left - prclIn->left + pptlMask->x;
            ptlMask.y = erclTrim.top  - prclIn->top  + pptlMask->y;

            pjMask = (BYTE *) pSurfMask->pvScan0() + pSurfMask->lDelta() * ptlMask.y;
        }

        //
        // If we are in bogus mode, initialize the buffer
        //

        ULONG   iOver;

        if (bBogus)
        {
            iOver = (iMode == BLACKONWHITE) ? -1 : 0;

            vInitBuffer(prun, &rclTrim, iOver);
        }

        prun->yPos = pdda->rcl.top;

        SUSPENDWATCH sw(pdoTrg);

        for (yRow = erclTrim.top, yCnt = 0; yRow < erclTrim.bottom; yRow++, yCnt++)
        {
            prun->cRep = pdda->plYStep[yCnt];

            if (prun->cRep)
            {
                (*pfnWrite)(prun,
                            (*pfnRead)(pdda,
                                       prun,
                                       pjSrc,
                                       pjMask,
                                       pxloIn,
                                       erclTrim.left,
                                       erclTrim.right,
                                       ptlMask.x),
                            pSurfOut,
                            pcoOut);

                //
                // If we are in bogus mode, reinitialize the buffer
                //

                if (bBogus)
                    vInitBuffer(prun, &rclTrim, iOver);
            }
            else
            {
                //
                // If we are in BLACKONWHITE or WHITEONBLACK mode, we need to read
                // the scan and mix it with the current buffer.
                //

                if (bBogus)
                {
                    (*pfnRead)(pdda,
                               prun,
                               pjSrc,
                               (BYTE *) NULL,
                               pxloIn,
                               erclTrim.left,
                               erclTrim.right,
                               0);
                }
            }

            pjSrc += pSurfIn->lDelta();
            prun->yPos += prun->cRep;

            if (pjMask != (BYTE *) NULL)
            {
                pjMask += pSurfMask->lDelta();
            }
        }

        sw.Resume();

        //
        // Free up the work buffers.
        //

        FreeTmpBuffer(prun);
        VFREEMEM(pdda);
    }

    //
    // See if we have drawn on the actual output surface.
    //

    if (pSurfOut == pSurfTrg)
#ifndef DBG_STRBLT
        return(TRUE);
#else
    {
        if (gflStrBlt & STRBLT_FORMAT)
            DbgBreakPoint();

        return(TRUE);
    }
#endif

    //
    // We need to build a clipping region equal to the trimmed target.
    //

    rclTrim.left   += eptlDev.x;
    rclTrim.top    += eptlDev.y;
    rclTrim.right  += eptlDev.x;
    rclTrim.bottom += eptlDev.y;

    RGNMEMOBJTMP rmo;

    if (!rmo.bValid())
        return(FALSE);

    if (pco == (CLIPOBJ *) NULL)
        rmo.vSet(&rclTrim);
    else
    {
        RGNMEMOBJTMP   rmoTmp;

        if (!rmoTmp.bValid())
            return(FALSE);

        rmoTmp.vSet(&rclTrim);

        if (!rmo.bMerge(rmoTmp, *((ECLIPOBJ *)pco), gafjRgnOp[RGN_AND]))
            return(FALSE);
    }

    ERECTL  ercl;

    rmo.vGet_rcl(&ercl);

    if (pco != NULL)
    {
        //
        // Make sure that the bounds are tight to the destination rectangle.
        //

        if (!bIntersect(&ercl, &pco->rclBounds, &ercl))
        {
            return(TRUE);
        }
    }

    ECLIPOBJ eco(rmo.prgnGet(), ercl, CLIP_FORCE);

    if (eco.erclExclude().bEmpty())
        return(TRUE);

    //
    // Copy from the temporary to the target surface.
    //

    erclDev.left   += eptlDev.x;
    erclDev.top    += eptlDev.y;
    erclDev.right  += eptlDev.x;
    erclDev.bottom += eptlDev.y;
    eptlDev.x       = 0;
    eptlDev.y       = 0;

#ifdef DBG_STRBLT
        vShowRect("Trg Out", (RECTL *) &erclDev);
#endif

    //
    // With CMYK color, temp surface is based on source, while non-CMYK
    // case it's target. So we need xlateobj for CMYK color case, but
    // don't need for non-CMYK case.
    //

    (*PPFNGET(pdoTrg,CopyBits,  pSurfTrg->flags())) (pSurfTrg->pSurfobj(),
                                                     dimoOut.pSurfobj(),
                                                     &eco,
                                                     (bSrcCMYKColor ? pxlo : NULL),
                                                     &erclDev,
                                                     &eptlDev);

#ifdef DBG_STRBLT
    if (gflStrBlt & STRBLT_FORMAT)
        DbgBreakPoint();
#endif

    return(TRUE);
}

/******************************Public*Routine******************************\
* EngStretchBltROP
*
* This does stretched bltting with a rop.
*
* This call returns TRUE for success, FALSE for ERROR.
*
* History:
*  24-Sept-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

BOOL EngStretchBltROP(
SURFOBJ         *psoTrg,
SURFOBJ         *psoSrc,
SURFOBJ         *psoMask,
CLIPOBJ         *pco,
XLATEOBJ        *pxlo,
COLORADJUSTMENT *pca,
POINTL          *pptlBrushOrg,
RECTL           *prclTrg,
RECTL           *prclSrc,
POINTL          *pptlMask,
ULONG            iMode,
BRUSHOBJ        *pbo,
ROP4            rop4)
{
    GDIFunctionID(EngStretchBltROP);

    ASSERTGDI(psoTrg != (SURFOBJ *) NULL, "psoTrg == NULL\n");
    ASSERTGDI(prclTrg != (PRECTL) NULL, "dst rectangle is NULL\n");

    PSURFACE pSurfTrg  = SURFOBJ_TO_SURFACE(psoTrg);
    PSURFACE pSurfSrc  = SURFOBJ_TO_SURFACE(psoSrc);

    ASSERTGDI(rop4, "rop4 == NULL\n");
    ASSERTGDI(pSurfTrg->iFormat() != BMF_JPEG,
              "dst BMF_JPEG not supported\n");
    ASSERTGDI(pSurfTrg->iFormat() != BMF_PNG,
              "dst BMF_PNG not supported\n");
    ASSERTGDI(!(ROP4NEEDSRC(rop4) && (psoSrc == (SURFOBJ *) NULL)),
              "psoSrc == NULL\n");
    ASSERTGDI(!(ROP4NEEDSRC(rop4) && (prclSrc == (PRECTL) NULL)),
              "src rectangle is NULL\n");
    ASSERTGDI(!(ROP4NEEDSRC(rop4) && (pSurfSrc->iFormat() == BMF_JPEG)),
              "src BMF_JPEG not supported\n");
    ASSERTGDI(!(ROP4NEEDSRC(rop4) && (pSurfSrc->iFormat() == BMF_PNG)),
              "src BMF_PNG not supported\n");
    ASSERTGDI(!(ROP4NEEDPAT(rop4) && (pbo == (BRUSHOBJ *) NULL)),
              "Pattern is NULL\n");
    ASSERTGDI(!(ROP4NEEDPAT(rop4) &&
                (pbo->iSolidColor == 0xFFFFFFFF) &&
                (pptlBrushOrg == (PPOINTL) NULL)),
              "Pattern offset is NULL\n");

    if ((rop4 != 0x0000CCCC) && (rop4 != 0x0000AACC))
    {
        //
        // Dont halftone if we got a weird ROP.
        //

        if (iMode == HALFTONE)
            iMode = COLORONCOLOR;

        LONG    l;
        BOOL    bFlipX = FALSE;
        BOOL    bFlipY = FALSE;

        //
        // order the target extents
        //

        if (prclTrg->left > prclTrg->right)
        {
           l = prclTrg->left, prclTrg->left = prclTrg->right, prclTrg->right = l;

           bFlipX = TRUE;
        }

        if (prclTrg->top > prclTrg->bottom)
        {
           l = prclTrg->top, prclTrg->top = prclTrg->bottom, prclTrg->bottom = l;

           bFlipY = TRUE;
        }

        DEVBITMAPINFO   dbmi;
        SURFMEM   dimoShadow;
        SURFMEM   dimoMask;

        ULONG ulAvec  = ((ULONG) gajRop3[rop4 & 0x00ff]) |
                        ((ULONG) gajRop3[(rop4 >> 8) & 0x00ff]);

        // The check above does not tell if we need a mask.
        // Check explicitly.

        if (ROP4NEEDMASK(rop4))
        {
            ulAvec |= AVEC_NEED_MASK;
        }

        EPOINTL ptl(0,0);

        //
        // Stretch the Mask
        //

        if (ulAvec & AVEC_NEED_MASK)
        {

            ASSERTGDI (psoMask, "psoMask == NULL\n");

            PSURFACE pSurfMask  = SURFOBJ_TO_SURFACE(psoMask);

            //
            // use ordered target extents for the size
            //

            dbmi.iFormat  = BMF_1BPP;
            dbmi.cxBitmap = prclTrg->right - prclTrg->left;
            dbmi.cyBitmap = prclTrg->bottom - prclTrg->top;
            dbmi.hpal     = (HPALETTE) 0;
            dbmi.fl       = pSurfMask->bUMPD() ? UMPD_SURFACE : 0;

            ERECTL  erclTrg(0, 0, dbmi.cxBitmap, dbmi.cyBitmap);

            if (bFlipX)
                l = erclTrg.left, erclTrg.left = erclTrg.right, erclTrg.right = l;

            if (bFlipY)
                l = erclTrg.top, erclTrg.top = erclTrg.bottom, erclTrg.bottom = l;

            dimoMask.bCreateDIB(&dbmi, (VOID *) NULL);

            if (!dimoMask.bValid())
                return(FALSE);

            ULONG cx = prclSrc->right - prclSrc->left;
            ULONG cy = prclSrc->bottom - prclSrc->top;

            ERECTL  erclMask(pptlMask->x, pptlMask->y, pptlMask->x+cx, pptlMask->y+cy);

            //
            // Call EngStretchBlt to stretch the mask.
            //

            if (!EngStretchBlt(dimoMask.pSurfobj(),
                        psoMask,
                        (SURFOBJ *) NULL,
                        (CLIPOBJ *) NULL,
                        NULL,
                        NULL,
                        (POINTL *)&ptl,
                        &erclTrg,
                        &erclMask,
                        (POINTL *) NULL,
                        iMode))
            {
                return(FALSE);
            }

        }

        //
        // Stretch the Src
        //

        if (ulAvec & AVEC_NEED_SOURCE)
        {
            //
            // use ordered target extents for the size
            //

            dbmi.iFormat  = pSurfSrc->iFormat();
            dbmi.cxBitmap = prclTrg->right - prclTrg->left;
            dbmi.cyBitmap = prclTrg->bottom - prclTrg->top;
            dbmi.hpal     = (HPALETTE) 0;
            dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;

            // Build a shadow rectangle.
            ERECTL  erclTrg(0, 0, dbmi.cxBitmap, dbmi.cyBitmap);

            if (bFlipX)
                l = erclTrg.left, erclTrg.left = erclTrg.right, erclTrg.right = l;

            if (bFlipY)
                l = erclTrg.top, erclTrg.top = erclTrg.bottom, erclTrg.bottom = l;

            dimoShadow.bCreateDIB(&dbmi, (VOID *) NULL);

            if (!dimoShadow.bValid())
            {
                WARNING("dimoShadow invalid\n");
                return(FALSE);
            }

            //
            // Call EngStretchBlt to stretch the source.
            //

            if (!EngStretchBlt(dimoShadow.pSurfobj(),
                                psoSrc,
                                (SURFOBJ *) NULL,
                                (CLIPOBJ *) NULL,
                                NULL,
                                NULL,
                                (POINTL *)&ptl,
                                &erclTrg,
                                prclSrc,
                                (POINTL *) NULL,
                                iMode))
             {
                 return(FALSE);
             }

        }

        //
        // Call BitBlt
        //

        return((*(pSurfTrg->pfnBitBlt()))
                  ( psoTrg,
                    dimoShadow.pSurfobj(),
                    dimoMask.pSurfobj(),
                    pco,
                    pxlo,
                    prclTrg,
                    (POINTL *)&ptl,
                    (POINTL *)&ptl,
                    pbo,
                    pptlBrushOrg,
                    rop4));
     }
     else
     {
        //
        // Just pass it off to EngStretchBlt since it doesn't have a complex ROP
        //

        PDEVOBJ pdoTrg(pSurfTrg->hdev());
        PDEVOBJ pdoSrc(pSurfSrc->hdev());

        // Inc the target surface uniqueness

        INC_SURF_UNIQ(pSurfTrg);

        PFN_DrvStretchBlt pfn = PPFNGET(pdoTrg, StretchBlt, pSurfTrg->flags());

        //
        // There are a bunch of conditions that we don't want to
        // call the driver, so we make pfn point to the Eng
        // function. But if the destination is a meta, we want it
        // to actually call the Mul layer.
        //
        // WINBUG #357937 4-3-2001 jasonha Meta DEVBITMAPs must go thru Mul layer
        //  Don't check iType:
        //    DEVICE/DEVBITMAP -> MulStretchBlt
        //    BITMAP (not hooked) -> EngStretchBlt

        if ((pSurfTrg->flags() & HOOK_StretchBlt) && !pdoTrg.bMetaDriver())
        {
            // Don't call the driver if it doesn't do halftone.

            if (iMode == HALFTONE)
            {
                if (!(pdoTrg.flGraphicsCapsNotDynamic() & GCAPS_HALFTONE))
                    pfn = (PFN_DrvStretchBlt)EngStretchBlt;
            }

            // WINBUG #95246 3-17-2000 jasonha GDI: StretchBlt optimizations: Let drivers handle more cases
            // Don't call the driver if the source rectangle exceeds the source
            // surface. Some drivers punt using a duplicate of the source
            // SURFOBJ, but without preserving its sizlBitmap member.

            BOOL bSrcExceeds = FALSE;

            if(pSurfSrc->iType() == STYPE_DEVICE && pdoSrc.bValid() && pdoSrc.bMetaDriver())
            {
                if((prclSrc->left < pdoSrc.pptlOrigin()->x ) ||
                   (prclSrc->top  < pdoSrc.pptlOrigin()->y ) ||
                   (prclSrc->right > pdoSrc.pptlOrigin()->x + pSurfSrc->sizl().cx) ||
                   (prclSrc->bottom > pdoSrc.pptlOrigin()->y + pSurfSrc->sizl().cy))
                {
                    bSrcExceeds = TRUE;
                }

            }
            else
            {
                if((prclSrc->left < 0) ||
                   (prclSrc->top  < 0) ||
                   (prclSrc->right  > pSurfSrc->sizl().cx) ||
                   (prclSrc->bottom > pSurfSrc->sizl().cy))
                {
                    bSrcExceeds = TRUE;
                }
            }

            if( bSrcExceeds )
            {
                pfn = (PFN_DrvStretchBlt)EngStretchBlt;
            }

            // WINBUG #95246 3-17-2000 jasonha GDI: StretchBlt optimizations: Let drivers handle more cases
            // Don't call the driver if the source overlaps the destination.
            // Some drivers don't handle this case.

            ASSERTGDI((prclSrc->left <= prclSrc->right) &&
                      (prclSrc->top  <= prclSrc->bottom),
                      "Source rectangle not well-ordered\n");

            // Use a well-ordered copy of the destination rectangle to do the
            // intersection test.

            ERECTL rclTrg(*prclTrg);
            rclTrg.vOrder();

            if ((psoSrc == psoTrg)            &&
                bIntersect(prclSrc, &rclTrg))
            {
                pfn = (PFN_DrvStretchBlt)EngStretchBlt;
            }

        }

        return ((*pfn)(psoTrg,
                       psoSrc,
                       (rop4 == 0x0000CCCC) ? (SURFOBJ *) NULL : psoMask,
                       pco,
                       pxlo,
                       pca,
                       pptlBrushOrg,
                       prclTrg,
                       prclSrc,
                       pptlMask,
                       iMode));
     }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\surfddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: surfddi.cxx
*
* Surface DDI callback routines
*
* Created: 23-Aug-1990
* Author: Greg Veres [w-gregv]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* EngMarkBandingSurface
*
* DDI entry point to mark a surface as a banding surface meaning we should
* capture all output to it in a metafile.
*
* History:
*  10-Mar-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL EngMarkBandingSurface(HSURF hsurf)
{
    SURFREF so;

    so.vAltCheckLockIgnoreStockBit(hsurf);

    ASSERTGDI(so.bValid(), "ERROR EngMarkBandingSurfae invalid HSURF passed in\n");

    so.ps->vSetBanding();

    return(TRUE);
}

/******************************Public*Routine******************************\
* hbmCreateDriverSurface
*
* Common entry point for creating DDI surfaces.
*
* History:
*  11-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HBITMAP hbmCreateDriverSurface(ULONG iType, DHSURF dhsurf, SIZEL sizl, LONG lWidth,
                               ULONG iFormat, FLONG fl, PVOID pvBits)
{
    DEVBITMAPINFO dbmi;
    ULONG cjWidth = (ULONG) lWidth;

    dbmi.iFormat = iFormat & ~UMPD_FLAG;
    dbmi.cxBitmap = sizl.cx;
    dbmi.cyBitmap = sizl.cy;
    dbmi.hpal = (HPALETTE) 0;
    dbmi.fl = fl;

    //
    // convert from bytes to pels if given a buffer and cjWidth.  If either
    // of these are set to 0 use what DIBMEMOBJ computes.
    //

    if ((pvBits) && (cjWidth))
    {
        switch (dbmi.iFormat)
        {
        case BMF_1BPP:
            dbmi.cxBitmap = cjWidth * 8;
            break;

        case BMF_4BPP:
            dbmi.cxBitmap = cjWidth * 2;
            break;

        case BMF_8BPP:
            dbmi.cxBitmap = cjWidth;
            break;

        case BMF_16BPP:
            dbmi.cxBitmap = cjWidth / 2;
            break;

        case BMF_24BPP:
            dbmi.cxBitmap = cjWidth / 3;
            break;

        case BMF_32BPP:
            dbmi.cxBitmap = cjWidth / 4;
            break;
        }
    }

    SURFMEM SurfDimo;

    SurfDimo.bCreateDIB(&dbmi, pvBits);

    if (!SurfDimo.bValid())
    {
        //
        // Constructor logs error code.
        //

        return((HBITMAP) 0);
    }

    //
    // We have to mark the surface with a special flag indicating it was
    // created via EngCreateDeviceBitmap, instead of just looking for
    // STYPE_DEVBITMAP, because EngModifySurface can change the type to
    // STYPE_BITMAP yet we still want to cleanup the surface by calling
    // DrvDeleteDeviceBitmap.
    //

    if (iType == STYPE_DEVBITMAP)
    {
        SurfDimo.ps->vSetEngCreateDeviceBitmap();
    }

    if (iType != STYPE_BITMAP)
    {
        SurfDimo.ps->lDelta(0);
        SurfDimo.ps->pvScan0(NULL);
        SurfDimo.ps->pvBits(NULL);
    }

    SurfDimo.ps->vSetDriverCreated();
    SurfDimo.ps->sizl(sizl);
    SurfDimo.ps->dhsurf(dhsurf);
    SurfDimo.ps->iType(iType);
    SurfDimo.vKeepIt();

    //
    // charge the surface from umpd driver against the process
    // so we can clean it up afterwards
    //

    if (!(iFormat & UMPD_FLAG))
        SurfDimo.vSetPID(OBJECT_OWNER_PUBLIC);
    else
        SurfDimo.ps->vSetUMPD();

    return((HBITMAP) SurfDimo.ps->hsurf());
}

/******************************Public*Routine******************************\
* EngCreateBitmap
*
* DDI entry point to create a engine bitmap surface.
*
* History:
*  11-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HBITMAP EngCreateBitmap(SIZEL sizl, LONG lWidth, ULONG iFormat, FLONG fl, PVOID pvBits)
{
    return(hbmCreateDriverSurface(STYPE_BITMAP, NULL, sizl, lWidth, iFormat,
                                  fl, pvBits));
}

/******************************Public*Routine******************************\
* EngCreateDeviceBitmap
*
* DDI entry point to create device managed bitmap.
*
* History:
*  10-Mar-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HBITMAP EngCreateDeviceBitmap(DHSURF dhsurf, SIZEL sizl, ULONG iFormat)
{
    return(hbmCreateDriverSurface(STYPE_DEVBITMAP, dhsurf, sizl, 0, iFormat,
                                  0, (PVOID)UIntToPtr( 0xdeadbeef )));
}

/******************************Public*Routine******************************\
* EngCreateDeviceSurface
*
* DDI entry point to create device managed bitmap.
*
* History:
*  10-Mar-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HSURF EngCreateDeviceSurface(DHSURF dhsurf, SIZEL sizl, ULONG iFormat)
{
    //
    // [NT 4.0 compatible]
    //
    //  EngCreateDeviceSurface in NT4, does not fail with invalid iFormat
    // (especially 0, Adobe Acrobat 3.01 - PDFKD.DLL calls with 0 at least).
    // So we replace the wrong data with something valid, here.
    //
    switch (iFormat & ~UMPD_FLAG)
    {
        case BMF_1BPP:
        case BMF_4BPP:
        case BMF_8BPP:
        case BMF_16BPP:
        case BMF_24BPP:
        case BMF_32BPP:
            break;

        default:
            //
            // UMPD_FLAG should be preserved.
            //
            iFormat = (iFormat & UMPD_FLAG) | BMF_1BPP;
    }

    return((HSURF) hbmCreateDriverSurface(STYPE_DEVICE, dhsurf, sizl, 0,
                                          iFormat, 0, (PVOID)UIntToPtr( 0xdeadbeef )));
}

/******************************Public*Routine******************************\
* EngDeleteSurface
*
* DDI entry point to delete a surface.
*
* History:
*  Thu 12-Mar-1992 -by- Patrick Haluptzok [patrickh]
* change to bool return.
*
*  11-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL EngDeleteSurface(HSURF hsurf)
{
    BOOL bReturn = TRUE;

    if (hsurf != 0)
    {
        bReturn = bDeleteSurface(hsurf);
    }

    ASSERTGDI(bReturn, "ERROR EngDeleteSurface failed");

    return(bReturn);
}

/******************************Public*Routine******************************\
* EngLockSurface
*
* DDI entry point to lock down a surface handle.
*
* History:
*  Thu 27-Aug-1992 -by- Patrick Haluptzok [patrickh]
* Remove SURFOBJ accelerator allocation.
*
*  11-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

SURFOBJ *EngLockSurface(HSURF hsurf)
{
    SURFREF so;

    so.vAltCheckLockIgnoreStockBit(hsurf);

    if (so.bValid())
    {
        so.vKeepIt();
        return(so.pSurfobj());
    }
    else
    {
        WARNING("EngLockSurface failed to lock handle\n");
        return((SURFOBJ *) NULL);
    }
}

/******************************Public*Routine******************************\
* EngUnlockSurface
*
* DDI entry point to unlock a surface that has been locked
* with EngLockSurface.
*
* History:
*  Thu 27-Aug-1992 -by- Patrick Haluptzok [patrickh]
* Remove SURFOBJ accelerator allocation.
*
*  11-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID EngUnlockSurface(SURFOBJ *pso)
{
    if (pso != (SURFOBJ *) NULL)
    {

        SURFACE *ps = SURFOBJ_TO_SURFACE_NOT_NULL(pso);

        if (ps == HmgReferenceCheckLock((HOBJ)pso->hsurf,SURF_TYPE,FALSE))
        {
            SURFREF su(pso);

            su.vUnreference();
        }
    }
}


#if DBG
BOOL PanCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);

VOID vAssertValidHookFlags(PDEVOBJ *pdo, SURFREF *pso) 
{
    FLONG flHooks;
    flHooks = pso->ps->flags();


    //
    // Check to make sure we haven't disabled h/w accelerations and are now
    // using the panning driver (unaccelerated driver).
    //

    if(PPFNDRV(*pdo, CopyBits)!=PanCopyBits) {
        //
        // Assert that the driver provides a routine entry point to match each
        // Hooked flag. 
        //
        // PPFNGET returns the driver routine if the appropriate flag is set.
        // if the flag is set and the routine is NULL, we ASSERT.
        //
        // if the flag is not set, then PPFNGET returns the Eng routine, which
        // better not be NULL, so we ASSERT if it is.
        //
    
        ASSERTGDI( (PPFNGET(*pdo, BitBlt, flHooks)), 
                   "HOOK_BITBLT specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, StretchBlt, flHooks)), 
                   "HOOK_STRETCHBLT specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, PlgBlt, flHooks)), 
                   "HOOK_PLGBLT specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, TextOut, flHooks)), 
                   "HOOK_TEXTOUT specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, Paint, flHooks)), 
                   "HOOK_PAINT specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, StrokePath, flHooks)), 
                   "HOOK_STROKEPATH specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, FillPath, flHooks)), 
                   "HOOK_FILLPATH specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, StrokeAndFillPath, flHooks)), 
                   "HOOK_STROKEANDFILLPATH specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, LineTo, flHooks)), 
                   "HOOK_LINETO specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, CopyBits, flHooks)), 
                   "HOOK_COPYBITS specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, StretchBltROP, flHooks)), 
                   "HOOK_STRETCHBLTROP specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, TransparentBlt, flHooks)), 
                   "HOOK_TRANSPARENTBLT specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, AlphaBlend, flHooks)), 
                   "HOOK_ALPHABLEND specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, GradientFill, flHooks)), 
                   "HOOK_GRADIENTFILL specified, but entry is NULL");
    
        ASSERTGDI( ((flHooks & HOOK_SYNCHRONIZE) == 0 || 
                   pdo->ppfn(INDEX_DrvSynchronize) != NULL ||
                   pdo->ppfn(INDEX_DrvSynchronizeSurface != NULL)),
                   "HOOK_SYNCHRONIZE specified, but appropriate driver function"
                   " (DrvSynchronize or DrvSynchronizeSurface) not available");
    }

}
#endif


/******************************Public*Routine******************************\
* EngAssociateSurface                                                      *
*                                                                          *
* DDI entry point for assigning a surface a palette, associating it with   *
* a device.                                                                *
*                                                                          *
* History:                                                                 *
*  Mon 27-Apr-1992 16:36:38 -by- Charles Whitmer [chuckwh]                 *
* Changed HPDEV to HDEV.                                                   *
*                                                                          *
*  Thu 12-Mar-1992 -by- Patrick Haluptzok [patrickh]                       *
* change to bool return                                                    *
*                                                                          *
*  Mon 01-Apr-1991 -by- Patrick Haluptzok [patrickh]                       *
* add pdev, dhpdev init, palette stuff                                     *
*                                                                          *
*  13-Feb-1991 -by- Patrick Haluptzok patrickh                             *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EngAssociateSurface(HSURF hsurf, HDEV hdev, FLONG flHooks)
{
    //
    // Remove any obsolete HOOK_ flags, so that we can overload them for
    // internal GDI purposes.
    //

    flHooks &= ~(HOOK_SYNCHRONIZEACCESS | HOOK_MOVEPANNING);

    ASSERTGDI((flHooks & (~HOOK_FLAGS)) == 0, "ERROR driver set high flags");

    //
    // This call needs to associate this surface with the the HDEV given.
    // We can't stick the palette in here because for palette managed devices
    // the compatible bitmaps have a NULL palette.  If we ever try and init
    // the palettes here we need to be careful not to do it for compatible
    // bitmaps on palette managed devices.
    //

    PDEVOBJ po(hdev);
    if (!po.bValid())
    {
        WARNING("EngAssociateSurface: invalid PDEV passed in\n");
        return FALSE;
    }

    SURFREF so;

    so.vAltCheckLockIgnoreStockBit(hsurf);

    if (!so.bValid())
    {
        WARNING("EngAssociateSurface: invalid SURF passed in\n");
        return FALSE;
    }

    //
    // EA Recovery support: If we are hooking the driver entry points for
    // EA recovery, we need to store away the surface and associated
    // LDEV so that when the DrvDeleteDeviceBitmap comes down, we can hook
    // up the "real" driver entry point.
    //
    // NOTE: We only create this node if EA recovery is currently enabled, and
    // DrvCreateDeviceBitmap (which will do the cleanup of the node) is present.
    //

    if (WatchdogIsFunctionHooked(po.pldev(), INDEX_DrvCreateDeviceBitmap)) {

        if (so.ps->bEngCreateDeviceBitmap()) {

            if (dhsurfAssociationIsNodeInList(so.ps->dhsurf(), hsurf) == FALSE) {

                PDHSURF_ASSOCIATION_NODE Node = dhsurfAssociationCreateNode();

                if (Node) {

                    Node->dhsurf = so.ps->dhsurf();
                    Node->hsurf = hsurf;
                    Node->pldev = po.pldev();

                    dhsurfAssociationInsertNode(Node);

                } else {

                    WARNING("EngAssociateSurface: failed to create association node\n");
                    return(FALSE);
                }
            }
        }
    }

    so.ps->pwo((EWNDOBJ *)NULL);
    so.ps->hdev(hdev);
    so.ps->dhpdev(po.dhpdevNotDynamic());   // Since we're being called from
                                            // the driver, we are implicitly
                                            // holding a dynamic mode change
                                            // lock, and so don't need to
                                            // check it -- hence 'NotDynamic'
    
    so.ps->flags(so.ps->flags() | flHooks);
    
    #if DBG
    vAssertValidHookFlags(&po, &so);
    #endif

    return(TRUE);
}

/******************************Public*Routine******************************\
* EngModifySurface
*
* DDI entry point for changing surface internals such as the type,
* bits pointers, and the hooked flags.

*  27-Apr-1998 -by- J. Andrew Goossen patrickh
* Wrote it.
\**************************************************************************/

BOOL EngModifySurface(
HSURF   hsurf,
HDEV    hdev,
FLONG   flHooks,
FLONG   flSurface,
DHSURF  dhsurf,
VOID*   pvScan0,
LONG    lDelta,
VOID*   pvReserved)
{
    BOOL    bRet = TRUE;            // Assume success;
    SURFREF so;
    PDHSURF_ASSOCIATION_NODE Node = NULL;

    PDEVOBJ po(hdev);
    if (!po.bValid())
    {
        WARNING("EngModifySurface: invalid PDEV passed in");
        return(FALSE);
    }

    so.vAltLockIgnoreStockBit(hsurf);

    if (!so.bValid())
    {
        WARNING("EngModifySurface: invalid surface handle passed in");
        return(FALSE);
    }

    if (pvReserved != NULL)
    {
        WARNING("EngModifySurface: pvReserved not NULL");
        bRet = FALSE;
    }

    if (flSurface & ~(MS_NOTSYSTEMMEMORY | MS_SHAREDACCESS))
    {
        WARNING("EngModifySurface: invalid flSurface flag");
        return(FALSE);
    }

    //
    // Only surfaces that were created via EngCreateDeviceBitmap or
    // EngCreateDeviceSurface are allowed to be modified.  We do this
    // primarily for two reasons:
    //
    //   1. This prevents the driver from modifying willy-nilly
    //      SURFOBJs that it sees;
    //   2. If solves some problems with bDeleteSurface calling
    //      DrvDeleteDeviceBitmap (it was impossible to allow
    //      an STYPE_BITMAP surface to have DrvDeleteDeviceBitmap
    //      called, and still handle the DrvEnableSurface case
    //      where a driver created its primary surface using
    //      EngCreateSurface and modified the 'dhsurf' field --
    //      in this case DrvDeleteDeviceBitmap should not be called!
    //
    // Note that as a side effect of how we check for STYPE_DEVICE,
    // primary surfaces should only ever be called with EngModifySurface
    // once.  Bitmap surfaces, however, can intentionally be modified by
    // EngModifySurface any number times.
    //

    if (!(so.ps->bEngCreateDeviceBitmap()) && (so.ps->iType() != STYPE_DEVICE))
    {
        WARNING("EngModifySurface: surface not driver created");
        bRet = FALSE;
    }

    if ((so.ps->hdev() != NULL) && (so.ps->hdev() != hdev))
    {
        WARNING("EngModifySurface: surface associated with different hdev");
        bRet = FALSE;
    }

    //
    // Remove any obsolete HOOK_ flags, so that we can overload them for
    // internal GDI purposes.
    //

    flHooks &= ~(HOOK_SYNCHRONIZEACCESS | HOOK_MOVEPANNING);

    ASSERTGDI((flHooks & (~HOOK_FLAGS)) == 0, "ERROR driver set high flags");


    //
    // WINBUG #254444 bhouse 12-14-2000 Allow drivers to change primary using EngModifySurface
    // TODO: Additional code review of this change
    // Allow drivers to change primary surface attributes so long as they
    // are not changing the hooking flags and the PDEV is disabled.
    //


    if (so.ps->bPDEVSurface() && ((po.pSpriteState()->flOriginalSurfFlags & HOOK_FLAGS) != flHooks || !po.bDisabled()))
    {
        WARNING("EngModifySurface: can't modify PDEV surface once created");
        bRet = FALSE;
    }

    //
    // EA Recovery support: If we are hooking the driver entry points for
    // EA recovery, we need to store away the surface and associated
    // LDEV so that when the DrvDeleteDeviceBitmap comes down, we can hook
    // up the "real" driver entry point.
    //
    //
    // NOTE: We only create this node if EA recovery is currently enabled, and
    // DrvCreateDeviceBitmap (which will do the cleanup of the node) is present.
    //

    if (WatchdogIsFunctionHooked(po.pldev(), INDEX_DrvCreateDeviceBitmap)) {

        if (so.ps->bEngCreateDeviceBitmap()) {

            if (dhsurfAssociationIsNodeInList(dhsurf, hsurf) == FALSE) {

                Node = dhsurfAssociationCreateNode();

                if (Node) {

                    Node->dhsurf = dhsurf;
                    Node->hsurf = hsurf;
                    Node->pldev = po.pldev();

                } else {

                    WARNING("EngAssociateSurface: failed to create association node\n");
                    bRet = FALSE;
                }
            }
        }
    }

    //
    // First, try changing the surface's type as appropriate:
    //

    if ((pvScan0 == NULL) || (lDelta == 0))
    {
        //
        // Make the surface opaque, assuming they've hooked the minimum
        // number of calls to allow an opaque surface.
        //

        if ((flHooks & (HOOK_TEXTOUT | HOOK_BITBLT | HOOK_STROKEPATH))
                    != (HOOK_TEXTOUT | HOOK_BITBLT | HOOK_STROKEPATH))
        {
            WARNING("EngModifySurface: opaque surfaces must hook textout, bitblt, strokepath");
            bRet = FALSE;
        }

        if (!(flSurface & MS_NOTSYSTEMMEMORY))
        {
            WARNING("EngModifySurface: why have opaque surface if system memory?");
            bRet = FALSE;
        }

        if (dhsurf == NULL)
        {
            WARNING("EngModifySurface: opaque types must have a dhsurf");
            bRet = FALSE;
        }

        //
        // If all systems are go, convert to an opaque surface:
        //

        if (bRet)
        {
            so.ps->pvScan0(NULL);
            so.ps->pvBits(NULL);
            so.ps->lDelta(0);

            //
            // We're making the surface opaque, and STYPE_DEVICE surfaces should
            // remain STYPE_DEVICE to denote the primary surface, and not become
            // STYPE_DEVBITMAP.
            //

            if (so.ps->iType() != STYPE_DEVICE)
            {
                so.ps->iType(STYPE_DEVBITMAP);
            }
        }
    }
    else
    {
        if ((flSurface & MS_NOTSYSTEMMEMORY) && !(flHooks & HOOK_SYNCHRONIZE))
        {
            WARNING("EngModifySurface: VRAM non-opaque surfaces must hook synchronize");
            bRet = FALSE;
        }

        //
        // If all systems are go, convert to a GDI-managed surface:
        //

        if (bRet)
        {
            so.ps->pvScan0(pvScan0);
            so.ps->lDelta(lDelta);
            so.ps->iType(STYPE_BITMAP);

            if (lDelta > 0)
            {
                so.ps->pvBits(pvScan0);
                so.ps->fjBitmap(so.ps->fjBitmap() | BMF_TOPDOWN);
            }
            else
            {
                so.ps->pvBits((VOID*) ((BYTE*) pvScan0
                            + (so.ps->sizl().cy - 1) * lDelta));
                so.ps->fjBitmap(so.ps->fjBitmap() & ~BMF_TOPDOWN);
            }
        }
    }

    //
    // If we were successful in changing the type, update some common fields:
    //

    if (bRet)
    {
        if (flSurface & MS_NOTSYSTEMMEMORY)
        {
            so.ps->fjBitmap(so.ps->fjBitmap() | BMF_NOTSYSMEM);
        }
        else
        {
            so.ps->fjBitmap(so.ps->fjBitmap() & ~BMF_NOTSYSMEM);
        }

        if (flSurface & MS_SHAREDACCESS)
        {
            so.ps->vSetShareAccess();
        }
        else
        {
            so.ps->vClearShareAccess();
        }

        so.ps->dhsurf(dhsurf);
        so.ps->pwo((EWNDOBJ *)NULL);
        so.ps->hdev(hdev);
        so.ps->dhpdev(po.dhpdev());
        
        so.ps->flags((so.ps->flags() & ~HOOK_FLAGS) | flHooks);
                                                // Replace the old hooked flags
                                                // with the new ones

        #if DBG
        vAssertValidHookFlags(&po, &so);
        #endif

        //
        // If we created a Node for EA recovery purposes, then insert the
        // node into our list now that we know this function will succeed.
        //

        if (Node) {
            dhsurfAssociationInsertNode(Node);
        }
    }
    else
    {
        //
        // We are failing.  Thus if we created an association node above,
        // we should clean that up.
        //

        if (Node) {
            AssociationDeleteNode(Node);
            Node = NULL;
        }

        WARNING("EngModifySurface: failed");
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\stockfnt.cxx ===
/******************************Module*Header*******************************\
* Module Name: stockfnt.cxx
*
* Initializes the stock font objects.
*
* Note:
*
*   This module requires the presence of the following section in the
*   WIN.INI file:
*
*       [GRE_Initialize]
*           fonts.fon=[System font filename]
*           oemfont.fon=[OEM (terminal) font filename]
*           fixedfon.fon=[System fixed-pitch font filename]
*
*   Also, an undocumented feature of WIN 3.0/3.1 is supported: the ability
*   to override the fonts.fon definition of the system font.  This is
*   done by defining SystemFont and SystemFontSize in the [windows]
*   section of WIN.INI.
*
*
* Rewritten 13-Nov-1994 Andre Vachon [andreva]
* Created: 06-May-1991 11:22:23
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// Function prototypes.

extern "C" BOOL bInitStockFonts(VOID);
extern "C" BOOL bInitStockFontsInternal(PWSZ pwszFontDir);
extern "C" BOOL bInitOneStockFont(PWSZ pwszValue, LFTYPE type, int iFont, HANDLE RegistryKey,
                                   PKEY_VALUE_PARTIAL_INFORMATION ValueKeyInfo,
                                   ULONG ValueLength, PWCHAR ValueName, PWCHAR ValueKeyName);
extern "C" BOOL bInitOneStockFontInternal(PWCHAR pwszFont, LFTYPE type, int iFont);
extern "C" BOOL bInitSystemFont(PWCHAR pfontFile, ULONG  fontSize);
extern "C" VOID vInitEmergencyStockFont(PWCHAR pfontFile);
#if(WINVER >= 0x0400)
extern "C" HFONT hfontInitDefaultGuiFont();
#endif

extern BOOL         G_fConsole;

#pragma alloc_text(INIT, bInitStockFonts)
#pragma alloc_text(INIT, bInitStockFontsInternal)
#pragma alloc_text(INIT, bInitOneStockFont)
#pragma alloc_text(INIT, bInitOneStockFontInternal)
#pragma alloc_text(INIT, bInitSystemFont)
#pragma alloc_text(INIT, vInitEmergencyStockFont)
#if(WINVER >= 0x0400)
#pragma alloc_text(INIT, hfontInitDefaultGuiFont)
#endif

// "Last resort" default HPFE for use by the mapper.

extern PFE *gppfeMapperDefault;

#if(WINVER >= 0x0400)
BOOL gbFinishDefGUIFontInit;
#endif

//
// This was the USER mode version of font initialization.
// This code relied on the ability of transforming a file name found in the
// registry to a full path name so the file could be loaded.
//
// In the kernel mode version, we will assume that all font files (except
// winsrv.dll) will be in the system directory
//
// If we, for some reason, need to get system font files loaded later on
// from another directory, the graphics engine should be "fixed" to allow
// for dynamic changing of the system font - especially when the USER logs
// on to a different desktop.
//

//
// Kernel mode version of font initialization.
//

/******************************Public*Routine******************************\
* BOOL bOpenKey(PWSZ pwszKey, HANDLE *pRegistryKey)
*
* History:
*  06-Aug-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bOpenKey(PWSZ pwszKey, HANDLE *pRegistryKey)
{
    UNICODE_STRING    UnicodeRoot;
    OBJECT_ATTRIBUTES ObjectAttributes;

    RtlInitUnicodeString(&UnicodeRoot, pwszKey);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeRoot,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    return NT_SUCCESS(ZwOpenKey(pRegistryKey,
                             (ACCESS_MASK) 0,
                             &ObjectAttributes));
}

/******************************Public*Routine******************************\
* BOOL bQueryValueKey
*
* History:
*  06-Aug-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bQueryValueKey
(
    PWSZ                           pwszValue,
    HANDLE                         RegistryKey,
    PKEY_VALUE_PARTIAL_INFORMATION ValueKeyInfo,
    ULONG                          ValueLength
)
{
    UNICODE_STRING UnicodeValue;
    ULONG          ValueReturnedLength;

    RtlInitUnicodeString(&UnicodeValue,pwszValue);

    return NT_SUCCESS(ZwQueryValueKey(RegistryKey,
                                   &UnicodeValue,
                                   KeyValuePartialInformation,
                                   ValueKeyInfo,
                                   ValueLength,
                                   &ValueReturnedLength));
}


/******************************Public*Routine******************************\
* BOOL bInitStockFonts ()
*
* Part of the GRE initialization.
*
* Creates LFONTs representing each of the different STOCK OBJECT fonts.
*
\**************************************************************************/

#define KEY_SOFTWARE_FONTS  L"\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles\\Current\\Software\\Fonts"
#define KEY_GRE_INITIALIZE  L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Gre_Initialize"
#define FONTDIR_FONTS  L"\\SystemRoot\\Fonts\\"

extern "C" BOOL bInitStockFontsInternal(PWSZ pwszFontDir)
{
    ENUMLOGFONTEXDVW  elfw;
    HANDLE   RegistryKey;
    BOOL     bOk;

    PULONG ValueBuffer;

    PKEY_VALUE_PARTIAL_INFORMATION ValueKeyInfo;
    PWCHAR                         ValueName;
    PWCHAR                         ValueKeyName;
    ULONG ValueLength = MAX_PATH * 2 - sizeof(LARGE_INTEGER);
    ULONG FontSize;
    ULONG cjFontDir = (wcslen(pwszFontDir) + 1) * sizeof(WCHAR);

    ValueBuffer = (PULONG)PALLOCMEM((MAX_PATH + cjFontDir) * 2,'gdii');

    if (!ValueBuffer)
        return FALSE;

    RtlMoveMemory(ValueBuffer,
                  pwszFontDir,
                  cjFontDir);

    ValueName = (PWCHAR) ValueBuffer;

    ValueKeyName = (PWCHAR)
        (((PUCHAR)ValueBuffer) + cjFontDir -
            sizeof(UNICODE_NULL));

// Offset the regsitry query buffer into the ValueBuffer, but make sure
// it is quad-word aligned.

    ValueKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION) (
        (((ULONG_PTR)ValueBuffer) + cjFontDir +
            sizeof(LARGE_INTEGER)) & (~(ULONG_PTR)(sizeof(LARGE_INTEGER) - 1)) );

// Lets try to use the USER defined system font

    if (bOpenKey(L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows",
                 &RegistryKey))
    {

        if (bQueryValueKey(L"SystemFontSize", RegistryKey,
                                       ValueKeyInfo,
                                       ValueLength))
        {
            FontSize = *((PULONG)(&ValueKeyInfo->Data[0]));

            if (bQueryValueKey(L"SystemFont", RegistryKey,
                                           ValueKeyInfo,
                                           ValueLength))

            {
                RtlMoveMemory(ValueKeyName,
                              &ValueKeyInfo->Data[0],
                              ValueKeyInfo->DataLength);

                bInitSystemFont(ValueName, FontSize);
            }
        }

        ZwCloseKey(RegistryKey);
    }

    bOk = bOpenKey(KEY_SOFTWARE_FONTS, &RegistryKey);

    if (!bOk)
    {
        bOk = bOpenKey(KEY_GRE_INITIALIZE, &RegistryKey);
    }

    if (bOk)
    {
    // If the user did not specify a font, or it failed to load, then use the
    // font in the fonts section. This functionality is here to allow
    // a sophisticated user to specify a system font other than the
    // default system font which is defined by font.fon
    // entry in gre_initialize. for instance, lucida unicode was
    // one attempted by LoryH for international setup's but it was
    // not deemed acceptable because of the shell hardcoded issues

        if (STOCKOBJ_SYSFONT == NULL)
        {
            bInitOneStockFont(
                L"FONTS.FON", LF_TYPE_SYSTEM, SYSTEM_FONT,
                RegistryKey, ValueKeyInfo,ValueLength,ValueName,ValueKeyName);
        }

    // init oem stock font

        bInitOneStockFont(
            L"OEMFONT.FON", LF_TYPE_OEM, OEM_FIXED_FONT,
            RegistryKey, ValueKeyInfo,ValueLength,ValueName,ValueKeyName);

    // Initialize the fixed system font - use the default system font
    // if the fixed font could not be loaded

        bInitOneStockFont(
            L"FIXEDFON.FON", LF_TYPE_SYSTEM_FIXED, SYSTEM_FIXED_FONT,
            RegistryKey, ValueKeyInfo,ValueLength,ValueName,ValueKeyName);

        ZwCloseKey(RegistryKey);
    }

// Load the emergency fonts for the system and OEM font in case one
// of the previous two failed. The vInitEmergencyStockFont routine itself
// does appropriate checks to determine if one or the other of these fonts
// has been loaded.

    vInitEmergencyStockFont(L"\\SystemRoot\\System32\\winsrv.dll");

// if system fixed font was not initialized above, make it equal to "ordinary"
// system font. (This is warrisome, because system in not fixed pitch).

    if (STOCKOBJ_SYSFIXEDFONT == NULL)
    {
        bSetStockObject(STOCKOBJ_SYSFONT,SYSTEM_FIXED_FONT);
    }

    DcAttrDefault.hlfntNew = STOCKOBJ_SYSFONT;

// Create the DeviceDefault Font
    
    bOk = TRUE;

    RtlZeroMemory(&elfw,sizeof(ENUMLOGFONTEXDVW));
    elfw.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = FIXED_PITCH;

    if (!bSetStockObject(
            hfontCreate(&elfw,
                        LF_TYPE_DEVICE_DEFAULT,
                        LF_FLAG_STOCK | LF_FLAG_ALIASED,
                        NULL),DEVICE_DEFAULT_FONT))
    {
        if (!G_fConsole)
        {
            bOk = FALSE;
            goto error;
        }
        else
            RIP("bInitStockFonts(): could not create STOCKOBJ_DEFAULTDEVFONT\n");
    }

// Create the ANSI variable Font

    RtlZeroMemory(&elfw,sizeof(ENUMLOGFONTEXDVW));
    elfw.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = VARIABLE_PITCH;

    if (!bSetStockObject(
               hfontCreate(&elfw,
                           LF_TYPE_ANSI_VARIABLE,
                           LF_FLAG_STOCK | LF_FLAG_ALIASED,
                           NULL),ANSI_VAR_FONT))
    {
        if (!G_fConsole)
        {
            bOk = FALSE;
            goto error;
        }
        else
            RIP("bInitStockFonts(): could not create STOCKOBJ_ANSIVARFONT\n");
    }

// Create the ANSI Fixed Font

    RtlZeroMemory(&elfw,sizeof(ENUMLOGFONTEXDVW));
    elfw.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = FIXED_PITCH;

    if (!bSetStockObject( hfontCreate(&elfw,
                                      LF_TYPE_ANSI_FIXED,
                                      LF_FLAG_STOCK | LF_FLAG_ALIASED,
                                      NULL),ANSI_FIXED_FONT))
    {
        if (!G_fConsole)
        {
            bOk = FALSE;
            goto error;
        }
        else
            RIP("bInitStockFonts(): could not create STOCKOBJ_ANSIFIXEDFONT\n");
    }

#if(WINVER >= 0x0400)
// Create the default GUI font.

    if (!bSetStockObject(hfontInitDefaultGuiFont(), DEFAULT_GUI_FONT))
    {
        if (!G_fConsole)
        {
            bOk = FALSE;
            goto error;
        }
        else
            RIP("bInitStockFonts(): could not create STOCKOBJ_DEFAULTGUIFONT\n");
    }
#endif

// Set all stock fonts public.

    if (   (!GreSetLFONTOwner(STOCKOBJ_SYSFONT,        OBJECT_OWNER_PUBLIC))
        || (!GreSetLFONTOwner(STOCKOBJ_SYSFIXEDFONT,   OBJECT_OWNER_PUBLIC))
        || (!GreSetLFONTOwner(STOCKOBJ_OEMFIXEDFONT,   OBJECT_OWNER_PUBLIC))
        || (!GreSetLFONTOwner(STOCKOBJ_DEFAULTDEVFONT, OBJECT_OWNER_PUBLIC))
        || (!GreSetLFONTOwner(STOCKOBJ_ANSIFIXEDFONT,  OBJECT_OWNER_PUBLIC))
        || (!GreSetLFONTOwner(STOCKOBJ_ANSIVARFONT,    OBJECT_OWNER_PUBLIC))
#if(WINVER >= 0x0400)
        || (!GreSetLFONTOwner(STOCKOBJ_DEFAULTGUIFONT, OBJECT_OWNER_PUBLIC))
#endif
       )
    {
        if (!G_fConsole)
        {
            bOk = FALSE;
            goto error;
        }
        else
            RIP("bInitStockFonts(): could not set owner\n");
    }

error:
    VFREEMEM(ValueBuffer);

    return bOk;
}

/******************************Public*Routine******************************\
*
* BOOL bInitStockFonts(VOID)
*
* first check for stock fonts in the %windir%\fonts directory
* and if they are not there, check in the %windir%\system directory
* Later we should even remove the second attepmt when fonts directory
* becomes established, but for now we want to check both places.
*
* History:
*  05-Oct-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

extern "C" BOOL bInitStockFonts(VOID)
{
    return bInitStockFontsInternal(FONTDIR_FONTS);
}

/******************************Public*Routine******************************\
* BOOL bInitSystemFont ()
*
* Initialize the system font from either the SystemFont and SystemFontSize
* or the FONTS.FON definitions in the [windows] and [GRE_Initialize]
* sections of the WIN.INI file, respectively.
*
\**************************************************************************/

BOOL bInitSystemFont(
    PWCHAR pfontFile,
    ULONG fontSize)
{
    ENUMLOGFONTEXDVW elfw;
    COUNT   cFonts;
    BOOL    bRet = FALSE;


    if ( (pfontFile) &&
         (*pfontFile != L'\0') &&
         (fontSize != 0) )
    {
        //
        // Load font file.
        //

        PPFF pPFF_Font;
        PUBLIC_PFTOBJ  pfto;

        // The engine does not handle FOT files anymore, we shouldn't get here with a FOT file 

        if ( (pfto.bLoadAFont(pfontFile,
                              &cFonts,
                              PFF_STATE_PERMANENT_FONT,
                              &pPFF_Font)) &&
             (cFonts != 0) &&
             (pPFF_Font != NULL) )
        {
            //
            // Create and validate public PFF user object.
            //

            PFFOBJ  pffo(pPFF_Font);

            if (pffo.bValid())
            {
                //
                // Find the best size match from the faces (PFEs) in the PFF.
                //

                LONG    lDist;                      // diff. in size of candidate
                LONG    lBestDist = 0x7FFFFFFF;     // arbitrarily high number
                PFE    *ppfeBest = (PFE *) NULL;    // handle of best candidate

                for (COUNT c = 0; c < cFonts; c++)
                {
                    PFEOBJ  pfeoTmp(pffo.ppfe(c));  // candidate face

                    if (pfeoTmp.bValid())
                    {
                        //
                        // Compute the magnitude of the difference in size.
                        // simulations are not relevant
                        //

                        IFIOBJ ifio(pfeoTmp.pifi());

                        if (ifio.bContinuousScaling())
                        {
                            //don't care about best dist.
                            //lBestDist = 0;
                            ppfeBest = pfeoTmp.ppfeGet();
                            break;
                        }
                        else
                        {
                            lDist = (LONG) fontSize - ifio.lfHeight();

                            if ((lDist >= 0) && (lDist < lBestDist))
                            {
                                lBestDist = lDist;
                                ppfeBest = pfeoTmp.ppfeGet();

                                if (lDist == 0)
                                    break;
                            }
                        }
                    }
                }

                //
                // Fill a LOGFONT based on the IFIMETRICS from the best PFE.
                //

                PFEOBJ  pfeo(ppfeBest);

                if (pfeo.bValid())
                {
                    vIFIMetricsToEnumLogFontExDvW(&elfw, pfeo.pifi());
                    IFIOBJ ifio(pfeo.pifi());

                    // If this is a scalable font, force the height to be the same
                    // as that specified by [SystemFontSize].

                    if (ifio.bContinuousScaling())
                    {
                        elfw.elfEnumLogfontEx.elfLogFont.lfHeight = fontSize;
                        elfw.elfEnumLogfontEx.elfLogFont.lfWidth  = 0;
                    }

                    //
                    // Save the HPFE handle.  This is the mapper's default HPFE
                    // (its last resort).
                    //

                    gppfeMapperDefault = pfeo.ppfeGet();

                    //
                    // Win 3.1 compatibility stuff
                    //

                    elfw.elfEnumLogfontEx.elfLogFont.lfQuality = PROOF_QUALITY;

                    bRet = bSetStockObject(hfontCreate(&elfw,
                                                LF_TYPE_SYSTEM,
                                                LF_FLAG_STOCK,
                                                NULL),SYSTEM_FONT);
                }
            }
        }
    }
    return bRet;
}


/******************************Public*Routine******************************\
* VOID bInitOneStockFont()
*
* Routine to initialize a stock font object
*
\**************************************************************************/

BOOL bInitOneStockFontInternal(
    PWCHAR   pwszFont,
    LFTYPE  type,
    int     iFont)
{
    COUNT         cFonts;
    PPFF          pPFF_Font;
    PUBLIC_PFTOBJ pfto;
    ENUMLOGFONTEXDVW    elfw;
    BOOL          bRet = FALSE;

    if ( (pfto.bLoadAFont(pwszFont,
                          &cFonts,
                          PFF_STATE_PERMANENT_FONT,
                          &pPFF_Font)) &&
         (cFonts != 0) &&
         (pPFF_Font != NULL) )
    {
        PFFOBJ  pffo(pPFF_Font);

        if (pffo.bValid())
        {
            PFEOBJ  pfeo(pffo.ppfe(0));

            if (pfeo.bValid())
            {
                vIFIMetricsToEnumLogFontExDvW(&elfw, pfeo.pifi());
                if (iFont == SYSTEM_FONT)
                {
                    //
                    // Save the HPFE handle.  This is the mapper's default
                    // HPFE (its last resort).
                    //

                    gppfeMapperDefault = pfeo.ppfeGet();
                }

                //
                // Win 3.1 compatibility stuff
                //

                elfw.elfEnumLogfontEx.elfLogFont.lfQuality = PROOF_QUALITY;

                bRet = bSetStockObject(hfontCreate(&elfw,type,LF_FLAG_STOCK,NULL),iFont);
            }
        }
    }

    if (STOCKFONT(iFont) == NULL)
    {
        KdPrint(("bInitOneStockFontInternal: Failed to initialize the %ws stock fonts\n",
                 pwszFont));
    }
    return bRet;
}

BOOL bInitOneStockFont
(
    PWSZ                           pwszValue,
    LFTYPE                         type,
    int                            iFont,
    HANDLE                         RegistryKey,
    PKEY_VALUE_PARTIAL_INFORMATION ValueKeyInfo,
    ULONG                          ValueLength,
    PWCHAR                         ValueName,
    PWCHAR                         ValueKeyName
)
{
    BOOL bRet = FALSE;
    if (bQueryValueKey(pwszValue, RegistryKey,
                                  ValueKeyInfo,
                                  ValueLength))
    {
        RtlMoveMemory(ValueKeyName,
                      &ValueKeyInfo->Data[0],
                      ValueKeyInfo->DataLength);

        bRet = bInitOneStockFontInternal(ValueName, type, iFont);
    }
    return bRet;
}

/******************************Public*Routine******************************\
* VOID vInitEmergencyStockFont()
*
* Initializes the system and oem fixed font stock objects in case the
* something failed during initialization of the fonts in WIN.INI.
*
\**************************************************************************/

VOID vInitEmergencyStockFont(
    PWSTR pfontFile)
{
    PPFF pPFF_Font;
    PUBLIC_PFTOBJ  pfto;
    COUNT cFonts;

    ENUMLOGFONTEXDVW  elfw;

    if ( ((STOCKOBJ_OEMFIXEDFONT == NULL) || (STOCKOBJ_SYSFONT == NULL)) &&
         (pfontFile) &&
         (pfto.bLoadAFont(pfontFile,
                          &cFonts,
                          PFF_STATE_PERMANENT_FONT,
                          &pPFF_Font)) &&
         (cFonts != 0) &&
         (pPFF_Font != NULL) )
    {
    // Create and validate PFF user object.

        PFFOBJ  pffo(pPFF_Font); // most recent PFF

        if (pffo.bValid())
        {
        // Create and validate PFE user object.

            for (COUNT i = 0;
                 (i < cFonts) && ((STOCKOBJ_OEMFIXEDFONT == NULL) ||
                                  (STOCKOBJ_SYSFONT      == NULL));
                 i++)
            {
                PFEOBJ pfeo(pffo.ppfe(i));

                if (pfeo.bValid())
                {
                // For the system font use the first face with the name
                // "system."  For the OEM font use the first face with
                // then name "terminal."

                    IFIOBJ ifiobj( pfeo.pifi() );

                    if ( (STOCKOBJ_SYSFONT == NULL) &&
                         (!_wcsicmp(ifiobj.pwszFaceName(), L"SYSTEM")) )
                    {
                        WARNING("vInitEmergencyStockFont(): trying to set STOCKOBJ_SYSFONT\n");

                        vIFIMetricsToEnumLogFontExDvW(&elfw, pfeo.pifi());
                        gppfeMapperDefault = pfeo.ppfeGet();

                    // Win 3.1 compatibility stuff

                        elfw.elfEnumLogfontEx.elfLogFont.lfQuality = PROOF_QUALITY;

                        bSetStockObject(
                            hfontCreate(&elfw,LF_TYPE_SYSTEM,LF_FLAG_STOCK,NULL),
                            SYSTEM_FONT);
                    }

                    if ( (STOCKOBJ_OEMFIXEDFONT == NULL) &&
                         (!_wcsicmp(ifiobj.pwszFaceName(), L"TERMINAL")) )
                    {
                        WARNING("vInitEmergencyStockFont(): trying to set STOCKOBJ_OEMFIXEDFONT\n");

                        vIFIMetricsToEnumLogFontExDvW(&elfw, pfeo.pifi());

                    // Win 3.1 compatibility stuff

                        elfw.elfEnumLogfontEx.elfLogFont.lfQuality = PROOF_QUALITY;

                        bSetStockObject(
                            hfontCreate(&elfw,LF_TYPE_OEM,LF_FLAG_STOCK,NULL),
                            OEM_FIXED_FONT);
                    }
                }
            }
        }

        WARNING("vInitEmergencyStockFont(): Done\n");
    }
}

#if(WINVER >= 0x0400)
/******************************Public*Routine******************************\
* hfontInitDefaultGuiFont
*
* Initialize the DEFAULT_GUI_FONT stock font.
*
* The code Win95 uses to initialize this stock font can be found in
* win\core\gdi\gdiinit.asm in the function InitGuiFonts.  Basically,
* a description of several key parameters (height, weight, italics,
* charset, and facename) are specified as string resources of GDI.DLL.
* After scaling, to compensate for the DPI of the display, these parameters
* are used to create the logfont.
*
* We will emulate this behavior by loading these properties from the
* registry.  Also, so as to not have to recreate the hives initially, if
* the appropriate registry entries do not exist, we will supply defaults
* that match the values currently used by the initial Win95 US release.
*
* The registry entries are:
*
*   [GRE_Initialize]
*       ...
*
*       GUIFont.Height = (height in POINTS, default 8pt.)
*       GUIFont.Weight = (font weight, default FW_NORMAL (400))
*       GUIFont.Italic = (1 if italicized, default 0)
*       GUIFont.CharSet = (charset, default ANSI_CHARSET (0))
*       GUIFont.Facename = (facename, default "MS Sans Serif")
*
* Note: On Win95, the facename is NULL.  This defaults to "MS Sans Serif"
*       on Win95.  Unfortunately, the WinNT mapper is different and will
*       map to "Arial".  To keep ensure that GetObject returns a LOGFONT
*       equivalent to Win95, we could create this font as LF_FLAG_ALIASED
*       so that externally the facename would be NULL but internally we
*       use one with the appropriate facename.  On the other hand, an app
*       might query to find out the facename of the DEFAULT_GUI_FONT and
*       create a new font.  On Win95, this would also map to "MS Sans Serif",
*       but we would map to "Arial".  For now, I propose that we go with
*       the simpler method (do not set LF_FLAG_ALIASED).  I just wanted
*       to note this in case a bug arises later.
*
* History:
*  11-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HFONT hfontInitDefaultGuiFont()
{
    HANDLE hkey;
    PKEY_VALUE_PARTIAL_INFORMATION ValueKeyInfo;
    BYTE aj[sizeof(PKEY_VALUE_PARTIAL_INFORMATION) + (LF_FACESIZE * sizeof(WCHAR))];

    ENUMLOGFONTEXDVW  elfw;

    RtlZeroMemory(&elfw,sizeof(ENUMLOGFONTEXDVW));

// Initialize to defaults.

    wcscpy(elfw.elfEnumLogfontEx.elfLogFont.lfFaceName, L"MS Shell Dlg");
    elfw.elfEnumLogfontEx.elfLogFont.lfHeight  = 8;
    elfw.elfEnumLogfontEx.elfLogFont.lfWeight  = FW_NORMAL;
    elfw.elfEnumLogfontEx.elfLogFont.lfItalic  = 0;
    elfw.elfEnumLogfontEx.elfLogFont.lfCharSet = gjCurCharset;

// Now let's attempt to initialize from registry.

    ValueKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION) aj;

    if (bOpenKey(KEY_GRE_INITIALIZE, &hkey))
    {
        if (bQueryValueKey(L"GUIFont.Facename", hkey, ValueKeyInfo, sizeof(aj)))
        {
            wcsncpy(elfw.elfEnumLogfontEx.elfLogFont.lfFaceName, (WCHAR *) ValueKeyInfo->Data,
                    LF_FACESIZE);
        }

        if (bQueryValueKey(L"GUIFont.Height", hkey, ValueKeyInfo, sizeof(aj)))
        {
            elfw.elfEnumLogfontEx.elfLogFont.lfHeight = *((PLONG)(&ValueKeyInfo->Data[0]));
        }

        if (bQueryValueKey(L"GUIFont.Weight", hkey, ValueKeyInfo, sizeof(aj)))
        {
            elfw.elfEnumLogfontEx.elfLogFont.lfWeight = *((PLONG)(&ValueKeyInfo->Data[0]));
        }

        if (bQueryValueKey(L"GUIFont.Italic", hkey, ValueKeyInfo, sizeof(aj)))
        {
            elfw.elfEnumLogfontEx.elfLogFont.lfItalic = (BYTE)*((PULONG)(&ValueKeyInfo->Data[0]));
        }

        if (bQueryValueKey(L"GUIFont.CharSet", hkey, ValueKeyInfo, sizeof(aj)))
        {
            elfw.elfEnumLogfontEx.elfLogFont.lfCharSet = (BYTE)*((PULONG)(&ValueKeyInfo->Data[0]));
        }

        ZwCloseKey(hkey);

    }

// Compute height using vertical DPI of display.
//
// Unfortunately, we do not have a display driver loaded so we do not
// know what the vertical DPI is.  So, set a flag indicating that this
// needs to be done and we will finish intitialization after the (first)
// display driver is loaded.

    //elfw.elfEnumLogfontEx.elfLogFont.lfHeight = -((elfw.elfEnumLogfontEx.elfLogFont.lfHeight * ydpi + 36) / 72);
    gbFinishDefGUIFontInit = TRUE;

// Create the LOGFONT and return.

    return hfontCreate(&elfw, LF_TYPE_DEFAULT_GUI, LF_FLAG_STOCK, NULL);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\srcblt8.cxx ===
/******************************Module*Header*******************************\
* Module Name: srcblt8.cxx
*
* This contains the bitmap simulation functions that blt to a 8 bit/pel
* DIB surface.
*
* Created: 07-Feb-1991 19:27:49
* Author: Patrick Haluptzok patrickh
*
* NB:  The function <vSrcCopySRLE8D8()> was removed from here on 22 Jan 1992
*      and placed in the module <rle8blt.cxx>.  - Andrew Milton (w-andym)
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/*******************Public*Routine*****************\
* vSrcCopyS1D8
*
* There are three main loops in this function.
*
* The first loop deals with the full two dwords part of
* the Dst while fetching/shifting the matching 8 bits
* from the Src.
*
* The second loop deals with the left most strip
* of the partial two dwords in Dst.
*
* The third loop deals with the right most strip
* of the partial two dwords in Dst.
*
* We use a 16 entry dword table to expand the
* Src bits.  We walk thru Src one byte at a time
* and expand to Dst two Dwords at a time.  Dst Dword
* is aligned.
*
* History:
* 17-Oct-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.
*
\**************************************************/

VOID vSrcCopyS1D8(PBLTINFO psb)
{
    BYTE  jSrc;    // holds a source byte
    BYTE  jDst;    // holds a dest byte
    INT   iSrc;    // bit position in the first Src byte
    INT   iDst;    // bit position in the first 8 Dst bytes
    PBYTE pjDst;   // pointer to the Src bytes
    PBYTE pjSrc;   // pointer to the Dst bytes
    LONG  xSrcEnd = psb->xSrcEnd;
    LONG  cy;      // number of rows
    LONG  cx;      // number of pixels
    BYTE  jAlignL;  // alignment bits to the left
    BYTE  jAlignR;  // alignment bits to the right
    LONG  cFullBytes;  //number of full 8 bytes dealed with
    BOOL  bNextByte;
    LONG  xDstEnd;
    LONG  lDeltaDst;
    LONG  lDeltaSrc;
    BYTE  jB = (BYTE) (psb->pxlo->pulXlate[0]);
    BYTE  jF = (BYTE) (psb->pxlo->pulXlate[1]);
    ULONG ulB = (ULONG)(psb->pxlo->pulXlate[0]);
    ULONG ulF = (ULONG)(psb->pxlo->pulXlate[1]);
    ULONG aulTable[16];
    UCHAR aucTable[2];
    INT   count;
    INT   i;
    BOOL  bNextSrc=TRUE;

    // We assume we are doing left to right top to bottom blting
    ASSERTGDI(psb->xDir == 1, "vSrcCopyS1D8 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS1D8 - direction not up to down");

    ASSERTGDI(psb->cy != 0, "ERROR: Src Move cy == 0");

    //DbgPrint ("vsrccopys1d8\n");

    // Generate aucTable
    aucTable[0] = jB;
    aucTable[1] = jF;

    // Generate ulTable
    ULONG ulVal = ulB;

    ulVal = ulVal | (ulVal << 8);
    ulVal = ulVal | (ulVal << 16);
    aulTable[0] = ulVal;            // 0 0 0 0
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[8] = ulVal;            // 0 0 0 1
    ulVal <<= 8;
    ulVal |=  ulB;
    aulTable[4] = ulVal;            // 0 0 1 0
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[10] = ulVal;            // 0 1 0 1
    ulVal <<= 8;
    ulVal |=  ulB;
    aulTable[5] = ulVal;           // 1 0 1 0
    ulVal <<= 8;
    ulVal |=  ulB;
    aulTable[ 2] = ulVal;           // 0 1 0 0
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[ 9] = ulVal;           // 1 0 0 1
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[12] = ulVal;           // 0 0 1 1
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[14] = ulVal;           // 0 1 1 1
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[15] = ulVal;           // 1 1 1 1
    ulVal <<= 8;
    ulVal |=  ulB;
    aulTable[ 7] = ulVal;           // 1 1 1 0
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[11] = ulVal;           // 1 1 0 1
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[13] = ulVal;           // 1 0 1 1
    ulVal <<= 8;
    ulVal |=  ulB;
    aulTable[06] = ulVal;           // 0 1 1 0
    ulVal <<= 8;
    ulVal |=  ulB;
    aulTable[ 3] = ulVal;           // 1 1 0 0
    ulVal <<= 8;
    ulVal |=  ulB;
    aulTable[ 1] = ulVal;           // 1 0 0 0

     //Get Src and Dst start positions
    iSrc = psb->xSrcStart & 0x0007;
    iDst = psb->xDstStart & 0x0007;

    // Checking alignment
    // If Src starting point is ahead of Dst
    if (iSrc < iDst)
        jAlignL = 8 - (iDst - iSrc);
    // If Dst starting point is ahead of Src
    else
        jAlignL = iSrc - iDst;

    jAlignR = 8 - jAlignL;

    cx=psb->cx;

    xDstEnd = psb->xDstStart + cx;

    lDeltaDst = psb->lDeltaDst;
    lDeltaSrc = psb->lDeltaSrc;

    // check if there is a next 8 bytes
    bNextByte = !((xDstEnd>>3) ==
                 (psb->xDstStart>>3));

    // if Src and Dst are aligned, use a separete loop
    // to obtain better performance;
    // If not, we shift the Src bytes to match with
    // the Dst 8 bytes (2 dwords) one at a time

    if (bNextByte)
    {
        long iStrideSrc;
        long iStrideDst;
        PBYTE pjSrcEnd;  //pointer to the Last full Src byte

        // Get first Dst full 8 bytes (2 dwords expanding from
        // 1 Src byte)
        pjDst = psb->pjDst + ((psb->xDstStart+7)&~0x07);

        // Get the Src byte that matches the first Dst
        // full 8 bytes
        pjSrc = psb->pjSrc + ((psb->xSrcStart+((8-iDst)&0x07)) >> 3);

        //Get the number of full bytes
        cFullBytes = (xDstEnd>>3)-((psb->xDstStart+7)>>3);

        //the increment to the full byte on the next scan line
        iStrideDst = lDeltaDst - cFullBytes*8;
        iStrideSrc = lDeltaSrc - cFullBytes;

        // deal with our special case
        cy = psb->cy;

        if (!jAlignL)
        {
            while (cy--)
            {
                pjSrcEnd = pjSrc+cFullBytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = *pjSrc++;

                    *(PULONG) (pjDst + 0) = aulTable[jSrc >> 4];
                    *(PULONG) (pjDst + 4) = aulTable[jSrc & 0X0F];

                    pjDst +=8;
                }

                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }

        }   //end of if (!jAlignL)


        else  // if not aligned
        {
            BYTE jRem;     //remainder

            while (cy--)
            {
                jRem = *pjSrc << jAlignL;

                pjSrcEnd = pjSrc+cFullBytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = ((*(++pjSrc))>>jAlignR) | jRem;

                    *(PULONG) (pjDst + 0) = aulTable[jSrc >> 4];
                    *(PULONG) (pjDst + 4) = aulTable[jSrc & 0X0F];

                    pjDst +=8;

                    //next remainder
                    jRem = *pjSrc << jAlignL;
                }

                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }
        } //else
    } //if
    // End of our dealing with the full bytes

    //Deal with the starting pixels
    if (!bNextByte)
    {
        count = cx;
        bNextSrc = ((iSrc + cx) > 8);
    }
    else
        count = 8-iDst;

    if (iDst | !bNextByte)
    {
        PBYTE pjDstTemp;
        PBYTE pjDstEnd;

        pjDst = psb->pjDst + psb->xDstStart;
        pjSrc = psb->pjSrc + (psb->xSrcStart>>3);

        cy = psb->cy;

        if (iSrc > iDst)
        {
            if (bNextSrc)
            {
                while (cy--)
                {
                    jSrc = *pjSrc << jAlignL;
                    jSrc |= *(pjSrc+1) >> jAlignR;

                    jSrc <<= iDst;

                    pjDstTemp = pjDst;

                    pjDstEnd = pjDst + count;

                    while (pjDstTemp != pjDstEnd)
                    {
                        * (pjDstTemp++) = aucTable[(jSrc&0x80)>>7];

                        jSrc <<= 1;
                    }

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;

                }
            }
            else // if (!bNextSrc)
            {
                while (cy--)
                {
                    jSrc = *pjSrc << jAlignL;

                    jSrc <<= iDst;

                    pjDstTemp = pjDst;

                    pjDstEnd = pjDst + count;

                    while (pjDstTemp != pjDstEnd)
                    {
                        * (pjDstTemp++) = aucTable[(jSrc&0x80)>>7];

                        jSrc <<= 1;
                    }

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;

                }
            }    //else
        }  // if
        else //if (iSrc <= iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << iSrc;

                pjDstTemp = pjDst;

                pjDstEnd = pjDst + count;

                while (pjDstTemp != pjDstEnd)
                {
                    *(pjDstTemp++) = aucTable[(jSrc&0x80)>>7];

                    jSrc <<= 1;
                }

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }

        }

   } //if

   // Deal with the ending pixels
   if ((xDstEnd & 0x0007)
       && bNextByte)
   {
        PBYTE pjDstTemp;
        PBYTE pjDstEnd;

        // Get the last partial bytes on the
        // scan line
        pjDst = psb->pjDst+(xDstEnd&~0x07);

        // Get the Src byte that matches the
        // right partial Dst 8 bytes
        pjSrc = psb->pjSrc + ((psb->xSrcEnd-1) >>3);

        // Get the ending position in the last
        // Src and Dst bytes
        iSrc = (psb->xSrcEnd-1) & 0x0007;
        iDst = (xDstEnd-1) & 0x0007;

        count = iDst+1;

        cy = psb->cy;

        if (iSrc >= iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << jAlignL;

                pjDstTemp = pjDst;

                pjDstEnd = pjDst + count;

                while (pjDstTemp != pjDstEnd)
                {
                    * (pjDstTemp++) = aucTable[(jSrc&0x80)>>7];

                    jSrc <<= 1;
                }

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
        else //if (iSrc < iDst)
        {
            while (cy--)
            {
                 jSrc = *(pjSrc-1) << jAlignL;

                 ASSERTGDI(pjSrc <= (psb->pjSrc+lDeltaSrc*(psb->cy-cy-1)+((psb->xSrcEnd-1)>>3)),
                           "vSrcCopyS1D8 - pjSrc passed the last byte");

                 jSrc |= *pjSrc >> jAlignR;

                 pjDstTemp = pjDst;

                 pjDstEnd = pjDst + count;

                 while (pjDstTemp != pjDstEnd)
                 {
                    *(pjDstTemp++) = aucTable[(jSrc&0x80)>>7];

                    jSrc <<= 1;
                 }

                 pjDst += lDeltaDst;
                 pjSrc += lDeltaSrc;
            }
        }
    } //if

}

/******************************Public*Routine******************************\
* vSrcCopyS4D8
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS4D8(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS4D8 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS4D8 - direction not up to down");

    BYTE  jSrc;
    LONG  i;
    PBYTE pjDst;
    PBYTE pjSrc;
    PBYTE pjDstHolder = psb->pjDst + psb->xDstStart;
    PBYTE pjSrcHolder  = psb->pjSrc + (psb->xSrcStart >> 1);
    ULONG cx = psb->xSrcEnd - psb->xSrcStart;
    ULONG cy = psb->cy;
    PULONG pulTranslate = psb->pxlo->pulXlate;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    do {
        pjDst = pjDstHolder;
	pjSrc = pjSrcHolder;

	if ((psb->xSrcStart & 0x1) != 0)
	{
            jSrc = *(pjSrc++);
        }

	for (i = psb->xSrcStart; i < psb->xSrcEnd; i += 1)
	{
	    if ((i & 0x1) != 0)
	    {
		*(pjDst++) = (BYTE) pulTranslate[jSrc & 0x0F];
	    }
	    else
	    {
                jSrc = *(pjSrc++);
		*(pjDst++) = (BYTE) pulTranslate[((ULONG) (jSrc & 0xF0)) >> 4];
            }
        }

        pjSrcHolder += psb->lDeltaSrc;
        pjDstHolder += psb->lDeltaDst;
	cy -= 1;

    } while(cy > 0);
}

/******************************Public*Routine******************************\
* vSrcCopyS8D8
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D8(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting.
// If it was on the same surface we would be doing the identity case.

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS8D8 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS8D8 - direction not up to down");

// These are our holding variables

#if MESSAGE_BLT
    DbgPrint("Now entering vSrcCopyS8D8\n");
#endif

    PBYTE pjSrc  = psb->pjSrc + psb->xSrcStart;
    PBYTE pjDst  = psb->pjDst + psb->xDstStart;
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;
    LONG lSrcSkip = psb->lDeltaSrc - cx;
    LONG lDstSkip = psb->lDeltaDst - cx;
    ULONG cStartPixels;
    ULONG cMiddlePixels;
    ULONG cEndPixels;
    ULONG i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    // 'cStartPixels' is the minimum number of 1-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((-((LONG_PTR) pjDst)) & 3);

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    while(1)
    {
        // Write pixels a byte at a time until we're 'dword' aligned on
        // the destination:

        for (i = cStartPixels; i != 0; i--)
        {
            *pjDst++ = (BYTE) pulXlate[*pjSrc++];
        }

        // Now write pixels a dword at a time.  This is almost a 4x win
        // over doing byte writes if we're writing to frame buffer memory
        // over the PCI bus on Pentium class systems, because the PCI
        // write throughput is so slow:

        for (i = cMiddlePixels; i != 0; i--)
        {
            *((ULONG*) (pjDst)) = (pulXlate[*(pjSrc)])
                                | (pulXlate[*(pjSrc + 1)] << 8)
                                | (pulXlate[*(pjSrc + 2)] << 16)
                                | (pulXlate[*(pjSrc + 3)] << 24);
            pjDst += 4;
            pjSrc += 4;
        }

        // Take care of the end alignment:

        for (i = cEndPixels; i != 0; i--)
        {
            *pjDst++ = (BYTE) pulXlate[*pjSrc++];
        }

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS8D8IdentityLtoR
*
* This is the special case no translate blting.  All the SmDn should have
* them if m==n.  Identity xlates only occur amoung matching format bitmaps
* and screens.
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D8IdentityLtoR(PBLTINFO psb)
{
#if MESSAGE_BLT
    DbgPrint("Now entering s8d8 identity L to R\n");
#endif

    ASSERTGDI(psb->xDir == 1, "S8D8identLtoR has wrong value xDir");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + psb->xSrcStart;
    PBYTE pjDst  = psb->pjDst + psb->xDstStart;
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

#if MESSAGE_BLT
    DbgPrint("xdir: %ld  cy: %lu  xSrcStart %lu  xDstStart %lu xSrcEnd %lu cx %lu\n",
             psb->xDir, cy, psb->xSrcStart, psb->xDstStart, psb->xSrcEnd, cx);
#endif

    do {
        if(psb->fSrcAlignedRd)
            vSrcAlignCopyMemory(pjDst,pjSrc,cx);
        else
            RtlMoveMemory((PVOID)pjDst, (PVOID)pjSrc, cx);
        pjSrc += psb->lDeltaSrc;
        pjDst += psb->lDeltaDst;
        cy -= 1;
    } while(cy > 0);
}

/******************************Public*Routine******************************\
* vSrcCopyS8D8IdentityRtoL
*
* This is the special case no translate blting.  All the SmDn should have
* them if m==n.  Identity xlates only occur amoung matching format bitmaps
* and screens.
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D8IdentityRtoL(PBLTINFO psb)
{
#if MESSAGE_BLT
    DbgPrint("Now entering s8d8 identity R to L\n");
#endif

    ASSERTGDI(psb->xDir == -1, "S8D8identR to L has wrong value xDir");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + psb->xSrcStart;
    PBYTE pjDst  = psb->pjDst + psb->xDstStart;
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

#if MESSAGE_BLT
    DbgPrint("xdir: %ld  cy: %lu  xSrcStart %lu  xDstStart %lu xSrcEnd %lu cx %lu\n",
             psb->xDir, cy, psb->xSrcStart, psb->xDstStart, psb->xSrcEnd, cx);
#endif

    pjSrc = pjSrc - cx + 1;
    pjDst = pjDst - cx + 1;

    do {
        if(psb->fSrcAlignedRd)
            vSrcAlignCopyMemory(pjDst,pjSrc,cx);
        else
            RtlMoveMemory((PVOID)pjDst, (PVOID)pjSrc, cx);
        pjSrc += psb->lDeltaSrc;
        pjDst += psb->lDeltaDst;
        cy -= 1;
    } while(cy > 0);
}

/**************************************************************************\
* vSrcCopyS16D8
*   Use translation table from 555RGB to surface palette. Not as accurare
*   as full nearest search but much faster.
*
* Arguments:
*
*   psb - bitblt info
*
* Return Value:
*
*   none
*
* History:
*
*    2/24/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID vSrcCopyS16D8(PBLTINFO psb)
{
    // We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D8 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D8 - direction not up to down");

    // These are our holding variables

    ULONG   cx          = psb->cx;
    ULONG   cy	        = psb->cy;
    XLATE  *pxlo        = psb->pxlo;
    PUSHORT pusSrc = (PUSHORT) (psb->pjSrc + (2 * psb->xSrcStart));
    PBYTE   pjDst       = psb->pjDst + psb->xDstStart;
    PBYTE   pxlate555   = NULL;
    PUSHORT pusSrcTemp;
    PBYTE   pjDstTemp;
    ULONG   cStartPixels;
    ULONG   cMiddlePixels;
    ULONG   cEndPixels;
    INT     i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    // 'cStartPixels' is the minimum number of 1-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((-((LONG_PTR) pjDst)) & 3);

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    PFN_XLATE_RGB_TO_PALETTE pfnXlate = XLATEOBJ_ulIndexToPalSurf;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");
    ASSERTGDI(((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).bValid(),"vSrcCopyS16D8: Src palette not valid\n");

    pxlate555 = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate555 != NULL)
    {
        ULONG  ulPalSrcFlags = ((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).flPal();

        if (ulPalSrcFlags & PAL_RGB16_555)
        {
            pfnXlate = XLATEOBJ_RGB16_555ToPalSurf;
        }
        else if (ulPalSrcFlags & PAL_RGB16_565)
        {
            pfnXlate = XLATEOBJ_RGB16_565ToPalSurf;
        }

        while(1)
        {
           // Write pixels a byte at a time until we're 'dword' aligned on
           // the destination:
           pjDstTemp = pjDst;
           pusSrcTemp  = pusSrc;

           for (i = cStartPixels; i != 0; i--)
           {
               *pjDstTemp++ = (*pfnXlate)(pxlo,pxlate555,*pusSrcTemp++);
           }

           // Now write pixels a dword at a time.  This is almost a 4x win
           // over doing byte writes if we're writing to frame buffer memory
           // over the PCI bus on Pentium class systems, because the PCI
           // write throughput is so slow:

           for (i = cMiddlePixels; i != 0; i--)
           {
               *((ULONG*) (pjDstTemp)) = (*pfnXlate)(pxlo,pxlate555,*pusSrcTemp)
                                   | (((*pfnXlate)(pxlo,pxlate555,*(pusSrcTemp+1))) << 8)
                                   | (((*pfnXlate)(pxlo,pxlate555,*(pusSrcTemp+2)))<< 16)
                                   | (((*pfnXlate)(pxlo,pxlate555,*(pusSrcTemp+3)))<< 24);
               pjDstTemp += 4;
               pusSrcTemp += 4;
           }

           // Take care of the end alignment:

           for (i = cEndPixels; i != 0; i--)
           {
               *pjDstTemp++ = (*pfnXlate)(pxlo,pxlate555,*pusSrcTemp++);
           }

           if (--cy == 0)
               break;

            pusSrc = (PUSHORT) (((PBYTE) pusSrc) + psb->lDeltaSrc);
            pjDst += psb->lDeltaDst;
        }

    }
}

/**************************************************************************\
* vSrcCopyS24D8
*   Use translation table from 555RGB to surface palette. Not as accurare
*   as full nearest search but 600 times faster.
*
* Arguments:
*
*   psb - bitblt info
*
* Return Value:
*
*   none
*
* History:
*
*    2/24/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID vSrcCopyS24D8(PBLTINFO psb)
{
    //
    // We assume we are doing left to right top to bottom blting
    //

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D8 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D8 - direction not up to down");

    ULONG cx         = psb->cx;
    ULONG cy         = psb->cy;
    PBYTE pjSrc      = psb->pjSrc + (3 * psb->xSrcStart);
    PBYTE pjDst      = psb->pjDst + psb->xDstStart;
    PBYTE pjDstEndY  = pjDst + cy * psb->lDeltaDst;
    PBYTE pjDstEnd;
    XLATE *pxlo      = psb->pxlo;
    PBYTE pxlate555  = NULL;
    PBYTE pjSrcTemp;
    PBYTE pjDstTemp;
    BYTE  r, g, b;
    BYTE  PaletteIndex1,PaletteIndex2,PaletteIndex3,PaletteIndex4;
    ULONG cStartPixels;
    ULONG cMiddlePixels;
    ULONG cEndPixels;
    INT   i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");
    ASSERTGDI(((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).bValid(),"vSrcCopyS24D8: Src palette not valid\n");

    // 'cStartPixels' is the minimum number of 1-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((-((LONG_PTR) pjDst)) & 3);

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    pxlate555 = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate555)
    {
        while(1)
        {
           // Write pixels a byte at a time until we're 'dword' aligned on
           // the destination:
           pjDstTemp = pjDst;
           pjSrcTemp  = pjSrc;

           for (i = cStartPixels; i != 0; i--)
           {
                b = *(pjSrcTemp  );
                g = *(pjSrcTemp+1);
                r = *(pjSrcTemp+2);

                *pjDstTemp = XLATEOBJ_RGB32ToPalSurf(pxlo,pxlate555,(b << 16) | (g << 8) | r);

                pjDstTemp ++;
                pjSrcTemp += 3;
           }

           // Now write pixels a dword at a time.  This is almost a 4x win
           // over doing byte writes if we're writing to frame buffer memory
           // over the PCI bus on Pentium class systems, because the PCI
           // write throughput is so slow:

           for (i = cMiddlePixels; i != 0; i--)
           {
               b = *(pjSrcTemp  );
               g = *(pjSrcTemp+1);
               r = *(pjSrcTemp+2);

               PaletteIndex1 = XLATEOBJ_RGB32ToPalSurf(pxlo,pxlate555,(b << 16) | (g << 8) | r);

               pjSrcTemp += 3;

               b = *(pjSrcTemp  );
               g = *(pjSrcTemp+1);
               r = *(pjSrcTemp+2);

               PaletteIndex2 = XLATEOBJ_RGB32ToPalSurf(pxlo,pxlate555,(b << 16) | (g << 8) | r);

               pjSrcTemp += 3;

               b = *(pjSrcTemp  );
               g = *(pjSrcTemp+1);
               r = *(pjSrcTemp+2);

               PaletteIndex3 = XLATEOBJ_RGB32ToPalSurf(pxlo,pxlate555,(b << 16) | (g << 8) | r);

               pjSrcTemp += 3;

               b = *(pjSrcTemp  );
               g = *(pjSrcTemp+1);
               r = *(pjSrcTemp+2);

               PaletteIndex4 = XLATEOBJ_RGB32ToPalSurf(pxlo,pxlate555,(b << 16) | (g << 8) | r);

               pjSrcTemp += 3;

               *((ULONG*) (pjDstTemp)) = PaletteIndex1
                                   | (PaletteIndex2 << 8)
                                   | (PaletteIndex3 << 16)
                                   | (PaletteIndex4 << 24);
               pjDstTemp += 4;
           }

           // Take care of the end alignment:

           for (i = cEndPixels; i != 0; i--)
           {
                b = *(pjSrcTemp  );
                g = *(pjSrcTemp+1);
                r = *(pjSrcTemp+2);

                *pjDstTemp = XLATEOBJ_RGB32ToPalSurf(pxlo,pxlate555,(b << 16) | (g << 8) | r);

                pjDstTemp ++;
                pjSrcTemp += 3;
           }

           if (--cy == 0)
               break;

           pjSrc += psb->lDeltaSrc;
           pjDst += psb->lDeltaDst;

        }

     }
}

/**************************************************************************\
* vSrcCopyS32D8
*   Use translation table from 555RGB to surface palette. Not as accurare
*   as full nearest search but 600 times faster.
*
* Arguments:
*
*   psb - bitblt info
*
* Return Value:
*
*   none
*
* History:
*
*    2/24/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID vSrcCopyS32D8(PBLTINFO psb)
{
    // We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D8 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D8 - direction not up to down");

    PULONG pulSrcTemp;
    PBYTE  pjDstTemp;
    PULONG pulSrc = (PULONG) (psb->pjSrc + (4 * psb->xSrcStart));
    PBYTE  pjDst  = psb->pjDst + psb->xDstStart;
    ULONG  cx     = psb->cx;
    ULONG  cy     = psb->cy;
    XLATE  *pxlo  = psb->pxlo;
    PBYTE  pxlate555 = NULL;
    ULONG  cStartPixels;
    ULONG  cMiddlePixels;
    ULONG  cEndPixels;
    INT    i;

    PFN_XLATE_RGB_TO_PALETTE pfnXlate = XLATEOBJ_ulIndexToPalSurf;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    //
    // match to the destination palette
    //

    ASSERTGDI(((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).bValid(),"vSrcCopyS32D8: Src palette not valid\n");

    // 'cStartPixels' is the minimum number of 1-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((-((LONG_PTR) pjDst)) & 3);

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    //
    // determine source palette type, use specialized code for RGB and BGR formats
    //

    ULONG  ulPalSrcFlags = ((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).flPal();

    if (ulPalSrcFlags & PAL_RGB)
    {
        pfnXlate = XLATEOBJ_RGB32ToPalSurf;
    }
    else if (ulPalSrcFlags & PAL_BGR)
    {
        pfnXlate = XLATEOBJ_BGR32ToPalSurf;
    }

    //
    // get 555 to palete translate table
    //
    pxlate555 = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate555 != NULL)
    {
        //
        // translate bitmap
        //
        while(1)
        {
           // Write pixels a byte at a time until we're 'dword' aligned on
           // the destination:
           pjDstTemp = pjDst;
           pulSrcTemp  = pulSrc;

           for (i = cStartPixels; i != 0; i--)
           {
               *pjDstTemp++ = (*pfnXlate)(pxlo,pxlate555,*pulSrcTemp++);
           }

           // Now write pixels a dword at a time.  This is almost a 4x win
           // over doing byte writes if we're writing to frame buffer memory
           // over the PCI bus on Pentium class systems, because the PCI
           // write throughput is so slow:

           for (i = cMiddlePixels; i != 0; i--)
           {
               *((ULONG*) (pjDstTemp)) = (*pfnXlate)(pxlo,pxlate555,*pulSrcTemp)
                                   | (((*pfnXlate)(pxlo,pxlate555,*(pulSrcTemp+1))) << 8)
                                   | (((*pfnXlate)(pxlo,pxlate555,*(pulSrcTemp+2)))<< 16)
                                   | (((*pfnXlate)(pxlo,pxlate555,*(pulSrcTemp+3)))<< 24);
               pjDstTemp += 4;
               pulSrcTemp += 4;
           }

           // Take care of the end alignment:

           for (i = cEndPixels; i != 0; i--)
           {
               *pjDstTemp++ = (*pfnXlate)(pxlo,pxlate555,*pulSrcTemp++);
           }

           if (--cy == 0)
               break;

            pulSrc = (PULONG) (((PBYTE) pulSrc) + psb->lDeltaSrc);
            pjDst += psb->lDeltaDst;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\surfeng.cxx ===
/******************************Module*Header*******************************\
* Module Name: surfeng.cxx
*
* Internal surface routines
*
* Created: 13-May-1991 12:53:31
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern "C" BOOL bInitBMOBJ();

#define MAX_STOCKBITMAPS 4*1024 
LONG gStockBitmapFree = MAX_STOCKBITMAPS;

#pragma alloc_text(INIT, bInitBMOBJ)

#if DBG_STOCKBITMAPS
#define STOCKWARNING DbgPrint
#define STOCKINFO    DbgPrint
#else
#define STOCKWARNING
#define STOCKINFO   
#endif

/******************************Public*Routine******************************\
* GreSetBitmapOwner
*
* Sets the bitmap owner.
*
\**************************************************************************/

BOOL
GreSetBitmapOwner(
    HBITMAP hbm,
    W32PID  lPid
    )
{
    BOOL bRet = FALSE;
    SURFREF so((HSURF)hbm);

    if (so.bValid())
    {
        if (!(so.ps->bDIBSection() && (lPid == OBJECT_OWNER_PUBLIC)))
        {
            if(HmgStockObj(hbm)) {
                WARNING("GreSetBitmapOwner: Cannot set owner for the stock bitmap\n");
            } 
            else
            { 
#if TRACE_SURFACE_ALLOCS
#if TRACE_SURFACE_USER_CHAIN_IN_UM
                BOOL            bOwned;
                TRACED_SURFACE *pts = (TRACED_SURFACE *)so.ps;

                if (pts->bEnabled())
                {
                    PENTRY  pentTmp = &gpentHmgr[(UINT) HmgIfromH(hbm)];

                    bOwned = ((OBJECTOWNER_PID(pentTmp->ObjectOwner) != OBJECT_OWNER_PUBLIC) &&
                              (OBJECTOWNER_PID(pentTmp->ObjectOwner) != OBJECT_OWNER_NONE));

                    if (bOwned && ((lPid == OBJECT_OWNER_PUBLIC) || (lPid == OBJECT_OWNER_NONE)))
                    {
                        pts->vProcessStackFromUM(TRUE);
                        ASSERTGDI(pentTmp->pUser == NULL, "Object becoming unowned, but user mem is still allocated.\n");
                    }
                }
                else
                {
                    bOwned = TRUE;
                }
#endif
#endif

                bRet = HmgSetOwner((HOBJ)hbm,lPid,SURF_TYPE);

#if TRACE_SURFACE_ALLOCS
#if TRACE_SURFACE_USER_CHAIN_IN_UM
                if (!bRet && !bOwned)
                {
                    pts->vProcessStackFromUM(TRUE);
                }
#endif
#endif
            }
        }
        else
        {
            WARNING ("GreSetBitmapOnwer - Setting a DIBSECTION to PUBLIC\n");
        }    
    }
    else
    {
        WARNING1("GreSetBitmapOnwer - invalid surfobj\n");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GreMakeBitmapStock
*
* Makes the bitmap a stock object.
*
* Requirements:
*    Bitmap is already not a stock Object.
*    Bitmap is not a dibsection.
*    Bitmap should not be selected into any DCs.
*    Not more than MAX_STOCKBITMAPS gStockBitmaps. 
*
\**************************************************************************/

HBITMAP
GreMakeBitmapStock(HBITMAP hbm)
{
    HANDLE bRet = 0;
    SURFREFAPI so((HSURF)hbm);

    if (so.bValid())
    {
        if (!(so.ps->bDIBSection()))
        {
            if (HmgStockObj(hbm) || so.ps->cRef())
            {
                STOCKWARNING("GreMakeBitmapStock: cannot make bitmap (%p) stock\nReason:",hbm);
                if (HmgStockObj(hbm))
                    STOCKWARNING(" it is already a stock bitmap\n");
                else 
                    STOCKWARNING(" it is selected into some DC\n");
            } 
            else
            {
                bRet = (HANDLE)((ULONG_PTR)hbm | GDISTOCKOBJ);
                if (InterlockedDecrement(&gStockBitmapFree) >= 0 &&
                    HmgLockAndModifyHandleType((HOBJ)bRet))
                {
                    so.ps->vSetStockSurface(); 
                    so.ps->hsurf(bRet);
                    so.vSetPID(OBJECT_OWNER_PUBLIC);
                 }
                 else
                 {
                     InterlockedIncrement(&gStockBitmapFree);
                     STOCKWARNING ("GreMakeBitmapStock - HmgLockAndModifyHandleType failed\n");
                     bRet = 0;
                 }
            }
        }
        else
        {
            WARNING ("GreMakeBitmapStock - Setting a DIBSECTION to Stock \n");
        }    
    }
    else
    {
        WARNING1("GreMakeBitmapStock - invalid surfobj\n");
    }

    return((HBITMAP)bRet);
}


/******************************Public*Routine******************************\
* GreMakeBitmapNonStock
*
* Makes the bitmap a non stock object.
*
* Requirements:
*    Bitmap is not default stock bitmap
*    Bitmap is a stock bitmap
*    Bitmap is not a dibsection
*    Bitmap is not selected into any DC
*    Some stock bitmaps should exist
*    Bitmap must be public
*
\**************************************************************************/

HBITMAP
GreMakeBitmapNonStock(HBITMAP hbm)
{
    HANDLE bRet = 0;
    SURFREFAPI so((HSURF)hbm);

    ASSERTGDI(GreGetObjectOwner((HOBJ)hbm,SURF_TYPE) == OBJECT_OWNER_PUBLIC,"GreMakeBitmapNonStock() bitmap is not public\n");
    ASSERTGDI(gStockBitmapFree != MAX_STOCKBITMAPS,"GreMakeBitmapNonStock() no stock bitmaps\n");

    if (so.bValid())
    {
        if (!(so.ps->bDIBSection()))
        {
            if (hbm==STOCKOBJ_BITMAP || !HmgStockObj(hbm))
            {
                STOCKWARNING("GreMakeBitmapNonStock: Cannot make stock bitmap (%p) non Stock\nReason:",hbm);
                if (hbm==STOCKOBJ_BITMAP)
                    STOCKWARNING(" it is the default stock bitmap\n");
                else 
                    STOCKWARNING(" it is not a stock bitmap\n");
            } 
            else
            {
                bRet = (HANDLE)((ULONG_PTR)hbm & ~GDISTOCKOBJ);

                if (so.ps->cRef())
                {
                    so.ps->vSetUndoStockSurfaceDelayed();
                    STOCKWARNING("GreMakeBitmapNonStock: Delaying make stock bitmap (%p) non Stock\n",hbm);
                }
                else if(HmgLockAndModifyHandleType((HOBJ)bRet))
                {
                    InterlockedIncrement(&gStockBitmapFree);

                    so.ps->vClearStockSurface(); 
                    so.ps->hsurf(bRet);
                    so.vSetPID(OBJECT_OWNER_CURRENT);

                 }
                 else
                 {
                     STOCKWARNING ("GreMakeBitmapNonStock - HmgLockAndModifyHandleType failed\n");
                     bRet = 0;
                 }
            }
        }
        else
        {
            WARNING ("GreMakeBitmapNonStock - DIBSECTION to set as non stock\n");
        }    
    }
    else
    {
        WARNING1("GreMakeBitmapNonStock - invalid surfobj\n");
    }

    return((HBITMAP)bRet);
}
/******************************Public*Routine******************************\
* bInitBMOBJ
*
* Initializes the default bitmap.
*
* History:
*  14-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C" BOOL bInitBMOBJ()
{
    HBITMAP hbmTemp = GreCreateBitmap(1, 1, 1, 1, (LPBYTE) NULL);

    if (hbmTemp == (HBITMAP) 0)
    {
        WARNING("Failed to create default bitmap\n");
        return(FALSE);
    }


    SURFREF so((HSURF)hbmTemp);

    ASSERTGDI(so.bValid(), "ERROR it created but isn't lockable STOCKOBJ_BITMAP");
    ASSERTGDI(so.ps->ppal() == ppalMono, "ERROR the default bitmap has no ppalMono");

    so.vSetPID(OBJECT_OWNER_PUBLIC);

    bSetStockObject(hbmTemp,PRIV_STOCK_BITMAP);
    so.ps->hsurf((HANDLE)((ULONG_PTR)hbmTemp | GDISTOCKOBJ));

    SURFACE::pdibDefault = so.ps;

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bDeleteSurface(HSURF)
*
* Delete the surface object
*
* History:
*  Sun 14-Apr-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

BOOL bDeleteSurface(HSURF hsurf)
{
    SURFREF so;

    so.vAltCheckLockIgnoreStockBit(hsurf);

    return(so.bDeleteSurface());        // bDeleteSurface() checks bValid()
}

/******************************Public*Routine******************************\
* hbmSelectBitmap
*
* Select the bitmap into a DC.  Provides option to override the
* DirectDraw surface check.
*
* History:
*  Wed 28-Aug-1991 -by- Patrick Haluptzok [patrickh]
* update it, make palette aware.
*
*  Mon 13-May-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

HBITMAP hbmSelectBitmap(HDC hdc, HBITMAP hsurf, BOOL bDirectDrawOverride)
{
    HSURF hsurfReturn = (HSURF) 0;
    BOOL  bDelete = FALSE;

    //
    // Grab multi-lock so noone can select or delete it.
    //

    MLOCKOBJ mlo;

    //
    // Lock bitmap
    //

    SURFREF  SurfBoNew;
    SurfBoNew.vMultiLock((HSURF) hsurf);

    MDCOBJ   dco(hdc);

    if (dco.bValid() && SurfBoNew.bValid())
    {
        PSURFACE pSurfNew = SurfBoNew.ps;

        ASSERTGDI(DIFFHANDLE(hsurf,STOCKOBJ_BITMAP) ||
                  (pSurfNew->cRef() == 0) , "ERROR STOCKOBJ_BITMAP cRef != 0");

        PDEVOBJ po(dco.hdev());
        PPALETTE ppalSrc;

        PROCESS_UM_TRACE(pSurfNew, FALSE);

        if ((dco.dctp() == DCTYPE_MEMORY) &&
            ((pSurfNew->cRef() == 0 || pSurfNew->bStockSurface()) || SAMEHANDLE(pSurfNew->hdc(),dco.hdc())) &&
            (bIsCompatible(&ppalSrc, pSurfNew->ppal(), pSurfNew, dco.hdev())))
        {
            //
            // Note: pSurfOld not safe outside of the MLOCKOBJ.
            //

            SURFACE *pSurfOld = dco.pSurfaceEff();

            //
            // Only DirectDraw itself may select DirectDraw surfaces
            // into, or out of, DCs.  This is because DirectDraw has
            // to track the DCs to be able to mark them as 'bInFullScreen'
            // when the corresponding DirectDraw surface is 'lost'.
            //

            if ((pSurfOld->bApiBitmap() && pSurfNew->bApiBitmap()) ||
                (bDirectDrawOverride))
            {
                //
                // If this DC is mirrored then turn the mirroring off
                // And turn it on after selecting the bitmap to set the correct
                // Window Org.
                //
                DWORD dwLayout = dco.pdc->dwLayout();
                if (dwLayout & LAYOUT_ORIENTATIONMASK)
                {
                    dco.pdc->dwSetLayout(-1 , 0);
                }
                if (pSurfNew->ppal() != ppalSrc)
                {
                    pSurfNew->flags(pSurfNew->flags() | PALETTE_SELECT_SET);
                    pSurfNew->ppal(ppalSrc);
                }
                HSURF hsurfDelete = (HSURF)
                    (pSurfOld->bLazyDelete() ? pSurfOld->hGet() : NULL);
                hsurfReturn = pSurfOld->hsurf();

                if (DIFFHANDLE((HSURF) hsurf, hsurfReturn))
                {
                    if (pSurfNew->bIsDefault())
                    {
                        dco.pdc->pSurface((SURFACE *) NULL);
                    }
                    else
                    {
                        dco.pdc->pSurface((SURFACE *) pSurfNew);

                        if (pSurfNew->bStockSurface())
                            dco.pdc->bStockBitmap(TRUE);
                        else
                            dco.pdc->bStockBitmap(FALSE);
                    }

                    dco.pdc->sizl(pSurfNew->sizl());
                    dco.pdc->ulDirtyAdd(DIRTY_BRUSHES);

                    //
                    // Lower the reference count on the old handle
                    //

                    if (!pSurfOld->bIsDefault())
                    {
                        pSurfOld->vDec_cRef();
                        if (pSurfOld->cRef() == 0)
                        {
                            //
                            // Remove reference to device palette if it has one.
                            //

                            if (pSurfOld->flags() & PALETTE_SELECT_SET)
                                pSurfOld->ppal(NULL);

                            pSurfOld->flags(pSurfOld->flags() & ~PALETTE_SELECT_SET);
                        }
                    }

                    //
                    // Device Format Bitmaps hooked by the driver must always
                    // have devlock synchronization.
                    //
                    // Other device-dependent bitmaps must have devlock
                    // synchronization if they can be affected by dynamic mode
                    // changes, because they may have to be converted on-the-fly
                    // to DIBs.
                    //

                    dco.bSynchronizeAccess(
                        (pSurfNew->bUseDevlock()) ||
                        (pSurfNew->bDeviceDependentBitmap() && po.bDisplayPDEV()));

                    dco.bShareAccess(dco.bSynchronizeAccess() && pSurfNew->bShareAccess());

                    //
                    // Put the relevant DC information into the surface as long as it's not
                    // the default surface.
                    //

                    if (!pSurfNew->bIsDefault())
                    {
                        pSurfNew->vInc_cRef();
                        if (!pSurfNew->bStockSurface())
                        {
                            pSurfNew->hdc(dco.hdc());
                            pSurfNew->hdev(dco.hdev());
                        }
                    }

                    //
                    // set DIBSection flag in DC
                    //

                    dco.pdc->vDIBSection(pSurfNew->bDIBSection());

                    //
                    // set DIBColorSpace indentifier.
                    //

                    if (pSurfNew->bDIBSection())
                    {
                        dco.pdc->dwDIBColorSpace(pSurfNew->dwDIBColorSpace());
                    }
                    else
                    {
                        dco.pdc->dwDIBColorSpace(0);
                    }

                    // Unref the SurfBoNew as we dont use pSurfNew anymore. This
                    // will also make sure any mode change logic called code 
                    // like pConvertDfbSurfaceToDib will not get
                    // tripped due to sharelocks held on the pSurfNew. 

                    SurfBoNew.vUnreference();

                    mlo.vDisable();

                    dco.pdc->bSetDefaultRegion();

                    dco.pdc->vUpdate_VisRect(dco.pdc->prgnVis());

                    if (hsurfDelete)
                    {
                        //
                        // We need one shared lock for bDeleteSurface to succeed:
                        //

                        SURFREF so(hsurfDelete);
                        so.bDeleteSurface();

                        hsurfReturn = (HSURF)STOCKOBJ_BITMAP;
                    }
                }
                //
                // If it was mirrored then turn back the mirroring on.
                //
                if (dwLayout & LAYOUT_ORIENTATIONMASK)
                {
                    dco.pdc->dwSetLayout(-1 , dwLayout);
                }
            }
            else
            {
                WARNING("hbmSelectBitmap failed, unselectable surface\n");
            }
        }
        else
        {
            WARNING1("hbmSelectBitmap failed selection, bitmap doesn't fit into DC\n");
        }
    }
    else
    {
#if DBG
        if (dco.bValid())
        {
            WARNING1("hbmSelectBitmap given invalid bitmap\n");
        }
        else
        {
            WARNING1("hbmSelectBitmap given invalid DC\n");
        }
#endif
    }

    return((HBITMAP) hsurfReturn);
}

/******************************Public*Routine******************************\
* GreSelectBitmap
*
* Select the bitmap into a DC.  User and the like will call this function.
*
\**************************************************************************/

HBITMAP GreSelectBitmap(HDC hdc, HBITMAP hsurf)
{
    return(hbmSelectBitmap(hdc, hsurf, FALSE));
}

/******************************Public*Routine******************************\
* hbmCreateClone
*
* Creates an engine managed clone of a bitmap.
*
* History:
*  Tue 17-May-1994 -by- Patrick Haluptzok [patrickh]
* Synchronize the call if it's a DFB that needs synching.
*
*  19-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HBITMAP hbmCreateClone(SURFACE *pSurfSrc, ULONG cx, ULONG cy)
{

    ASSERTGDI(pSurfSrc != NULL, "ERROR hbmCreateClone invalid src");

    ASSERTGDI((pSurfSrc->iType() == STYPE_BITMAP) ||
              (pSurfSrc->iType() == STYPE_DEVBITMAP), "ERROR hbmCreateClone src type");

    DEVBITMAPINFO dbmi;

    dbmi.iFormat = pSurfSrc->iFormat();

    if ((cx == 0) || (cy == 0))
    {
        dbmi.cxBitmap = pSurfSrc->sizl().cx;
        dbmi.cyBitmap = pSurfSrc->sizl().cy;
    }
    else
    {
        ASSERTGDI(cx <= LONG_MAX, "hbmCreateClone: cx too large\n");
        dbmi.cxBitmap = min(pSurfSrc->sizl().cx,(LONG)cx);

        ASSERTGDI(cy <= LONG_MAX, "hbmCreateClone: cy too large\n");
        dbmi.cyBitmap = min(pSurfSrc->sizl().cy,(LONG)cy);
    }

    dbmi.hpal = (HPALETTE) 0;

    if (pSurfSrc->ppal() != NULL)
    {
        dbmi.hpal = (HPALETTE) pSurfSrc->ppal()->hGet();
    }

    dbmi.fl = BMF_TOPDOWN;

    HBITMAP hbmReturn = (HBITMAP) 0;

    SURFMEM SurfDimo;

    if (SurfDimo.bCreateDIB(&dbmi, NULL))
    {
        POINTL ptlSrc;
        ptlSrc.x = 0;
        ptlSrc.y = 0;

        RECTL rclDst;
        rclDst.left  = 0;
        rclDst.right  = dbmi.cxBitmap;
        rclDst.top    = 0;
        rclDst.bottom = dbmi.cyBitmap;

        HSEMAPHORE hsemDevLock = NULL;
        PPDEV ppdev            = NULL;

        if (pSurfSrc->bUseDevlock())
        {
            PDEVOBJ po(pSurfSrc->hdev());
            ASSERTGDI(po.bValid(), "PDEV invalid");
            hsemDevLock = po.hsemDevLock();
            ppdev       = po.ppdev;
            GreAcquireSemaphoreEx(hsemDevLock, SEMORDER_DEVLOCK, NULL);
            GreEnterMonitoredSection(ppdev, WD_DEVLOCK);
        }

        if (EngCopyBits( SurfDimo.pSurfobj(),        // Destination surfobj
                         pSurfSrc->pSurfobj(),       // Source surfobj.
                         (CLIPOBJ *) NULL,           // Clip object.
                         &xloIdent,                  // Palette translation object.
                         &rclDst,                    // Destination rectangle.
                         &ptlSrc ))
        {
            SurfDimo.vKeepIt();
            hbmReturn = (HBITMAP) SurfDimo.ps->hsurf();
        }
        else
        {
            WARNING("ERROR hbmCreateClone failed EngBitBlt\n");
        }

        if (hsemDevLock)
        {
            GreExitMonitoredSection(ppdev, WD_DEVLOCK);
            GreReleaseSemaphoreEx(hsemDevLock);
        }
    }
    else
    {
        WARNING("ERROR hbmCreateClone failed DIB allocation\n");
    }

    return(hbmReturn);
}



/******************************Public*Routine******************************\
* NtGdiGetDCforBitmap
*
* Get the DC that the bitmap is selected into
*
* History:
* 12-12-94 -by- Lingyun Wang[lingyunw]
* Wrote it.
\**************************************************************************/

HDC NtGdiGetDCforBitmap(HBITMAP hsurf)
{
    HDC      hdcReturn = 0;
    SURFREF   so((HSURF) hsurf);

    if (so.bValid())
    {
        hdcReturn = so.ps->hdc();
    }

    return(hdcReturn);
}

/******************************Public*Routine******************************\
* NtGdiColorSpaceforBitmap
*
* Get the color space data for this bitmap
*
* History:
* 06-06-97 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

ULONG_PTR NtGdiGetColorSpaceforBitmap(HBITMAP hsurf)
{
    ULONG_PTR  dwReturn = 0;
    SURFREF   so((HSURF) hsurf);

    if (so.bValid() && so.ps->bDIBSection())
    {
        dwReturn = so.ps->dwDIBColorSpace();
    }

    return(dwReturn);
}

/******************************Public*Routine******************************\
* GreMakeInfoDC()
*
*   This routine is used to take a printer DC and temporarily make it a
*   Metafile DC for spooled printing.  This way it can be associated with
*   an enhanced metafile.  During this period, it should look and act just
*   like an info DC.
*
*   bSet determines if it should be set into the INFO DC state or restored
*   to the Direct state.
*
* History:
*  04-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL NtGdiMakeInfoDC(
    HDC  hdc,
    BOOL bSet)
{
    ASSERTGDI(LO_TYPE(hdc) == LO_ALTDC_TYPE,"GreMakeInfoDC - not alt type\n");

    BOOL bRet = FALSE;

    XDCOBJ dco( hdc );

    if (dco.bValid())
    {
        bRet = dco.pdc->bMakeInfoDC(bSet);
        dco.vUnlockFast();
    }

    return(bRet);
}

/******************************Private*Routine*****************************\
* BOOL pConvertDfbSurfaceToDib
*
* Converts a compatible bitmap into an engine managed bitmap.  Note that
* if the bitmap is currently selected into a DC, bConvertDfbDcToDib should
* be called.
*
* The devlock must be already be held.
*
* History:
*  Wed 5-May-1994 -by- Tom Zakrajsek [tomzak]
* Wrote it (with lots of help from PatrickH and EricK).
\*************************************************************************/

SURFACE* pConvertDfbSurfaceToDib
(
    HDEV     hdev,
    SURFACE *pSurfOld,
    LONG     ExpectedShareCount
)
{
    BOOL     b;
    SURFACE *pSurfNew;
    SURFACE *pSurfRet;

#if TEXTURE_DEMO
    if (ghdevTextureParent)
    {
        return(NULL);
    }
#endif

    pSurfRet = NULL;

    ASSERTGDI((pSurfOld != NULL),
        "pConvertDfbSurfaceToDib: pSurf attached to the DC is NULL\n");

    ASSERTGDI((pSurfOld->bRedirection() == FALSE),
        "pConvertDfbSurfaceToDib: pSurf is a redirection surface");

    //
    // GDI surfaces wrapped around DirectDraw surfaces cannot be
    // converted (DirectDraw wouldn't know about its new state).
    //
    // Similarly, we can't convert surfaces that are the primary
    // screen!
    //

    if (pSurfOld->bDirectDraw() || pSurfOld->bPDEVSurface())
    {
        return(NULL);
    }

    //
    // Create a DIB (dimoCvt) with the same height,width,
    // and BPP as the DEVBITMAP attached to the DC and
    // then replace the DEVBITMAP with the DIB
    //

    SURFMEM         dimoCvt;
    DEVBITMAPINFO   dbmi;
    ERECTL          ercl(0, 0, pSurfOld->sizl().cx, pSurfOld->sizl().cy);
    PDEVOBJ         po(hdev);

    //
    // Figure out what format the engine should use by looking at the
    // size of palette.  This is a clone from CreateCompatibleBitmap().
    //

    dbmi.iFormat    = pSurfOld->iFormat(); 
    dbmi.cxBitmap   = pSurfOld->sizl().cx;
    dbmi.cyBitmap   = pSurfOld->sizl().cy;
    dbmi.hpal       = 0;
    dbmi.fl         = BMF_TOPDOWN;

    if (dimoCvt.bCreateDIB(&dbmi, NULL))
    {
        pSurfNew = dimoCvt.ps;

        //
        // Fill in other necessary fields
        //

        ASSERTGDI(pSurfOld->hdev() == hdev, "hdev's don't match");

        pSurfNew->hdev(hdev);

        //
        // Copy the area as big as the bitmap
        //

        if ((*PPFNGET(po, CopyBits, pSurfOld->flags()))
                (
                dimoCvt.pSurfobj(),           // destination surface
                pSurfOld->pSurfobj(),         // source surface
                (CLIPOBJ *)NULL,              // clip object
                &xloIdent,                    // palette translation object
                (RECTL *) &ercl,              // destination rectangle
                (POINTL *) &ercl              // source origin
                ))
        {
            MLOCKOBJ mlo;
            LONG SurfTargShareCount;

            SurfTargShareCount = HmgQueryAltLock((HOBJ)pSurfOld->hsurf());

            if (SurfTargShareCount == ExpectedShareCount)
            {
                BOOL bStockSurface =  pSurfOld->bStockSurface();
                BOOL bUndoStockSurfaceDelayed = pSurfOld->bUndoStockSurfaceDelayed();

                if (HmgSwapLockedHandleContents((HOBJ)pSurfOld->hsurf(),
                                          SurfTargShareCount,
                                          (HOBJ)pSurfNew->hsurf(),
                                          HmgQueryAltLock((HOBJ)pSurfNew->hsurf()),
                                          SURF_TYPE))
                {
                    //
                    // Swap necessary fields between the bitmaps
                    // hsurf, hdc, cRef, hpalHint, sizlDim, ppal, SurfFlags
                    //

                    HSURF hsurfTemp = pSurfOld->hsurf();
                    pSurfOld->hsurf(pSurfNew->hsurf());
                    pSurfNew->hsurf(hsurfTemp);

                    HDC hdcTemp = pSurfOld->hdc();
                    pSurfOld->hdc(pSurfNew->hdc());
                    pSurfNew->hdc(hdcTemp);

                    ULONG cRefTemp = pSurfOld->cRef();
                    pSurfOld->cRef(pSurfNew->cRef());
                    pSurfNew->cRef(cRefTemp);

                    HPALETTE hpalTemp = pSurfOld->hpalHint();
                    pSurfOld->hpalHint(pSurfNew->hpalHint());
                    pSurfNew->hpalHint(hpalTemp);

                    SIZEL sizlTemp = pSurfOld->sizlDim();
                    pSurfOld->sizlDim(pSurfNew->sizlDim());
                    pSurfNew->sizlDim(sizlTemp);

                    PPALETTE ppalTemp = pSurfOld->ppal();
                    pSurfOld->ppal(pSurfNew->ppal());
                    pSurfNew->ppal(ppalTemp);

                    FLONG flagsTemp = pSurfOld->flags();
                    pSurfOld->flags((pSurfOld->flags() & ~SURF_FLAGS) | (pSurfNew->flags() & SURF_FLAGS));
                    pSurfNew->flags((pSurfNew->flags() & ~SURF_FLAGS) | (flagsTemp & SURF_FLAGS));

                    //
                    // Some flags have to stay with the original surface,
                    // so swap them yet again to go back to the original:
                    //

                    #define KEEP_FLAGS ENG_CREATE_DEVICE_SURFACE

                    flagsTemp = pSurfOld->flags();
                    pSurfOld->flags((pSurfOld->flags() & ~KEEP_FLAGS) | (pSurfNew->flags() & KEEP_FLAGS));
                    pSurfNew->flags((pSurfNew->flags() & ~KEEP_FLAGS) | (flagsTemp & KEEP_FLAGS));

#if TRACE_SURFACE_ALLOCS
                    // We don't care about copying the current allocation trace
                    // to the old object.
                    if (TRACED_SURFACE::bEnabled())
                    {
                        TRACED_SURFACE *ptsOld = (TRACED_SURFACE *)pSurfOld;
                        TRACED_SURFACE *ptsNew = (TRACED_SURFACE *)pSurfNew;

                        ptsNew->Trace = ptsOld->Trace;

#if TRACE_SURFACE_USER_CHAIN_IN_UM
                        // pUser values were swapped in HmgSwapLockedHandleContents.
                        // Swap them back since object owners weren't swapped.
                        // It doesn't matter if TRACED_SURFACE::bUserChainInUM
                        //  is enable, since pUser is unused if not enabled.
                        PENTRY  pEntryOld = &gpentHmgr[HmgIfromH(pSurfOld->hGet())];
                        PENTRY  pEntryNew = &gpentHmgr[HmgIfromH(pSurfNew->hGet())];
                        PVOID   pUserTemp = pEntryOld->pUser;
                        pEntryOld->pUser = pEntryNew->pUser;
                        pEntryNew->pUser = pUserTemp;
#endif
                    }
#endif

                    if (bStockSurface)
                    {
                        DC* pdc;
                        HOBJ hObj = 0;

                        pSurfOld->vClearStockSurface();
                        pSurfNew->vSetStockSurface();

                        STOCKINFO("Transfer Stock Bitmap State from %p to %p\n", pSurfOld, pSurfNew);

                        if (bUndoStockSurfaceDelayed)
                        {
                            STOCKINFO("Transfer Delayed Undo Stock Bitmap State from %p to %p\n", pSurfOld, pSurfNew);
                            pSurfNew->vSetUndoStockSurfaceDelayed();
                        }

                        // As its a Stock surface it may be selected into many DCs. Run thru all of them
                        // and replace with new .

                        while (pdc = (DC*) HmgSafeNextObjt(hObj, DC_TYPE))
                        {
                            hObj = (HOBJ)pdc->hGet();

                            if ((pdc->pSurface() == pSurfOld))
                            {
                                STOCKINFO("Updating DC (%p) which refs old stockbmp %p with new stockbmp %p\n", pdc, pSurfOld, pSurfNew);
                                pdc->flbrushAdd(DIRTY_BRUSHES);
                                pdc->pSurface(pSurfNew);

                                MDCOBJA dco((HDC)hObj);
                                LONG lNumLeft = dco.lSaveDepth();
                                HDC hdcSave = dco.hdcSave();

                                while (lNumLeft > 1)
                                {
                                    MDCOBJA dcoTmp(hdcSave);
                                    if (dcoTmp.pSurface() == pSurfOld)
                                    {
                                        dcoTmp.pdc->pSurface(pSurfNew);
                                    }
                                    lNumLeft = dcoTmp.lSaveDepth();
                                    hdcSave = dcoTmp.hdcSave();
                                }
                            }
                        }
		    }
                    //
                    // Destroy the DFB
                    //
                    // If the deletion fails, we're toast, since a bad,
                    // stale surface will have been left in the handle
                    // table.  So on the next mode-change, when we walk
                    // the table looking at all surfaces belonging to
                    // this HDEV, we'd crash.
                    //

                    mlo.vDisable();
                    b = pSurfOld->bDeleteSurface();
                    ASSERTGDI(b, "A bad surface is left in handle table");

                    //
                    // Keep a reference to the new surface.
                    //

                    dimoCvt.vKeepIt();
                    dimoCvt.ps = NULL;

                    pSurfRet = pSurfNew;
                }
                else
                {
                    WARNING("pConvertDfbSurfaceToDib failed to swap bitmap handles\n");
                }
            }
            else
            {
                WARNING("pConvertDfbSurfaceToDib someone else is holding a lock\n");
            }
        }
        else
        {
            WARNING("pConvertDfbSurfaceToDib failed copying DFB to DIB\n");
        }
    }

    return(pSurfRet);
}

/******************************Private*Routine*****************************\
* BOOL bConvertDfbDcToDib
*
* Converts a compatible bitmap that is currently selected into a DC
* into an engine managed bitmap.
*
* The Devlock must already be held.  Some sort of lock must also be held
* to prevent SaveDC/RestoreDC operations from occuring -- either via an
* exclusive DC lock or some other lock.
*
* History:
*  Wed 5-May-1994 -by- Tom Zakrajsek [tomzak]
* Wrote it (with lot's of help from PatrickH and EricK).
\*************************************************************************/

BOOL bConvertDfbDcToDib
(
    XDCOBJ * pdco
)
{
    SURFACE *pSurfOld;
    SURFACE *pSurfNew;

    ASSERTDEVLOCK(pdco->pdc);

    pSurfOld = pdco->pSurface();
    pSurfNew = pConvertDfbSurfaceToDib(pdco->hdev(),
                                       pSurfOld,
                                       pSurfOld->cRef());

    if (pSurfNew)
    {
        //
        // Make sure that the surface pointers in any EBRUSHOBJ's get
        // updated, by ensuring that vInitBrush() gets called the next
        // time any brush is used in this DC.
        //

        pdco->pdc->flbrushAdd(DIRTY_BRUSHES);

        //
        // Replace the pSurf reference in the DCLEVEL
        //

        pdco->pdc->pSurface(pSurfNew);

        //
        // Walk the saved DC chain
        //

        LONG lNumLeft = pdco->lSaveDepth();
        HDC  hdcSave = pdco->hdcSave();

        while (lNumLeft > 1)
        {
            MDCOBJA dcoTmp(hdcSave);

            //
            // Replace all references to pSurfOld with references to pSurfNew
            //

            if (dcoTmp.pSurface() == pSurfOld)
            {
                dcoTmp.pdc->pSurface(pSurfNew);
            }

            lNumLeft = dcoTmp.lSaveDepth();
            hdcSave = dcoTmp.hdcSave();
        }
    }

    return(pSurfNew != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\surfgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: surfgdi.cxx
*
* This file contains the bitmap creation functions
*
* Created: 14-Jun-1991 17:05:47
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

BOOL bDoGetSetBitmapBits(SURFOBJ *, SURFOBJ *, BOOL);

/******************************Public*Routine******************************\
* HBITMAP GreCreateBitmap
*
* API Entry point to create a bitmap.
*
* Returns: Handle to bitmap for success
*
* History:
*  Wed 23-Jan-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

HBITMAP APIENTRY GreCreateBitmap(
    int cx,
    int cy,
    UINT cPlanes,
    UINT cBits,
    LPBYTE pvBits
    )
{
    //
    // Try to guess what format the user wanted.  We will always guarantee
    // enough space in the bitmap for the info.  Note that if either cPlanes
    // or cBits is zero, a monochrome bitmap will be created.
    //

    ULONG iFormat = cPlanes * cBits;
    
    //
    // Validate the width, height, planes, and bits
    //

    if ((cx <= 0) ||
        (cx > MAX_SURF_WIDTH) ||
        (cy <= 0) ||
        (cPlanes > 32) ||
        (cBits   > 32) ||
        (iFormat > 32))
    {
        WARNING("GreCreateBitmap failed - parameter too big");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HBITMAP) 0);
    }

    ULONG       cjScanBytes = (((((ULONG) cx * iFormat) + 15) >> 4) << 1);
    ULONGLONG   cjTotal =  (ULONGLONG) cjScanBytes * (ULONGLONG) cy;

    // BUGFIX #172774 12-12-2000 bhouse
    //
    // NOTE: Is there a better way to detect overflow then to use ULONGLONG?
    //       I vaguely recall that if for unsigned values r = a * b
    //       then an overflow occured if either r < a || r < b

    if(cjTotal  > ULONG_MAX)
    {
        WARNING("GreCreateBitmap failed - size too big");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HBITMAP) 0);
    }


    //
    // This if-else loop can be simplified and made smaller but until we get
    // this right let's leave it like this so it's easy to change.
    //

    DEVBITMAPINFO dbmi;
    dbmi.cxBitmap   = cx;
    dbmi.cyBitmap   = cy;
    dbmi.hpal       = (HPALETTE) 0;
    dbmi.fl         = BMF_TOPDOWN;

    if (iFormat <= 1)
    {
        //
        // A monochrome bitmap has a fixed palette.  The 0 (black) is always
        // mapped to foreground, the 1 is always mapped to background (white).
        //

        iFormat = BMF_1BPP;
        dbmi.hpal = hpalMono;
    }
    else if (iFormat <= 4)
    {
        iFormat = BMF_4BPP;
    }
    else if (iFormat <= 8)
    {
        iFormat = BMF_8BPP;
    }
    else if (iFormat <= 16)
    {
        iFormat = BMF_16BPP;
    }
    else if (iFormat <= 24)
    {
        iFormat = BMF_24BPP;
    }
    else if (iFormat <= 32)
    {
        iFormat = BMF_32BPP;
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HBITMAP) 0);
    }

    dbmi.iFormat = iFormat;

    SURFMEM SurfDimo;

    SurfDimo.bCreateDIB(&dbmi, NULL);

    if (!SurfDimo.bValid())
    {
        WARNING("Failed surface memory alloc in GreCreateBitmap\n");
        return((HBITMAP) 0);
    }

    SurfDimo.ps->vSetApiBitmap();

    if (pvBits != (LPBYTE) NULL)
    {
        //
        // Initialize the bitmap.
        //

        ULONG   cColors;
        cColors = 0;
        GreSetBitmapBits((HBITMAP)SurfDimo.ps->hsurf(), (ULONG) cjTotal,
                         (PBYTE) pvBits, (LONG *) &cColors);
    }

    //
    // Monochrome bitmaps are not considered to be DDBs:
    //

    if (iFormat != BMF_1BPP)
    {
        SurfDimo.ps->vSetDeviceDependentBitmap();
    }

    SurfDimo.vKeepIt();
    GreSetBitmapOwner((HBITMAP) SurfDimo.ps->hsurf(), OBJECT_OWNER_CURRENT);
    return((HBITMAP) SurfDimo.ps->hsurf());
}

/******************************Public*Routine******************************\
* HSURF hsurfCreateCompatibleSurface(hdev,cx,cy,bDriver)
*
* Low-level GDI interface for creating a compatible surface, possibly
* hooked by the driver.
*
\**************************************************************************/

HSURF hsurfCreateCompatibleSurface(
    HDEV hdev,
    ULONG iFormat,
    HPALETTE hpal,
    int cx,
    int cy,
    BOOL bDriverCreatible
    )
{
    PDEVOBJ po(hdev);

    po.vAssertDevLock();

    //
    // Fill in the desired bitmap properties
    //

    DEVBITMAPINFO   dbmi;
    dbmi.cxBitmap   = cx;
    dbmi.cyBitmap   = cy;
    dbmi.hpal       = hpal;
    dbmi.iFormat    = iFormat;
    dbmi.fl         = BMF_TOPDOWN;

    if (po.bUMPD())
    {
        dbmi.fl |= UMPD_SURFACE;
    }

    //
    // See if the device driver will manage the bitmap.
    //

    if ((bDriverCreatible) &&
        (PPFNVALID(po,CreateDeviceBitmap)))
    {
        //
        // Ok the device exports the entry point.  Let's call him up.
        //

        HSURF   hsurf;

        SIZEL sizlTemp;
        sizlTemp.cx = cx;
        sizlTemp.cy = cy;

        hsurf = (HSURF) (*PPFNDRV(po,CreateDeviceBitmap))(po.dhpdev(),
                                                          sizlTemp,
                                                          dbmi.iFormat);

        if (hsurf && (LongToHandle(HandleToLong(hsurf)) != (HANDLE)-1))
        {
            SURFREF so(hsurf);
            ASSERTGDI(so.bValid(), "ERROR device gave back invalid handle");

            //
            // Device Format Bitmaps (DFBs) are a subset of Device
            // Depdendent Bitmaps (DDBs):
            //

            so.ps->vSetDeviceDependentBitmap();
            so.ps->vSetApiBitmap();

            //
            // DFBs must always be accessed under the devlock, in part
            // because they have to be deleted and recreated when a
            // dynamic mode change occurs.
            //

            so.ps->vSetUseDevlock();

            if (dbmi.hpal != (HPALETTE) 0)
            {
                EPALOBJ palSurf(dbmi.hpal);
                ASSERTGDI(palSurf.bValid(), "ERROR invalid palette CreateCompatibleBitmap");

                //
                // Set palette into surface.
                //

                so.ps->ppal(palSurf.ppalGet());

                //
                // Reference count it by making sure it is not unlocked.
                //

                palSurf.ppalSet((PPALETTE) NULL);  // It won't be unlocked
            }

            //
            // Zero memory by sending a bitblt command to device
            //

            RECTL rclDst;

            rclDst.left   = 0;
            rclDst.top    = 0;
            rclDst.right  = cx;
            rclDst.bottom = cy;

            (*(so.ps->pfnBitBlt()))(
                            so.pSurfobj(),
                            (SURFOBJ *)NULL,
                            (SURFOBJ *)NULL,
                            (CLIPOBJ *)NULL,
                            NULL,
                            &rclDst,
                            (POINTL *)NULL,
                            (POINTL *)NULL,
                            (EBRUSHOBJ *)NULL,
                            (POINTL *)NULL,
                            0x0);

            return(hsurf);
        }
    }

    SURFMEM SurfDimo;

    SurfDimo.bCreateDIB(&dbmi, (PVOID) NULL);

    if (!SurfDimo.bValid())
    {
        return(0);
    }

    //
    // Mark the bitmap a keeper.
    //

    SurfDimo.vKeepIt();
    SurfDimo.ps->vSetDeviceDependentBitmap();
    SurfDimo.ps->vSetApiBitmap();
    SurfDimo.ps->hdev(po.hdev());
    return(SurfDimo.ps->hsurf());
}

/******************************Public*Routine******************************\
* HBITMAP GreCreateCompatibleBitmap(hdc,cx,cy)
*
* GDI Interface routine to create a bitmap.
*
* History:
*  Mon 06-Nov-1995 -by- Tom Zakrajsek [tomzak]
* Add overflow checking for cx*cy.
*
*  Mon 01-Jun-1992 -by- Patrick Haluptzok [patrickh]
* Add IC support.
*
*  Fri 25-Jan-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

HBITMAP APIENTRY GreCreateCompatibleBitmap(HDC hdc, int cx, int cy)
{
    BOOL bDriver;
    HSURF hsurf;
    HPALETTE hpal;
    ULONG iFormat;

    bDriver = TRUE;
    if (cy & CCB_NOVIDEOMEMORY)
    {
        cy &= ~CCB_NOVIDEOMEMORY;
        bDriver = FALSE;
    }

    //
    // Validate the width and height
    //

    if ((cx <= 0) || (cy <= 0))
    {
        WARNING("GreCreateCompatibleBitmap failed - cx or cy was <= 0\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HBITMAP) 0);
    }

    
    ULONGLONG   cjTotal =  (ULONGLONG) cx * (ULONGLONG) cy;

    //
    // Assume worse case (32bpp pixels) and calculate possible overflow condition
    //
    // BUGFIX #172447 12-12-2000 bhouse
    //
    // NOTE: Tom Zakrajsek added a fairly restrictive checking of cx/cy in 1995
    //       and we have modified this check to be less restrictive.  It appears the
    //       check was to avoid potential numeric overflow when cx and cy are multiplied
    //       together with bytes per pixel.  It is kinda goofy to have this check
    //       here though as the possible overflow does not even occur in this
    //       routine but farther down in the call stack.  We will leave the modified
    //       check here to avoid introducing a possible regression.
    //

    if(cjTotal  > (ULONG_MAX >> 2))
    {
        WARNING("GreCreateCompatibleBitmap failed - size too big");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HBITMAP) 0);
    }

    //
    // Without an hdc we create a monochrome bitmap.
    //

    if (hdc == (HDC) NULL)
        return(GreCreateBitmap(cx, cy, 1, 1, (LPBYTE) NULL));

    //
    // Ok lock down the hdc and the surface.
    //

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        WARNING("CreateCompatibleBitmap failed - invalid hdc\n");
        return((HBITMAP) 0);
    }

    //
    // NOTE:  Even though we touch the SURFOBJ, we actually aren't going to read
    // or write it.  We just need some of its information.
    //

    PDEVOBJ po(dco.hdev());

    //
    // We must hold a lock to protect against the dynamic mode change
    // code and to synchronize access to the drivers.
    //

    {
        DEVLOCKOBJ dlo(po);

        PSURFACE pSurf = dco.pSurfaceEff();

        hpal = 0;

        if (dco.dctp() == DCTYPE_MEMORY)
        {
            iFormat = pSurf->iFormat();

            if (pSurf->ppal() != NULL)
            {
                hpal = (HPALETTE) pSurf->ppal()->hGet();
            }
        }
        else
        {
            iFormat = po.iDitherFormat();

            if (!po.bIsPalManaged())
            {
                hpal = (HPALETTE) po.ppalSurf()->hGet();
            }
        }

        hsurf = hsurfCreateCompatibleSurface(dco.hdev(),
                                             iFormat,
                                             hpal,
                                             cx,
                                             cy,
                                             bDriver);
    }

    GreSetBitmapOwner((HBITMAP) hsurf, OBJECT_OWNER_CURRENT);

    return((HBITMAP) hsurf);
}

/******************************Public*Routine******************************\
* GreSetBitmapBits
*
* Does the work for SetBitmapBits.
*
* History:
*  19-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

LONG
GreSetBitmapBits(
    HBITMAP hbm,
    ULONG cjTotal,
    PBYTE pjBuffer,
    PLONG pOffset
    )
{

    if (cjTotal == 0)
    {
        return(0);
    }

    LONG lReturn = 0;

    SURFREF  SurfBmo((HSURF) hbm);
    SURFMEM  SurfDimo;
    PSURFACE pSurf;

    pSurf = SurfBmo.ps;

    if (SurfBmo.bValid() && SurfBmo.ps->bApiBitmap())
    {
        LONG lInitOffset = *pOffset;
        SURFOBJ soTemp;
        ERECTL erclDst;
        POINTL ptlSrc;

        soTemp.dhsurf        = 0;
        soTemp.hsurf         = 0;
        soTemp.dhpdev        = SurfBmo.ps->dhpdev();
        soTemp.hdev          = SurfBmo.ps->hdev();
        soTemp.sizlBitmap.cx = SurfBmo.ps->sizl().cx;
        soTemp.sizlBitmap.cy = SurfBmo.ps->sizl().cy;
        soTemp.cjBits        = cjTotal;
        soTemp.pvBits        = pjBuffer;
        soTemp.pvScan0       = 0;
        soTemp.lDelta        = lInitOffset;
        soTemp.iUniq         = 0;
        soTemp.iType         = (USHORT) STYPE_BITMAP;
        soTemp.fjBitmap      = 0;

        ptlSrc.x = 0;
        ptlSrc.y = 0;
        erclDst.left = 0;
        erclDst.top  = 0;
        erclDst.right  = SurfBmo.ps->sizl().cx;
        erclDst.bottom = SurfBmo.ps->sizl().cy;

        HSEMAPHORE hsemDevLock = NULL;
        PPDEV ppdev            = NULL;

        if (SurfBmo.ps->bUseDevlock())
        {
            PDEVOBJ po(SurfBmo.ps->hdev());
            ASSERTGDI(po.bValid(), "PDEV invalid");
            hsemDevLock = po.hsemDevLock();
            ppdev       = po.ppdev;
            GreAcquireSemaphoreEx(hsemDevLock, SEMORDER_DEVLOCK, NULL);
            GreEnterMonitoredSection(ppdev, WD_DEVLOCK);
        }

        if (SurfBmo.ps->iType() == STYPE_DEVBITMAP)
        {
            DEVBITMAPINFO   dbmi;

            dbmi.iFormat    = SurfBmo.ps->iFormat();
            dbmi.cxBitmap   = SurfBmo.ps->sizl().cx;
            dbmi.cyBitmap   = SurfBmo.ps->sizl().cy;
            dbmi.hpal       = 0;
            dbmi.fl         = SurfBmo.ps->bUMPD() ? UMPD_SURFACE : 0;

            //
            // Create a DIB (SurfDimo) with the same height,width,
            // and BPP as the DEVBITMAP passed in
            //

            if (!SurfDimo.bCreateDIB(&dbmi,NULL))
            {
                WARNING("GreSetBitmapBits failed bCreateDIB\n");
                lInitOffset = -1;  // This is to make us fail the call below.
            }
            else
            {
                pSurf = SurfDimo.ps;

                //
                // We don't need to copy if the offset is 0 because either
                // it's a 1 shot set that inits the whole thing, or else
                // it's the first of a batch.  In either case anything
                // that's there before doesn't need to be saved because
                // it will all be over-written when we are done.
                //

                if (lInitOffset != 0)
                {
                    BOOL bCopyRet = EngCopyBits
                                    (
                                        pSurf->pSurfobj(),
                                        SurfBmo.pSurfobj(),
                                        NULL,
                                        NULL,
                                        &erclDst,
                                        &ptlSrc
                                    );

                    ASSERTGDI(bCopyRet, "ERROR how can this fail ?");
                }
            }
        }

        //
        // Check for invalid initial offset.
        //

        if (lInitOffset >= 0)
        {
            PDEVOBJ po(SurfBmo.ps->hdev());

            //
            // Inc the target surface uniqueness
            //

            INC_SURF_UNIQ(SurfBmo.ps);

            //
            // Copy the buffer to the DIB
            //

            BOOL bReturn = bDoGetSetBitmapBits(pSurf->pSurfobj(),&soTemp,FALSE);

            ASSERTGDI(bReturn, "GreSetBitmapBits failed bDoGetSetBitmapBits\n");

            lReturn = soTemp.cjBits;
            *pOffset = lInitOffset + lReturn;

            if (SurfBmo.ps->iType() == STYPE_DEVBITMAP)
            {
                //
                // Have the driver copy the temp DIB to the DEVBITMAP
                //

                if (!((*PPFNGET(po,CopyBits,SurfBmo.ps->flags())) (
                        SurfBmo.pSurfobj(),
                        pSurf->pSurfobj(),
                        NULL,
                        NULL,
                        &erclDst,
                        &ptlSrc)))
                {
                    WARNING("GreSetBitmapBits failed copying temp DIB to DFB\n");
                    lReturn = 0;
                }
            }
        }

        if (hsemDevLock)
        {
            GreExitMonitoredSection(ppdev, WD_DEVLOCK);
            GreReleaseSemaphoreEx(hsemDevLock);
        }
    }
    else
    {
       WARNING("GreSetBitmapBits failed - invalid bitmap handle\n");
       SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(lReturn);
}

/******************************Public*Routine******************************\
* GreGetBitmapBits
*
* Does the work for GetBitmapBits
*
* Returns: Number of bytes copied, or if pjBuffer is NULL the total size of
*          the bitmap.
*
* History:
*  Mon 01-Jun-1992 -by- Patrick Haluptzok [patrickh]
* Return bitmap scanlines in BMF_TOPDOWN organization.
*
*  22-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

LONG GreGetBitmapBits(HBITMAP hbm, ULONG cjTotal, PBYTE pjBuffer, PLONG pOffset)
{

    LONG lReturn = 0;

    SURFREF SurfBmo((HSURF) hbm);

    if (SurfBmo.bValid() && SurfBmo.ps->bApiBitmap())
    {
        SURFMEM SurfDimo;
        SURFACE *pSurf;
        PDEVOBJ pdo(SurfBmo.ps->hdev());

        pSurf = SurfBmo.ps;

        lReturn = ((((gaulConvert[SurfBmo.ps->iFormat()] * SurfBmo.ps->sizl().cx) + 15) >> 4) << 1) * SurfBmo.ps->sizl().cy;

        if (pjBuffer != (PBYTE) NULL)
        {
            SURFOBJ soTemp;
            ERECTL erclDst;
            POINTL ptlSrc;

            soTemp.dhsurf        = 0;
            soTemp.hsurf         = 0;
            soTemp.dhpdev        = SurfBmo.ps->dhpdev();
            soTemp.hdev          = SurfBmo.ps->hdev();
            soTemp.sizlBitmap.cx = SurfBmo.ps->sizl().cx;
            soTemp.sizlBitmap.cy = SurfBmo.ps->sizl().cy;
            soTemp.cjBits        = 0;
            soTemp.pvBits        = 0;
            soTemp.pvScan0       = 0;
            soTemp.lDelta        = 0;
            soTemp.iUniq         = 0;
            soTemp.iType         = (USHORT) STYPE_BITMAP;
            soTemp.fjBitmap      = 0;

            ptlSrc.x = 0;
            ptlSrc.y = 0;
            erclDst.left = 0;
            erclDst.top  = 0;
            erclDst.right  = SurfBmo.ps->sizl().cx;
            erclDst.bottom = SurfBmo.ps->sizl().cy;

            HSEMAPHORE hsemDevLock = NULL;
            PPDEV ppdev            = NULL;
            
            if (SurfBmo.ps->bUseDevlock())
            {
                PDEVOBJ po(SurfBmo.ps->hdev());
                ASSERTGDI(po.bValid(), "PDEV invalid");
                hsemDevLock = po.hsemDevLock();
                ppdev       = po.ppdev;
                GreAcquireSemaphoreEx(hsemDevLock, SEMORDER_DEVLOCK, NULL);
                GreEnterMonitoredSection(ppdev, WD_DEVLOCK);
            }

            if (SurfBmo.ps->iType() == STYPE_DEVBITMAP)
            {
                //
                // Create a DIB (SurfDimo) with the same height,width,
                // and BPP as the DEVBITMAP passed in
                //

                DEVBITMAPINFO   dbmi;

                dbmi.iFormat    = SurfBmo.ps->iFormat();
                dbmi.cxBitmap   = SurfBmo.ps->sizl().cx;
                dbmi.cyBitmap   = SurfBmo.ps->sizl().cy;
                dbmi.hpal     = 0;
                dbmi.fl       = SurfBmo.ps->bUMPD() ? UMPD_SURFACE : 0;

                if (!SurfDimo.bCreateDIB(&dbmi,NULL))
                {
                    WARNING("GreGetBitmapBits failed bCreateDIB\n");
                    lReturn = 0;
                }
                else
                {
                    pSurf = SurfDimo.ps;

                    EngCopyBits(pSurf->pSurfobj(),
                                SurfBmo.pSurfobj(),
                                NULL,
                                NULL,
                                &erclDst,
                                &ptlSrc);
                }
            }

            if (lReturn)
            {
                //
                // We know how big the buffer needs to be.  Set up the
                // soTemp so the driver knows how much to fill in.
                //

                ULONG cjMaxLength = lReturn;
                LONG lInitOffset = *pOffset;

                //
                // Check for invalid initial offset.
                //

                if ((lInitOffset >= 0) && ((ULONG)lInitOffset < cjMaxLength))
                {
                    //
                    // Make cjTotal valid range.
                    //

                    if ((lInitOffset + cjTotal) > cjMaxLength)
                    {
                        cjTotal = cjMaxLength - lInitOffset;
                    }

                    if (cjTotal > 0)
                    {

                        //
                        // Fill in our return values, we know them already.
                        //

                        soTemp.cjBits = cjTotal;
                        soTemp.lDelta = lInitOffset;
                        soTemp.pvBits = pjBuffer;

                        BOOL bReturn = bDoGetSetBitmapBits(&soTemp,pSurf->pSurfobj(),TRUE);

                        ASSERTGDI(bReturn, "GreGetBitmapBits failed bDoGetSetBitmapBits\n");

                        lReturn = soTemp.cjBits;
                        *pOffset = lInitOffset + lReturn;
                    }
                    else
                    {
                        WARNING("GreGetBitmapBits failed cjTotal 0\n");
                        lReturn = 0;
                    }
                }
                else
                {
                    WARNING("GreGetBitmapBits failed lInitOffset invalid\n");
                    lReturn = 0;
                }
            }

            if (hsemDevLock)
            {
                GreExitMonitoredSection(ppdev, WD_DEVLOCK);
                GreReleaseSemaphoreEx(hsemDevLock);
            }
        }
    }
    else
    {
        WARNING("GreGetBitmapBits failed - invalid bitmap handle\n");

        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(lReturn);
}

/******************************Public*Routine******************************\
* bDoGetSetBitmapBits
*
* Does the get or set of bitmap bits for EngCopyBits.
*
* History:
*  16-Mar-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL bDoGetSetBitmapBits(SURFOBJ *psoDst, SURFOBJ *psoSrc, BOOL bGetBits)
{

    ASSERTGDI(psoDst->iType == STYPE_BITMAP, "ERROR no DIB dst");
    ASSERTGDI(psoSrc->iType == STYPE_BITMAP, "ERROR no DIB src");

    //
    // Synchronize with the device driver before touching the device surface.
    //

    if (bGetBits)
    {
        //
        // Doing a GetBitmapBits.
        //

        PSURFACE pSurfSrc =  SURFOBJ_TO_SURFACE(psoSrc);

        {
            PDEVOBJ po(psoSrc->hdev);
            po.vSync(psoSrc,NULL,0);
        }

        if (psoDst->pvBits == NULL)
        {
            psoDst->cjBits = ((((gaulConvert[psoSrc->iBitmapFormat] * psoSrc->sizlBitmap.cx) + 15) >> 4) << 1) * psoSrc->sizlBitmap.cy;
        }
        else
        {
            //
            // Initialize temporaries.
            //

            PBYTE pjBuffer = (PBYTE) psoDst->pvBits;
            PBYTE pjBitmap = (PBYTE) psoSrc->pvScan0;
            LONG lDeltaBitmap  = psoSrc->lDelta;
            ULONG cjScanBitmap = pSurfSrc->cjScan();

            ASSERTGDI(pjBuffer != NULL, "ERROR pjBuffer is NULL");
            ASSERTGDI(pjBitmap != NULL, "ERROR pjBitmap is NULL");

            //
            // Get the WORD aligned width of the input scanlines.
            //

            ULONG cjScanInput = ((((gaulConvert[psoSrc->iBitmapFormat] * psoSrc->sizlBitmap.cx) + 15) >> 4) << 1);
            ULONG cjMaxLength = cjScanInput * psoSrc->sizlBitmap.cy;
            LONG lInitOffset = psoDst->lDelta;
            ULONG cjTotal = psoDst->cjBits;

            //
            // Check for invalid initial offset.
            //

            if ((lInitOffset < 0) || ((ULONG)lInitOffset >= cjMaxLength))
            {
                psoDst->cjBits = 0;
                return(FALSE);
            }

            //
            // Make cjTotal valid range.
            //

            if (lInitOffset + cjTotal > cjMaxLength)
            {
                cjTotal = cjMaxLength - lInitOffset;
            }

            //
            // Fill in our return values.
            //

            psoDst->cjBits = cjTotal;

            //
            // Move pointer to current scanline in bitmap.
            //

            pjBitmap += ((lInitOffset / cjScanInput) * lDeltaBitmap);

            ULONG ulTemp,ulCopy;

            //
            // Move partial scan if necesary.
            //

            ulTemp = (lInitOffset % cjScanInput);

            if (ulTemp)
            {
                ulCopy = MIN((cjScanInput - ulTemp), cjTotal);

                RtlCopyMemory((PVOID) pjBuffer, (PVOID) (pjBitmap + ulTemp), (unsigned int) ulCopy);

                pjBuffer += ulCopy;
                pjBitmap += lDeltaBitmap;
                cjTotal  -= ulCopy;
            }

            //
            // Move as many scans that fit.
            //

            ulTemp = cjTotal / cjScanInput;
            cjTotal -= (ulTemp * cjScanInput);

            while (ulTemp--)
            {
                RtlCopyMemory((PVOID) pjBuffer, (PVOID) pjBitmap, (unsigned int) cjScanInput);

                pjBuffer += cjScanInput;
                pjBitmap += lDeltaBitmap;
            }

            //
            // Move as much of partial scan as possible.
            //

            if (cjTotal)
            {
                RtlCopyMemory((PVOID) pjBuffer, (PVOID) pjBitmap, (unsigned int) cjTotal);
            }
        }
    }
    else
    {

        //
        // Doing a SetBitmapBits call.
        //

        PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);

        {
            PDEVOBJ po(psoDst->hdev);
            po.vSync(psoDst,NULL,0);
        }

        //
        // Initialize temporaries.
        //

        PBYTE pjBuffer = (PBYTE) psoSrc->pvBits;
        PBYTE pjBitmap = (PBYTE) psoDst->pvScan0;
        LONG lDeltaBitmap = psoDst->lDelta;
        ULONG cjScanBitmap = pSurfDst->cjScan();

        //
        // Get the WORD aligned width of the input scanlines.
        //

        ULONG cjScanInput = ((((gaulConvert[psoDst->iBitmapFormat] * psoDst->sizlBitmap.cx) + 15) >> 4) << 1);
        ULONG cjMaxLength = cjScanInput * psoDst->sizlBitmap.cy;
        LONG lInitOffset = psoSrc->lDelta;
        ULONG cjTotal = psoSrc->cjBits;

        //
        // Check for invalid initial offset.
        //

        if ((lInitOffset < 0) || ((ULONG)lInitOffset >= cjMaxLength))
        {
            psoSrc->cjBits = 0;
            return(TRUE);
        }

        //
        // Make cjTotal valid range.
        //

        if (lInitOffset + cjTotal > cjMaxLength)
        {
            cjTotal = cjMaxLength - lInitOffset;
        }

        //
        // Fill in our return values, we know them already.
        //

        psoSrc->cjBits = cjTotal;

        //
        // Move pointer to current scanline in bitmap.
        //

        pjBitmap += ((lInitOffset / cjScanInput) * lDeltaBitmap);

        ULONG ulTemp,ulCopy;

        //
        // Move partial scan if necesary.
        //

        ulTemp = (lInitOffset % cjScanInput);

        if (ulTemp)
        {
            ulCopy = MIN((cjScanInput - ulTemp), cjTotal);

            RtlCopyMemory((PVOID) (pjBitmap + ulTemp), (PVOID) pjBuffer, (unsigned int) ulCopy);

            pjBuffer += ulCopy;
            pjBitmap += lDeltaBitmap;
            cjTotal  -= ulCopy;
        }

        //
        // Move as many scans that fit.
        //

        ulTemp = cjTotal / cjScanInput;
        cjTotal -= (ulTemp * cjScanInput);

        while (ulTemp--)
        {
            RtlCopyMemory((PVOID) pjBitmap, (PVOID) pjBuffer, (unsigned int) cjScanInput);

            pjBuffer += cjScanInput;
            pjBitmap += lDeltaBitmap;
        }

        //
        // Move as much of partial scan as possible.
        //

        if (cjTotal)
        {
            RtlCopyMemory((PVOID) pjBitmap, (PVOID) pjBuffer, (unsigned int) cjTotal);
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\textgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: textgdi.cxx
*
* Text APIs for NT graphics engine
*
* Created: 18-Dec-1990 10:09:19
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"


EFLOAT efCos(EFLOAT x);
EFLOAT efSin(EFLOAT x);

extern PBRUSH gpbrText;
extern PBRUSH gpbrBackground;

#define XFORMNULL (EXFORMOBJ *) NULL

// This is a tiny class just to make sure we don't forget to free up any
// objects before leaving ExtTextOut.

class TXTCLEANUP
{
    XDCOBJ *pdco;
public:
    TXTCLEANUP()                   {pdco=(DCOBJ *) NULL;}
   ~TXTCLEANUP()                   {if (pdco != (DCOBJ *) NULL) vMopUp();}
    VOID vSet(XDCOBJ& dco)         {pdco = &dco;}
    VOID vMopUp();
};

VOID TXTCLEANUP::vMopUp()
{
    RGNOBJ ro(pdco->pdc->prgnAPI());
    ro.bDeleteRGNOBJ();
    pdco->pdc->prgnAPI(NULL);
}

// Helper routine to draw a device coordinate RECTL into a path.

BOOL bAddRectToPath(EPATHOBJ& po,RECTL *prcl)
{
    POINTFIX aptfx[4];

    aptfx[3].x = aptfx[0].x = LTOFX(prcl->left);
    aptfx[1].y = aptfx[0].y = LTOFX(prcl->top);
    aptfx[2].x = aptfx[1].x = LTOFX(prcl->right);
    aptfx[3].y = aptfx[2].y = LTOFX(prcl->bottom);

    return(po.bAddPolygon(XFORMNULL,(POINTL *) aptfx,4));
}


/******************************Public*Routine******************************\
* GreExtTextOutRect: Wrapper for common GreExtTextOutW code. This routine just
* acquires locks then calls GreExtTextOutWLocked
*
* Arguments:
*
*    Same as ExtTextOutRect
*
* Return Value:
*
*    BOOL States
*
* History:
*
*    30-Oct-1995 - Initial version of wrapper
*
\**************************************************************************/


BOOL
GreExtTextOutRect(
    HDC     hdc,
    LPRECT  prcl
    )
{
    BOOL bRet = FALSE;

    //
    // call GreExtTextOutW
    //

    XDCOBJ dcoDst(hdc);

    //
    // Validate the destination DC.
    //

    if (dcoDst.bValid())
    {
        DEVLOCKOBJ dlo;

        if (dlo.bLock(dcoDst))
        {
            if ((!dcoDst.bDisplay() || dcoDst.bRedirection()) || UserScreenAccessCheck())
            {
                bRet = ExtTextOutRect(
                               dcoDst,
                               prcl);
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
            }
        }
        else
        {
            bRet = dcoDst.bFullScreen();
        }

        dcoDst.vUnlock();
    }
    return(bRet);
}

/******************************Public*Routine******************************\
* ExtTextOutRect
*
* Called when just a Rectangle is passed.  Over-used by Winbench4.0 the
* perf app we aim to please.
*
* History:
*  02-Nov-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
ExtTextOutRect(
    XDCOBJ    &dcoDst,
    LPRECT prcl
    )
{
// Assume failure.

    BOOL bReturn;

// Validate the destination DC.

    if (dcoDst.bValid())
    {
        ASSERTGDI(prcl != NULL, "This API must be past a valid rect");

        EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);

        if (!xoDst.bRotation())
        {
            ERECTL erclDst(prcl->left, prcl->top, prcl->right, prcl->bottom);
            xoDst.bXform(erclDst);
            erclDst.vOrder();

            if (!erclDst.bEmpty())
            {
            // Accumulate bounds.  We can do this before knowing if the operation is
            // successful because bounds can be loose.

                if (dcoDst.fjAccum())
                    dcoDst.vAccumulate(erclDst);

            // Check surface is included in DC.

                SURFACE *pSurfDst = dcoDst.pSurface();

                if (pSurfDst != NULL)
                {
                // With a fixed DC origin we can change the destination to SCREEN coordinates.

                    erclDst += dcoDst.eptlOrigin();

                    ECLIPOBJ *pco = NULL;

                // This is a pretty knarly expression to save a return in here.
                // Basically pco can be NULL if the rect is completely in the
                // cached rect in the DC or if we set up a clip object that isn't empty.

                    if (((erclDst.left   >= dcoDst.prclClip()->left) &&
                         (erclDst.right  <= dcoDst.prclClip()->right) &&
                         (erclDst.top    >= dcoDst.prclClip()->top) &&
                         (erclDst.bottom <= dcoDst.prclClip()->bottom)) ||
                        (pco = dcoDst.pco(),
                         pco->vSetup(dcoDst.prgnEffRao(), erclDst,CLIP_NOFORCETRIV),
                         erclDst = pco->erclExclude(),
                         (!erclDst.bEmpty())))
                    {
                    // Set up the brush if necessary.

                        EBRUSHOBJ *pbo = dcoDst.peboBackground();

                        if (dcoDst.bDirtyBrush(DIRTY_BACKGROUND))
                        {
                            dcoDst.vCleanBrush(DIRTY_BACKGROUND);

                            XEPALOBJ palDst(pSurfDst->ppal());
                            XEPALOBJ palDstDC(dcoDst.ppal());

                            pbo->vInitBrush(dcoDst.pdc,
                                            gpbrBackground,
                                            palDstDC,
                                            palDst,
                                            pSurfDst,
                                            (dcoDst.flGraphicsCaps() & GCAPS_ARBRUSHOPAQUE) ? TRUE : FALSE);
                        }

                        DEVEXCLUDEOBJ dxo(dcoDst,&erclDst,pco);

                    // Inc the target surface uniqueness

                        INC_SURF_UNIQ(pSurfDst);

                    // Dispatch the call.

                        bReturn = (*(pSurfDst->pfnBitBlt()))

                                      (pSurfDst->pSurfobj(),
                                       (SURFOBJ *) NULL,
                                       (SURFOBJ *) NULL,
                                       pco,
                                       NULL,
                                       &erclDst,
                                       (POINTL *)  NULL,
                                       (POINTL *)  NULL,
                                       pbo,
                                       &dcoDst.pdc->ptlFillOrigin(),
                                       0x0000f0f0);

                    }
                    else
                    {
                        bReturn = TRUE;
                    }
                }
                else
                {
                    bReturn = TRUE;
                }
            }
            else
            {
                bReturn = TRUE;
            }
        }
        else
        {
        // There is rotation involved - send it off to ExtTextOutW to handle it.

            bReturn = GreExtTextOutWLocked(dcoDst, 0, 0, ETO_OPAQUE,
                prcl, (LPWSTR) NULL, 0, NULL, dcoDst.pdc->jBkMode(), NULL, 0);
        }
    }
    else
    {
        WARNING1("ERROR TextOutRect called on invalid DC\n");
        bReturn = FALSE;
    }

    return(bReturn);
}
/******************************Public*Routine******************************\
* BOOL GrePolyTextOut
*
* Write text with lots of random spacing and alignment options.
*
* Arguments:
*
*   hdc      -  handle to DC
*   lpto     -  Ptr to array of polytext structures
*   nStrings -  number of polytext structures
*
* Return Value:
*
* History:
*  Tue 09-Nov-1993 -by- Patrick Haluptzok [patrickh]
* For code size we'll call ExtTextOutW.  After the RFONT and brushes are
* realized, the RaoRegion is setup etc, future calls to ExtTextOutW
* will be very cheap.  Plus ExtTextOut will be in the working set where a
* huge GrePolyTextOut won't be.  It is still a savings by avoiding kernel
* transitions
*
\**************************************************************************/

BOOL GrePolyTextOutW(
    HDC        hdc,
    POLYTEXTW *lpto,
    UINT       nStrings,
    DWORD      dwCodePage
)
{
    BYTE CaptureBuffer[TEXT_CAPTURE_BUFFER_SIZE];
    BOOL bRet = TRUE;

    //
    // call GreExtTextOutW
    //

    XDCOBJ dcoDst(hdc);

    //
    // Validate the destination DC.
    //

    if (dcoDst.bValid())
    {
        DEVLOCKOBJ dlo;

        if (dlo.bLock(dcoDst))
        {
            for (POLYTEXTW *ppt = lpto; ppt < lpto+nStrings; ppt += 1)
            {
                //
                // Try to use stack buffer
                //

                PVOID pStrObjBuffer = NULL;
                ULONG cjStrObj = SIZEOF_STROBJ_BUFFER(ppt->n);

                if (TEXT_CAPTURE_BUFFER_SIZE >= cjStrObj)
                {
                    pStrObjBuffer = CaptureBuffer;
                }

                if (!GreExtTextOutWLocked(
                                    dcoDst,
                                    ppt->x,
                                    ppt->y,
                                    ppt->uiFlags,
                                    &(ppt->rcl),
                                    (LPWSTR) ppt->lpstr,
                                    ppt->n,
                                    ppt->pdx,
                                    dcoDst.pdc->jBkMode(),
                                    pStrObjBuffer,
                                    dwCodePage))
                {
                    WARNING1("GrePolyTextOutW failed a call to GreExtTextOutW\n");
                    bRet = FALSE;
                    break;
                }
            }
        }
        else
        {
            bRet = dcoDst.bFullScreen();
        }

        dcoDst.vUnlock();
    }
    else
    {
        WARNING1("GrePolyTextOutW: can not lock dc \n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        bRet = FALSE;
    }
    return(bRet);
}


/******************************Public*Routine******************************\
* GreExtTextOutW: Wrapper for common GreExtTextOutW code. This routine just
* acquires locks then calls GreExtTextOutWLocked
*
* Arguments:
*
*    Same as GreExtTextOutW
*
* Return Value:
*
*    BOOL States
*
* History:
*
*    30-Oct-1995 - Initial version of wrapper
*
\**************************************************************************/

// for user/kernel consumption only

BOOL GreExtTextOutW(
    HDC     hdc,
    int     x,
    int     y,
    UINT    flOpts,
    CONST RECT *prcl,
    LPCWSTR    pwsz,
    UINT       cwc,
    CONST INT *pdx
    )
{
    return GreExtTextOutWInternal(
            hdc,
            x,
            y,
            flOpts,
            (LPRECT)prcl,
            (LPWSTR)pwsz,
            (int) cwc,
            (LPINT)pdx,
            NULL,
            0
            );
}



BOOL GreExtTextOutWInternal(
    HDC     hdc,
    int     x,
    int     y,
    UINT    flOpts,
    LPRECT  prcl,
    LPWSTR  pwsz,
    int     cwc,
    LPINT   pdx,
    PVOID   pvBuffer,
    DWORD   dwCodePage
    )
{

    BOOL bRet = FALSE;

    //
    // call GreExtTextOutW
    //

    XDCOBJ dcoDst(hdc);

    //
    // Validate the destination DC.
    //

    if (dcoDst.bValid())
    {
        DEVLOCKOBJ dlo;

        if (dlo.bLock(dcoDst))
        {
            bRet = GreExtTextOutWLocked(
                                 dcoDst,
                                 x,
                                 y,
                                 flOpts,
                                 prcl,
                                 pwsz,
                                 cwc,
                                 pdx,
                                 dcoDst.pdc->jBkMode(),
                                 pvBuffer,
                                 dwCodePage);
        }
        else
        {
            bRet = dcoDst.bFullScreen();
        }

        dcoDst.vUnlock();
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* GreBatchTextOut: Set propper DC flags and attributes, then call textout
* pr textoutrect.
*
* Arguments:
*
*   dcoDst Locked DCOBJ
*   xoDst  XFORMOBJ
*   pbText Batched textout entry
*
* Return Value:
*
*   Status
*
*    14-Oct-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/


#define ETO_NULL_PRCL 0x80000000

BOOL
GreBatchTextOut(
    XDCOBJ          &dcoDst,
    PBATCHTEXTOUT   pbText,
    ULONG           cjBatchLength   // cannot trust the Length field in pbText
                                    // because it is accessible to user-mode
    )
{
    //
    // set foreground and background color in DC
    // and restore after call (if needed)
    //

    BYTE CaptureBuffer[TEXT_CAPTURE_BUFFER_SIZE];
    COLORREF crSaveText = (COLORREF)-1;
    COLORREF crSaveBack = (COLORREF)-1;
    HANDLE   hlfntNewSave = NULL;
    UINT     flTextAlignSave = -1;
    POINTL   ptlViewportOrgSave;
    PVOID    pStrObjBuffer = NULL;
    ULONG    ulSaveText, ulSaveBack;

    if (pbText->Type == BatchTypeTextOutRect)
    {
        ASSERTGDI(((PBATCHTEXTOUTRECT)pbText)->fl & ETO_OPAQUE, "GreBatchTextOut, flags\n");

        crSaveBack = dcoDst.pdc->crBackClr();
        ulSaveBack = dcoDst.pdc->ulBackClr();

        if (crSaveBack != ((PBATCHTEXTOUTRECT)pbText)->BackColor)
        {
            dcoDst.pdc->crBackClr(((PBATCHTEXTOUTRECT)pbText)->BackColor);
            dcoDst.pdc->ulBackClr(((PBATCHTEXTOUTRECT)pbText)->ulBackColor);
            dcoDst.ulDirtyAdd(DIRTY_FILL|DIRTY_LINE|DIRTY_BACKGROUND);
        }

        ptlViewportOrgSave = dcoDst.pdc->ptlViewportOrg();

        if ((ptlViewportOrgSave.x != ((PBATCHTEXTOUTRECT)pbText)->ptlViewportOrg.x) ||
            (ptlViewportOrgSave.y != ((PBATCHTEXTOUTRECT)pbText)->ptlViewportOrg.y))
        {
            dcoDst.pdc->lViewportOrgX(((PBATCHTEXTOUTRECT)pbText)->ptlViewportOrg.x);
            dcoDst.pdc->lViewportOrgY(((PBATCHTEXTOUTRECT)pbText)->ptlViewportOrg.y);

            dcoDst.pdc->flSet_flXform(
                               PAGE_XLATE_CHANGED     |
                               DEVICE_TO_WORLD_INVALID);
        }

        ExtTextOutRect(dcoDst,(LPRECT)&((PBATCHTEXTOUTRECT)pbText)->rcl);

        if (dcoDst.pdc->crBackClr() != crSaveBack)
        {
            dcoDst.pdc->crBackClr(crSaveBack);
            dcoDst.pdc->ulBackClr(ulSaveBack);
            dcoDst.ulDirtyAdd(DIRTY_FILL|DIRTY_LINE|DIRTY_BACKGROUND);
        }


        if ((ptlViewportOrgSave.x != dcoDst.pdc->lViewportOrgX()) ||
             (ptlViewportOrgSave.y != dcoDst.pdc->lViewportOrgY()))
        {
            dcoDst.pdc->lViewportOrgX(ptlViewportOrgSave.x);
            dcoDst.pdc->lViewportOrgY(ptlViewportOrgSave.y);

            dcoDst.pdc->flSet_flXform(
                               PAGE_XLATE_CHANGED     |
                               DEVICE_TO_WORLD_INVALID);

        }

    }
    else
    {
        RECT newRect;
        LPRECT prcl;
        LPINT  pdx = NULL;

        //
        // Capture the buffer length parameters from the TEB batch.
        // They can be overwritten by user-mode, so are not to be
        // trusted.
        //

        ULONG fl        = pbText->fl;
        ULONG cChar     = pbText->cChar;
        ULONG PdxOffset = pbText->PdxOffset;

        //
        // Check that char data will not overflow the data buffer.
        //

        ULONG cjBuf = cjBatchLength - offsetof(BATCHTEXTOUT, ulBuffer);

        if (cChar > (cjBuf / sizeof(WCHAR)))
        {
            WARNING("GreBatchTextOut: batch overflow char\n");
            return FALSE;
        }

        //
        // Check that optional pdx data will not overflow the data buffer.
        //

        if (PdxOffset != 0)
        {
            ULONG cjPdxPerChar;

            //
            // The pdx array must have cChar number of horizontal
            // deltas and, if the optional ETO_PDY flag is set, cChar
            // number of vertical deltas.
            //

            cjPdxPerChar = sizeof(INT);
            if (fl & ETO_PDY)
                cjPdxPerChar *= 2;

            //
            // Is the start and end of the pdx array in range?
            //

            if ((PdxOffset > cjBuf) ||
                 (cChar > ((cjBuf - PdxOffset) / cjPdxPerChar)))
            {
                WARNING("GreBatchTextOut: batch overflow pdx\n");
                return FALSE;
            }

            //
            // Since we know that the pdx array is in range, go ahead
            // and set pdx.
            //

            pdx = (LPINT)((PUCHAR)&pbText->ulBuffer[0] + PdxOffset);
        }

        //
        // Set foreground and background text colors.
        //

        crSaveText = dcoDst.pdc->crTextClr();
        ulSaveText = dcoDst.pdc->ulTextClr();

        if (crSaveText != pbText->TextColor)
        {
            dcoDst.pdc->crTextClr(pbText->TextColor);
            dcoDst.pdc->ulTextClr(pbText->ulTextColor);
            dcoDst.ulDirtyAdd(DIRTY_FILL|DIRTY_LINE|DIRTY_TEXT);
        }

        crSaveBack = dcoDst.pdc->crBackClr();
        ulSaveBack = dcoDst.pdc->ulBackClr();

        if (crSaveBack != pbText->BackColor)
        {
            dcoDst.pdc->crBackClr(pbText->BackColor);
            dcoDst.pdc->ulBackClr(pbText->ulBackColor);
            dcoDst.ulDirtyAdd(DIRTY_FILL|DIRTY_LINE|DIRTY_BACKGROUND);
        }

        if (dcoDst.pdc->hlfntNew() != pbText->hlfntNew)
        {
            hlfntNewSave = dcoDst.pdc->hlfntNew();
            dcoDst.pdc->hlfntNew((HLFONT)pbText->hlfntNew);
            dcoDst.ulDirtyAdd(DIRTY_CHARSET);
            dcoDst.ulDirtySub(SLOW_WIDTHS);

        }

        if (dcoDst.pdc->flTextAlign() != pbText->flTextAlign)
        {
            flTextAlignSave = dcoDst.pdc->flTextAlign();
            dcoDst.pdc->flTextAlign(pbText->flTextAlign);
        }

        ptlViewportOrgSave = dcoDst.pdc->ptlViewportOrg();

        if ((ptlViewportOrgSave.x != pbText->ptlViewportOrg.x) ||
            (ptlViewportOrgSave.y != pbText->ptlViewportOrg.y))
        {
            dcoDst.pdc->lViewportOrgX(pbText->ptlViewportOrg.x);
            dcoDst.pdc->lViewportOrgY(pbText->ptlViewportOrg.y);

            dcoDst.pdc->flSet_flXform(
                                        PAGE_XLATE_CHANGED     |
                                        DEVICE_TO_WORLD_INVALID);
        }

        if (fl & ETO_NULL_PRCL)
        {
            prcl = NULL;
            fl &= ~ETO_NULL_PRCL;
        }
        else
        {
            __try
            {
                newRect = ProbeAndReadStructure((LPRECT)&pbText->rcl,RECT);
                prcl = &newRect;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(119);

                return FALSE;
            }
        }

        //
        // try to use stack based temp buffer
        //

        ULONG cjStrObj = SIZEOF_STROBJ_BUFFER(cChar);

        if (TEXT_CAPTURE_BUFFER_SIZE >= cjStrObj)
        {
            pStrObjBuffer = &CaptureBuffer[0];
        }

        GreExtTextOutWLocked(
                             dcoDst,
                             pbText->x,
                             pbText->y,
                             fl,
                             prcl,
                             (LPWSTR)&pbText->ulBuffer[0],
                             cChar,
                             pdx,
                             pbText->BackMode,
                             pStrObjBuffer,
                             pbText->dwCodePage);

        //
        // Restore the foreground and background text colors.
        //

        if (dcoDst.pdc->crTextClr() != crSaveText)
        {
            dcoDst.pdc->crTextClr(crSaveText);
            dcoDst.pdc->ulTextClr(ulSaveText);
            dcoDst.ulDirtyAdd(DIRTY_FILL|DIRTY_LINE|DIRTY_TEXT);
        }

        if (dcoDst.pdc->crBackClr() != crSaveBack)
        {
            dcoDst.pdc->crBackClr(crSaveBack);
            dcoDst.pdc->ulBackClr(ulSaveBack);
            dcoDst.ulDirtyAdd(DIRTY_FILL|DIRTY_LINE|DIRTY_BACKGROUND);
        }

        if (hlfntNewSave != NULL)
        {
           dcoDst.pdc->hlfntNew(((HLFONT)hlfntNewSave));
           dcoDst.ulDirtyAdd(DIRTY_CHARSET);
           dcoDst.ulDirtySub(SLOW_WIDTHS);
        }

        if (flTextAlignSave != -1)
        {
            dcoDst.pdc->flTextAlign(flTextAlignSave);
        }

        if ((ptlViewportOrgSave.x != dcoDst.pdc->lViewportOrgX()) ||
             (ptlViewportOrgSave.y != dcoDst.pdc->lViewportOrgY()))
        {
            dcoDst.pdc->lViewportOrgX(ptlViewportOrgSave.x);
            dcoDst.pdc->lViewportOrgY(ptlViewportOrgSave.y);

            dcoDst.pdc->flSet_flXform(
                            PAGE_XLATE_CHANGED     |
                            DEVICE_TO_WORLD_INVALID);

        }

    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL GreExtTextOutW (hdc,x,y,flOpts,prcl,pwsz,cwc,pdx,pvBuffer)
*
* Write text with lots of random spacing and alignment options.
*
* Below are the string length distributions from running the Winstone 95
* scenarios for Excel and Winword, courtesy of KirkO:
*
*   [Excel]
*                  ------ OPAQUE ------- ----- TRANSPARENT ---
*    string length   pdx == 0   pdx != 0   pdx == 0   pdx != 0
*    ------------- ---------- ---------- ---------- ----------
*         0--9           3799          0      15323       9143
*        10--19           695          0       1651        983
*        20--29           527          0        196         22
*        30--39           200          0        289         53
*        40--49            12          0          3          0
*        50--59            96          0         12          0
*        60--69            10          0          4          0
*        70--79             3          0          0          0
*        80--89             0          0          0          0
*        90--99             0          0         49         16
*       100--109           11          0          0          0
*
*   [Winword]
*
*                 ------ OPAQUE ------- ----- TRANSPARENT ---
*   string length   pdx == 0   pdx != 0   pdx == 0   pdx != 0
*   ------------- ---------- ---------- ---------- ----------
*        0--9           1875          9       3350          0
*       10--19           878         17        324          0
*       20--29           254         17         25          0
*       30--39            93          6         28          2
*       40--49           146         30         18         12
*       50--59            34         16          3         14
*       60--69            20         13          8          7
*       70--79           128         73         13         18
*       80--89            53        139          6         23
*       90--99            41        903          9        127
*      100--109           92       1878          3        217
*      110--119            5         23          0          0
*
* History:
*  Fri 05-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Make smaller and faster.
*
*  Sat 14-Mar-1992 06:08:26 -by- Charles Whitmer [chuckwh]
* Rewrote it.
*
*  Thu 03-Jan-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define TS_DRAW_TEXT                0x0001
#define TS_DRAW_OPAQUE_PGM          0x0002
#define TS_DRAW_COMPLEX_UNDERLINES  0x0004
#define TS_DRAW_OPAQUE_RECT         0x0008
#define TS_DRAW_BACKGROUND_PGM      0x0010
#define TS_DRAW_VECTOR_FONT         0x0020
#define TS_DRAW_OUTLINE_FONT        0x0040
#define TS_START_WITH_SUCCESS       0x0080

// Due to the massiveness of this function we will use 2 space tabs.

#if DBG // statistics
    typedef struct _TSTATENTRY {
        int c;         // number observed
    } TSTATENTRY;
    typedef struct _TSTAT {
        TSTATENTRY NO; // pdx == 0, opaque
        TSTATENTRY DO; // pdx != 0, opaque
        TSTATENTRY NT; // pdx == 0, transparent
        TSTATENTRY DT; // pdx != 0, transparent
    } TSTAT;
    #define MAX_CHAR_COUNT 200  // observe for 0,1,..200,201 and above
    typedef struct _TEXTSTATS {
        int cchMax;             // = MAX_CHAR_COUNT
        TSTAT ats[MAX_CHAR_COUNT+2];
    } TEXTSTATS;
    TEXTSTATS gTS = {MAX_CHAR_COUNT};
    #define TS_START    1
    #define TS_CONTINUE 2
    #define TS_VERBOSE  4
    #define TS_STOP     8
    FLONG   gflTS = 0;          // flags that control text statistics
#endif  // statistics


BOOL GreExtTextOutWLocked(
    XDCOBJ    &dco,             // Locked DC
    int       x,                // Initial x position
    int       y,                // Initial y position
    UINT      flOpts,           // Options
    LPRECT    prcl,             // Clipping rectangle
    LPWSTR    pwsz,             // Unicode character array
    int       cwc,              // Count of characters
    LPINT     pdx,              // Character spacing
    ULONG     ulBkMode,         // Current background mode
    PVOID     pvBuffer,         // If non-NULL, contains a buffer for storing
                                //   the STROBJ, so that we don't need to
                                //   allocate one on the fly.  Must be at
                                //   least SIZEOF_STROBJ_BUFFER(cwc) bytes in
                                //   size.
                                // If NULL, we will try to use the global
                                //   STROBJ buffer, otherwise we will allocate
                                //   on the fly.
    DWORD     dwCodePage        // Code page for current textout
)
{
  // flState gets set with BITS for things we need to draw.
  // We also use this for the return value, setting it to 0 if an error occurs.

  BOOL bIsVectorFont = FALSE;
  BOOL bPathFont = FALSE;


  FLONG flState = TS_START_WITH_SUCCESS;
  BOOL  flType = ((flOpts & ETO_GLYPH_INDEX) ? RFONT_TYPE_HGLYPH : RFONT_TYPE_UNICODE);

  // Win95 comaptibility: If in path bracket and ETO_CLIPPED is set, then fail call

  if ( dco.pdc->bActive() && ( flOpts & ETO_CLIPPED ) )
  {
    EngSetLastError( ERROR_INVALID_PARAMETER );
    return( FALSE );
  }

  if (dco.bDisplay() && !dco.bRedirection() && !UserScreenAccessCheck())
  {
      SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
      return( FALSE );
  }

// ignore RTOLREADING flag,
// only does something if lpk dlls are loaded under win95

  BOOL bPdy = flOpts & ETO_PDY;

  flOpts &= ~(ETO_PDY | ETO_GLYPH_INDEX | ETO_RTLREADING | ETO_IGNORELANGUAGE | ETO_NUMERICSLOCAL | ETO_NUMERICSLATIN);
  if (!prcl)
  {
      flOpts &= ~(ETO_CLIPPED | ETO_OPAQUE); // ignore flags if no rect, win95 compat
  }
  else if ((prcl->left == prcl->right) || (prcl->top == prcl->bottom))
  {
      prcl->left = prcl->right = x;
      prcl->top = prcl->bottom = y;

      // now prcl is guaranteed to be within text rect

      if ((flOpts & (ETO_OPAQUE|ETO_CLIPPED)) == ETO_OPAQUE)
      {
    prcl = NULL; // since it is empty, we may as well ignore it
    flOpts &= ~ETO_OPAQUE; // ignore flag if no rect
      }
  }

  PFN_DrvTextOut pfnTextOut;
  MIX mix = R2_COPYPEN + 256*R2_COPYPEN;    // default mix sent to TextOut routines

  // Lock the DC and set the new attributes.

  if (dco.bValid())
  {
    #if DBG // statistics
    if (gflTS & TS_START) {
        KdPrint((
            "\n"
            "***************************************\n"
            "*** BEGIN GreExtTextOutW statistics ***\n"
            "***************************************\n"
            "\n"
        ));
        RtlZeroMemory(gTS.ats, sizeof(TSTAT)*(gTS.cchMax+2));
        gflTS ^= TS_START;
        gflTS |= TS_CONTINUE;
    }
    if (gflTS & TS_CONTINUE) {
        TSTATENTRY *ptse;
        char       *psz;
        TSTAT      *pts;

        pts = gTS.ats + min(cwc,gTS.cchMax+1);
        ptse = 0;
        switch (ulBkMode)
        {
        case OPAQUE:
            ptse = (pdx) ? &(pts->DO) : &(pts->NO);
            psz =  "OPAQUE";
            break;
        case TRANSPARENT:
            ptse = (pdx) ? &(pts->DT) : &(pts->NT);
            psz  = "TRANSP";
            break;
        default:
            KdPrint(("jBkMode = UNKNOWN\n"));
            break;
        }
        if (ptse) {
            ptse->c += 1;
            if (gflTS & TS_VERBOSE)
                KdPrint((
                    "%10d %10d %s %s"
                ,   min(cwc,gTS.cchMax+1)
                ,   ptse->c
                ,   psz
                ,   (pdx) ? "(pdx)" : ""
                ));
        }
    }
    if (gflTS & TS_STOP) {
        KdPrint((
            "\n"
            "*************************************\n"
            "*** END GreExtTextOutW statistics ***\n"
            "*************************************\n"
            "\n"
        ));
        gflTS = 0;
    }
    #endif  // statistics

    // Check the validity of the flags.

    if
    (
      ((flOpts == 0) || ((prcl != (RECT *) NULL) && ((flOpts & ~(ETO_CLIPPED | ETO_OPAQUE)) == 0)))
      &&
      !(dco.pdc->bActive() && (flOpts & ETO_CLIPPED)) // no clipping in a path
    )
    {
      FLONG flControl = 0;        // Set to 0 in case cwc is 0
      ERECTL rclExclude(0,0,0,0);

      // Lock the Rao region if we are drawing on a display surface.  The Rao region
      // might otherwise change asynchronously.  The DEVLOCKOBJ also makes sure that
      // the VisRgn is up to date, calling the window manager if necessary to
      // recompute it.  This is needed if want to compute positions in screen coords.
      // No DEVLOCK is needed if we are in path accumulation mode.

      POINTL   ptlOrigin;             // The window origin.
      POINTFIX ptfxOrigin;            // Same thing in FIX.

        if (dco.pdc->bActive())
        {
          ptlOrigin.x = 0;
          ptlOrigin.y = 0;
        }
        else
        {
          ptlOrigin = dco.eptlOrigin();
        }

        ptfxOrigin.x = LTOFX(ptlOrigin.x);
        ptfxOrigin.y = LTOFX(ptlOrigin.y);

        // Get the transform from the DC.

        EXFORMOBJ xo(dco, WORLD_TO_DEVICE);

        // Transform the input rectangle.  In the simple case the result is in
        // rclInput.  In the general case a parallelogram is in ptfxInput[4], and
        // bounds for the parallelogram are in rclInput.

        ERECTL    rclInput;
        POINTFIX  ptfxInput[4];

        // this must go after the DCOBJ, so that the DCOBJ still exists at cleanup

        TXTCLEANUP clean;              // Mops up before exit.

        if (prcl != (RECT *) NULL)
        {
          if (flOpts & ETO_OPAQUE)
          {
            flState |= TS_DRAW_OPAQUE_RECT;
          }

          // The intent of the following bTranslationsOnly and bScale cases is to provide
          // faster inline versions of the same code that would be executed by xo.bXform(prcl).
          // We must be completely compatible with the normal xform code because apps expect
          // to opaque and clip to the same rectangles as a PatBlt would cover.  So, if you
          // intend to modify the behavior of this code, make sure you change PatBlt and
          // BitBlt as well!  (I.e. just don't do it.)  [chuckwh]

          if (xo.bTranslationsOnly())
          {
            rclInput.left   = prcl->left   + ptlOrigin.x + FXTOL(xo.fxDx() + 8);
            rclInput.right  = prcl->right  + ptlOrigin.x + FXTOL(xo.fxDx() + 8);
            rclInput.top    = prcl->top    + ptlOrigin.y + FXTOL(xo.fxDy() + 8);
            rclInput.bottom = prcl->bottom + ptlOrigin.y + FXTOL(xo.fxDy() + 8);
          }
          else if (xo.bScale())        // Simple scaling.
          {
            rclInput.left   = FXTOL(xo.fxFastX(prcl->left)   + 8) + ptlOrigin.x;
            rclInput.right  = FXTOL(xo.fxFastX(prcl->right)  + 8) + ptlOrigin.x;
            rclInput.top    = FXTOL(xo.fxFastY(prcl->top)    + 8) + ptlOrigin.y;
            rclInput.bottom = FXTOL(xo.fxFastY(prcl->bottom) + 8) + ptlOrigin.y;
          }
          else                        // General case.
          {
            //
            // Construct three vertices of the input rectangle, in drawing order.
            //

            ptfxInput[0].x = prcl->left;
            ptfxInput[0].y = prcl->bottom;
            ptfxInput[1].x = prcl->left;
            ptfxInput[1].y = prcl->top;
            ptfxInput[2].x = prcl->right;
            ptfxInput[2].y = prcl->top;

            // Transform the vertices.

            xo.bXform((POINTL *) ptfxInput,ptfxInput,3);

            // We construct the fourth vertex ourselves to avoid excess transform
            // work and roundoff errors.

            ptfxInput[3].x = ptfxInput[0].x + ptfxInput[2].x - ptfxInput[1].x;
            ptfxInput[3].y = ptfxInput[0].y + ptfxInput[2].y - ptfxInput[1].y;

            // Bound the parallelogram.  (Using Black Magic.)

            // DChinn: At this point, we know that EITHER points 0 and 2 OR
            // points 1 and 3 are the extreme x coordinates (left and right).
            // Similarly, EITHER points 0 and 2 OR points 1 and 3 are the extreme y
            // coordinates.
            //
            // ASSERT: it is possible that at this point, prcl is inverted
            // (i.e., left > right or top > bottom).  If this is true, then
            // ptfxInput[] will have its points ordered counterclockwise rather
            // than clockwise.

            int ii;

            ii = (ptfxInput[1].x > ptfxInput[0].x)
                 == (ptfxInput[1].x > ptfxInput[2].x);

            // Rounding direction depends on whether the parallelogram is inverted or not.
            if (ptfxInput[ii].x <= ptfxInput[ii+2].x)
            {
                rclInput.left   = ptlOrigin.x + FXTOL(ptfxInput[ii].x);
                rclInput.right  = ptlOrigin.x + FXTOLCEILING(ptfxInput[ii+2].x);
            }
            else
            {
                rclInput.left   = ptlOrigin.x + FXTOLCEILING(ptfxInput[ii].x);
                rclInput.right  = ptlOrigin.x + FXTOL(ptfxInput[ii+2].x);
            }

            ii = (ptfxInput[1].y > ptfxInput[0].y)
                 == (ptfxInput[1].y > ptfxInput[2].y);

            // Rounding direction depends on whether the parallelogram is inverted or not.
            if (ptfxInput[ii].y <= ptfxInput[ii+2].y)
            {
                rclInput.top    = ptlOrigin.y + FXTOL(ptfxInput[ii].y);
                rclInput.bottom = ptlOrigin.y + FXTOLCEILING(ptfxInput[ii+2].y);
            }
            else
            {
                rclInput.top    = ptlOrigin.y + FXTOLCEILING(ptfxInput[ii].y);
                rclInput.bottom = ptlOrigin.y + FXTOL(ptfxInput[ii+2].y);
            }

            // Take care of a complex clipping request now.  We'll set things up
            // so that the clipping will just happen automatically, and then clear
            // the clipping flag.  This simplifies the rest of the code.

            if (flOpts & ETO_CLIPPED)
            {
              // Allocate a path.  We know we're not already in a path bracket
              // since clipping requests in path brackets were rejected above.
              // Draw the parallelogram into it.

              PATHMEMOBJ po;

              if (po.bValid() && po.bAddPolygon(XFORMNULL,(POINTL *)&ptfxInput[0],4))
              {
                //
                // Construct a region from the path.
                //

                RECTL Bounds, *pBounds;

                // Only the top and bottom are used for clipping and
                // they have to be initialized as FIX.
                Bounds.top    = LTOFX(dco.erclClip().top - ptlOrigin.y);
                Bounds.bottom = LTOFX(dco.erclClip().bottom - ptlOrigin.y);
                pBounds = &Bounds;

                RGNMEMOBJ rmo(po, ALTERNATE, pBounds);


                if (rmo.bValid())
                {
                  // Stuff the region handle into the DC.  This is a nifty trick
                  // (courtesy of DonaldS) that uses this region in the next
                  // calculation of the clipping pipeline.  We'll clear the prgnAPI
                  // after we're through.

                  dco.pdc->prgnAPI(rmo.prgnGet());

                  // Clipping is now transparent, so forget about it.

                  clean.vSet(dco);        // This frees the region on exit.

                  if (dco.pdc->prgnRao() != (REGION *)NULL)
                  {
                    dco.pdc->vReleaseRao();
                  }

                  if (dco.pdc->bCompute())
                  {
                    flOpts &= ~ETO_CLIPPED;
                  }

                  // Now that we have a complex clip area, we can opaque with a
                  // simple BitBlt.  So we don't need to set TS_DRAW_OPAQUE_PGM.
                }
              }

              //
              // Well if we have succeeded we will have erased the ETO_CLIPPED flag.
              // Otherwise we failed and need to return FALSE.  We can't return here
              // without generating tons of destructors so we set flState and a few
              // other fields to 0 so we bop down and return FALSE.
              //

              if (flOpts & ETO_CLIPPED)
              {
                flOpts  = 0;
                flState = 0;
                cwc     = 0;
              }
            }
            else if (flOpts & ETO_OPAQUE)
            {
              flState &= ~TS_DRAW_OPAQUE_RECT;
              flState |= TS_DRAW_OPAQUE_PGM;

              // Since we're actually going to use it, offset the parallelogram
              // to screen coordinates. use unrolled loop

              EPOINTFIX *pptfx = (EPOINTFIX *) &ptfxInput[0];

              *pptfx++ += ptfxOrigin;
              *pptfx++ += ptfxOrigin;
              *pptfx++ += ptfxOrigin;
              *pptfx   += ptfxOrigin;
            }
          }

          // If it a mirrored DC then shift the rect one pixel to the right
          // This will give the effect of including the right edge of the rect and exclude the left edge.
          if (MIRRORED_DC(dco.pdc)) {
             ++rclInput.left;
             ++rclInput.right;
          }
          // Force the rectangle to be well ordered.

          rclInput.vOrder();

          // Add any opaquing into the exclusion area.

          if (flState &
              (TS_DRAW_OPAQUE_RECT | TS_DRAW_OPAQUE_PGM))
          {
            rclExclude += rclInput;
          }
        }

        POINTFIX aptfxBackground[4];    // The TextBox.
        BOOL     bComplexBackground;    // TRUE if the TextBox is a parallelogram.
        RECTL   *prclBackground = NULL; // Bkgnd rectangle passed to DrvTextOut.
        RECTL   *prclExtraRects = NULL; // Extra rectangles passed to DrvTextOut.
        RFONTOBJ rfo;
        ESTROBJ to;

        if (cwc)
        {
          //
          // Locate the font cache.  Demand PATHOBJ's if we are in a path bracket.
          //

          rfo.vInit(dco, dco.pdc->bActive() ? TRUE  : FALSE, flType);
          if (rfo.bValid())
          {
            bPathFont = rfo.bPathFont();
            bIsVectorFont = rfo.bPathFont() && !rfo.bReturnsOutlines();

            // The recording of the simulation flags and escapement must come AFTER
            // the rfont constructor since they're cached values that are copied from
            // the LFONT only when the font is realized.

            flControl = (dco.pdc->flTextAlign() & TA_MASK)
                         | dco.pdc->flSimulationFlags();

            // Get the reference point.

            EPOINTFIX ptfx;

            if (flControl & TA_UPDATECP)
            {
              if (dco.pdc->bValidPtfxCurrent())
              {
                // Mark that we'll be updating the DC's CP in device coords only:

                dco.pdc->vInvalidatePtlCurrent();
                ptfx.x = dco.ptfxCurrent().x + ptfxOrigin.x;
                ptfx.y = dco.ptfxCurrent().y + ptfxOrigin.y;
              }
              else
              {
                // DC's CP is in logical coords; we have to transform it to device
                // space and mark that we'll be updating the CP in device space:

                dco.pdc->vValidatePtfxCurrent();
                dco.pdc->vInvalidatePtlCurrent();

                if (xo.bTranslationsOnly())
                {
                    ptfx.x = LTOFX(dco.ptlCurrent().x) + xo.fxDx();
                    ptfx.y = LTOFX(dco.ptlCurrent().y) + xo.fxDy();
                }
                else if (xo.bScale())
                {
                    ptfx.x = xo.fxFastX(dco.ptlCurrent().x);
                    ptfx.y = xo.fxFastY(dco.ptlCurrent().y);
                }
                else
                {
                    xo.bXform((POINTL *) &dco.ptlCurrent(), &ptfx, 1);
                }

                dco.ptfxCurrent() = ptfx;
                ptfx += ptfxOrigin;
              }
            }
            else
            {
              //
              // The reference point is passed in.  Transform it to device coords.
              //

              if (xo.bTranslationsOnly())
              {
                ptfx.x = LTOFX(x) + xo.fxDx() + ptfxOrigin.x;
                ptfx.y = LTOFX(y) + xo.fxDy() + ptfxOrigin.y;
              }
              else if (xo.bScale())
              {
                ptfx.x = xo.fxFastX(x) + ptfxOrigin.x;
                ptfx.y = xo.fxFastY(y) + ptfxOrigin.y;
              }
              else
              {
                ptfx.x = x;
                ptfx.y = y;
                xo.bXform((POINTL *) &ptfx,&ptfx,1);
                ptfx += ptfxOrigin;
              }
            }

            // The STROBJ will now compute the text alignment, character positions,
            // and TextBox.

            to.vInit
            (
                pwsz,
                cwc,
                dco,
                rfo,
                xo,
                (LONG *) pdx,
                bPdy,
                dco.pdc->lEscapement(),   // Only read this after RFONTOBJ!
                dco.pdc->lTextExtra(),
                dco.pdc->lBreakExtra(),
                dco.pdc->cBreak(),
                ptfx.x,ptfx.y,
                flControl,
                (LONG *) NULL,
                pvBuffer,
                dwCodePage
            );

            if (to.bValid())
            {
              // Compute the bounding box and the background opaquing area.  The
              // parallelogram aptfxBackground is only computed when it's complex.

              bComplexBackground = to.bOpaqueArea(aptfxBackground,
                                                  &to.rclBkGround);

// This hack, due to filtering needs to be put in textgdi.cxx
// filtering leeks color one pixel to the left and one pixel to the right
// The trouble with it is that is it going to add a pixel on each side
// to the text background when text is painted in the OPAQUE mode.


              if (rfo.pfo()->flFontType & FO_CLEARTYPE_X)
              {
                   to.rclBkGround.left--;
                   to.rclBkGround.right++;
              }

              if (to.bLinkedGlyphs())
              {
                to.vEudcOpaqueArea(aptfxBackground, bComplexBackground);
              }

              // Accumulate the touched area to the exclusion rect.

              rclExclude += to.rclBkGround;

              // Make notes of exactly what drawing needs to be done.

              if (ulBkMode == OPAQUE)
              {
                if (bComplexBackground)
                {
                  flState |= TS_DRAW_BACKGROUND_PGM;
                }
                else
                {
                  prclBackground = &to.rclBkGround; // No TS_ bit since this gets
                }                                   // passed directly to DrvTextOut.
              }

              // In a few bizarre cases the STROBJ can have an empty text rectangle
              // we don't want to call DrvTextOut in those case but still need
              // to worry about the opaque rectangle.

              BOOL bEmptyTextRectangle = ((ERECTL *)&(to.rclBkGround))->bEmpty();

              // Attempt to combine the rectangles.  Even in transparent mode we should
              // attempt to send an opaquing rectangle to DrvTextOut in prclBackground.

              if ((flState & TS_DRAW_OPAQUE_RECT)     &&
                  (rclInput.bContain(to.rclBkGround)) &&
                  (!bEmptyTextRectangle) )
              {
                  prclBackground = &rclInput;
                  flState &= ~TS_DRAW_OPAQUE_RECT;
              }

              if ( ((prclBackground != NULL ) && !((ERECTL *)prclBackground)->bEmpty() ) ||
                   ((prclBackground == NULL) && !bEmptyTextRectangle) )
              {
                  flState |= TS_DRAW_TEXT;
              }

              if (flControl & (TSIM_UNDERLINE1 | TSIM_STRIKEOUT))
              {
                  if ((prclExtraRects = to.prclExtraRects()) == NULL)
                  {
                      flState |= TS_DRAW_COMPLEX_UNDERLINES;
                  }
                  else // include extra rectangles into the touched area:
                  {
                      ERECTL *eprcl = (ERECTL *) prclExtraRects;

                      for (; !eprcl->bEmpty(); eprcl++)
                      {
                            rclExclude += *eprcl;
                      }
                  }
              }

              // Accelerate the clipping case when it's irrelevant.  (I'm concerned
              // that a spreadsheet might tell us to clip to a cell, even though the
              // string lies completely within.)

              if (flOpts & ETO_CLIPPED)
              {
                if (rclInput.bContain(rclExclude))
                {
                  flOpts &= ~ETO_CLIPPED;
                }
                else
                {
                  rclExclude *= rclInput;
                }
              }
            }
            else // if (to.bValid())
            {
              flState = 0;
            }
          }
          else // if (rfo.bValid())
          {
            flState = 0;
          }
        } // if (cwc)

        if (flControl & TA_UPDATECP)
        {
          dco.ptfxCurrent().x += to.ptfxAdvance().x;
          dco.ptfxCurrent().y += to.ptfxAdvance().y;
        }

        //
        // Draw the text into a path if we're in a path bracket.
        //

        if (dco.pdc->bActive())
        {
          //
          // We fail this call if we are asked to CLIP while in a path bracket.
          //

          if (flOpts & ETO_CLIPPED)
          {
            flState = 0;
          }

          XEPATHOBJ po(dco);

          if (po.bValid())
          {
            // Draw the various background shapes.

            if (flState & TS_DRAW_OPAQUE_RECT)
            {
              if (!bAddRectToPath(po,&rclInput))
              {
                flState = 0;
              }
            }

            if (flState & TS_DRAW_OPAQUE_PGM)
            {
              if (!po.bAddPolygon(XFORMNULL,(POINTL *) &ptfxInput[0],4))
              {
                flState = 0;
              }
            }

            if (flState & TS_DRAW_BACKGROUND_PGM)
            {
              if (!po.bAddPolygon(XFORMNULL,(POINTL *) aptfxBackground,4))
              {
                flState = 0;
              }
            }

            BOOL bNeedUnflattend = FALSE;

            //
            // Draw the background rect, text, and extra rectangles.
            //

            if (flState & TS_DRAW_TEXT)
            {
              //
              // Draw a background rectangle.
              //

              if ((prclBackground == (RECTL *) NULL) ||
                  bAddRectToPath(po,prclBackground))
              {
                //
                // Draw the text.
                //

                bNeedUnflattend =
                    ( dco.flGraphicsCaps() & GCAPS_BEZIERS ) ? FALSE : TRUE;

                if (!to.bTextToPath(po, dco, bNeedUnflattend))
                {
                  flState = 0;
                }
                else
                {
                  //
                  // Draw extra rectangles.
                  //

                  if (prclExtraRects != (ERECTL *) NULL)
                  {
                    ERECTL *eprcl = (ERECTL *) prclExtraRects;

                    for (; !eprcl->bEmpty(); eprcl++)
                    {
                      if (!bAddRectToPath(po,eprcl))
                      {
                        flState = 0;
                        break;
                      }
                    }
                  }
                }
              } // if ((prclBackground==0)||bAddRectToPath(po,prclBackground))
            } // if (flState & TS_DRAW_TEXT)

            //
            // Handle complex cases of strikeout and underlines.
            //

            if (flState & TS_DRAW_COMPLEX_UNDERLINES)
            {
              if (!to.bExtraRectsToPath(po, bNeedUnflattend))
              {
                flState = 0;
              }
            }
          } // if (po.bValid())
        }
        else // if (dco.pdc->bActive())
        {
          //
          // If there's nothing to do, get out now.
          //

          if (!rclExclude.bEmpty())
          {
            // Accumulate bounds.  We can do this before knowing if the operation is
            // successful because bounds can be loose.

            if (dco.fjAccum())
            {
              // Use a temporary exclusion rect in device coordinates.

              ERECTL rclExcludeDev;
              rclExcludeDev.left   = rclExclude.left   - ptlOrigin.x;
              rclExcludeDev.right  = rclExclude.right  - ptlOrigin.x;
              rclExcludeDev.top    = rclExclude.top    - ptlOrigin.y;
              rclExcludeDev.bottom = rclExclude.bottom - ptlOrigin.y;
              dco.vAccumulate(*((ERECTL *) &rclExcludeDev));
            }

            // Compute the clipping complexity and maybe reduce the exclusion rectangle.
            // It appears that a 10pt script font (on a screen DC) can be outside of
            // the bounds of the background rectangle.  We have a situation where
            // an app creates a memory DC exactly the size of the bouding rectangle
            // and then draws a vector font to it.  We compute the cliping to be
            // trivial since we think the vector string fits completely inside
            // the bounds of the DC and blow up later in the code. Rather than tweak
            // the vector font driver at this point in the game I am going to force
            // cliping to be set for vector fonts.  Later on we should figure out
            // why this is happening and fix the vector font driver. [gerritv]

            // Under some xform, the text might be "stretched" to some extent length
            // and it will go to the bSimpleFill path code. Force clipping for this
            // case, otherwise we might hit the AV since recl's generated from the
            // pathobj might be a pixel off than the clip rclBounds <seen in stress>.

            ECLIPOBJ co(dco.prgnEffRao(),rclExclude,
                        bPathFont || (flOpts & ETO_CLIPPED) ? CLIP_FORCE :
                                                                  CLIP_NOFORCE);
            rclExclude = co.erclExclude();

            // Check the destination which is reduced by clipping.

            if (!co.erclExclude().bEmpty())
            {
              SURFACE *pSurf = dco.pSurface();

              if (pSurf != NULL)
              {
                PDEVOBJ pdo(pSurf->hdev());
                XEPALOBJ palDest(pSurf->ppal());
                XEPALOBJ palDestDC(dco.ppal());

                // Get the foreground and opaque brushes

                FLONG flCaps = dco.flGraphicsCaps();
                EBRUSHOBJ *peboText = dco.peboText();
                EBRUSHOBJ *peboBackground = dco.peboBackground();

                BOOL bDitherText = FALSE;
                if ( flCaps & GCAPS_ARBRUSHTEXT )
                {
                  // Even if a printer driver sets GCAPS_ARBRUSHTEXT, we
                  // can't allow vector fonts to be dithered.

                  bDitherText = !bIsVectorFont;

                  // We always dirty the text brush if ARBRUSHTEXT is set to
                  // catch the cases where we transition between vector and
                  // non-vector fonts but keep the same brush -- if we didn't
                  // do this, we might try to use a cached, dithered brush
                  // after switching from a TrueType font to a vector font.

                  dco.ulDirtyAdd(DIRTY_TEXT);

                  // Get through the are-you-really-dirty check in vInitBrush:

                  peboText->vInvalidateUniqueness();
                }

                if ( dco.bDirtyBrush(DIRTY_TEXT|DIRTY_BACKGROUND) )
                {
                  if ( dco.bDirtyBrush(DIRTY_TEXT) )
                  {
                    peboText->vInitBrush(dco.pdc,
                                         gpbrText,
                                         palDestDC,
                                         palDest,
                                         pSurf,
                                         bDitherText);
                  }

                  if ( dco.bDirtyBrush(DIRTY_BACKGROUND) )
                  {
                    peboBackground->vInitBrush(dco.pdc,
                                     gpbrBackground,
                                     palDestDC, palDest, pSurf,
                                     (flCaps & GCAPS_ARBRUSHOPAQUE) ? TRUE : FALSE);
                  }
                  dco.vCleanBrush(DIRTY_TEXT|DIRTY_BACKGROUND);
                }

                // exclude the pointer

                DEVEXCLUDEOBJ dxo(dco,&co.erclExclude(),&co);

                //
                // Draw background shapes that are too complex for DrvTextOut.
                //

                POINTL *pptlBO = &dco.pdc->ptlFillOrigin();

                // There's an extra layer of conditional here so that simple text can just
                // jump over it all.

                if (flState &
                    (TS_DRAW_OPAQUE_RECT | TS_DRAW_OPAQUE_PGM | TS_DRAW_BACKGROUND_PGM))
                {
                  if ((flState & TS_DRAW_OPAQUE_RECT) && !rclInput.bEmpty())
                  {
                    // intersect the dest rect with the clip rect and set it in co

                    // we can only get away with touching co.rclBounds after
                    // the ECLIPOBJ constructor because of two reasons:
                    // a) the target rectangle passed to bitblt is contained in the
                    //    original bounds set by ECLIPOBJ, being the intersection
                    //    of the origianal bounds with THE intended target rectangle.
                    // b) clipping complexity may have changed when we changed
                    //    co.erclExclude, but it only could have gotten simpler,
                    //    so at worst in those rare situations we would not go
                    //    through the optimal code path.
                    // By changing clipping bounds we accomplish that no intersection
                    // of the target rectangle with clipping region rectangle is emtpy
                    // relieving the driver of extra work [bodind]

                    co.erclExclude().left   = max(rclExclude.left,rclInput.left);
                    co.erclExclude().right  = min(rclExclude.right,rclInput.right);

                    co.erclExclude().top    = max(rclExclude.top,rclInput.top);
                    co.erclExclude().bottom = min(rclExclude.bottom,rclInput.bottom);

                    // if not clipped, Just paint the rectangle.

                    if ((co.erclExclude().left < co.erclExclude().right) &&
                        (co.erclExclude().top < co.erclExclude().bottom))
                    {
                      // Inc target surface uniqueness

                        INC_SURF_UNIQ(pSurf);

                        TextOutBitBlt(pSurf,
                                      rfo,
                                      (SURFOBJ *)  NULL,
                                      (SURFOBJ *)  NULL,
                                      &co,
                                      NULL,
                                      &co.rclBounds,
                                      (POINTL *)  NULL,
                                      (POINTL *)  NULL,
                                      (BRUSHOBJ *)peboBackground,
                                      pptlBO,
                                      0x0000f0f0);
                    }

                    co.erclExclude() = rclExclude;
                  }

                  if (flState & (TS_DRAW_OPAQUE_PGM | TS_DRAW_BACKGROUND_PGM))
                  {
                    PATHMEMOBJ po;

                    if (po.bValid())
                    {
                      if (flState & TS_DRAW_OPAQUE_PGM)
                      {
                        if (!po.bAddPolygon(XFORMNULL,(POINTL *) &ptfxInput[0],4))
                        {
                          flState = 0;
                        }
                      }

                      if (flState & TS_DRAW_BACKGROUND_PGM)
                      {
                        if (!po.bAddPolygon(XFORMNULL,(POINTL *) aptfxBackground,4))
                        {
                          flState = 0;
                        }
                      }

                      if (flState & (TS_DRAW_OPAQUE_PGM | TS_DRAW_BACKGROUND_PGM))
                      {
                        if (!po.bTextOutSimpleFill(dco,
                                                   rfo,
                                                   &pdo,
                                                   pSurf,
                                                   &co,
                                                   (BRUSHOBJ *)peboBackground,
                                                   pptlBO,
                                                   (R2_COPYPEN << 8) | R2_COPYPEN,
                                                   WINDING))
                        {
                          flState = 0;
                        }
                      } // if (flState & (TS_DRAW_OPAQUE_PGM | TS_DRAW_BACKGROUND_PGM))
                    } // if (po.bValid())
                  } // if (flState & (TS_DRAW_OPAQUE_PGM | TS_DRAW_BACKGROUND_PGM))
                } // if (flState & (TS_DRAW_OPAQUE_RECT | TS_DRAW_OPAQUE_PGM | TS_DRAW_BACKGROUND_PGM))

                //
                // Draw the background rect, text, and extra rectangles.
                //

                if (flState & TS_DRAW_TEXT)
                {
                    ERECTL *prclSimExtra = NULL;

                    // Prepare for a vector font simulation.  Note that we'll also need to
                    // simulate the background and extra rectangles.

                    if (bPathFont)
                    {
                        flCaps &= ~(GCAPS_OPAQUERECT);
                        flState |= (rfo.bReturnsOutlines()) ? TS_DRAW_OUTLINE_FONT:TS_DRAW_VECTOR_FONT;
                    }

                    // Simulate a background rectangle.

                    if ((prclBackground != (RECTL *) NULL) &&
                        !(flCaps & GCAPS_OPAQUERECT))
                    {
                      // intersect the dest rect with the clip rect and set it in co

                      // we can only get away with touching co.rclBounds after
                      // the ECLIPOBJ constructor because of two reasons:
                      // a) the target rectangle passed to bitblt is contained in the
                      //    original bounds set by ECLIPOBJ, being the intersection
                      //    of the origianal bounds with THE intended target rectangle.
                      // b) clipping complexity may have changed when we changed
                      //    co.erclExclude, but it only could have gotten simpler,
                      //    so at worst in those rare situations we would not go
                      //    through the optimal code path.
                      // By changing clipping bounds we accomplish that no intersection
                      // of the target rectangle with clipping region rectangle is emtpy
                      // relieving the driver of extra work [bodind]

                      co.erclExclude().left   = max(rclExclude.left,prclBackground->left);
                      co.erclExclude().right  = min(rclExclude.right,prclBackground->right);

                      co.erclExclude().top    = max(rclExclude.top,prclBackground->top);
                      co.erclExclude().bottom = min(rclExclude.bottom,prclBackground->bottom);

                      // if not clipped, Just paint the rectangle.

                      if ((co.erclExclude().left < co.erclExclude().right) &&
                          (co.erclExclude().top < co.erclExclude().bottom))
                      {
                      // Inc target surface uniqueness

                        INC_SURF_UNIQ(pSurf);

                        TextOutBitBlt(pSurf,
                                      rfo,
                                      (SURFOBJ *)  NULL,
                                      (SURFOBJ *)  NULL,
                                      &co,
                                      NULL,
                                      &co.rclBounds,
                                      (POINTL *)  NULL,
                                      (POINTL *)  NULL,
                                      (BRUSHOBJ *)peboBackground,
                                      pptlBO,
                                      0x0000f0f0);
                      }

                      co.erclExclude() = rclExclude;
                      prclBackground = NULL;
                    }

                    // Prepare for the extra rectangle simulation.
                    // For TTY drivers, we need to pass prclExtraRects
                    // to the DrvTextOut call.

                    if ((prclExtraRects != (ERECTL *) NULL) &&
                        (pdo.ulTechnology() != DT_CHARSTREAM))
                    {
                      prclSimExtra = (ERECTL *) prclExtraRects;
                      prclExtraRects = NULL;
                    }

                    // Draw the text.

                    if (flState & TS_DRAW_VECTOR_FONT)
                    {

#ifdef FE_SB
                        if( to.bLinkedGlyphs() )
                        {
                            if( ! bProxyDrvTextOut
                                  (
                                    dco,
                                    pSurf,
                                    to,
                                    co,
                                    (RECTL*) NULL,
                                    (RECTL*) NULL,
                                    (BRUSHOBJ*) peboText,
                                    (BRUSHOBJ*) peboBackground,
                                    pptlBO,
                                    rfo,
                                    &pdo,
                                    dco.flGraphicsCaps(),
                                    &rclExclude
                                   ))
                            {
                                flState = 0;
                            }
                        }
                        else
                        {
#endif

                        PATHMEMOBJ po;
                        if ((!po.bValid())        ||
                            (!to.bTextToPath(po, dco)) ||
                            (!po.bTextOutSimpleStroke1(dco,
                                                       rfo,
                                                       &pdo,
                                                       pSurf,
                                                       &co,
                                                       (BRUSHOBJ *)peboText,
                                                       pptlBO,
                                                       (R2_COPYPEN | (R2_COPYPEN << 8)))))
                        {
                          flState = 0;
                        }
                      }
                    }
                    else // if (flState & TS_DRAW_VECTOR_FONT)
                    {
                      if (pSurf->pdcoAA)
                      {
                          RIP("pdcoAA != 0\n");
                          pSurf->pdcoAA = 0;    // let the free build run
                      }

                      pfnTextOut = pSurf->pfnTextOut();

                      // If the pointer to the TextOut function points to SpTextOut then
                      // we know that AntiAliased text can be handled and we can skip
                      // the funny business in the else clause

		      if (pfnTextOut == SpTextOut)
                      {
			if (rfo.prfnt->fobj.flFontType & (FO_GRAY16 | FO_CLEARTYPE_X))
                        {
                            pSurf->pdcoAA = &dco;
                        }
                      }
                      else
                      {

                        if
                        (
                            (rfo.prfnt->fobj.flFontType & FO_GRAY16) &&
                            (!(dco.flGraphicsCaps() & GCAPS_GRAY16) ||
                              (rfo.prfnt->fobj.flFontType & FO_CLEARTYPE_X))
                        )
                        {

                          // Inform SpTextOut that this call came from GreExtTextOutW
                          // for the purpose of rendering anti aliased text on a device
                          // that does not support it. Remember to set this to zero
                          // before releasing the surface to other users.

			  if (pfnTextOut != EngTextOut)
			      pSurf->pdcoAA = &dco;

                          pfnTextOut = SpTextOut;
                        }
                      } // if (pfnTextOut == SpTextOut) else

                      if (flState & TS_DRAW_OUTLINE_FONT)
                      {

#ifdef FE_SB
                        if( to.bLinkedGlyphs() )
                        {
                            if( ! bProxyDrvTextOut
                                  (
                                    dco,
                                    pSurf,
                                    to,
                                    co,
                                    (RECTL*) NULL,
                                    (RECTL*) NULL,
                                    (BRUSHOBJ*) peboText,
                                    (BRUSHOBJ*) peboBackground,
                                    pptlBO,
                                    rfo,
                                    &pdo,
                                    dco.flGraphicsCaps(),
                                    &rclExclude
                                   ))
                            {
                                flState = 0;
                            }
                        }
                        else
                        {
#endif

                        PATHMEMOBJ po;
                        if ((!po.bValid())        ||
                            (!to.bTextToPath(po, dco)) ||
                            (  ( po.cCurves > 1 ) &&
                               !po.bTextOutSimpleFill(dco,
                                                      rfo,
                                                      &pdo,
                                                      pSurf,
                                                      &co,
                                                      (BRUSHOBJ *)peboText,
                                                      pptlBO,
                                                      (R2_COPYPEN | (R2_COPYPEN << 8)),
                                                      WINDING)))
                        {
                          flState = 0;
                        }
                        }
                      }
                      else // if (flState & TS_DRAW_OUTLINE_FONT)
                      {
                        if (flState & TS_DRAW_COMPLEX_UNDERLINES)
                        {
                          INC_SURF_UNIQ(pSurf);

                          // Unfortunately, many drivers destroy the coordinates in our
                          // GLYPHPOS array.  This means that any complex underlining has
                          // to be calculated now.

                          PATHMEMOBJ po;

                          if ((!po.bValid())               ||
                              (!to.bExtraRectsToPath(po))  ||
#ifdef FE_SB
                                    ((to.bLinkedGlyphs() ) ?
                                      (!bProxyDrvTextOut
                                        (
                                            dco,
                                            pSurf,
                                            to,
                                            co,
                                            prclExtraRects,
                                            prclBackground,
                                            peboText,
                                            peboBackground,
                                            pptlBO,
                                            rfo,
                                            (PDEVOBJ *) NULL,
                                            (FLONG) 0L,
                                            &rclExclude
                                        )) :
#endif

                              (!((*pfnTextOut)
                                      (pSurf->pSurfobj(),
                                       (STROBJ *) &to,
                                       rfo.pfo(),
                                       &co,
                                       prclExtraRects,
                                       prclBackground,
                                       (BRUSHOBJ *)peboText,
                                       (BRUSHOBJ *)peboBackground,
                                       pptlBO,
                                       mix)))

                              ) ||
                              (!po.bTextOutSimpleFill(dco,
                                                      rfo,
                                                      &pdo,
                                                      pSurf,
                                                      &co,
                                                      (BRUSHOBJ *)peboText,
                                                      pptlBO,
                                                      (R2_COPYPEN | (R2_COPYPEN << 8)),
                                                      WINDING)))
                          {
                              flState = 0;
                          }

                          flState &= ~TS_DRAW_COMPLEX_UNDERLINES;
                        } // if (flState & TS_DRAW_COMPLEX_UNDERLINES)
                        else
                        {
                          // Inc target surface uniqueness

                          INC_SURF_UNIQ(pSurf);

#ifdef FE_SB
                            if( to.bLinkedGlyphs() )
                            {
                                if( !bProxyDrvTextOut
                                  (
                                    dco,
                                    pSurf,
                                    to,
                                    co,
                                    prclExtraRects,
                                    prclBackground,
                                    peboText,
                                    peboBackground,
                                    pptlBO,
                                    rfo,
                                    &pdo,
                                    (FLONG) 0,
                                    &rclExclude
                                  ))
                                {
                                    flState = 0;
                                }
                            }
                            else
                            {
#endif
                                rfo.PreTextOut(dco);
                                if (!(*pfnTextOut)(pSurf->pSurfobj(),
                                                              (STROBJ *) &to,
                                                              rfo.pfo(),
                                                              &co,
                                                              prclExtraRects,
                                                              prclBackground,
                                                              (BRUSHOBJ *)peboText,
                                                              (BRUSHOBJ *)peboBackground,
                                                              pptlBO,
                                                              mix))
                                {
                                  flState = 0;
                                }
                                rfo.PostTextOut(dco);
                            }
                        } // if (flState & TS_DRAW_COMPLEX_UNDERLINES) else
                      } // if (flState & TS_DRAW_OUTLINE_FONT) else

                      ASSERTGDI(pSurf != NULL, "pSurf null after EngTextOut");
                      /* we have seen pSurf being null with privates binaries */
                      if (pSurf != NULL)
                          pSurf->pdcoAA = 0;    // clear AA state;

                    } // if (flState & TS_DRAW_VECTOR_FONT) else

                    // Simulate extra rectangles.

                    if (prclSimExtra != (ERECTL *) NULL)
                    {
                      ERECTL erclOrg;
                      erclOrg = co.erclExclude();

                      // Inc target surface uniqueness

                      INC_SURF_UNIQ(pSurf);

                      for (; !prclSimExtra->bEmpty(); prclSimExtra++)
                      {
                        // intersect the dest rect with the clip rect and set it in co

                        co.erclExclude().left   = max(erclOrg.left,prclSimExtra->left);
                        co.erclExclude().right  = min(erclOrg.right,prclSimExtra->right);

                        if (co.erclExclude().left >= co.erclExclude().right)
                            continue;

                        co.erclExclude().top    = max(erclOrg.top,prclSimExtra->top);
                        co.erclExclude().bottom = min(erclOrg.bottom,prclSimExtra->bottom);

                        if (co.erclExclude().top >= co.erclExclude().bottom)
                        {
                            continue;
                        }

                        //
                        // not completely clipped, do the bitblt
                        //

                        TextOutBitBlt(pSurf,
                                      rfo,
                                      (SURFOBJ *)  NULL,
                                      (SURFOBJ *)  NULL,
                                      &co,
                                      NULL,
                                      &co.rclBounds,
                                      (POINTL *)  NULL,
                                      (POINTL *)  NULL,
                                      (BRUSHOBJ *)peboText,
                                      pptlBO,
                                      0x0000f0f0);
                      }

                      co.erclExclude() = erclOrg;
                    } // if (prclSimExtra != (ERECTL *) NULL)
                } // if (flState & TS_DRAW_TEXT)

                //
                // Handle complex cases of strikeout and underlines.
                //

                if (flState & TS_DRAW_COMPLEX_UNDERLINES)
                {

                  PATHMEMOBJ po;

                  if (po.bValid())
                  {
                    if (!to.bExtraRectsToPath(po) ||
                        !po.bTextOutSimpleFill(dco,
                                               rfo,
                                               &pdo,
                                               pSurf,
                                               &co,
                                               (BRUSHOBJ *)peboText,
                                               pptlBO,
                                               (R2_COPYPEN | (R2_COPYPEN << 8)),
                                               WINDING))
                    {
                      flState = 0;
                    }
                  }
                  else // if (po.bValid())
                  {
                    flState = 0;
                  }

                } // if (flState & TS_DRAW_COMPLEX_UNDERLINES)

              } // if (pSurf != NULL)

            } // if (!co.erclExclude().bEmpty())

          } // if (!rclExclude.bEmpty())
        } // else if (dco.pdc->bActive())
    }
    else // if (((flOpts == 0) ||
         // ((prcl != (RECT *) NULL) &&
         // ((flOpts & ~(ETO_CLIPPED | ETO_OPAQUE)) == 0)))
         // && !(dco.pdc->bActive() && (flOpts & ETO_CLIPPED)))
    {
      WARNING1("Invalid flags for ExtTextOut.\n");
      flState = 0;
    }

  }
  else
  {
    flState = 0;
  }

  //
  // flState is filled with all the stuff we need to do.
  // If it is 0 we failed.
  //

  // return(flState /* != 0 */);
  return(flState != 0);
}

/******************************Public*Routine******************************\
* BOOL GreGetTextExtentW
*
* Computes the size of the text box in logical coordinates.  The text box
* has sides which are parallel to the baseline of the text and its ascent
* direction.  The height is measured in the ascent direction.  The width
* is measured in the baseline direction.  This definition does not change
* for transformed text.
*
* History:
*  Sat 14-Mar-1992 05:39:04 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

#define PDXNULL (LONG *) NULL

BOOL GreGetTextExtentW(
    HDC    hdc,    // device context
    LPWSTR pwsz,   // pointer to a UNICODE text string
    int    cwc,    // Count of chars.
    PSIZE  pSize,  // address to return the dimensions of the string to
    UINT   fl      // internal flags
)
{
    BOOL bRet = FALSE;

    if (cwc == 0)
    {
        //
        // Nothing to do, but we do not fail.
        //

        pSize->cx = 0;
        pSize->cy = 0;
        bRet = TRUE;
    }
    else
    {
        //
        // Lock the DC and set the new attributes.
        //

        DCOBJ dco(hdc);

        if (dco.bValid())
        {
            RFONTOBJ rfo(dco,FALSE, (fl & GGTE_GLYPH_INDEX) ? RFONT_TYPE_HGLYPH : RFONT_TYPE_UNICODE);

            if (rfo.bValid())
            {
            // fix up glyph indices for bitmap fonts

                if (rfo.prfnt->flType & RFONT_TYPE_HGLYPH)
                    rfo.vFixUpGlyphIndices((USHORT *)pwsz, cwc);

                // If we have (escapement != orientation) we return the extents of the
                // bounding parallelogram.  This is not Windows compatible, but then
                // Windows can't draw it either.

                LONG lEsc = dco.pdc->lEscapement(); // Only read this after RFONTOBJ!

                if ((lEsc != (LONG)rfo.ulOrientation()) &&
                    ((rfo.iGraphicsMode() != GM_COMPATIBLE) ||
                        (rfo.prfnt->flInfo & FM_INFO_TECH_STROKE)))
                {
                    //
                    // Get the transform from the DC.
                    //

                    EXFORMOBJ xo(dco,WORLD_TO_DEVICE);

                    //
                    // The STROBJ will now compute the text alignment, character positions,
                    // and TextBox.
                    //


                    ESTROBJ to(pwsz,
                               cwc,
                               dco,
                               rfo,
                               xo,
                               PDXNULL,FALSE,
                               lEsc,
                               dco.pdc->lTextExtra(),
                               dco.pdc->lBreakExtra(),
                               dco.pdc->cBreak(),
                               0,
                               0,
                               0,
                               PDXNULL);

                    if (to.bValid())
                    {
                        //
                        // Transform the TextBox to logical coordinates.
                        //

                        bRet = to.bTextExtent(rfo,lEsc,pSize);

                    }
                }
                else
                {
                    //
                    // At this point we have (escapement == orientation) so we can just run
                    // some pretty trivial code.
                    //

                    bRet = rfo.bTextExtent(dco,
                                           pwsz,
                                           cwc,
                                           lEsc,
                                           dco.pdc->lTextExtra(),
                                           dco.pdc->lBreakExtra(),
                                           dco.pdc->cBreak(),
                                           fl,
                                           pSize);

                    //
                    // finally if this is compatible mode and a vector font, do win31
                    // crazyness about text extent: "rotate" cx and cy by esc vector.
                    // This is totally crazy, and is different from what win31 is doing
                    // for tt, but it turns out that quatro pro for windows has figured
                    // this out and that they use this "feature" [bodind]
                    //

                    if (bRet                                        &&
                        lEsc                                        &&
                        (dco.pdc->iGraphicsMode() == GM_COMPATIBLE) &&
                        !dco.pdc->bUseMetaPtoD()                    &&
                        (rfo.prfnt->flInfo & FM_INFO_TECH_STROKE))
                    {
                        EVECTORFL evfl((LONG)pSize->cx, (LONG)pSize->cy);
                        EFLOATEXT efAngle = lEsc;
                        efAngle /= (LONG)10;

                        MATRIX mx;

                        mx.efM11 = efCos(efAngle);
                        mx.efM11.vAbs();
                        mx.efM22 = mx.efM11;

                        mx.efM12 = efSin(efAngle);
                        mx.efM12.vAbs();
                        mx.efM21 = mx.efM12;
                        mx.efDx.vSetToZero();
                        mx.efDy.vSetToZero();

                        EXFORMOBJ xoExt(&mx,COMPUTE_FLAGS | XFORM_FORMAT_LTOL);

                        if ((bRet = xoExt.bXform(evfl)) != FALSE)
                        {
                            evfl.x.vAbs();
                            evfl.y.vAbs();
                            bRet = evfl.bToPOINTL(*(POINTL *)pSize);
                        }
                    }
                }
            }
            else
            {
                WARNING("gdisrv!GreGetTextExtentW(): could not lock HRFONT\n");
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* RFONTOBJ::bTextExtent (pwsz,lExtra,lBreakExtra,cBreak,cc,fl,psizl)       *
*                                                                          *
* A quick function to compute text extents on the server side.  Only       *
* handles the case where (escapement==orientation).  Call the ESTROBJ      *
* version for the other very hard case.                                    *
*                                                                          *
*  Thu 14-Jan-1993 04:00:57 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.  OK, so it's a blatant ripoff of my bComputeTextExtent from    *
* the client side.  Fine.                                                  *
\**************************************************************************/

#define CTE_BATCH 82

BOOL RFONTOBJ::bTextExtent(
    XDCOBJ     &dco,
    LPWSTR    pwsz,
    int       cc,
    LONG      lEsc,
    LONG      lExtra,
    LONG      lBreakExtra,
    LONG      cBreak,
    UINT      fl,
    SIZE     *psizl
)
{
    LONG      fxBasicExtent;
    int       ii, cNoBackup;
    FIX       fxCharExtra = 0;
    FIX       fxBreakExtra;
    FIX       fxExtra = 0;
    GLYPHPOS  agpos[CTE_BATCH];  // Default set of GLYPHPOS structures.

// Compute the basic extent.  Batch the glyphs through our array.

    if (lExtra)
    {
       fxCharExtra = lCvt(efWtoDBase(),lExtra);
       cNoBackup = 0;
    }

#ifndef FE_SB
    if(lCharInc() == 0)
#endif
    {
        fxBasicExtent = 0;

    // NOTE PERF: This is the loop that PaulB would like to optimize with a
    // special cache access function.  Why create the GLYPHPOS
    // array? [chuckwh]

        int    cBatch;
        int    cLeft = cc;
        WCHAR *pwc = pwsz;

        while (cLeft)
        {
            cBatch = cLeft;
            if (cBatch > CTE_BATCH)
                cBatch = CTE_BATCH;

        // Get the glyph data.

            if (!bGetGlyphMetrics(cBatch,agpos,pwc,&dco))
                return(FALSE);

        // Sum the advance widths.

            for (ii=0; ii<cBatch; ii++)
            {
                fxBasicExtent += ((EGLYPHPOS *) &agpos[ii])->pgd()->fxD;

            // the layout code won't allow lExtra to backup a character behind
            // its origin so keep track of the number of times this happens

                if( ( fxCharExtra < 0 ) &&
                    ( ((EGLYPHPOS *) &agpos[ii])->pgd()->fxD + fxCharExtra <= 0 ) )
                {
                    cNoBackup += 1;
                }
            }

            cLeft -= cBatch;
            pwc   += cBatch;

        }
    }

// Adjust for CharExtra.

    if (lExtra)
    {
        PDEVOBJ pdo(prfnt->hdevConsumer);
        ASSERTGDI(pdo.bValid(), "bTextExtentRFONTOBJ(): PDEVOBJ constructor failed\n");

        if ( (fl & GGTE_WIN3_EXTENT) && pdo.bDisplayPDEV()
             && (!(prfnt->flInfo & FM_INFO_TECH_STROKE)) )
            fxExtra = fxCharExtra * ((lExtra > 0) ? cc : (cc - 1));
        else
            fxExtra = fxCharExtra * ( cc - cNoBackup );
    }

// Adjust for lBreakExtra.

    if (lBreakExtra && cBreak)
    {
    // Track down the break character.

        PFEOBJ pfeo(ppfe());
        IFIOBJ ifio(pfeo.pifi());

    // Compute the extra space in device units.

        fxBreakExtra = lCvt(efWtoDBase(),lBreakExtra) / cBreak;

    // Windows won't let us back up over a break.  Set up the BreakExtra
    // to just cancel out what we've already got.

        if (fxBreakExtra + fxBreak() + fxCharExtra < 0)
            fxBreakExtra = -(fxBreak() + fxCharExtra);

    // Add it up for all breaks.

        WCHAR wcBreak = (fl & GGTE_GLYPH_INDEX)?
                        (WCHAR)hgBreak():ifio.wcBreakChar();

        WCHAR *pwc = pwsz;
        for (ii=0; ii<cc; ii++)
        {
            if (*pwc++ == wcBreak)
                fxExtra += fxBreakExtra;
        }
    }

// Add in the extra stuff.

    fxBasicExtent += fxExtra;

// Add in the overhang for font simulations.

    if (fl & GGTE_WIN3_EXTENT)
        fxBasicExtent += lOverhang() << 4;

// Transform the result to logical coordinates.

    if (efDtoWBase_31().bIs1Over16())
        psizl->cx = (fxBasicExtent + 8) >> 4;
    else
        psizl->cx = lCvt(efDtoWBase_31(),fxBasicExtent);

    if (efDtoWAscent_31().bIs1Over16())
        psizl->cy = lMaxHeight();
    else
        psizl->cy = lCvt(efDtoWAscent_31(),lMaxHeight() << 4);


#ifdef FE_SB
    if( gbDBCSCodePage &&                   // Only in DBCS system locale
        (iGraphicsMode() == GM_COMPATIBLE)  && // We are in COMPAPIBLE mode
        !(flInfo() & FM_INFO_ARB_XFORMS) && // The driver couldnt do arbitrary rotations
        !(flInfo() & FM_INFO_TECH_STROKE) && // The driver is not vector driver
         (flInfo() & FM_INFO_90DEGREE_ROTATIONS) && // Driver does 90 degree rotations
         (lEsc == 900L || lEsc == 2700L)  // Current font Escapemant is 900 or 2700
      )
    {
        LONG lSwap = psizl->cx;
        psizl->cx  = psizl->cy;
        psizl->cy  = lSwap;
    }
#endif

    return(TRUE);
}

/******************************Public*Routine******************************\
* GreSetTextJustification (hdc,lBreakExtra,cBreak)                         *
*                                                                          *
* Sets the amount of extra spacing we'd like to add for each break (space) *
* character to (lBreakExtra/cBreak) in logical coordinates.                *
*                                                                          *
* History:                                                                 *
*  Fri 13-Mar-1992 02:25:12 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL APIENTRY
NtGdiSetTextJustification(
    HDC hdc,
    int lBreakExtra, // Space in logical units to be added to the line.
    int cBreak       // Number of break chars in the line.
)
{
    BOOL bRet;

    DCOBJ dco(hdc);

    if ((bRet = dco.bValid()) != FALSE)
    {
        dco.pdc->lBreakExtra(lBreakExtra);
        dco.pdc->cBreak(cBreak);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL GreGetTextExtentExW                                                 *
*                                                                          *
* Determines the number of characters in the input string that fit into    *
* the given max width (with the widths computed along the escapement       *
* vector).  The partial widths (the distance from the string origin to     *
* a given character with the width of that character included) for each of *
* character.                                                               *
*                                                                          *
* Returns:                                                                 *
*   TRUE if successful, FALSE otherwise.                                   *
*                                                                          *
* History:                                                                 *
*  Sat 14-Mar-1992 06:03:32 -by- Charles Whitmer [chuckwh]                 *
* Rewrote with new ESTROBJ technology.                                     *
*                                                                          *
*  06-Jan-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL GreGetTextExtentExW(
    HDC     hdc,            // device context
    LPWSTR  pwsz,           // pointer to a UNICODE text string
    COUNT   cwc,            // count of WCHARs in the string
    ULONG   dxMax,          // maximum width to return
    COUNT  *pcChars,        // number of chars that fit in dxMax
    PULONG  pdxOut,         // offset of each character from string origin
    LPSIZE  pSize,          // return height and width of string
    FLONG   fl
)
{
    BOOL bRet = FALSE;
    PVOID pv;

#ifdef DUMPCALL
    DbgPrint("\nGreGetTextExtentExW("                       );
    DbgPrint("\n    HDC         hdc     = %-#8lx\n", hdc    );
    DbgPrint("\n    LPWSTR      pwsz    = %-#8lx -> \"%ws\"\n", pwsz ,pwsz  );
    DbgPrint("\n    COUNT       cwc     = %d\n",     cwc    );
    DbgPrint("\n    ULONG       dxMax   = %-#8lx\n", dxMax  );
    DbgPrint("\n    COUNT      *pcChars = %-#8lx\n", pcChars);
    DbgPrint("\n    PULONG      pdxOut  = %-#8lx\n", pdxOut );
    DbgPrint("\n    LPSIZE      pSize   = %-#8lx\n", pSize  );
    DbgPrint("\n    )\n"                                    );
#endif

// Parameter validation.

    if ( ((pwsz == (LPWSTR) NULL) && (cwc != 0))
         || (pSize == (LPSIZE) NULL) )
    {
        WARNING("gdisrv!GreGetTextExtentExW(): invalid parameter\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

// Early out.

    if (cwc == 0L)              // Nothing to do, but we do not fail.
    {
        if ( pcChars != (COUNT *) NULL )
        {
            *pcChars = 0;
        }

        return(TRUE);
    }

// Lock the DC and set the new attributes.

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        WARNING("gdisrv!GreGetTextExtentExW(): invalid HDC\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }
    else
    {
    // Get the transform.

        EXFORMOBJ xo(dco, WORLD_TO_DEVICE);

    // Realize font and get the simulation flags and escapement.

        RFONTOBJ rfo(dco, FALSE, (fl & GTEEX_GLYPH_INDEX) ? RFONT_TYPE_HGLYPH : RFONT_TYPE_UNICODE);
        if (!rfo.bValid())
        {
            WARNING("gdisrv!GreGetTextExtentExW(): could not lock HRFONT\n");
        }
        else
        {
            if (rfo.prfnt->flType & RFONT_TYPE_HGLYPH)
                rfo.vFixUpGlyphIndices((USHORT *)pwsz, cwc);

        // If there is no pdxOut buffer provided, but we still need one to compute the
        // number of characters that fit (pcChars not NULL), then we will have to
        // allocate one of our own.

        #define DXOUTLEN 40

            ULONG dxOut[DXOUTLEN];
            PULONG pdxAlloc = NULL;

            if ((pdxOut == (PULONG) NULL) && (pcChars != (COUNT *) NULL))
            {
                if (cwc <= DXOUTLEN)
                {
                    pdxOut = &dxOut[0];
                }
                else
                {
                    if ((pdxAlloc = (PULONG) PALLOCMEM(cwc * sizeof(ULONG), 'txtG')) == (PULONG) NULL)
                    {
                        WARNING("gdisrv!GreGetTextExtentExW(): could not alloc temp buffer\n");
                        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                    }
                    pdxOut = pdxAlloc;
                }
            }

        // The STROBJ will now compute the text alignment, character positions,
        // and TextBox.

            ESTROBJ to(
                       pwsz,cwc,
                       dco,
                       rfo,
                       xo,PDXNULL,FALSE,      // xo, PDXNULL, bPdy = FALSE
                       dco.pdc->lEscapement(),
                       dco.pdc->lTextExtra(),
                       dco.pdc->lBreakExtra(),
                       dco.pdc->cBreak(),
                       0,0,0,(LONG *) pdxOut
                      );

            if (to.bValid())
            {

            // Transform the TextExtent to logical coordinates.  Because this is a
            // new NT function, we need not worry about the extent compatibility hack.

                if (to.bTextExtent(rfo,0L,pSize))
                {

                // Count number of characters that fit in the max. width.
                // If pcChars is NULL, we skip this and ignore the dxMax limit.

                    if (pcChars && pdxOut)
                    {
                        ULONG c;

                        for (c=0; c<cwc && *pdxOut<=dxMax; c++,pdxOut++)
                        {}

                        *pcChars = c;
                    }

                    bRet = TRUE;
                }
            }

        // Free temp buffer.

            if (pdxAlloc)
                VFREEMEM(pdxAlloc);
        }
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* BOOL GreConsoleTextOut
*
* Write text with no spacing and alignment options, thereby saving a ton
* of time.
*
* History:
*  Fri 12-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Smaller and Faster
*
*  Wed 16-Sep-1992 17:36:17 -by- Charles Whitmer [chuckwh]
* Duplicated GrePolyTextOut, and then deleted the unneeded code.
\**************************************************************************/

extern "C" BOOL GreConsoleTextOut(
    HDC        hdc,
    POLYTEXTW *lpto,            // Ptr to array of polytext structures
    UINT       nStrings,        // number of polytext structures
    RECTL     *prclBounds
)
{
    // make sure CSR is calling us

    if (PsGetCurrentProcess() != gpepCSRSS)
        return(FALSE);

    //
    // Assume we will succeed, set Failure if we don't
    //

    BOOL bRet = TRUE;

    //
    // Lock the DC.
    //

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        //
        // Accumulate bounds.  We can do this before knowing if
        // the operation is successful because bounds can be loose.
        //

        if (dco.bAccum())
            dco.erclBounds() |= *prclBounds;

        //
        // Lock the Rao region.
        //

        DEVLOCKOBJ dlo;

        if (dlo.bLock(dco))
        {
            //
            // Locate the font realization.
            //

            RFONTOBJ rfo;

            rfo.vInit(dco,FALSE);

            if (rfo.bValid() && !rfo.bPathFont())
            {
                POINTL   ptlOrigin;
                ptlOrigin = dco.eptlOrigin();
                SURFACE *pSurf = dco.pSurface();
                XEPALOBJ palDest(pSurf->ppal());
                XEPALOBJ palDestDC(dco.ppal());
                POINTL   *pptlBO = &dco.pdc->ptlFillOrigin();
                EBRUSHOBJ *peboText = dco.peboText();
                EBRUSHOBJ *peboBackground = dco.peboBackground();

                BOOL bDitherText = FALSE;
                if ( dco.flGraphicsCaps() & GCAPS_ARBRUSHTEXT )
                {
                  // Even if a printer driver sets GCAPS_ARBRUSHTEXT, we
                  // can't allow vector fonts to be dithered.

                  bDitherText = (!rfo.bPathFont() || rfo.bReturnsOutlines());

                  // We always dirty the text brush if ARBRUSHTEXT is set to
                  // catch the cases where we transition between vector and
                  // non-vector fonts but keep the same brush -- if we didn't
                  // do this, we might try to use a cached, dithered brush
                  // after switching from a TrueType font to a vector font.

                  dco.ulDirtyAdd(DIRTY_TEXT);

                  // Get through the are-you-really-dirty check in vInitBrush:

                  peboText->vInvalidateUniqueness();
                }

                if ( dco.bDirtyBrush(DIRTY_TEXT|DIRTY_BACKGROUND) )
                {
                  if ( dco.bDirtyBrush(DIRTY_TEXT) )
                  {
                    peboText->vInitBrush(dco.pdc,
                                         gpbrText,
                                         palDestDC, palDest,
                                         pSurf,
                                         bDitherText);
                  }

                  if ( dco.bDirtyBrush(DIRTY_BACKGROUND) )
                  {
                    peboBackground->vInitBrush(
                                     dco.pdc,
                                     gpbrBackground,
                                     palDestDC, palDest, pSurf,
                                     (dco.flGraphicsCaps() & GCAPS_ARBRUSHOPAQUE) ?
                                     TRUE : FALSE);
                  }
                  dco.vCleanBrush(DIRTY_TEXT|DIRTY_BACKGROUND);
                }

                //
                // Compute the clipping complexity and maybe reduce the exclusion
                // rectangle. The bounding rectangle must be converted to Screen
                // coordinates.
                //

                ERECTL rclExclude;

                rclExclude.left   = prclBounds->left   + ptlOrigin.x;
                rclExclude.right  = prclBounds->right  + ptlOrigin.x;
                rclExclude.top    = prclBounds->top    + ptlOrigin.y;
                rclExclude.bottom = prclBounds->bottom + ptlOrigin.y;

                ECLIPOBJ co(
                     dco.prgnEffRao(),
                     rclExclude,
                     (rfo.prfnt->fobj.flFontType & FO_CLEARTYPE_X) ? CLIP_FORCE : CLIP_NOFORCE
                     );

                rclExclude = co.erclExclude();

                //
                // Check the destination which is reduced by clipping.
                //

                if (!rclExclude.bEmpty())
                {
                    DEVEXCLUDEOBJ dxo(dco,&rclExclude,&co);

                    //
                    // We now begin the 'Big Loop'.  We will pass thru this loop once for
                    // each entry in the array of PolyText structures.  Increment the
                    // pSurface once before we enter.  We assume success from here on out
                    // unless we hit a failure.
                    //

                    INC_SURF_UNIQ(pSurf);
                    PFN_DrvBitBlt  pfnBitBlt  = pSurf->pfnBitBlt();

                    PFN_DrvTextOut pfnTextOut;

                    if
                    (
                        ((rfo.prfnt->fobj.flFontType & FO_GRAY16) && !(dco.flGraphicsCaps() & GCAPS_GRAY16)) ||
                        (rfo.prfnt->fobj.flFontType & FO_CLEARTYPE_X)
                    )
                    {
                        pfnTextOut = SpTextOut;
                        pSurf->pdcoAA = &dco; // make sure this is needed
                    }
                    else
                    {
                        pfnTextOut = pSurf->pfnTextOut();
                    }

                    ERECTL  rclInput;

                    for (POLYTEXTW *ppt = lpto; ppt < lpto + nStrings; ppt += 1)
                    {
                        //
                        // Process the rectangle in prcl.
                        //

                        rclInput.left   = ppt->rcl.left   + ptlOrigin.x;
                        rclInput.right  = ppt->rcl.right  + ptlOrigin.x;
                        rclInput.top    = ppt->rcl.top    + ptlOrigin.y;
                        rclInput.bottom = ppt->rcl.bottom + ptlOrigin.y;

                        //
                        // Process the string.
                        //

                        if (ppt->n)
                        {
                            //
                            // The STROBJ will now compute the text alignment,
                            // character positions, and TextBox.
                            //

                            ESTROBJ to;

                            to.vInitSimple(
                                           (PWSZ) ppt->lpstr,
                                           ppt->n,
                                           dco,
                                           rfo,ppt->x+ptlOrigin.x,
                                           ppt->y+ptlOrigin.y,NULL);

                            if (to.bValid())
                            {
                            // Draw the text.
#ifdef FE_SB
                                if( to.bLinkedGlyphs() )
                                {
                                    // If there are linked glyphs, then the bounds of the
                                    // glyphs (to.rclBkGround) might exceed the bounds of the
                                    // clipping object (co.rclBounds).  If so, then we need
                                    // to increase the complexity of the clipping object from
                                    // DC_TRIVIAL to DC_RECT.
                                    if ((co.iDComplexity == DC_TRIVIAL) &&
                                        ((to.rclBkGround.left   < co.rclBounds.left)  ||
                                         (to.rclBkGround.right  > co.rclBounds.right) ||
                                         (to.rclBkGround.top    < co.rclBounds.top)   ||
                                         (to.rclBkGround.bottom > co.rclBounds.bottom)))
                                    {
                                        co.iDComplexity = DC_RECT;
                                    }

                                    bProxyDrvTextOut
                                    (
                                        dco,
                                        pSurf,
                                        to,
                                        co,
                                        (RECTL *) NULL,
                                        &rclInput,
                                        peboText,
                                        peboBackground,
                                        pptlBO,
                                        rfo,
                                        (PDEVOBJ*)NULL,
                                        (FLONG) 0L,
                                        &rclExclude
                                    );
                                }
                                else
                                {
#endif

                                (*pfnTextOut)(pSurf->pSurfobj(),
                                              (STROBJ *) &to,
                                              rfo.pfo(),
                                              &co,
                                              (RECTL *) NULL,
                                              &rclInput,
                                              peboText,
                                              peboBackground,
                                              pptlBO,
                                              (R2_COPYPEN | (R2_COPYPEN << 8)));
                                }
                            }
                            else
                            {
                                bRet = FALSE;
                                break;
                            }
                        }
                        else
                        {
                        // intersect the dest rect with the clip rect and set it in co

                        // we can only get away with touching co.rclBounds after
                        // the ECLIPOBJ constructor because of two reasons:
                        // a) the target rectangle passed to bitblt is contained in the
                        //    original bounds set by ECLIPOBJ, being the intersection
                        //    of the origianal bounds with THE intended target rectangle.
                        // b) clipping complexity may have changed when we changed
                        //    co.erclExclude, but it only could have gotten simpler,
                        //    so at worst in those rare situations we would not go
                        //    through the optimal code path.
                        // By changing clipping bounds we accomplish that no intersection
                        // of the target rectangle with clipping region rectangle is emtpy
                        // relieving the driver of extra work [bodind]

                            co.erclExclude().left   = max(rclExclude.left,rclInput.left);
                            co.erclExclude().right  = min(rclExclude.right,rclInput.right);

                            co.erclExclude().top    = max(rclExclude.top,rclInput.top);
                            co.erclExclude().bottom = min(rclExclude.bottom,rclInput.bottom);

                            // if not clipped, Just paint the rectangle.

                            if ((co.erclExclude().left < co.erclExclude().right) &&
                                (co.erclExclude().top < co.erclExclude().bottom))
                            {

                                (*pfnBitBlt)(pSurf->pSurfobj(),
                                            (SURFOBJ *)  NULL,
                                            (SURFOBJ *)  NULL,
                                            &co,
                                            NULL,
                                            &co.rclBounds,
                                            (POINTL *)   NULL,
                                            (POINTL *)   NULL,
                                            (BRUSHOBJ *)peboBackground,
                                            pptlBO,
                                            0x0000f0f0);
                            }
                            co.erclExclude() = rclExclude;
                        }

                    }
                    pSurf->pdcoAA = NULL;
                }

            }
            else
            {
                WARNING("gdisrv!GreExtTextOutW(): could not lock HRFONT\n");
                bRet = FALSE;
            }
        }
        else
        {
            bRet = dco.bFullScreen();
        }
    }
    else
    {
        bRet = FALSE;
        WARNING("Invalid DC passed to GreConsoleTextOut\n");
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* DWORD GreSetTextAlign (hdc,flOpts)                                       *
*                                                                          *
* Set the text alignment flags in the DC.                                  *
*                                                                          *
* History:                                                                 *
*                                                                          *
*  Tue 28-Dec-1993 -by- Patrick Haluptzok [patrickh]                       *
* smaller and faster                                                       *
*                                                                          *
*  18-Dec-1990 -by- Donald Sidoroff [donalds]                              *
* Wrote it.                                                                *
\**************************************************************************/

UINT APIENTRY GreSetTextAlign(HDC hdc,UINT flOpts)
{
    ULONG    ulReturn = 0;

    XDCOBJ dco( hdc );

    if(!dco.bValid())
    {
        WARNING("Invalid DC or offset passed to GreSetTextAlign\n");
    }
    else
    {
        ulReturn = (UINT)dco.pdc->lTextAlign();
        dco.pdc->lTextAlign(flOpts);

        if (MIRRORED_DC(dco.pdc) && ((flOpts & TA_CENTER) != TA_CENTER)) {
            flOpts = flOpts ^ TA_RIGHT;
        }

        dco.pdc->flTextAlign(flOpts & (TA_UPDATECP | TA_CENTER | TA_BASELINE));
        dco.vUnlockFast();
    }

    return((UINT)ulReturn);
}


/******************************Public*Routine******************************\
* int GreSetTextCharacterExtra (hdc,lExtra)                                *
*                                                                          *
* Sets the amount of intercharcter spacing for TextOut.                    *
*                                                                          *
* History:                                                                 *
*  Tue 28-Dec-1993 -by- Patrick Haluptzok [patrickh]                       *
* smaller and faster                                                       *
*                                                                          *
*  Tue 08-Jan-1991 -by- Bodin Dresevic [BodinD]                            *
* Update: bug, used to return lExtra instead of lOld, transform stuff      *
* deleted since it will be done at the TextOut time.                       *
*                                                                          *
*  18-Dec-1990 -by- Donald Sidoroff [donalds]                              *
* Wrote it.                                                                *
\**************************************************************************/

int APIENTRY GreSetTextCharacterExtra(HDC hdc,int lExtra)
{
    ULONG ulOld = 0x80000000;

    XDCOBJ dco( hdc );

    if(!dco.bValid())
    {
        WARNING("Invalid DC or offset passed to GreSetTextCharacterExtra\n");
    }
    else
    {
        ulOld = dco.pdc->lTextExtra();
        dco.pdc->lTextExtra(lExtra);
        dco.vUnlockFast();
    }

    return(ulOld);
}


/******************************Public*Routine******************************\
* int GreGetTextCharacterExtra (hdc)                                       *
*                                                                          *
* Gets the amount of intercharcter spacing for TextOut.                    *
*                                                                          *
*  29-Jun-1995 -by- Fritz Sands [fritzs]                                   *
* Wrote it.                                                                *
\**************************************************************************/

int APIENTRY GreGetTextCharacterExtra(HDC hdc)
{
    ULONG    ulOld = 0;

    XDCOBJ dco( hdc );

    if(!dco.bValid())
    {
        WARNING("Invalid DC or offset passed to GreGetTextCharacterExtra\n");
    }
    else
    {
        ulOld = dco.pdc->lTextExtra();
        dco.vUnlockFast();
    }

    return(ulOld);
}



/******************************Public*Routine******************************\
*
* CalcJustInArray
*
* Effects: mimics win95 asm code, except that their code does not have
* if (b_lpDx) clause, for all of their arrays are 16 bit.
*
* if GCP_JUSTIFYIN flag is set, the lpDx array on input contains
* justifying priorities.
* For latin this means the lpDx array will contain
* 0's or 1's where 0 means that the glyph at this position can not be
* used for spacing while 1 means that the glyph at this position should
* be used for spacing. If GCP_JUSTIFYIN is NOT set, than space chars ' ',
* in the input string are used to do justification.
*
* History:
*  21-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



DWORD nCalcJustInArray(
    UINT **ppJustIn,      // place to store the pointer to array
    WCHAR  Glyph,         // glyph to find
    VOID  *pvIn,          // input array
    BOOL   b_lpDx,        // input array is lpDx or pwc
    UINT   cGlyphs        // length of the input array
    )
{
    WCHAR *pwc, *pwcEnd;
    int   *pDx, *pDxEnd;
    int    iGlyph;
    COUNT  nJustIn = 0;
    UINT  *piInit;

// look for Glyph in the string

    if (b_lpDx)
    {
        iGlyph = (int)Glyph;
        pDxEnd = (int*)pvIn + cGlyphs;
        for (pDx = (int*)pvIn; pDx < pDxEnd; pDx++)
        {
            if (*pDx == iGlyph)
                nJustIn++;
        }
    }
    else
    {
        pwcEnd = (WCHAR*)pvIn + cGlyphs;
        for (pwc = (WCHAR*)pvIn; pwc < pwcEnd; pwc++)
        {
            if (*pwc == Glyph)
                nJustIn++;
        }
    }

    if ((nJustIn == 0) || // did not find any Glyphs in the string
       !(piInit = (UINT *)PALLOCMEM(nJustIn * sizeof(UINT), 'ylgG')))
    {
        *ppJustIn = NULL;
        return 0;
    }

// store locations where Glyph's are found in the input array

    UINT *pi = piInit;

    if (b_lpDx)
    {
        for (pDx = (int*)pvIn; pDx < pDxEnd; pDx++)
        {
            if (*pDx == iGlyph)
            {
                //Sundown: safe to truncate since pDxEnd = pvIn + cGlyphs
                *pi++ = (UINT)(pDx - (int*)pvIn);
            }
        }
    }
    else
    {
        for (pwc = (WCHAR*)pvIn; pwc < pwcEnd; pwc++)
        {
            if (*pwc == Glyph)
            {
                //Sundown: same as above
                *pi++ = (UINT)(pwc - (WCHAR*)pvIn);
            }
        }
    }

// return the pointer with array of locations of uiGlyphs

    *ppJustIn = piInit;
    return nJustIn;
}

/******************************Public*Routine******************************\
*
* VOID RFONTOBJ::vFixUpGlyphIndices(USHORT *pgi, UINT cgi)
*
* Effects: Windows 95 returns glyph indices for bitmap fonts that are the
*          same as ansi values. On NT glyph handles are zero based, so
*          we need to add chFirstChar to NT handles to get win95 indices
*          which is what we do in GetGlyphIndicesA/W and GetCharacterPlacement.
*          Conversely, when those indices are passed to us through
*          text routines we have to subtract chFirstChar from indices to
*          produce NT handles. This is what this routine does:
*
* History:
*  04-Mar-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vFixUpGlyphIndices(USHORT *pgi, UINT cgi)
{
    USHORT usFirst = prfnt->ppfe->pifi->chFirstChar;

    ASSERTGDI(prfnt->flType & RFONT_TYPE_HGLYPH, "vFixUpGlyphIndices\n");

    ASSERTGDI(prfnt->ppfe->pfdg, "RFONTOBJ::vFixUpGlyphIndices invalid ppfe->pfdg \n");

    if ((prfnt->ppfe->pfdg->flAccel & GS_8BIT_HANDLES) && usFirst)
    {
    // win95 does not return true glyph indicies but ansi
    // values for raster, vector, ps fonts

        for (USHORT *pgiEnd = pgi + cgi; pgi < pgiEnd; pgi++)
           *pgi -= usFirst;
    }
}

/******************************Public*Routine******************************\
*
* GreGetGlyphIndicesW (
*
* Effects: designed to emulate win95 behavior
*
* Warnings:
*
* History:
*  25-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




DWORD GreGetGlyphIndicesW (
    HDC     hdc,
    WCHAR  *pwc,
    DWORD   cwc,
    USHORT *pgi,
    DWORD   iMode,
    BOOL    bSubset
    )
{
    DWORD         dwRet = GDI_ERROR;
    HGLYPH *phg, *phgInit;
    USHORT *pgiEnd = pgi + cwc;

    XDCOBJ dco(hdc);           // Lock the DC.
    if (dco.bValid())          // Check if it's good.
    {
    // Locate the RFONT.
    // It might be better to set the type to RFONT_TYPE_HGLYPH
    // in anticipation of ETO_GLYPH_INDEX ExtTextOut calls

        RFONTOBJ rfo(dco, FALSE, RFONT_TYPE_UNICODE);

        if (rfo.bValid())
        {
            USHORT usFirst = rfo.prfnt->ppfe->pifi->chFirstChar;

        // if cwc == 0 all we are care for is the # of distinct glyph indices

            if (cwc==0)
            {
                ASSERTGDI(iMode == 0, "GreGetGlyphIndicesW parameters bogus\n");

                if (rfo.prfnt->ppfe->pifi->cjIfiExtra > offsetof(IFIEXTRA,cig))
                {
                    dwRet = ((IFIEXTRA *)(rfo.prfnt->ppfe->pifi + 1))->cig;
                }
                else
                {
                    dwRet = 0;
                }
            }
            else
            {
            // if we ever switch to 16 bit HGLYPHS in ddi, this alloc will no
            // longer be necessary [bodind]

                if (phgInit = (phg = (HGLYPH *)PALLOCMEM(cwc * sizeof(HGLYPH), 'ylgG')))
                {
                    rfo.vXlatGlyphArray(pwc, cwc, phg, iMode, bSubset);

                // separate loops for faster processing:

                    ASSERTGDI(rfo.prfnt->ppfe->pfdg, "GreGetGlyphIndicesW invalid ppfe->pfdg \n");

                    if (rfo.prfnt->ppfe->pfdg->flAccel & (GS_8BIT_HANDLES|GS_16BIT_HANDLES))
                    {
                        if ((rfo.prfnt->ppfe->pfdg->flAccel & GS_8BIT_HANDLES) && usFirst)
                        {
                        // win95 does not return true glyph indicies but ansi
                        // values for raster, vector, ps fonts

                            for ( ; pgi < pgiEnd; pgi++, pwc++, phg++)
                               *pgi = (USHORT)*phg + usFirst;
                        }
                        else
                        {
                            for ( ; pgi < pgiEnd; pgi++, pwc++, phg++)
                               *pgi = (USHORT)*phg;
                        }

                        dwRet = cwc; // can not fail any more
                    }
                    else
                    {
                        dwRet = GDI_ERROR;
                    }

                    VFREEMEM(phgInit);
                }
            }
        }

        dco.vUnlockFast();
    }
    return dwRet;
}



/******************************Public*Routine******************************\
*
* DWORD GreGetCharacterPlacementW
*
*
*
* History:
*  06-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


DWORD GreGetCharacterPlacementW(
    HDC     hdc,
    LPWSTR  pwsz,
    DWORD   nCountIn,
    DWORD   nMaxExtent,
    LPGCP_RESULTSW   pResults,
    DWORD   dwFlags
)
{
    SIZE   size;
    GCP_RESULTSW gcpw;

    DWORD nCount = nCountIn;
    DWORD dwWidthType = 0;
    int   *pDx = NULL;
    UINT  *pJustIn = NULL;
    DWORD dwJustInOff = 0; // used by calc routine for spacing
    DWORD nJustIn = 0;
    ULONG nKern = 0;
    KERNINGPAIR *pKern = NULL;
    KERNINGPAIR *pKernSave = NULL; // esential initialization
    int   nExtentLeft = 0;
    int   nExtentRem = 0;
    WORD *pwc,*pwcEnd;
    DWORD i, j;

// init size

    size.cx = size.cy = 0;

// we will only be implementing the simple version of this api,
// that is for now we will not be calling LPK dlls

    if (!pResults)
    {
        if (!GreGetTextExtentW(hdc, (LPWSTR)pwsz, (int)nCount, &size, GGTE_WIN3_EXTENT))
        {
            WARNING("GreGetCharacterPlacementW, GreGetTextExtentW failed\n");
            return 0;
        }

    // now do unthinkable win95 stuff, chop off 32 bit values to 16 bits

        return (DWORD)((USHORT)size.cx) | (DWORD)(size.cy << 16);
    }

// main code starts here. We are following win95 code as closely as possible.
// Copy pResults to the stack, for faster access I presume.

    gcpw = *pResults;

// take nCount to be the smaller of the nCounts and nGlyphs

    if (nCount > gcpw.nGlyphs)
        nCount = gcpw.nGlyphs;

// Calc pJustIn array if any

    if (dwFlags & GCP_JUSTIFY)     // if have this
        dwFlags |= GCP_MAXEXTENT;  // then must also have this

    if ((dwFlags & GCP_JUSTIFYIN) && gcpw.lpDx)
    {
    // if this flag is set, the lpDx array on input contains
    // justifying priorities so we can not continue if lpDx is not present.
    // For latin this means the lpDx array will contain
    // 0's or 1's where 0 means that the glyph at this position can not be
    // used for spacing while 1 means that the glyph at this position should
    // be used for spacing. If GCP_JUSTIFYIN is NOT set, than space chars ' ',
    // in the string are used to do justification.
    // Now that we have everything in place we can call CalcJustInArray
    // to compute the array in pJustIn

        nJustIn = nCalcJustInArray(&pJustIn, 1,
                                   (VOID *)gcpw.lpDx, TRUE ,gcpw.nGlyphs);
        if (!nJustIn)
        {
        // if this computation fails must pretend that this flag is not set

            dwFlags &= ~GCP_JUSTIFYIN;
        }
    }
    else
    {
    // either GCP_JUSTIFYIN not set or lpDx is NULL input,
    // in either case can kill the bit

            dwFlags &= ~GCP_JUSTIFYIN;
    }

// we could have either the lpDx, lpCaretPos or neither or both.  Take this
// into account and call GetTextExtentEx

// we could or could not be asking for a maximum.  If we are, put it in the
// local version of the results structure.

    if (gcpw.lpDx)
        dwWidthType += 1; // bogus way of doing it, i.e. win95 way
    if (gcpw.lpCaretPos)
        dwWidthType += 2; // bogus way of doing it, i.e. win95 way

// dwWidthType can be 0,1,2,3

    pDx = gcpw.lpDx;
    if (dwWidthType == 2) // CaretPos only
        pDx = gcpw.lpCaretPos; // reset the array pointer

// Check if the count should be reduced even further

    COUNT *pnCount = NULL;
    if (dwFlags & GCP_MAXEXTENT)
    {
        pnCount = (COUNT*)&nCount;
    }

// now call GetTextExtentEx

    if (!GreGetTextExtentExW(
                hdc,                // device context
                (LPWSTR)pwsz,       // pointer to a UNICODE text string
                nCount,             // count of WCHARs in the string
                (ULONG)nMaxExtent,  // maximum width to return
                pnCount,            // number of chars that fit in dxMax
                (PULONG)pDx,        // offset of each character from string origin
                &size,0))
    {
        if (pJustIn)
            VFREEMEM(pJustIn);
        return 0;
    }

// these few lines of code do not exist in Win95, presumably because
// their internal version of GetTextExtentExW does not return positions
// of glyphs (relative to the first glyph) but character increments along
// baseline.

    if (pDx && (nCount > 0))
    {
        for (int * pDxEnd = &pDx[nCount - 1]; pDxEnd > pDx; pDxEnd--)
        {
            *pDxEnd -= pDxEnd[-1];
        }
    }

    if ((dwFlags & GCP_MAXEXTENT) && (nCount == 0))
    {
        if (pJustIn)
            VFREEMEM(pJustIn);
        return (DWORD)((USHORT)size.cx) | (DWORD)(size.cy << 16);
    }

// Kerning:
// It only makes sense to do kerning if there are more than 2 glyphs

    if ((dwFlags & GCP_USEKERNING) && (dwWidthType != 0) && (nCount >= 2))
    {
    // Get the number of kerning pairs, if zero done

        if (nKern = GreGetKerningPairs(hdc,0,NULL))
        {
            if (pKernSave = (KERNINGPAIR*)PALLOCMEM(nKern * sizeof(KERNINGPAIR), 'txtG'))
            {
            // consistency check for GetKerningPairs:

                if (GreGetKerningPairs(hdc,nKern,pKernSave) != nKern)
                {
                // something is gone wrong, out of here

                    if (pJustIn)
                        VFREEMEM(pJustIn);
                    if (pKernSave)
                        VFREEMEM(pKernSave);

                    return 0;
                }

                KERNINGPAIR *pKernEnd = pKernSave + nKern;
                for (pKern = pKernSave; pKern < pKernEnd; pKern++)
                {
                // now go over the sting and find all the instances of
                // THIS kerning pair in the string:

                    register WORD wcFirst = pKern->wFirst;

                // note that this is the loop for trying the wcFirst
                // so that the end condition is &pwsz[nCount - 2],
                // wcSecond could go up to &pwsz[nCount - 1],
                // Either I do not understand Win95 code or they have
                // a bug in that they could fault on trying to access the
                // the second glyph in a pair in the input string

                    pwcEnd = (WORD*)pwsz + (nCount - 1);

                    for (pwc = (WORD *)pwsz; pwc < pwcEnd; pwc++)
                    {
                        if ((wcFirst == pwc[0]) && (pwc[1] == pKern->wSecond))
                        {
                        // found a kerning pair in the string,
                        // we need to modify the pDx vector for the second
                        // glyph in the kerning pair

                            pDx[pwc - (WORD *)pwsz] += pKern->iKernAmount;

                        // also adjust the return value accordingly:

                            size.cx += pKern->iKernAmount;
                        }
                    }
                } // on to the next pair

            // done with kerning pairs can free the memory

                VFREEMEM(pKernSave);

            // if we have kerned positive amounts, then the string could well
            // have gone over the preset limit. If so, reduce the number of
            // characters we found [win95 comment]

                if (dwFlags & GCP_MAXEXTENT)
                {
                    while (((DWORD)size.cx > nMaxExtent) && (nCount > 0))
                    {
                    // point to the last glyph in the string

                        size.cx -= pDx[nCount - 1];

                        nCount -= 1;
                    }

                // see if there are any glyphs left to process

                    if (nCount == 0)
                    {
                        if (pJustIn)
                            VFREEMEM(pJustIn);

                        pResults->nGlyphs = nCount;
                        pResults->nMaxFit = (int)nCount;
                        return 0;
                    }
                }
            } // no memory
        } // no kern pairs
    }

// Justification, check flags and the presence of array

    if ((dwFlags & GCP_JUSTIFY) && dwWidthType && (nCount > 0))
    {
        int *pDxEnd = &pDx[nCount - 1]; // must have nCount > 0 for this

    // check trailing spaces, adjust nCount further to remove trailing spaces

        for
        (
            pwcEnd = (WORD*)&pwsz[nCount-1];
            (pwcEnd >= (WORD*)pwsz) && (*pwcEnd == L' ');
            nCount--, pwcEnd--, pDxEnd--
        )
        {
            size.cx -= *pDxEnd;
        }

        if (nCount == 0)
        {
            if (pJustIn)
                VFREEMEM(pJustIn);

            pResults->nGlyphs = nCount;
            pResults->nMaxFit = (int)nCount;
            return 0;
        }

    // See if we need to justify.
    // Can not justify one character, need at least two...

        nExtentLeft = (int)nMaxExtent - (int)size.cx;

        if ((nExtentLeft >= 0) && (nCount >= 2))
        {
        // ... yes, we do need to justify

        // if GCP_JUSTIFYIN was set, pJustIn and nJustIn have
        // already been set.

            if (!nJustIn) // try to use ' ' as a "spacer glyph"
            {
                nJustIn = nCalcJustInArray(&pJustIn,L' ',
                                           (VOID *)pwsz, FALSE, nCount);
            }


            if (nJustIn)
            {
            // Make sure that the array doesn't say to
            // space a character beyond the new nCount.

                j = nCount - 1; // convert count to index of the last glyph

                int ii;

                for (ii = (int)(nJustIn - 1); ii >= 0; ii--)
                {
                    if ((UINT)j >= pJustIn[ii])
                        break;
                }

            // pJustIn array is zero based, to get the effective number
            // of "spacers" in the array must add 1 to the index of the last "spacer" in the array

                i = (DWORD)ii + 1;

            // run a sort of primitive DDA a'la DavidMS

                nExtentRem = (int) (((DWORD)nExtentLeft) % i);
                nExtentLeft /= i;

                for (j = 0; j < i; j++, nExtentRem--)
                {
                    int  dxCor = nExtentLeft;
                    if (nExtentRem > 0)
                        dxCor += 1;
                    pDx[pJustIn[j]] += dxCor;
                }
            }
            else
            {
            // no spaces. justify by expanding every character evenly.

                while (nExtentLeft > 0)
                {
                // Note the end condition: nCount - 1, rather
                // than usual nCount; This is because there is no point
                // in adding spaces to the last glyph in the string

                    j = nCount - 1;
                    for (i = 0; i < j; i++)
                    {
                        pDx[i] += 1;
                        if (!(--nExtentLeft))
                            break;
                    }
                }
            }
        }
        #if DBG
        else
        {
            if (nCount < 2)
                RIP("GetCharacterPlacement, justification wrong\n");
        }
        #endif

    // we now have exactly this:

        size.cx = (LONG)nMaxExtent;
    }

// fill other width array, that is CaretPos

    if (dwWidthType == 3) // both lpDx and lpCaretPos are non NULL
        RtlCopyMemory(gcpw.lpCaretPos, gcpw.lpDx, nCount * sizeof(int));

// caret positioning is from the start of the string,
// not the previous character.

    if (gcpw.lpCaretPos)
    {
        int iCaretPos = 0,  iDx = 0;

        for (i = 0; i < nCount; i++)
        {
            iDx = gcpw.lpCaretPos[i];
            gcpw.lpCaretPos[i] = iCaretPos;
            iCaretPos += iDx;
        }
    }

// Fix Output String

    if (gcpw.lpOutString)
        RtlCopyMemory(gcpw.lpOutString, pwsz, nCount * sizeof(WCHAR));

// Classification

    if (gcpw.lpClass)
        RtlFillMemory(gcpw.lpClass, nCount, GCPCLASS_LATIN);

// Ordering

    if (gcpw.lpOrder)
    {
        for (i = 0; i < nCount; i++)
        {
            gcpw.lpOrder[i] = i;
        }
    }

// Get lpGlyphs

    if (gcpw.lpGlyphs)
    {
        if (GreGetGlyphIndicesW(
                hdc,(WCHAR*)pwsz,nCount,
                (USHORT*)gcpw.lpGlyphs,0, FALSE) == GDI_ERROR)
        {
            nCount = 0;
            size.cx = size.cy = 0;
        }
    }

// Finally fix counters in the returned structure

    if (pJustIn)
        VFREEMEM(pJustIn);
    pResults->nGlyphs = nCount;
    pResults->nMaxFit = nCount;
    return (DWORD)((USHORT)size.cx) | (DWORD)(size.cy << 16);
}


/**************************************************************************\
* NtGdiGetWidthTable
*
* Gets a table of character advance widths for a font.  Returns SHORTs
* over the C/S interface to save space.  (Note that 99+% of all requests
* will be happy with this limitation.)
*
* We will try real hard to get widths for the "special" characters at the
* start of the array.  Other widths are returned only when they are not
* expensive.  (Expensive is True Type rasterizing a glyph, for example.)
* The value NO_WIDTH is returned for those expensive glyphs.
*
* We return GDI_ERROR (0xFFFFFFFF) in case of an error.  TRUE indicates
* that all widths were easy.
*
* History:
*  Tue 13-Jun-1995 22:24:49 by Gerrit van Wingerden [gerritv]
*  Moved to kernel mode
*
*  Mon 11-Jan-1993 22:24:39 -by- Charles Whitmer [chuckwh]
* Wrote it.  Sorry about the wierd structure, I'm trying to get good tail
* merging.
\**************************************************************************/

BOOL APIENTRY NtGdiGetWidthTable
(
    HDC        hdc,         // Device context
    ULONG      cSpecial,
    WCHAR     *pwc,         // Pointer to a UNICODE text codepoints.
    ULONG      cwc,         // Count of chars.
    USHORT    *psWidth,     // Width table (returned).
    WIDTHDATA *pwd,         // Useful font data (returned).
    FLONG     *pflInfo      // Font info flags.
)
{
    ULONG ii;
    BOOL  bRet = (BOOL) GDI_ERROR;

    XDCOBJ dco(hdc);             // Lock the DC.

    if (dco.bValid())          // Check if it's good.
    {
        WIDTHDATA wd;

        FLONG flInfo;
        USHORT *psWidthTmp = NULL;
        WCHAR *pwcTmp;

        if (!BALLOC_OVERFLOW2(cwc, USHORT, WCHAR))
        {
            psWidthTmp = (USHORT*) AllocFreeTmpBuffer(cwc*(sizeof(USHORT)+sizeof(WCHAR)));
        }

        if( psWidthTmp )
        {
            pwcTmp = (WCHAR*) (psWidthTmp + cwc);
            __try
            {
                ProbeForRead(pwc,sizeof(WCHAR)*cwc,sizeof(WORD));
                RtlCopyMemory(pwcTmp,pwc,cwc*sizeof(WCHAR));
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                cwc = 0;
            }
        }
        else
        {
            WARNING("NtGdiGetWidthTable unable to allocate memory\n");
            cwc = 0;
        }

        if (cwc)
        {
        // Locate the RFONT.

            RFONTOBJ rfo(dco,FALSE);

            if (rfo.bValid())
            {
            // Grab the flInfo flags.

                flInfo = rfo.flInfo();

                if (rfo.cxMax() < 0xFFF)
                {
                // Check for a simple case.  We still have to fill the table
                // because some one may want it.

                    if (rfo.lCharInc())
                    {
                        USHORT *psWidth1 = psWidthTmp;

                        LONG fxInc = rfo.lCharInc() << 4;

                        for (ii=0; ii<cwc; ii++)
                            *psWidth1++ = (USHORT) fxInc;
                        bRet = TRUE;
                    }
                    else
                    {
                        bRet = rfo.bGetWidthTable(dco,cSpecial,pwcTmp,cwc,psWidthTmp);
                    }

                // If things are going well, get the WIDTHDATA.

                    if (bRet != GDI_ERROR)
                    {
                        if (!rfo.bGetWidthData(&wd,dco))
                            bRet = (BOOL) GDI_ERROR;
                    }
                }
            }
            else
            {
                WARNING("gdisrv!GreGetWidthTable(): could not lock HRFONT\n");
            }
        }

        if( bRet != GDI_ERROR )
        {
            __try
            {
                ProbeForWrite(psWidth,sizeof(USHORT)*cwc,sizeof(USHORT));
                RtlCopyMemory(psWidth,psWidthTmp,cwc*sizeof(USHORT));
                if( pwd )
                {
                    ProbeForWrite(pwd,sizeof(WIDTHDATA),sizeof(DWORD));
                    RtlCopyMemory(pwd,&wd,sizeof(WIDTHDATA));
                }
                ProbeForWrite(pflInfo,sizeof(FLONG),sizeof(DWORD));
                RtlCopyMemory(pflInfo,&flInfo,sizeof(FLONG));
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                bRet = GDI_ERROR;
            }
        }

        if (psWidthTmp)
        {
            FreeTmpBuffer( psWidthTmp );
        }

        dco.vUnlockFast();

    }
    return(bRet);
}

/******************************Public*Routine******************************\
* iGetPublicWidthTable()
*
*
* History:
*  28-Feb-1996 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

EFLOAT_S ef_16   = EFLOAT_16;
EFLOAT_S ef_1_16 = EFLOAT_1Over16;

int iGetPublicWidthTable(
    HDC   hdc)
{
    ULONG ii   = MAX_PUBLIC_CFONT; // this means failure
    BOOL  bRet = FALSE;
    HLFONT hf;

    XDCOBJ dco(hdc);             // Lock the DC.

    if (dco.bValid())            // Check if it's good.
    {
        // only want to support no transforms

        if ((dco.pdc->ulMapMode() == MM_TEXT) && (dco.ulDirty() & DISPLAY_DC))
        {
            // Get the hfont and check if it is public

            hf = dco.pdc->hlfntNew();

            if ((hf != NULL) &&
                GreGetObjectOwner((HOBJ)hf,LFONT_TYPE) == OBJECT_OWNER_PUBLIC)
            {
                RFONTOBJ rfo(dco,FALSE);

                if (rfo.bValid() && (rfo.cxMax() < 0xFFF))
                {
                    // lets see if we can find an available cpf

                    for (ii = 0; ii < MAX_PUBLIC_CFONT; ++ii)
                    {
                        if (gpGdiSharedMemory->acfPublic[ii].hf == 0)
                            break;

                        if (gpGdiSharedMemory->acfPublic[ii].hf == (HFONT)hf)
                        {
                            WARNING("iGetPublicWidthTable - font already in public list\n");
                            ii = MAX_PUBLIC_CFONT;
                        }
                    }

                    if (ii < MAX_PUBLIC_CFONT)
                    {
                        PCFONT pcf = &gpGdiSharedMemory->acfPublic[ii];

                        pcf->timeStamp = gpGdiSharedMemory->timeStamp;

                        // Grab the flInfo flags.

                        pcf->flInfo = rfo.flInfo();

                        // Check for a simple case.  We still have to fill the table
                        // because some one may want it.

                        if (rfo.lCharInc())
                        {
                            USHORT usInc = (USHORT)(rfo.lCharInc() << 4);

                            for (ii=0; ii<256; ii++)
                                pcf->sWidth[ii] = usInc;

                            bRet = TRUE;
                        }
                        else
                        {
                            WCHAR wch[256];
                            LFONTOBJ lfo(hf);

                            if (lfo.bValid())
                            {

                                if (IS_ANY_DBCS_CHARSET(lfo.plfw()->lfCharSet))
                                {
                                    ULONG  uiCodePage = ulCharsetToCodePage((UINT)lfo.plfw()->lfCharSet);

                                    for (ii = 0; ii < 256; ++ii)
                                    {
                                        UCHAR j = (UCHAR) ii;

                                        EngMultiByteToWideChar(uiCodePage,
                                                               &wch[ii],
                                                               sizeof(WCHAR),
                                                               (LPSTR)&j,
                                                               1);
                                    }
                                }
                                else
                                {
                                    UCHAR ach[256];
                                    ULONG BytesReturned;

                                    for (ii = 0; ii < 256; ++ii)
                                      ach[ii] = (UCHAR)ii;

                                    RtlMultiByteToUnicodeN(wch,
                                                           sizeof(wch),
                                                           &BytesReturned,
                                                           (PCHAR)ach,
                                                           sizeof(ach));
                                }

                                bRet = rfo.bGetWidthTable(dco,256,wch,256,pcf->sWidth);

                                if (bRet == GDI_ERROR)
                                    bRet = FALSE;
                            }
                        }

                        // If things are going well, get the WIDTHDATA , metrics and
                        // RealizationInfo
                        DCOBJ dcof(hdc);

                        if (bRet &&
                            rfo.bGetWidthData(&pcf->wd,dco) &&
#ifdef LANGPACK
                            rfo.GetRealizationInfo(&pcf->ri) &&
#endif
                            bGetTextMetrics(rfo, dcof, &pcf->tmw)
                           )
                        {
                            pcf->fl   = CFONT_COMPLETE       |
                                        CFONT_CACHED_METRICS |
                                        CFONT_CACHED_WIDTHS  |
#ifdef LANGPACK
                                        CFONT_CACHED_RI      |
#endif
                                        CFONT_PUBLIC;

                            // since we are always MM_TEXT, the xform is identity

                            pcf->efM11          = ef_16;
                            pcf->efM22          = ef_16;
                            pcf->efDtoWBaseline = ef_1_16;
                            pcf->efDtoWAscent   = ef_1_16;

                            pcf->hf             = (HFONT)hf;
                            pcf->hdc            = 0;
                            pcf->cRef           = 0;
                            pcf->lHeight        = FXTOL((LONG) pcf->wd.sHeight);
                        }
                        else
                        {
                        // if got error... we should retuen MAX_PUBLIC_CFONT..
                        // At this point "ii" is not equal to MAX_PUBLIC_CFONT, it
                        // points first free entry of cache table...
                        // Just force set it to error..

                            ii = MAX_PUBLIC_CFONT;
                        }
                    }
                }
                else
                {
                    WARNING("gdisrv!GreGetWidthTable(): could not lock HRFONT\n");
                }
            }
        }
        dco.vUnlockFast();
    }

    return(ii);
}

/******************************Public*Routine******************************\
* NtGdiSetupPublicCFONT()
*
*  Modify the cached public cfont.
*
*  if HDC is non-null, textmetrics must be set
*  if HF  is non-null, cached ave width must be set
*
*  returns index of cfont modified
*
* History:
*  23-Feb-1996 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int APIENTRY NtGdiSetupPublicCFONT(
    HDC     hdc,
    HFONT   hf,
    ULONG   ulAve)
{
    int ii = MAX_PUBLIC_CFONT;

    // get metrics and widths if necesary

    if (hdc)
    {
        ii = iGetPublicWidthTable(hdc);
    }

    // now see if we need to fill in the ave width

    if (hf)
    {
        // if we havn't found it yet, find it

        if (ii == MAX_PUBLIC_CFONT)
        {
            for (ii = 0; ii < MAX_PUBLIC_CFONT; ++ii)
            {
                if (gpGdiSharedMemory->acfPublic[ii].hf == hf)
                    break;
            }
        }

        if (ii < MAX_PUBLIC_CFONT)
        {
            gpGdiSharedMemory->acfPublic[ii].ulAveWidth = ulAve;
            gpGdiSharedMemory->acfPublic[ii].fl        |= CFONT_CACHED_AVE;
        }
    }

    return(ii);
}


UINT APIENTRY GreGetTextAlign(HDC hdc)
{
    XDCOBJ dco( hdc );

    if(dco.bValid())
    {
        UINT uTextAlign = dco.pdc->lTextAlign();
        dco.vUnlockFast();
        return uTextAlign;
    }
    else
    {
        WARNING("GreGetTextAlign: invalid DC\n");
        return(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\textobj.cxx ===
/******************************module*header*******************************\
* Module Name: textobj.cxx
*
* Supporting routines for text output calls, ExtTextOut etc.
*
* Created: 08-Feb-1991 09:25:14
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1999 Microsoft Corporation
\**************************************************************************/


#include "precomp.hxx"

#define XFORMNULL (EXFORMOBJ *) NULL

VOID vGenWidths
(
    FIX    *pfxD1,
    FIX    *pfxD2,
    EFLOAT& efRA,
    EFLOAT& efRB,
    FIX     fxWidth,
    FIX     fxTop,
    FIX     fxBottom,
    FIX     fxMaxAscent
);

#define SO_ACCEL_FLAGS (SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE \
                        | SO_CHAR_INC_EQUAL_BM_BASE | SO_ZERO_BEARINGS)

BOOL bAdjusBaseLine(RFONTOBJ &rfoBase, RFONTOBJ &rfoLink, POINTL *pptlAdjustBaseLine);

/******************************Member*Function*****************************\
* ESTROBJ::vInit
*
* Constructor for ESTROBJ.  Performs the following operations:
*
*  1) Initialize the STROBJ fields for the driver.
*  2) Compute all character positions.
*  3) Compute the TextBox.
*  4) In the simplest cases, computes rectangles for underline and
*     strikeout.
*
* The TextBox is a parallelogram in device coordinates, whose sides are
* parallel to the transformed sides of a character cell, and which bounds
* all the character cells.  A and C spacings are taken into account to
* assure that it is a proper bound.
*
* We record the TextBox in an unusual notation.  If a line is constructed
* through the character origin of the first character in the string and in
* the direction of the ascent, then what we record as the "left" and
* "right" of the TextBox are really the distances from this line to each
* of those edges of the parallelogram, in device coordinates.  Likewise,
* the "top" and "bottom" are the distances from the baseline of the first
* character.  This completely determines the parallelogram, and is
* surprisingly easy to compute.  ExtTextOut later turns this data into the
* actual parallelogram, whereas the TextExtent functions turn this data
* into scalar extents.
*
* History:
*  Fri 13-Mar-1992 00:47:05 -by- Charles Whitmer [chuckwh]
* Rewrote from the ground up.
*
*  21-Jan-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID ESTROBJ::vInit
(
    PWSZ        pwsz,
    LONG        cwc,
    XDCOBJ&  dco,
    RFONTOBJ&   rfo,
    EXFORMOBJ&  xo,
    LONG       *pdx,
    BOOL        bPdy,
    LONG        lEsc,
    LONG        lExtra,
    LONG        lBreakExtra,
    LONG        cBreak,
    FIX        xRef,
    FIX         yRef ,
    FLONG       flControl,
    LONG       *pdxOut,
    PVOID       pvBuffer,
    DWORD       CodePage
)
{
    EGLYPHPOS  *pg;
    GLYPHDATA  *pgd;
    UINT    ii;
    EFLOAT  efScaleX = xo.efM11();

    cGlyphs     = cwc;
    prfo        = &rfo;
    flTO        = 0L;

    flAccel     = bPdy ? SO_DXDY : 0L;

    // we don't want to substitute the symbol font
    // if its glyph set has been extended

    {
        PFE         *ppfe = rfo.ppfe();

        ASSERTGDI(ppfe->pfdg, "ESTROBJ::vInit invalid ppfe->pfdg \n");
        
        if (ppfe->pfdg->flAccel & GS_EXTENDED)
        {
            ASSERTGDI(ppfe->pifi->jWinCharSet == SYMBOL_CHARSET,
                      "ESTROBJ::vInit(): GS_EXTENDED set for on SYMBOL_CHARSET fonts\n");

            flAccel |= SO_DO_NOT_SUBSTITUTE_DEVICE_FONT;
        }
    }

    ulCharInc   = 0L;
    cgposCopied = 0;
    cgposPositionsEnumerated = 0;
    cExtraRects = 0;
    pgp         = NULL;
    pgpos       = NULL;
    pwszOrg     = pwsz;
    dwCodePage  = CodePage;
    xExtra      = 0; // will be computed later if needed
    xBreakExtra = 0; // will be computed later if needed

// fix the string if in GLYPH_INDEX mode, waste of time to be win95 compatible

    if (rfo.prfnt->flType & RFONT_TYPE_HGLYPH)
    {
        flAccel |= SO_GLYPHINDEX_TEXTOUT;
        rfo.vFixUpGlyphIndices((USHORT *)pwsz, cwc);
    }

// Remember if the printer driver wants 28.4 char positions.

    PDEVOBJ po(rfo.hdevConsumer());

    if (po.bCapsHighResText())
        flTO |= TO_HIGHRESTEXT;

// Locate the GLYPHPOS array.  Use the buffer given, if there is one.  We
// need one more GLYPHPOS structure than there are glyphs.  The concatenation
// point is computed in the last one.

    if (pvBuffer)
    {
        pg = (EGLYPHPOS *) pvBuffer;
    }
    else
    {
        pg = (EGLYPHPOS *) PVALLOCTEMPBUFFER(SIZEOF_STROBJ_BUFFER(cwc));
        if (pg == (PGLYPHPOS) NULL)
            return;

        // Note that the memory has been allocated.

        flTO |= TO_MEM_ALLOCATED;
    }

    pgpos = pg;     // Make sure our cached value is in the structure.

// In Win 3.1 compatibility mode, we always assume that escapement is
// the same as orientation, except for vector fonts.  Make it explicitly so.

    if (rfo.iGraphicsMode() == GM_COMPATIBLE)
    {
        if (!(rfo.prfnt->flInfo & FM_INFO_TECH_STROKE))
           lEsc = rfo.ulOrientation();
    }

// Offset the reference point for TA_TOP and TA_BOTTOM.  Our GLYPHPOS
// structures always contain positions along the baseline.  The TA_BASELINE
// case is therefore already correct.

    switch (flControl & (TA_TOP | TA_BASELINE | TA_BOTTOM))
    {
    case TA_TOP:
        xRef -= rfo.ptfxMaxAscent().x;
        yRef -= rfo.ptfxMaxAscent().y;
        break;

    case TA_BOTTOM:
        xRef -= rfo.ptfxMaxDescent().x;
        yRef -= rfo.ptfxMaxDescent().y;
        break;
    }

/**************************************************************************\
* [Win 3.1 compatibility issue]
*
* Adjust pdx array if there is a non-zero lExtra.
*
* This is only done under compatibility mode and only when using non-vector
* fonts on a non-display device.
\**************************************************************************/

    if ( lExtra
         && (pdx != (LONG *) NULL)
         && (rfo.iGraphicsMode() == GM_COMPATIBLE)
         && (!(rfo.prfnt->flInfo & FM_INFO_TECH_STROKE))
         && po.bDisplayPDEV() )
    {
        LONG *pdxAdj = pdx;
        LONG *pdxEnd;

        if (!bPdy)
        {
            pdxEnd = pdx + cwc;

            for (;pdxAdj < pdxEnd; pdxAdj += 1)
                *pdxAdj += lExtra;
        }
        else
        {
            pdxEnd = pdx + 2*cwc;

            for (;pdxAdj < pdxEnd; pdxAdj += 2)
                *pdxAdj += lExtra;
        }
    }

/**************************************************************************\
* Handle all horizontal special cases.
\**************************************************************************/

    if (
        ((lEsc | rfo.ulOrientation()) == 0)
        && xo.bScale()
        && !xo.efM22().bIsNegative()  // Otherwise the ascent goes down.
        && !efScaleX.bIsNegative()    // Otherwise A and C spaces get confused.
       )
    {
        /**********************************************************************\
        * We provide several special routines to calculate the character
        * positions and TextBox.  Each routine is responsible for calculating:
        *
        *  1) Each position
        *  2) Bounding coordinates.
        *  3) The ptfxUpdate vector.
        *  4) The flAccel flags.
        \**********************************************************************/

        if (pdx != NULL)
        {
        // Case H1: A PDX array is provided.

            if (!bPdy)
            {
                vCharPos_H1(
                        dco,
                        rfo,xRef,yRef,pdx,efScaleX);
            }
            else
            {
                if (flControl & (TSIM_UNDERLINE1 | TSIM_STRIKEOUT))
                {
                // In H4 case we want to force individual character underlining
                // as we do for esc!=orientation case,

                    if (!rfo.bCalcEscapement(xo,lEsc))
                        return;
                    flTO |= TO_ESC_NOT_ORIENT;
                }

                vCharPos_H4(
                        dco,
                        rfo,xRef,yRef,pdx, efScaleX,xo.efM22());
            }

        }

        else if (rfo.lCharInc() && ((lExtra | lBreakExtra) == 0))
        {
        // Case H2: Characters have constant integer width.

            vCharPos_H2(dco,rfo,xRef,yRef,efScaleX);
        }

        else
        {
        // Case H3: The general case.

            vCharPos_H3(dco,rfo,xRef,yRef,lExtra,lBreakExtra,cBreak,efScaleX);
        }

        /**********************************************************************\
        * Horizontal special cases done!
        *
        * It remains only to finish the alignment.
        \**********************************************************************/

        // Offset all the relevant points if our alignment is RIGHT or CENTER.
        // Also correct the CP update vector.

        ptfxEscapement.x = ptfxUpdate.x;        // Remember this for underlining.
        ptfxEscapement.y = ptfxUpdate.y;

        if (flControl & (TA_RIGHT | TA_CENTER))
        {
            FIX dx = ptfxUpdate.x;

            if ((flControl & TA_CENTER) == TA_CENTER)
            {
                dx /= 2;
                ptfxUpdate.x = 0;       // Don't update CP.
            }
            else
            {
                ptfxUpdate.x = -ptfxUpdate.x; // Reverse the CP update.
            }

            pg = pgpos;
            dx = FXTOL(dx + 8);             // Convert to LONG for pgp adjusts
            xRef = ((pg++)->ptl.x -= dx);   // Always adjust the first one.
            xRef = LTOFX(xRef);             // Convert back to FIX for later

            if (ulCharInc == 0)
            {
                for (ii=0; ii<(ULONG) cwc-1; ii++)
                    (pg++)->ptl.x -= dx;
            }
        }

        // Fill in a pdxOut array.

        if (pdxOut != (LONG *) NULL)
        {
            EFLOAT efDtoW = rfo.efDtoWBase();

        if (ulCharInc && !bLinkedGlyphs())
            {
                FIX dx, xSum;

                dx = lCvt(efDtoW,LTOFX(ulCharInc));
                xSum = 0;
                for (ii=0; ii<(ULONG) cwc; ii++)
                {
                    xSum += dx;
                    *pdxOut++ = xSum;
                }
            }
            else
            {
                pg = pgpos + 1; // skip the first element
                for (ii=0; ii<(ULONG) cwc-1; ii++,pg++)
                    *pdxOut++ = lCvt(efDtoW,LTOFX(pg->ptl.x) - xRef);

            // Unfortunately, to be consistent with the rounding we've done
            // in the above cases, we can't simply compute this last one
            // as: *pdxOut = lCvt(efDtoW,ptfxUpdate.x):

                *pdxOut = lCvt(efDtoW, ((ptfxUpdate.x + xRef) & ~0xf) - xRef);
            }
        }

        ptfxRef.x = LTOFX(pgpos->ptl.x);
        ptfxRef.y = LTOFX(pgpos->ptl.y);
    }

/**************************************************************************\
* Handle the harder cases, i.e general orientations and transforms are
* allowed.
\**************************************************************************/

    else
    {
        if (!bPdy)
        {
            if (lEsc == (LONG)rfo.ulOrientation())
            {
                if (pdx != NULL)
                {
                // Case G1: A PDX array is provided.  Escapement == Orientation.

                    vCharPos_G1(dco,rfo,xRef,yRef,pdx,pdxOut);
                }
                else // (pdx == NULL)
                {
                // Case G2: No PDX array.  Escapement == Orientation.

                    vCharPos_G2(dco,rfo,xRef,yRef,lExtra,lBreakExtra,cBreak,pdxOut);
                }
            }
            else // lEsc!=rfo.ulOrientation()
            {
            // Case G3: Escapement != Orientation.

                // Make sure escapement vectors and data are up to date.

                if (!rfo.bCalcEscapement(xo,lEsc))
                    return;
                flTO |= TO_ESC_NOT_ORIENT;
                flAccel |= SO_ESC_NOT_ORIENT;

                vCharPos_G3
                (
                dco,
                rfo,
                xRef,yRef,
                lExtra,lBreakExtra,cBreak,
                pdx,
                pdxOut
                );
            }
        }
        else // pdy case
        {
        // Make sure escapement vectors and data are up to date.

            if (!rfo.bCalcEscapement(xo,lEsc))
                return;
            flTO |= TO_ESC_NOT_ORIENT;

            vCharPos_G4
            (
                dco,
                rfo,
                xRef,
                yRef,
                pdx
            );
        }


        /**********************************************************************\
        * General special cases done!
        *
        * It remains only to finish the alignment.
        \**********************************************************************/

        // Offset all the relevant points if our alignment is RIGHT or CENTER.
        // Also correct the CP update vector.

        ptfxEscapement = ptfxUpdate;        // Remember this for underlining.

        if (flControl & (TA_RIGHT | TA_CENTER))
        {
            FIX dx = ptfxUpdate.x;
            FIX dy = ptfxUpdate.y;

            if ((flControl & TA_CENTER) == TA_CENTER)
            {
                dx /= 2;
                dy /= 2;
                ptfxUpdate.x = 0;         // No CP update.
                ptfxUpdate.y = 0;
            }
            else
            {
                ptfxUpdate.x = -ptfxUpdate.x; // Reverse the CP update.
                ptfxUpdate.y = -ptfxUpdate.y;
            }

            pg = pgpos;
            for (ii=0; ii<(ULONG)cwc; ii++)
            {
                pg->ptl.x -= dx;
                pg->ptl.y -= dy;
                pg++;
            }
            xRef -= dx;
            yRef -= dy;
        }

        // Convert the FIX coordinates to LONG for low res devices.

        pg = pgpos;

        ptfxRef.x = xRef;
        ptfxRef.y = yRef;

        for (ii=0; ii<(ULONG)cwc; ii++,pg++)
        {
            pg->ptl.x = FXTOL(pg->ptl.x + 8);
            pg->ptl.y = FXTOL(pg->ptl.y + 8);
        }
    }

// Fill in the underline and strikeout rectangles.  The horizontal cases
// are the only ones that can use the extra rectangles of DrvTextOut to
// draw the lines quickly.  We'll use a PATHOBJ (in a separate optional
// method) for the complex cases.

    if (flControl & (TSIM_UNDERLINE1 | TSIM_STRIKEOUT))
    {
        flTO |= flControl & (TSIM_UNDERLINE1 | TSIM_STRIKEOUT);

        if (((lEsc | rfo.ulOrientation() | bPdy) == 0) && xo.bScale())
        {
            ERECTL *prcl = (ERECTL *) &arclExtra[cExtraRects];

        // Round off the starting point and update width to pels.

            LONG x  = FXTOL(xRef+8);
            LONG y  = FXTOL(yRef+8);
            LONG dx = FXTOL(ptfxEscapement.x+8);

            if (flControl & TSIM_UNDERLINE1)
            {
                prcl->right  = (prcl->left = x + rfo.ptlUnderline1().x) + dx;
                prcl->bottom = (prcl->top  = y + rfo.ptlUnderline1().y)
                           + rfo.ptlULThickness().y;
                prcl->vOrder();

                cExtraRects++;
                prcl++;
            }

            if (flControl & TSIM_STRIKEOUT)
            {
                prcl->right  = (prcl->left = x + rfo.ptlStrikeOut().x) + dx;
                prcl->bottom = (prcl->top  = y + rfo.ptlStrikeOut().y)
                           + rfo.ptlSOThickness().y;
                prcl->vOrder();

                cExtraRects++;
                prcl++;
            }

        // Put a NULL rectangle at the end of the list.

            prcl->left   = 0;
            prcl->right  = 0;
            prcl->bottom = 0;
            prcl->top    = 0;
        }
    }

    if ( rfo.prfnt->fobj.flFontType & RASTER_FONTTYPE )
    {
        flTO |= TO_BITMAPS;
    }
    else
    {
        flTO &= ~TO_BITMAPS;
    }
}

/******************************Member*Function*****************************\
* ESTROBJ::vInitSimple
*
* Constructor for ESTROBJ.  Performs the following operations:
*
*  1) Initialize the STROBJ fields for the driver.
*  2) Compute all character positions.
*  3) Compute the TextBox.
*  4) Stores the TextBox in the ESTROBJ. <--- Note!
*
* The is the special case code for the console, so we ignore transforms
* and other fancy options.
*
* Note that you don't need to call bOpaqueArea to get rclBkGround
* initialized.  This is a difference from the normal vInit.
*
* History:
*  Thu 17-Sep-1992 17:32:10 -by- Charles Whitmer [chuckwh]
* Took the vInit code and simplified it for the special console case.
\**************************************************************************/


VOID ESTROBJ::vInitSimple
(
    PWSZ    pwsz,
    LONG    cwc,
    XDCOBJ&  dco,
    RFONTOBJ&   rfo,
    LONG    xRef,
    LONG    yRef,
    PVOID   pvBuffer
)
{
// Characters have constant integer width.  We will also ignore the A and C spaces.

    EGLYPHPOS  *pg;
    cGlyphs = cwc;
    prfo    = &rfo;
    cgposCopied = 0;
    pgp     = NULL;
    pwszOrg = pwsz;

    ASSERTGDI(cwc > 0, "Count of glyphs must be greater than zero");

// Locate the GLYPHPOS array.  Try to use the default one on the stack.  We
// need one more GLYPHPOS structure than there are glyphs.  The concatenation
// point is computed in the last one.

    if (pvBuffer)
    {
        pg = (EGLYPHPOS *) pvBuffer;
    }
    else
    {
        pg = (EGLYPHPOS *) PVALLOCTEMPBUFFER(SIZEOF_STROBJ_BUFFER(cwc));
        if (pg == (PGLYPHPOS) NULL)
            return;

    // Note that the memory has been allocated.

        flTO |= TO_MEM_ALLOCATED;
    }
    pgpos = pg;     // Make sure our cached value is in the structure.

// Compute device driver accelerator flags.

    flAccel = SO_HORIZONTAL | (rfo.flRealizedType() & SO_ACCEL_FLAGS);

    BOOL bAccel;

    if (!rfo.bGetGlyphMetricsPlus(cwc, pg, pwsz, &bAccel, &dco, this))
        return;

    if ( bAccel )
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

// We leave these variables uninitialized in this simple case.
// BE CAREFUL!

    // cExtraRects = 0;
    // ptfxUpdate.x = dx;
    // ptfxUpdate.y = 0;
    // ptfxEscapement = ptfxUpdate;
    // ptfxRef.x = xRef;
    // ptfxRef.y = yRef;

// Offset the reference point for TA_TOP.  Our GLYPHPOS structures always contain
// positions along the baseline.

// We assume that displays never set the GCAPS_HIGHRESTEXT bit.

    pg->ptl.x = xRef;
    pg->ptl.y = yRef + rfo.lMaxAscent();

// Set the width accelerator.  When the device driver sees ulCharInc
// non-zero, it must not expect any more x coordinates.

    ulCharInc = rfo.lCharInc();


#ifdef FE_SB
// If this is a SBCS linked to a DBCS font the font is really "binary pitch" and we
// should ignore ulCharInc. In the case of a DBCS TT font, the font is also really
// "binary pitch" and the TT driver will set ulCharInc to 0.  In either case use
// the individual glyph metrics to lay out glyphs.  This is slightly slower than
// the fixed pitch optimization but not enough to be significant.

    if( bLinkedGlyphs() || (ulCharInc == 0) )
    {
        FIX  xA , xLeft , xRight;
        UINT ii;

        ulCharInc = 0;

    // Calculate the left bound using only the first glyph.

        xLeft = pg->pgd()->fxA;

    // Handle the remaining glyphs in this batch.

        xA = 0; // Distance along the escapement (x) in device coords.
        for (ii=1; ii<(unsigned) cwc; ii++)
        {

        // Compute the next position.

            xA += pg->pgd()->fxD;
            pg++;
            pg->ptl.x = xRef + FXTOL(8 + xA);
            pg->ptl.y = yRef + rfo.lMaxAscent();
        }

    // Calculate the right bound.  This is easier than the general case since
    // there's no extra spacing.

        xRight = xA + pg->pgd()->fxAB;

    // Compute the bounding rectangle.

        rclBkGround.left   = xRef + FXTOL(xLeft);
        rclBkGround.right  = xRef + FXTOLCEILING(xRight);
        rclBkGround.top    = yRef;
        rclBkGround.bottom = yRef + rfo.lMaxHeight();
    }
    else
    {

#endif

// Compute the bounding rectangle.

    rclBkGround.left   = xRef;
    rclBkGround.right  = xRef + cwc * ulCharInc;
    rclBkGround.top    = yRef;
    rclBkGround.bottom = yRef + rfo.lMaxHeight();

    }

// color filtering causes spill on each side for cleartype

    if (rfo.pfo()->flFontType & FO_CLEARTYPE_X)
    {
        rclBkGround.left -= 1;
        rclBkGround.right += 1;
    }

    flTO |= TO_VALID;
}

/******************************Public*Routine******************************\
*
* Routine Name: "ESTROBJ::vCorrectBackGround"
*
* Routine Description:
*
*     If a glyph lies outside the background rectangle
*     the background rectangle is expanded to contain
*     the errant glyph. This is a hack routine to fix
*     some anomalies found when rendering texts at
*     arbitrary angles.
*
* Arguments:
*
*   pfo             a pointer to the associated FONTOBJ
*                   This is used to inform us if the
*                   font contains bitmaps
*
* Return Value: TRUE if string is consistent FALSE if not.
*
\**************************************************************************/

#if DBG
void ESTROBJ::vCorrectBackGroundError(GLYPHPOS *pgp)
{
    GLYPHBITS *pgb = pgp->pgdf->pgb;
    char *psz = "vCorrectBackGround: Glyph found outside background rectangle";

    DbgPrint("\n");
    DbgPrint("\n");
    DbgPrint("%s\n", psz);
    DbgPrint("STROJB* = %-#x\n", this);

    DbgPrint(
        "rclBkGround = %d %d %d %d\n",
        rclBkGround.left,
        rclBkGround.top,
        rclBkGround.right,
        rclBkGround.bottom
    );
    DbgPrint("pgp = %-#x\n", pgp);
    DbgPrint("    hg  = %-#x\n",  pgp->hg);
    DbgPrint("    ptl = %d %d\n", pgp->ptl.x, pgp->ptl.y);
    DbgPrint("    pgb = %-#x\n",  pgb);
    DbgPrint("        ptlOrigin = %d %d\n", pgb->ptlOrigin.x, pgb->ptlOrigin.y);
    DbgPrint("        sizlBitmap = %d %d\n", pgb->sizlBitmap.cx, pgb->sizlBitmap.cy);
    DbgPrint("\n");
    RIP("Stopping for debugging\n");
}

void ESTROBJ::vCorrectBackGround()
{
    LONG l;                     // place holder for glyph bitmap coord
    GLYPHPOS *pgp, *pgp_;
    GLYPHBITS *pgb;

    if (
        ((flAccel & SO_FLAG_DEFAULT_PLACEMENT) == 0 ) &&
        ( flTO & TO_BITMAPS                         ) &&
        ( pgpos                                     )
    )
    {
        pgp_ = pgpos + cGlyphs;
        for ( pgp = pgpos ; pgp < pgp_ ; pgp++ ) {
            if ( pgb = pgp->pgdf->pgb )
            {
                l = pgp->ptl.x + pgb->ptlOrigin.x;
                if ( l < rclBkGround.left )
                {
                    vCorrectBackGroundError( pgp );
                    rclBkGround.left = l;
                }
                l += pgb->sizlBitmap.cx;
                if ( l > rclBkGround.right )
                {
                    vCorrectBackGroundError( pgp );
                    rclBkGround.right = l;
                }
                l = pgp->ptl.y + pgb->ptlOrigin.y;
                if ( l < rclBkGround.top )
                {
                    vCorrectBackGroundError( pgp );
                    rclBkGround.top = l;
                }
                l += pgb->sizlBitmap.cy;
                if ( l > rclBkGround.bottom )
                {
                    vCorrectBackGroundError( pgp );
                    rclBkGround.bottom = l;
                }
            }
        }
    }
}

#endif


/******************************Public*Routine******************************\
* ESTROBJ::vCharPos_G3 (rfo,x,y,lExtra,lBreakExtra,cBreak,pdx,pdxOut)
*
* Computes character positions in the case where escapement does not equal
* orientation.  This is pretty tricky.  We have to make up vertical
* spacings.  Also, the character positions we record in the GLYPHPOS
* structure all have to be adjusted because for general escapements the
* concatenation point is not the same as the character origin.
*
* The following fields of the ESTROBJ are filled in:
*
*  1) Each x,y position.
*  2) Bounding coordinates in rcfx.
*  3) The ptfxUpdate vector.
*
* History:
*  Sun 22-Mar-1992 23:31:55 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/


VOID ESTROBJ::vCharPos_G3
(
    XDCOBJ&  dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef,
    LONG      lExtra,
    LONG      lBreakExtra,
    LONG      cBreak,
    LONG     *pdx,
    LONG     *pdxOut
)
{
// In this case, we keep track of how far we have traveled along the
// escapement vector in device coordinates.  We need scales to project
// this distance onto the base and ascent, as well as a unit escapement
// vector to find the position.

    POINTFL pteEsc  = rfo.pteUnitEsc();     // Unit escapement vector.
    EFLOAT efScaleX = rfo.efEscToBase();    // Project escapement to baseline.
    EFLOAT efScaleY = rfo.efEscToAscent();  // Project escapement to ascent.

// Compute logical to device transforms.

    EFLOAT efWtoDEsc = rfo.efWtoDEsc(); // Forward transform for pdx.
    EFLOAT efDtoWEsc = rfo.efDtoWEsc(); // Back transform for pdxOut.

// Compute extra spacing for the non-pdx case.

    FIX    fxD1,fxD2;       // Pre- and Post-center character widths.
    FIX    fxAscent  = rfo.fxMaxAscent();  // Cache locally.
    HGLYPH hgBreak;

    if (pdx == (LONG *) NULL)
    {
        // Calculate the lExtra and lBreakExtra spacing.

        xExtra      = 0;
        xBreakExtra = 0;
        hgBreak     = 0;

        if (lExtra)
        {
            xExtra = lCvt(rfo.efWtoDEsc(),lExtra);
        }
        if (lBreakExtra && cBreak)
        {
            xBreakExtra = lCvt(rfo.efWtoDEsc(),lBreakExtra) / cBreak;

        // Windows won't let us back up over a break.

            vGenWidths
            (
            &fxD1,          // Pre-center spacing
            &fxD2,          // Post-center spacing
            efScaleY,       // Ascent projection
            efScaleX,       // Baseline projection
            rfo.fxBreak(),      // Character width
            fxAscent,       // Ink box top
            0,          // Ink box bottom
            fxAscent        // Maximum Ascent
            );
            if (fxD1 + fxD2 + xBreakExtra + xExtra < 0)
                xBreakExtra = -(fxD1 + fxD2 + xExtra);
            hgBreak = rfo.hgBreak();
        }
    }

// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;

// Set the first character position.

    pg->ptl.x = xRef;
    pg->ptl.y = yRef;

// Set up for character loop.

    LONG   xSum;        // Keep pdx sum here.
    FIX    xA,xB;       // Baseline coordinates.
    FIX    yA,yB;       // Ascent coordinates.
    FIX    sA;          // Position on the escapement vector.
    RECTFX rcfxBounds;      // Accumulate bounds here.
    UINT   ii;
    FIX    fxDescent = rfo.fxMaxDescent(); // Cache locally.

    rcfxBounds.xLeft   = LONG_MAX; // Start with an empty TextBox.
    rcfxBounds.xRight  = LONG_MIN;
    rcfxBounds.yTop    = LONG_MIN;
    rcfxBounds.yBottom = LONG_MAX;

    ASSERTGDI(cGlyphs > 0, "G3, cGlyphs == 0\n");

// We keep the current concatenation point in sA.  Note that this is NOT
// where the character origin will be placed.

    sA   = 0;
    xSum = 0;

    BOOL bAccel;

    if (!rfo.bGetGlyphMetricsPlus(cGlyphs, pg, pwsz, &bAccel, &dco, this))
        return;

    if (bAccel)
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

    BOOL bZeroBearing = ( rfo.flRealizedType() & SO_ZERO_BEARINGS ) && !bLinkedGlyphs();

    for (ii=0; ii<cGlyphs; ii++)
    {
        pgd = pg->pgd();

    // Using the GenWidths function, determine where the
    // character center should be placed.

        vGenWidths
        (
            &fxD1,              // Pre-center spacing
            &fxD2,              // Post-center spacing
            efScaleY,           // Ascent projection
            efScaleX,           // Baseline projection
            pgd->fxD,           // Character width
            pgd->fxInkTop,      // Ink box top
            pgd->fxInkBottom,   // Ink box bottom
            fxAscent            // Maximum Ascent
        );

        sA += fxD1;         // Advance to the character center.

    // Update ascent bounds.

        yA = lCvt(efScaleY,sA); // Project onto ascent.
        yB = yA + fxDescent;
        if (yB < rcfxBounds.yBottom)
            rcfxBounds.yBottom = yB;
        yB = yA + fxAscent;
        if (yB > rcfxBounds.yTop)
            rcfxBounds.yTop = yB;

        ASSERTGDI(!rfo.bSmallMetrics(),"ESTROBJ__vCharPos_G3: Small Metrics in cache\n");

    // Project the center position onto the baseline and
    // move back to the character origin.

        xA = lCvt(efScaleX,sA) - pgd->fxD / 2;

    // Update the width bounds.  Fudge a quarter pel on each side for
    // roundoff.

        if( bZeroBearing )
        {
            xB = xA - 4;
            if (xB < rcfxBounds.xLeft)
                rcfxBounds.xLeft = xB;
            xB = xA + pgd->fxD + 4;
            if (xB > rcfxBounds.xRight)
                rcfxBounds.xRight = xB;
        }
        else
        {
            xB = xA + pgd->fxA - 4;
            if (xB < rcfxBounds.xLeft)
                rcfxBounds.xLeft = xB;
            xB = xA + pgd->fxAB + 4;
            if (xB > rcfxBounds.xRight)
                rcfxBounds.xRight = xB;
        }

    // Save the adjusted character origin.

        pg->ptl.x
         = xRef + lCvt(pteEsc.x,sA) - pgd->ptqD.x.u.HighPart / 2;

        pg->ptl.y
         = yRef + lCvt(pteEsc.y,sA) - pgd->ptqD.y.u.HighPart / 2;

    // Advance to the next concatenation point.

        if (pdx != (LONG *) NULL)
        {
            xSum += *pdx++;
            sA = lCvt(efWtoDEsc,xSum);

            if (pdxOut != (LONG *) NULL)
                *pdxOut++ = xSum;
        }
        else
        {
            sA += fxD2 + xExtra;

            if (xBreakExtra && (pg->hg == hgBreak))
            {
                sA += xBreakExtra;
            }

        // Record the concatenation point for GetTextExtentEx.  This
        // would be very difficult to reconstruct at a later time.

            if (pdxOut != (LONG *) NULL)
                *pdxOut++ = lCvt(efDtoWEsc,sA);
        }
        pg++;
    }
    ptfxUpdate.x = lCvt(pteEsc.x,sA);
    ptfxUpdate.y = lCvt(pteEsc.y,sA);

    rcfx = rcfxBounds;
    flTO |= TO_VALID;
}

/******************************Public*Routine******************************\
* ESTROBJ::vCharPos_G2 (rfo,xRef,yRef,lExtra,lBreakExtra,cBreak,pdxOut)
*
* Computes character positions in the case where no pdx array is provided
* and escapement equals orientation.
*
* The following fields of the ESTROBJ are filled in:
*
*  1) Each x,y position.
*  2) Bounding coordinates in rcfx.
*  3) The ptfxUpdate vector.
*  4) The fxExtent.
*
* History:
*  Sun 22-Mar-1992 23:31:55 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

VOID ESTROBJ::vCharPos_G2
(
    XDCOBJ&  dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef,
    LONG      lExtra,
    LONG      lBreakExtra,
    LONG      cBreak,
    LONG     *pdxOut
)
{
// Calculate the lExtra and lBreakExtra spacing.

    HGLYPH   hgBreak     = 0;
    EPOINTQF ptqExtra;      // Accurate spacing along the escapement.
    EPOINTQF ptqBreakExtra;

    if (lExtra)
    {
        xExtra    = lCvt(rfo.efWtoDBase(),lExtra);
        ptqExtra  = rfo.pteUnitBase();
        ptqExtra *= (LONG) xExtra;
    }
    if (lBreakExtra && cBreak)
    {
        xBreakExtra    = lCvt(rfo.efWtoDBase(),lBreakExtra) / cBreak;

        // Windows won't let us back up over a break.

        if (rfo.fxBreak() + xBreakExtra + xExtra < 0)
            xBreakExtra = -(rfo.fxBreak() + xExtra);
        ptqBreakExtra  = rfo.pteUnitBase();
        ptqBreakExtra *= (LONG) xBreakExtra;
        hgBreak        = rfo.hgBreak();
    }

// Prepare for a pdxOut.

    EFLOAT efDtoW = rfo.efDtoWBase();

// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;

// Set the first character position.

    pg->ptl.x = xRef;
    pg->ptl.y = yRef;

// Set up for character loop.

    FIX      xA,xB;
    FIX      xLeft,xRight;      // Accumulate bounds here.
    UINT     ii;
    EPOINTQF ptq;           // Record the current position here.

    ptq.y = ptq.x = (LONGLONG) LONG_MAX + 1;

    xLeft  = 0;             // Start with an empty TextBox.
    xRight = 0;
    xA     = 0;     // Distance along the escapement (x) in device coords.

    BOOL bAccel;

    if (!rfo.bGetGlyphMetricsPlus(cGlyphs,pg, pwsz, &bAccel,&dco,this))
        return;

    if (bAccel)
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

    ASSERTGDI(!rfo.bSmallMetrics(),"ESTROBJ__vCharPos_G2: Small Metrics in cache\n");

    BOOL bZeroBearing = ( rfo.flRealizedType() & SO_ZERO_BEARINGS ) && !bLinkedGlyphs();

    ii = cGlyphs;
    while (TRUE)
    {
    // Update the bounds.

        if( bZeroBearing )
        {
            pgd = pg->pgd();
            if (xA < xLeft)
                xLeft = xA;
            xB = xA + pgd->fxD;
            if (xB > xRight)
                xRight = xB;
        }
        else
        {
            pgd = pg->pgd();
            xB = xA + pgd->fxA;
            if (xB < xLeft)
                xLeft = xB;
            xB = xA + pgd->fxAB;
            if (xB > xRight)
                xRight = xB;
        }

    // Move to the next position.

        xA  += pgd->fxD;
        ptq += pgd->ptqD;

        if ( (xExtra) && (xExtra + pgd->fxD > 0) )
        {
            xA  += xExtra;
            ptq += ptqExtra;
        }

        if (xBreakExtra && (pg->hg == hgBreak))
        {
            xA  += xBreakExtra;
            ptq += ptqBreakExtra;
        }

    // Handle a pdxOut.

        if (pdxOut != (LONG *) NULL)
            *pdxOut++ = lCvt(efDtoW,xA);

        if (--ii == 0)
            break;

    // Save the next position.

        pg++;
        pg->ptl.x = xRef + (LONG) (ptq.x >> 32);
        pg->ptl.y = yRef + (LONG) (ptq.y >> 32);

    }
    fxExtent     = xA;
    ptfxUpdate.x = (LONG) (ptq.x >> 32);
    ptfxUpdate.y = (LONG) (ptq.y >> 32);

// Expand the text box out to the concatenation point.  This allows us to
// continue on with another opaqued string with no visible gap in the
// opaquing.

    if (xA > xRight)
        xRight = xA;
    else if (xA < xLeft)
        xLeft = xA;         // possible if lExtra < 0

    rcfx.xLeft   = xLeft;
    rcfx.xRight  = xRight;
    rcfx.yTop    = rfo.fxMaxAscent();
    rcfx.yBottom = rfo.fxMaxDescent();
    flTO |= TO_VALID;
}

/******************************Public*Routine******************************\
* ESTROBJ::vCharPos_G1 (rfo,xRef,yRef,pdx,pdxOut)
*
* Computes character positions in the case where a pdx array is provided
* and escapement equals orientation.
*
* The following fields of the ESTROBJ are filled in:
*
*  1) Each x,y position.
*  2) Bounding coordinates in rcfx.
*  3) The ptfxUpdate vector.
*
* History:
*  Sun 22-Mar-1992 18:48:19 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

VOID ESTROBJ::vCharPos_G1
(
    XDCOBJ&  dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef,
    LONG     *pdx,
    LONG     *pdxOut
)
{
    ASSERTGDI(!rfo.bSmallMetrics(),"ESTROBJ__vCharPos_G1: Small Metrics in cache\n");

// Our X scale is measured along the escapement direction.  We cache a
// local copy of the unit escapement vector.

    EFLOAT  efScaleX = rfo.efWtoDBase();
    POINTFL pteEsc   = rfo.pteUnitBase();

// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;

// Set the first character position.

    pg->ptl.x = xRef;
    pg->ptl.y = yRef;

// Set up for character loop.

    FIX   xA,xB;
    LONG  xSum;
    FIX   xLeft,xRight;         // Accumulate bounds here.
    UINT  ii;

    xLeft  = 0;             // Start with an empty TextBox.
    xRight = 0;
    xA     = 0;     // Distance along the escapement (x) in device coords.

// To avoid roundoff errors, we accumulate the DX widths in logical
// coordinates and transform the sums.

    xSum = 0;

    BOOL bAccel;

    if (!rfo.bGetGlyphMetricsPlus(cGlyphs, pg, pwsz, &bAccel,&dco,this))
        return;

    if (bAccel)
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

    BOOL bZeroBearing = (rfo.flRealizedType() & SO_ZERO_BEARINGS) && !bLinkedGlyphs();

    ii = cGlyphs;
    while (TRUE)
    {
    // Update the bounds.

        if( bZeroBearing )
        {
            pgd = pg->pgd();
            if (xA < xLeft)
                xLeft = xA;
            xB = xA + pgd->fxD;
            if (xB > xRight)
                xRight = xB;
        }
        else
        {
            pgd = pg->pgd();
            xB = xA + pgd->fxA;
            if (xB < xLeft)
                xLeft = xB;
            xB = xA + pgd->fxAB;
            if (xB > xRight)
                xRight = xB;
        }

    // Add the next offset.

        xSum += *pdx++;
        if (pdxOut != (LONG *) NULL)
            *pdxOut++ = xSum;

    // Scale the new offset.

        xA = lCvt(efScaleX,xSum);

        if (--ii == 0)
            break;

    // Save the next position.

        pg++;
        pg->ptl.x = xRef + lCvt(pteEsc.x,xA);
        pg->ptl.y = yRef + lCvt(pteEsc.y,xA);
    }

// Expand the text box out to the concatenation point.  This allows us to
// continue on with another opaqued string with no visible gap in the
// opaquing.

    if (xA > xRight)
        xRight = xA;

    ptfxUpdate.x = lCvt(pteEsc.x,xA);
    ptfxUpdate.y = lCvt(pteEsc.y,xA);

    rcfx.xLeft   = xLeft;
    rcfx.xRight  = xRight;
    rcfx.yTop    = rfo.fxMaxAscent();
    rcfx.yBottom = rfo.fxMaxDescent();
    flTO |= TO_VALID;
}



/******************************Public*Routine******************************\
* ESTROBJ::vCharPos_H1 (rfo,xRef,yRef,pdx,efScale)
*
* Computes character positions in the simple horizontal case when a pdx
* array is provided.  We use the ABC spacing info for the TextBox.
*
* The following fields of the ESTROBJ are filled in:
*
*  1) Each x,y position.
*  2) Bounding coordinates in rcfx.
*  3) The ptfxUpdate vector.
*  4) The flAccel flags.
*
* History:
*  Sun 22-Mar-1992 18:48:19 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

VOID ESTROBJ::vCharPos_H1
(
    XDCOBJ&  dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef,
    LONG     *pdx,
    EFLOAT    efScale
)
{
// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;

// Compute device driver accelerator flags.

    flAccel |= SO_HORIZONTAL
            | (rfo.flRealizedType() & SO_MAXEXT_EQUAL_BM_SIDE);

// The transform is pretty simple, we're going to handle it ourselves.
// Accelerate on a really simple transform.

    BOOL bUnity = efScale.bIs16();

    BOOL bAccel;

    if (!rfo.bGetGlyphMetricsPlus(cGlyphs, pg, pwsz, &bAccel,&dco,this))
        return;

    if (bAccel)
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

// Set up for character loop.

    FIX   xA,xB;
    LONG  xSum;
    FIX   xLeft,xRight;         // Accumulate bounds here.
    UINT  ii;

    xLeft  = 0;             // Start with an empty TextBox.
    xRight = 0;

// To avoid roundoff errors, we accumulate the DX widths in logical
// coordinates and transform the sums.

    xSum = 0;     // Distance along the escapement in logical coords.
    xA   = 0;     // Distance along the escapement (x) in device coords.

// Set the first character position:

    yRef = FXTOL(yRef + 8);         // Convert y to LONG coordinate
    xRef += 8;                      // Add in rounding offset for later
                                    //   converting x to LONG coordinate
    pg->ptl.x = FXTOL(xRef);
    pg->ptl.y = yRef;

    if((rfo.flRealizedType() & SO_ZERO_BEARINGS) && !bLinkedGlyphs())
    {
        ii = cGlyphs;
        while (TRUE)
        {
        // Update the bounds.

            pgd = pg->pgd();
            if (xA < xLeft)
                xLeft = xA;
            xB = xA + pgd->fxD;
            if (xB > xRight)
                xRight = xB;

        // Add the next offset.

            xSum += *pdx++;

        // Scale the new offset.

            xA = bUnity ? LTOFX(xSum) : lCvt(efScale,xSum);

            if (--ii == 0)
                break;

        // Save the next position.

            pg++;
            pg->ptl.y = yRef;
            pg->ptl.x = FXTOL(xA + xRef);
        }
    }
    else
    {
        ii = cGlyphs;
        while (TRUE)
        {
        // Update the bounds.

            pgd = pg->pgd();
            xB = xA + pgd->fxA;
            if (xB < xLeft)
                xLeft = xB;
            xB = xA + pgd->fxAB;
            if (xB > xRight)
                xRight = xB;

        // Add the next offset.

            xSum += *pdx++;

        // Scale the new offset.

            xA = bUnity ? LTOFX(xSum) : lCvt(efScale,xSum);

            if (--ii == 0)
                break;

        // Save the next position.

            pg++;
            pg->ptl.y = yRef;
            pg->ptl.x = FXTOL(xA + xRef);
        }
    }

// Expand the text box out to the concatenation point.  This allows us to
// continue on with another opaqued string with no visible gap in the
// opaquing.

    if (xA > xRight)
        xRight = xA;

    ptfxUpdate.x = xA;
    ptfxUpdate.y = 0;

    rcfx.xLeft   = xLeft;
    rcfx.xRight  = xRight;

    if (dco.pdc->bYisUp())
    {
        rcfx.yTop    = -rfo.fxMaxDescent();
        rcfx.yBottom = -rfo.fxMaxAscent();
    }
    else
    {
        rcfx.yTop    = rfo.fxMaxAscent();
        rcfx.yBottom = rfo.fxMaxDescent();
    }

    flTO |= TO_VALID;
}

/******************************Public*Routine******************************\
* ESTROBJ::vCharPos_H2()
*
* Computes character positions in the simple horizontal case when
* characters have constant integer width.
*
* The following fields of the ESTROBJ are filled in:
*
*  1) Each x,y position.
*  2) Bounding coordinates in rcfx.
*  3) The ptfxUpdate vector.
*  4) The flAccel flags.
*  5) The fxExtent.
*
* History:
*  Sun 22-Mar-1992 18:48:19 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

VOID ESTROBJ::vCharPos_H2
(
    XDCOBJ&   dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef
   ,EFLOAT    efScale
)
{
// In this case we will also assume that the A and C spaces are
// constants.
//
// NOTE: this is actually wrong assumption for tt fixed pitch fonts
// however, we will set ZERO_BEARINGS flag when we want to lie
// about this to the engine. [bodind]

    LONG  dx;

// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;

    // Set the first character position.  This is the only y position
    // we'll fill in.

        pg->ptl.x = FXTOL(xRef + 8);
        pg->ptl.y = FXTOL(yRef + 8);

    // Compute device driver accelerator flags.

        flAccel |= SO_HORIZONTAL | (rfo.flRealizedType() & SO_ACCEL_FLAGS);

    // Set the width accelerator.  When the device driver sees ulCharInc
    // non-zero, it must not expect any more x coordinates.

        ulCharInc = rfo.lCharInc();
        dx = LTOFX(cGlyphs * ulCharInc);
        fxExtent = dx;

        BOOL bAccel;

        if (!rfo.bGetGlyphMetricsPlus(cGlyphs, pg, pwsz, &bAccel,&dco,this))
            return;

#ifdef FE_SB
    // if there are linked glyphs we can't count on this optimization

        if(bLinkedGlyphs())
        {
            ASSERTGDI((dco.pdc->lTextExtra()|dco.pdc->lBreakExtra()) == 0,
                      "vCharPos_H3 lTextExtra or lBreakExtra non zero\n");

            vCharPos_H3(dco,rfo,xRef,yRef,0,0,dco.pdc->cBreak(),efScale,&bAccel);
            return;
        }
#endif
        if (bAccel)
        {
            flTO |= TO_ALL_PTRS_VALID;
            pgp = pgpos;
        }

        pgd = pg->pgd();

        if (flAccel & SO_ZERO_BEARINGS)
        {
            rcfx.xLeft  = 0;
            rcfx.xRight = dx;
        }
        else
        {
        //
        // Old Comment from bodind might point out possible work item:
        //      these lines of code rely on the const a,c spaces
        //      assumption which is only true for simulated italic
        //      fonts [bodind]

            rcfx.xLeft  = pgd->fxA;
            rcfx.xRight = dx - LTOFX(ulCharInc) + pgd->fxAB;
        }

    if (dco.pdc->bYisUp())
    {
        rcfx.yTop    = -rfo.fxMaxDescent();
        rcfx.yBottom = -rfo.fxMaxAscent();
    }
    else
    {
        rcfx.yTop    = rfo.fxMaxAscent();
        rcfx.yBottom = rfo.fxMaxDescent();
    }

        ptfxUpdate.x = dx;
        ptfxUpdate.y = 0;

        flTO |= TO_VALID;
}

/******************************Public*Routine******************************\
* ESTROBJ::vCharPos_H3 (rfo,xRef,yRef,lExtra,lBreakExtra,cBreak,efScale)
*
* Computes character positions in the simple horizontal case when no pdx
* array is provided and the character widths are not constant.
*
* The following fields of the ESTROBJ are filled in:
*
*  1) Each x,y position.
*  2) Bounding coordinates in rcfx.
*  3) The ptfxUpdate vector.
*  4) The flAccel flags.
*  5) The fxExtent.
*
* History:
*  Sun 22-Mar-1992 18:48:19 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

VOID ESTROBJ::vCharPos_H3
(
    XDCOBJ&  dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef,
    LONG      lExtra,
    LONG      lBreakExtra,
    LONG      cBreak,
    EFLOAT    efScale,
    PBOOL     pbAccel
)
{
// Calculate the lExtra and lBreakExtra spacing.

    HGLYPH hgBreak  = 0;

    if ((lExtra | lBreakExtra) == 0)
    {
    // Will use only character increments given to us with the font

        flAccel |= SO_HORIZONTAL | (rfo.flRealizedType() & SO_ACCEL_FLAGS);
    }
    else
    {
        flAccel |= SO_HORIZONTAL
                | (rfo.flRealizedType() & SO_MAXEXT_EQUAL_BM_SIDE);

        if (lExtra)
        {
            xExtra = lCvt(efScale,lExtra);
            if (xExtra > 0)
                flAccel |= SO_CHARACTER_EXTRA;
        }

        if (lBreakExtra && cBreak)
        {
            xBreakExtra = lCvt(efScale,lBreakExtra) / cBreak;

        // Windows won't let us back up over a break.

            if (rfo.fxBreak() + xBreakExtra + xExtra < 0)
                xBreakExtra = -(rfo.fxBreak() + xExtra);
            hgBreak  = rfo.hgBreak();
            flAccel |= SO_BREAK_EXTRA;
        }
    }

// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;

// Set up for FIX to LONG conversion.

    xRef += 8;
    yRef = FXTOL(yRef + 8);

// Set the first character position.

    pg->ptl.x = FXTOL(xRef);
    pg->ptl.y = yRef;

// Set up for character loop.

    FIX   xA,xB;
    FIX   xLeft,xRight;         // Accumulate bounds here.
    UINT  ii;

    xLeft  = 0;             // Start with an empty TextBox.
    xRight = 0;
    xA     = 0;     // Distance along the escapement (x) in device coords.

    BOOL bAccel;


//  If pbAccel is NULL it means we have encountered the case where we were
//  going to do a fixed pitch optimization of the base font but encountered
//  linked characters which weren't fixed pitch.  In this case we have
//  already called bGetGlyphMetricsPlus and will signal this by passing
//  in a pointer to bAccel

    if( pbAccel == (BOOL*) NULL )
    {
        if (!rfo.bGetGlyphMetricsPlus(cGlyphs, pg, pwsz, &bAccel, &dco, this))
            return;
    }
    else
    {
        bAccel = *pbAccel;
    }

    if (bAccel)
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

// if there are linked glyphs then SO_ZERO_BEARINGS and SO_CHAR_INC_EQUAL_BM_BASE
// will be turned off in the ESTROBJ::bPartitionInit

    if (((flAccel & (SO_ZERO_BEARINGS | SO_CHAR_INC_EQUAL_BM_BASE))
                 == (SO_ZERO_BEARINGS | SO_CHAR_INC_EQUAL_BM_BASE)) &&
        (xExtra >= 0) &&
        (xBreakExtra == 0))
    {
    // This handles the case when the glyphs won't overlap, thus simplifying

    // the computation of the bounding box.

        ii = cGlyphs;
        while (TRUE)
        {
            pgd = pg->pgd();

        // Move to the next position.

            xA += pgd->fxD + xExtra;

            if (--ii == 0)
                break;

        // Save the next position.

            pg++;
            pg->ptl.x = FXTOL(xA + xRef);
            pg->ptl.y = yRef;
        }

    // Expand the text box out to the concatenation point.  This allows us to
    // continue on with another opaqued string with no visible gap in the
    // opaquing.

        xLeft  = 0;
        xRight = xA;
    }
    else
    {
    // This handles the general case.

        ii = cGlyphs;
        while (TRUE)
        {
        // Update the bounds.

            pgd = pg->pgd();
            xB = xA + pgd->fxA;
            if (xB < xLeft)
                xLeft = xB;
            xB = xA + pgd->fxAB;
            if (xB > xRight)
                xRight = xB;

        // Move to the next position.

            xA += pgd->fxD;

        // don't let xExtra backup past the origin of the previous glyph

            if( ( xExtra ) && (pgd->fxD + xExtra  > 0) )
            {
                xA += xExtra;
            }

            if (pg->hg == hgBreak)
                xA += xBreakExtra;

            if (--ii == 0)
                break;

        // Save the next position.

            pg++;
            pg->ptl.x = FXTOL(xA + xRef);
            pg->ptl.y = yRef;
        }

    // Expand the text box out to the concatenation point.  This allows us to
    // continue on with another opaqued string with no visible gap in the
    // opaquing.

        if (xA > xRight)
            xRight = xA;
    }

    fxExtent     = xA;
    ptfxUpdate.x = xA;
    ptfxUpdate.y = 0;

    rcfx.xLeft   = xLeft;
    rcfx.xRight  = xRight;

    if (dco.pdc->bYisUp())
    {
        rcfx.yTop    = -rfo.fxMaxDescent();
        rcfx.yBottom = -rfo.fxMaxAscent();
    }
    else
    {
        rcfx.yTop    = rfo.fxMaxAscent();
        rcfx.yBottom = rfo.fxMaxDescent();
    }

    flTO |= TO_VALID;
}

/******************************Public*Routine******************************\
* ESTROBJ::bOpaqueArea (pptfx,prcl)
*
* Computes the opaquing area for the text.
*
* In the complex case, i.e. non-horizontal case, the TextBox is written as
* a parallelogram into pptfx.  A bounding rectangle is computed in prcl.
* TRUE is returned.
*
* In the simple case, the opaque area is also the bounds and is returned
* only in prcl.  FALSE is returned.
*
* History:
*  Fri 13-Mar-1992 19:52:00 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/


BOOL ESTROBJ::bOpaqueArea(POINTFIX *pptfx,RECTL *prcl)
{
// Handle the simplest case.

    if (flAccel & SO_HORIZONTAL)
    {
    // The opaque area is a simple rectangle.  We do the rounding in a
    // particular order so that if the whole string is displaced by a
    // fraction of a pel in any direction, the TextBox will not change size,
    // and will move exactly with the characters.

        LONG x      = FXTOL(ptfxRef.x + 8);
        prcl->left  = x + FXTOL(rcfx.xLeft);
        prcl->right = x + FXTOLCEILING(rcfx.xRight);

        // Making the background rectangle compatible with WFW
        //
        // The problem surfaced with Dbase for Windows where one found
        // that a console window would not be repainted correctly.  The
        // problem was that the Borland coders relied on the fact that WFW
        // vga drivers make the background rectangle for text equal to the
        // rectangle returned in GetTextExtent().  Using this they would
        // erase blank lines by printing lines with a lot of blanks.  Of
        // course this is an extremely bad thing to do but it got the
        // job done, all be it slowly.  Now the interesting part: Under
        // WFW the background rectangle for emboldend (via simulation)
        // text has a horizontal extend equal to one greater than the sum
        // of character widths.  NT is compatible with this.  However,
        // under NT 3.5 Gdi calculated the horizontal extent of the
        // background rectangle equal to the sum of the character widths
        // (at least for simple fonts e.g.  MS Sans Serif) because this
        // was guaranteed to cover all of the bits of the glyphy.  Thus,
        // for the case of emboldened text, NT had BackGround.x =
        // GetTextExtent.x - 1 where WFW had BackGround.x =
        // GetTextExtent.x.  So if the text is simulated bold we bump the
        // horizontal extent of the background rectangle by 1.

        if (
            (prfo->prfnt->fobj.flFontType & FO_SIM_BOLD) &&
            (prfo->prfnt->flInfo & (FM_INFO_TECH_BITMAP | FM_INFO_TECH_STROKE))
        )
        {
            prcl->right++;

            // The line of code that follows this comment is a
            // hack to compensate for a bug in many of the video
            // drivers shipped with 3.5.  This started with the
            // S3 driver which is the prototype of all of the NT
            // video driver shipped from Microsoft.  The S3
            // driver has the following line of code in textout.c:
            //
            // bTextPerfectFit = (pstro->flAccel &
            // (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
            // SO_MAXEXT_EQUAL_BM_SIDE |
            // SO_CHAR_INC_EQUAL_BM_BASE)) == (SO_ZERO_BEARINGS |
            // SO_FLAG_DEFAULT_PLACEMENT |
            // SO_MAXEXT_EQUAL_BM_SIDE |
            // SO_CHAR_INC_EQUAL_BM_BASE);
            //
            // it says that if flAccel sets all of the following
            // bits {SO_ZERO_BEARINGS, SO_FLAG_DEFAULT_PLACEMENT,
            // SO_MAXEXT_EQUAL_BM_SIDE, SO_CHAR_INC_EQUAL_BM_BASE}
            // then the S3 driver will assume that the text
            // passed down from the driver is "perfect".  The S3
            // driver assumes that if a STROBJ is perfect, then
            // it just has to lay down the text.  This conclusion
            // applys to the background rectangle as well.  That
            // is, the S3 driver assume that if this magic set of
            // bits is set, then it can safely ignore the
            // background rectangle safe in the knowlege that it
            // will be taken care of in the process of laying
            // down the glyphs. Unfortunately, this assumption of
            // perfection is not correct now that I have bumped
            // up the background rectangle by one. What is a
            // coder to do? Well I have decided to make the text
            // not so perfect by erasing one of the bits. This
            // will have a couple of result. First it correct the
            // bug as demonstrated by Dbase for Windows. Second
            // it will slow down the case of emboldened text.
            // How important is this? I don't know. We usually
            // base our performance decisions on WinBench tests.
            // If this hack has a noticeable impact then we may
            // have to rethink this strategy.
            //
            // Ref. Bug No. 25102 "T1 DBaseWin X86 Command ..."
            //
            // Wed 07-Dec-1994 08:25:21 by Kirk Olynyk [kirko]

            flAccel &= ~SO_ZERO_BEARINGS;
        }

        LONG y       = FXTOL(ptfxRef.y + 8);

        prcl->top    = y - FXTOLCEILING(rcfx.yTop);
        prcl->bottom = y - FXTOL(rcfx.yBottom);

        return(FALSE);
    }

// An inverting transform or an escapement could get us here.

    EPOINTFL *ppteBase   = &prfo->pteUnitBase();
    EPOINTFL *ppteAscent = &prfo->pteUnitAscent();

    if (ppteBase->y.bIsZero() && ppteAscent->x.bIsZero())
    {
        LONG x = FXTOL(ptfxRef.x + 8);

        if (ppteBase->x.bIsNegative())
        {
            prcl->left  = x - FXTOLCEILING(rcfx.xRight);
            prcl->right = x - FXTOL(rcfx.xLeft);
        }
        else
        {
            prcl->left  = x + FXTOL(rcfx.xLeft);
            prcl->right = x + FXTOLCEILING(rcfx.xRight);
        }

        LONG y = FXTOL(ptfxRef.y + 8);

        if (ppteAscent->y.bIsNegative())
        {
            prcl->top    = y - FXTOLCEILING(rcfx.yTop);
            prcl->bottom = y - FXTOL(rcfx.yBottom);
        }
        else
        {
            prcl->top    = y + FXTOL(rcfx.yBottom);
            prcl->bottom = y + FXTOLCEILING(rcfx.yTop);
        }

    // fudge an extra pixel, do not have a better solution for a space
    // character at the beginning or at the end of string written horizontally
    // It should not be necessary to do any of
    //
    //     prcl->top--;
    //     prcl->bottom++;
    //
    // because space character is positioned at the baseline, so it should not
    // stick out at the top or at the bottom
    //
    // Also it should not be neccessary to do
    //
    //     prcl->left--;
    //
    // because we always ADD a cx = 1 for the space character to the
    // origin of the space character

        prcl->right++;

        return(FALSE);
    }

// A 90 degree rotation could get us here.

    if (ppteBase->x.bIsZero() && ppteAscent->y.bIsZero())
    {
        LONG x    = FXTOL(ptfxRef.x + 8);

        if (ppteAscent->x.bIsNegative())
        {
            prcl->left   = x - FXTOLCEILING(rcfx.yTop);
            prcl->right  = x - FXTOL(rcfx.yBottom);
        }
        else
        {
            prcl->left   = x + FXTOL(rcfx.yBottom);
            prcl->right  = x + FXTOLCEILING(rcfx.yTop);
        }

        LONG y    = FXTOL(ptfxRef.y + 8);

        if (ppteBase->y.bIsNegative())
        {
            prcl->top    = y - FXTOLCEILING(rcfx.xRight);
            prcl->bottom = y - FXTOL(rcfx.xLeft);
        }
        else
        {
            prcl->top    = y + FXTOL(rcfx.xLeft);
            prcl->bottom = y + FXTOLCEILING(rcfx.xRight);
        }

    // fudge an extra pixel, do not have a better solution for a space
    // character at the beginning or at the end of string written vertically.
    // It should not be necessary to do any of
    //
    //     prcl->right++;
    //     prcl->left--;
    //
    // because space character is positioned at the baseline, so it should not
    // stick out left or right.
    //
    // Also it should not be neccessary to do
    //
    //     prcl->top--;
    //
    // because we always ADD a cy = 1 for the space character to the
    // origin of the space character

        prcl->bottom++;

        return(FALSE);
    }

// The opaque area is a parallelogram.  We multiply the orientation and
// ascent unit vectors by the computed bounding widths to get the
// displacements from the reference point.

    POINTFIX ptfxLeft,ptfxRight,ptfxTop,ptfxBottom;

    ptfxLeft.x   = lCvt(ppteBase->x,rcfx.xLeft);
    ptfxLeft.y   = lCvt(ppteBase->y,rcfx.xLeft);
    ptfxRight.x  = lCvt(ppteBase->x,rcfx.xRight);
    ptfxRight.y  = lCvt(ppteBase->y,rcfx.xRight);
    ptfxTop.x    = lCvt(ppteAscent->x,rcfx.yTop);
    ptfxTop.y    = lCvt(ppteAscent->y,rcfx.yTop);
    ptfxBottom.x = lCvt(ppteAscent->x,rcfx.yBottom);
    ptfxBottom.y = lCvt(ppteAscent->y,rcfx.yBottom);

    pptfx[0].x = ptfxRef.x + ptfxLeft.x  + ptfxTop.x;
    pptfx[1].x = ptfxRef.x + ptfxRight.x + ptfxTop.x;
    pptfx[2].x = ptfxRef.x + ptfxRight.x + ptfxBottom.x;
    pptfx[3].x = ptfxRef.x + ptfxLeft.x  + ptfxBottom.x;
    pptfx[0].y = ptfxRef.y + ptfxLeft.y  + ptfxTop.y;
    pptfx[1].y = ptfxRef.y + ptfxRight.y + ptfxTop.y;
    pptfx[2].y = ptfxRef.y + ptfxRight.y + ptfxBottom.y;
    pptfx[3].y = ptfxRef.y + ptfxLeft.y  + ptfxBottom.y;

// Bound the parallelogram.  (Using Black Magic.)

    int ii;

    ii = (pptfx[1].x > pptfx[0].x)
     == (pptfx[1].x > pptfx[2].x);

    prcl->left   = pptfx[ii].x;
    prcl->right  = pptfx[ii+2].x;

    ii = (pptfx[1].y > pptfx[0].y)
     == (pptfx[1].y > pptfx[2].y);

    prcl->top    = pptfx[ii].y;
    prcl->bottom = pptfx[ii+2].y;

    ((ERECTL *) prcl)->vOrder();

    prcl->left   = FXTOL(prcl->left) - 2;          // to be safe, 1 not enough [bodind]
    prcl->top    = FXTOL(prcl->top) - 2;           // to be safe, 1 not enough [bodind]
    prcl->right  = FXTOLCEILING(prcl->right) + 2;  // to be safe, 1 not enough [bodind]
    prcl->bottom = FXTOLCEILING(prcl->bottom) + 2; // to be safe, 1 not enough [bodind]

    #if 0
    vCorrectBackGround();
    #endif

    return(TRUE);
}

/******************************Public*Routine******************************\
* ESTROBJ::bTextExtent (psize)
*
* Simply transforms the TextBox extents back to logical coordinates.
*
* History:
*  Wed 31-Mar-1993 03:15:04 -by- Charles Whitmer [chuckwh]
* Removed the overhang hack since the RFONTOBJ version of this function is
* the Windows compatible one.  Made it return an advance width based
* extent when (escapement==orientation).  Otherwise, the bounding box is
* the only sensible definition.
*
*  Thu 24-Sep-1992 18:36:14 -by- Charles Whitmer [chuckwh]
* Added the compatibility hack.
*
*  Sat 14-Mar-1992 22:08:21 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

BOOL ESTROBJ::bTextExtent(RFONTOBJ& rfo,LONG lEsc,PSIZE pSize)
{
    if (flTO & TO_ESC_NOT_ORIENT)
    {
        pSize->cx = lCvt(prfo->efDtoWBase(),rcfx.xRight-rcfx.xLeft);
        pSize->cy = lCvt(prfo->efDtoWAscent(),rcfx.yTop-rcfx.yBottom);
    }
    else
    {
    // Computes a more Windows compatible extent.  This is only possible
    // when (escapement==orientation) and no pdx vector was provided.
    // The field fxExtent is only defined in these cases!  We neglect adding
    // in the overhang, since only GetTextExtentEx, a Win32 function, can
    // get here.

        pSize->cx = lCvt(prfo->efDtoWBase(),fxExtent);
        pSize->cy = lCvt(prfo->efDtoWAscent(),prfo->lMaxHeight() << 4);
    }

#ifdef FE_SB
    if( gbDBCSCodePage &&                   // Only in DBCS system locale
        (rfo.iGraphicsMode() == GM_COMPATIBLE) && // We are in COMPATIBLE mode
        !(rfo.flInfo() & FM_INFO_ARB_XFORMS) && // Driver can't do arbitrary rotations
        !(rfo.flInfo() & FM_INFO_TECH_STROKE) && // Not a vector driver
         (rfo.flInfo() & FM_INFO_90DEGREE_ROTATIONS) && // Driver does 90 deg. rotations
         (lEsc == 900L || lEsc == 2700L) // Current font Escapement is 900 or 2700
      )
    {
        LONG lSwap = pSize->cx;
        pSize->cx  = pSize->cy;
        pSize->cy  = lSwap;
    }
#endif FE_SB

    return(TRUE);
}

/******************************Public*Routine******************************\
* bTextToPath (po)
*
* Draws the outlines of all the glyphs in the string into the given path.
*
* History:
*  Wed 17-Jun-1992 15:43:22 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

BOOL ESTROBJ::bTextToPath(EPATHOBJ& po, XDCOBJ& dco, BOOL bNeedUnflattened)
{
    BOOL ReturnValue;

    if (bLinkedGlyphs())
    {
        ReturnValue = bLinkedTextToPath(po, dco, bNeedUnflattened);
    }
    else
    {
        ReturnValue = bTextToPathWorkhorse(po, bNeedUnflattened);
    }
    return(ReturnValue);
}

BOOL ESTROBJ::bTextToPathWorkhorse(EPATHOBJ& po, BOOL bNeedUnflattened)
{
    ULONG     ii, iFound;
    ULONG     cLeft, cGot;
    POINTFIX  ptfxOffset;
    EGLYPHPOS *pg;
    FIX       dx;
    BOOL      bMore;

    cLeft = 0;
    vEnumStart();
    do
    {
        bMore =  STROBJ_bEnum(this, &iFound, (GLYPHPOS**)&pg);
        if (iFound == 0 || pg == 0)
        {
            break;
        }
        if (ulCharInc)
        {
            ASSERTGDI(flAccel & SO_HORIZONTAL, "bTextToPath,text not horizontal\n");

            ptfxOffset.x = pg->ptl.x;
            ptfxOffset.y = pg->ptl.y;

            if (!(flTO & TO_HIGHRESTEXT))
            {
                ptfxOffset.x <<=4;
                ptfxOffset.y <<=4;
            }

            dx = (FIX)(ulCharInc << 4);
            ptfxOffset.x -= dx;
        }
        else
        {
            dx = 0;
        }

        for (cGot = cLeft = iFound; cLeft; cLeft -= cGot)
        {
            //
            // If the paths in the cache have been flattened we will need to
            // call directly to the driver to get unflatttened paths [gerritv].
            //

            if ( bNeedUnflattened )
            {
                if (!prfo->bInsertPathLookaside(pg,FALSE))
                {
                    break;
                }
                cGot = 1;
            }
            else if (!(flTO & TO_ALL_PTRS_VALID))
            {
                if ((cGot = prfo->cGetGlyphData(cLeft,pg)) == 0)
                {
                    break;
                }
            }

            for (ii = 0; ii < cGot; ii++, pg++)
            {
                if (dx)
                {
                    ptfxOffset.x += dx;
                }
                else
                {
                    ptfxOffset.x = pg->ptl.x;
                    ptfxOffset.y = pg->ptl.y;

                    if (!(flTO & TO_HIGHRESTEXT))
                    {
                        ptfxOffset.x <<=4;
                        ptfxOffset.y <<=4;
                    }
                }
                if (!po.bAppend((EPATHOBJ *) pg->pgdf->ppo, &ptfxOffset))
                {
                    if (bNeedUnflattened)
                       pg->pgdf = NULL;
                        
                    break;
                }

                if (bNeedUnflattened)
                    pg->pgdf = NULL;
            }

            if (ii < cGot)
            {
                break;
            }
        }
        if (cLeft)
        {
            break;
        }
    } while (bMore);

    if (bNeedUnflattened)
    {
       flTO = (flTO & ~TO_ALL_PTRS_VALID);
    }   
       
    return(cLeft == 0);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   ESTROBJ::bLinkedTextToPath
*
* Routine Description:
*
*   Renders a text in the form of a path for the case where font linking
*   is in place.
*
* Arguments:
*
*   po - a referece to an EPATHOBJ. This will receive the text path.
*
*   bNeedUnflattened - a variable that indicates that whether the path
*       should be unflattened. If it needs to be unflattened we must
*       go back to the font driver to get the glyph path in its original
*       form before being flattend.
*
* Called by:
*
*   ESTROBJ::bTextToPath
*
* Return Value:
*
\**************************************************************************/

BOOL ESTROBJ::bLinkedTextToPath(EPATHOBJ& po, XDCOBJ& dco, BOOL bNeedUnflattened)
{
    RFONTOBJ *prfoSave;
    WCHAR *pwszSave, *pwcTmp, *pwcSource;
    LONG  *plPart, *plPartLast, lFontLast, lFont, lInflatedMax = 0;
    ULONG count;

    prfoSave   = prfo;
    pgp        = 0;                              // forces enumeration
    flAccel    = 0;
    ulCharInc  = 0;
    pwszSave   = pwszOrg;
    plPartLast = plPartition + cGlyphs;         // useful

    lFontLast = EUDCTYPE_FACENAME + (LONG) prfo->uiNumFaceNameLinks();

    for (lFont = EUDCTYPE_BASEFONT; lFont < lFontLast ; lFont++)
    {
        RFONTTMPOBJ rfoLink;
        RFONTOBJ   *prfoLink;

        // (re)initialize prfo, because it could be pointing to an old 
        // or invalid rfoLink from a previous iteration.
        prfo = prfoSave;

        if (lFont == EUDCTYPE_BASEFONT)
        {
            prfoLink = prfo;
        }
        else
        {
            RFONT *prfnt;

            switch (lFont)
            {
            case EUDCTYPE_SYSTEM_TT_FONT:

                if(cTTSysGlyphs == 0)
                {
                    continue;
                }
                prfnt = prfo->prfntSystemTT();
                break;

            case EUDCTYPE_SYSTEM_WIDE:

                if(cSysGlyphs == 0)
                {
                    continue;
                }
                prfnt = prfo->prfntSysEUDC();
                break;

            case EUDCTYPE_DEFAULT:

                if(cDefGlyphs == 0)
                {
                    continue;
                }
                prfnt = prfo->prfntDefEUDC();
                break;

            default:

                if(cFaceNameGlyphsGet(lFont - EUDCTYPE_FACENAME) == 0)
                {
                    continue;
                }
                prfnt = prfo->prfntFaceName(lFont - EUDCTYPE_FACENAME);
                break;
            }

            if (prfnt == 0)
            {
                RIP("prfnt == 0\n");
                return(FALSE);
            }

            rfoLink.vInit(prfnt);
            prfoLink = (RFONTOBJ*) &rfoLink;

        }

        plPart    = plPartition;
        pwcTmp    = pwcPartition;
        pwcSource = pwszSave;
        count     = 0;
        for ( ; plPart < plPartLast; plPart++, pwcSource++)
        {
            if (*plPart == lFont)
            {
                *pwcTmp++ = *pwcSource;
                count++;
            }
        }

        if (count)
        {
            cGlyphs = count;
            pwszOrg = pwcPartition;
            prfo    = prfoLink;
            vFontSet(lFont);

            if (lFont != EUDCTYPE_BASEFONT)
            {
                POINTL ptlAdjustBaseLine;
                if (bAdjusBaseLine(*prfo, rfoLink, &ptlAdjustBaseLine))
                {
                    ptlBaseLineAdjustSet(ptlAdjustBaseLine);
                }
            }

            if (!bTextToPathWorkhorse(po))
            {
                pwszOrg = pwszSave;
                prfo    = prfoSave;
                return(FALSE);
            }
        }
    }
    pwszOrg = pwszSave;
    prfo    = prfoSave;

    return(TRUE);
}

/******************************Public*Routine******************************\
* bAddPgmToPath (po,x,y,dx1,dy1,dx2,dy2)
*
* Performs the often repeated adding of a parallelogram to a path.
*
*  Tue 07-Apr-1992 00:17:57 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

BOOL bAddPgmToPath(EPATHOBJ& po,FIX x,FIX y,FIX dx1,FIX dy1,FIX dx2,FIX dy2)
{
    POINTFIX aptfx[4];

    aptfx[0].x = x;
    aptfx[0].y = y;
    aptfx[1].x = x + dx1;
    aptfx[1].y = y + dy1;
    aptfx[2].x = x + dx1 + dx2;
    aptfx[2].y = y + dy1 + dy2;
    aptfx[3].x = x + dx2;
    aptfx[3].y = y + dy2;
    return(po.bAddPolygon(XFORMNULL,(POINTL *) aptfx,4));
}

/******************************Public*Routine******************************\
* bExtraRectsToPath (po)
*
* Draws all the underlines and strikeouts into a path, suitable for
* filling.
*
* History:
*  Tue 07-Apr-1992 00:44:00 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

BOOL ESTROBJ::bExtraRectsToPath(EPATHOBJ& po, BOOL bNeedUnflattend)
{
    FIX x;
    FIX y;

// Get local copies of the offsets and thicknesses.

    POINTFIX ptfxUL;
    POINTFIX ptfxULThick;

    ptfxUL.x      = LTOFX(prfo->ptlUnderline1().x);
    ptfxUL.y      = LTOFX(prfo->ptlUnderline1().y);
    ptfxULThick.x = LTOFX(prfo->ptlULThickness().x);
    ptfxULThick.y = LTOFX(prfo->ptlULThickness().y);

    POINTFIX ptfxSO;
    POINTFIX ptfxSOThick;

    ptfxSO.x      = LTOFX(prfo->ptlStrikeOut().x);
    ptfxSO.y      = LTOFX(prfo->ptlStrikeOut().y);
    ptfxSOThick.x = LTOFX(prfo->ptlSOThickness().x);
    ptfxSOThick.y = LTOFX(prfo->ptlSOThickness().y);

// Underlines and strikeouts are continuous and parallel the escapement
// vector, if escapement equals orientation.

    if (!(flTO & TO_ESC_NOT_ORIENT))
    {
        // Round off the starting point.

        x = (ptfxRef.x + 8) & -16;
        y = (ptfxRef.y + 8) & -16;

        if (flTO & TSIM_UNDERLINE1)
        {
            if (!bAddPgmToPath
             (
              po,
              x + ptfxUL.x,
              y + ptfxUL.y,
              ptfxEscapement.x,
              ptfxEscapement.y,
              ptfxULThick.x,
              ptfxULThick.y
             )
               )
            return(FALSE);
        }

        if (flTO & TSIM_STRIKEOUT)
        {
            if (!bAddPgmToPath
             (
              po,
              x + ptfxSO.x,
              y + ptfxSO.y,
              ptfxEscapement.x,
              ptfxEscapement.y,
              ptfxSOThick.x,
              ptfxSOThick.y
             )
               )
            return(FALSE);
        }
        return(TRUE);
    }

// Otherwise underlines and strikeouts apply to each character.

    UINT  ii;
    ULONG cLeft;
    ULONG cGot;

    EGLYPHPOS *pg = pgpos;
    WCHAR *pwsz = pwszOrg;

    for (cGot=cLeft=cGlyphs; cLeft; cLeft-=cGot)
    {
        if (bNeedUnflattend)
        {
            if ((cGot = prfo->cGetGlyphDataLookaside(cLeft, pg)) == 0)
                return (FALSE);
        }
        else if (!(flTO & TO_ALL_PTRS_VALID))
        {
            if ((cGot = prfo->cGetGlyphData(cLeft,pg)) == 0)
                return(FALSE);
        }

        pwsz += cGot;

        EPOINTFL *ppteBase   = &prfo->pteUnitBase();
        POINTFIX ptfxA;
        POINTFIX ptfxB;

        for (ii=0; ii<cGot; ii++,pg++)
        {
            x = pg->ptl.x;
            y = pg->ptl.y;

            // If pg->ptl contains LONG's, we must convert them to FIX's.

            if (!(flTO & TO_HIGHRESTEXT))
            {
                x <<=4;
                y <<=4;
            }

            ptfxA.x = lCvt(ppteBase->x,pg->pgd()->fxA);
            ptfxA.y = lCvt(ppteBase->y,pg->pgd()->fxA);
            ptfxB.x = lCvt(ppteBase->x,(pg->pgd()->fxAB - pg->pgd()->fxA));
            ptfxB.y = lCvt(ppteBase->y,(pg->pgd()->fxAB - pg->pgd()->fxA));

            if (flTO & TSIM_UNDERLINE1)
            {
                if (!bAddPgmToPath
                 (
                  po,
                  x + ptfxUL.x + ptfxA.x,
                  y + ptfxUL.y + ptfxA.y,
                  ptfxB.x,
                  ptfxB.y,
                  ptfxULThick.x,
                  ptfxULThick.y
                 )
               )
                return(FALSE);
            }

            if (flTO & TSIM_STRIKEOUT)
            {
                if (!bAddPgmToPath
                 (
                  po,
                  x + ptfxSO.x + ptfxA.x,
                  y + ptfxSO.y + ptfxA.y,
                  ptfxB.x,
                  ptfxB.y,
                  ptfxSOThick.x,
                  ptfxSOThick.y
                 )
               )
                return(FALSE);
            }
        }
    }
    return(TRUE);
}





/******************************Public*Routine******************************\
* VOID STROBJ_vEnumStart (pstro)
*
* Initialize the string enumerator.
*
* History
*  Tue 17-Mar-1992 10:33:09 -by- Charles Whitmer [chuckwh]
* Simplified it.
*
*  Fri 25-Jan-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

extern "C" VOID STROBJ_vEnumStart(STROBJ *pso)
{
    ((ESTROBJ *)pso)->vEnumStart();
}

/******************************Public*Routine******************************\
* BOOL STROBJ_bEnum
*
* The glyph enumerator.
*
* History:
*  Tue 17-Mar-1992 10:35:05 -by- Charles Whitmer [chuckwh]
* Simplified it and gave it the quick exit.  Also let drivers call here
* direct.
*
*  02-Oct-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL STROBJ_bEnumLinked(ESTROBJ *peso, ULONG *pc,PGLYPHPOS  *ppgpos);

extern "C" BOOL STROBJ_bEnum(STROBJ *pso, ULONG *pc, PGLYPHPOS *ppgpos)
{

    // Quick exit.

#ifdef FE_SB
    if(((ESTROBJ*)pso)->flTO & (TO_PARTITION_INIT|TO_SYS_PARTITION))
    {
        return(STROBJ_bEnumLinked( (ESTROBJ*) pso, pc, ppgpos ));
    }
#endif

    if (((ESTROBJ*)pso)->flTO & TO_ALL_PTRS_VALID)
    {
        *pc = ((ESTROBJ*)pso)->cGlyphs;
        *ppgpos = ((ESTROBJ*)pso)->pgpos;
        return(FALSE);
    }

// compute the number of wc's in the string for which the GLYPHPOS strucs
// have not yet been written to the driver's buffer

    ULONG cgposYetToCopy = ((ESTROBJ*)pso)->cGlyphs - ((ESTROBJ*)pso)->cgposCopied;

    if (cgposYetToCopy == 0)
    {
        *pc = 0;
        return(FALSE);
    }

    GLYPHPOS *pgp = ((ESTROBJ*)pso)->pgpos + ((ESTROBJ*)pso)->cgposCopied;
    ULONG cgposActual; // # of chars enumerated during this call to strobj

    if ( ((ESTROBJ*)pso)->prfo == NULL)  // check for journaling
    {
        WARNING("ESTROBJ::bEnum(), bitmap font, prfo == NULL\n");
        *pc = 0;
        return(FALSE);
    }

    cgposActual =((ESTROBJ*)pso)->prfo->cGetGlyphData(cgposYetToCopy,pgp);

    if (cgposActual == 0)
    {
        *pc = 0;
        return(FALSE);
    }

// The first glyph in a batch should always have the position info.

    if (((ESTROBJ*)pso)->cgposCopied && ((ESTROBJ*)pso)->ulCharInc)
    {
        if (((ESTROBJ*)pso)->flTO & TO_HIGHRESTEXT)
        {
            pgp->ptl.x = ((ESTROBJ*)pso)->pgpos->ptl.x +
                ((((ESTROBJ*)pso)->cgposCopied * ((ESTROBJ*)pso)->ulCharInc) << 4);
        }
        else
        {
            pgp->ptl.x = ((ESTROBJ*)pso)->pgpos->ptl.x +
                ((ESTROBJ*)pso)->cgposCopied * ((ESTROBJ*)pso)->ulCharInc;
        }
        pgp->ptl.y = ((ESTROBJ*)pso)->pgpos->ptl.y;
    }

    ((ESTROBJ*)pso)->cgposCopied += cgposActual;     // update enumeration state

    *pc = cgposActual;
    *ppgpos = pgp;

    return(((ESTROBJ*)pso)->cgposCopied < ((ESTROBJ*)pso)->cGlyphs);  // TRUE => more to come.
}

/******************************Public*Routine******************************\
* vGenWidths
*
* Computes the advance widths for escapement not equal to orientation.
* The theory is pretty simple.  We construct an 'egg' whose upper and
* lower outlines are half ellipses with sizes determined by the top and
* bottom of the ink box.  The escapement vector always goes through the
* center of the character baseline.  We call that point (halfway between
* the normal concatenation points of the glyph) the 'center'.  We advance
* the current position from where the escapement vector first pierces the
* egg to the center, and then from the center to where the vector exits
* the egg.  These are the D1 and D2 returned widths from this routine.
*
*  Mon 07-Jun-1993 12:27:22 -by- Charles Whitmer [chuckwh]
* Wrote it long ago.  My apologies for the undocumented math.
\**************************************************************************/

VOID vGenWidths
(
    FIX    *pfxD1,      // First part of advance width. (Returned.)
    FIX    *pfxD2,      // Second part of advance width. (Returned.)
    EFLOAT& efRA,       // Projection ratio of escapement onto Ascent.
    EFLOAT& efRB,       // Projection ratio of escapement onto Baseline.
    FIX     fxWidth,    // Normal width.
    FIX     fxTop,      // Top of ink box.
    FIX     fxBottom,   // Bottom of ink box.
    FIX     fxMaxAscent
)
{
    EFLOAT efA,efB,efOne;
    FIX    fxTemp;

// Worry about the width being zero.  This can occur in a Unicode font.
// Never advance in this case, since the character is some kind of
// overpainting glyph.

    if (fxWidth == 0)
    {
        *pfxD2 = 0;
        *pfxD1 = 0;
        return;
    }

// For escapement along the baseline, we return the normal width, separated
// into two parts.

    if (efRA.bIsZero())
    {
        *pfxD1 = fxWidth / 2;
        *pfxD2 = fxWidth - *pfxD1;
        return;
    }

    if (fxBottom == fxTop)      // Probably a break character.
    {
        fxBottom = -(fxMaxAscent / 4);
        fxTop    = fxMaxAscent/2 + fxBottom;
    }
    if (fxBottom >= 0)
        fxBottom = 0;
    if (fxTop <= 0)
        fxTop = 0;
    if (efRA.bIsNegative())
    {
        fxTemp   = fxBottom;
        fxBottom = -fxTop;
        fxTop    = -fxTemp;
    }

// Provide a little extra spacing in addition to the ink box.

    fxTop    += fxMaxAscent / 16;
    if ( fxTop == 0 )
    {
        WARNING1("vGenWidths: fxTop == 0 .. setting to +1\n");
        fxTop = 1;
    }
    fxBottom -= fxMaxAscent / 16;
    if ( fxBottom == 0 )
    {
        WARNING1("vGenWidths: fxBottom == 0 .. setting to -1\n");
        fxBottom = -1;
    }

// For escapement in the ascent direction, we return a width that will
// traverse the ink box.  Note that the general code below would give the
// same result, only take longer!

    if (efRB.bIsZero())
    {
        *pfxD2 = fxTop;
        *pfxD1 = -fxBottom;
        return;
    }

// Compute the displacements.

    ASSERTGDI(fxWidth, "fxWidth == 0\n");
    efB = fxWidth;          // Converts to EFLOAT.
    efB.vDivBy2();
    efB.eqDiv(efRB,efB);
    efB.eqMul(efB,efB);

    efA = fxBottom;
    efA.eqDiv(efRA,efA);
    efA.eqMul(efA,efA);
    efA.eqAdd(efA,efB);
    efA.eqSqrt(efA);
    efOne.vSetToOne();
    efA.eqDiv(efOne,efA);
    efA.bEfToL(*pfxD1);

    efA = fxTop;
    efA.eqDiv(efRA,efA);
    efA.eqMul(efA,efA);
    efA.eqAdd(efA,efB);
    efA.eqSqrt(efA);
    efA.eqDiv(efOne,efA);
    efA.bEfToL(*pfxD2);
    return;
}



/******************************Public*Routine******************************\
*
* VOID ESTROBJ::vCharPos_H4, pdxdy case for zero esc and orientation
*
* History:
*  18-Sep-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID ESTROBJ::vCharPos_H4
(
    XDCOBJ&  dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef,
    LONG     *pdxdy,
    EFLOAT    efXScale,
    EFLOAT    efYScale
)
{
// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;
    POINTL *pDxDy = (POINTL *)pdxdy;

// The transform is pretty simple, we're going to handle it ourselves.
// Accelerate on a really simple transforms.

    BOOL bUnityX = efXScale.bIs16();
    BOOL bUnityY = efYScale.bIs16();

    BOOL bAccel;


    if (!rfo.bGetGlyphMetricsPlus(cGlyphs, pg, pwsz, &bAccel,&dco,this))
        return;

    if (bAccel)
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

// Set up for character loop.

    FIX   xA,xB;
    FIX   yT,yB;
    LONG  xSum, ySum;
    FIX   xLeft,xRight, yTop, yBottom;  // Accumulate bounds here.
    UINT  ii;
    FIX fxAscent, fxDescent;

    if (dco.pdc->bYisUp())
    {
        fxAscent  = -rfo.fxMaxDescent();
        fxDescent = -rfo.fxMaxAscent();
    }
    else
    {
        fxAscent  = rfo.fxMaxAscent();
        fxDescent = rfo.fxMaxDescent();
    }

    xLeft  = 0;             // Start with an empty TextBox.
    xRight = 0;
    yTop   = 0;
    yBottom = 0;

// To avoid roundoff errors, we accumulate the DX widths in logical
// coordinates and transform the sums.

    xSum = 0;     // Distance along the escapement in logical coords.
    ySum = 0;     // Distance along the ascender in logical coords.
    xA   = 0;     // Distance along the escapement (x) in device coords.
    yT   = 0;     // Distance along the ascender (y) in device coords

// Set the first character position:

    yRef += 8;  // Add in rounding offset for later
    xRef += 8;  // converting x and y to LONG coordinates

    pg->ptl.x = FXTOL(xRef);
    pg->ptl.y = FXTOL(yRef);

    ii = cGlyphs;
    while (TRUE)
    {
    // Update the bounds.

        pgd = pg->pgd();
        xB = xA + pgd->fxA;
        if (xB < xLeft)
            xLeft = xB;
        xB = xA + pgd->fxAB;
        if (xB > xRight)
            xRight = xB;

    // make top and bottom independent of glyphs, ie replace glyph in the
    // string by another one, want to get the same top and bottom, possibly
    // different left and right.
    // (this is similar to how all other H? cases work)

        yB = yT + fxAscent;
        if (yB > yTop)
            yTop = yB;
        yB = yT + fxDescent;
        if (yB < yBottom)
            yBottom = yB;

    // Add the next offset.

        xSum += pDxDy->x;
        ySum += pDxDy->y;
        pDxDy++;

    // Scale the new offset.

        xA = bUnityX ? LTOFX(xSum) : lCvt(efXScale,xSum);
        yT = bUnityY ? LTOFX(ySum) : lCvt(efYScale,ySum);

        if (--ii == 0)
            break;

    // Save the next position.

        pg++;
        pg->ptl.x = FXTOL(xA + xRef);
        pg->ptl.y = FXTOL(-yT + yRef); // y goes down, not opposite from ascender
    }

// Expand the text box out to the concatenation point.  This allows us to
// continue on with another opaqued string with no visible gap in the
// opaquing.

    if (xA > xRight)
        xRight = xA;

    ptfxUpdate.x = xA;
    ptfxUpdate.y = -yT;

    rcfx.xLeft   = xLeft;
    rcfx.xRight  = xRight;

    if (dco.pdc->bYisUp())
    {
        rcfx.yTop    = -yBottom;
        rcfx.yBottom = -yTop;
    }
    else
    {
        rcfx.yTop    = yTop;
        rcfx.yBottom = yBottom;
    }


    flTO |= TO_VALID;
}


/******************************Public*Routine******************************\
*
* VOID ESTROBJ::vCharPos_G4
*
* handles pdy case with esc != orientation
*
* History:
*  17-Sep-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID ESTROBJ::vCharPos_G4
(
    XDCOBJ&  dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef,
    LONG     *pdxdy
)
{
// In this case, we keep track of how far we have traveled along the
// escapement vector in device coordinates.  We need scales to project
// this distance onto the base and ascent, as well as a unit escapement
// vector to find the position.

    POINTFL pteEsc  = rfo.pteUnitEsc();     // Unit escapement vector.
    POINTFL pteAsc  = rfo.pteUnitAscent();  // Unit ascender vector.
    EFLOAT efScaleX = rfo.efEscToBase();    // Project escapement to baseline.
    EFLOAT efScaleY = rfo.efEscToAscent();  // Project escapement to ascent.

// Compute logical to device transforms.

    EFLOAT efWtoDEsc = rfo.efWtoDEsc();    // Forward transform for pdx.
    EFLOAT efWtoDAsc = rfo.efWtoDAscent(); // Forward transform for pdy
    BOOL   bUnityEsc = efWtoDEsc.bIs16();
    BOOL   bUnityAsc = efWtoDAsc.bIs16();

// Compute extra spacing for the non-pdx case.

    FIX    fxD1,fxD2;       // Pre- and Post-center character widths.
    FIX    fxAscent  = rfo.fxMaxAscent();  // Cache locally.
    FIX    fxDescent = rfo.fxMaxDescent(); // Cache locally.

    ASSERTGDI(pdxdy, "G4 text out case: pdxdy is null\n");
    ASSERTGDI(cGlyphs > 0, "G4, cGlyphs == 0\n");

// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;

// Set the first character position.

    pg->ptl.x = xRef;
    pg->ptl.y = yRef;

// Set up for character loop.

    LONG   xSum;        // Keep pdx sum here.
    LONG   ySum;        // Keep pdy sum here.
    FIX    xA,xB;       // Baseline coordinates.
    FIX    yA,yB;       // Ascent coordinates.
    FIX    sA;          // Position on the escapement vector.
    FIX    sT;          // Position on the ascender vector.

    RECTFX rcfxBounds;  // Accumulate bounds here.
    UINT   ii;
    POINTL *pDxDy = (POINTL *)pdxdy;

    rcfxBounds.xLeft   = LONG_MAX; // Start with an empty TextBox.
    rcfxBounds.xRight  = LONG_MIN;
    rcfxBounds.yTop    = LONG_MIN;
    rcfxBounds.yBottom = LONG_MAX;

// We keep the current concatenation point in sA.  Note that this is NOT
// where the character origin will be placed.

    sA   = sT   = 0;
    xSum = ySum = 0;

    BOOL bAccel;

    if (!rfo.bGetGlyphMetricsPlus(cGlyphs, pg, pwsz, &bAccel, &dco, this))
        return;

    if (bAccel)
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

    for (ii=0; ii<cGlyphs; ii++, pg++, pDxDy++)
    {
        pgd = pg->pgd();

    // Using the GenWidths function, determine where the
    // character center should be placed.

        vGenWidths
        (
            &fxD1,              // Pre-center spacing
            &fxD2,              // Post-center spacing
            efScaleY,           // Ascent projection
            efScaleX,           // Baseline projection
            pgd->fxD,           // Character width
            pgd->fxInkTop,      // Ink box top
            pgd->fxInkBottom,   // Ink box bottom
            fxAscent            // Maximum Ascent
        );

        sA += fxD1;         // Advance to the character center.

    // Update ascent bounds.

        yA = lCvt(efScaleY,sA) + sT; // Project onto ascent.
        yB = yA + fxDescent;
        if (yB < rcfxBounds.yBottom)
            rcfxBounds.yBottom = yB;
        yB = yA + fxAscent;
        if (yB > rcfxBounds.yTop)
            rcfxBounds.yTop = yB;

        ASSERTGDI(!rfo.bSmallMetrics(),"ESTROBJ__vCharPos_G3: Small Metrics in cache\n");

    // Project the center position onto the baseline and
    // move back to the character origin.

        xA = lCvt(efScaleX,sA) - pgd->fxD / 2;

    // Update the width bounds.  Fudge a quarter pel on each side for
    // roundoff.

        xB = xA + pgd->fxA - 4;
        if (xB < rcfxBounds.xLeft)
            rcfxBounds.xLeft = xB;
        xB = xA + pgd->fxAB + 4;
        if (xB > rcfxBounds.xRight)
            rcfxBounds.xRight = xB;

    // Save the adjusted character origin.

        pg->ptl.x
         = xRef + lCvt(pteEsc.x,sA) + lCvt(pteAsc.x,sT) - pgd->ptqD.x.u.HighPart / 2;

        pg->ptl.y
         = yRef + lCvt(pteEsc.y,sA) + lCvt(pteAsc.y,sT) - pgd->ptqD.y.u.HighPart / 2;

    // Advance to the next concatenation point.

        xSum += pDxDy->x;
        ySum += pDxDy->y;

        sA = bUnityEsc ? LTOFX(xSum) : lCvt(efWtoDEsc,xSum);
        sT = bUnityAsc ? LTOFX(ySum) : lCvt(efWtoDAsc,ySum);
    }


// ptfxUpdate, continue where the last glyph is written:

    ptfxUpdate.x = lCvt(pteEsc.x,sA) + lCvt(pteAsc.x,sT);
    ptfxUpdate.y = lCvt(pteEsc.y,sA) + lCvt(pteAsc.y,sT);

    rcfx = rcfxBounds;
    flTO |= TO_VALID;
}


/******************************Public*Routine******************************\
* STROBJ_bGetAdvanceWidthsLinked(
*
* returns the widths for the batch of glyphs from the current font
*
* Warnings: assumes that the glyph has been partitioned properly
*
* History:
*  27-Jan-1998 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL STROBJ_bGetAdvanceWidthsLinked(
    ESTROBJ * peso,
    ULONG     iFirst,
    ULONG     cBatch,
    POINTQF  *pptqD
)
{
// Quick exit.

    BOOL bRet = FALSE;
    ULONG iG, iLast;

    iG = 0;
    iLast = iFirst +  cBatch;


    if (iLast <= peso->cGlyphs)
    {
        bRet = TRUE;

        for(iG = 0, peso->plNext = peso->plPartition, peso->pgpNext = peso->pgpos;
            iG < iLast;
            (peso->pgpNext)++, (peso->plNext)++)
        {

            if (*(peso->plNext) == peso->lCurrentFont)
            {
                if (iG >= iFirst)
                {
                    EGLYPHPOS *pg = (EGLYPHPOS *)peso->pgpNext;

                    if (peso->prfo->bSmallMetrics())
                    {
                        pptqD->x.u.HighPart = pg->pgd()->fxD;
                        pptqD->x.u.LowPart = 0;
                        pptqD->y.u.HighPart = 0;
                        pptqD->y.u.LowPart = 0;
                    }
                    else
                    {
                        *pptqD = pg->pgd()->ptqD;
                    }

                // get to the next adv. width

                    pptqD++;
                }

            // increment iG, count of glyphs from this font

                iG++;
            }
        }
    }
    return bRet;
}



/******************************Public*Routine******************************\
*
*
* Effects: accelerator for the printer drivers, they need to know how to
*          update current position, so they need advance vectors of glyphs
*          in this string.
*
* Warnings: I think this will not work for linked fonts
*           On the other hand printer driver never get called with STROBJ
*           for linked string, so this should be ok.
*
* History:
*  09-Jan-1998 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


extern "C" BOOL APIENTRY STROBJ_bGetAdvanceWidths(
    STROBJ   *pso, ULONG iFirst, ULONG cBatch,POINTQF  *pptqD
    )
{
// We know that all the widths are in the cache, computed already
// just need to copy them down

    if(((ESTROBJ*)pso)->flTO & (TO_PARTITION_INIT|TO_SYS_PARTITION))
    {
        return STROBJ_bGetAdvanceWidthsLinked((ESTROBJ*)pso,iFirst,cBatch,pptqD);
    }

    BOOL bRet = FALSE;

    if ((iFirst +  cBatch) <= ((ESTROBJ*)pso)->cGlyphs)
    {
        EGLYPHPOS *pg    = &((ESTROBJ*)pso)->pgpos[iFirst];
        EGLYPHPOS *pgEnd = pg  + cBatch;
        bRet = TRUE;

        if (((ESTROBJ*)pso)->prfo->bSmallMetrics())
        {
            for ( ; pg < pgEnd; pg++, pptqD++)
            {
                pptqD->x.u.HighPart = pg->pgd()->fxD;
                pptqD->x.u.LowPart = 0;
                pptqD->y.u.HighPart = 0;
                pptqD->y.u.LowPart = 0;
            }
        }
        else
        {
            for ( ; pg < pgEnd; pg++)
            {
                *pptqD++ = pg->pgd()->ptqD;
            }
        }
    }
    return bRet;
}


/******************************Public*Routine******************************\
*
* BOOL STROBJ_bEnumPositionsOnlyLinked
*
* Enumerates positions only in paralel with STROBJ_bEnumLinked in misceudc.cxx
*
* History:
*  20-Jan-1998 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL STROBJ_bEnumPositionsOnlyLinked(ESTROBJ *peso, ULONG *pc,PGLYPHPOS  *ppgpos)
{
// Quick exit.

    if( peso->cgposPositionsEnumerated == 0 )
    {
        for( peso->plNext = peso->plPartition, peso->pgpNext = peso->pgpos;
            *(peso->plNext) != peso->lCurrentFont;
            (peso->pgpNext)++, (peso->plNext)++ );
        {
        }
    }
    else
    {
       if (peso->cgposPositionsEnumerated == peso->cGlyphs)
       {
        // no more glyphs so just return
            *pc = 0;
            return(FALSE);
       }
       else
       {
        // find next glyph

            for( (peso->plNext)++, (peso->pgpNext)++;
                 *(peso->plNext) != (peso->lCurrentFont);
                 (peso->pgpNext)++, (peso->plNext)++ );
            {
            }
       }
    }

    peso->cgposPositionsEnumerated += 1;     // update enumeration state
    *pc = 1;
    *ppgpos = peso->pgpNext;

    return(peso->cgposPositionsEnumerated < peso->cGlyphs);  // TRUE => more to come.
}


BOOL APIENTRY STROBJ_bEnumPositionsOnly(
    STROBJ    *pso,
    ULONG     *pc,
    PGLYPHPOS *ppgpos
    )
{
// Quick exit.

    if(((ESTROBJ*)pso)->flTO & (TO_PARTITION_INIT|TO_SYS_PARTITION))
    {
        return STROBJ_bEnumPositionsOnlyLinked((ESTROBJ*)pso, pc, ppgpos);
    }

// if not linked all positions are guaranteed to be in the cache:

    *pc = ((ESTROBJ*)pso)->cGlyphs;
    *ppgpos = ((ESTROBJ*)pso)->pgpos;
    return(FALSE); // no more
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\textddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: textddi.cxx
*
*   EngTextOut text drawing to DIBs
*
* Copyright (c) 1994-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"


VOID vRectBlt(PBYTE, ULONG, LONG, LONG, LONG, LONG);
VOID vRectBlt4(BYTE*,ULONG, LONG, LONG, LONG, LONG);
VOID vRectBlt8(BYTE*,ULONG, LONG, LONG, LONG, LONG);

class FRINGERECT
{
private:
    SURFACE  *pSurf;
    PVOID    pvBits; // see comment [1] below
    CLIPOBJ  *pco;
    BRUSHOBJ *pboOpaque;
    int      crcl;              // Count of fringe rectangles to do.
    RECTL    arcl[4];

public:
    FRINGERECT(SURFACE *pSurf1,CLIPOBJ *pco1,BRUSHOBJ *pboOpaque1)
    {
        pSurf     = pSurf1;

        if (pSurf1->iType() == STYPE_BITMAP)
             pvBits = pSurf1->pvBits();
        else
             pvBits = NULL;

        pco       = pco1;
        pboOpaque = pboOpaque1;
        crcl      = 0;
    }

   ~FRINGERECT()
    {
        //
        // We just assume the Rop is P according to the DDI.
        //

        if (pvBits)
        {
            while (--crcl >= 0)
            {
                vDIBSolidBlt(
                    pSurf                 ,
                    &arcl[crcl]           ,
                    pco                   ,
                    pboOpaque->iSolidColor,
                    FALSE
                    );
            }
        }
        else
        {
            // this section was put in to support AntiAliased
            // text. It is possible that for the case of
            // antialiased text EngTextOut could be asked to
            // render to a device managed surface. In that
            // case, we use the device's BitBlt function to
            // render the rectangles

            POINTL  ptlBrush = {0,0}; // it does not matter, it is solid color always
            RECTL   *prcl;
            SURFOBJ *pso            = pSurf->pSurfobj();
            PFN_DrvBitBlt pFnBitBlt = pSurf->pfnBitBlt();


            for (prcl = arcl; prcl < arcl + crcl; prcl++)
            {
                (*(pFnBitBlt))(
                    pso              , // psoTrg
                    0                , // psoSrc
                    0                , // psoMask
                    pco              , // pco
                    0                , // pxlo
                    prcl             , // prclTrg
                    0                , // pptlSrc
                    0                , // pptlMask
                    pboOpaque        , // pbo
                    &ptlBrush        , // pptlBrush
                    0x0000f0f0         // rop4
                    );
            }
        }
    }

    VOID vAddRect(LONG left, LONG top, LONG right, LONG bottom)
    {
        arcl[crcl].left   = left;
        arcl[crcl].top    = top;
        arcl[crcl].right  = right;
        arcl[crcl].bottom = bottom;
        crcl++;
    }
};

/***********************************************************************
*    [1]                                                               *
*                                                                      *
*    Before GDI provided support for antialiased text it would         *
*    not have been possible to have a surface without a pointer        *
*    to the DIB bits. However, in the case of antialiased text         *
*    it is possible that we reached here by way of GreExtTextOutW()    *
*    ( this case is signaled by pSurf->pdcoAA != 0  ). In this         *
*    case, the original surface of the device may not be accessible    *
*    by GDI. This case would be indicated by a zero value for          *
*    pvBits. You might worry that this means that we cannot take       *
*    care of the background rectangles. But this is not the case!      *
*    The background rectangle will be taken care of by GreExtTextOutW. *
*                                                                      *
***********************************************************************/

#define SO_MASK                     \
(                                   \
    SO_FLAG_DEFAULT_PLACEMENT |     \
    SO_ZERO_BEARINGS          |     \
    SO_CHAR_INC_EQUAL_BM_BASE |     \
    SO_MAXEXT_EQUAL_BM_SIDE         \
)


#define     TEXT_BUFFER_SIZE    1024
#define     KERNEL_ALLOC_SIZE   65536

//
// accelerator masks for four canonical directions of
// writing (multiples of 90 degrees)
//

#define SO_LTOR          (SO_MASK | SO_HORIZONTAL)
#define SO_RTOL          (SO_LTOR | SO_REVERSED)
#define SO_TTOB          (SO_MASK | SO_VERTICAL)
#define SO_BTOT          (SO_TTOB | SO_REVERSED)

//
// Glyph copy Declarations
//

typedef VOID (*PFN_MASTERTEXTTYPE)(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);

//
// Temp buffer expansion Declarations
//

typedef VOID (*PFN_TEXTSRCCPY)(
    BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

VOID vExpandAndCopyText(
    SURFACE *,
    FONTOBJ * ,
    GLYPHPOS *,
    ULONG    ,
    PBYTE,
    ULONG,
    ULONG,
    SURFACE *,
    SURFACE *,
    RECTL *,
    RECTL *,
    INT,
    INT,
    ULONG,
    RECTL *,
    RECTL *,
    ULONG,
    BRUSHOBJ *,
    POINTL *
    );

extern "C" {

VOID vFastText(
    GLYPHPOS *,
    ULONG    ,
    PBYTE,
    ULONG,
    ULONG,
    SURFOBJ *,
    RECTL *,
    RECTL *,
    INT,
    INT,
    ULONG,
    RECTL *,
    RECTL *
    );

VOID vSrcTranCopyError(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

VOID vSrcTranCopyS1D1(   BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS1D4(   BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS1D8(   BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS1D16(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS1D24(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS1D32(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

VOID vSrcOpaqCopyS1D1(   BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS1D4(   BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS1D8(   BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS1D8_64(BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS1D32(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS1D16(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS1D24(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

VOID vSrcTranCopyS4D16(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS4D24(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS4D32(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

VOID vSrcOpaqCopyS4D16(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS4D24(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS4D32(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

VOID vSrcOpaqCopyS8D16(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS8D24(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS8D32(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

VOID vSrcTranCopyS8D16(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS8D24(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS8D32(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);





VOID draw_f_tb_no_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);
VOID draw_nf_tb_no_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);
VOID draw_f_ntb_o_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);
VOID draw_nf_ntb_o_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);

// grayscale routines

VOID draw_gray_nf_ntb_o_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);
VOID draw_gray_f_ntb_o_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);

// cleartype routines

VOID draw_clrt_nf_ntb_o_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);
VOID draw_clrt_f_ntb_o_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);

ULONG TextExpStartMask[]  = {0xFFFFFFFF,
                             0xFFFFFF00,
                             0xFFFF0000,
                             0xFF000000
                            };

ULONG TextExpEndMask[]    = {0xFFFFFFFF,
                             0x000000FF,
                             0x0000FFFF,
                             0x00FFFFFF
                            };

LONG  TextExpStartByteCount[] = {0,3,2,1};

}




#define NO_TARGET 0
#define     FIFTEEN_BITS        ((1 << 15)-1)

#if DBG
void vDump8bppDIB(SURFMEM& surfmem);
#endif

/******************************Public*Routine******************************\
* Routine Name:
*
*   EngTextOut
*
* Routine Description:
*
*   This routine blts glyphs to a DIB.
*
* Arguments:
*
*   pso         - Surface object for destination surface
*   pstro       - String object for enumerating glyphs
*   pfo         - Font object of glyphs
*   pco         - Clip object
*   prclExtra   - Extra rectangles to draw with text
*   prclOpaque  - Opaque rectangle
*   pboFore     - Foreground brush
*   pboOpaque   - Background brush
*   pptlOrg     - Brush starting origin
*   mix         - Equal to SRCCOPY for now
*
* Return Value:
*
*   BOOL Status
*
\**************************************************************************/
#define ETO_GRAY                       8
#define ETO_DEVICE_SURFACE            16
#define ETO_CLEARTYPE_X               32
#define ETO_CLEARTYPE_Y               64

VOID EngTextOutBitBlt(
    SURFACE     *pSurf,
    FONTOBJ     *pfo,
    ULONG       fDrawFlags,
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoMsk,
    CLIPOBJ     *pco,
    XLATEOBJ    *plxo,
    RECTL       *prclTrg,
    POINTL      *pptlSrc,
    POINTL      *pptlMsk,
    BRUSHOBJ    *pbo,
    POINTL      *pptlBrush,
    ROP4        rop4
)
{

    if (fDrawFlags & ETO_DEVICE_SURFACE)
    {
        RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));

        TextOutBitBlt(pSurf, rfo, psoSrc, psoMsk, pco, plxo,
                      prclTrg, pptlSrc, pptlMsk, pbo, pptlBrush, rop4);
    }
    else
    {
        EngBitBlt(pSurf->pSurfobj(), psoSrc, psoMsk, pco, plxo,
                  prclTrg, pptlSrc, pptlMsk, pbo, pptlBrush, rop4);
    }
}

BOOL EngTextOut(
    SURFOBJ  *pso,
    STROBJ   *pstro,
    FONTOBJ  *pfo,
    CLIPOBJ  *pco,
    PRECTL    prclExtra,
    PRECTL    prclOpaque,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    PPOINTL   pptlOrg,
    MIX       mix
    )
{
    ULONG           iClip;                  // Clip object's complexity
    BOOL            bMore;                  // Flag for clip enumeration
    CLIPENUMRECT    txen;                   // Clip enumeration object
    GLYPHPOS       *pgp;                    // pointer to the 1st glyph
    BOOL            bMoreGlyphs;            // Glyph enumeration flag
    ULONG           cGlyph;                 // number of glyphs in one batch
    ULONG           iSolidForeColor;        // Solid foreground color
    ULONG           iSolidBkColor;          // Solid background color
    FLONG           flStr = 0;              // Accelator flag for DrvTextOut()
    FLONG           flOption = 0;           // Accelator flag for pfnBlt
    RECTL           arclTmp[4];             // Temp storage for portions of
                                            //  opaquing rect
    RECTL          *prclClip;               // ptr to list of clip rectangles
    ULONG           ulBufferWidthInBytes = 0;
    ULONG           ulBufferHeight;
    ULONG           ulBufferBytes;
    BOOL            bTextPerfectFit;
    ULONG           fDrawFlags = 0;
    BYTE           *pjTempBuffer;
    BOOL            bTempAlloc;
    BOOL            bKernelAlloc;
    BYTE            szTextBuffer[TEXT_BUFFER_SIZE];
    ULONG           Native64BitAccess = TRUE;
    ULONG           iTrgType = 0;
    SURFACE        *pSurfDraw;
    RECTL           rcScreen;               // intersection of Screen & DIB
                                            // in screen coordinates
    RECTL           rcDIB;                  // intersection of Screen & DIB
                                            // in DIB coordinates

    XDCOBJ         *pdco = 0;               // equal to pSurf->pdcoAA
                                            // this is non-zero in the case
                                            // where the text in anti-aliased
                                            // and the device does not support
                                            // antialiased text directly. In such
                                            // a case we must be able to pass
                                            // information about the original
                                            // deivce surface
    SURFACE        *pSurfDevice = 0;        // pointer to original device surface
                                            // this is obtained via pdco

// This hack, due to filtering needs to be put in textgdi.cxx
// filtering leeks color one pixel to the left and one pixel to the right

    ASSERTGDI(pso   != (SURFOBJ *) NULL, "ERROR: EngTextOut Surface\n");
    ASSERTGDI(pstro != (STROBJ  *) NULL, "ERROR: EngTextOut String\n" );
    ASSERTGDI(pfo   != (FONTOBJ *) NULL, "ERROR: EngTextOut Font\n"   );

    // In order to support antialiasing text on devices that don't
    // support antialiasing GDI will first render the text to
    // a DIB then later copy the DIB to the original device surface.
    // In such a case pso represents the DIB surface and mix
    // contains a pointer to the original XDCOBJ which will
    // be needed in order to interpret the colors corectly. The
    // way that we recognize this situation is that
    // pSurf->pdcoAA is non-zero

    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);
    pSurfDraw = pSurf;

    if (pfo->flFontType & FO_GRAY16)
    {
        if ( pdco = pSurf->pdcoAA )
        {
            ASSERTGDI(pdco->dctp() != DCTYPE_INFO, "dctp == DCTYPE_INFO\n");

            pSurfDevice = pdco->pdc->ppdev()->pSurface;

        }
        else
        {
            pSurfDevice = pSurf;
        }

        if (pSurf->iType() != STYPE_BITMAP)
        {
            fDrawFlags |= ETO_DEVICE_SURFACE;
        }
    }

    if ((pfo->flFontType & DEVICE_FONTTYPE) != 0)
    {
        WARNING("Attempting EngTextOut with Device Font\n");
        return(FALSE);
    }

    //
    // Note that we don't synchronize with the device here (we do that in
    // vExpandAndCopyText after doing a bunch of work not involving the
    // frame buffer), but we do let the driver know we're going to be
    // calling Synchronize soon via FLUSH, to get it to empty its DMA
    // buffer.
    //

//    {
//        PDEVOBJ po(pSurf->hdev());
//        if (po.flGraphicsCaps2() & GCAPS2_SYNCFLUSH)
//        {
//            po.vSync(pso, NULL, DSS_FLUSH_EVENT);
//        }
//    }

    iClip = (pco != NULL) ? pco->iDComplexity : DC_TRIVIAL;

    iSolidForeColor = pboFore->iSolidColor;

    //
    // assume no opaque rectangle
    //

    iSolidBkColor = 0xFFFFFFFF;

    //
    // See if the temp buffer is big enough for the text; if not,
    // try to allocate enough memory.
    // Round up to the nearest dword multiple so that the alignment
    // will stay constant when blt to the destination surface.
    //

    if(pfo->flFontType & FO_GRAY16)
    {
        if (pSurf->iFormat() == BMF_8BPP)
        {
            if (pboOpaque->iSolidColor == -1L)
            {
                RIP("EngTextOut Error attempting anti-aliased text\n"
                    "at 8bpp with a transparent background.\n");
                return(FALSE);
            }
        }

        fDrawFlags |= ETO_GRAY;

        if (pfo->flFontType & FO_CLEARTYPE_X)
        {
        //
        // This is the case 8-bpp antialiased text
        //
        // The strategy is to create a 8-bpp buffer representing
        // the entire string.
        //
        // The buffer shall be aligned with the destination. That
        // is, 32-bit boundaries in the buffer correspond to 32
        // bit boundaries in the destination surface and the text
        // in the buffer has the same relative alignment as the
        // destination. To do this, we bump boundaries of the buffer
        // such that the left and right boundaries of the buffer
        // land on 32-bit aligned postions. This is done in the
        // following way. We note that a DWORD is 32 bits, this
        // is enough information to specify 4 (8bpp) pixels. The
        // number aligned DWORD's needed to surround the nibbles
        // defining the text is calculated by finding the nearest
        // multiple of 4 above and below the x-boundaries of the
        // text. The difference between these two numbers is a
        // count of DWORD's. Then since each DWORD is made up
        // of 4 bytes, we multiply by 4 at the end to get a count
        // of bytes.
        //
        // buffer width in bytes = 4 * (ceiling((right+1)/4) - floor(left/4))
        //

            fDrawFlags |= ETO_CLEARTYPE_X;

            ulBufferWidthInBytes  =
             ( ((pstro->rclBkGround.right + 4) >> 2)
             - ((pstro->rclBkGround.left     ) >> 2) ) << 2;

        }
        else if (pfo->flFontType & FO_CLEARTYPE_Y)
        {
            RIP("FO_CLEARTYPE_Y, not supported yet\n");
        }
        else
        {
        //
        // This is the case 4-bpp antialiased text
        //
        // The strategy is to create a 4-bpp buffer representing
        // the entire string.
        //
        // The buffer shall be aligned with the destination. That
        // is, 32-bit boundaries in the buffer correspond to 32
        // bit boundaries in the destination surface and the text
        // in the buffer has the same relative alignment as the
        // destination. To do this, we bump boundaries of the buffer
        // such that the left and right boundaries of the buffer
        // land on 32-bit aligned postions. This is done in the
        // following way. We note that a DWORD is 32 bits, this
        // is enough information to specify 8 (4bpp) pixels. The
        // number aligned DWORD's needed to surround the nibbles
        // defining the text is calculated by finding the nearest
        // multiple of 8 above and below the x-boundaries of the
        // text. The difference between these two numbers is a
        // count of DWORD's. Then since each DWORD is made up
        // of 4 bytes, we multiply by 4 at the end to get a count
        // of bytes.
        //
        // buffer width in bytes = 4 * (ceiling((right+1)/8) - floor(left/8))
        //

            ulBufferWidthInBytes  =
                ( ((pstro->rclBkGround.right + 8) >> 3)
                - ((pstro->rclBkGround.left     ) >> 3) ) << 2;

        }
    }
    else
    {
        ulBufferWidthInBytes =
            ((((pstro->rclBkGround.right + 32) & ~31) -
            (pstro->rclBkGround.left & ~31)) >> 3);
    }
    ulBufferHeight = (ULONG)(pstro->rclBkGround.bottom - pstro->rclBkGround.top);

    if ((ulBufferWidthInBytes > FIFTEEN_BITS) ||
        (ulBufferHeight > FIFTEEN_BITS))
    {
        //
        // the math will have overflowed
        //

        return(FALSE);
    }
    ulBufferBytes = ulBufferWidthInBytes * ulBufferHeight;

    if (ulBufferBytes <= TEXT_BUFFER_SIZE)
    {
        //
        // The temp buffer on the stack is big enough, so we'll use it
        //

        pjTempBuffer = szTextBuffer;
        bTempAlloc = FALSE;
    }
    else
    {
        //
        // The temp buffer isn't big enough, so we'll try to allocate
        // enough memory
        //

        #if DBG

            if (ulBufferBytes >= (PAGE_SIZE * 10000))
            {
                WARNING("EngTextOut: temp buffer >= 10000 pages");
                return(FALSE);
            }

        #endif
        
        bKernelAlloc = (ulBufferBytes < KERNEL_ALLOC_SIZE);
        if (bKernelAlloc)
        {
            pjTempBuffer = (BYTE*) PALLOCNOZ(ulBufferBytes, 'oteG');
        }
        else
        {
            pjTempBuffer = (BYTE*) EngAllocUserMem(ulBufferBytes,'oteG');
        }

        if (pjTempBuffer == NULL)
        {
            return(FALSE);
        }

        //
        // Mark that we have to free the buffer when we're done
        //

        bTempAlloc = TRUE;
    }

    //
    // One way or another, we've found a buffer that's big enough; set up
    // for accelerated text drawing
    //
    // Set fixed pitch, overlap, and top & bottom Y alignment flags
    //

    if ((!(pstro->flAccel & SO_HORIZONTAL)) || (pstro->flAccel & SO_REVERSED))
    {
        ;
    }
    else
    {
        fDrawFlags |= ((pstro->ulCharInc != 0) |


                     (
                       (
                        (pstro->flAccel & (SO_ZERO_BEARINGS |
                         SO_FLAG_DEFAULT_PLACEMENT)) !=
                        (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT)
                        ) << 1
                     ) |

                     (
                      ((pstro->flAccel & (SO_ZERO_BEARINGS |
                        SO_FLAG_DEFAULT_PLACEMENT |
                        SO_MAXEXT_EQUAL_BM_SIDE)) ==
                       (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
                        SO_MAXEXT_EQUAL_BM_SIDE)
                       ) << 2
                      )
                     );
    }

    //
    // Handle the opaque rectangle if given.
    //
    // If the background brush is a pattern brush or the foreground brush is
    // a pattern brush (foreground pattern brush is not supported), we
    // will output the whole rectangle now.
    //
    // Otherwise, we will compute the fringe opaque area outside the text
    // rectangle and include the remaining rectangle in the text output.
    // The fringe rectangles will be output last to reduce flickering when
    // a string is "moved" continuously across the screen.
    //

    FRINGERECT fr(pSurf, pco, pboOpaque);

    if (prclOpaque != (PRECTL) NULL)
    {
        //
        // If we have a device managed surface then the pattern should be
        // laid down with the device's BitBlt function
        //

        iSolidBkColor = pboOpaque->iSolidColor;
        if ((iSolidBkColor   == 0xFFFFFFFF)  ||   // Background brush is pattern.
            (iSolidForeColor == 0xFFFFFFFF))      // Foreground brush is pattern.
        {

            //
            // Output the whole rectangle.
            //

            EngTextOutBitBlt(
                    pSurf,
                    pfo,
                    fDrawFlags,
                    (SURFOBJ *)  NULL,    // Source surface.
                    (SURFOBJ *)  NULL,    // Mask surface.
                    pco,                  // Clip object.
                    NULL,                 // Palette translation object.
                    prclOpaque,           // Destination rectangle.
                    (POINTL *)  NULL,     // Source origin.
                    (POINTL *)  NULL,     // Mask origin.
                    pboOpaque,            // Realized opaque brush.
                    pptlOrg,              // brush origin
                    0x0000f0f0            // PATCOPY
            );
        }
        else
        {
            //
            // Compute the four fringe rectangles.
            //
            // According to the DDI, the opaque rectangle,
            // if given, always bounds the text to be drawn.
            //
            // (iClip == DC_RECT) added because display driver changes prclOpq 
            // after intersecting the original prclOpq, rclBkGrnd and rclClip
            // iClip == DC_RECT if there is a clipping rectangle.
            //

            ASSERTGDI((iClip != DC_TRIVIAL) || ((ERECTL *) prclOpaque)->bContain(pstro->rclBkGround),
                        "EngTextOut: opaque rectangle does not bound text background!");

            if (pstro->rclBkGround.top > prclOpaque->top) 
            {
                fr.vAddRect(prclOpaque->left, prclOpaque->top,
                            prclOpaque->right, pstro->rclBkGround.top);
            }

            if (pstro->rclBkGround.left > prclOpaque->left)
            {
                fr.vAddRect(prclOpaque->left, pstro->rclBkGround.top,
                            pstro->rclBkGround.left, pstro->rclBkGround.bottom);
            }

            if (pstro->rclBkGround.right < prclOpaque->right)
            {
                fr.vAddRect(pstro->rclBkGround.right, pstro->rclBkGround.top,
                            prclOpaque->right, pstro->rclBkGround.bottom);
            }

            if (pstro->rclBkGround.bottom < prclOpaque->bottom) 
            {
                fr.vAddRect(prclOpaque->left, pstro->rclBkGround.bottom,
                            prclOpaque->right, prclOpaque->bottom);
            }
        }
    }


    //
    // Draw the text into the temp buffer, and thence to the screen
    //

    //
    // IF (a device surface) THEN BEGIN
    //   create a DIB;
    //   IF (allocation was not successful) THEN return(FAILURE);
    //   IF (transparent text) THEN
    //     copy the surface bits to the DIB;
    // END
    //
    SURFMEM surfmem;
    DEVBITMAPINFO dbmi;
    if (fDrawFlags & ETO_DEVICE_SURFACE)
    {
        ASSERTGDI(fDrawFlags & ETO_GRAY, 
            "Device surface but not antialiased text\n");

        //  Rectangles of interest (in screen coordinates)
        //
        //  1. screen
        //
        //                  left_s   = 0
        //                  top_s    = 0
        //                  right_s  = pso->sizlBitmap.cx
        //                  bottom_s = pso->sizlBitmap.cy
        //
        //  2. text
        //
        //                  left_t   = prcl->left
        //                  top_t    = prcl->top
        //                  right_t  = prcl->right
        //                  bottom_t = prcl->bottom
        //
        //  3. buffer
        //
        //                  left_b   = left_t & ~7
        //                  top_b    = top_t
        //                  right_b  = (right_t + 7) & ~7
        //                  bottom_b = bottom_t
        //
        //  4. dib
        //
        //                  left_d   = left_b
        //                  top_d    = top_b
        //                  right_d  = right_t
        //                  bottom_d = bottom_t
        //
        //  The intersection of the screen and dib rectangles
        //  have screen coordinates
        //
        //  5. interesection of the screen and text rectangles
        //     (screen coordinates)
        //
        //      left_st   = max(left_t,   left_s  )
        //      top_st    = max(top_t,    top_s   )
        //      right_st  = min(right_t,  right_s )
        //      bottom_st = min(bottom_t, bottom_s)
        //
        //  6. intersection of the screen and text coordinates
        //     (DIB coordinates)
        //
        //      left_st'   = left_st   - left_d
        //      top_st'    = top_st    - top_d
        //      right_st'  = right_st  - left_d
        //      bottom_st' = bottom_st - top_d
        //
        // Make the DIB aligned with the buffer on the left
        // and aligned with the text on the right
        //
        // Actually, I could have been less aggressive in allocating
        // memory. There is actually no reason to allocate memory
        // that is larger than the screen. However, if I did that
        // I would have to watch for the end of the dib while I
        // processed the glyphs which would slow things down.
        //

        long left = pstro->rclBkGround.left & ~7;   // left of DIB (screen coordinates)

        if (fDrawFlags & ETO_CLEARTYPE_X)
            left = pstro->rclBkGround.left & ~3;

        long top  = pstro->rclBkGround.top;         // top  of DIB (screen coordinates)

        dbmi.iFormat  = pSurf->iFormat();
        dbmi.cxBitmap = pstro->rclBkGround.right  - left;
        dbmi.cyBitmap = pstro->rclBkGround.bottom - top;
        dbmi.hpal     = 0;
        dbmi.fl       = BMF_TOPDOWN;

        if (pSurf->bUMPD())
            dbmi.fl |= UMPD_SURFACE;

        if (!surfmem.bCreateDIB(&dbmi,0))
        {
            WARNING("EngTextOut: surfmem.bCreateDIB failed\n");
            if (bTempAlloc)
            {
                if (bKernelAlloc)
                    VFREEMEM(pjTempBuffer);
                else
                    EngFreeUserMem(pjTempBuffer);
            }
            return(FALSE);
        }
        pSurfDraw = surfmem.ps;

        //
        // Compute the source surface origin, taking into account multi-mon
        // and negative offsets:
        //

        LONG xOrigin = 0;
        LONG yOrigin = 0;

        PDEVOBJ pdoSrc(pSurf->hdev());
        ASSERTGDI(pdoSrc.bValid(),"Invalid pdoSrc I\n");

        if (pdoSrc.bPrimary(pSurf) && pdoSrc.bMetaDriver())
        {
            xOrigin = pdoSrc.pptlOrigin()->x;
            yOrigin = pdoSrc.pptlOrigin()->y;
        }

        //
        // rcScreen = screen & text intersection (screen coordinates)
        //

        rcDIB = pstro->rclBkGround;

        rcScreen.left   = max(xOrigin, pstro->rclBkGround.left);
        rcScreen.top    = max(yOrigin, pstro->rclBkGround.top );
        rcScreen.right  = min(xOrigin + pso->sizlBitmap.cx, pstro->rclBkGround.right );
        rcScreen.bottom = min(yOrigin + pso->sizlBitmap.cy, pstro->rclBkGround.bottom);

        //
        // The DDI guarantees the driver that 'pco->rclBounds' is guaranteed
        // to intersect with 'prclDst' on a DrvCopyBits call.  Later on, we
        // will use 'pco' and 'rcScreen' in a DrvCopyBits call, so check for
        // no drawing here:
        //

        if ((iClip != DC_TRIVIAL) && !bIntersect(&rcScreen, &pco->rclBounds))
        {
            if (bTempAlloc)
            {
                if (bKernelAlloc)
                    VFREEMEM(pjTempBuffer);
                else
                    EngFreeUserMem(pjTempBuffer);
            }
            return(TRUE);
        }

        //
        // rcDIB = screen & text intersection (DIB coordinates)
        //

        rcDIB = rcScreen;
        rcDIB.left   -= left;
        rcDIB.top    -= top;
        rcDIB.right  -= left;
        rcDIB.bottom -= top;

        if (iSolidBkColor == (ULONG) -1)
        {
            //
            // background is transparent copy bits from surface to DIB
            //

            if (rcScreen.left < rcScreen.right && rcScreen.top < rcScreen.bottom)
            {
                (*PPFNGET(pdoSrc,CopyBits,pSurf->flags())) (
                         surfmem.pSurfobj(),
                         pSurf->pSurfobj(),
                         0,
                         &xloIdent,
                         &rcDIB,
                         (POINTL*) &rcScreen);
            }
        }
    }

    //
    // Some drivers do banking meaning they will call EngTextOut multiple times
    // per TextOut call.  Most of the time all the GLYPH positions in the STROBJ will
    // be valid meaning it doesn't matter that you call STROBJ_vEnumStart.  But if
    // they aren't, it does matter.  This is always true in the case of linked text out
    // calls.
    //

    STROBJ_vEnumStart(pstro);

    //
    // clear buffer for opaque mode
    //
    if (iSolidBkColor != -1L)
        RtlFillMemoryUlong((ULONG*) pjTempBuffer, ulBufferBytes, 0);

    do
    {
        //
        // Get the next batch of glyphs
        //

        //
        // clear buffer, transparent mode, we need to clean the buffer in the while loop to get the font linking 
        //               with antialiazing work right 
        //
        if (iSolidBkColor == -1L)
            RtlFillMemoryUlong((ULONG*) pjTempBuffer, ulBufferBytes, 0);

        if (pstro->pgp != NULL)
        {
            //
            // There's only the one batch of glyphs, so save ourselves a call
            //

            pgp = pstro->pgp;
            cGlyph = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro,&cGlyph,&pgp);
        }

        //
        //  No glyph, no work!
        //

        if (cGlyph)
        {
            arclTmp[0].left   = LONG_MIN;
            arclTmp[0].top    = LONG_MIN;
            arclTmp[0].right  = LONG_MAX;
            arclTmp[0].bottom = LONG_MAX;
            arclTmp[1].bottom = 0;
            prclClip = &arclTmp[0];

            {
                switch (iClip)
                {
                case DC_RECT:
                    arclTmp[0] = pco->rclBounds;    // copy clip rect to arclTmp[0]
                    arclTmp[1].bottom = 0;          // make arclTmp[1] a null rect

                    //
                    // falling through !
                    //

                case DC_TRIVIAL:
                    vExpandAndCopyText(pSurf,
                                       pfo,
                                       pgp,
                                       cGlyph,
                                       (PBYTE)pjTempBuffer,
                                       ulBufferWidthInBytes,
                                       pstro->ulCharInc,
                                       pSurfDraw,
                                       pSurfDevice,
                                       &pstro->rclBkGround,
                                       prclOpaque,
                                       iSolidForeColor,
                                       iSolidBkColor,
                                       fDrawFlags,
                                       prclClip,
                                       prclExtra,
                                       Native64BitAccess,
                                       pboFore,
                                       pptlOrg);
                    break;

                case DC_COMPLEX:
                    prclClip = &txen.arcl[0];


                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do
                    {
                        bMore = CLIPOBJ_bEnum(pco,
                                (ULONG) (sizeof(txen) - sizeof(RECT)),
                                (PULONG) &txen);

                        txen.arcl[txen.c].bottom = 0;   // terminate txen.arcl[]
                                                        // with a null rect
                        vExpandAndCopyText(pSurf,
                                           pfo,
                                           pgp,
                                           cGlyph,
                                           (PBYTE)pjTempBuffer,
                                           ulBufferWidthInBytes,
                                           pstro->ulCharInc,
                                           pSurfDraw,
                                           pSurfDevice,
                                           &pstro->rclBkGround,
                                           prclOpaque,
                                           iSolidForeColor,
                                           iSolidBkColor,
                                           fDrawFlags,
                                           prclClip,
                                           prclExtra,
                                           Native64BitAccess,
                                           pboFore,
                                           pptlOrg);
                    } while (bMore);
                    break;
                }
            }
        }
    } while (bMoreGlyphs);

    if (fDrawFlags & ETO_DEVICE_SURFACE)
    {
        PDEVOBJ pdoSrc(pSurf->hdev());
        ASSERTGDI(pdoSrc.bValid(), "Invalid pdoSrc II\n");

        (*PPFNGET(pdoSrc,CopyBits,pSurf->flags())) (
                 pSurf->pSurfobj(),
                 surfmem.pSurfobj(),
                 pco,
                 0,
                 &rcScreen,
                 (POINTL*) &rcDIB);
    }

    //
    // Free up any memory we allocated for the temp buffer
    //

    if (bTempAlloc) 
    {

        if (bKernelAlloc)
            VFREEMEM(pjTempBuffer);
        else
            EngFreeUserMem(pjTempBuffer);
    }

    return(TRUE);
}



//
// lookup tables for character drawing and temp buffer expansion
//


#if !defined (_X86_)
PVOID   MastertextTypeTabel[] = {
            draw_nf_ntb_o_to_temp_start,
            draw_f_ntb_o_to_temp_start,
            draw_nf_ntb_o_to_temp_start,
            draw_f_ntb_o_to_temp_start,
            draw_nf_tb_no_to_temp_start,
            draw_f_tb_no_to_temp_start,
            draw_nf_ntb_o_to_temp_start,
            draw_f_ntb_o_to_temp_start,

            draw_gray_nf_ntb_o_to_temp_start,
            draw_gray_f_ntb_o_to_temp_start,
            draw_gray_nf_ntb_o_to_temp_start,
            draw_gray_f_ntb_o_to_temp_start,
            draw_gray_nf_ntb_o_to_temp_start,
            draw_gray_f_ntb_o_to_temp_start,
            draw_gray_nf_ntb_o_to_temp_start,
            draw_gray_f_ntb_o_to_temp_start
        };
#endif




//
// MIPS has separate code for 8bpp destination depending
// on whether the driver supports the GCAPS_64BITMEMACCESS flag.
// This is because on some MIPS systems, 64 bit memory accesses
// the video space are truncated to 32. These systems must use the
// 32 bit version of 8 bpp output.
//


// SrcCopyTextFunctionTable is an array of 32 pointers to functions
// takeing BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*
// as arguments and returning a VOID.

#if !defined (_MIPS_)

VOID (*(SrcCopyTextFunctionTable[48]))
(BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*) = {

                vSrcTranCopyError,         // 0 opaque
                vSrcOpaqCopyS1D1,          // 1
                vSrcOpaqCopyS1D4,          // 2
                vSrcOpaqCopyS1D8,          // 3
                vSrcOpaqCopyS1D16,         // 4
                vSrcOpaqCopyS1D24,         // 5
                vSrcOpaqCopyS1D32,         // 6
                vSrcTranCopyError,         // 7

                vSrcTranCopyError,         // 8 transparent
                vSrcTranCopyS1D1,          // 9
                vSrcTranCopyS1D4,          // a
                vSrcTranCopyS1D8,          // b
                vSrcTranCopyS1D16,         // c
                vSrcTranCopyS1D24,         // d
                vSrcTranCopyS1D32,         // e
                vSrcTranCopyError,         // f

                                           // gray pixels
                vSrcTranCopyError,         // 10 opaque
                vSrcTranCopyError,         // 11
                vSrcTranCopyError,         // 12
                vSrcTranCopyError,         // 13
                vSrcOpaqCopyS4D16,         // 14
                vSrcOpaqCopyS4D24,         // 15
                vSrcOpaqCopyS4D32,         // 16
                vSrcTranCopyError,         // 17

                vSrcTranCopyError,         // 18 transparent
                vSrcTranCopyError,         // 19
                vSrcTranCopyError,         // 1a
                vSrcTranCopyError,         // 1b
                vSrcTranCopyS4D16,         // 1c
                vSrcTranCopyS4D24,         // 1d
                vSrcTranCopyS4D32,         // 1e
                vSrcTranCopyError,         // 1f

                // CLEARTYPE_X

                vSrcTranCopyError,         // 20 opaque
                vSrcTranCopyError,         // 21
                vSrcTranCopyError,         // 22
                vSrcTranCopyError,         // 23
                vSrcOpaqCopyS8D16,         // 24
                vSrcOpaqCopyS8D24,         // 25
                vSrcOpaqCopyS8D32,         // 26
                vSrcTranCopyError,         // 27

                vSrcTranCopyError,         // 28 transparent
                vSrcTranCopyError,         // 29
                vSrcTranCopyError,         // 2a
                vSrcTranCopyError,         // 2b
                vSrcTranCopyS8D16,         // 24
                vSrcTranCopyS8D24,         // 25
                vSrcTranCopyS8D32,         // 26
                vSrcTranCopyError,         // 2f
            };

#else

VOID (*(SrcCopyTextFunctionTable[48]))
(BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*) = {

                vSrcOpaqCopyS1D8,          // 0 opaque
                vSrcOpaqCopyS1D1,          // 1
                vSrcOpaqCopyS1D4,          // 2
                vSrcOpaqCopyS1D8_64,       // 3
                vSrcOpaqCopyS1D16,         // 4
                vSrcOpaqCopyS1D24,         // 5
                vSrcOpaqCopyS1D32,         // 6
                vSrcTranCopyError,         // 7

                vSrcTranCopyError,         // 8 transparent
                vSrcTranCopyS1D1,          // 9
                vSrcTranCopyS1D4,          // a
                vSrcTranCopyS1D8,          // b
                vSrcTranCopyS1D16,         // c
                vSrcTranCopyS1D24,         // d
                vSrcTranCopyS1D32,         // e
                vSrcTranCopyError,         // f

                                           // gray pixels
                vSrcTranCopyError,         // 10 opaque
                vSrcTranCopyError,         // 11
                vSrcTranCopyError,         // 12
                vSrcTranCopyError,         // 13
                vSrcOpaqCopyS4D16,         // 14
                vSrcOpaqCopyS4D24,         // 15
                vSrcOpaqCopyS4D32,         // 16
                vSrcTranCopyError,         // 17

                vSrcTranCopyError,         // 18 transparent
                vSrcTranCopyError,         // 19
                vSrcTranCopyError,         // 1a
                vSrcTranCopyError,         // 1b
                vSrcTranCopyS4D16,         // 1c
                vSrcTranCopyS4D24,         // 1d
                vSrcTranCopyS4D32,         // 1e
                vSrcTranCopyError,         // 1f

                // CLEARTYPE_X

                vSrcTranCopyError,         // 20 opaque
                vSrcTranCopyError,         // 21
                vSrcTranCopyError,         // 22
                vSrcTranCopyError,         // 23
                vSrcOpaqCopyS8D16,         // 24
                vSrcOpaqCopyS8D24,         // 25
                vSrcOpaqCopyS8D32,         // 26
                vSrcTranCopyError,         // 27

                vSrcTranCopyError,         // 28 transparent
                vSrcTranCopyError,         // 29
                vSrcTranCopyError,         // 2a
                vSrcTranCopyError,         // 2b
                vSrcTranCopyS8D16,         // 2c
                vSrcTranCopyS8D24,         // 2d
                vSrcTranCopyS8D32,         // 2e
                vSrcTranCopyError,         // 2f
            };
#endif




/******************************Public*Routine******************************\
*
* Routine Name
*
*   vExpandAndCopyText
*
* Routine Description:
*
*   Break down glyph drawing into several classes, based on
*   pitch, alignment and overlap, and in this loop dispatch to
*   highly specialized glyph drawing routines based on width
*   and bit rotation.
*
* Arguments:
*
*   pGlyphPos               - Pointer to first in list of GLYPHPOS structs
*   cGlyph                  - Number of glyphs to draw
*   pjTempBuffer            - temp 1BPP [4BPP] buffer to draw into
*   ulBufferWidthInBytes    - Delta for temp buffer
*   ulCharInc               - pstro->ulCharInc, increment for fixed pitch
*   pSurf                   - surface obj, for drawing on actual surface
*   pSurfDevice             - surface object for original device
*                             (for antialiased text on devices that
*                              don't support antialiased text natively).
*   prclText                - bounding rectangle on dest surface
*   prclOpaque              - boundary of opaque rect
*   iSolidForeColor         - foreground color when drawing on dest surface
*   iSolidBkColor           - background color when drawing on dest surface
*   fDrawFlags              - special flags to allow for table lookup of routines
*   prclClip                - clipping rect
*   prclExtra               - extra rects to draw
*   Native64BitAccess       - can use 64 bit accesses
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID vExpandAndCopyText(
    SURFACE* pSurface,
    FONTOBJ* pfo,
    GLYPHPOS *pGlyphPos,
    ULONG     cGlyph,
    BYTE     *pjTempBuffer,
    ULONG     ulBufferWidthInBytes,
    ULONG     ulCharInc,
    SURFACE   *pSurf,
    SURFACE   *pSurfDevice,
    RECTL     *prclText,
    RECTL     *prclOpaque,
    INT       iSolidForeColor,
    INT       iSolidBkColor,
    ULONG     fDrawFlags,
    RECTL     *prclClip,
    RECTL     *prclExtra,
    ULONG     Native64BitAccess,
    BRUSHOBJ  *pboFore,
    POINTL    *pptlOrg
    )
{

    PFN_MASTERTEXTTYPE pfnMasterType;
    BLTINFO            SrcCopyBltInfo;
    PFN_TEXTSRCCPY     pfnTextSrcCopy;
    EXLATEOBJ          exlo;
    XLATE              *pxlo = NULL;
    RECTL              *pCurrentRect;
    ULONG              BufferAlign;
    ULONG              BufferOffset;
    ULONG              ulSrcCopyFlag;
    ULONG              ulTempTop;

#if DBG
/**/void vDumpGrayBuffer(BYTE *, ULONG, RECTL*);
#endif

	GLYPHPOS *pGPosTmp = pGlyphPos;

	//
	//	pGlyphPos->pgdf->pgb must not be NULL.
	//	But if there is printer a driver bug and GetGlyphMode() returns FO_HGLYPHS
	//	instead of FO_GLYPHBITS, then it can be NULL and crash system.
	//	To protect from this situation, vExpandAndCopyText() just return without copying
	//	in this case.
	//
	
	for(ULONG i=0; i<cGlyph; i++, pGPosTmp++){
		if(pGPosTmp->pgdf->pgb == NULL){
        	WARNING("pGlyphPos->pgdf->pgb is NULL. Possibly GetGlyphMode() bug of Printer Driver\n");
        	return;
		}
	}

    // 
    // XP bug #352368
    // Due to bad design of LTOFX and FXToL, overflow will alway happen when >0x7ffffff or <0xf8000000
    // At worst case, there can be big jump in the middle among the returned long values and will cause AV in vFastText
    // To avoid this, if the difference of pGlyphPos between the first char and last char is too big
    // We reject it.
    // 

   if( !(fDrawFlags & 1) && cGlyph > 1){
   	pGPosTmp=pGlyphPos+(cGlyph-1);	
    	if((pGlyphPos->ptl.x - pGPosTmp->ptl.x) > 0x8000000 || (pGlyphPos->ptl.x - pGPosTmp->ptl.x) < -0x8000000 ){
    		WARNING("Big jump among pGlyphPos.ptl.x. Mustbe LToFx overflow");
       	return;
    		}
   }
    	

    // UMPD NtGdiEngTextOut holding RFONT cache semaphore.
    // vExpandAndCopyText might call back into user mode.

    BOOL bSem = FALSE;
    ULONG fl = 0, numLinks = 0;
    BOOL  aFaceLink[UMPD_MAX_FONTFACELINK], *pFaceLink = aFaceLink;
    
    //
    // Release rfont semaphores, otherwise holding rfont semaphores can
    // disable APC queue while calling to the user mode.
    //

    //
    //  WINBUG #214225 tessiew 10-27-2000 Blackcomb: re-visit the RFONT.hsemCache acquiring/releasing issue
    // Need to revisit the font semaphore problem in Blackcomb
    //  It seems that a thread doesn't need to hold the font caching semaphore
    //  during the whole GreExtTextOutWLocked call.
    //

    PDEVOBJ po(pSurface->hdev());
    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));

    if (po.bValid() && po.bPrinter() && po.bUMPD() && rfo.bValid())
    {
        bSem = UMPDReleaseRFONTSem(rfo, NULL, &fl, &numLinks, &pFaceLink);
    }

    //
    // save global params
    //

    ulTempTop = prclText->top;

    //
    // DWORD Align temp buffer to DST.
    //
    // For 1Bpp addresses, left[31:05] = DWORD Address
    //                     left[04:03] = Byte in DWORD
    //                     left[02:00] = Pixel in Byte
    //
    // To optimize 1bpp drawing, both buffers must be DWORD aligned,
    // this makes the temp buffer starting point is left[04:00].
    //
    // This means that the glyph offset in the temporary buffer is xPos - left[31:05]
    //

    //
    // BufferOffset = x-position of nearest pixel to the left of the text rectangle
    //                whose address is on a 32-bit boundary in the glyph source
    //                which is either monchrome (1bpp) or gray (4bpp). This
    //                is also the position of the first pixel position on
    //                a temporary DIB buffer provided for anti-aliased text
    //                simulation.
    //
    // BufferAlign  = number of pixels the left portion of the text is
    //                offset to the right from BufferOffset
    //
    // prclText = BufferOffset + BufferAlign
    //
    //      monochrome text
    //
    //              BufferOffset = prclText->left & ~31
    //              BufferAlign  = prclText->left &  31
    //
    //      gray (4bpp) text
    //
    //              BufferOffset = prclText->left & ~7
    //              BufferAlign  = prclText->left &  7
    //
    //      clear type 8bpp text
    //
    //              BufferOffset = prclText->left & ~3
    //              BufferAlign  = prclText->left &  3
    //

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        if (fDrawFlags & ETO_GRAY)
        {
            GLYPHPOS *pgp, *pgpBad;
            DbgPrint(
                "vExpandAndCopyText(\n"
                "   GLYPHPOS *pGlyphPos            =    %-#x\n"
                "   ULONG     cGlyph               =    %u\n"
                "   BYTE     *pjTempBuffer         =    %-#x\n"
                "   ULONG     ulBufferWidthInBytes =    %u\n"
                "   ULONG     ulCharInc            =    %u\n"
                "   SURFACE   *pSurf               =    %-#x\n"
                "   SURFACE   *pSurfDevice         =    %-#x\n"
                , pGlyphPos
                , cGlyph
                , pjTempBuffer
                , ulBufferWidthInBytes
                , ulCharInc
                , pSurf
                , pSurfDevice
                );
            DbgPrint(
                "   RECTL     *prclText            =    %-#x\n"
                "   RECTL     *prclOpaque          =    %-#x\n"
                "   INT       iSolidForeColor      =    %-#x\n"
                "   INT       iSolidBkColor        =    %-#x\n"
                , prclText
                , prclOpaque
                , iSolidForeColor
                , iSolidBkColor
            );
            DbgPrint(
                "   RECTL     *prclClip            =    %-#x\n"
                "   RECTL     *prclExtra           =    %-#x\n"
                "   ULONG     Native64BitAccess    =    %-#x\n"
                , prclClip
                , prclExtra
                , Native64BitAccess
            );
            DbgPrint(
                "   ULONG     fDrawFlags           =    %-#x\n"
                , fDrawFlags
            );
            if (fDrawFlags & 1)
            {
                DbgPrint("\t\t\t\t\tETO_FIXED_PITCH\n");
            }
            if (fDrawFlags & 2)
            {
                DbgPrint(
                "\t\t\t\t\tETO_NOT_DEFAULT\n"
                );
            }
            if (fDrawFlags & ETO_GRAY)
            {
                DbgPrint("\t\t\t\t\tETO_GRAY\n");
            }
            if (fDrawFlags & ETO_DEVICE_SURFACE)
            {
                DbgPrint("\t\t\t\t\tETO_DEVICE_SURFACE\n");
            }
            DbgPrint(")\n");
            DbgPrint("---\n");
            pSurf->vDump();
            if (pSurfDevice)
                pSurfDevice->vDump();
            DbgBreakPoint();
        }
    }
#endif
    //
    // pSurfDevice is an argument given to the SrcTextCopy function
    // It must be non-zero in order to get information about the
    // device palette
    //
    if (!pSurfDevice)
    {
        pSurfDevice = pSurf;
    }

    // This is a wasted calculation for the case of a device surface
    // but what the heck, a branch costs too

    BufferAlign  = prclText->left & ((fDrawFlags & ETO_GRAY) ? ((fDrawFlags & ETO_CLEARTYPE_X) ? 3 : 7) : 31);
    BufferOffset = prclText->left - BufferAlign;


    if(!(fDrawFlags & ETO_CLEARTYPE_X))
    {

#if !defined (_X86_)

    //
    // select and jump to appropriate glyph dispatch
    // routine
    //

    pfnMasterType =
    (PFN_MASTERTEXTTYPE)MastertextTypeTabel[
        fDrawFlags & ~(ETO_DEVICE_SURFACE | ETO_CLEARTYPE_X)
    ];
    pfnMasterType(
        pGlyphPos
      , cGlyph
      , pjTempBuffer
      , BufferOffset
      , ulBufferWidthInBytes
      , ulCharInc
      , ulTempTop
      );

#else

    //
    // call x86 version for glyph copy
    //

    vFastText(
        pGlyphPos,
        cGlyph,
        pjTempBuffer + ((prclText->left >> 3) & 3),
        ulBufferWidthInBytes,
        ulCharInc,
        pSurf->pSurfobj(),
        prclText,
        prclOpaque,
        iSolidForeColor,
        iSolidBkColor,
        fDrawFlags & ~(ETO_DEVICE_SURFACE | ETO_CLEARTYPE_X),
        prclClip,
        prclExtra
    );
#endif

    }
    else // cleartype
    {
        PVOID   MastertextClearTypeTable[] = {
            draw_clrt_nf_ntb_o_to_temp_start,
            draw_clrt_f_ntb_o_to_temp_start,
        };

        pfnMasterType =
        (PFN_MASTERTEXTTYPE)MastertextClearTypeTable[fDrawFlags & 1];

        pfnMasterType(
            pGlyphPos
          , cGlyph
          , pjTempBuffer
          , BufferOffset
          , ulBufferWidthInBytes
          , ulCharInc
          , ulTempTop
          );
    }

    //
    //  draw extra rects (if any)
    //

    if (prclExtra != (PRECTL) NULL)
    {
        //
        // intersect extra rects with temp buffer, draw any
        // that intersect
        //

        VOID (*pfn)(PBYTE, ULONG, LONG, LONG, LONG, LONG);

        pfn = (fDrawFlags & ETO_GRAY) ? ((fDrawFlags & ETO_CLEARTYPE_X) ? vRectBlt8 : vRectBlt4) : vRectBlt;

        while (prclExtra->left != prclExtra->right) {

            LONG xleft, xright, ytop, ybottom;

            xleft   = max(prclExtra->left,   prclText->left)   - BufferOffset;
            xright  = min(prclExtra->right,  prclText->right)  - BufferOffset;
            ytop    = max(prclExtra->top,    prclText->top)    - prclText->top;
            ybottom = min(prclExtra->bottom, prclText->bottom) - prclText->top;

            //
            // Render the clipped 'extra' rectangle into the mono dib.
            //

            if (xleft < xright && ytop < ybottom) {
                (*pfn)(pjTempBuffer,ulBufferWidthInBytes, xleft, ytop, xright, ybottom);
            }

            prclExtra++;
        }
    }

    //
    // draw/expand 1bpp temp buffer onto target surface
    //

    ASSERTGDI(pSurf->iFormat() > 0,"Error in DIB format");
    ASSERTGDI(pSurf->iFormat() <= BMF_32BPP,"Error in DIB format");

    ULONG   iFormat = pSurf->iFormat();

#if defined (_MIPS_)

    //
    // special check for MIPS 64 bit opaque,
    // set format to 0 (use 32 bit opaque routine)
    //

    if
    (
        (iFormat == BMF_8BPP) &&
        (!Native64BitAccess)  &&
        (iSolidBkColor != 0xFFFFFFFF)
    )
    {
        iFormat = 0;
    }

#endif

    //
    // Get a pointer to the appropriate function
    //

    {
        int i = iFormat;
        ASSERTGDI(i < 8, "bad index");
        if (iSolidBkColor == -1L)
        {
            i += 8;                     // transparent background
        }

        if (ETO_GRAY & fDrawFlags)
        {
            i += 16;                    // anti-aliased text

            if (ETO_CLEARTYPE_X & fDrawFlags)
                i += 16;
        }
        pfnTextSrcCopy = SrcCopyTextFunctionTable[i];
    }

    //
    // blt each clip rectangle
    //

    for (pCurrentRect=prclClip; pCurrentRect->bottom; pCurrentRect++)
    {
        LONG Left   = max(prclText->left  , pCurrentRect->left  );
        LONG Right  = min(prclText->right , pCurrentRect->right );
        LONG Top    = max(prclText->top   , pCurrentRect->top   );
        LONG Bottom = min(prclText->bottom, pCurrentRect->bottom);
        ULONG dX    = (ULONG) (Left - prclText->left);
        ULONG dY    = (ULONG) (Top  - prclText->top );

        if (fDrawFlags & ETO_DEVICE_SURFACE)
        {
            // Left = position of first pixel relative to the left
            //        hand edge of the temporary 4bpp buffer

            Left   -= BufferOffset;
            Right  -= BufferOffset;
            Top    -= prclText->top;
            Bottom -= prclText->top;

#if DBG
            if (gflFontDebug & DEBUG_AA)
            {
                DbgPrint(
                    "*pCurrentRect = 0x%lx 0x%lx 0x%lx 0x%lx\n"
                    "*prclText     = 0x%lx 0x%lx 0x%lx 0x%lx\n"
                    " intersection = 0x%lx 0x%lx 0x%lx 0x%lx\n"
                    " BuffOffset BuffAlign = 0x%lx 0x%lx    \n"
                    " dX dY        = 0x%lx 0x%lx            \n"
                ,   pCurrentRect->left
                ,   pCurrentRect->top
                ,   pCurrentRect->right
                ,   pCurrentRect->bottom
                ,   prclText->left
                ,   prclText->top
                ,   prclText->right
                ,   prclText->bottom
                ,   Left
                ,   Top
                ,   Right
                ,   Bottom
                ,   BufferOffset, BufferAlign
                ,   dX,dY
                );
            }
#endif

        }
        else
        {
            //
            // Synchronize with the driver
            //

            PDEVOBJ poSurf(pSurf->hdev());
            poSurf.vSync(pSurf->pSurfobj(), NULL, 0);
        }

        if ((Left < Right) && (Top < Bottom))
        {
            if (iSolidForeColor == 0xffffffff)
            {
                //
                // Our (*pfnTextSrcCopy) routines can only expand solid
                // colors, so if the foreground color is a dither we fall
                // back to our slower MaskBlt support.  We set the mask
                // to the monochrome text bitmap and do a masked PatBlt
                // using the dithered brush.
                //
                // Note that we've already laid down the opaquing rectangle,
                // so this is now effectively a "transparent" textout
                // operation.
                //

                ASSERTGDI(!(fDrawFlags & ETO_GRAY),
                    "Can't do dithered anti-aliased text");

                RECTL   rclDst;
                SURFACE surfMask;
                POINTL  ptlMask;

                rclDst.left   = Left;
                rclDst.top    = Top;
                rclDst.right  = Right;
                rclDst.bottom = Bottom;

                surfMask.iFormat(BMF_1BPP);
                surfMask.iType(STYPE_BITMAP);
                surfMask.pvScan0(pjTempBuffer);
                surfMask.lDelta(ulBufferWidthInBytes);
                surfMask.sizl().cx = 8 * ulBufferWidthInBytes;
                surfMask.sizl().cy = prclText->bottom - prclText->top;

                ptlMask.x = dX + BufferAlign;
                ptlMask.y = dY;

                BltLnk(pSurf,
                       NULL,
                       &surfMask,
                       NULL,
                       NULL,
                       &rclDst,
                       NULL,
                       &ptlMask,
                       pboFore,
                       pptlOrg,
                       0xaaf0);
            }
            else
            {
                // The brush is a solid color, so use our optimized monochrome
                // solid color expansion routines.
                __try
                {
                    PBYTE pjSrc = (PBYTE)pjTempBuffer 
                        + dY * ulBufferWidthInBytes;
                    PBYTE pjDst = (PBYTE)pSurf->pvScan0() 
                        + Top * pSurf->lDelta();
                    (*pfnTextSrcCopy)(
                          pjSrc,
                          BufferAlign + dX,
                          ulBufferWidthInBytes,
                          pjDst,
                          Left,
                          Right,
                          pSurf->lDelta(),
                          Bottom - Top,
                          iSolidForeColor,
                          iSolidBkColor,
                          pSurfDevice
                    );
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING("pfnTextSrcCopy: exception raised!!!");
                }
            }
        }
    }

    // acquire the font semaphore(s)

    if (bSem)
    {
        UMPDAcquireRFONTSem(rfo, NULL, fl, numLinks, pFaceLink);
        
        if (pFaceLink && pFaceLink != aFaceLink)
        {
            VFREEMEM(pFaceLink);
        }        
    }
}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcTranCopyS1D1
*
* Routine Description:
*
*   Transparent blt of 1BPP src to all destination format
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*    pSurf      - not used
*
* Return Value:
*
*   None
*
\**************************************************************************/



#if !defined (_X86_)


VOID
vSrcTranCopyS1D1(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )

{

    //
    // DWORD version
    //
    // if uF == 1 then  Dst |= Src
    //
    // if uF == 0 then  Dst &= ~Src
    //
    //

    LONG    cx = DstRight - DstLeft;

    LONG    lStartCase = SrcLeft;
    LONG    lEndCase   = SrcLeft + cx;
    ULONG   uStartMask = (ULONG)~0;
    ULONG   uEndMask   = (ULONG)~0;
    LONG    lEndOffset;
    LONG    lSrcStride = DeltaSrcIn;
    LONG    lDstStride = DeltaDstIn;

    PBYTE   pjSrc;
    PBYTE   pjDst;
    PBYTE   pjSrcEnd;
    PBYTE   pjSrcEndY;

    lStartCase  = lStartCase & 0x1F;
    lEndCase    = lEndCase   & 0x1F;

    //
    // big endian masks
    //

    if (lStartCase) {
        uStartMask  >>= lStartCase;

        //
        // convert to little
        //                                      // 0 1 2 3

        ULONG u0 = uStartMask << 24;             // 3 - - -
        ULONG u1 = uStartMask >> 24;             // - - - 0
        ULONG u2 = (uStartMask >> 8) & 0xFF00;   // - - 1 -
        uStartMask = (uStartMask & 0xFF00) << 8;  // - 2 - -

        uStartMask |= u0 | u1 | u2;

    }

    if (lEndCase) {

        uEndMask    <<= (32 - lEndCase);

        //
        // convert to little
        //                                      // 0 1 2 3

        ULONG u0 = uEndMask << 24;               // 3 - - -
        ULONG u1 = uEndMask >> 24;               // - - - 0
        ULONG u2 = (uEndMask >> 8) & 0xFF00;     // - - 1 -
        uEndMask = (uEndMask & 0xFF00) << 8;      // - 2 - -

        uEndMask |= u0 | u1 | u2;
    }

    //
    // calc starting and ending addresses (DWORD aligned)
    //

    pjDst     = pjDstIn + ((DstLeft >> 5) << 2);
    pjSrc     = pjSrcIn + ((SrcLeft >> 5) << 2);
    pjSrcEnd  = pjSrcIn + (((SrcLeft+cx) >> 5) << 2);

    // Sundown safe truncation
    lEndOffset = (ULONG)((ULONG_PTR)pjSrcEnd - (ULONG_PTR)pjSrc);

    pjSrcEndY = pjSrc + cy * lSrcStride;

    if (uF) {

        if (pjSrc != pjSrcEnd) {

            //
            // start and stop are not in same byte
            //

            lDstStride -= lEndOffset;
            lSrcStride -= lEndOffset;

            do {

                pjSrcEnd = pjSrc + lEndOffset;

                if (lStartCase) {
                    *(PULONG)pjDst |= *(PULONG)pjSrc & uStartMask;
                    pjDst+=4;
                    pjSrc+=4;
                }

                while (pjSrc != pjSrcEnd) {

                    *(PULONG)pjDst |= *(PULONG)pjSrc;
                    pjSrc +=4;
                    pjDst +=4;

                }

                if (lEndCase) {
                    *(PULONG)pjDst |= *(PULONG)pjSrc & uEndMask;
                }

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);

        } else {

            //
            // start and stop are in same byte
            //

            uStartMask &= uEndMask;

            do {

                *(PULONG)pjDst |= *(PULONG)pjSrc & uStartMask;

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);
        }

    } else {

        //
        // uF == 0,   Dst &= ~Src
        //

        if (pjSrc != pjSrcEnd) {

            //
            // start and stop are not in same byte
            //

            lDstStride -= lEndOffset;
            lSrcStride -= lEndOffset;

            do {

                pjSrcEnd = pjSrc + lEndOffset;

                if (lStartCase) {
                    *(PULONG)pjDst &= ~(*(PULONG)pjSrc & uStartMask);
                    pjDst+=4;
                    pjSrc+=4;
                }

                while (pjSrc != pjSrcEnd) {

                    *(PULONG)pjDst &= ~(*(PULONG)pjSrc);
                    pjSrc +=4;
                    pjDst +=4;

                }

                if (lEndCase) {
                    *(PULONG)pjDst &= ~(*(PULONG)pjSrc & uEndMask);
                }

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);

        } else {

            //
            // start and stop are in same byte
            //

            uStartMask &= uEndMask;

            do {

                *(PULONG)pjDst &= ~(*(PULONG)pjSrc & uStartMask);

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);
        }
    }
}

#endif




/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcTranCopyS1D4
*
* Routine Description:
*
*   Transparent blt of 1BPP src to all destination format
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID vSrcTranCopyS1D4(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )

{
    //
    // Warning, noot optimized. It is not expected that 4 bit text
    // will be handled by the negine
    //

    LONG    cx = DstRight - DstLeft;
    BYTE    jF = (BYTE)uF;
    BYTE    jB = (BYTE)uB;
    BYTE    TextExpMask[4] = {0x00,0x0f,0xf0,0xff};

    //
    // build byte of replicate foreground
    //

    BYTE    Accum      = jF | (jF << 4);
    LONG    SrcRight   = SrcLeft + cx;
    LONG    lStartCase = SrcLeft  & 0x07;
    LONG    lEndCase   = SrcRight & 0x07;
    PBYTE   pjSrc      = pjSrcIn + ((SrcLeft + 7) >> 3);
    PBYTE   pjSrcEndY  = pjSrc + cy * DeltaSrcIn;
    PBYTE   pjSrcEnd;
    LONG    lSrcStartOffset = (8 - lStartCase);
    LONG    lSrcStride;


    PBYTE   pjDst;

    BYTE    jSrc;
    BYTE    Mask;


    if (lStartCase == 0) {
        lSrcStartOffset = 0;
    }

    cx = cx - lSrcStartOffset - (SrcRight & 0x07);

    if (cx > 0) {

        LONG    lDstStride = DeltaDstIn - (cx >> 1);
        lSrcStride = DeltaSrcIn - (cx >> 3);

        pjDst = pjDstIn + ((DstLeft + lSrcStartOffset) >> 1);

        do {

            pjSrcEnd = pjSrc + (cx >> 3);

            //
            // aligned middle
            //

            do {

                jSrc = *pjSrc;

                Mask = TextExpMask[(jSrc & 0xC0) >> 6];

                *pjDst = (*pjDst & ~Mask ) | (Accum & Mask);

                Mask = TextExpMask[(jSrc & 0x30) >> 4];

                *(pjDst+1) = (*(pjDst+1) & ~Mask ) | (Accum & Mask);

                Mask = TextExpMask[(jSrc & 0x0C) >> 2];

                *(pjDst+2) = (*(pjDst+2) & ~Mask ) | (Accum & Mask);

                Mask = TextExpMask[(jSrc & 0x03)     ];

                *(pjDst+3) = (*(pjDst+3) & ~Mask ) | (Accum & Mask);

                pjDst += 4;
                pjSrc ++;

            } while (pjSrc != pjSrcEnd);

            pjDst += lDstStride;
            pjSrc += lSrcStride;

        } while (pjSrc != pjSrcEndY);

    }


    //
    // start case
    //

    if (lStartCase) {

        //
        // check for start and stop in same src byte
        //

        BOOL  bSameByte = ((SrcLeft) & ~0x07) ==  ((SrcRight) & ~0x07);

        if (bSameByte) {

            //
            // start and stop in same src byte
            //

            PBYTE pjDstEnd2;
            PBYTE pjDstScan  = pjDstIn + ((DstLeft >> 1));
            LONG  lTextWidth = lEndCase - lStartCase;

            //
            // check for bad width
            //

            if (lTextWidth <= 0) {
                return;
            }

            pjSrc           = pjSrcIn + (SrcLeft >> 3);
            pjSrcEndY       = pjSrc + cy * DeltaSrcIn;

            do {

                pjDst   = pjDstScan;
                jSrc    = *pjSrc << lStartCase;
                LONG    ix = lTextWidth;

                //
                // partial nibble on left edge
                //

                if (lStartCase & 0x01) {

                    if (jSrc & 0x80) {
                        *pjDst = (*pjDst & 0xF0) | (Accum & 0x0F);
                    }

                    jSrc <<= 1;
                    pjDst++;
                    ix--;
                }

                //
                // bytes
                //

                while (ix >= 2) {

                    Mask     = TextExpMask[(jSrc & 0xc0) >> 6];
                    *(pjDst) = (*(pjDst) & ~Mask ) | (Accum & Mask);
                    jSrc<<=2;
                    ix -= 2;
                    pjDst++;

                }

                //
                // last nibble on right edge
                //

                if (ix & 0x01) {
                    if (jSrc & 0x80) {
                        *pjDst = (*pjDst & 0x0F) | (Accum & 0xF0);
                    }
                }

                pjSrc     += DeltaSrcIn;
                pjDstScan += DeltaDstIn;

            } while (pjSrc != pjSrcEndY);

            //
            // make sure end case doesn't run
            //

            lEndCase = 0;

        } else {

            //
            // start case
            //

            pjSrc           = pjSrcIn + (SrcLeft >> 3);
            pjDst           = pjDstIn + ((DstLeft >> 1));
            pjSrcEndY       = pjSrc + cy * DeltaSrcIn;
            LONG lDstStride = DeltaDstIn - ((9 - lStartCase) >> 1);

            do {

                jSrc    = *pjSrc << lStartCase;
                LONG ix = 8 - lStartCase;

                //
                // partial
                //

                if (ix & 0x01) {

                    if (jSrc & 0x80) {
                        *pjDst = (*pjDst & 0xF0) | (Accum & 0x0F);
                    }

                    jSrc <<= 1;
                    pjDst++;
                    ix--;
                }

                //
                // bytes
                //

                while (ix != 0) {

                    Mask     = TextExpMask[(jSrc & 0xc0) >> 6];
                    *(pjDst) = (*(pjDst) & ~Mask ) | (Accum & Mask);
                    jSrc<<=2;
                    ix-=2;
                    pjDst++;

                }

                pjSrc += DeltaSrcIn;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);
        }

    }

    //
    // end case
    //

    if (lEndCase) {

        pjSrc           = pjSrcIn + (SrcRight >> 3);
        pjDst           = pjDstIn + ((DstRight - lEndCase) >> 1);
        pjSrcEndY       = pjSrc + cy * DeltaSrcIn;
        LONG lDstStride = DeltaDstIn - ((lEndCase + 1) >> 1);

        do {

            jSrc = *pjSrc;

            LONG ix = lEndCase;

            //
            // bytes
            //

            while (ix >= 2) {

                Mask = TextExpMask[(jSrc & 0xC0) >> 6];

                *(pjDst) = (*(pjDst) & ~Mask ) | (Accum & Mask);

                jSrc <<= 2;
                ix   -=  2;
                pjDst ++;

            }

            //
            // last partial
            //

            if (ix) {

                if (jSrc & 0x80) {
                    *pjDst = (*pjDst & 0x0F) | (Accum & 0xF0);
                }

                pjDst++;

            }

            pjSrc += DeltaSrcIn;
            pjDst += lDstStride;

        } while (pjSrc != pjSrcEndY);
    }
}

#if !defined(_MIPS_)


const ULONG TranTable [] =
                         {
                           0x00000000,
                           0xff000000,
                           0x00ff0000,
                           0xffff0000,
                           0x0000ff00,
                           0xff00ff00,
                           0x00ffff00,
                           0xffffff00,
                           0x000000ff,
                           0xff0000ff,
                           0x00ff00ff,
                           0xffff00ff,
                           0x0000ffff,
                           0xff00ffff,
                           0x00ffffff,
                           0xffffffff
                         };


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcTranCopyS1D8
*
* Routine Description:
*
*   Transparent blt of 1BPP src to all destination format
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID
vSrcTranCopyS1D8(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )
{
    //
    // start at 8-byte aligned left edge
    //


    ULONG   uExpand      = uF | (uF << 8);
    ULONG   LeftAln      = (DstLeft   & ~0x07);
    ULONG   LeftEdgeMask = 0xFF >> (DstLeft & 0x07);
    ULONG   RightAln     = (DstRight  & ~0x07);
    ULONG   EndOffset    = RightAln - LeftAln;
    LONG    DeltaDst;
    LONG    DeltaSrc;
    PBYTE   pjDstEndY;
    PBYTE   pjSrc;
    PBYTE   pjDst;

    uExpand = uExpand | (uExpand << 16);

    //
    // calc addresses and strides
    //

    pjDst     = pjDstIn + LeftAln;
    pjDstEndY = pjDst + cy * DeltaDstIn;
    pjSrc     = pjSrcIn + (SrcLeft >> 3);

    DeltaSrc  = DeltaSrcIn - (EndOffset >> 3);
    DeltaDst  = DeltaDstIn - EndOffset;

    //
    // make sure at least 1 QWORD needs copied
    //

    if (RightAln != LeftAln) {

        do {

            PBYTE pjDstEnd   = pjDst + EndOffset;

            //
            // and first src byte to cover left edge
            //

            BYTE c0 = *pjSrc & (BYTE)LeftEdgeMask;

            if (c0 != 0) {

                ULONG MaskLow = TranTable[c0 >> 4];
                ULONG MaskHi  = TranTable[c0 & 0x0F];
                ULONG d0      = *(PULONG)pjDst;
                ULONG d1      = *(PULONG)(pjDst + 4);

                d0 = (d0 & ~MaskLow) | (uExpand & MaskLow);
                d1 = (d1 & ~MaskHi)  | (uExpand & MaskHi);

                *(PULONG)pjDst       = d0;
                *(PULONG)(pjDst + 4) = d1;
            }

            pjSrc ++;
            pjDst += 8;

            while (pjDst != pjDstEnd) {

                c0 = *pjSrc;

                if (c0 != 0) {

                    ULONG MaskLow = TranTable[c0 >> 4];
                    ULONG MaskHi  = TranTable[c0 & 0x0F];
                    ULONG d0      = *(PULONG)pjDst;
                    ULONG d1      = *(PULONG)(pjDst + 4);

                    d0 = (d0 & ~MaskLow) | (uExpand & MaskLow);
                    d1 = (d1 & ~MaskHi)  | (uExpand & MaskHi);

                    *(PULONG)pjDst       = d0;
                    *(PULONG)(pjDst + 4) = d1;
                }

                pjSrc ++;
                pjDst += 8;

            };

            pjDst += DeltaDst;
            pjSrc += DeltaSrc;

        } while (pjDst != pjDstEndY);
    }

    RightAln = DstRight & 0x07;

    if (RightAln) {

        BOOL  bSameQWord     = ((DstLeft) & ~0x07) ==  ((DstRight) & ~0x07);

        //
        // if left and right edges are in same qword handle with masked
        // read-modify-write
        //

        if (bSameQWord) {

            LeftAln = DstLeft & 0x07;

            LONG  xCount = RightAln - LeftAln;

            //
            // assert ic xCount < 0
            //

            if (xCount <= 0) {
                return;
            }

            LONG  lDeltaDst = DeltaDstIn - xCount;

            PBYTE pjDstEnd;

            pjDst     = pjDstIn + DstLeft;
            pjDstEndY = pjDst + cy * DeltaDstIn;
            pjSrc     = pjSrcIn + (SrcLeft >> 3);

            //
            // expand, one src byte is all that's required
            //

            BYTE  jSrc;
            do {

                //
                // load src and shift into place
                //

                jSrc = *pjSrc;
                jSrc <<= LeftAln;

                pjDstEnd  = pjDst + xCount;

                do {

                    if (jSrc & 0x80) {
                        *pjDst = (BYTE)uF;
                    }

                    jSrc <<=1;
                    pjDst++;

                } while (pjDst != pjDstEnd);

                pjDst += lDeltaDst;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            return;

        } else {

            ULONG ul0,ul1;
            BYTE  jSrc;
            LONG  lDeltaDst = DeltaDstIn - RightAln;
            PBYTE pjDstEnd;

            pjDst               = pjDstIn + (DstRight & ~0x07);
            pjDstEndY           = pjDst + cy * DeltaDstIn;
            pjSrc               = pjSrcIn + ((SrcLeft + (DstRight - DstLeft)) >> 3);

            do {

                //
                // read src
                //

                jSrc = *pjSrc;

                if (jSrc != 0) {

                    pjDstEnd = pjDst + RightAln;

                    do {
                        if (jSrc & 0x80) {
                            *pjDst = (BYTE)uF;
                        }
                        jSrc <<=1;
                        pjDst++;
                    } while (pjDst != pjDstEnd);

                } else {

                    //
                    // short cut for zero
                    //

                    pjDst += RightAln;

                }


                pjDst += lDeltaDst;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

        }
    }
}

#endif



/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcTranCopyS1D16
*
* Routine Description:
*
*   Transparent blt of 1BPP src to all destination format
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID
vSrcTranCopyS1D16(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )
{
    BYTE    jSrc;
    LONG    ixStart    = SrcLeft & 0x07;
    PUSHORT pusEnd;
    PUSHORT pusEnd8;
    PUSHORT pusDst     = (PUSHORT)pjDstIn + DstLeft;
    PBYTE   pjSrc      = pjSrcIn + (SrcLeft >> 3);
    LONG    cx         = DstRight - DstLeft;
    LONG    lDstStride = DeltaDstIn - (cx << 1);
    LONG    lSrcStride = DeltaSrcIn - ((cx + ixStart + 7) >> 3);
    PUSHORT pusEndY    = (PUSHORT)((PBYTE)pusDst + DeltaDstIn * cy);
    LONG    StartOffset = min(cx, (8 - ixStart));

    do {

        pusEnd = pusDst + cx;

        //
        // do starting pixels
        //

        if (ixStart) {

            jSrc = *pjSrc << ixStart;

            pjSrc++;

            PUSHORT pusEndSt = pusDst + StartOffset;

            do {

                if (jSrc & 0x80) {
                    *pusDst = (USHORT)uF;
                }

                pusDst++;
                jSrc <<=1;

            } while (pusDst != pusEndSt);
        }


        //
        // number of full bytes that can be expanded
        //

        pusEnd8 = (PUSHORT)((PBYTE)pusDst + (((ULONG_PTR)pusEnd - (ULONG_PTR)pusDst) & ~0x0F));

        //
        // expand full bytes
        //

        while (pusDst != pusEnd8) {

            jSrc = *pjSrc;

            if (jSrc & 0x80) {
                *(pusDst+0) = (USHORT)uF;
            }
            if (jSrc & 0x40) {
                *(pusDst+1) = (USHORT)uF;
            }
            if (jSrc & 0x20) {
                *(pusDst+2) = (USHORT)uF;
            }
            if (jSrc & 0x10) {
                *(pusDst+3) = (USHORT)uF;
            }
            if (jSrc & 0x08) {
                *(pusDst+4) = (USHORT)uF;
            }
            if (jSrc & 0x04) {
                *(pusDst+5) = (USHORT)uF;
            }
            if (jSrc & 0x02) {
                *(pusDst+6) = (USHORT)uF;
            }
            if (jSrc & 0x01) {
                *(pusDst+7) = (USHORT)uF;
            }


            pjSrc++;
            pusDst += 8;

        }

        //
        // finish off scan line if needed
        //

        if (pusDst != pusEnd) {

            jSrc = *pjSrc++;

            do {
                if (jSrc & 0x80) {
                    *pusDst = (USHORT)uF;
                }
                jSrc<<=1;
                pusDst++;
            } while (pusDst != pusEnd);

        }

        pusDst = (PUSHORT)((PBYTE)pusDst + lDstStride);
        pjSrc  += lSrcStride;

    } while(pusDst != pusEndY);

}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcTranCopyS1D24
*
* Routine Description:
*
*   Transparent blt of 1BPP src to all destination format
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
vSrcTranCopyS1D24(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )
{
    BYTE    jSrc;
    BYTE    jF0         = (BYTE)uF;
    BYTE    jF1         = (BYTE)(uF >> 8);
    BYTE    jF2         = (BYTE)(uF >> 16);
    LONG    ixStart     = SrcLeft & 0x07;
    PBYTE   pjEnd;
    PBYTE   pjEnd8;
    PBYTE   pjDst       = (PBYTE)pjDstIn + 3 * DstLeft;
    PBYTE   pjSrc       = pjSrcIn + (SrcLeft >> 3);
    LONG    cx          = DstRight - DstLeft;
    LONG    lDstStride  = DeltaDstIn -  3* cx;
    LONG    lSrcStride  = DeltaSrcIn - ((cx + ixStart + 7) >> 3);
    PBYTE   pjEndY      = (PBYTE)((PBYTE)pjDst + DeltaDstIn * cy);
    LONG    StartOffset = 3 * min(cx, (8 - ixStart));

    do {

        pjEnd = pjDst + 3 * cx;

        //
        // do starting pixels
        //

        if (ixStart) {

            jSrc = *pjSrc << ixStart;

            pjSrc++;

            PBYTE pjEndSt = pjDst + StartOffset;

            do {

                if (jSrc & 0x80) {
                    *pjDst     = jF0;
                    *(pjDst+1) = jF1;
                    *(pjDst+2) = jF2;
                }

                pjDst += 3;
                jSrc <<=1;

            } while (pjDst != pjEndSt);
        }


        //
        // number of full bytes that can be expanded
        //

        pjEnd8 = (PBYTE)((PBYTE)pjDst + ( 24 * (((ULONG_PTR)(pjEnd - pjDst))/24)));

        //
        // expand full bytes
        //

        while (pjDst != pjEnd8) {

            jSrc = *pjSrc;

            if (jSrc & 0x80) {
                *(pjDst+0) = jF0;
                *(pjDst+1) = jF1;
                *(pjDst+2) = jF2;
            }
            if (jSrc & 0x40) {
                *(pjDst+3) = jF0;
                *(pjDst+4) = jF1;
                *(pjDst+5) = jF2;
            }
            if (jSrc & 0x20) {
                *(pjDst+6) = jF0;
                *(pjDst+7) = jF1;
                *(pjDst+8) = jF2;
            }
            if (jSrc & 0x10) {
                *(pjDst+9) = jF0;
                *(pjDst+10) = jF1;
                *(pjDst+11) = jF2;
            }
            if (jSrc & 0x08) {
                *(pjDst+12) = jF0;
                *(pjDst+13) = jF1;
                *(pjDst+14) = jF2;
            }
            if (jSrc & 0x04) {
                *(pjDst+15) = jF0;
                *(pjDst+16) = jF1;
                *(pjDst+17) = jF2;
            }
            if (jSrc & 0x02) {
                *(pjDst+18) = jF0;
                *(pjDst+19) = jF1;
                *(pjDst+20) = jF2;
            }
            if (jSrc & 0x01) {
                *(pjDst+21) = jF0;
                *(pjDst+22) = jF1;
                *(pjDst+23) = jF2;
            }


            pjSrc++;
            pjDst += 3*8;

        }

        //
        // finish off scan line if needed
        //

        if (pjDst != pjEnd) {

            jSrc = *pjSrc++;

            do {
                if (jSrc & 0x80) {
                    *(pjDst+0) = jF0;
                    *(pjDst+1) = jF1;
                    *(pjDst+2) = jF2;
                }
                jSrc <<= 1;
                pjDst += 3;
            } while (pjDst != pjEnd);

        }

        pjDst = (PBYTE)((PBYTE)pjDst + lDstStride);
        pjSrc  += lSrcStride;

    } while(pjDst != pjEndY);

}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcTranCopyS1D32
*
* Routine Description:
*
*   Transparent blt of 1BPP src to all destination format
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
vSrcTranCopyS1D32(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )
{
    BYTE    jSrc;
    LONG    ixStart    = SrcLeft & 0x07;
    PULONG  pulEnd;
    PULONG  pulEnd8;
    PULONG  pulDst     = (PULONG)pjDstIn + DstLeft;
    PBYTE   pjSrc      = pjSrcIn + (SrcLeft >> 3);
    LONG    cx         = DstRight - DstLeft;
    LONG    lDstStride = DeltaDstIn - (cx << 2);
    LONG    lSrcStride = DeltaSrcIn - ((cx + ixStart + 7) >> 3);
    PULONG  pulEndY    = (PULONG)((PBYTE)pulDst + DeltaDstIn * cy);
    LONG    StartOffset = min(cx, (8 - ixStart));

    do {

        pulEnd = pulDst + cx;

        //
        // do starting pixels
        //

        if (ixStart) {

            jSrc = *pjSrc << ixStart;

            pjSrc++;

            PULONG pulEndSt = pulDst + StartOffset;

            do {

                if (jSrc & 0x80) {
                    *pulDst = uF;
                }

                pulDst++;
                jSrc <<=1;

            } while (pulDst != pulEndSt);
        }


        //
        // number of full bytes that can be expanded
        //

        pulEnd8 = (PULONG)((PBYTE)pulDst + (((ULONG_PTR)pulEnd - (ULONG_PTR)pulDst) & ~0x1F));

        //
        // expand full bytes
        //

        while (pulDst != pulEnd8) {

            jSrc = *pjSrc;

            if (jSrc & 0x80) {
                *(pulDst+0) = uF;
            }
            if (jSrc & 0x40) {
                *(pulDst+1) = uF;
            }
            if (jSrc & 0x20) {
                *(pulDst+2) = uF;
            }
            if (jSrc & 0x10) {
                *(pulDst+3) = uF;
            }
            if (jSrc & 0x08) {
                *(pulDst+4) = uF;
            }
            if (jSrc & 0x04) {
                *(pulDst+5) = uF;
            }
            if (jSrc & 0x02) {
                *(pulDst+6) = uF;
            }
            if (jSrc & 0x01) {
                *(pulDst+7) = uF;
            }


            pjSrc++;
            pulDst += 8;

        }

        //
        // finish off scan line if needed
        //

        if (pulDst != pulEnd) {

            jSrc = *pjSrc++;

            do {
                if (jSrc & 0x80) {
                    *pulDst = uF;
                }
                jSrc<<=1;
                pulDst++;
            } while (pulDst != pulEnd);

        }

        pulDst = (PULONG)((PBYTE)pulDst + lDstStride);
        pjSrc  += lSrcStride;

    } while(pulDst != pulEndY);

}




/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcOpaqCopyS1D1
*
* Routine Description:
*
*   Opaque blt of 1BPP src to destination format
*
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/



#if !defined (_X86_)

VOID
vSrcOpaqCopyS1D1(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )

{

    //
    // DWORD version
    //
    //
    //  build and and xor mask
    //
    //  and mask is set to 0x00 if uF == uB, so that
    //  this routine acts like a solid fill. (although src is not needed!)
    //
    //  The xor mask is set to 0xFF if inversion is needed:
    //      either uF == uB == 1, for solid fill 1s or
    //      uF = 0, uB = 1 for inverted text
    //

    uF      &= 1;
    uB      &= 1;

    LONG    cx = DstRight - DstLeft;

    LONG    lStartCase = SrcLeft;
    LONG    lEndCase   = SrcLeft + cx;
    ULONG   uStartMask = (ULONG)~0;
    ULONG   uEndMask   = (ULONG)~0;
    LONG    lEndOffset;
    LONG    lSrcStride = DeltaSrcIn;
    LONG    lDstStride = DeltaDstIn;

    PBYTE   pjSrc;
    PBYTE   pjDst;
    PBYTE   pjSrcEnd;
    PBYTE   pjSrcEndY;

    lStartCase  = lStartCase & 0x1F;
    lEndCase    = lEndCase   & 0x1F;

    //
    // big endian masks
    //

    if (lStartCase) {
        uStartMask  >>= lStartCase;

        //
        // convert to little
        //                                       // 0 1 2 3

        ULONG u0 = uStartMask << 24;             // 3 - - -
        ULONG u1 = uStartMask >> 24;             // - - - 0
        ULONG u2 = (uStartMask >> 8) & 0xFF00;   // - - 1 -
        uStartMask = (uStartMask & 0xFF00) << 8; // - 2 - -

        uStartMask |= u0 | u1 | u2;

    }

    if (lEndCase) {

        uEndMask    <<= (32 - lEndCase);

        //
        // convert to little
        //                                       // 0 1 2 3

        ULONG u0 = uEndMask << 24;               // 3 - - -
        ULONG u1 = uEndMask >> 24;               // - - - 0
        ULONG u2 = (uEndMask >> 8) & 0xFF00;     // - - 1 -
        uEndMask = (uEndMask & 0xFF00) << 8;     // - 2 - -

        uEndMask |= u0 | u1 | u2;
    }

    //
    // calc starting and ending full dword addresses (DWORD aligned)
    //

    pjDst     = pjDstIn + (((DstLeft) >> 3) & ~0x03);
    pjSrc     = pjSrcIn + (((SrcLeft) >> 3) & ~0x03);
    pjSrcEnd  = pjSrcIn + (((SrcLeft+cx) >> 3) & ~0x03);

    //Sundown safe truncation
    lEndOffset = (ULONG)((ULONG_PTR)pjSrcEnd - (ULONG_PTR)pjSrc);

    pjSrcEndY = pjSrc + cy * lSrcStride;

    //
    // special case uF = 1 and uB = 0
    //

    if (uF && !uB) {

        //
        // special case direct copy
        //

        if (pjSrc != pjSrcEnd) {

            //
            // start and stop are not in same byte
            //

            lDstStride -= lEndOffset;
            lSrcStride -= lEndOffset;

            do {

                pjSrcEnd = pjSrc + lEndOffset;

                if (lStartCase) {
                    *(PULONG)pjDst = (*(PULONG)pjDst & ~uStartMask) | (*(PULONG)pjSrc & uStartMask);
                    pjDst+=4;
                    pjSrc+=4;
                }

                while (pjSrc != pjSrcEnd) {

                    *(PULONG)pjDst = *(PULONG)pjSrc;
                    pjSrc +=4;
                    pjDst +=4;

                }

                if (lEndCase) {
                    *(PULONG)pjDst = (*(PULONG)pjDst & ~uEndMask) | (*(PULONG)pjSrc & uEndMask);
                }

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);

        } else {

            //
            // start and stop are in same byte
            //

            uStartMask &= uEndMask;

            do {

                *(PULONG)pjDst = (*(PULONG)pjDst & ~uStartMask) | (*(PULONG)pjSrc & uStartMask);

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);
        }

    //
    //  special case uF = 0 and uB = 1  (invert)
    //

    } else if (!uF && uB) {

        //
        // dst = ~Src
        //

        if (pjSrc != pjSrcEnd) {

            //
            // start and stop are not in same byte
            //

            lDstStride -= lEndOffset;
            lSrcStride -= lEndOffset;

            do {

                pjSrcEnd = pjSrc + lEndOffset;

                if (lStartCase) {
                    *(PULONG)pjDst = (*(PULONG)pjDst & ~uStartMask) | (~(*(PULONG)pjSrc) & uStartMask);
                    pjDst+=4;
                    pjSrc+=4;
                }

                while (pjSrc != pjSrcEnd) {

                    *(PULONG)pjDst = ~(*(PULONG)pjSrc);
                    pjSrc +=4;
                    pjDst +=4;

                }

                if (lEndCase) {
                    *(PULONG)pjDst = (*(PULONG)pjDst & ~uEndMask) | (~(*(PULONG)pjSrc) & uEndMask);
                }

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);

        } else {

            //
            // start and stop are in same byte
            //

            uStartMask &= uEndMask;

            do {

                *(PULONG)pjDst = (*(PULONG)pjDst & ~uStartMask) | (~(*(PULONG)pjSrc) & uStartMask);

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);
        }


    } else {

        ULONG   AndMask = (uF == uB) ? 0x00 : 0xFF;
                AndMask |= AndMask << 8;
                AndMask |= AndMask << 16;

        ULONG   XorMask = (uB == 1)  ? 0xFF : 0x00;
                XorMask |= XorMask << 8;
                XorMask |= XorMask << 16;



        if (pjSrc != pjSrcEnd) {

            //
            // start and stop are not in same byte
            //

            lDstStride -= lEndOffset;
            lSrcStride -= lEndOffset;

            do {

                pjSrcEnd = pjSrc + lEndOffset;

                if (lStartCase) {
                    *(PULONG)pjDst = (*(PULONG)pjDst & ~uStartMask) | (((*(PULONG)pjSrc & AndMask) ^ XorMask) & uStartMask);
                    pjDst+=4;
                    pjSrc+=4;
                }

                while (pjSrc != pjSrcEnd) {

                    *(PULONG)pjDst = *(PULONG)pjSrc & AndMask ^ XorMask;
                    pjSrc +=4;
                    pjDst +=4;

                }

                if (lEndCase) {
                    *(PULONG)pjDst = (*(PULONG)pjDst & ~uEndMask) | (((*(PULONG)pjSrc & AndMask) ^ XorMask) & uEndMask);
                }

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);

        } else {

            //
            // start and stop are in same byte
            //

            uStartMask &= uEndMask;

            do {

                *(PULONG)pjDst = (*(PULONG)pjDst & ~uStartMask) | (((*(PULONG)pjSrc & AndMask) ^ XorMask) & uStartMask);

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);
        }

    }
}

#endif



/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcOpaqCopyS1D4
*
* Routine Description:
*
*   Opaque blt of 1BPP src to destination format
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID vSrcOpaqCopyS1D4(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )
{

    //
    // Warning, this 4bit code is not optimized, it is not expected that
    // we will draw many 4bpp engine bitmaps.
    //

    //
    // check for quick out?
    //

    BYTE    jF = (BYTE)uF;
    BYTE    jB = (BYTE)uB;
    BYTE    TextExpTable[4];
    LONG    cx = DstRight - DstLeft;

    //
    // build small table
    //

    BYTE    Accum = jB | (jB << 4);

    TextExpTable[0] = Accum;                // 0 0
    Accum <<= 4;
    Accum |= jF;
    TextExpTable[1] = Accum;                // 0 1
    Accum <<= 4;
    Accum |= jF;
    TextExpTable[3] = Accum;                // 1 1
    Accum <<= 4;
    Accum |= jB;
    TextExpTable[2] = Accum;                // 1 0

    LONG    lStartCase    = SrcLeft & 0x07;
    LONG    SrcRight      = SrcLeft+cx;
    LONG    lEndCase      = SrcRight & 0x07;
    PBYTE   pjSrc         = pjSrcIn + ((SrcLeft + 7) >> 3);
    PBYTE   pjSrcEndY     = pjSrc + cy * DeltaSrcIn;
    PBYTE   pjSrcEnd;
    LONG    lSrcStartOffset = (8 - lStartCase);
    LONG    lSrcStride;
    PBYTE   pjDst;
    BYTE    jSrc;

    if (lStartCase == 0) {
        lSrcStartOffset = 0;
    }

    cx = cx - lSrcStartOffset - lEndCase;

    if (cx > 0) {

        LONG lDstStride = DeltaDstIn - (cx >> 1);
        lSrcStride = DeltaSrcIn - (cx >> 3);

        pjDst = pjDstIn + ((DstLeft + lSrcStartOffset) >> 1);

        do {

            pjSrcEnd = pjSrc + (cx >> 3);

            //
            // aligned middle
            //

            do {

                jSrc = *pjSrc;

                *pjDst     = TextExpTable[(jSrc & 0xC0) >> 6];
                *(pjDst+1) = TextExpTable[(jSrc & 0x30) >> 4];
                *(pjDst+2) = TextExpTable[(jSrc & 0x0C) >> 2];
                *(pjDst+3) = TextExpTable[ jSrc & 0x03 ];

                pjDst += 4;
                pjSrc ++;

            } while (pjSrc != pjSrcEnd);

            pjDst += lDstStride;
            pjSrc += lSrcStride;

        } while (pjSrc != pjSrcEndY);

    }

    //
    // start case
    //

    if (lStartCase) {

        //
        // are start and stop in same src byte
        //

        BOOL  bSameByte = ((SrcLeft) & ~0x07) ==  ((SrcRight) & ~0x07);

        if (bSameByte) {

            //
            // start and stop in same byte
            //

            PBYTE pjDstScan = pjDstIn + ((DstLeft >> 1));
            PBYTE pjDstEnd2;
            LONG  lTextWidth = lEndCase - lStartCase;

            //
            // check for bad width
            //

            if (lTextWidth <= 0) {
                return;
            }

            pjSrc           = pjSrcIn + (SrcLeft >> 3);
            pjSrcEndY       = pjSrc + cy * DeltaSrcIn;

            do {

                pjDst   = pjDstScan;
                jSrc    = *pjSrc << (lStartCase & ~0x01);
                LONG ix = lTextWidth;

                //
                // starting odd nibble
                //

                if (lStartCase & 0x01) {
                    *pjDst     = (*pjDst & 0xF0) | (TextExpTable[(jSrc & 0xc0) >> 6] & 0x0F);
                    jSrc <<= 2;
                    pjDst++;
                    ix--;
                }

                //
                // full byte nibble pairs
                //

                while (ix >= 2) {
                    *(pjDst) = TextExpTable[(jSrc & 0xC0) >> 6];
                    jSrc<<=2;
                    pjDst++;
                    ix -= 2;
                }

                //
                // last nibble
                //

                if (ix) {
                    *(pjDst) = (*(pjDst) & 0x0F) | (TextExpTable[(jSrc & 0xc0) >> 6] & 0xF0);
                }

                pjSrc     += DeltaSrcIn;
                pjDstScan += DeltaDstIn;

            } while (pjSrc != pjSrcEndY);

            //
            // make sure end case doesn't run
            //

            lEndCase = 0;

        } else {

            pjSrc           = pjSrcIn + (SrcLeft >> 3);
            pjDst           = pjDstIn + ((DstLeft >> 1));
            pjSrcEndY       = pjSrc + cy * DeltaSrcIn;
            LONG lDstStride = DeltaDstIn - ((9 - lStartCase) >> 1); // ((8 - lStartCase) + 1) / 2

            do {

                jSrc    = *pjSrc << (lStartCase & ~0x01);
                LONG ix = 8 - lStartCase;

                //
                // partial
                //

                if (ix & 0x01) {

                    *pjDst     = (*pjDst & 0xF0) | (TextExpTable[(jSrc & 0xc0) >> 6] & 0x0F);

                    jSrc <<= 2;
                    pjDst++;
                    ix--;
                }

                //
                // bytes
                //

                while (ix != 0) {

                    *(pjDst) = TextExpTable[(jSrc & 0xC0) >> 6];
                    jSrc<<=2;
                    ix-=2;
                    pjDst++;
                }

                pjSrc += DeltaSrcIn;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);
        }
    }

    //
    // end case
    //

    if (lEndCase) {

        pjSrc           = pjSrcIn + (SrcRight >> 3);
        pjDst           = pjDstIn + ((DstRight - lEndCase) >> 1);
        pjSrcEndY       = pjSrc + cy * DeltaSrcIn;
        LONG lDstStride = DeltaDstIn - ((lEndCase + 1) >> 1);

        do {

            jSrc = *pjSrc;

            LONG ix = lEndCase;

            //
            // bytes
            //

            while (ix >= 2) {

                *(pjDst) = TextExpTable[(jSrc & 0xC0) >> 6];

                jSrc <<= 2;
                ix   -=  2;
                pjDst ++;

            }

            //
            // last partial
            //

            if (ix) {


                *(pjDst) = (*(pjDst) & 0x0F) | (TextExpTable[(jSrc & 0xc0) >> 6] & 0xF0);
                pjDst++;

            }

            pjSrc += DeltaSrcIn;
            pjDst += lDstStride;

        } while (pjSrc != pjSrcEndY);
    }
}

//
// edge mask for 8 bit expansion
//

extern "C" {

ULONG gTextLeftMask[8][2] = {
		     {0xffffffff,0xffffffff},
                     {0xffffff00,0xffffffff},
                     {0xffff0000,0xffffffff},
                     {0xff000000,0xffffffff},
                     {0x00000000,0xffffffff},
                     {0x00000000,0xffffff00},
                     {0x00000000,0xffff0000},
                     {0x00000000,0xff000000}
                 };
ULONG gTextRightMask[8][2] = {
		     {0xffffffff,0xffffffff},
                     {0x000000ff,0x00000000},
                     {0x0000ffff,0x00000000},
                     {0x00ffffff,0x00000000},
                     {0xffffffff,0x00000000},
                     {0xffffffff,0x000000ff},
                     {0xffffffff,0x0000ffff},
                     {0xffffffff,0x00ffffff}
                 };
}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcOpaqCopyS1D8
*
* Routine Description:
*
*   Opaque blt of 1BPP src to destination format
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
vSrcOpaqCopyS1D8(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )
{
    //
    // Aligned portion
    //

    ULONG   LeftAln    = ((DstLeft + 7) & ~0x07);
    ULONG   RightAln   = ((DstRight)    & ~0x07);
    ULONG   EndOffset  = RightAln - LeftAln;
    ULONG   EndOffset4 = EndOffset & ~0x0F;
    ULONG   EndOffset8 = EndOffset & ~0x1F;
    LONG    DeltaDst;
    LONG    DeltaSrc;
    PBYTE   pjDstEndY;
    PBYTE   pjSrc;
    PBYTE   pjDst;
    ULONG   TextExpTable[16];

    //
    // Generate text expasion table
    //

    ULONG  Accum = uB;

    Accum = Accum | (Accum << 8);
    Accum = Accum | (Accum << 16);
    TextExpTable[0] = Accum;            // 0 0 0 0
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[8] = Accum;            // 0 0 0 1
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[4] = Accum;            // 0 0 1 0
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[10] = Accum;            // 0 1 0 1
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[5] = Accum;           // 1 0 1 0
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[ 2] = Accum;           // 0 1 0 0
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[ 9] = Accum;           // 1 0 0 1
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[12] = Accum;           // 0 0 1 1
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[14] = Accum;           // 0 1 1 1
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[15] = Accum;           // 1 1 1 1
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[ 7] = Accum;           // 1 1 1 0
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[11] = Accum;           // 1 1 0 1
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[13] = Accum;           // 1 0 1 1
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[06] = Accum;           // 0 1 1 0
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[ 3] = Accum;           // 1 1 0 0
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[ 1] = Accum;           // 1 0 0 0

    //
    // calc addresses and strides
    //

    pjDst     = pjDstIn + LeftAln;
    pjDstEndY = pjDst + cy * DeltaDstIn;
    pjSrc     = pjSrcIn + ((SrcLeft+7) >> 3);

    DeltaSrc  = DeltaSrcIn - (EndOffset >> 3);
    DeltaDst  = DeltaDstIn - EndOffset;

    //
    // make sure at least 1 QWORD needs copied
    //

    if (RightAln > LeftAln) {

        //
        // expand buffer
        //

        do {

            PBYTE pjDstEnd  = pjDst + EndOffset;
            PBYTE pjDstEnd4 = pjDst + EndOffset4;
            PBYTE pjDstEnd8 = pjDst + EndOffset8;

            //
            // 4 times unrolled
            //

            while (pjDst != pjDstEnd8) {
                BYTE c0 = *(pjSrc + 0);
                BYTE c1 = *(pjSrc + 1);
                BYTE c2 = *(pjSrc + 2);
                BYTE c3 = *(pjSrc + 3);

                *(PULONG)(pjDst + 0) = TextExpTable[c0  >>  4];
                *(PULONG)(pjDst + 4) = TextExpTable[c0 & 0x0F];

                *(PULONG)(pjDst + 8) = TextExpTable[c1  >>  4];
                *(PULONG)(pjDst +12) = TextExpTable[c1 & 0x0F];

                *(PULONG)(pjDst +16) = TextExpTable[c2  >>  4];
                *(PULONG)(pjDst +20) = TextExpTable[c2 & 0x0F];

                *(PULONG)(pjDst +24) = TextExpTable[c3  >>  4];
                *(PULONG)(pjDst +28) = TextExpTable[c3 & 0x0F];

                pjSrc += 4;
                pjDst += 32;
            }

            //
            // 2 times unrolled
            //

            while (pjDst != pjDstEnd4) {
                BYTE c0 = *(pjSrc + 0);
                BYTE c1 = *(pjSrc + 1);

                *(PULONG)(pjDst + 0) = TextExpTable[c0  >>  4];
                *(PULONG)(pjDst + 4) = TextExpTable[c0 & 0x0F];

                *(PULONG)(pjDst + 8) = TextExpTable[c1  >>  4];
                *(PULONG)(pjDst +12) = TextExpTable[c1 & 0x0F];

                pjSrc += 2;
                pjDst += 16;
            }

            //
            // 1 byte expansion loop
            //

            while (pjDst != pjDstEnd) {
                BYTE c0 = *(pjSrc + 0);

                *(PULONG)(pjDst + 0) = TextExpTable[c0  >>  4];
                *(PULONG)(pjDst + 4) = TextExpTable[c0 & 0x0F];

                pjSrc++;
                pjDst += 8;
            }

            pjDst += DeltaDst;
            pjSrc += DeltaSrc;


        } while (pjDst != pjDstEndY);
    }

    //
    // Starting alignment case: at most 1 src byte is required.
    // Start and end may occur in same Quadword.
    //
    //
    // Left                  Right
    //    0 1 2 34 5 6 7       0 1 2 34 5 6 7
    //        
    // 1  xxxxxxx   1 x       
    //        
    // 2   xxxxxx   2 xx      
    //        
    // 3    xxxxx   3 xxx     
    //        
    // 4     xxxx   4 xxxx    
    //        
    // 5      xxx   5 xxxxx   
    //        
    // 6       xx   6 xxxxxx  
    //        
    // 7        x   7 xxxxxxx 
    //        
    //

    LeftAln  = DstLeft & 0x07;
    RightAln = DstRight & 0x07;

    if (LeftAln) {

        BYTE  jSrc;
        BOOL  bSameDWord     = ((DstLeft) & ~0x03) ==  ((DstRight-1) & ~0x03);
        BOOL  bSameQWord     = ((DstLeft) & ~0x07) ==  ((DstRight-1) & ~0x07);
        ULONG ul0,ul1;

	ASSERTGDI (DstLeft < DstRight, "vSrcOpaqCopyS1D8: null rectangle passed in.");

        // if left and right edges are in the same dword or the same qword,
        // handle with masked read-modify-write

        if (bSameDWord) {

            ULONG Mask0;

	    Mask0     = gTextLeftMask[LeftAln & 3][0] &
			gTextRightMask[RightAln & 3][0];

            pjDst     = pjDstIn + (DstLeft & ~0x03);
	    pjDstEndY = pjDst + cy * DeltaDstIn;

            // (SrcLeft >> 3) is the number of bytes to offset by
	    // (1 BPP in the src buffer).

            pjSrc     = pjSrcIn + (SrcLeft >> 3);

            // expand

            do {

                jSrc = *pjSrc;

		if (LeftAln < 4)
		    ul0 = TextExpTable[jSrc  >>	4];
		else
		    ul0 = TextExpTable[jSrc  & 0xf];

		*(PULONG)pjDst = (*(PULONG)pjDst & ~Mask0) | (ul0 & Mask0);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            return;

        } else if (bSameQWord) {

            ULONG Mask0,Mask1;

            Mask0     = gTextLeftMask[LeftAln][0] & gTextRightMask[RightAln][0];
            Mask1     = gTextLeftMask[LeftAln][1] & gTextRightMask[RightAln][1];

            pjDst     = pjDstIn + (DstLeft & ~0x07);
            pjDstEndY = pjDst + cy * DeltaDstIn;
            // (SrcLeft >> 3) is the number of bytes to offset by
            // (1 BPP in the src buffer).
            pjSrc     = pjSrcIn + (SrcLeft >> 3);

            //
            // expand
            //

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *(PULONG)(pjDst)   = (*(PULONG)(pjDst)   & ~Mask0) | (ul0 & Mask0);
                *(PULONG)(pjDst+4) = (*(PULONG)(pjDst+4) & ~Mask1) | (ul1 & Mask1);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            return;
        }

        //
        // Left edge only, handle with special write-only loops
        //

        pjDst     = pjDstIn + (DstLeft & ~0x07);
        pjDstEndY = pjDst + cy * DeltaDstIn;
        pjSrc     = pjSrcIn + (SrcLeft >> 3);

        switch (LeftAln) {

        case 1:

            do {

                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *(pjDst+1)            = (BYTE)(ul0 >> 8);
                *((PUSHORT)(pjDst+2)) = (USHORT)(ul0 >> 16);
                *((PULONG)(pjDst+4))  = ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            break;

        case 2:

            do {

                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *((PUSHORT)(pjDst+2)) = (USHORT)(ul0 >> 16);
                *((PULONG)(pjDst+4))  = ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            break;

        case 3:

            do {

                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *(pjDst+3)            = (BYTE)(ul0 >> 24);
                *((PULONG)(pjDst+4))  = ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            break;

        case 4:

            do {

                jSrc = *pjSrc;
                ul1 = TextExpTable[jSrc & 0x0F];

                *((PULONG)(pjDst+4))  = ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            break;

        case 5:

            do {

                jSrc = *pjSrc;
                ul1 = TextExpTable[jSrc & 0x0F];

                *(pjDst+5)            = (BYTE)(ul1 >> 8);
                *((PUSHORT)(pjDst+6)) = (USHORT)(ul1 >> 16);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            break;

        case 6:

            do {

                jSrc = *pjSrc;
                ul1 = TextExpTable[jSrc & 0x0F];

                *((PUSHORT)(pjDst+6)) = (USHORT)(ul1 >> 16);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            break;

        case 7:

            do {

                jSrc = *pjSrc;
                ul1 = TextExpTable[jSrc & 0x0F];

                *(pjDst+7) = (BYTE)(ul1 >> 24);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            break;
        }
    }

    //
    // handle right edge only, use special write-only loops for each case
    //

    if (RightAln) {

        ULONG ul0,ul1;
        BYTE  jSrc;

        pjDst               = pjDstIn + (DstRight & ~0x07);
        pjDstEndY           = pjDst + cy * DeltaDstIn;
        pjSrc               = pjSrcIn + ((SrcLeft + (DstRight - DstLeft)) >> 3);

        //
        // select right case
        //

        switch (RightAln) {
        case 1:

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];

                *(pjDst) = (BYTE)ul0;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;

        case 2:

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];

                *(PUSHORT)(pjDst) = (USHORT)ul0;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;

        case 3:

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];

                *(PUSHORT)(pjDst) = (USHORT)ul0;
                *(pjDst+2)        = (BYTE)(ul0 >> 16);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;

        case 4:

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];

                *(PULONG)(pjDst) = ul0;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;

        case 5:

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *(PULONG)(pjDst) = ul0;
                *(pjDst+4)       = (BYTE)ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;

        case 6:

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *(PULONG)(pjDst)    = ul0;
                *(PUSHORT)(pjDst+4) = (USHORT)ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;

        case 7:

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *(PULONG)(pjDst)    = ul0;
                *(PUSHORT)(pjDst+4) = (USHORT)ul1;
                *(pjDst+6)          = (BYTE)(ul1 >> 16);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;
        }
    }
}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcOpaqCopyS1D16
*
* Routine Description:
*
*   Opaque blt of 1BPP src to destination format
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
vSrcOpaqCopyS1D16(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )

{
    BYTE    jSrc;
    LONG    ixStart     = SrcLeft & 0x07;
    PUSHORT pusEnd;
    PUSHORT pusEnd8;
    PUSHORT pusDst      = (PUSHORT)pjDstIn + DstLeft;
    PBYTE   pjSrc       = pjSrcIn + (SrcLeft >> 3);
    LONG    cx          = DstRight - DstLeft;
    LONG    lDstStride  = DeltaDstIn - (cx << 1);
    LONG    lSrcStride  = DeltaSrcIn - ((cx + ixStart + 7) >> 3);
    UCHAR   ExpTable[4];
    PUSHORT pusEndY     = (PUSHORT)((PBYTE)pusDst + DeltaDstIn * cy);
    LONG    StartOffset = min(cx, (8 - ixStart));

    //
    // build exp table
    //

    *(PUSHORT)ExpTable     = (USHORT)uB;
    *(PUSHORT)(ExpTable+2) = (USHORT)uF;

    do {

        pusEnd = pusDst + cx;

        //
        // do starting pixels
        //

        if (ixStart) {

            jSrc = *pjSrc << ixStart;

            pjSrc++;

            PUSHORT pusEndSt = pusDst + StartOffset;

            do {
                *pusDst = *(PUSHORT)(ExpTable + ((jSrc & 0x80) >> (7-1)));
                pusDst++;
                jSrc <<=1;

            } while (pusDst != pusEndSt);
        }


        //
        // number of full bytes that can be expanded
        //

        pusEnd8 = (PUSHORT)((PBYTE)pusDst + (((ULONG_PTR)pusEnd - (ULONG_PTR)pusDst) & ~0x0F));

        //
        // expand full bytes
        //

        while (pusDst != pusEnd8) {

            jSrc = *pjSrc;

            *(pusDst + 0) = *(PUSHORT)(ExpTable + ((jSrc & 0x80) >> (7-1)));
            *(pusDst + 1) = *(PUSHORT)(ExpTable + ((jSrc & 0x40) >> (6-1)));
            *(pusDst + 2) = *(PUSHORT)(ExpTable + ((jSrc & 0x20) >> (5-1)));
            *(pusDst + 3) = *(PUSHORT)(ExpTable + ((jSrc & 0x10) >> (4-1)));
            *(pusDst + 4) = *(PUSHORT)(ExpTable + ((jSrc & 0x08) >> (3-1)));
            *(pusDst + 5) = *(PUSHORT)(ExpTable + ((jSrc & 0x04) >> (2-1)));
            *(pusDst + 6) = *(PUSHORT)(ExpTable + ((jSrc & 0x02) >> (1-1)));
            *(pusDst + 7) = *(PUSHORT)(ExpTable + ((jSrc & 0x01) << 1));

            pjSrc++;
            pusDst += 8;

        }

        //
        // finish off scan line if needed
        //

        if (pusDst != pusEnd) {

            jSrc = *pjSrc++;

            do {
                *pusDst = *(PUSHORT)(ExpTable + ((jSrc & 0x80) >> (7-1)));
                jSrc<<=1;
                pusDst++;
            } while (pusDst != pusEnd);

        }

        pusDst = (PUSHORT)((PBYTE)pusDst + lDstStride);
        pjSrc  += lSrcStride;

    } while(pusDst != pusEndY);

}



/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcOpaqCopyS1D24
*
* Routine Description:
*
*   Opaque blt of 1BPP src to destination format
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
vSrcOpaqCopyS1D24(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )

{
    BYTE    jSrc;
    BYTE    F0,F1,F2;
    BYTE    B0,B1,B2;
    LONG    ixStart     = SrcLeft & 0x07;
    PBYTE   pjEnd;
    PBYTE   pjEnd8;
    PBYTE   pjDst       = pjDstIn + 3 * DstLeft;
    PBYTE   pjSrc       = pjSrcIn + (SrcLeft >> 3);
    LONG    cx          = DstRight - DstLeft;
    LONG    lDstStride  = DeltaDstIn - (cx * 3);
    LONG    lSrcStride  = DeltaSrcIn - ((cx + ixStart + 7) >> 3);
    UCHAR   ExpTable[8];
    PBYTE   pjEndY      = pjDst + DeltaDstIn * cy;
    LONG    StartOffset = 3 * (min(cx, (8 - ixStart)));
    PBYTE   pTable;

    //
    // build exp table
    //

    *(PULONG)ExpTable     = uB;
    *(PULONG)(ExpTable+4) = uF;

    do {

        pjEnd = pjDst + 3 * cx;

        //
        // do starting pixels
        //

        if (ixStart) {

            jSrc = *pjSrc << ixStart;

            pjSrc++;

            PBYTE pjEndSt = pjDst + StartOffset;

            do {

                pTable = ExpTable + ((jSrc & 0x80) >> (7-2));

                *pjDst   = *pTable;
                *(pjDst+1) = *(pTable+1);
                *(pjDst+2) = *(pTable+2);

                pjDst += 3;

                jSrc <<=1;

            } while (pjDst != pjEndSt);
        }


        //
        // number of full bytes that can be expanded
        //

        pjEnd8 = pjDst + (24 * (((ULONG_PTR)pjEnd - (ULONG_PTR)pjDst)/24));

        //
        // expand full bytes
        //

        while (pjDst != pjEnd8) {

            jSrc = *pjSrc;

            pTable = ExpTable + ((jSrc & 0x80) >> (7-2));

            *(pjDst + 0) = *pTable;
            *(pjDst + 1) = *(pTable+1);
            *(pjDst + 2) = *(pTable+2);

            pTable = ExpTable + ((jSrc & 0x40) >> (6-2));

            *(pjDst + 3) = *pTable;
            *(pjDst + 4) = *(pTable+1);
            *(pjDst + 5) = *(pTable+2);

            pTable = ExpTable + ((jSrc & 0x20) >> (5-2));

            *(pjDst + 6) = *pTable;
            *(pjDst + 7) = *(pTable+1);
            *(pjDst + 8) = *(pTable+2);

            pTable = ExpTable + ((jSrc & 0x10) >> (4-2));

            *(pjDst + 9) = *pTable;
            *(pjDst + 10) = *(pTable+1);
            *(pjDst + 11) = *(pTable+2);

            pTable = ExpTable + ((jSrc & 0x08) >> (3-2));

            *(pjDst + 12) = *pTable;
            *(pjDst + 13) = *(pTable+1);
            *(pjDst + 14) = *(pTable+2);

            pTable = ExpTable + (jSrc & 0x04);

            *(pjDst + 15) = *pTable;
            *(pjDst + 16) = *(pTable+1);
            *(pjDst + 17) = *(pTable+2);

            pTable = ExpTable + ((jSrc & 0x02) << 1);

            *(pjDst + 18) = *pTable;
            *(pjDst + 19) = *(pTable+1);
            *(pjDst + 20) = *(pTable+2);

            pTable = ExpTable + ((jSrc & 0x01) << 2);

            *(pjDst + 21) = *pTable;
            *(pjDst + 22) = *(pTable+1);
            *(pjDst + 23) = *(pTable+2);

            pjSrc++;
            pjDst += (3*8);

        }

        //
        // finish off scan line if needed
        //

        if (pjDst != pjEnd) {

            jSrc = *pjSrc++;

            do {

                pTable = ExpTable + ((jSrc & 0x80) >> (7-2));

                *(pjDst +  0) = *pTable;
                *(pjDst +  1) = *(pTable+1);
                *(pjDst +  2) = *(pTable+2);

                jSrc<<=1;
                pjDst+= 3;
            } while (pjDst != pjEnd);

        }

        pjDst = (PBYTE)((PBYTE)pjDst + lDstStride);
        pjSrc  += lSrcStride;

    } while(pjDst != pjEndY);

}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcOpaqCopyS1D32
*
* Routine Description:
*
*   Opaque blt of 1BPP src to destination format
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
vSrcOpaqCopyS1D32(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )

{
    BYTE    jSrc;
    LONG    ixStart    = SrcLeft & 0x07;
    PULONG  pulEnd;
    PULONG  pulEnd8;
    PULONG  pulDst     = (PULONG)pjDstIn + DstLeft;
    PBYTE   pjSrc      = pjSrcIn + (SrcLeft >> 3);
    LONG    cx         = DstRight - DstLeft;
    LONG    lDstStride = DeltaDstIn - (cx << 2);
    LONG    lSrcStride = DeltaSrcIn - ((cx + ixStart + 7) >> 3);
    UCHAR   ExpTable[8];
    PULONG  pulEndY    = (PULONG)((PBYTE)pulDst + DeltaDstIn * cy);
    LONG    StartOffset = min(cx, (8 - ixStart));

    //
    // build exp table
    //

    *(PULONG)ExpTable     = uB;
    *(PULONG)(ExpTable+4) = uF;

    do {

        pulEnd = pulDst + cx;

        //
        // do starting pixels
        //

        if (ixStart) {

            jSrc = *pjSrc << ixStart;

            pjSrc++;

            PULONG pulEndSt = pulDst + StartOffset;

            do {
                *pulDst = *(PULONG)(ExpTable + ((jSrc & 0x80) >> (7-2)));
                pulDst++;
                jSrc <<=1;

            } while (pulDst != pulEndSt);
        }


        //
        // number of full bytes that can be expanded
        //

        pulEnd8 = (PULONG)((PBYTE)pulDst + (((ULONG_PTR)pulEnd - (ULONG_PTR)pulDst) & ~0x1F));

        //
        // expand full bytes
        //

        while (pulDst != pulEnd8) {

            jSrc = *pjSrc;

            *(pulDst + 0) = *(PULONG)(ExpTable + ((jSrc & 0x80) >> (7-2)));
            *(pulDst + 1) = *(PULONG)(ExpTable + ((jSrc & 0x40) >> (6-2)));
            *(pulDst + 2) = *(PULONG)(ExpTable + ((jSrc & 0x20) >> (5-2)));
            *(pulDst + 3) = *(PULONG)(ExpTable + ((jSrc & 0x10) >> (4-2)));
            *(pulDst + 4) = *(PULONG)(ExpTable + ((jSrc & 0x08) >> (3-2)));
            *(pulDst + 5) = *(PULONG)(ExpTable + ((jSrc & 0x04) >> (2-2)));
            *(pulDst + 6) = *(PULONG)(ExpTable + ((jSrc & 0x02) << 1));
            *(pulDst + 7) = *(PULONG)(ExpTable + ((jSrc & 0x01) << 2));

            pjSrc++;
            pulDst += 8;

        }

        //
        // finish off scan line if needed
        //

        if (pulDst != pulEnd) {

            jSrc = *pjSrc++;

            do {
                *pulDst = *(PULONG)(ExpTable + ((jSrc & 0x80) >> (7-2)));
                jSrc<<=1;
                pulDst++;
            } while (pulDst != pulEnd);

        }

        pulDst = (PULONG)((PBYTE)pulDst + lDstStride);
        pjSrc  += lSrcStride;

    } while(pulDst != pulEndY);

}



VOID vSrcTranCopyError(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )
{
/**/WARNING("!!vSrcTranCopyError!!\n");
}

/******************************Public*Routine******************************\
* vRectBlt
*
* 'Extra' rectangle on a monochrome dib.
*
* History:
*  Thu Dec 03 11:22:21 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID vRectBlt
(
    PBYTE pjMonoDib,
    ULONG cjScanMono,
    LONG  xleft,
    LONG  ytop,
    LONG  xright,
    LONG  ybottom
)
{
    PWORD pwDst;
    ULONG cy = (ULONG) (ybottom - ytop);

    //
    // Left mask
    //

    static WORD awMaskL[16] = {
        0x0000, 0x0080, 0x00C0, 0x00E0, 0x00F0, 0x00F8, 0x00FC, 0x00FE,
        0x00FF, 0x80FF, 0xC0FF, 0xE0FF, 0xF0FF, 0xF8FF, 0xFCFF, 0xFEFF};

    //
    // Right mask
    //

    static WORD awMaskR[16] = {
        0xFFFF, 0xFF7F, 0xFF3F, 0xFF1F, 0xFF0F, 0xFF07, 0xFF03, 0xFF01,
        0xFF00, 0x7F00, 0x3F00, 0x1F00, 0x0F00, 0x0700, 0x0300, 0x0100};

    ASSERTGDI(xleft < xright && ytop < ybottom, "vRectBlt: bad rectangle");

    pjMonoDib += (ytop * cjScanMono);
    pjMonoDib += (xleft >> 4 << 1);

    //
    // Since the mono dib is word-aligned, we will set one word at a time
    // in the main loop.
    //

    LONG cWords = (xright >> 4) - ((xleft + 0xF) >> 4);

    do {

        pwDst = (PWORD) pjMonoDib;
        pjMonoDib += cjScanMono;

        //
        // Handle the special case where both xleft and xright are in
        // the same word and ((xleft & 0xF) != 0) and ((xright & 0xF) != 0).
        //

        if (cWords < 0)
        {
            WORD wMask = awMaskR[xleft & 0xF] & awMaskL[xright & 0xF];
            *pwDst = *pwDst | wMask;
            continue;
        }

        //
        // Handle the first partial source word.
        //

        if (xleft & 0xF)
        {
            *pwDst = *pwDst | awMaskR[xleft & 0xF];
            pwDst++;
        }

        //
        // Handle the main loop for each source word.
        //

        for (LONG i = cWords; i > 0; i--) {
            *pwDst++ = (WORD) ~0;
        }

        //
        // Handle the last partial source word.
        //

        if (xright & 0xF) {
            *pwDst = *pwDst | awMaskL[xright & 0xF];
        }
    } while (--cy);
}


VOID vRectBlt4
(
    PBYTE pj4bpp,
    ULONG cjScanMono,
    LONG  xleft,
    LONG  ytop,
    LONG  xright,
    LONG  ybottom
)
{
    // Put in a rectangle by hand. This is a matter of setting each
    // of the appropriate nibbles to 0xf
}


VOID vRectBlt8
(
    PBYTE pj8bpp,
    ULONG cjScanMono,
    LONG  xleft,
    LONG  ytop,
    LONG  xright,
    LONG  ybottom
)
{
    // Put in a rectangle by hand. This is a matter of setting each
    // of the appropriate pixels  to ????

    RIP("cleartype vRectBlt8 \n");

}



/******************************Public*Routine******************************\
* STROBJ_dwGetCodePage
*
* Code page corresponding to the current TextOut
*
* History:
*  Wed Jan 24 11:09:21 1996     -by-    Tessie Wu    [tessiew]
* Wrote it.
\**************************************************************************/

extern "C" DWORD STROBJ_dwGetCodePage( STROBJ* pstro)
{
   return ( ((ESTROBJ*)pstro)->dwCodePage );
}


/******************************Public*Routine******************************\
*
* more accelerators for ps driver:
*
* FIX APIENTRY STROBJ_fxCharacterExtra(STROBJ  *pstro)
* FIX APIENTRY STROBJ_fxBreakExtra(STROBJ  *pstro)
* Effects:
*
* History:
*  25-Oct-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



extern "C" FIX APIENTRY STROBJ_fxCharacterExtra(STROBJ  *pstro)
{
    if (((ESTROBJ*)pstro)->flAccel & SO_CHARACTER_EXTRA)
        return ((ESTROBJ*)pstro)->xExtra;
    else
        return 0;
}

extern "C" FIX APIENTRY STROBJ_fxBreakExtra(STROBJ  *pstro)
{
    if (((ESTROBJ*)pstro)->flAccel & SO_BREAK_EXTRA)
        return ((ESTROBJ*)pstro)->xBreakExtra;
    else
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\textxl.c ===
/******************************Module*Header*******************************\
* Module Name: textxl.c
*
*   Draw glyphs to 1Bpp temporary buffer. This is the portable version
*   of the x86 code from the VGA driver.
*
*
* Copyright (c) 1994-1999 Microsoft Corporation
\**************************************************************************/

#include "engine.h"

#if !defined (_X86_)


typedef VOID (*PFN_GLYPHLOOP)(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
typedef VOID (*PFN_GLYPHLOOPN)(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG,LONG);

PFN_GLYPHLOOP   pfnGlyphLoop;

//
// debug routine
//

VOID
exit_fast_text(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    return;
}

//
// or_all_1_wide_rotated_need_last::
// or_all_1_wide_rotated_no_last::
// or_first_1_wide_rotated_need_last
// or_first_1_wide_rotated_no_last::
//

VOID
or_all_1_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + cyGlyph;
    UCHAR  c;

    do {
        c = *pGlyph++;
        *pBuffer |= c >> RightRot;
        pBuffer += ulBufDelta;
    } while (pGlyph != pjEnd);
}

//
// mov_first_1_wide_rotated_need_last::
// mov_first_1_wide_rotated_no_last::
//

VOID
mov_first_1_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + cyGlyph;
    UCHAR  c;

    do {
        c = *pGlyph++;
        *pBuffer = c >> RightRot;
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
// mov_first_1_wide_unrotated::
//

VOID
mov_first_1_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + cyGlyph;
    do {
        *pBuffer = *pGlyph++;
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}


//
//or_all_1_wide_unrotated::
//or_all_1_wide_unrotated_loop::
//

VOID
or_all_1_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + cyGlyph;
    do {
        *pBuffer |= *pGlyph++;
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
// or_first_2_wide_rotated_need_last::
//

VOID
or_first_2_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 2*cyGlyph;
    ULONG rl = 8-RightRot;
    UCHAR c0,c1;

    do {
        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        pGlyph+=2;
        *pBuffer |= c0 >> RightRot;
        *(pBuffer+1) = (c1 >> RightRot) | (c0 << rl);
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
//or_all_2_wide_rotated_need_last::
//

VOID
or_all_2_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 2*cyGlyph;
    ULONG  rl    = 8-RightRot;
    USHORT usTmp;
    UCHAR  c0,c1;



    do {
        usTmp = *(PUSHORT)pGlyph;
        pGlyph += 2;
        c0 = (UCHAR)usTmp;
        c1 = (UCHAR)(usTmp >> 8);
        *pBuffer |= (UCHAR)(c0 >> RightRot);
        *(pBuffer+1) |= (UCHAR)((c1 >> RightRot) | (c0 << rl));
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
// mov_first_2_wide_rotated_need_last::
//

VOID
mov_first_2_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 2*cyGlyph;
    ULONG rl = 8-RightRot;
    USHORT us;
    UCHAR c0;
    UCHAR c1;

    do {
        us = *(PUSHORT)pGlyph;
        c0 = (us & 0xff);
        c1 = us >> 8;
        pGlyph += 2;
        *pBuffer     = c0 >> RightRot;
        *(pBuffer+1) = (c1 >> RightRot) | (c0 << rl);
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
// or_first_2_wide_rotated_no_last
//

VOID
or_first_2_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + cyGlyph;
    ULONG rl = 8-RightRot;
    UCHAR c0;

    do {
        c0 = *pGlyph++;
        *pBuffer     |= c0 >> RightRot;
        *(pBuffer+1)  = (c0 << rl);
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}


//
//or_all_2_wide_rotated_no_last::
//

VOID
or_all_2_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + cyGlyph;
    ULONG rl = 8-RightRot;
    UCHAR c;

    do {
        c = *pGlyph;
        pGlyph ++;
        *pBuffer     |= (UCHAR)(c >> RightRot);
        *(pBuffer+1) |= (UCHAR)(c << rl);
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
// or_all_2_wide_unrotated::
//

VOID
or_all_2_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 2*cyGlyph;

    //
    // aligned?
    //

    if ((ULONG_PTR)pBuffer & 0x01) {

        //
        // not aligned
        //

        USHORT usTmp;
        UCHAR  c1,c0;

        do {
            usTmp = *(PUSHORT)pGlyph;
            pGlyph +=2;
            *pBuffer     |= (UCHAR)usTmp;
            *(pBuffer+1) |= (UCHAR)(usTmp >> 8);
            pBuffer += ulBufDelta;
        }  while (pGlyph != pjEnd);

    } else {

        //
        // aligned
        //

        USHORT usTmp;

        do {
            usTmp = *(PUSHORT)pGlyph;
            pGlyph +=2;
            *(PUSHORT)pBuffer |= usTmp;
            pBuffer += ulBufDelta;
        }  while (pGlyph != pjEnd);

    }

}

//
// mov_first_2_wide_unrotated::
//

VOID
mov_first_2_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 2*cyGlyph;
    USHORT     us;

    do {
        us = *(PUSHORT)pGlyph;
        pGlyph +=2;
        *pBuffer      = us & 0xff;
        *(pBuffer+1)  = (UCHAR)(us >> 8);
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
// mov_first_2_wide_rotated_no_last::
//

VOID
mov_first_2_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + cyGlyph;
    ULONG rl = 8-RightRot;
    UCHAR c0;
    UCHAR c1;

    do {
        c0 = *pGlyph++;
        *pBuffer      = c0 >> RightRot;
        *(pBuffer+1)  = c0 << rl;
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
// or_first_3_wide_rotated_need_last::
//

VOID
or_first_3_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 3*cyGlyph;
    ULONG ul;
    UCHAR c0,c1,c2;

    do {
        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        //
        // make into big-endian ulong and shift
        //

        ul = (c0 << 16) | (c1 << 8) | c2;
        ul >>= RightRot;

        *pBuffer     |= (BYTE)(ul >> 16);
        *(pBuffer+1)  = (BYTE)(ul >> 8);
        *(pBuffer+2)  = (BYTE)(ul);

        pGlyph += 3;
        pBuffer += ulBufDelta;
    } while (pGlyph != pjEnd);
}


//
// or_all_3_wide_rotated_need_last::
//

VOID
or_all_3_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 3*cyGlyph;
    ULONG ul;
    UCHAR c0,c1,c2;
    do {
        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        //
        // make into big-endian ulong and shift
        //

        ul = (c0 << 16) | (c1 << 8) | c2;
        ul >>= RightRot;

        *pBuffer     |= (BYTE)(ul >> 16);
        *(pBuffer+1) |= (BYTE)(ul >> 8);
        *(pBuffer+2) |= (BYTE)(ul);

        pGlyph += 3;
        pBuffer += ulBufDelta;

    } while (pGlyph != pjEnd);
}

//
// or_all_3_wide_rotated_no_last::
//

VOID
or_all_3_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 2*cyGlyph;
    ULONG  ul;
    UCHAR  c0,c1;

    do {

        c0 = *pGlyph;
        c1 = *(pGlyph+1);

        //
        // make big-endian and shift
        //

        ul = (c0 << 16) | (c1 << 8);
        ul >>= RightRot;

        //
        // store result
        //

        *pBuffer     |= (BYTE)(ul >> 16);
        *(pBuffer+1) |= (BYTE)(ul >> 8);
        *(pBuffer+2) |= (BYTE)ul;


        pGlyph += 2;
        pBuffer += ulBufDelta;

    } while (pGlyph != pjEnd);
}

//
// or_first_3_wide_rotated_no_last::
//

VOID
or_first_3_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 2*cyGlyph;
    ULONG  ul;
    UCHAR  c0,c1;

    do {

        c0 = *pGlyph;
        c1 = *(pGlyph+1);

        //
        // make big-endian and shift
        //

        ul = (c0 << 16) | (c1 << 8);
        ul >>= RightRot;

        //
        // store result, only or in first byte
        //

        *pBuffer     |= (BYTE)(ul >> 16);
        *(pBuffer+1)  = (BYTE)(ul >> 8);
        *(pBuffer+2)  = (BYTE)ul;


        pGlyph += 2;
        pBuffer += ulBufDelta;

    } while (pGlyph != pjEnd);
}

//
// mov_first_3_wide_unrotated::
//

VOID
mov_first_3_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 3*cyGlyph;
    ULONG rl = 8-RightRot;
    UCHAR c0,c1,c2;

    do {

        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        *pBuffer     = c0;
        *(pBuffer+1) = c1;
        *(pBuffer+2) = c2;

        pGlyph += 3;
        pBuffer += ulBufDelta;

    } while (pGlyph != pjEnd);
}


//
//or_all_3_wide_unrotated::
//

VOID
or_all_3_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 3*cyGlyph;
    ULONG rl = 8-RightRot;
    UCHAR c0,c1,c2;

    do {
        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        *pBuffer |= c0;
        *(pBuffer+1) |= c1;
        *(pBuffer+2) |= c2;

        pBuffer += ulBufDelta;
        pGlyph += 3;

    } while (pGlyph != pjEnd);
}

//
// or_first_4_wide_rotated_need_last::
//

VOID
or_first_4_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 4*cyGlyph;
    ULONG  ul;
    ULONG  t0,t1,t2;

    do {

        ul = *(PULONG)pGlyph;

        //
        // endian swap
        //

        t0 = ul << 24;
        t1 = ul >> 24;
        t2 = (ul >> 8) & (0xff << 8);
        ul = (ul << 8) & (0xff << 16);

        ul = ul | t0 | t1 | t2;

        ul >>= RightRot;

        *pBuffer     |= (BYTE)(ul >> 24);

        *(pBuffer+1)  = (BYTE)(ul >> 16);

        *(pBuffer+2)  = (BYTE)(ul >> 8);

        *(pBuffer+3)  = (BYTE)(ul);

        pGlyph += 4;
        pBuffer += ulBufDelta;
    } while (pGlyph != pjEnd);
}

//
// or_all_4_wide_rotated_need_last::
//

VOID
or_all_4_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 4*cyGlyph;
    ULONG  ul;
    ULONG  t0,t1,t2;

    do {

        ul = *(PULONG)pGlyph;

        //
        // endian swap
        //

        t0 = ul << 24;
        t1 = ul >> 24;
        t2 = (ul >> 8) & (0xff << 8);
        ul = (ul << 8) & (0xff << 16);

        ul = ul | t0 | t1 | t2;

        ul >>= RightRot;

        *pBuffer     |= (BYTE)(ul >> 24);

        *(pBuffer+1) |= (BYTE)(ul >> 16);

        *(pBuffer+2) |= (BYTE)(ul >> 8);

        *(pBuffer+3) |= (BYTE)(ul);

        pGlyph += 4;
        pBuffer += ulBufDelta;

    } while (pGlyph != pjEnd);
}

//
// or_first_4_wide_rotated_no_last::
//

VOID
or_first_4_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PBYTE pjEnd = pGlyph + 3*cyGlyph;
    BYTE  c0,c1,c2;
    ULONG ul;


    while (pGlyph != pjEnd) {

        //
        // load src
        //

        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        //
        // or into big endian ULONG and shift
        //

        ul = (c0 << 24) | (c1 << 16) | (c2 << 8);
        ul >>= RightRot;

        //
        // store result, ony or in fisrt byte
        //

        *pBuffer     |= (BYTE)(ul >> 24);

        *(pBuffer+1) = (BYTE)(ul >> 16);;

        *(pBuffer+2) = (BYTE)(ul >> 8);

        *(pBuffer+3) = (BYTE)(ul);

        //
        // inc scan line
        //

        pGlyph += 3;
        pBuffer += ulBufDelta;
    }
}

//
// or_all_4_wide_rotated_no_last::
//

VOID
or_all_4_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PBYTE pjEnd = pGlyph + 3*cyGlyph;
    BYTE  c0,c1,c2;
    ULONG ul;


    while (pGlyph != pjEnd) {

        //
        // load src
        //

        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        //
        // or into big endian ULONG and shift
        //

        ul = (c0 << 24) | (c1 << 16) | (c2 << 8);
        ul >>= RightRot;

        //
        // store result
        //

        *pBuffer     |= (BYTE)(ul >> 24);

        *(pBuffer+1) |= (BYTE)(ul >> 16);;

        *(pBuffer+2) |= (BYTE)(ul >> 8);

        *(pBuffer+3) |= (BYTE)(ul);

        //
        // inc scan line
        //

        pGlyph += 3;
        pBuffer += ulBufDelta;
    }
}

VOID
mov_first_4_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 4*cyGlyph;

    switch ((ULONG_PTR)pBuffer & 0x03 ) {
    case 0:

        while (pGlyph != pjEnd) {
            *(PULONG)pBuffer = *(PULONG)pGlyph;
            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;

    case 1:
    case 3:
        while (pGlyph != pjEnd) {

            *pBuffer              = *pGlyph;
            *(pBuffer+1)          = *(pGlyph+1);
            *(pBuffer+2)          = *(pGlyph+2);
            *(pBuffer+3)          = *(pGlyph+3);

            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;
    case 2:
        while (pGlyph != pjEnd) {

            *(PUSHORT)(pBuffer)   = *(PUSHORT)pGlyph;
            *(PUSHORT)(pBuffer+2) = *(PUSHORT)(pGlyph+2);

            pBuffer += ulBufDelta;
            pGlyph += 4;
        }
        break;
    }
}


//
// or_all_4_wide_unrotated::
//

VOID
or_all_4_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 4*cyGlyph;

    switch ((ULONG_PTR)pBuffer & 0x03 ) {
    case 0:

        while (pGlyph != pjEnd) {

            *(PULONG)pBuffer |= *(PULONG)pGlyph;

            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;

    case 1:
    case 3:

        while (pGlyph != pjEnd) {

            *pBuffer              |= *pGlyph;
            *(pBuffer+1)          |= *(pGlyph+1);
            *(pBuffer+2)          |= *(pGlyph+2);
            *(pBuffer+3)          |= *(pGlyph+3);

            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;

    case 2:

        while (pGlyph != pjEnd) {

            *(PUSHORT)pBuffer     |= *(PUSHORT)pGlyph;
            *(PUSHORT)(pBuffer+2) |= *(PUSHORT)(pGlyph+2);

            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;
    }
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   or_first_N_wide_rotated_need_last
*
*
* Routine Description:
*
*   Draw arbitrarily wide glyphs to 1BPP temp buffer
*
*
* Arguments:
*
*   cyGlyph     -   glyph height
*   RightRot    -   alignment
*   ulBufDelta  -   scan line stride of temp buffer
*   pGlyph      -   pointer to glyph bitmap
*   pBuffer     -   pointer to temp buffer
*   cxGlyph     -   glyph width in pixels
*   cxDst       -   Dest width in bytes
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID
or_first_N_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    PUCHAR pjDst      = (PUCHAR)pBuffer;
    PUCHAR pjDstEnd;
    PUCHAR pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;
    LONG   rl         = 8-RightRot;

    //
    // source doesn't advance after first byte, and
    // we do the first byte outside the loop
    //

    do {

        UCHAR c0 = *pGlyph++;
        UCHAR c1;
        pjDstEnd = pjDst + cxDst;

        *pjDst |= c0 >> RightRot;
        pjDst++;
        c1 = c0 << rl;

        //
        // know cxDst is at least 4, use do-while
        //

        do {
            c0 = *pGlyph;
            *pjDst = (c0 >> RightRot) | c1;
            c1 = c0 << rl;
            pjDst++;
            pGlyph++;

        } while (pjDst != pjDstEnd);

        pjDst += lStride;

    }  while (pjDst != pjDstEndy);
}

VOID
or_all_N_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    PUCHAR pjDst      = (PUCHAR)pBuffer;
    PUCHAR pjDstEnd;
    PUCHAR pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;
    LONG   rl         = 8-RightRot;

    //
    // source doesn't advance after first byte, and
    // we do the first byte outside the loop
    //

    do {

        UCHAR c0 = *pGlyph++;
        UCHAR c1;
        pjDstEnd = pjDst + cxDst;

        *pjDst |= c0 >> RightRot;
        pjDst++;
        c1 = c0 << rl;

        //
        // know cxDst is at least 4, use do-while
        //

        do {
            c0 = *pGlyph;
            *pjDst |= ((c0 >> RightRot) | c1);
            c1 = c0 << rl;
            pjDst++;
            pGlyph++;

        } while (pjDst != pjDstEnd);

        pjDst += lStride;

    }  while (pjDst != pjDstEndy);
}

VOID
or_first_N_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    PUCHAR pjDst      = (PUCHAR)pBuffer;
    PUCHAR pjDstEnd;
    PUCHAR pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;
    LONG   rl         = 8-RightRot;

    //
    // source doesn't advance after first byte, and
    // we do the first byte outside the loop
    //

    do {

        UCHAR c0;
        UCHAR c1;
        pjDstEnd = pjDst + cxDst - 1;

        //
        // do first dest byte outside loop for OR
        //

        c1 = 0;
        c0 = *pGlyph;
        *pjDst |= ((c0 >> RightRot) | c1);
        pjDst++;
        pGlyph++;


        //
        // know cxDst is at least 4, use do-while
        //

        do {
            c0 = *pGlyph;
            *pjDst = ((c0 >> RightRot) | c1);
            c1 = c0 << rl;
            pjDst++;
            pGlyph++;

        } while (pjDst != pjDstEnd);

        //
        // last dst byte outside loop, no new src needed
        //

        *pjDst = c1;
        pjDst++;

        pjDst += lStride;

    }  while (pjDst != pjDstEndy);
}

VOID
or_all_N_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    PUCHAR pjDst      = (PUCHAR)pBuffer;
    PUCHAR pjDstEnd;
    PUCHAR pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;
    LONG   rl         = 8-RightRot;

    //
    // source doesn't advance after first byte, and
    // we do the first byte outside the loop
    //

    do {

        UCHAR c0;
        UCHAR c1;
        pjDstEnd = pjDst + cxDst - 1;

        //
        // do first dest byte outside loop for OR
        //

        c1 = 0;

        //
        // know cxDst is at least 4, use do-while
        //

        do {
            c0 = *pGlyph;
            *pjDst |= ((c0 >> RightRot) | c1);
            c1 = c0 << rl;
            pjDst++;
            pGlyph++;

        } while (pjDst != pjDstEnd);

        //
        // last dst byte outside loop, no new src needed
        //

        *pjDst |= c1;
        pjDst++;

        pjDst += lStride;

    }  while (pjDst != pjDstEndy);
}

//
// The following routines can be significantly sped up by
// breaking them out into DWORD alignment cases.
//

VOID
mov_first_N_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    PUCHAR pjDst      = (PUCHAR)pBuffer;
    PUCHAR pjDstEnd;
    PUCHAR pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;

    //
    // byte aligned copy
    //


    do {

        pjDstEnd = pjDst + cxDst;

        //
        // let compiler unroll inner loop
        //

        do {

            *pjDst++ = *pGlyph++;

        } while (pjDst != pjDstEnd );

        pjDst += lStride;

    }  while (pjDst != pjDstEndy);
}

VOID
or_all_N_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    PUCHAR pjDst      = (PUCHAR)pBuffer;
    PUCHAR pjDstEnd;
    PUCHAR pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;

    //
    // byte aligned copy
    //


    do {

        pjDstEnd = pjDst + cxDst;

        //
        // let compiler unroll inner loop
        //

        do {

            *pjDst++ |= *pGlyph++;

        } while (pjDst != pjDstEnd );

        pjDst += lStride;

    }  while (pjDst != pjDstEndy);
}



VOID exit_fast_text(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_1_wide_rotated_need_last(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_1_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_1_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_2_wide_rotated_need_last(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_2_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_2_wide_rotated_no_last  (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_2_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_3_wide_rotated_need_last(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_3_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_3_wide_rotated_no_last  (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_3_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_4_wide_rotated_need_last(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_4_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_4_wide_rotated_no_last  (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_4_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_N_wide_rotated_need_last(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG,LONG);
VOID or_all_N_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG,LONG);
VOID or_all_N_wide_rotated_no_last  (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG,LONG);
VOID or_all_N_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG,LONG);


PVOID OrAllTableNarrow[] = {
        exit_fast_text,
        exit_fast_text,
        exit_fast_text,
        exit_fast_text,
        or_all_1_wide_rotated_need_last,
        or_all_1_wide_unrotated,
        or_all_1_wide_rotated_need_last,
        or_all_1_wide_unrotated,
        or_all_2_wide_rotated_need_last,
        or_all_2_wide_unrotated,
        or_all_2_wide_rotated_no_last,
        or_all_2_wide_unrotated,
        or_all_3_wide_rotated_need_last,
        or_all_3_wide_unrotated,
        or_all_3_wide_rotated_no_last,
        or_all_3_wide_unrotated,
        or_all_4_wide_rotated_need_last,
        or_all_4_wide_unrotated,
        or_all_4_wide_rotated_no_last,
        or_all_4_wide_unrotated
    };


PVOID OrInitialTableNarrow[] = {
        exit_fast_text                     ,
        exit_fast_text                     ,
        exit_fast_text                     ,
        exit_fast_text                     ,

        or_all_1_wide_rotated_need_last    ,
        mov_first_1_wide_unrotated         ,
        or_all_1_wide_rotated_need_last    ,
        mov_first_1_wide_unrotated         ,

        or_first_2_wide_rotated_need_last  ,
        mov_first_2_wide_unrotated         ,
        or_first_2_wide_rotated_no_last    ,
        mov_first_2_wide_unrotated         ,

        or_first_3_wide_rotated_need_last  ,
        mov_first_3_wide_unrotated         ,
        or_first_3_wide_rotated_no_last    ,
        mov_first_3_wide_unrotated         ,
        or_first_4_wide_rotated_need_last  ,
        mov_first_4_wide_unrotated         ,
        or_first_4_wide_rotated_no_last    ,
        mov_first_4_wide_unrotated
    };

//
// Handles arbitrarily wide glyph drawing, for case where initial byte should be
// ORed if it's not aligned (intended for use in drawing all but the first glyph
// in a string). Table format is:
//  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
//  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
//

PVOID OrInitialTableWide[] = {
        or_first_N_wide_rotated_need_last,
        mov_first_N_wide_unrotated,
        or_first_N_wide_rotated_no_last,
        mov_first_N_wide_unrotated
    };

//
// Handles arbitrarily wide glyph drawing, for case where all bytes should
// be ORed (intended for use in drawing potentially overlapping glyphs).
// Table format is:
//  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
//  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
//
//

PVOID OrAllTableWide[] =  {
        or_all_N_wide_rotated_need_last,
        or_all_N_wide_unrotated,
        or_all_N_wide_rotated_no_last,
        or_all_N_wide_unrotated
    };


/******************************Public*Routine******************************\
*
* Routine Name
*
*   draw_nf_ntb_o_to_temp_start
*
* Routine Description:
*
*   Specialized glyph dispatch routine for non-fixed pitch, top and
*   bottom not aligned glyphs that do overlap. This routine calculates
*   the glyph's position on the temp buffer, then determines the correct
*   highly specialized routine to be used to draw each glyph based on
*   the glyph width, alignment and rotation
*
* Arguments:
*
*   pGlyphPos               - Pointer to first in list of GLYPHPOS structs
*   cGlyph                  - Number of glyphs to draw
*   pjTempBuffer            - Pointer to temp 1Bpp buffer to draw into
*   ulLeftEdge              - left edge of TextRect & 0xFFFFFFF80
*   TempBufDelta            - Scan line Delta for TempBuffer (always pos)
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID
draw_nf_ntb_o_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjTempBuffer,
    ULONG           ulLeftEdge,
    ULONG           TempBufDelta,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{

    LONG           NumScans;
    LONG           RightRot;
    PBYTE          pGlyphData;
    PBYTE          pTempOutput;
    GLYPHBITS      *pGlyphBits;
    LONG           GlyphPosX;
    LONG           GlyphPixels;
    LONG           GlyphAlignment;
    LONG           SrcBytes;
    LONG           DstBytes;
    ULONG          ulDrawFlag;
    PFN_GLYPHLOOPN pfnGlyphLoopN;
    PFN_GLYPHLOOP  pfnGlyphLoop;
    ULONG          iGlyph = 0;
    LONG           GlyphPosY;

    //
    // Draw non fixed pitch, tops and bottoms not aligned,overlap
    //

    while (cGlyphs--) {

        pGlyphBits = pGlyphPos[iGlyph].pgdf->pgb;

        //
        // Glyph position in temp buffer = point.x + org.c - (TextRect.left & 0xffffffe0)
        //

        GlyphPosX = pGlyphPos[iGlyph].ptl.x + pGlyphPos[iGlyph].pgdf->pgb->ptlOrigin.x - ulLeftEdge;
        GlyphPosY = pGlyphPos[iGlyph].ptl.y + pGlyphPos[iGlyph].pgdf->pgb->ptlOrigin.y - ulTempTop ;
        GlyphAlignment = GlyphPosX & 0x07;

        //
        // calc byte offset
        //

        pTempOutput = pjTempBuffer + (GlyphPosX >> 3);

        //
        // glyph width
        //

        GlyphPixels = pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cx;

        //
        // source and dest bytes required
        //

        DstBytes = ((GlyphAlignment) + GlyphPixels + 7) >> 3;
        SrcBytes = (GlyphPixels + 7) >> 3;

        pTempOutput += (GlyphPosY * TempBufDelta);

        if (DstBytes <= 4) {

            //
            // use narrow initial table
            //

            ulDrawFlag = (
                            (DstBytes << 2)              |
                            ((DstBytes > SrcBytes) << 1) |
                            ((GlyphAlignment == 0))
                         );


            pfnGlyphLoop = (PFN_GLYPHLOOP)OrAllTableNarrow[ulDrawFlag];

            pfnGlyphLoop(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes
                        );

        } else {

            //
            // use wide glyph drawing
            //

            ulDrawFlag = (
                            ((DstBytes > SrcBytes) << 1) |
                            ((GlyphAlignment == 0))
                         );


            pfnGlyphLoopN = (PFN_GLYPHLOOPN)OrAllTableWide[ulDrawFlag];

            pfnGlyphLoopN(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes,
                            DstBytes
                        );


        }

        iGlyph++;
    }


}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   draw_f_ntb_o_to_temp_start
*
* Routine Description:
*
*   Specialized glyph dispatch routine for fixed pitch, top and
*   bottom not aligned glyphs that do overlap. This routine calculates
*   the glyph's position on the temp buffer, then determines the correct
*   highly specialized routine to be used to draw each glyph based on
*   the glyph width, alignment and rotation
*
* Arguments:
*
*   pGlyphPos               - Pointer to first in list of GLYPHPOS structs
*   cGlyph                  - Number of glyphs to draw
*   pjTempBuffer            - Pointer to temp 1Bpp buffer to draw into
*   ulLeftEdge              - left edge of TextRect & 0xFFFFFFF80
*   TempBufDelta            - Scan line Delta for TempBuffer (always pos)
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID
draw_f_ntb_o_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjTempBuffer,
    ULONG           ulLeftEdge,
    ULONG           TempBufDelta,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{
    LONG           NumScans;
    LONG           RightRot;
    PBYTE          pGlyphData;
    PBYTE          pTempOutput;
    GLYPHBITS      *pGlyphBits;
    LONG           GlyphPosX;
    LONG           GlyphPixels;
    LONG           GlyphAlignment;
    LONG           SrcBytes;
    LONG           DstBytes;
    ULONG          ulDrawFlag;
    PFN_GLYPHLOOP  pfnGlyphLoop;
    PFN_GLYPHLOOPN pfnGlyphLoopN;
    ULONG          iGlyph = 0;
    LONG           GlyphPitchX;
    LONG           GlyphPitchY;
    LONG           GlyphPosY;

    //
    // Draw fixed pitch, tops and bottoms not aligned,overlap
    //

    GlyphPitchX = pGlyphPos->ptl.x - ulLeftEdge;
    GlyphPitchY = pGlyphPos->ptl.y - ulTempTop;

    while (cGlyphs--) {

        pGlyphBits = pGlyphPos[iGlyph].pgdf->pgb;

        //
        // Glyph position in temp buffer = point.x + org.c - (TextRect.left & 0xfffffff8)
        //

        GlyphPosX = GlyphPitchX + pGlyphPos[iGlyph].pgdf->pgb->ptlOrigin.x;
        GlyphPosY = GlyphPitchY + pGlyphPos[iGlyph].pgdf->pgb->ptlOrigin.y;

        GlyphAlignment = GlyphPosX & 0x07;

        //
        // calc byte offset
        //

        pTempOutput = pjTempBuffer + (GlyphPosX >> 3);

        //
        // glyph width
        //

        GlyphPixels = pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cx;

        //
        // source and dest bytes required
        //

        DstBytes = ((GlyphAlignment) + GlyphPixels + 7) >> 3;
        SrcBytes = (GlyphPixels + 7) >> 3;

        //
        // calc glyph destination scan line
        //

        pTempOutput += (GlyphPosY * TempBufDelta);

        if (DstBytes <= 4) {

            //
            // use narrow initial table
            //

            ulDrawFlag = (
                            (DstBytes << 2)              |
                            ((DstBytes > SrcBytes) << 1) |
                            ((GlyphAlignment == 0))
                         );


            pfnGlyphLoop = (PFN_GLYPHLOOP)OrAllTableNarrow[ulDrawFlag];

            pfnGlyphLoop(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes
                        );

        } else {

            //
            // use wide glyph drawing
            //

            ulDrawFlag = (
                            ((DstBytes > SrcBytes) << 1) |
                            ((GlyphAlignment == 0))
                         );


            pfnGlyphLoopN = (PFN_GLYPHLOOPN)OrAllTableWide[ulDrawFlag];

            pfnGlyphLoopN(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes,
                            DstBytes
                        );


        }

        GlyphPitchX += ulCharInc;
        iGlyph++;
    }

}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   draw_nf_tb_no_to_temp_start
*
* Routine Description:
*
*   Specialized glyph dispatch routine for non-fixed pitch, top and
*   bottom aligned glyphs that do not overlap. This routine calculates
*   the glyph's position on the temp buffer, then determines the correct
*   highly specialized routine to be used to draw each glyph based on
*   the glyph width, alignment and rotation
*
* Arguments:
*
*   pGlyphPos               - Pointer to first in list of GLYPHPOS structs
*   cGlyph                  - Number of glyphs to draw
*   pjTempBuffer            - Pointer to temp 1Bpp buffer to draw into
*   ulLeftEdge              - left edge of TextRect & 0xFFFFFFF80
*   TempBufDelta            - Scan line Delta for TempBuffer (always pos)
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID
draw_nf_tb_no_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjTempBuffer,
    ULONG           ulLeftEdge,
    ULONG           TempBufDelta,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{

    LONG           NumScans;
    LONG           RightRot;
    PBYTE          pGlyphData;
    PBYTE          pTempOutput;
    GLYPHBITS      *pGlyphBits;
    LONG           GlyphPosX;
    LONG           GlyphPixels;
    LONG           GlyphAlignment;
    LONG           SrcBytes;
    LONG           DstBytes;
    ULONG          ulDrawFlag;
    PFN_GLYPHLOOP  pfnGlyphLoop;
    PFN_GLYPHLOOPN pfnGlyphLoopN;
    ULONG          iGlyph = 0;

    //
    // Draw non fixed pitch, tops and bottoms not aligned,overlap
    //

    while (cGlyphs--) {

        pGlyphBits = pGlyphPos[iGlyph].pgdf->pgb;

        //
        // Glyph position in temp buffer = point.x + org.c - (TextRect.left & 0xfffffff8)
        //

        GlyphPosX = pGlyphPos[iGlyph].ptl.x + pGlyphPos[iGlyph].pgdf->pgb->ptlOrigin.x - ulLeftEdge;
        GlyphAlignment = GlyphPosX & 0x07;

        //
        // calc byte offset
        //

        pTempOutput = pjTempBuffer + (GlyphPosX >> 3);

        //
        // glyph width
        //

        GlyphPixels = pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cx;

        //
        // source and dest bytes required
        //

        DstBytes = ((GlyphAlignment) + GlyphPixels + 7) >> 3;
        SrcBytes = (GlyphPixels + 7) >> 3;

        if (DstBytes <= 4) {

            //
            // use narrow initial table
            //

            ulDrawFlag = (
                            (DstBytes << 2)              |
                            ((DstBytes > SrcBytes) << 1) |
                            ((GlyphAlignment == 0))
                         );


            pfnGlyphLoop = (PFN_GLYPHLOOP)OrInitialTableNarrow[ulDrawFlag];

            pfnGlyphLoop(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes
                        );

        } else {

            //
            // use wide glyph drawing
            //

            ulDrawFlag = (
                            ((DstBytes > SrcBytes) << 1) |
                            ((GlyphAlignment == 0))
                         );


            pfnGlyphLoopN = (PFN_GLYPHLOOPN)OrAllTableWide[ulDrawFlag];

            pfnGlyphLoopN(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes,
                            DstBytes
                        );


        }

        iGlyph++;
    }

}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   draw_f_tb_no_to_temp_start
*
* Routine Description:
*
*   Specialized glyph dispatch routine for fixed pitch, top and
*   bottom aligned glyphs that do not overlap. This routine calculates
*   the glyph's position on the temp buffer, then determines the correct
*   highly specialized routine to be used to draw each glyph based on
*   the glyph width, alignment and rotation
*
* Arguments:
*
*   pGlyphPos               - Pointer to first in list of GLYPHPOS structs
*   cGlyph                  - Number of glyphs to draw
*   pjTempBuffer            - Pointer to temp 1Bpp buffer to draw into
*   ulLeftEdge              - left edge of TextRect & 0xFFFFFFF80
*   TempBufDelta            - Scan line Delta for TempBuffer (always pos)
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
draw_f_tb_no_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjTempBuffer,
    ULONG           ulLeftEdge,
    ULONG           TempBufDelta,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{

    LONG           NumScans;
    LONG           RightRot;
    PBYTE          pGlyphData;
    PBYTE          pTempOutput;
    GLYPHBITS      *pGlyphBits;
    LONG           GlyphPosX;
    LONG           GlyphPixels;
    LONG           GlyphAlignment;
    LONG           SrcBytes;
    LONG           DstBytes;
    ULONG          ulDrawFlag;
    PFN_GLYPHLOOPN pfnGlyphLoopN;
    PFN_GLYPHLOOP  pfnGlyphLoop;
    ULONG          iGlyph = 0;
    LONG           GlyphPitchX;

    GlyphPitchX = pGlyphPos->ptl.x;

    //
    // Draw fixed pitch, tops and bottoms not aligned,overlap
    //

    while (cGlyphs--) {

        pGlyphBits = pGlyphPos[iGlyph].pgdf->pgb;

        //
        // Glyph position in temp buffer = point.x + org.c - (TextRect.left & 0xfffffff8)
        //

        GlyphPosX = GlyphPitchX + pGlyphPos[iGlyph].pgdf->pgb->ptlOrigin.x - ulLeftEdge;
        GlyphAlignment = GlyphPosX & 0x07;

        //
        // calc byte offset
        //

        pTempOutput = pjTempBuffer + (GlyphPosX >> 3);

        //
        // glyph width
        //

        GlyphPixels = pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cx;

        //
        // source and dest bytes required
        //

        DstBytes = ((GlyphAlignment) + GlyphPixels + 7) >> 3;
        SrcBytes = (GlyphPixels + 7) >> 3;

        if (DstBytes <= 4) {

            //
            // use narrow initial table
            //

            ulDrawFlag = (
                            (DstBytes << 2)                       |
                            ((DstBytes > SrcBytes) << 1)          |
                            (GlyphAlignment == 0)
                         );


            pfnGlyphLoop = (PFN_GLYPHLOOP)OrInitialTableNarrow[ulDrawFlag];

            pfnGlyphLoop(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes
                        );

        } else {

            //
            // use wide glyph drawing
            //

            ulDrawFlag = (
                            ((DstBytes > SrcBytes) << 1) |
                            ((GlyphAlignment == 0))
                         );


            pfnGlyphLoopN = (PFN_GLYPHLOOPN)OrAllTableWide[ulDrawFlag];

            pfnGlyphLoopN(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes,
                            DstBytes
                        );


        }


        iGlyph++;
        GlyphPitchX += ulCharInc;

    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\surfobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: surfobj.cxx
*
* Surface user objects.
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#ifdef _HYDRA_
#include "muclean.hxx"
#endif

extern BOOL G_fConsole;

// Global surface uniqueness -- incremented every time a surface is created.

ULONG _ulGlobalSurfaceUnique;

// The following declarations are required by the native c8 compiler.

PSURFACE SURFACE::pdibDefault;   // The default bitmap pointer

SIZE_T SURFACE::tSize = sizeof(SURFACE);

#if TRACE_SURFACE_ALLOCS
TRACED_SURFACE::SurfaceTraceStatus TRACED_SURFACE::eTraceStatus = SURFACE_TRACING_UNINITIALIZED;
#if TRACE_SURFACE_USER_CHAIN_IN_UM
TRACED_SURFACE::SurfaceTraceStatus TRACED_SURFACE::eUMTraceStatus = SURFACE_TRACING_UNINITIALIZED;
#endif
#endif

// By default, EngCreateBitmap allocations larger than 260k will be
// allocated as a section:

#define KM_SIZE_MAX   0x40000


/******************************Public*Routine******************************\
* GreMarkUndeletableBitmap -- a USER callable API to mark a surface as
*     undeletable.  Currently this is used to make sure applications
*     cannot delete redirection bitmaps.
*
* Arguments:
*
*   hbm -- handle to bitmap to be marked undeletable
*
* Return Value:
*   
*   TRUE upon success, FALSE otherwise.
*
* History:
*
*    2-Nov-1998 -by- Ori Gershony [orig]
*
\**************************************************************************/

BOOL
GreMarkUndeletableBitmap(
    HBITMAP hbm
    )
{
    return (HmgMarkUndeletable((HOBJ) hbm, SURF_TYPE));
}

/******************************Public*Routine******************************\
* GreMarkDeletableBitmap -- a USER callable API to mark a surface as
*     deletable.  Currently this is used by USER just before deleting
*     a redirection bitmap.
*
* Arguments:
*
*   hbm -- handle to bitmap to be marked deletable
*
* Return Value:
*   
*   TRUE upon success, FALSE otherwise.
*
* History:
*
*    2-Nov-1998 -by- Ori Gershony [orig]
*
\**************************************************************************/

BOOL
GreMarkDeletableBitmap(
    HBITMAP hbm
    )
{
    return (HmgMarkDeletable((HOBJ) hbm, SURF_TYPE));
}


/******************************Public*Routine******************************\
*   pvAllocateKernelSection - Allocate kernel mode section
*
* Arguments:
*
*   AllocationSize - size in bytes of requested memory
*
* Return Value:
*
*   Pointer to memory or NULL
*
* History:
*
*    22-May-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

PVOID
pvAllocateKernelSection(
    ULONGSIZE_T   AllocationSize,
    ULONG         Tag
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LARGE_INTEGER MaximumSize;
    PVOID  pvAlloc = NULL;
    PVOID  pvRet   = NULL;

    //
    // Create km section
    //


    ACCESS_MASK DesiredAccess =  SECTION_MAP_READ |
                                 SECTION_MAP_WRITE;

    ULONG SectionPageProtection = PAGE_READWRITE;

    ULONG AllocationAttributes = SEC_COMMIT |
                                 SEC_NO_CHANGE;

    MaximumSize.HighPart = 0;
    MaximumSize.LowPart  = AllocationSize + sizeof(KMSECTIONHEADER);



    PVOID pHandleSection;

    //
    // map a copy of this section into kernel address space
    // Lets use the Section tagging code.
    //
    Status = Win32CreateSection(&pHandleSection,
                                DesiredAccess,
                                NULL,
                                &MaximumSize,
                                SectionPageProtection,
                                AllocationAttributes,
                                NULL,
                                NULL,
                                TAG_SECTION_DIB);

    if (!NT_SUCCESS(Status))
    {
        WARNING1("pvAllocateKernelSection: ObReferenceObjectByHandle failed\n");
    }
    else
    {
        SIZE_T ViewSize = 0;

#ifdef _HYDRA_
        // MmMapViewInSessionSpace is internally promoted to
        // MmMapViewInSystemSpace on non-Hydra systems.
        Status = Win32MapViewInSessionSpace(
                        pHandleSection,
                        (PVOID*)&pvAlloc,
                        &ViewSize);
#else
        Status = MmMapViewInSystemSpace(
                        pHandleSection,
                        (PVOID*)&pvAlloc,
                        &ViewSize);
#endif

        if (!NT_SUCCESS(Status))
        {
            //
            // free section
            //

            WARNING1("pvAllocateKernelSection: MmMapViewInSystemSpace failed\n");
            Win32DestroySection(pHandleSection);
        }
        else
        {
#ifdef _HYDRA_
#if DBG
            if (!G_fConsole)
            {
                DebugGreTrackAddMapView(pvAlloc);
            }
#endif
#endif
            ((PKMSECTIONHEADER)pvAlloc)->Tag      = Tag;
            ((PKMSECTIONHEADER)pvAlloc)->pSection = pHandleSection;

            pvRet = (PVOID)(((PUCHAR)pvAlloc)+sizeof(KMSECTIONHEADER));
        }
    }

    return(pvRet);
}

/******************************Public*Routine******************************\
*   vFreeKernelSection: Free kernel mode section
*
* Arguments:
*
*   pvMem - Kernel mode section pointer
*
* Return Value:
*
*   None
*
* History:
*
*    22-May-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFreeKernelSection(
    PVOID pvMem
    )
{
    NTSTATUS Status;
    PVOID    pHandleSection;

    if (pvMem != NULL)
    {
        PKMSECTIONHEADER pvHeader = (PKMSECTIONHEADER)((PUCHAR)pvMem - sizeof(KMSECTIONHEADER));

        pHandleSection = pvHeader->pSection;

        //
        // Temporary code to catch stress failure (bug #263678)
        // We want to fail before the page is unmapped, instead of
        // afterwards
        //

        if (!pHandleSection) 
        {
            KeBugCheckEx(PAGE_FAULT_IN_NONPAGED_AREA,
                         (LONG_PTR) pHandleSection,
                         (LONG_PTR) pvHeader->pSection,
                         (LONG) pvHeader->Tag,
                         0);
        }

        //
        // unmap kernel mode view
        //

#ifdef _HYDRA_
        // MmUnmapViewInSessionSpace is internally promoted to
        // MmUnmapViewInSystemSpace on non-Hydra systems.

        Status = Win32UnmapViewInSessionSpace((PVOID)pvHeader);
#else
        Status = MmUnmapViewInSystemSpace((PVOID)pvHeader);
#endif

        if (!NT_SUCCESS(Status))
        {
            WARNING1("vFreeKernelSection: MmUnmapViewInSystemSpace failed\n");
        }
        else
        {
#ifdef _HYDRA_
#if DBG
            if (!G_fConsole)
            {
                DebugGreTrackRemoveMapView(pvHeader);
            }
#endif
#endif
            //
            // delete reference to section
            //

            Win32DestroySection(pHandleSection);
        }
    }
    else
    {
        WARNING("vFreeKernelSection called with NULL pvMem\n");
    }
}

/******************************Public*Routine******************************\
* SURFACE::bDeleteSurface()
*
* Delete the surface.  Make sure it is not selected into a DC if it is
* a bitmap.  We do under cover of multi-lock to ensure no one will select
* the bitmap into a DC after we checked cRef.
*
* History:
*  Mon 17-Feb-1992 -by- Patrick Haluptzok [patrickh]
* Add support for closing journal file.
*
*  Fri 22-Feb-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

BOOL
SURFACE::bDeleteSurface(CLEANUPTYPE cutype)
{
    GDIFunctionID(SURFACE::bDeleteSurface);

    BOOL bRet = TRUE;

    if (!bIsDefault() && bValid())
    {
        HANDLE hSecure       = NULL;
        HANDLE hDibSection   = NULL;
        PVOID  pvBitsBaseOld = NULL;

        if (iType() == STYPE_BITMAP)
        {
            hSecure       = DIB.hSecure;
            hDibSection   = DIB.hDIBSection;
            pvBitsBaseOld = pvBitsBase();
        }

        PDEVOBJ      pdo(hdev());
        ULONG        iTypeOld  = iType();
        DHSURF       dhsurfOld = dhsurf();
        PPALETTE     ppalOld   = ppal();
        EWNDOBJ     *pwoDelete = pwo();
        PVOID        pvBitsOld = pvBits();
        FLONG        fl        = fjBitmap();

        //
        // If the surface is a bitmap, ensure it is not selected into a DC.
        // Also make sure we are the only one with it locked down. These are
        // both tested at once with HmgRemoveObject, because we increment
        // and decrement the alt lock count at the same time we increment
        // and decrement the cRef count on selection and deselection into
        // DCs. Note that surfaces can also be locked for GetDIBits with no
        // DC involvement, so the alt lock count may be higher than the
        // reference count.
        //

        ASSERTGDI(HmgQueryLock((HOBJ) hGet()) == 0,
                  "ERROR cLock != 0");

        //
        // If it's a device bitmap, acquire the devlock to protect against
        // dynamic mode and driver changes.
        //

        DEVLOCKOBJ dlo;

        if (bEngCreateDeviceBitmap() && pdo.bValid())
        {
            dlo.vLock(pdo);
        }
        else
        {
            dlo.vInit();
        }

#if TRACE_SURFACE_ALLOCS
#if TRACE_SURFACE_USER_CHAIN_IN_UM
        PVOID   pvUserMem = NULL;

        if (TRACED_SURFACE::bEnabled())
        {
            TRACED_SURFACE *pts = (TRACED_SURFACE *)this;
            UINT            uiIndex = (UINT) HmgIfromH(hGet());

            if (pts->Trace.UserChainAllocated &&
                uiIndex < gcMaxHmgr)
            {
                pvUserMem = gpentHmgr[uiIndex].pUser;
                ASSERTGDI(pvUserMem == NULL ||
                          OBJECTOWNER_PID(gpentHmgr[uiIndex].ObjectOwner) == W32GetCurrentPID(),
                          "Unowned SURFACE still has User Memory.");
            }
        }
#endif
#endif
        //
        // Remove undeletable surfaces only during session cleanup.
        //

        if (HmgRemoveObject((HOBJ) hGet(), 0, 1, (cutype == CLEANUP_SESSION), 
            SURF_TYPE))
        {
#if TRACE_SURFACE_ALLOCS
#if TRACE_SURFACE_USER_CHAIN_IN_UM
            EngFreeUserMem(pvUserMem);
#endif
#endif
            //
            // If this bitmap was created by EngCreateDeviceBitmap, we have
            // to call DrvDeleteDeviceBitmap to clean it up.  Note that we
            // can't simply check for STYPE_DEVBITMAP, since EngModifySurface
            // may have changed the type to STYPE_BITMAP.
            //

            if (bEngCreateDeviceBitmap() && (dhsurfOld != NULL))
            {
                //
                // In UMPD, a bad driver/app(ntcrash) can create a dev bitmap by
                // EngCreateDeviceBitmap.  But hdev could be null if 
                // EngAssociateSurface is not called.
                //

                if (pdo.bValid() && PPFNVALID(pdo, DeleteDeviceBitmap))
                {
                    #if defined(_GDIPLUS_)

                    (*PPFNDRV(pdo,DeleteDeviceBitmap))(dhsurfOld);

                    #else // !_GDIPLUS_

                    if (bUMPD())
                    {
                        //
                        // Do not callout to user-mode driver if the
                        // user-mode process is gone (i.e., during
                        // session or process cleanup).
                        //

                        if (cutype == CLEANUP_NONE)
                        {
                            UMPDDrvDeleteDeviceBitmap(pdo.dhpdev(), dhsurfOld);
                        }
                    }
                    else
                    {
                        (*PPFNDRV(pdo,DeleteDeviceBitmap))(dhsurfOld);
                    }

                    #endif // !_GDIPLUS_
                }
            }

            FREEOBJ(this, SURF_TYPE);

            //
            // Note, 'this' not set to NULL
            //

            //
            // For kernel mode, we must unlock the section memory,
            // then free the memory. If the section handle is NULL
            // then we just use NtVirtualFree, otherwise we must
            // use NtUnmapViewOfSection
            //

            if (hSecure != NULL)
            {
                MmUnsecureVirtualMemory(hSecure);

                if (pvBitsOld == NULL)
                {
                    WARNING("deleting DIB but hSecure or pvBitsOld == NULL");
                }
                else
                {
                    if (hDibSection != NULL)
                    {
                        ZwUnmapViewOfSection(NtCurrentProcess(), pvBitsBaseOld);
                    }
                    else
                    {

                        SIZE_T ViewSize = 0;

                        ZwFreeVirtualMemory(
                                        NtCurrentProcess(),
                                        &pvBitsOld,
                                        &ViewSize,
                                        MEM_RELEASE);
                    }
                }
            }
            else if (fl & BMF_USERMEM)
            {
#if defined(_WIN64)
                if (fl & BMF_UMPDMEM)
                    UMPDEngFreeUserMem(pvBitsOld);
                else
#endif
                    EngFreeUserMem(pvBitsOld);
            }
            else if (fl & BMF_KMSECTION)
            {
                vFreeKernelSection(pvBitsOld);
            }

            //
            // This DC is going away, the associated WNDOBJ should be deleted.
            // The WNDOBJs for memory bitmap and printer surface are deleted here.
            // The WNDOBJs for display DCs are deleted in DestroyWindow.
            //

            if (pwoDelete)
            {
                GreDeleteWnd((PVOID) pwoDelete);
            }

            if (ppalOld != NULL)
            {
                XEPALOBJ pal(ppalOld);
                pal.vUnrefPalette();
            }
        }
        else
        {
            //
            // if we can't remove it because it's an application's bitmap
            // and is currently selected, mark it for lazy deletion
            //

            if (HmgQueryAltLock((HOBJ)hGet()) != 1)
            {
                if (hdc() != NULL || bStockSurface())
                {
                    //
                    // The surface is currently selected into a DC, so we can't
                    // simply delete it.  Instead, mark it to be deleted when
                    // the DC is destroyed, or a new surface is selected into
                    // the DC.
                    //

                    vLazyDelete();
                    bRet = TRUE;

                    //
                    // Because we're returning TRUE, the caller will expect
                    // that the deletion succeeded and so will not unlock the
                    // object.  But since it wasn't truly deleted, we have
                    // to keep the lock count consistent with the number of DC
                    // references.  We account for the fact that the caller
                    // won't do the unlock by doing it here:
                    //

                    DEC_SHARE_REF_CNT(this);
                }
                else
                {
                    WARNING("LIKELY MEMORY LEAK IN DRIVER OR GDI!");
                    RIP("active locks prevented surface deletion");
                    bRet = FALSE;
                }
            }
            else
            {
                RIP("failed, handle busy\n");
                SAVE_ERROR_CODE(ERROR_BUSY);
                bRet = FALSE;
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SURFMEM::bCreateDIB
*
* Constructor for device independent bitmap memory object
*
* History:
*  Mon 18-May-1992 -by- Patrick Haluptzok [patrickh]
* return BOOL
*
*  28-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
SURFMEM::bCreateDIB(
    PDEVBITMAPINFO pdbmi,
    PVOID pvBitsIn,
    HANDLE hDIBSection,
    DWORD  dsOffset,
    HANDLE hSecure,
    ULONG_PTR  dwColorSpace
    )
{
    GDIFunctionID(SURFMEM::bCreateDIB);

    BOOL bRet = TRUE;

    AllocationFlags = SURFACE_DIB;
    ps = (PSURFACE) NULL;
    FLONG flAllocateSection = 0;
    BOOL bCompressed = FALSE;

    //
    // Figure out the length of a scanline taking arithmetic overflows into account.
    //

    ULONG cjScanTemp;

    switch(pdbmi->iFormat)
    {
    case BMF_1BPP:
        cjScanTemp = ((pdbmi->cxBitmap + 31) & ~31);
        if(cjScanTemp < pdbmi->cxBitmap)
            return(FALSE);
        cjScanTemp >>= 3;
        break;

    case BMF_4BPP:
        cjScanTemp = ((pdbmi->cxBitmap + 7) & ~7);
        if (cjScanTemp < pdbmi->cxBitmap)
            return(FALSE);
        cjScanTemp >>= 1;
        break;

    case BMF_8BPP:
        cjScanTemp = (pdbmi->cxBitmap + 3) & ~3;
        if (cjScanTemp < pdbmi->cxBitmap)
            return(FALSE);
        break;

    case BMF_16BPP:
        cjScanTemp = ((pdbmi->cxBitmap + 1) & ~1) << 1;
        if (cjScanTemp < pdbmi->cxBitmap)
            return(FALSE);
        break;

    case BMF_24BPP:
        if ((pdbmi->cxBitmap * 3 < pdbmi->cxBitmap) ||
            ((cjScanTemp = ((pdbmi->cxBitmap * 3) + 3) & ~3) < pdbmi->cxBitmap))
            return(FALSE);
        break;

    case BMF_32BPP:
        cjScanTemp = pdbmi->cxBitmap << 2;
        if (cjScanTemp < pdbmi->cxBitmap)
            return(FALSE);
        break;

    case BMF_8RLE:
    case BMF_4RLE:
    case BMF_JPEG:
    case BMF_PNG:
        bCompressed = TRUE;
        break;

    default:
        WARNING("ERROR: failed INVALID BITMAP FORMAT \n");
        return(FALSE);
    }

    //
    // If we are given a pointer to bits, then only allocate a DIB header.
    // Otherwise allocate space for the header and the required bits.
    //

    ULONGSIZE_T size = (ULONGSIZE_T) SURFACE::tSizeOf();

    FSHORT fsAlloc = HMGR_ALLOC_ALT_LOCK|HMGR_NO_ZERO_INIT;

    if (pvBitsIn == (PVOID) NULL)
    {
        LONGLONG eq;

        if (bCompressed)
            eq = (LONGLONG)(ULONGLONG) pdbmi->cjBits;
        else
            eq = Int32x32To64(pdbmi->cyBitmap, cjScanTemp);

        eq += (LONGLONG)(ULONGLONG) size;

        if (eq > LONG_MAX)
        {
            WARNING("Attempting to allocate > 4Gb\n");
            return(FALSE);
        }

        //
        // if it is UMPD and size > PAGE_SIZE, we always allocate in user memory
        //
        //
        // make sure no one will change KM_SIZE_MAX later and mess things up
        //
        ASSERTGDI(PAGE_SIZE < KM_SIZE_MAX, "bad KM_SIZE_MAX\n");

        if ((pdbmi->fl & UMPD_SURFACE) && (eq > PAGE_SIZE))
            pdbmi->fl |= BMF_USERMEM;

        // see if we need to allocate the bits out of USER memory

        if (pdbmi->fl & BMF_USERMEM)
        {
            pvBitsIn = EngAllocUserMem((LONG) eq,'mbuG'); //Gubm

            if (pvBitsIn == NULL)
                return(FALSE);
        }
        else if ((pdbmi->fl & BMF_KMSECTION) || (eq > KM_SIZE_MAX))
        {
            //
            // Kernel-mode pool is limited in size and prone to fragmentation.
            // For this reason, we will automatically allocate 'large' bitmaps
            // as sections, which will not be charged against kernel-mode
            // pool.
            //
            // We also allow the driver to specify BMF_KMSECTION -- this is
            // specifically for the ModeX driver to allow it to map its shadow
            // buffer into user-mode.
            //

            //
            //Sundown, change from SIZE_T to LONG, we return false earlier if > 4GB
            //
            pvBitsIn = pvAllocateKernelSection((LONG)eq,'mbkG');

            if (pvBitsIn != NULL)
            {
                //
                // mark surface as KM SECTION
                //

                flAllocateSection = BMF_KMSECTION;
            }
        }

        //
        // combine size and allocate from pool
        //

        if (pvBitsIn == NULL)
        {
            size = (ULONGSIZE_T) eq;

            if ((pdbmi->fl & BMF_NOZEROINIT) == 0)
            {
                fsAlloc = HMGR_ALLOC_ALT_LOCK;
            }
        }
    }
    else
    {
        ASSERTGDI(!(pdbmi->fl & BMF_USERMEM),"flags error\n");
    }

    ps = (PSURFACE)ALLOCOBJ(size,SURF_TYPE,!(fsAlloc & HMGR_NO_ZERO_INIT));

    if (ps == NULL)
    {
        WARNING("failed memory alloc\n");
        bRet = FALSE;
    }
    else
    {
        //
        // Initialize the surf fields
        //

        SIZEL sizlTemp;
        sizlTemp.cx = pdbmi->cxBitmap;
        sizlTemp.cy = pdbmi->cyBitmap;
        ps->sizl(sizlTemp);
        ps->iType(STYPE_BITMAP);
        ps->hSecureUMPD = 0;

        if (pdbmi->hpal != (HPALETTE) 0)
        {
            EPALOBJ palSurf(pdbmi->hpal);
            ASSERTGDI(palSurf.bValid(), "ERROR invalid palette");

            //
            // Set palette into surface.
            //

            ps->ppal(palSurf.ppalGet());

            //
            // Reference count it by making sure it is not unlocked.
            //

            palSurf.ppalSet((PPALETTE) NULL);  // It won't be unlocked
        }
        else
        {
            ps->ppal((PPALETTE) NULL);
        }

        //
        // Initialize the BITMAP fields
        //

        ps->iFormat(pdbmi->iFormat);

        ps->fjBitmap(((pdbmi->fl) & (BMF_TOPDOWN | BMF_USERMEM)) |
                     (flAllocateSection));

        ps->DIB.hDIBSection = hDIBSection;
        ps->DIB.dwOffset = dsOffset;
        ps->DIB.hSecure = hSecure;
        ps->DIB.dwDIBColorSpace = dwColorSpace;

        ps->dhsurf((DHSURF) 0);
        ps->dhpdev((DHPDEV) 0);
        ps->flags(pdbmi->fl & UMPD_SURFACE);
        ps->pwo((EWNDOBJ *) NULL);
        sizlTemp.cx = 0;
        sizlTemp.cy = 0;
        ps->sizlDim(sizlTemp);
        ps->hdev((HDEV) 0);
        ps->EBitmap.hdc = (HDC) 0;
        ps->EBitmap.cRef = 0;
        ps->EBitmap.hpalHint = 0;
        ps->pdcoAA = NULL;

        if (hSecure != (HANDLE) NULL)
        {
            //
            // Set flag for DIBSECTION so driver doesn't cache it.
            // because we don't know to increment the uniqueness
            // when the app writes on it.
            //

            ps->so.fjBitmap |= BMF_DONTCACHE;
        }

        //
        // Initialize the DIB fields
        //

        if (pvBitsIn == (PVOID) NULL)
        {
            ps->pvBits((PVOID) (((ULONG_PTR) ps) + SURFACE::tSizeOf()));
        }
        else
        {
            ps->pvBits(pvBitsIn);
        }

        if ((pdbmi->iFormat != BMF_8RLE) &&
            (pdbmi->iFormat != BMF_4RLE) &&
            (pdbmi->iFormat != BMF_JPEG) &&
            (pdbmi->iFormat != BMF_PNG ))
        {
            ps->cjBits(pdbmi->cyBitmap * cjScanTemp);

            if (pdbmi->fl & BMF_TOPDOWN)
            {
                ps->lDelta(cjScanTemp);
                ps->pvScan0(ps->pvBits());
            }
            else
            {
                ps->lDelta(-(LONG)cjScanTemp);
                ps->pvScan0((PVOID) (((PBYTE) ps->pvBits()) +
                                   (ps->cjBits() - cjScanTemp)));
            }
        }
        else
        {
            //
            // lDelta is 0 because RLE's don't have scanlines.
            //

            ps->lDelta(0);
            ps->cjBits(pdbmi->cjBits);

            //
            // pvScan0 is ignored for JPEG's and PNG's
            //

            if ((pdbmi->iFormat != BMF_JPEG) && (pdbmi->iFormat != BMF_PNG))
                ps->pvScan0(ps->pvBits());
            else
                ps->pvScan0(NULL);
        }

        //
        // Set initial uniqueness.  Not 0 because that means don't cache it.
        //
        // We used to always set the uniqueness to 1 on creation, but the
        // NetMeeting folks ran into tool-bar scenarios where the buttons
        // were being created and deleted on every repaint and eventually we
        // would run out of uniqueness bits in the handles.  So the end
        // result would be that the NetMeeting driver would see a surface
        // with a handle the same as the one they cached, and with an iUniq
        // the same as the one they cached (specifically, a value of '1') --
        // but the cached bitmap would not match the actual bitmap bits!
        //
        // We fix this by always creating the surface with a unique uniqueness.
        // Note that it's still possible to get different surfaces with the
        // same uniqueness because drawing calls simply increment the surface
        // uniqueness, not the global uniqueness.  However, this change will
        // make the possibility of the driver mis-caching a bitmap extremely
        // unlikely.
        //

        ps->iUniq(ulGetNewUniqueness(_ulGlobalSurfaceUnique));

        //
        // Now that the surface is set up, give it a handle
        //

        if (HmgInsertObject(ps, fsAlloc, SURF_TYPE) == 0)
        {
            WARNING("failed HmgInsertObject\n");

            //
            // Don't forget to decrement reference count on the palette before
            // freeing the surface
            //

            if (ps->ppal())
            {
                XEPALOBJ pal(ps->ppal());
                pal.vUnrefPalette();
                ps->ppal((PPALETTE) NULL); // Not necessary, but makes the code cleaner
            }

            FREEOBJ(ps, SURF_TYPE);
            ps = NULL;
            bRet = FALSE;
        }
        else
        {
            ps->hsurf(ps->hGet());

#if TRACE_SURFACE_ALLOCS
            if (TRACED_SURFACE::bEnabled())
            {
                TRACED_SURFACE *pts = (TRACED_SURFACE *)ps;

                RtlZeroMemory(&pts->Trace, sizeof(pts->Trace));
                pts->Trace.pProcess = PsGetCurrentProcess();
                pts->Trace.pThread = PsGetCurrentThread();
                pts->Trace.KernelLength = RtlWalkFrameChain((PVOID *)pts->Trace.Chain,
                                                           lengthof(pts->Trace.Chain),
                                                           0);
                ULONG   MaxUserLength;
                PVOID  *UserChain;
                PVOID   TmpUserChain[TRACE_SURFACE_MIN_USER_CHAIN];

                MaxUserLength = lengthof(pts->Trace.Chain) - pts->Trace.KernelLength;
                if (MaxUserLength < TRACE_SURFACE_MIN_USER_CHAIN)
                {
                    MaxUserLength = TRACE_SURFACE_MIN_USER_CHAIN;
                    UserChain = TmpUserChain;
                }
                else
                {
                    UserChain = (PVOID *)&pts->Trace.Chain[pts->Trace.KernelLength];
                }

                pts->Trace.UserLength = RtlWalkFrameChain(UserChain,
                                                          MaxUserLength,
                                                          1);

                if (UserChain == TmpUserChain && pts->Trace.UserLength != 0)
                {
                    pts->Trace.KernelLength = min(pts->Trace.KernelLength, (ULONG) lengthof(pts->Trace.Chain) - pts->Trace.UserLength);
                    RtlCopyMemory(&pts->Trace.Chain[pts->Trace.KernelLength],
                                  UserChain,
                                  pts->Trace.UserLength);
                }

#if TRACE_SURFACE_USER_CHAIN_IN_UM
                if (pts->bUMEnabled())
                {
                    SurfaceUserTrace   *pSurfUserTrace;
                    PENTRY              pentTmp;
                    UINT                uiIndex = (UINT) HmgIfromH(pts->hGet());

                    pentTmp = &gpentHmgr[uiIndex];

                    ASSERTGDI(pentTmp->pUser == NULL,
                              "SURFACE's pUser is already being used.\n");

                    pSurfUserTrace = (SurfaceUserTrace *)EngAllocUserMem(sizeof(SurfaceUserTrace), 'rTSG');

                    if (pSurfUserTrace != NULL)
                    {
                        pts->Trace.UserChainAllocated = 1;
                        pts->Trace.UserChainNotRead = 1;

                        pSurfUserTrace->MaxLength = lengthof(pSurfUserTrace->Chain);
                        pSurfUserTrace->UserLength = 0;
                        pentTmp->pUser = pSurfUserTrace;
                    }
                }
#endif
            }
#endif
        }
    }

    //
    // cleanup in failure case
    //

    if (!bRet && pvBitsIn)
    {
        if (pdbmi->fl & BMF_USERMEM)
        {
            EngFreeUserMem(pvBitsIn);
        }
        else if (flAllocateSection & BMF_KMSECTION)
        {
            vFreeKernelSection(pvBitsIn);
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* SURFMEM::~SURFMEM
*
*   Description:
*
*       SURFACE Destructor, takes appropriate action based
*       on allocation flags
*
\**************************************************************************/
SURFMEM::~SURFMEM()
{

    if (ps != (SURFACE*) NULL)
    {
        //
        // what type of surface
        //

        if (AllocationFlags & SURFACE_KEEP)
        {

            DEC_SHARE_REF_CNT(ps);

        } else {

            if (AllocationFlags & SURFACE_DIB)
            {
                //
                // free selected palette
                //

                if (ps->ppal() != NULL)
                {
                    XEPALOBJ pal(ps->ppal());
                    pal.vUnrefPalette();
                }
            }

            //
            // remove object from hmgr and free
            //

            if (!HmgRemoveObject((HOBJ) ps->hGet(), 0, 1, TRUE, SURF_TYPE))
            {
                ASSERTGDI(TRUE, "Failed to remove object in ~DIBMEMOBJ");
            }

            PVOID        pvBitsOld = ps->pvBits();
            FLONG        fl        = ps->fjBitmap();
            BOOL         bUMPD = ps->bUMPD();

            FREEOBJ(ps, SURF_TYPE);

            if (fl & BMF_USERMEM)
            {
                if (bUMPD && pvBitsOld)
                {
                    EngFreeUserMem(pvBitsOld);
                }
                else if (!bUMPD)
                {
                   RIP("SURFMEM destructor has BMF_USERMEM set\n");
                }
            }
            else if (fl & BMF_KMSECTION)
            {
                vFreeKernelSection(pvBitsOld);
            }
        }
    }
}

#if DBG
void SURFACE::vDump()
{
    DbgPrint("SURFACE @ %-#x\n", this);
    DbgPrint("    so.dhsurf        = %-#x\n"  ,   so.dhsurf);
    DbgPrint("    so.hsurf         = %-#x\n"  ,   so.hsurf);
    DbgPrint("    so.dhpdev        = %-#x\n"  ,   so.dhpdev);
    DbgPrint("    so.hdev          = %-#x\n"  ,   so.hdev);
    DbgPrint("    so.sizlBitmap    = %u %u\n" ,   so.sizlBitmap.cx , so.sizlBitmap.cy);
    DbgPrint("    so.cjBits        = %u\n"    ,   so.cjBits);
    DbgPrint("    so.pvBits        = %-#x\n"  ,   so.pvBits);
    DbgPrint("    so.pvScan0       = %-#x\n"  ,   so.pvScan0);
    DbgPrint("    so.lDelta        = %d\n"    ,   so.lDelta);
    DbgPrint("    so.iUniq         = %u\n"    ,   so.iUniq);
    DbgPrint("    so.iBitmapFormat = %u\n"    ,   so.iBitmapFormat);
    DbgPrint("    so.iType         = %u\n"    ,   so.iType);
    DbgPrint("    so.fjBitmap      = %-#x\n"  ,   so.fjBitmap);


    DbgPrint("    SurfFlags        = %-#x\n"  ,   SurfFlags);
    DbgPrint("    pPal             = %-#x\n"  ,   pPal);
    DbgPrint("    pWo              = %-#x\n"  ,   pWo);
    DbgPrint("    EBitmap.sizlDim  = %u %u\n" ,   EBitmap.sizlDim.cx, EBitmap.sizlDim.cy);
    DbgPrint("    EBitmap.hdc      = %-#x\n"  ,   EBitmap.hdc);
    DbgPrint("    EBitmap.cRef     = %-#x\n"  ,   EBitmap.cRef);
    DbgPrint("    DIB.hDIBSection  = %-#x\n"  ,   DIB.hDIBSection);
    DbgPrint("    DIB.hSecure      = %-#x\n"  ,   DIB.hSecure);

}
#endif

#if TRACE_SURFACE_ALLOCS

#define TRACE_SURFACE_KM_ENABLE_MASK    0x00000001
#define TRACE_SURFACE_UM_ENABLE_MASK    0x00000002

VOID TRACED_SURFACE::vInit()
{
    NTSTATUS    Status;
    DWORD       dwDefaultValue = 0;
    DWORD       dwEnableStack;

    // Check registry key to determine whether to enable stack traces
    // or not for SURFACE allocations
 
    RTL_QUERY_REGISTRY_TABLE QueryTable[] =
        {
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"EnableSurfaceTrace",
             &dwEnableStack, REG_DWORD, &dwDefaultValue, sizeof(dwDefaultValue)},
            {NULL, 0, NULL}
        };

    if (eTraceStatus == SURFACE_TRACING_UNINITIALIZED)
    {
        Status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                        L"GRE_Initialize",
                                        &QueryTable[0],
                                        NULL,
                                        NULL);
        if (NT_SUCCESS(Status))
        {
            if (dwEnableStack & TRACE_SURFACE_KM_ENABLE_MASK)
            {
                eTraceStatus = SURFACE_TRACING_ENABLED;
                SURFACE::tSize = sizeof(TRACED_SURFACE);

                if (dwEnableStack & TRACE_SURFACE_UM_ENABLE_MASK)
                {
#if TRACE_SURFACE_USER_CHAIN_IN_UM
                    eUMTraceStatus = SURFACE_TRACING_ENABLED;
#else
                    WARNING("GDI: UM Surface Trace requested, but not available.\n");
#endif
                }
                else
                {
#if TRACE_SURFACE_USER_CHAIN_IN_UM
                    eUMTraceStatus = SURFACE_TRACING_DISABLED;
#endif
                }
            }
            else
            {
                eTraceStatus = SURFACE_TRACING_DISABLED;
#if TRACE_SURFACE_USER_CHAIN_IN_UM
                eUMTraceStatus = SURFACE_TRACING_DISABLED;
#endif
            }
        }
    }
    else
    {
        RIP("TRACED_SURFACE::vInit: Tracing already initialized.\n");
    }
}


#if TRACE_SURFACE_USER_CHAIN_IN_UM
VOID TRACED_SURFACE::vProcessStackFromUM(
    BOOL bFreeUserMem
    )
{
    GDIFunctionID(TRACED_SURFACE::vProcessStackFromUM);

    if (Trace.UserChainAllocated)
    {
        if (Trace.UserChainNotRead || bFreeUserMem)
        {
            PENTRY  pentTmp;
            UINT    uiIndex = (UINT) HmgIfromH(hHmgr);
            ULONG   ulNewKernelLength;
            ULONG   ulMaxUserLength;
            ULONG   ulMaxLength = lengthof(Trace.Chain);

            if (uiIndex < gcMaxHmgr)
            {
                pentTmp = &gpentHmgr[uiIndex];

                if (pentTmp->pUser != NULL)
                {
                    if (Trace.UserChainNotRead)
                    {
                        SurfaceUserTrace *pUserTrace = (SurfaceUserTrace *)pentTmp->pUser;
                        __try {
                            if (pUserTrace->UserLength > 0)
                            {
                                ulMaxUserLength = min(pUserTrace->UserLength, ulMaxLength);
                                ulNewKernelLength = ulMaxLength - ulMaxUserLength;
                                if (ulNewKernelLength > Trace.KernelLength)
                                {
                                    ulNewKernelLength = Trace.KernelLength;
                                }
                                RtlCopyMemory(&Trace.Chain[ulNewKernelLength],
                                              pUserTrace->Chain,
                                              ulMaxUserLength);

                                Trace.UserLength = ulMaxUserLength;
                                Trace.UserChainNotRead = 0;
                                Trace.KernelLength = ulNewKernelLength;
                            }
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            WARNING("Couldn't read UM stored stack trace.");
                        }
                    }

                    if (bFreeUserMem)
                    {
                        Trace.UserChainAllocated = 0;
                        EngFreeUserMem(pentTmp->pUser);
                        pentTmp->pUser = NULL;
                    }
                }
                else
                {
                    RIP("Lost track of UserMem trace allocation.\n");
                    Trace.UserChainAllocated = 0;
                }
            }
        }
    }
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\textxlg.c ===
/******************************Module*Header*******************************\
* Module Name: textxlg.c
*
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#if 0

The following code assumes that the gray glyphs comming from the
font driver have DWORD aligned scans.....

/******************************Public*Routine******************************\
*
* Routine Name
*
*   draw_gray_nf_ntb_o_to_temp_start
*
* Routine Description:
*
*   The input glyphs are 4-bpp gray scale bitmaps that are DWORD aligned.
*   Specialized glyph dispatch routine for non-fixed pitch, top and
*   bottom not aligned glyphs that do overlap. This routine calculates
*   the glyph's position on the temp buffer, then determines the correct
*   highly specialized routine to be used to draw each glyph based on
*   the glyph width, alignment and rotation
*
* Arguments:
*
*   pGlyphPos               - Pointer to first in list of GLYPHPOS structs
*   cGlyph                  - Number of glyphs to draw
*   pjDst                   - Pointer to temp 4Bpp buffer to draw into
*   ulLeftEdge              - left edge of TextRect & 0xfffffff8
*                             This is equal to the position of the left
*                             edge rounded down to the nearest 32-bit
*                             aligned boundary (8 pixels / DWORD)
*   dpDst                   - Scan line Delta for TempBuffer (always pos)
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
draw_gray_nf_ntb_o_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjDst,
    ULONG           ulLeftEdge,
    ULONG           dpDst,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{
    GLYPHBITS *pgb; // pointer to current GLYPHBITS
    int x;          // pixel offset of the left edge of the glyph bitmap
                    // from the left edge of the output (4-bpp) bitmap
    int y;          // the pixel offset of the top edge of the glyph
                    // bitmap from the top edge of the output bitmap.
    GLYPHPOS *pgpOut;  // sentinel for loop
    void (*apfnGray[8])(ULONG*,ptrdiff_t,ULONG*,ULONG*,ptrdiff_t);

/**/DbgPrint(
/**/   "draw_gray_nf_ntb_o_to_temp_start(\n"
/**/   "    PGLYPHPOS       pGlyphPos  = %-#x\n"
/**/   "    ULONG           cGlyphs    = %u\n"
/**/   "    PUCHAR          pjDst      = %-#x\n"
/**/   "    ULONG           ulLeftEdge = %u\n"
/**/   "    ULONG           dpDst      = %-#x\n"
/**/   "    ULONG           ulCharInc  = %u\n"
/**/   "    ULONG           ulTempTop  = %u\n"
/**/   "     )\n"
/**/);
/**/DbgBreakPoint();

    for (pgpOut = pGlyphPos + cGlyphs; pGlyphPos < pgpOut; pGlyphPos++)
    {
        ULONG *pulSrcScan;
        ptrdiff_t dpulSrcScan;

        pgb         = pGlyphPos->pgdf->pgb;
        x           = pGlyphPos->ptl.x + pgb->ptlOrigin.x - ulLeftEdge;
        y           = pGlyphPos->ptl.y + pgb->ptlOrigin.y - ulTempTop ;
        pulSrcScan = (ULONG*) &(pgb->aj[0]);
        dpulSrcScan = (ptrdiff_t) (pgb->sizlBitmap.cx + 7)/8;
        //
        // dispatch to the appropriate function
        //
/**/    DbgPrint(
/**/        "pgb         = %-#x\n"
/**/        "x           = %d\n"
/**/        "y           = %d\n"
/**/        "pulSrcScan  = %-#x\n"
/**/        "dpulSrcScan = %u = %-#x\n"
/**/      , pgb
/**/      , x
/**/      , y
/**/      , pulSrcScan
/**/      , dpulSrcScan
/**/    );
/**/    DbgBreakPoint();
        (*apfnGray[x & 0x07]) (
            pulSrcScan                                                 ,
            dpulSrcScan                                                ,
            pulSrcScan + dpulSrcScan * (unsigned) pgb->sizlBitmap.cy   ,
            (ULONG*) (pjDst + y * dpDst) + ( x / 8)                    ,
            (ptrdiff_t) dpDst / sizeof(ULONG)
        );
    }
}

void
vOrShiftGrayGlyph0(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            *pulDst |= *pulSrc;
        }
    }
}


void
vOrShiftGrayGlyph2(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        ULONG b = 0;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            ULONG a = *pulSrc;

            *pulDst |= (a << 4*2) + (b >> (32-4*2));
            b = a;
        }
    }
}


void
vOrShiftGrayGlyph4(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        ULONG b = 0;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            ULONG a = *pulSrc;

            *pulDst |= (a << 4*4) + (b >> (32-4*4));
            b = a;
        }
    }
}

void
vOrShiftGrayGlyph6(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        ULONG b = 0;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            ULONG a = *pulSrc;

            *pulDst |= (a << 4*6) + (b >> (32-4*6));
            b = a;
        }
    }
}

#define MASK_0 0x0f0f0f0f
#define MASK_1 0xf0f0f0f0

void
vOrShiftGrayGlyph1(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        ULONG b = 0;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            ULONG u;
            ULONG a = *pulSrc;

            u  = (a & MASK_0) << 12;
            u |= (b & MASK_0) >> 20;
            u |= (a & MASK_1) >>  4;
            u |= (b & MASK_1) << 28;
            *pulDst = u;
            b = a;
        }
    }
}


void
vOrShiftGrayGlyph3(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        ULONG b = 0;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            ULONG u;
            ULONG a = *pulSrc;

            u  = (a & MASK_0) << 20;
            u |= (b & MASK_0) >> 12;
            u |= (a & 0x00f0f0f0) <<  4;
            u |= (b & MASK_1) >> 28;
            *pulDst = u;
            b = a;
        }
    }
}

void
vOrShiftGrayGlyph5(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        ULONG b = 0;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            ULONG u;
            ULONG a = *pulSrc;

            u  = (a & MASK_0) << 28;
            u |= (b & MASK_0) >>  4;
            u |= (a & MASK_1) <<  4;
            u |= (b & MASK_1) >> 28;
            *pulDst = u;
            b = a;
        }
    }
}

void
vOrShiftGrayGlyph7(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        ULONG b = 0;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            ULONG u;
            ULONG a = *pulSrc;

            u  = (a & MASK_0) >> 28;
            u |= (b & MASK_0) <<  4;
            u |= (a & MASK_1) << 20;
            u |= (b & MASK_1) >> 12;
            *pulDst = u;
            b = a;
        }
    }
}

void (*apfnGray[8])(ULONG*,ptrdiff_t,ULONG*,ULONG*,ptrdiff_t) =
{
    vOrShiftGrayGlyph0
   ,vOrShiftGrayGlyph1
   ,vOrShiftGrayGlyph2
   ,vOrShiftGrayGlyph3
   ,vOrShiftGrayGlyph4
   ,vOrShiftGrayGlyph5
   ,vOrShiftGrayGlyph6
   ,vOrShiftGrayGlyph7
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\timer.cxx ===
/******************************Module*Header*******************************\
* Module Name: timer.cxx
*
* For profiling
*
* Warning!
*
*       In its present form, this profiler will work only for single
*       threads of execution.
*
* Created: 13-Oct-1994 10:01:42
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1994-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

#if DBG

FLONG  TIMER::fl               = 0; // set 0'th bit to start timing
char  *TIMER::pszRecordingFile = 0; // set to "c:\timer.txt" or whatever
TIMER *TIMER::pCurrent         = 0; // don't change this

/******************************Member*Function*****************************\
* TIMER::TIMER                                                             *
*                                                                          *
* History:                                                                 *
*  Fri 14-Oct-1994 06:59:29 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

TIMER::TIMER(char *psz_)
{
    if (fl & TIMER_MEASURE) {
        psz      = psz_;
        pParent  = pCurrent;
        pCurrent = this;
        NtQuerySystemTime((LARGE_INTEGER*)&llTick);
    }
}

/******************************Member*Function*****************************\
* TIMER::~TIMER                                                            *
*                                                                          *
* History:                                                                 *
*  Fri 14-Oct-1994 06:59:08 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

TIMER::~TIMER()
{
    if (fl & TIMER_MEASURE)  {
        if (psz)  {
            TIMER *p;
            CHAR ach[200];
            LONGLONG ll;
            NtQuerySystemTime((LARGE_INTEGER*)&ll);

            // calculate the difference in 0.1 microsecond units

            ll -= llTick;

            // print the lowest 32 bits of ll -- this limits
            // function calls to less than 429 seconds
            // this time is placed on the far left of the screen

            DbgPrint("%7u\t", (unsigned) ll / 100);
            // CHAR *pch = ach + wsprintfA(ach, "%7u\t", (unsigned) ll / 100);

            // indent one space for each parent that you have

            for (p = pParent; p; p = p->pParent)
                DbgPrint(" ");
                //*pch++ = ' ';

            // write the string after the indentation

            DbgPrint(psz);
            //pch += wsprintf(pch, "%s\n", psz);


            // always write the result to the debugging screen

            // DbgPrint("%s", ach);

            // if a recording file has been specified then append
            // the same string at the end of that file

            if (pszRecordingFile) {
                HANDLE hf;

                ASSERTGDI(FALSE, "Timer Recording File broken for now\n");

            //    if  (
            //        hf =
            //            CreateFileA(
            //                pszRecordingFile
            //            ,   GENERIC_WRITE
            //            ,   0
            //            ,   0
            //            ,   OPEN_ALWAYS
            //            ,   FILE_ATTRIBUTE_NORMAL
            //            ,   0
            //            )
            //    )  {
            //        LONG l = 0;
            //        SetFilePointer(hf, 0, &l, FILE_END);
            //        WriteFile(hf, ach, pch - ach, (DWORD*) &l, 0);
            //        CloseHandle(hf);
            //    }
            }
            // before this TIMER dies, change the current pointer
            // back to the parent

            pCurrent = pParent;

            // Put the parent TIMER's to sleep during the time that
            // this TIMER was in scope.
            // unfortunately this does not compensate the parents
            // for the this last little bit of copying .. oh well

            NtQuerySystemTime((LARGE_INTEGER*)&ll);
            ll -= llTick;
            for (p = pParent; p; p = p->pParent)
                p->llTick += ll;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\tranblt.cxx ===
/******************************Module*Header*******************************\
* Module Name: transblt.cxx
*
* Transparent BLT
*
* Created: 08-Nov-96
* Author: Lingyun Wang [lingyunw]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

VOID vTransparentCopy (PBLTINFO psb);

VOID vTransparentCopyS4D8 (PBLTINFO psb);
VOID vTransparentCopyS4D16 (PBLTINFO psb);
VOID vTransparentCopyS4D24 (PBLTINFO psb);
VOID vTransparentCopyS4D32 (PBLTINFO psb);

VOID vTransparentCopyS8D8Identity (PBLTINFO psb);
VOID vTransparentCopyS8D8 (PBLTINFO psb);
VOID vTransparentCopyS8D16 (PBLTINFO psb);
VOID vTransparentCopyS8D24 (PBLTINFO psb);
VOID vTransparentCopyS8D32 (PBLTINFO psb);

VOID vTransparentCopyS16D16Identity (PBLTINFO psb);
VOID vTransparentCopyS16D8 (PBLTINFO psb);
VOID vTransparentCopyS16D16 (PBLTINFO psb);
VOID vTransparentCopyS16D24 (PBLTINFO psb);
VOID vTransparentCopyS16D32 (PBLTINFO psb);

VOID vTransparentCopyS24D24Identity (PBLTINFO psb);
VOID vTransparentCopyS24D8 (PBLTINFO psb);
VOID vTransparentCopyS24D16 (PBLTINFO psb);
VOID vTransparentCopyS24D24 (PBLTINFO psb);
VOID vTransparentCopyS24D32 (PBLTINFO psb);

VOID vTransparentCopyS32D32Identity (PBLTINFO psb);
VOID vTransparentCopyS32D8 (PBLTINFO psb);
VOID vTransparentCopyS32D16 (PBLTINFO psb);
VOID vTransparentCopyS32D24 (PBLTINFO psb);
VOID vTransparentCopyS32D32 (PBLTINFO psb);


typedef VOID  (*PFN_TRANSPARENT)(PBLTINFO);

//
// Note:  if we ever want to reduce the amount of code we generate, we
//        can replace rarely used functions below with vTransparentCopy
//        (the general case function) and the linker should be smart
//        enough not to generate the unused code.  This will reduce
//        performance by roughly 5-15% (more in the no color translation
//        cases).
//
//        For now, we will not generate special code for 1BPP sources
//        and destinations
//

PFN_TRANSPARENT TransFunctionTable [6][7] = {
    vTransparentCopy, // 1BPP Source
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopy, // 4BPP Source
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopyS4D8,
    vTransparentCopyS4D16,
    vTransparentCopyS4D24,
    vTransparentCopyS4D32,
    vTransparentCopyS8D8Identity, // 8BPP Source
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopyS8D8,
    vTransparentCopyS8D16,
    vTransparentCopyS8D24,
    vTransparentCopyS8D32,
    vTransparentCopyS16D16Identity, // 16BPP Source
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopyS16D8,
    vTransparentCopyS16D16,
    vTransparentCopyS16D24,
    vTransparentCopyS16D32,
    vTransparentCopyS24D24Identity, // 24BPP Source
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopyS24D8,
    vTransparentCopyS24D16,
    vTransparentCopyS24D24,
    vTransparentCopyS24D32,
    vTransparentCopyS32D32Identity, // 32BPP Source
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopyS32D8,
    vTransparentCopyS32D16,
    vTransparentCopyS32D24,
    vTransparentCopyS32D32
};



BOOL
GreTransparentBltPS(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      TransColor
);

/******************************Public*Routine******************************\
* StartPixel
*    Given a scanline pointer and position of a pixel, return the byte address
* of where the pixel is at depending on the format
*
* History:
*  2-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
PBYTE StartPixel (
    PBYTE pjBits,
    ULONG xStart,
    ULONG iBitmapFormat
)
{
   PBYTE pjStart = pjBits;
    //
    // getting the starting pixel
    //
    switch (iBitmapFormat)
    {
      case BMF_1BPP:
          pjStart = pjBits + (xStart >> 3);
          break;

       case BMF_4BPP:
          pjStart = pjBits + (xStart >> 1);
          break;

       case BMF_8BPP:
          pjStart = pjBits + xStart;
          break;

       case BMF_16BPP:
          pjStart = pjBits + 2*xStart;
          break;

       case BMF_24BPP:
          pjStart = pjBits + 3*xStart;
          break;

       case BMF_32BPP:
          pjStart = pjBits+4*xStart;
          break;

       default:
           WARNING ("Startpixel -- bad iFormatSrc\n");
    }

    return (pjStart);
}


/******************************Public*Routine******************************\
* vTransparentCopy
*     Does the gerneral transparent copy between 1,4,8,16,24,32 bit formats
*
*     Note:
*     performance can be improved by breaking this routine into many
*     dealing with different format so that we can save two comparsions
*     for each pixel operation.  Working set size will be large
*
*
* History:
*  15-Nov-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentCopy (PBLTINFO psb)
{
    // We assume we are doing left to right top to bottom blting.
    // If it was on the same surface it would be the identity case.

    ASSERTGDI(psb->xDir == 1, "vTransparentCopy - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vTransparentCopy - direction not up to down");

    // These are our holding variables

    PBYTE  pjSrc;
    PBYTE  pjDst;
    ULONG  cx     = psb->cx;
    ULONG  cy     = psb->cy;
    XLATE  *pxlo  = psb->pxlo;
    PBYTE  pjSrcTemp;
    PBYTE  pjDstTemp;
    ULONG  cxTemp;
    INT    iPosSrc, iPosDst;
    PULONG pulXlate = psb->pxlo->pulXlate;
    BYTE   jDst, jSrc;
    ULONG ulDst;
    ULONG ulSrc;
    BYTE jDstMask1[] = {0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe};
    BYTE jDstMask4[] = {0x00, 0xf0};
    
    // We should never have got to this point with cx or 
    // cy zero, since there should be a check for empty rectangles 
    // before we get here 

    ASSERTGDI( cx != 0 && cy != 0,"vTransparentCopy - called with an empty rectangle"); 

    // used for 16bpp and 32bpp only
    XEPALOBJ palSrc(psb->pdioSrc->ppal()); 
    FLONG flcolMask = palSrc.bValid() ? (palSrc.flRed() | 
                     palSrc.flGre() | 
                     palSrc.flBlu()) : 0xFFFFFFFF;

    pjSrc = StartPixel (psb->pjSrc, psb->xSrcStart, psb->iFormatSrc);
    pjDst = StartPixel (psb->pjDst, psb->xDstStart, psb->iFormatDst);

    while(cy--)
    {
        pjSrcTemp  = pjSrc;
        pjDstTemp  = pjDst;
        cxTemp     = cx;

        iPosSrc = psb->xSrcStart;
        iPosDst = psb->xDstStart;

        if( psb->iFormatSrc == BMF_1BPP )
        {
            if (!(iPosSrc & 0x00000007))
            {
                // Decrement since we'll get incremented again 
                // right at the begining of this case in the 
                // switch statement.
                pjSrcTemp--;
            }
            else
            {
                jSrc = *pjSrcTemp << (iPosSrc & 0x7); 
            }
        }

        // jDst is used only by 1BPP and 4BPP destinations.  Need to get the correct
        // initial value for left boundary condition.
        if (psb->iFormatDst == BMF_1BPP)
        {
            jDst = *pjDstTemp & jDstMask1[iPosDst & 0x7];
        }
        else if (psb->iFormatDst == BMF_4BPP)
        {
            jDst = *pjDstTemp & jDstMask4[iPosDst & 0x1];
        }


        while (cxTemp--)
        {
            //
            // get a pixel from source and put it in ulSrc
            // move down one pixel
            //
            switch (psb->iFormatSrc)
            {
            case BMF_32BPP:
                ulSrc = *(PULONG)(pjSrcTemp) & flcolMask;
                pjSrcTemp +=4;
                break;

            case BMF_24BPP:
                ulSrc = *(pjSrcTemp + 2);
                ulSrc = ulSrc << 8;
                ulSrc |= (ULONG) *(pjSrcTemp + 1);
                ulSrc = ulSrc << 8;
                ulSrc |= (ULONG) *pjSrcTemp;
                pjSrcTemp += 3;
                break;

            case BMF_16BPP:
                ulSrc = (ULONG) *((PUSHORT)pjSrcTemp) & flcolMask;
                pjSrcTemp += 2;
                break;

            case BMF_8BPP:
                ulSrc = (ULONG) *pjSrcTemp;
                pjSrcTemp++;
                break;

            case BMF_4BPP:
                if (iPosSrc & 0x00000001)
                {
                    ulSrc = *pjSrcTemp & 0x0F;
                    pjSrcTemp++;
                }
                else
                {
                    ulSrc = (*pjSrcTemp & 0xF0)>>4;
                }

                iPosSrc++;
                break;

            case BMF_1BPP:
                if (!(iPosSrc & 0x00000007))
                {
                    pjSrcTemp++;
                    jSrc = *pjSrcTemp;
                }

                ulSrc = (ULONG)(jSrc & 0x80);
                ulSrc >>= 7;
                jSrc <<= 1;

                iPosSrc++;

                break;

            default:
                WARNING ("vTransparentCopy -- bad iFormatSrc\n");
                return ;

            } /*switch*/

            //
            // put one pixel in the dest
            //
            switch (psb->iFormatDst)
            {
            case BMF_32BPP:
                if (ulSrc != psb->TransparentColor)
                {
                    *(PULONG)pjDstTemp = pxlo->ulTranslate(ulSrc);
                }
                pjDstTemp += 4;
                break;

            case BMF_24BPP:
                if (ulSrc != psb->TransparentColor)
                {
                    ulDst = pxlo->ulTranslate(ulSrc);
                    *(pjDstTemp) = (BYTE) ulDst;
                    *(pjDstTemp + 1) = (BYTE) (ulDst >> 8);
                    *(pjDstTemp + 2) = (BYTE) (ulDst >> 16);
                }
                pjDstTemp += 3;
                break;

            case BMF_16BPP:
                if (ulSrc != psb->TransparentColor)
                    *(PUSHORT)pjDstTemp = (USHORT)pxlo->ulTranslate(ulSrc);

                pjDstTemp += 2;
                break;

            case BMF_8BPP:
                if (ulSrc != psb->TransparentColor)
                    *pjDstTemp = (BYTE)pxlo->ulTranslate(ulSrc);

                pjDstTemp++;
                break;

            case BMF_4BPP:
                if (iPosDst & 0x00000001)
                {
                    if (ulSrc != psb->TransparentColor)
                    {
                        jDst |= (BYTE)pxlo->ulTranslate(ulSrc);
                    }
                    else
                    {
                        jDst |= *pjDstTemp & 0x0F;
                    }

                    *pjDstTemp++ = jDst;
                }
                else
                {
                    if (ulSrc != psb->TransparentColor)
                    {
                        jDst = (BYTE)pxlo->ulTranslate(ulSrc) << 4;
                    }
                    else
                    {
                        jDst = *pjDstTemp & 0xF0;
                    }
                }

                iPosDst++;
                break;


            case BMF_1BPP:
                if (ulSrc != psb->TransparentColor)
                {
                    jDst |= pxlo->ulTranslate(ulSrc)<<7;
                }
                else
                {
                    jDst |= (*pjDstTemp << (iPosDst & 0x7)) & 0x80;
                }
                iPosDst++;

                if (!(iPosDst & 0x00000007) )
                {
                    *pjDstTemp++ = jDst;
                    jDst = 0;
                }
                else
                {
                    jDst >>= 1;
                }

                break;

            default:
                WARNING ("vTransparentCopy -- bad iFormatDst\n");
                return;
            }
        }

        // The boundary condition on the right
        if (psb->iFormatDst == BMF_1BPP)
        {
            if (iPosDst & 0x7)
            {
                BYTE mask = jDstMask1[iPosDst & 0x7];;
                *pjDstTemp = ((*pjDstTemp & (~mask)) | (jDst & mask));
            }
        }
        else if (psb->iFormatDst == BMF_4BPP)
        {
            if (iPosDst & 0x1)
            {
                BYTE mask = jDstMask4[iPosDst & 0x1];
                *pjDstTemp = ((*pjDstTemp & (~mask)) | (jDst & mask));
            }
        }

        pjSrc = pjSrc + psb->lDeltaSrc;
        pjDst = pjDst + psb->lDeltaDst;
    }
}

/**************************************************************************\
 *
 * Macro Generation Framework:
 *
 *   We use specialized functions to do the transparent blit from every
 *   source format to every target format.  In order to minimize typing
 *   errors, these are automatically generated using macros.  Here is
 *   the general structure of the vTransparentCopy Routines:
 *
 *   TC_START_TRANSPARENT_COPY(name)
 *   TC_INIT_PJSRC_[1,4,8,16,24,32]BPP
 *   TC_INIT_PJDST_[1,4,8,16,24,32]BPP
 *   TC_START_LOOP
 *   TC_GET_SRC_[1,4,8,16,24,32]BPP
 *   TC_PUT_DST_[1,4,8,16,24,32]BPP
 *   TC_FINISH
 *
 *   Note that in order to simplify boundary cases, we don't generate optimized
 *   code for 1BPP sources and destination, and 4BPP destinations.  This is OK
 *   because those cases are not very common.
 *
 * History:
 *  14-Aug-1997 -by- Ori Gershony [orig]
 * Wrote it.
 *
\**************************************************************************/

//
// Function declaration and variable declaration
//
#define TC_START_TRANSPARENT_COPY_PFNXLATE(name)                                \
VOID name (PBLTINFO psb)                                                        \
{                                                                               \
    ASSERTGDI(psb->xDir == 1,"vTransparentCopy - direction not left to right"); \
    ASSERTGDI(psb->yDir == 1,"vTransparentCopy - direction not up to down");    \
                                                                                \
    PBYTE  pjSrc;                                                               \
    PBYTE  pjDst;                                                               \
    ULONG  cx     = psb->cx;                                                    \
    ULONG  cy     = psb->cy;                                                    \
    XLATE  *pxlo  = psb->pxlo;                                                  \
    PBYTE  pjSrcTemp;                                                           \
    PBYTE  pjDstTemp;                                                           \
    ULONG  cxTemp;                                                              \
    INT    iPosSrc, iPosDst;                                                    \
    PULONG pulXlate = psb->pxlo->pulXlate;                                      \
    PFN_pfnXlate pfnXlate = pxlo->pfnXlateBetweenBitfields();                   \
    BYTE   jDst = 0, jSrc;                                                      \
    ULONG ulDst;                                                                \
    ULONG ulSrc;

#define TC_START_TRANSPARENT_COPY(name)                                   \
VOID name (PBLTINFO psb)                                                        \
{                                                                               \
    ASSERTGDI(psb->xDir == 1,"vTransparentCopy - direction not left to right"); \
    ASSERTGDI(psb->yDir == 1,"vTransparentCopy - direction not up to down");    \
                                                                                \
    PBYTE  pjSrc;                                                               \
    PBYTE  pjDst;                                                               \
    ULONG  cx     = psb->cx;                                                    \
    ULONG  cy     = psb->cy;                                                    \
    XLATE  *pxlo  = psb->pxlo;                                                  \
    PBYTE  pjSrcTemp;                                                           \
    PBYTE  pjDstTemp;                                                           \
    ULONG  cxTemp;                                                              \
    INT    iPosSrc, iPosDst;                                                    \
    PULONG pulXlate = psb->pxlo->pulXlate;                                      \
    BYTE   jDst = 0, jSrc;                                                      \
    ULONG ulDst;                                                                \
    ULONG ulSrc;

//
//  Initialize pjSrc based on source format
//
#define TC_INIT_PJSRC_4BPP \
    pjSrc = psb->pjSrc + (psb->xSrcStart >> 1);

#define TC_INIT_PJSRC_8BPP \
    pjSrc = psb->pjSrc + psb->xSrcStart;

#define TC_INIT_PJSRC_16BPP \
    XEPALOBJ palSrc(psb->pdioSrc->ppal()); \
    FLONG flcolMask = palSrc.bValid() ? (palSrc.flRed() | \
                                         palSrc.flGre() | \
                                         palSrc.flBlu()) : \
                                        0xFFFF; \
    pjSrc = psb->pjSrc + (psb->xSrcStart * 2);

#define TC_INIT_PJSRC_24BPP \
    pjSrc = psb->pjSrc + (psb->xSrcStart * 3);

#define TC_INIT_PJSRC_32BPP \
    XEPALOBJ palSrc(psb->pdioSrc->ppal()); \
    FLONG flcolMask = palSrc.bValid() ? (palSrc.flRed() | \
                                         palSrc.flGre() | \
                                         palSrc.flBlu()) : \
                                        0xFFFFFFFF; \
    pjSrc = psb->pjSrc + (psb->xSrcStart * 4);


//
//  Initialize pjDst based on destination format
//
#define TC_INIT_PJDST_8BPP \
    pjDst = psb->pjDst + psb->xDstStart;

#define TC_INIT_PJDST_16BPP \
    pjDst = psb->pjDst + (psb->xDstStart * 2);

#define TC_INIT_PJDST_24BPP \
    pjDst = psb->pjDst + (psb->xDstStart * 3);

#define TC_INIT_PJDST_32BPP \
    pjDst = psb->pjDst + (psb->xDstStart * 4);



//
// The loop upto the first switch statement
//
#define TC_START_LOOP              \
    while(cy--)                    \
    {                              \
        pjSrcTemp  = pjSrc;        \
        pjDstTemp  = pjDst;        \
        cxTemp     = cx;           \
                                   \
        iPosSrc = psb->xSrcStart;  \
        iPosDst = psb->xDstStart;  \
                                   \
        while (cxTemp--)           \
        {


//
// Get the source pixel
//
#define TC_GET_SRC_4BPP                    \
    if (iPosSrc & 0x00000001)              \
    {                                      \
        ulSrc = *pjSrcTemp & 0x0F;         \
        pjSrcTemp++;                       \
    }                                      \
    else                                   \
    {                                      \
        ulSrc = (*pjSrcTemp & 0xF0)>>4;    \
    }                                      \
    iPosSrc++;

#define TC_GET_SRC_8BPP                    \
    ulSrc = (ULONG) *pjSrcTemp;            \
    pjSrcTemp++;

#define TC_GET_SRC_16BPP                                \
    ulSrc = (ULONG) *((PUSHORT)pjSrcTemp) & flcolMask;  \
    pjSrcTemp += 2;

#define TC_GET_SRC_24BPP                   \
    ulSrc = *(pjSrcTemp + 2);              \
    ulSrc = ulSrc << 8;                    \
    ulSrc |= (ULONG) *(pjSrcTemp + 1);     \
    ulSrc = ulSrc << 8;                    \
    ulSrc |= (ULONG) *pjSrcTemp;           \
    pjSrcTemp += 3;

#define TC_GET_SRC_32BPP                                \
    ulSrc = *(PULONG)(pjSrcTemp) & flcolMask;          \
    pjSrcTemp +=4;


//
// Put the destination pixel (color translation version)
//

#define TC_PUT_DST_8BPP(A)                           \
    if (ulSrc != psb->TransparentColor)              \
        *pjDstTemp = (BYTE) A;                       \
    pjDstTemp++;

#define TC_PUT_DST_16BPP(A)                          \
    if (ulSrc != psb->TransparentColor)              \
        *(PUSHORT)pjDstTemp = (USHORT) A;            \
    pjDstTemp += 2;

#define TC_PUT_DST_24BPP(A)                          \
    if (ulSrc != psb->TransparentColor)              \
    {                                                \
        ulDst = A;                                   \
        *(pjDstTemp) = (BYTE) ulDst;                 \
        *(pjDstTemp + 1) = (BYTE) (ulDst >> 8);      \
        *(pjDstTemp + 2) = (BYTE) (ulDst >> 16);     \
    }                                                \
    pjDstTemp += 3;

#define TC_PUT_DST_32BPP(A)                          \
    if (ulSrc != psb->TransparentColor)              \
    {                                                \
        *(PULONG)pjDstTemp = A;                      \
    }                                                \
    pjDstTemp += 4;



//
// Put the destination pixel (no color translation)
//

#define TC_PUT_DST_IDENT_8BPP                        \
    if (ulSrc != psb->TransparentColor)              \
        *pjDstTemp = (BYTE) ulSrc;                   \
    pjDstTemp++;

#define TC_PUT_DST_IDENT_16BPP                       \
    if (ulSrc != psb->TransparentColor)              \
        *(PUSHORT)pjDstTemp = (USHORT) ulSrc;        \
    pjDstTemp += 2;

#define TC_PUT_DST_IDENT_24BPP                       \
    if (ulSrc != psb->TransparentColor)              \
    {                                                \
        ulDst = ulSrc;                               \
        *(pjDstTemp) = (BYTE) ulDst;               \
        *(pjDstTemp + 1) = (BYTE) (ulDst >> 8);        \
        *(pjDstTemp + 2) = (BYTE) (ulDst >> 16);       \
    }                                                \
    pjDstTemp += 3;

#define TC_PUT_DST_IDENT_32BPP                       \
    if (ulSrc != psb->TransparentColor)              \
    {                                                \
        *(PULONG)pjDstTemp = ulSrc;                  \
    }                                                \
    pjDstTemp += 4;




//
// The rest of the function:
//
#define TC_FINISH                                    \
         } pjSrc = pjSrc + psb->lDeltaSrc;           \
         pjDst = pjDst + psb->lDeltaDst;             \
    }                                                \
}





/******************************Public*Routine******************************\
* vTransparentS4Dxx
*
*     Does the transparent copy from a 4BPP source
*
* History:
*  14-Aug-1997 -by- Ori Gershony [orig]
* Wrote it.
\**************************************************************************/

TC_START_TRANSPARENT_COPY(vTransparentCopyS4D8)
TC_INIT_PJSRC_4BPP
TC_INIT_PJDST_8BPP
TC_START_LOOP
TC_GET_SRC_4BPP
TC_PUT_DST_8BPP(pulXlate[ulSrc])
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS4D16)
TC_INIT_PJSRC_4BPP
TC_INIT_PJDST_16BPP
TC_START_LOOP
TC_GET_SRC_4BPP
TC_PUT_DST_16BPP(pulXlate[ulSrc])
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS4D24)
TC_INIT_PJSRC_4BPP
TC_INIT_PJDST_24BPP
TC_START_LOOP
TC_GET_SRC_4BPP
TC_PUT_DST_24BPP(pulXlate[ulSrc])
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS4D32)
TC_INIT_PJSRC_4BPP
TC_INIT_PJDST_32BPP
TC_START_LOOP
TC_GET_SRC_4BPP
TC_PUT_DST_32BPP(pulXlate[ulSrc])
TC_FINISH







/******************************Public*Routine******************************\
* vTransparentS8Dxx
*
*     Does the transparent copy from a 8BPP source
*
* History:
*  14-Aug-1997 -by- Ori Gershony [orig]
* Wrote it.
\**************************************************************************/

TC_START_TRANSPARENT_COPY(vTransparentCopyS8D8Identity)
TC_INIT_PJSRC_8BPP
TC_INIT_PJDST_8BPP
TC_START_LOOP
TC_GET_SRC_8BPP
TC_PUT_DST_IDENT_8BPP
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS8D8)
TC_INIT_PJSRC_8BPP
TC_INIT_PJDST_8BPP
TC_START_LOOP
TC_GET_SRC_8BPP
TC_PUT_DST_8BPP(pulXlate[ulSrc])
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS8D16)
TC_INIT_PJSRC_8BPP
TC_INIT_PJDST_16BPP
TC_START_LOOP
TC_GET_SRC_8BPP
TC_PUT_DST_16BPP(pulXlate[ulSrc])
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS8D24)
TC_INIT_PJSRC_8BPP
TC_INIT_PJDST_24BPP
TC_START_LOOP
TC_GET_SRC_8BPP
TC_PUT_DST_24BPP(pulXlate[ulSrc])
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS8D32)
TC_INIT_PJSRC_8BPP
TC_INIT_PJDST_32BPP
TC_START_LOOP
TC_GET_SRC_8BPP
TC_PUT_DST_32BPP(pulXlate[ulSrc])
TC_FINISH






/******************************Public*Routine******************************\
* vTransparentS16Dxx
*
*     Does the transparent copy from a 16BPP source
*
* History:
*  14-Aug-1997 -by- Ori Gershony [orig]
* Wrote it.
\**************************************************************************/

TC_START_TRANSPARENT_COPY(vTransparentCopyS16D16Identity)
TC_INIT_PJSRC_16BPP
TC_INIT_PJDST_16BPP
TC_START_LOOP
TC_GET_SRC_16BPP
TC_PUT_DST_IDENT_16BPP
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS16D8)
TC_INIT_PJSRC_16BPP
TC_INIT_PJDST_8BPP
TC_START_LOOP
TC_GET_SRC_16BPP
TC_PUT_DST_8BPP(pxlo->ulTranslate(ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS16D16)
TC_INIT_PJSRC_16BPP
TC_INIT_PJDST_16BPP
TC_START_LOOP
TC_GET_SRC_16BPP
TC_PUT_DST_16BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS16D24)
TC_INIT_PJSRC_16BPP
TC_INIT_PJDST_24BPP
TC_START_LOOP
TC_GET_SRC_16BPP
TC_PUT_DST_24BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS16D32)
TC_INIT_PJSRC_16BPP
TC_INIT_PJDST_32BPP
TC_START_LOOP
TC_GET_SRC_16BPP
TC_PUT_DST_32BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH





/******************************Public*Routine******************************\
* vTransparentS24Dxx
*
*     Does the transparent copy from a 24BPP source
*
* History:
*  14-Aug-1997 -by- Ori Gershony [orig]
* Wrote it.
\**************************************************************************/

TC_START_TRANSPARENT_COPY(vTransparentCopyS24D24Identity)
TC_INIT_PJSRC_24BPP
TC_INIT_PJDST_24BPP
TC_START_LOOP
TC_GET_SRC_24BPP
TC_PUT_DST_IDENT_24BPP
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS24D8)
TC_INIT_PJSRC_24BPP
TC_INIT_PJDST_8BPP
TC_START_LOOP
TC_GET_SRC_24BPP
TC_PUT_DST_8BPP(pxlo->ulTranslate(ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS24D16)
TC_INIT_PJSRC_24BPP
TC_INIT_PJDST_16BPP
TC_START_LOOP
TC_GET_SRC_24BPP
TC_PUT_DST_16BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS24D24)
TC_INIT_PJSRC_24BPP
TC_INIT_PJDST_24BPP
TC_START_LOOP
TC_GET_SRC_24BPP
TC_PUT_DST_24BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS24D32)
TC_INIT_PJSRC_24BPP
TC_INIT_PJDST_32BPP
TC_START_LOOP
TC_GET_SRC_24BPP
TC_PUT_DST_32BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH





/******************************Public*Routine******************************\
* vTransparentS32Dxx
*
*     Does the transparent copy from a 32BPP source
*
* History:
*  14-Aug-1997 -by- Ori Gershony [orig]
* Wrote it.
\**************************************************************************/

TC_START_TRANSPARENT_COPY(vTransparentCopyS32D32Identity)
TC_INIT_PJSRC_32BPP
TC_INIT_PJDST_32BPP
TC_START_LOOP
TC_GET_SRC_32BPP
TC_PUT_DST_IDENT_32BPP
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS32D8)
TC_INIT_PJSRC_32BPP
TC_INIT_PJDST_8BPP
TC_START_LOOP
TC_GET_SRC_32BPP
TC_PUT_DST_8BPP(pxlo->ulTranslate(ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS32D16)
TC_INIT_PJSRC_32BPP
TC_INIT_PJDST_16BPP
TC_START_LOOP
TC_GET_SRC_32BPP
TC_PUT_DST_16BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS32D24)
TC_INIT_PJSRC_32BPP
TC_INIT_PJDST_24BPP
TC_START_LOOP
TC_GET_SRC_32BPP
TC_PUT_DST_24BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS32D32)
TC_INIT_PJSRC_32BPP
TC_INIT_PJDST_32BPP
TC_START_LOOP
TC_GET_SRC_32BPP
TC_PUT_DST_32BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH




/******************************Public*Routine******************************\
* EngTransparentBlt
*
*    Sets up for a transparent blt from <psoSrc> to <psoDst> with TransColor.
*    The actual copying of the bits is performed by a function call.
*
\**************************************************************************/

BOOL
EngTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      TransColor,
    ULONG      bCalledFromBitBlt    // Officially, this is 'ulReserved' and
                                    //   should always be set to zero.  But
                                    //   for the purposes of our 'ccaa' trick
                                    //   below, we use it for some private
                                    //   communication within GDI.  If this
                                    //   field needs to be used for something
                                    //   else in the future, GDI can communicate
                                    //   via some other mechanism.  (That is,
                                    //   feel free to use this field for something
                                    //   else in the future.)
)
{
    ASSERTGDI(psoDst != NULL, "ERROR EngTransparentBlt:  No Dst. Object");
    ASSERTGDI(psoSrc != NULL, "ERROR EngTransparentBlt:  No Src. Object");
    ASSERTGDI(prclDst != (PRECTL) NULL,  "ERROR EngTransparentBlt:  No Target Rect.");
    ASSERTGDI(prclDst->left < prclDst->right, "ERROR EngTransparentBlt left < right");
    ASSERTGDI(prclDst->top < prclDst->bottom, "ERROR EngTransparentBlt top < bottom");

    if ((psoDst->iType != STYPE_BITMAP) || (psoSrc->iType != STYPE_BITMAP))
    {
        //
        // Performance is horrible and disgusting when the driver doesn't hook
        // DrvTransparentBlt and we can't directly access the bits.  As a work-
        // around for this problem, we piggy-back on DrvBitBlt: we know that when
        // the driver sees a weird ROP, it will turn around and call EngBitBlt,
        // with STYPE_BITMAP surfaces.  Then in EngBitBlt, we catch that case and
        // route it back here.  In this way we can cheaply get direct
        // access to the bits.
        //
        // Note that to avoid endlessly recursive calls (like with the VGA driver 
        // when the destination is a DIB and the source is a device bitmap), we
        // terminate the loop via 'bCalledFromBitBlt':

        if (!(bCalledFromBitBlt) &&
            ((prclDst->right - prclDst->left) == (prclSrc->right - prclSrc->left)) &&
            ((prclDst->bottom - prclDst->top) == (prclSrc->bottom - prclSrc->top)))
        {
            BRUSHOBJ bo;

            PDEVOBJ po(psoDst->hdev != NULL ? psoDst->hdev : psoSrc->hdev);

            bo.iSolidColor = TransColor;
            bo.flColorType = 0;
            bo.pvRbrush = NULL;

            return(PPFNDRV(po, BitBlt)(psoDst, psoSrc, NULL, pco, pxlo, prclDst, 
                                       (POINTL*) prclSrc, NULL, &bo, NULL, 0xccaa));
        }
    }

    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);
    PSURFACE pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);

    //
    // Make sure we psSetupTransparentSrcSurface doesn't modify caller's rectangles
    //

    RECTL rclDstWk = *prclDst;
    RECTL rclSrcWk = *prclSrc;
    prclDst = &rclDstWk;
    prclSrc = &rclSrcWk;

    //
    // Synchronize with the device driver before touching
    // the device surface.
    //

    {
         PDEVOBJ po(psoDst->hdev);
         po.vSync(psoDst,NULL,0);
    }

    {
         PDEVOBJ po(psoSrc->hdev);
         po.vSync(psoSrc,NULL,0);
    }

    SURFACE *pSurfaceOld = NULL;
    RECTL   rclDstOld;
    CLIPOBJ    *pcoOld = pco;

    //
    // Get a readable source surface that is stretched to the destination size.
    //

    SURFMEM SurfDimoSrc;
    POINTL  ptlSrc;

    pSurfSrc = psSetupTransparentSrcSurface(
                        pSurfSrc,
                        pSurfDst,
                        prclDst,
                        NULL,
                        prclSrc,
                        SurfDimoSrc,
                        SOURCE_TRAN,
                        TransColor);

    //
    // adjust psoSrc and prclSrc
    //
    if (!pSurfSrc)
    {
        WARNING ("EngTransparentBlt -- psSetupTransparentSrcSurface failed\n");
        return (FALSE);
    }

    if (prclDst->left == prclDst->right)
    {
        return (TRUE);
    }

    psoSrc   = pSurfSrc->pSurfobj();

    //
    // If Dst is a device surface, copy it into a temporary DIB.
    //

    SURFMEM SurfDimoDst;

    pSurfaceOld = pSurfDst;
    rclDstOld = *prclDst;

    PDEVOBJ po(psoDst->hdev);

    //
    // printer surface, one scanline at a time
    //
    if ((pSurfDst->iType() != STYPE_BITMAP) && po.bPrinter())
    {
         return (GreTransparentBltPS(
                                    psoDst,
                                    psoSrc,
                                    pco,
                                    pxlo,
                                    prclDst,
                                    prclSrc,
                                    TransColor
                                   ));

    }
    else
    {
        pSurfDst = psSetupDstSurface(
                        pSurfDst,
                        prclDst,
                        SurfDimoDst,
                        FALSE,
                        TRUE
                        );
    }

    if (pSurfDst && (pSurfDst != pSurfaceOld))
    {
          //
          // adjust psoDst and prclDst and remember the original ones
          //

          psoDst = pSurfDst->pSurfobj();
          pco = NULL;
    }
    else if (pSurfDst == NULL)
    {
          return (FALSE);
    }

    //
    // prepare to call vTransparentCopy between two bitmaps
    //
    BOOL     bMore;            // True while more clip regions exist
    ULONG    ircl;             // Clip region index
    BLTINFO  bltinfo;          // Data passed to our vSrcCopySnDn fxn

    bltinfo.TransparentColor = TransColor;
    bltinfo.lDeltaSrc  = psoSrc->lDelta;
    bltinfo.lDeltaDst  = psoDst->lDelta;
    bltinfo.pdioSrc    = pSurfSrc;
    
    //
    // Determine the clipping region complexity.
    //

    CLIPENUMRECT    clenr;           // buffer for storing clip rectangles

    if (pco != (CLIPOBJ *) NULL)
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:
            bMore = FALSE;
            clenr.c = 1;
            clenr.arcl[0] = *prclDst;
            break;

        case DC_RECT:
            bMore = FALSE;
            clenr.c = 1;
            clenr.arcl[0] = pco->rclBounds;
            break;

        case DC_COMPLEX:
            bMore = TRUE;
            ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY,
                                           CLIPOBJ_ENUM_LIMIT);
            break;

        default:
            RIP("ERROR EngTransBlt bad clipping type");
        }
    }
    else
    {
        bMore = FALSE;                   //Default to TRIVIAL for no clip
        clenr.c = 1;
        clenr.arcl[0] = *prclDst;        // Use the target for clipping
    }

    //
    // Set up the static blt information into the BLTINFO structure -
    // The colour translation, & the copy directions.
    //

    //
    // pxlo is NULL implies identity colour translation. */
    //
    if (pxlo == NULL)
        bltinfo.pxlo = &xloIdent;
    else
        bltinfo.pxlo = (XLATE *) pxlo;

    bltinfo.xDir = 1L;
    bltinfo.yDir = 1L;


    ASSERTGDI(psoDst->iBitmapFormat <= BMF_32BPP, "ERROR EngTransparentBits:  bad destination format");
    ASSERTGDI(psoSrc->iBitmapFormat <= BMF_32BPP, "ERROR EngTransparentBits:  bad source format");
    ASSERTGDI(psoDst->iBitmapFormat != 0, "ERROR EngTransparentBits:  bad destination format");
    ASSERTGDI(psoSrc->iBitmapFormat != 0, "ERROR EngTransparentBits:  bad source format");

     //
     // Compute the function table index and select the source copy
     // function.
     //

     bltinfo.iFormatDst = psoDst->iBitmapFormat;
     bltinfo.iFormatSrc = psoSrc->iBitmapFormat;

     PFN_TRANSPARENT pfnTransCopy;

     ASSERTGDI(BMF_1BPP == 1, "ERROR EngTransparentBlt:  BMF_1BPP not eq 1");
     ASSERTGDI(BMF_4BPP == 2, "ERROR EngTransparentBlt:  BMF_1BPP not eq 2");
     ASSERTGDI(BMF_8BPP == 3, "ERROR EngTransparentBlt:  BMF_1BPP not eq 3");
     ASSERTGDI(BMF_16BPP == 4, "ERROR EngTransparentBlt:  BMF_1BPP not eq 4");
     ASSERTGDI(BMF_24BPP == 5, "ERROR EngTransparentBlt:  BMF_1BPP not eq 5");
     ASSERTGDI(BMF_32BPP == 6, "ERROR EngTransparentBlt:  BMF_1BPP not eq 6");
     ASSERTGDI(psoDst->iBitmapFormat <= BMF_32BPP, "ERROR EngTransparentBlt:  bad destination format");
     ASSERTGDI(psoSrc->iBitmapFormat <= BMF_32BPP, "ERROR EngTransparentBlt:  bad source format");
     ASSERTGDI(psoDst->iBitmapFormat != 0, "ERROR EngTransparentBlt:  bad destination format");
     ASSERTGDI(psoSrc->iBitmapFormat != 0, "ERROR EngTransparentBlt:  bad source format");


     do
     {
         if (bMore)
             bMore = ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr),
                                               (PVOID) &clenr);

         for (ircl = 0; ircl < clenr.c; ircl++)
         {
             PRECTL prcl = &clenr.arcl[ircl];

             //
             // Insersect the clip rectangle with the target rectangle to
             // determine our visible recangle
             //

             if (prcl->left < prclDst->left)
                 prcl->left = prclDst->left;
             if (prcl->right > prclDst->right)
                 prcl->right = prclDst->right;
             if (prcl->top < prclDst->top)
                 prcl->top = prclDst->top;
             if (prcl->bottom > prclDst->bottom)
                 prcl->bottom = prclDst->bottom;

             //
             // Process the result if it's a valid rectangle.
             //
             if ((prcl->top < prcl->bottom) && (prcl->left < prcl->right))
             {
                 LONG   xSrc;
                 LONG   ySrc;
                 LONG   xDst;
                 LONG   yDst;

                 //
                 // Figure out the upper-left coordinates of rects to blt
                 //
                 xDst = prcl->left;
                 yDst = prcl->top;
                 xSrc = prclSrc->left + xDst - prclDst->left;
                 ySrc = prclSrc->top + yDst - prclDst->top;

                 //
                 // Figure out the width and height of this rectangle
                 //
                 bltinfo.cx = prcl->right  - xDst;
                 bltinfo.cy = prcl->bottom - yDst;

                 //
                 // # of pixels offset to first pixel for src and dst
                 // from start of scan
                 //
                 bltinfo.xSrcStart = xSrc;
                 bltinfo.xSrcEnd   = bltinfo.xSrcStart + bltinfo.cx;
                 bltinfo.xDstStart = xDst;
                 bltinfo.yDstStart = prcl->top;

                 //
                 // Src scanline begining
                 // Destination scanline begining
                 //
                 bltinfo.pjSrc = ((PBYTE) psoSrc->pvScan0) +
                     ySrc*(psoSrc->lDelta);
                 bltinfo.pjDst = ((PBYTE) psoDst->pvScan0) +
                     yDst * (psoDst->lDelta);


                 //
                 // Do the blt.  Assume that BMF_1BPP=1, BMF_32BPP=6 and the rest
                 // are in between.
                 //

                 ASSERTGDI(((bltinfo.iFormatSrc >= BMF_1BPP) && (bltinfo.iFormatSrc <= BMF_32BPP)),
                     "Source format is not one of 1BPP, 4BPP, 8BPP, 16BPP, 24BPP or 32BPP\n");

                 if ((((XLATE *)(bltinfo.pxlo))->bIsIdentity()) &&
                     (bltinfo.iFormatSrc == bltinfo.iFormatDst))
                 {
                     pfnTransCopy = TransFunctionTable[bltinfo.iFormatSrc-BMF_1BPP][0];
                 }
                 else
                 {
                     pfnTransCopy = TransFunctionTable[bltinfo.iFormatSrc-BMF_1BPP][bltinfo.iFormatDst];
                 }

                 (*pfnTransCopy)(&bltinfo);
             }
         }

    } while (bMore);

    //
    // if we have blt to a temp dest DIB, need to blt to the original dest
    //
    if (pSurfaceOld != pSurfDst)
    {
        PDEVOBJ pdoDstOld(pSurfaceOld->hdev());
        POINTL  ptl = {0,0};

        (*PPFNGET(pdoDstOld,CopyBits,pSurfaceOld->flags()))(
                  pSurfaceOld->pSurfobj(),
                  psoDst,
                  pcoOld,
                  &xloIdent,
                  &rclDstOld,
                  &ptl);

    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* ReadScanLine
*     read the scanline until it hits a transparent color pixel
*
* History:
*  26-Nov-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
ULONG ReadScanLine(
    PBYTE pjSrc,
    ULONG xStart,
    ULONG xEnd,
    ULONG iFormat,
    ULONG TransparentColor)
{
    ULONG  cx = xEnd-xStart;
    ULONG  Shift = (iFormat - 3 > 0) ? iFormat : 1;
    ULONG  iPos;
    ULONG  ulSrc;
    BOOL   bStop = FALSE;

    pjSrc = StartPixel (pjSrc, xStart, iFormat);

    //
    // performance can be improved by breaking this routine into many
    // dealing with different format so that we can save two comparsions
    // for each pixel operation.  But working set size will be large
    //
     iPos = xStart;

     //
     // read one pixel at a time and compare it to the transparent color
     // if it matches the transparent color, come out
     //
     while ((iPos <= xEnd) && !bStop)
     {
         //
         // get a pixel from source and compare is to the transparent color
         //
         switch (iFormat)
         {
         case BMF_1BPP:
             ulSrc = *pjSrc & 0x00000001;
             *pjSrc >>= 1;

             if ((iPos & 0x00000007) == 0x7 )
                 pjSrc++;
             break;

         case BMF_4BPP:
             if (iPos & 0x00000001)
             {
                 ulSrc = *pjSrc & 0x0F;
                 pjSrc++;
             }
             else
             {
                 ulSrc = (*pjSrc & 0xF0)>>4;
             }
             break;

         case BMF_8BPP:
             ulSrc = (ULONG) *pjSrc;
             pjSrc++;
             break;

         case BMF_16BPP:
             ulSrc = (ULONG) *((PUSHORT)pjSrc);
             pjSrc += 2;
             break;

         case BMF_24BPP:
             ulSrc = *(pjSrc + 2);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *(pjSrc + 1);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *pjSrc;
             pjSrc += 3;
             break;

          case BMF_32BPP:
             ulSrc = *(PULONG)(pjSrc);
             pjSrc +=4;
             break;

          default:
              WARNING ("vTransparentScan -- bad iFormatSrc\n");
              return(0);

         } /*switch*/

         if (ulSrc == TransparentColor)
             bStop = TRUE;

         iPos++;
    }

    return (iPos);
}

/******************************Public*Routine******************************\
* SkipScanLine
*     read the scanline until it hits a non-transparent color pixel
*
* History:
*  26-Nov-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
ULONG SkipScanLine(
    PBYTE pjSrc,
    ULONG xStart,
    ULONG xEnd,
    ULONG iFormat,
    ULONG TransparentColor)
{
    ULONG  Shift = (iFormat - 3 > 0) ? iFormat : 1;
    ULONG  iPos = xStart;
    ULONG  ulSrc;
    BOOL   bStop = FALSE;

    pjSrc = StartPixel (pjSrc, xStart, iFormat);

    //
    // performance can be improved by breaking this routine into many
    // dealing with different format so that we can save two comparsions
    // for each pixel operation.  But working set size will be large
    //

     //
     // read one pixel at a time and compare it to the transparent color
     // if it matches the transparent color, come out
     //
     while ((iPos <= xEnd) && !bStop)
     {
         //
         // get a pixel from source and compare is to the transparent color
         //
         switch (iFormat)
         {
         case BMF_1BPP:
             ulSrc = *pjSrc & 0x00000001;
             *pjSrc >>= 1;

             if ((iPos & 0x00000007) == 0x7 )
                 pjSrc++;
             break;

         case BMF_4BPP:
             if (iPos & 0x00000001)
             {
                 ulSrc = *pjSrc & 0x0F;
                 pjSrc++;
             }
             else
             {
                 ulSrc = (*pjSrc & 0xF0)>>4;
             }
             break;

         case BMF_8BPP:
             ulSrc = (ULONG) *pjSrc;
             pjSrc++;
             break;

         case BMF_16BPP:
             ulSrc = (ULONG) *((PUSHORT)pjSrc);
             pjSrc += 2;
             break;

         case BMF_24BPP:
             ulSrc = *(pjSrc + 2);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *(pjSrc + 1);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *pjSrc;
             pjSrc += 3;
             break;

          case BMF_32BPP:
             ulSrc = *(PULONG)(pjSrc);
             pjSrc +=4;
             break;

          default:
              WARNING ("vTransparentScan -- bad iFormatSrc\n");
              return (0);

         } /*switch*/

         if (ulSrc != TransparentColor)
             bStop = TRUE;

         iPos++;   // move to the next pixel
    }

    return (iPos);
}

/******************************Public*Routine******************************\
* VOID vTransparentScan
*
* Read a scanline at a time and send the non-transparent pixel scans over
*
* History:
*  2-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

VOID vTransparentScan (
    SURFOBJ   *psoDst,
    SURFOBJ   *psoSrc,
    ULONG     xSrc,
    ULONG     ySrc,
    XLATEOBJ  *pxlo,
    RECTL     *prcl,
    ULONG     TransparentColor)
{
    ULONG xStart = xSrc;
    ULONG cx =  prcl->right - prcl->left;
    ULONG xEnd = xSrc + cx;
    ULONG xStop, xReStart;
    RECTL erclTemp = *prcl;
    POINTL ptlSrc;

    PBYTE pjSrc = (PBYTE)psoSrc->pvScan0 + (LONG)ySrc * psoSrc->lDelta;

     // get the scanline

    ptlSrc.x = xSrc;
    ptlSrc.y = ySrc;

    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);

    PDEVOBJ pdoDst(pSurfDst->hdev());

    while (xStart < xEnd)
    {
        xStop = ReadScanLine((PBYTE)pjSrc,
                              xStart,
                              xEnd,
                              psoSrc->iBitmapFormat,
                              TransparentColor);

        if (xStop-1 > xStart)
        {
            erclTemp.right = erclTemp.left + xStop - xStart;

            // send the partial scan line over

            (*PPFNGET(pdoDst,CopyBits,pSurfDst->flags())) (psoDst,
                                                       psoSrc,
                                                       (CLIPOBJ *) NULL,
                                                       pxlo,
                                                       &erclTemp,
                                                       &ptlSrc);

        }

        //get to the next non transparent pixel
        xReStart = SkipScanLine((PBYTE)pjSrc,
                                 xStop,
                                 xEnd,
                                 psoSrc->iBitmapFormat,
                                 TransparentColor);

        erclTemp.left = erclTemp.left + xReStart-xStart;

        ptlSrc.x = xReStart;

        xStart = xReStart;
     }
}

/******************************Public*Routine******************************\
* GreTransparentBltPS
*
*    Special routine for Pscript when the destination is unreadable
*
\**************************************************************************/
BOOL
GreTransparentBltPS(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      TransColor
)
{
    ASSERTGDI(psoDst != NULL, "ERROR GreTransparentBltPS:  No Dst. Object");
    ASSERTGDI(psoSrc != NULL, "ERROR GreTransparentBltPS:  No Src. Object");
    ASSERTGDI(prclDst != (PRECTL) NULL,  "ERROR GreTransparentBltPS:  No Target Rect.");
    ASSERTGDI(prclDst->left < prclDst->right, "ERROR GreTransparentBltPS left < right");
    ASSERTGDI(prclDst->top < prclDst->bottom, "ERROR GreTransparentBltPS top < bottom");

    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);
    PSURFACE pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);

    ULONG cx = prclDst->right-prclDst->left;
    ULONG cy = prclDst->bottom-prclDst->top;

    //
    // If same legnth/width but Src is a device surface,
    // need to copy it into atemporary DIB.
    //

    SURFMEM SurfDimoDst;

    ASSERTGDI (psoSrc->iType == STYPE_BITMAP, "ERROR GreTransparentBltPS:  source surface not STYPE_BITMAP");
    ASSERTGDI (psoDst->iType != STYPE_BITMAP, "ERROR GreTransparentBltPS:  destination surface is STYPE_BITMAP");

    //
    // prepare to call vTransparentCopy between two bitmaps
    //

    BOOL     bMore;            // True while more clip regions exist
    ULONG    ircl;             // Clip region index

    //
    // Determine the clipping region complexity.
    //

    CLIPENUMRECT    clenr;           // buffer for storing clip rectangles

    if (pco != (CLIPOBJ *) NULL)
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:
            bMore = FALSE;
            clenr.c = 1;
            clenr.arcl[0] = *prclDst;    // Use the target for clipping
            break;

        case DC_RECT:
            bMore = FALSE;
            clenr.c = 1;
            clenr.arcl[0] = pco->rclBounds;
            break;

        case DC_COMPLEX:
            bMore = TRUE;
            ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY,
                                           CLIPOBJ_ENUM_LIMIT);
            break;

        default:
            RIP("ERROR EngTransBlt bad clipping type");
            return (FALSE);
        }
    }
    else
    {
        bMore = FALSE;                   //Default to TRIVIAL for no clip
        clenr.c = 1;
        clenr.arcl[0] = *prclDst;        // Use the target for clipping
    }

    //
    // Set up the static blt information into the BLTINFO structure -
    // The colour translation, & the copy directions.
    //

    //
    // pxlo is NULL implies identity colour translation. */
    //
    if (pxlo == NULL)
        pxlo = &xloIdent;

    ASSERTGDI(psoDst->iBitmapFormat <= BMF_32BPP, "ERROR GreTransparentBltPS:  bad destination format");
    ASSERTGDI(psoSrc->iBitmapFormat <= BMF_32BPP, "ERROR GreTransparentBltPS:  bad source format");
    ASSERTGDI(psoDst->iBitmapFormat != 0, "ERROR GreTransparentBltPS:  bad destination format");
    ASSERTGDI(psoSrc->iBitmapFormat != 0, "ERROR GreTransparentBltPS:  bad source format");


    do
    {
        if (bMore)
            bMore = ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr),
                                              (PVOID) &clenr);

        for (ircl = 0; ircl < clenr.c; ircl++)
        {
            PRECTL prcl = &clenr.arcl[ircl];

            //
            // Insersect the clip rectangle with the target rectangle to
            // determine our visible recangle
            //

            if (prcl->left < prclDst->left)
                prcl->left = prclDst->left;
            if (prcl->right > prclDst->right)
                prcl->right = prclDst->right;
            if (prcl->top < prclDst->top)
                prcl->top = prclDst->top;
            if (prcl->bottom > prclDst->bottom)
                prcl->bottom = prclDst->bottom;

            //
            // Process the result if it's a valid rectangle.
            //
            if ((prcl->top < prcl->bottom) && (prcl->left < prcl->right))
            {
                LONG   xSrc;
                LONG   ySrc;
                LONG   xDst;
                LONG   yDst;
                ERECTL ercl;
                POINTL ptlSrc;

                //
                // Figure out the upper-left coordinates of rects to blt
                //
                ercl.left = prcl->left;
                ercl.top  = prcl->top;
                ercl.right = prcl->right;
                ercl.bottom = ercl.top+1;

                xDst = prcl->left;
                yDst = prcl->top;

                xSrc = prclSrc->left + xDst - prclDst->left;
                ySrc = prclSrc->top + yDst - prclDst->top;

                //
                // Figure out the width and height of this rectangle
                //
                LONG cx = prcl->right  - prcl->left;
                LONG cy = prcl->bottom - prcl->top;

                while (cy--)
                {
                    //
                    // Send one scanline over
                    //

                    //
                    // draw one scan line and skip transparent color pixels
                    //
                    vTransparentScan (psoDst, psoSrc, xSrc, ySrc, pxlo, &ercl, TransColor);

                    ySrc++;
                    ercl.top++;
                    ercl.bottom++;
                }

            }

        }

    } while (bMore);

    return TRUE;
}


/******************************Public*Routine******************************\
* NtGdiTransparentBlt
*
*     Copy or stretch the source bits onto the destionation surface which
* preserving the specific Transparent color on the destination Surface
*
* 25-Jun-97 Added rotation support -by- Ori Gershony [orig]
*
*  8-Nov-96 by Lingyun Wang [lingyunw]
*
\**************************************************************************/

BOOL
NtGdiTransparentBlt(
    HDC      hdcDst,
    int      xDst,
    int      yDst,
    int      cxDst,
    int      cyDst,
    HDC      hdcSrc,
    int      xSrc,
    int      ySrc,
    int      cxSrc,
    int      cySrc,
    COLORREF TransColor
    )
{
    GDITraceHandle2(NtGdiTransparentBlt, "(%X, %d, %d, %d, %d, %X, %d, %d, %d, %d, %X)\n", (va_list)&hdcDst, hdcDst, hdcSrc);

    BOOL bReturn = FALSE;

    //
    // no mirroring
    //
    
    if ((cxDst < 0) || (cyDst < 0) || (cxSrc < 0) || (cySrc < 0)) 
    {
        WARNING1("NtGdiTransparentBlt: mirroring not allowed\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    
    //
    // Lock down both the Src and Dest DCs
    //

    DCOBJ  dcoDst(hdcDst);
    DCOBJ  dcoSrc(hdcSrc);

    if ((dcoDst.bValid() && !dcoDst.bStockBitmap()) && dcoSrc.bValid())
    {
        EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);
        EXFORMOBJ xoSrc(dcoSrc, WORLD_TO_DEVICE);

        //
        // no source rotation
        //
        if (!xoSrc.bRotationOrMirroring())
        {
            //
            // Return null operations.  Don't need to check source for
            // empty because the xforms are the same except translation.
            //

            ERECTL erclSrc(xSrc,ySrc,xSrc+cxSrc,ySrc+cySrc);
            xoSrc.bXform(erclSrc);
            erclSrc.vOrder();


            //
            // If destination has a rotation, compute a bounding box for the
            // resulting parallelogram
            //
            EPOINTFIX pptfxDst[4];
            ERECTL erclDst;
            BOOL bRotationDst;

            if ((bRotationDst = xoDst.bRotationOrMirroring()))
            {
                //
                // Compute the resulting parallelogram.  In order to make sure we don't lose
                // precision in the rotation, we will store the output of the transformation
                // in fixed point numbers (this is how PlgBlt does it and we want our output
                // to match).
                // 
                POINTL pptlDst[3];

                pptlDst[0].x = xDst;
                pptlDst[0].y = yDst;

                pptlDst[1].x = xDst+cxDst;
                pptlDst[1].y = yDst;

                pptlDst[2].x = xDst;
                pptlDst[2].y = yDst+cyDst;

                xoDst.bXform(pptlDst, pptfxDst, 3);

                if (!xoDst.bRotation()) 
                {
                    //
                    // Mirroring transforms hack:  back in windows 3.1, they used to shift
                    // by one for mirroring transforms.  We need to support this here to
                    // be compatible with NT's BitBlt/StretchBlt that also use this hack, and
                    // also to be compatible with AlphaBlend that calls BitBlt/StretchBlt
                    // code when constant alpha=255 and there's no per-pixel alpha.  Ick!
                    // See BLTRECORD::vOrderStupid for details.  Also see bug 319917.
                    //

                    if (pptfxDst[0].x > pptfxDst[1].x) 
                    {
                        //
                        // Mirroring in x
                        //
                        pptfxDst[0].x += LTOFX(1);
                        pptfxDst[1].x += LTOFX(1);
                        pptfxDst[2].x += LTOFX(1);
                    }

                    if (pptfxDst[0].y > pptfxDst[2].y) 
                    {
                        //
                        // Mirroring in y
                        //
                        pptfxDst[0].y += LTOFX(1);
                        pptfxDst[1].y += LTOFX(1);
                        pptfxDst[2].y += LTOFX(1);
                    }
                }

                //
                // Compute the fourth point using the first three points.
                //
                pptfxDst[3].x = pptfxDst[1].x + pptfxDst[2].x - pptfxDst[0].x;
                pptfxDst[3].y = pptfxDst[1].y + pptfxDst[2].y - pptfxDst[0].y;

                //
                // Compute the bounding box.  Algorithm borrowed from Donald Sidoroff's code
                // in EngPlgBlt.  Basically the first two statements decide whether the indices of
                // the extremas are odd or even, and the last two statements determine exactly what
                // they are.
                //
                int iLeft = (pptfxDst[1].x > pptfxDst[0].x) == (pptfxDst[1].x > pptfxDst[3].x);
                int iTop  = (pptfxDst[1].y > pptfxDst[0].y) == (pptfxDst[1].y > pptfxDst[3].y);
                 
                if (pptfxDst[iLeft].x > pptfxDst[iLeft ^ 3].x)
                {
                    iLeft ^= 3;
                }
                 
                if (pptfxDst[iTop].y > pptfxDst[iTop ^ 3].y)
                {
                    iTop ^= 3;
                }

                erclDst = ERECTL(LONG_CEIL_OF_FIX(pptfxDst[iLeft  ].x),
                                 LONG_CEIL_OF_FIX(pptfxDst[iTop   ].y),
                                 LONG_CEIL_OF_FIX(pptfxDst[iLeft^3].x),
                                 LONG_CEIL_OF_FIX(pptfxDst[iTop^3 ].y));

                //
                // The vertices should now be in vOrder, but it doesn't hurt to verify this...
                //
                ASSERTGDI((erclDst.right  >= erclDst.left), "NtGdiTransparentBlt:  erclDst not in vOrder");
                ASSERTGDI((erclDst.bottom >= erclDst.top),  "NtGdiTransparentBlt:  erclDst not in vOrder");
            }
            else
            {
                //
                // No rotation--just apply the transformation to the rectangle
                //

                erclDst = ERECTL(xDst,yDst,xDst+cxDst,yDst+cyDst);
                xoDst.bXform(erclDst);
                erclDst.vOrder();
            }

            if (!erclDst.bEmpty())
            {
                //
                // Accumulate bounds.  We can do this outside the DEVLOCK
                //

                if (dcoDst.fjAccum())
                    dcoDst.vAccumulate(erclDst);

                //
                // Lock the Rao region and the surface if we are drawing on a
                // display surface.  Bail out if we are in full screen mode.
                //

                DEVLOCKBLTOBJ dlo;
                BOOL bLocked;

                bLocked = dlo.bLock(dcoDst, dcoSrc);

                if (bLocked)
                {
                    //
                    // Check pSurfDst, this may be an info DC or a memory DC with default bitmap.
                    //

                    SURFACE *pSurfDst;

                    if ((pSurfDst = dcoDst.pSurface()) != NULL)
                    {
                        XEPALOBJ   palDst(pSurfDst->ppal());
                        XEPALOBJ   palDstDC(dcoDst.ppal());


                        SURFACE *pSurfSrc = dcoSrc.pSurface();

                        //
                        // Basically we check that pSurfSrc is not NULL which
                        // happens for memory bitmaps with the default bitmap
                        // and for info DC's.  Otherwise we continue if
                        // the source is readable or if it isn't we continue
                        // if we are blting display to display or if User says
                        // we have ScreenAccess on this display DC.  Note
                        // that if pSurfSrc is not readable the only way we
                        // can continue the blt is if the src is a display.
                        //

                        if (pSurfSrc != NULL)
                        {
                            if ((pSurfSrc->bReadable()) ||
                                ((dcoSrc.bDisplay())  &&
                                 ((dcoDst.bDisplay()) || UserScreenAccessCheck() )))
                            {

                                
                                //
                                // With a fixed DC origin we can change the rectangles to SCREEN coordinates.                                
                                //

                                //
                                // This is useful later for rotations
                                //                                
                                ERECTL erclDstOrig = erclDst;

                                erclDst += dcoDst.eptlOrigin();
                                erclSrc += dcoSrc.eptlOrigin();

                                //
                                // Make sure the source rectangle lies completely within the source
                                // surface.
                                //

                                BOOL bBadRects; 

                                // If the source is a Meta device, we must check bounds taking its 
                                // origin into account. 

                                PDEVOBJ pdoSrc( pSurfSrc->hdev() ); 

                                if( pSurfSrc->iType() == STYPE_DEVICE && 
                                    pdoSrc.bValid() && pdoSrc.bMetaDriver())
                                {
                                    bBadRects = ((erclSrc.left < pdoSrc.pptlOrigin()->x) ||
                                                    (erclSrc.top  < pdoSrc.pptlOrigin()->y) ||
                                                    (erclSrc.right  > (pdoSrc.pptlOrigin()->x + 
                                                     pSurfSrc->sizl().cx)) ||
                                                    (erclSrc.bottom > (pdoSrc.pptlOrigin()->y + 
                                                     pSurfSrc->sizl().cy)));
                                }
                                else
                                {   
                                    bBadRects = ((erclSrc.left < 0) ||
                                                    (erclSrc.top  < 0) ||
                                                    (erclSrc.right  > pSurfSrc->sizl().cx) ||
                                                    (erclSrc.bottom > pSurfSrc->sizl().cy));
                                }
 
                                if (bBadRects)
                                {
                                    WARNING("NtGdiTransparentBlt -- source rectangle out of surface bounds");
                                }

                                //
                                // Make sure that source and destination rectangles don't overlap if the
                                // source surface is the same as the destination surface.
                                //
                                if (pSurfSrc == pSurfDst)
                                {
                                    ERECTL erclIntersection = erclSrc;
                                    erclIntersection *= erclDst;
                                    if (!erclIntersection.bEmpty())
                                    {
                                        bBadRects = TRUE;
                                        WARNING ("NtGdiTransparentBlt -- source and destination rectangles are on the same surface and overlap");
                                    }
                                }

                                if (!bBadRects)
                                {

                                    XEPALOBJ   palSrc(pSurfSrc->ppal());
                                    XEPALOBJ   palSrcDC(dcoSrc.ppal());

                                    //
                                    // get representation of src color
                                    //

                                    ULONG ulColor = ulGetNearestIndexFromColorref(
                                        palSrc,
                                        palSrcDC,
                                        TransColor,
                                        SE_DO_SEARCH_EXACT_FIRST
                                        );

                                    //
                                    // we don't want to touch the src/dest rectangles when there is stretching
                                    //
                                    // Compute the clipping complexity and maybe reduce the exclusion rectangle.

                                    ECLIPOBJ eco(dcoDst.prgnEffRao(), erclDst);

                                    // Check the destination which is reduced by clipping.

                                    if (eco.erclExclude().bEmpty())
                                    {
                                        return (TRUE);
                                    }

                                    // Compute the exclusion rectangle.

                                    ERECTL erclExclude = eco.erclExclude();

                                    // If we are going to the same source, prevent bad overlap situations

                                    if (dcoSrc.pSurface() == dcoDst.pSurface())
                                    {
                                        if (erclSrc.left   < erclExclude.left)
                                            erclExclude.left   = erclSrc.left;

                                        if (erclSrc.top    < erclExclude.top)
                                            erclExclude.top    = erclSrc.top;

                                        if (erclSrc.right  > erclExclude.right)
                                            erclExclude.right  = erclSrc.right;

                                        if (erclSrc.bottom > erclExclude.bottom)
                                            erclExclude.bottom = erclSrc.bottom;
                                    }

                                    // We might have to exclude the source or the target, get ready to do either.

                                    DEVEXCLUDEOBJ dxo;

                                    // They can't both be display

                                    if (dcoSrc.bDisplay())
                                    {
                                        ERECTL ercl(0,0,pSurfSrc->sizl().cx,pSurfSrc->sizl().cy);

                                        if (dcoSrc.pSurface() == dcoDst.pSurface())
                                            ercl *= erclExclude;
                                        else
                                            ercl *= erclSrc;

                                        dxo.vExclude(dcoSrc.hdev(),&ercl,NULL);
                                    }
                                    else if (dcoDst.bDisplay())
                                        dxo.vExclude(dcoDst.hdev(),&erclExclude,&eco);


                                    //
                                    // If the destination requires rotation, we allocate a surface and rotate the
                                    // source surface into it.
                                    //

                                    SURFMEM surfMemTmpSrc;
                                    if (bRotationDst)
                                    {
                                        //
                                        // Allocate memory for the rotated source surface
                                        //
                                        DEVBITMAPINFO   dbmi;

                                        dbmi.cxBitmap = erclDst.right  - erclDst.left;
                                        dbmi.cyBitmap = erclDst.bottom - erclDst.top;
                                        dbmi.iFormat  = pSurfSrc->iFormat();
                                        dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;
                                        dbmi.hpal     = (HPALETTE)NULL;

                                        BOOL bStatus = surfMemTmpSrc.bCreateDIB(&dbmi, (VOID *) NULL);

                                        //
                                        // init DIB to transparent
                                        // (so that portions of dst rect not covered by source rect are not drawn)
                                        //
                                        if (bStatus)
                                        {
                                            ULONG i;
                                            ULONG cjBits = surfMemTmpSrc.ps->cjBits();
                                            ULONG ulColor4BPP;

                                            switch (pSurfSrc->iFormat())
                                            {
                                            case BMF_1BPP:
                                                if (ulColor)
                                                {
                                                    memset(surfMemTmpSrc.ps->pvBits(),0xff,cjBits);
                                                }
                                                else
                                                {
                                                    memset(surfMemTmpSrc.ps->pvBits(),0,cjBits);
                                                }
                                                break;

                                            case BMF_4BPP:
                                                ulColor4BPP = ulColor | (ulColor << 4);
                                                memset(surfMemTmpSrc.ps->pvBits(),ulColor4BPP,cjBits);
                                                break;

                                            case BMF_8BPP:
                                                memset(surfMemTmpSrc.ps->pvBits(),ulColor,cjBits);
                                                break;

                                            case BMF_16BPP:
                                                {
                                                    PUSHORT pvBits = (PUSHORT) surfMemTmpSrc.ps->pvBits();

                                                    for (i=0; i<(cjBits/sizeof(USHORT)); i++)
                                                    {
                                                        *pvBits++ = (USHORT) ulColor;

                                                    }
                                                }
                                            break;

                                            case BMF_24BPP:
                                                {
                                                    BYTE bC1 = ((PBYTE)&ulColor)[0];
                                                    BYTE bC2 = ((PBYTE)&ulColor)[1];
                                                    BYTE bC3 = ((PBYTE)&ulColor)[2];


                                                    PULONG pulDstY     = (PULONG)surfMemTmpSrc.ps->pvScan0();
                                                    PULONG pulDstLastY = (PULONG)((PBYTE)pulDstY +
                                                                                  (surfMemTmpSrc.ps->lDelta() * surfMemTmpSrc.ps->sizl().cy));
                                                    while (pulDstY != pulDstLastY)
                                                    {
                                                        PBYTE pulDstX     = (PBYTE) pulDstY;
                                                        PBYTE pulDstLastX = pulDstX + 3 * surfMemTmpSrc.ps->sizl().cx;

                                                        while (pulDstX < pulDstLastX-2)
                                                        {
                                                            *pulDstX++ = bC1;
                                                            *pulDstX++ = bC2;
                                                            *pulDstX++ = bC3;
                                                        }
                                                        pulDstY = (PULONG)((PBYTE)pulDstY + surfMemTmpSrc.ps->lDelta());
                                                    }
                                                }
                                            break;

                                            case BMF_32BPP:
                                                {
                                                    PULONG pvBits = (PULONG) surfMemTmpSrc.ps->pvBits();

                                                    for (i=0; i<(cjBits/sizeof(ULONG)); i++)
                                                    {
                                                        *pvBits++ = ulColor;
                                                    }
                                                }
                                            break;
                                            }
                                        }
                                        else
                                        {
                                            //
                                            // Fail the call
                                            //
                                            WARNING("NtGdiTransparentBlt:  failed to create temporary DIB\n");
                                            EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                                            return FALSE;
                                        }


                                        //
                                        // Now define the parallelogram the source bitmap is mapped to in surfMemTmpSrc
                                        //

                                        EPOINTFIX eptlNewSrc[3];

                                        eptlNewSrc[0] = EPOINTFIX(
                                            pptfxDst[0].x - LTOFX(erclDstOrig.left), 
                                            pptfxDst[0].y - LTOFX(erclDstOrig.top)
                                            );

                                        eptlNewSrc[1] = EPOINTFIX(
                                            pptfxDst[1].x - LTOFX(erclDstOrig.left), 
                                            pptfxDst[1].y - LTOFX(erclDstOrig.top)
                                            );

                                        eptlNewSrc[2] = EPOINTFIX(
                                            pptfxDst[2].x - LTOFX(erclDstOrig.left), 
                                            pptfxDst[2].y - LTOFX(erclDstOrig.top)
                                            );

                                        EngPlgBlt(
                                            surfMemTmpSrc.ps->pSurfobj(),
                                            pSurfSrc->pSurfobj(),
                                            NULL,   // No mask
                                            NULL,   // No clipping object
                                            &xloIdent,
                                            NULL,   // No color adjustment
                                            NULL,
                                            eptlNewSrc,
                                            &erclSrc,
                                            NULL,
                                            COLORONCOLOR
                                            );

                                        //
                                        // Now adjust the local variables
                                        //

                                        pSurfSrc = surfMemTmpSrc.ps;
                                        erclSrc.left = 0;
                                        erclSrc.top = 0;
                                        erclSrc.right = erclDst.right - erclDst.left;
                                        erclSrc.bottom = erclDst.bottom - erclDst.top;

                                    }

                                    bReturn = TRUE;

                                    EXLATEOBJ xlo;
                                    XLATEOBJ *pxlo;

                                    pxlo = NULL;

                                    if (dcoSrc.pSurface() != dcoDst.pSurface())
                                    {
                                        //
                                        // Get a translate object.
                                        //

                                        bReturn = xlo.bInitXlateObj(
                                            NULL,
                                            DC_ICM_OFF,
                                            palSrc,
                                            palDst,
                                            palSrcDC,
                                            palDstDC,
                                            dcoDst.pdc->crTextClr(),
                                            dcoDst.pdc->crBackClr(),
                                            (COLORREF)-1
                                            );

                                        pxlo = xlo.pxlo();
                                    }

                                    if (bReturn)
                                    {

                                        //
                                        // Inc the target surface uniqueness
                                        //

                                        INC_SURF_UNIQ(pSurfDst);

                                        //
                                        // Check were on the same PDEV, we can't blt between
                                        // different PDEV's.  We could make blting between different
                                        // PDEV's work easily.  All we need to do force EngBitBlt to
                                        // be called if the PDEV's aren't equal in the dispatch.
                                        // EngBitBlt does the right thing.
                                        //
                                        if (dcoDst.hdev() == dcoSrc.hdev())
                                        {
                                            PDEVOBJ pdo(pSurfDst->hdev());

                                            //
                                            // Dispatch the call.
                                            //

                                            bReturn = (*PPFNGET(pdo, TransparentBlt, pSurfDst->flags())) (
                                                pSurfDst->pSurfobj(),
                                                pSurfSrc->pSurfobj(),
                                                &eco,
                                                pxlo,
                                                &erclDst,
                                                &erclSrc,
                                                ulColor,
                                                0);
                                        }
                                        else
                                        {
                                            WARNING1("NtGdiTransparentBlt failed: source and destination surfaces not on same PDEV");
                                            EngSetLastError(ERROR_INVALID_PARAMETER);
                                            bReturn = FALSE;
                                        }
                                    }
                                    else
                                    {
                                        WARNING("NtGdiTransparentBlt -- failed to initxlateobj\n");
                                        EngSetLastError(ERROR_INVALID_HANDLE);
                                        bReturn = FALSE;
                                    }
                                }
                                else
                                {
                                    EngSetLastError(ERROR_INVALID_PARAMETER);
                                    bReturn = FALSE;
                                }
                            }
                            else
                            {
                                WARNING1("TransparentBlt failed - trying to read from unreadable surface\n");
                                EngSetLastError(ERROR_INVALID_HANDLE);
                                bReturn = FALSE;
                            }
                        }
                        else  // null src suface
                        {
                            bReturn = TRUE;
                        }
                    }
                    else  // null dest surface
                    {
                        bReturn = TRUE;
                    }
                }
                else
                {
                    // Return True if we are in full screen mode.

                    bReturn = dcoDst.bFullScreen() | dcoSrc.bFullScreen();
                }
            }
            else
            {
                bReturn = TRUE;
            }
        }
        else
        {
            WARNING ("Source rotation in TranparentBlt is not supported\n");
            EngSetLastError(ERROR_INVALID_PARAMETER);
            bReturn=FALSE;
        }

    }
    else
    {
        WARNING("NtGdiTransparentBlt failed invalid src or dest dc \n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        bReturn=FALSE;
    }

    return(bReturn);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\trimesh.cxx ===
/******************************Module*Header*******************************\
* Module Name: trimesh.cxx
*
* Gradient fill inplementation
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "solline.hxx"

/**************************************************************************\
* pfnDetermineTriangleFillRoutine
*
*   determine scan line drawing routine for gradient fill
*
* Arguments:
*
*   pSurfDst          - dest surface
*   *ppal             - dest palette
*   *pnfTriangleFill  - return triangle fill routine
*   *pnfRectangleFill - return gradient fill routine
*
* Return Value:
*
*   status
*
* History:
*
*    2/17/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bDetermineTriangleFillRoutine(
    PSURFACE     pSurfDst,
    XEPALOBJ     *ppal,
    PFN_GRADIENT *pnfTriangleFill,
    PFN_GRADRECT *pnfRectangleFill
    )
{

    switch (pSurfDst->iFormat())
    {
    case BMF_1BPP:
        *pnfTriangleFill  = vGradientFill1;
        *pnfRectangleFill = vFillGRectDIB1;
        break;
    case BMF_4BPP:
        *pnfTriangleFill  = vGradientFill4;
        *pnfRectangleFill = vFillGRectDIB4;
        break;

    case BMF_8BPP:
        *pnfTriangleFill  = vGradientFill8;
        *pnfRectangleFill = vFillGRectDIB8;
        break;

    case BMF_16BPP:
    {
        ULONG flR = ppal->flRed();
        ULONG flG = ppal->flGre();
        ULONG flB = ppal->flBlu();

        if (
            (flR == 0xf800) &&
            (flG == 0x07e0) &&
            (flB == 0x001f)
           )
        {
            *pnfTriangleFill  = vGradientFill16_565;
            *pnfRectangleFill = vFillGRectDIB16_565;
        }
        else if (
            (flR == 0x7c00) &&
            (flG == 0x03e0) &&
            (flB == 0x001f)
           )
        {
            *pnfTriangleFill  = vGradientFill16_555;
            *pnfRectangleFill = vFillGRectDIB16_555;
        }
        else
        {
            *pnfTriangleFill  = vGradientFill16Bitfields;
            *pnfRectangleFill = vFillGRectDIB16Bitfields;
        }
    }
    break;

    case BMF_24BPP:
        if(ppal->bIsRGB())
        {
            *pnfTriangleFill = vGradientFill24RGB;
            *pnfRectangleFill = vFillGRectDIB24RGB;
        }
        else if(ppal->bIsBGR())
        {
            *pnfTriangleFill = vGradientFill24BGR;
            *pnfRectangleFill = vFillGRectDIB24BGR;
        }
        else
        {
            *pnfTriangleFill = vGradientFill24Bitfields;
            *pnfRectangleFill = vFillGRectDIB24Bitfields;
        }
        break;

    case BMF_32BPP:
        if (ppal->bIsRGB())
        {
            *pnfTriangleFill = vGradientFill32RGB;
            *pnfRectangleFill = vFillGRectDIB32RGB;
        }
        else if (ppal->bIsBGR())
        {
            *pnfTriangleFill = vGradientFill32BGRA;
            *pnfRectangleFill = vFillGRectDIB32BGRA;
        }
        else
        {
            *pnfTriangleFill = vGradientFill32Bitfields;
            *pnfRectangleFill = vFillGRectDIB32Bitfields;
        }
        break;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* vHorizontalLine
*
*   Record information for horizontal line.
*   Colors are recorded as fixed point 8.56
*
* Arguments:
*
*   pv1      - vertex 1
*   pv2      - vertex 2
*   ptData   - triangle data
*   ptridda  - dda data
*
* Return Value:
*
*   none
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vHorizontalLine(
    PTRIVERTEX    pv1,
    PTRIVERTEX    pv2,
    PTRIANGLEDATA ptData,
    PTRIDDA       ptridda
    )
{
    LONG yPosition = ptridda->N0;
    LONG yIndex    = yPosition - ptData->y0;

    //
    // check if this line is whithin clipping in y
    //

    if (
         (yPosition >= ptData->rcl.top)   &&
         (yPosition < ptData->rcl.bottom)
       )
    {
       //
       // find left edge
       //

       if (pv1->x <= pv2->x)
       {
            //
            // left edge
            //

            ptData->TriEdge[yIndex].xLeft   = pv1->x;
            ptData->TriEdge[yIndex].llRed   = ((LONGLONG)pv1->Red)   << 48;
            ptData->TriEdge[yIndex].llGreen = ((LONGLONG)pv1->Green) << 48;
            ptData->TriEdge[yIndex].llBlue  = ((LONGLONG)pv1->Blue)  << 48;
            ptData->TriEdge[yIndex].llAlpha = ((LONGLONG)pv1->Alpha) << 48;

            //
            // right edge
            //

            ptData->TriEdge[yIndex].xRight = pv2->x;
       }
       else
       {
            //
            // left edge
            //

            ptData->TriEdge[yIndex].xLeft   = pv2->x;
            ptData->TriEdge[yIndex].llRed   = pv2->Red   << 48;
            ptData->TriEdge[yIndex].llGreen = pv2->Green << 48;
            ptData->TriEdge[yIndex].llBlue  = pv2->Blue  << 48;
            ptData->TriEdge[yIndex].llAlpha = pv2->Alpha << 48;

            //
            // right edge
            //

            ptData->TriEdge[yIndex].xRight = pv1->x;
        }
    }
}

/******************************Public*Routine******************************\
* vEdgeDDA
*
*   Run line DDA down an edge of the triangle recording edge
*   position and color
*
* Arguments:
*
*   ptData  - triangle data
*   ptridda - line dda information
*
* Return Value:
*
*   None
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vEdgeDDA(
     PTRIANGLEDATA ptData,
     PTRIDDA       ptridda
     )
{
    LONG NumScanLines = ptridda->NumScanLines;
    LONG yIndex       = ptridda->yIndex;
    LONGLONG llRed    = ptridda->llRed;
    LONGLONG llGreen  = ptridda->llGreen;
    LONGLONG llBlue   = ptridda->llBlue;
    LONGLONG llAlpha  = ptridda->llAlpha;
    LONG L            = ptridda->L;
    LONG Rb           = ptridda->Rb;

    //
    // Scan all lines, only record lines contained by
    // the clipping in ptData->rcl (y)
    //

    while (NumScanLines--)
    {
        //
        // check for and record left edge
        //

        if (yIndex >= 0)
        {
            if (L < ptData->TriEdge[yIndex].xLeft)
            {
                ptData->TriEdge[yIndex].xLeft   = L;
                ptData->TriEdge[yIndex].llRed   = llRed;
                ptData->TriEdge[yIndex].llGreen = llGreen;
                ptData->TriEdge[yIndex].llBlue  = llBlue;
                ptData->TriEdge[yIndex].llAlpha = llAlpha;
            }

            if (L > ptData->TriEdge[yIndex].xRight)
            {
                ptData->TriEdge[yIndex].xRight = L;
            }
        }

        //
        // inc y by one scan line, inc x(L) by integer step
        // and inc error term by dR
        //

        yIndex++;

        L  += ptridda->dL;
        Rb -= ptridda->dR;

        //
        // inc color components by y and integer x components
        //

        llRed   += (ptridda->lldxyRed);
        llGreen += (ptridda->lldxyGreen);
        llBlue  += (ptridda->lldxyBlue);
        llAlpha += (ptridda->lldxyAlpha);

        //
        // check for DDA error term overflow, add one
        // more step in x and color if true,
        // and correct error term
        //

        if (Rb < 0)
        {
            //
            // fraction step in x
            //

            L += ptridda->Linc;

            //
            // fraction step in color components
            //

            llRed   += ptData->lldRdX;
            llGreen += ptData->lldGdX;
            llBlue  += ptData->lldBdX;
            llAlpha += ptData->lldAdX;

            //
            // adjust error term
            //

            Rb += ptridda->dN;
        }
    }
}

/******************************Public*Routine******************************\
* vCalulateLine
*
*   calculate bounding line
*
* Arguments:
*
*   pv1    - vertex 1
*   pv2    - vertex 2
*   ptData - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vCalculateLine(
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData
    )
{
    TRIDDA tridda;

    //
    // initial y component
    //

    tridda.lldxyRed   = ptData->lldRdY;
    tridda.lldxyGreen = ptData->lldGdY;
    tridda.lldxyBlue  = ptData->lldBdY;
    tridda.lldxyAlpha = ptData->lldAdY;

    //
    // N0 = integer y starting location
    // M0 = integer x starting location
    // dN = integer delta y
    // dM = integer delta x
    //
    // Arrange lines, must run DDA in positive delta y.
    //

    if (pv2->y >= pv1->y)
    {
        tridda.dN      = pv2->y - pv1->y;
        tridda.dM      = pv2->x - pv1->x;
        tridda.N0      = pv1->y;
        tridda.M0      = pv1->x;
    }
    else
    {
        tridda.dN       = pv1->y - pv2->y;
        tridda.dM       = pv1->x - pv2->x;
        tridda.N0       = pv2->y;
        tridda.M0       = pv2->x;
    }

    //
    // caclulate initial color value at stating vertex
    //

    tridda.llRed   = ptData->lldRdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldRdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +
                     ptData->llRA;

    tridda.llGreen = ptData->lldGdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldGdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +
                     ptData->llGA;

    tridda.llBlue  = ptData->lldBdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldBdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +
                     ptData->llBA;

    tridda.llAlpha = ptData->lldAdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldAdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +
                     ptData->llAA;

    //
    // Check for horizontal line, dN == 0 is a horizontal line.
    // In this case just record the end points.
    //

    if (tridda.dN == 0)
    {
        vHorizontalLine(pv1,pv2,ptData,&tridda);
    }
    else
    {
        LONGLONG l0,Frac;

        tridda.Linc = 1;

        //
        // yIndex is the offset into the edge array for
        // the current line. Calc number of scan lines
        // and maximum y position
        //

        tridda.yIndex = tridda.N0 - ptData->y0;

        tridda.NumScanLines = tridda.dN;

        LONG NMax   = tridda.N0 + tridda.NumScanLines;

        //
        // make sure scan lines do not overrun buffer due to
        // clipping
        //

        if (
             (tridda.N0 > ptData->rcl.bottom) ||
             (NMax < ptData->rcl.top)
           )
        {
            //
            // nothing to draw
            //

            return;
        }
        else if (NMax > ptData->rcl.bottom)
        {
            tridda.NumScanLines = tridda.NumScanLines - (NMax - ptData->rcl.bottom);
        }

        tridda.j = tridda.N0;

        tridda.C = ((LONGLONG)tridda.M0 * (LONGLONG)tridda.dN) - ((LONGLONG)tridda.N0 * (LONGLONG)tridda.dM) -1;

        tridda.C = tridda.C + tridda.dN;

        LONGLONG LongL;

        if (tridda.dM > 0)
        {
            tridda.dL = tridda.dM / tridda.dN;
            tridda.dR = tridda.dM - tridda.dL * tridda.dN;
        }
        else if (tridda.dM < 0)
        {
            //
            // negative divide
            //

            LONG dLQ,dLR;

            tridda.dM = -tridda.dM;

            dLQ = (tridda.dM - 1) / tridda.dN;
            dLR = tridda.dM - 1 - (dLQ * tridda.dN);
            tridda.dL  = -(dLQ + 1);
            tridda.dR  = tridda.dN - dLR - 1;
        }
        else
        {
            //
            // dM = 0
            //

            tridda.dL = 0;
            tridda.dR = 0;
        }

        l0    = tridda.j * tridda.dL;
        LongL = tridda.j * tridda.dR + tridda.C;

        if (LongL > 0)
        {
            Frac = (LONG)(LongL/tridda.dN);
        }
        else if (LongL < 0)
        {
            LONGLONG Q = ((-LongL - 1)/tridda.dN);
            Frac = -(Q + 1);
        }
        else
        {
            Frac = 0;
        }

        tridda.R  = (LONG)(LongL - (Frac * tridda.dN));
        tridda.L  = (LONG)(l0 + Frac);
        tridda.Rb = tridda.dN - tridda.R - 1;

        //
        // Calculate color steps for dx
        //

        tridda.lldxyRed   = tridda.lldxyRed   + (ptData->lldRdX * tridda.dL);
        tridda.lldxyGreen = tridda.lldxyGreen + (ptData->lldGdX * tridda.dL);
        tridda.lldxyBlue  = tridda.lldxyBlue  + (ptData->lldBdX * tridda.dL);
        tridda.lldxyAlpha = tridda.lldxyAlpha + (ptData->lldAdX * tridda.dL);

        //
        // run edge dda
        //

        vEdgeDDA(ptData,&tridda);
    }
}

/**************************************************************************\
* bCalulateColorGradient
*
*   Calculate all color gradients
*
* Arguments:
*
*   pv0,pv1,pv2 - triangle verticies
*   ptData      - triangel data
*
* Return Value:
*
*   status
*
* History:
*
*    5/22/1997 Kirk Olnyk [kirko]
*
\**************************************************************************/

BOOL
bCalulateColorGradient(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData
    )
{
    GRADSTRUCT g;
    LONGLONG d;
    LONG z;

    g.x1 = pv1->x;
    g.y1 = pv1->y;
    g.x2 = pv2->x;
    g.y2 = pv2->y;

    z = pv0->x;
    g.x1 -= z;
    g.x2 -= z;

    z = pv0->y;
    g.y1 -= z;
    g.y2 -= z;

    g.d  = g.x1 * g.y2 - g.x2 * g.y1;

    LONG tx = MIN(g.x1,0);
    LONG ty = MIN(g.y1,0);

    g.m = MIN(tx,g.x2) + MIN(ty,g.y2);

    d = (LONGLONG) ABS(g.d);
    g.Q = (LONGLONG)TWO_TO_THE_48TH / d;
    g.R = (LONGLONG)TWO_TO_THE_48TH % d;

    ptData->ptColorCalcOrg.x = pv0->x;
    ptData->ptColorCalcOrg.y = pv0->y;

    bDoGradient(  &ptData->lldRdX   // &A
                , &ptData->lldRdY   // &B
                , &ptData->llRA     // &C
                , pv0->Red          // R0
                , pv1->Red          // R1
                , pv2->Red          // R2
                , &g             );

    bDoGradient(  &ptData->lldGdX
                , &ptData->lldGdY
                , &ptData->llGA
                , pv0->Green
                , pv1->Green
                , pv2->Green
                , &g             );

    bDoGradient(  &ptData->lldBdX
                , &ptData->lldBdY
                , &ptData->llBA
                , pv0->Blue
                , pv1->Blue
                , pv2->Blue
                , &g             );


    bDoGradient(  &ptData->lldAdX
                , &ptData->lldAdY
                , &ptData->llAA
                , pv0->Alpha
                , pv1->Alpha
                , pv2->Alpha
                , &g             );

    return(TRUE);
}

/**************************************************************************\
* MDiv64
*   64 bit mul-div
*
* Arguments:
*
*   return = (a * b) / c
*
* Return Value:
*
*
*
* History:
*
*    5/22/1997 Kirk Olnyk [kirko]
*
\**************************************************************************/

LONGLONG
MDiv64(
    LONGLONG a,
    LONGLONG b,
    LONGLONG c)
{
    LONGLONG Result;
    int isNegative=0;

    Result = 0;
    if (a != 0 && b != 0)
    {
        if (a < 0)
        {
            a = -a;
            isNegative = 1;
        }
        else if (b < 0)
        {
            b = -b;
            isNegative = 1;
        }
        a = a * b - (LONGLONG) isNegative;
        Result = a / c;
        if (isNegative)
        {
            Result = - Result - 1;
        }
    }
    return(Result);
}

/**************************************************************************\
* bDoGradient
*
*   calc color gradient for one color
*
* Arguments:
*
*   pA
*   pB
*   pC
*   g0
*   g1
*   g2
*   pg
*
* Return Value:
*
*   status
*
* History:
*
*    5/22/1997 Kirk Olnyk   [kirko]
*
\**************************************************************************/

BOOL
bDoGradient(
    LONGLONG *pA,
    LONGLONG *pB,
    LONGLONG *pC,
    LONG g0,
    LONG g1,
    LONG g2,
    GRADSTRUCT *pg
    )
{
    BOOL bDiv(LONGLONG*, LONGLONG, LONG);
    LONGLONG a,b,c,d;

    g1 = g1 - g0;
    g2 = g2 - g0;

    a = g1 * pg->y2 - g2 * pg->y1;
    b = g2 * pg->x1 - g1 * pg->x2;
    d = pg->d;

    if (d < 0)
    {
        a = -a;
        b = -b;
        d = -d;
    }

    *pA = pg->Q * a + MDiv64(a, pg->R, d);
    *pB = pg->Q * b + MDiv64(b, pg->R, d);

    c = (d >> 1) + 1;
    a = c * pg->R - pg->m - 1;
    a /= d;
    a += c * pg->Q;
    a += pg->m;

    *pC = a + (((LONGLONG) g0) << 48);
    return(TRUE);
}

/**************************************************************************\
* lCalculateTriangleArea
*
* Arguments:
*
*  pv0    - vertex
*  pv1    - vertex
*  pv2    - vertex
*  ptData - triangle data
*
* Return Value:
*
*    < 0 = negative area
*    0   = 0 area
*    > 0 = positive area
*
* History:
*
*    2/26/1997 Mark Enstrom [marke]
*
\**************************************************************************/

LONG
lCalculateTriangleArea(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData
    )
{
    LONG lRet;

    //
    // calc area, color gradients in x,y
    //
    // area = (v2-v0) X (v1 - v2)
    //

    LONGLONG v12x = pv1->x - pv2->x;
    LONGLONG v12y = pv1->y - pv2->y;

    LONGLONG v02x = pv0->x - pv2->x;
    LONGLONG v02y = pv0->y - pv2->y;

    LONGLONG Area = (v12y * v02x) - (v12x * v02y);

    if (Area == 0)
    {
        lRet = 0;
    }
    else if (Area > 0)
    {
        lRet = 1;

        if (ptData != NULL)
        {
            ptData->Area = Area;
        }
    }
    else
    {
        lRet = -1;
    }

    return(lRet);
}


/**************************************************************************\
* LIMIT_COLOR
*
*   Actual input colors are limited to 0x0000 - 0xff00
*       256 * (0x00 - 0xff)
*
* Arguments:
*
*   pv - vertex
*
* History:
*
*    2/26/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define LIMIT_COLOR(pv)        \
                               \
    if (pv->Red > 0xff00)      \
    {                          \
        pv->Red = 0xff00;      \
    }                          \
                               \
    if (pv->Green > 0xff00)    \
    {                          \
        pv->Green = 0xff00;    \
    }                          \
                               \
    if (pv->Blue > 0xff00)     \
    {                          \
        pv->Blue = 0xff00;     \
    }

/******************************Public*Routine******************************\
* bCalculateTriangle
*
*   if triangle is too largre, break it in into 2 triangles and call this
*   routine on each (max recursion ~= 16)
*
*   Calculate color gradients, then scan the three lines that make up the
*   triangle. Fill out a structure that can later be used to fill in the
*   interior of the triangle.
*
* Arguments:
*
*   pSurfDst - destination surface
*   pInV0    - vertex
*   pInV1    - vertex
*   pInV2    - vertex
*   ptData   - triangle data
*   pfnG     - surface gradient draw routine
*
* Return Value:
*
*   status
*
* History:
*
*    17-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bCalculateAndDrawTriangle(
    PSURFACE        pSurfDst,
    PTRIVERTEX      pInV0,
    PTRIVERTEX      pInV1,
    PTRIVERTEX      pInV2,
    PTRIANGLEDATA   ptData,
    PFN_GRADIENT    pfnG
    )
{
    BOOL        bStatus = TRUE;
    LONG        index;
    LONG        lStatus;
    PTRIVERTEX  pv0 = pInV0;
    PTRIVERTEX  pv1 = pInV1;
    PTRIVERTEX  pv2 = pInV2;

    {
        PTRIVERTEX pvt;

        //
        // sort in y for line processing
        //

        if (pv0->y > pv1->y)
        {
            SWAP_VERTEX(pv0,pv1,pvt);
        }

        if (pv1->y > pv2->y)
        {
            SWAP_VERTEX(pv1,pv2,pvt);
        }

        if (pv0->y > pv1->y)
        {
            SWAP_VERTEX(pv0,pv1,pvt);
        }

        lStatus = lCalculateTriangleArea(pv0,pv1,pv2,ptData);

        //
        // if area is zero then this is a degenerate triangle
        //

        if (lStatus == 0)
        {
            return(FALSE);
        }
        else if (lStatus <0)
        {
            //
            // negative area, swap pv1 and pv2 and recalcualte
            //

            SWAP_VERTEX(pv1,pv2,pvt);

            lStatus = lCalculateTriangleArea(pv0,pv1,pv2,ptData);

            if (lStatus == 0)
            {
                return(FALSE);
            }
            else if (lStatus <0)
            {
                WARNING1("Triangle Area still negative after vertex swap\n");
                return(FALSE);
            }
        }

        //
        // calc min and max drawing y
        //

        ptData->y0   = MAX(pv0->y,ptData->rcl.top);
        LONG MaxY    = MAX(pv1->y,pv2->y);
        ptData->y1   = MIN(MaxY,ptData->rcl.bottom);

        {
            //
            // init ptdata
            //

            LONG lIndex;

            for (lIndex=0;lIndex<(ptData->y1-ptData->y0);lIndex++)
            {
                ptData->TriEdge[lIndex].xLeft  = LONG_MAX;
                ptData->TriEdge[lIndex].xRight = LONG_MIN;
            }
        }

        //
        // calculate color gradients for each color. There is a little redundant
        // work here with calculation of deltas. Should make this one call or
        // do it in place.
        //

        LIMIT_COLOR(pv0);
        LIMIT_COLOR(pv1);
        LIMIT_COLOR(pv2);

        bCalulateColorGradient(pv0,pv1,pv2,ptData);

        //
        // draw lines into data array
        //

        vCalculateLine(pv0,pv1,ptData);
        vCalculateLine(pv1,pv2,ptData);
        vCalculateLine(pv2,pv0,ptData);

        pfnG(pSurfDst,ptData);
    }

    return(bStatus);
}

/**************************************************************************\
* bIsTriangleInBounds
*
*   Is triangle inside bounding rect
*
* Arguments:
*
*   pInV0  - vertex 0
*   pInV1  - vertex 1
*   pInV2  - vertex 2
*   ptData - triangle data
*
* Return Value:
*
*   TRUE in any of the triangle is contained in bounding rect
*
* History:
*
*    5/8/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bIsTriangleInBounds(
    PTRIVERTEX      pInV0,
    PTRIVERTEX      pInV1,
    PTRIVERTEX      pInV2,
    PTRIANGLEDATA   ptData
    )
{
    PRECTL prclClip = &ptData->rcl;

    RECTL  rclTri;

    rclTri.left   = MIN(pInV0->x,pInV1->x);
    rclTri.right  = MAX(pInV0->x,pInV1->x);
    rclTri.top    = MIN(pInV0->y,pInV1->y);
    rclTri.bottom = MAX(pInV0->y,pInV1->y);

    rclTri.left   = MIN(rclTri.left,pInV2->x);
    rclTri.right  = MAX(rclTri.right,pInV2->x);
    rclTri.top    = MIN(rclTri.top,pInV2->y);
    rclTri.bottom = MAX(rclTri.bottom,pInV2->y);

    if ((rclTri.left   >= prclClip->right) ||
        (rclTri.right  <= prclClip->left)  ||
        (rclTri.top    >= prclClip->bottom) ||
        (rclTri.bottom <= prclClip->top))
    {
        return(FALSE);
    }

    return(TRUE);
}

/**************************************************************************\
* bTriangleNeedSplit
*   determine whether triangle needs split
*
* Arguments:
*
*   pv0,pv1,pv2 - triangle vertex
*
* Return Value:
*
*   TRUE if triangle needs to be split
*
* History:
*
*    5/8/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bTriangleNeedsSplit(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2
    )
{
    //
    // calc dx,dy for each leg
    //

    LONG dx01 = ABS(pv0->x - pv1->x);
    LONG dy01 = ABS(pv0->y - pv1->y);

    LONG dx02 = ABS(pv0->x - pv2->x);
    LONG dy02 = ABS(pv0->y - pv2->y);

    LONG dx12 = ABS(pv1->x - pv2->x);
    LONG dy12 = ABS(pv1->y - pv2->y);

    //
    // if any length is longer than max, break triangle into two pieces
    // and call this routine for each
    //

    if (
         (
           (dx01 > MAX_EDGE_LENGTH) || (dy01 > MAX_EDGE_LENGTH) ||
           (dx02 > MAX_EDGE_LENGTH) || (dy02 > MAX_EDGE_LENGTH) ||
           (dx12 > MAX_EDGE_LENGTH) || (dy12 > MAX_EDGE_LENGTH)
         )
       )
    {
        return(TRUE);
    }

    return(FALSE);
}

/**************************************************************************\
* bSplitTriangle
*   Determine is triangle must be split.
*   Split triangle along longest edge
*
* Arguments:
*
*   pv0,pv1,pv2 - triangle
*   pvNew       - new vertex
*   pGrad       - mesh
*
* Return Value:
*
*   TRUE if split, FALSE otherwise
*
* History:
*
*    5/8/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bSplitTriangle(
    PTRIVERTEX           pVert,
    PULONG               pFreeVert,
    PGRADIENT_TRIANGLE   pMesh,
    PULONG               pFreeMesh,
    PULONG               pRecurseLevel
    )
{
    BOOL bStatus = FALSE;

    ULONG CurrentMesh = (*pFreeMesh) - 1;

    ULONG ulTM0 = pMesh[CurrentMesh].Vertex1;
    ULONG ulTM1 = pMesh[CurrentMesh].Vertex2;
    ULONG ulTM2 = pMesh[CurrentMesh].Vertex3;

    PTRIVERTEX         pv0 = &pVert[ulTM0];
    PTRIVERTEX         pv1 = &pVert[ulTM1];
    PTRIVERTEX         pv2 = &pVert[ulTM2];

    PTRIVERTEX         pvT0 = pv0;
    PTRIVERTEX         pvT1 = pv1;
    PTRIVERTEX         pvT2 = pv2;

    TRIVERTEX          triNew;

    //
    // find longest edge
    //

    LONGLONG dx01 = ABS(pv0->x - pv1->x);
    LONGLONG dy01 = ABS(pv0->y - pv1->y);

    LONGLONG dx02 = ABS(pv0->x - pv2->x);
    LONGLONG dy02 = ABS(pv0->y - pv2->y);

    LONGLONG dx12 = ABS(pv1->x - pv2->x);
    LONGLONG dy12 = ABS(pv1->y - pv2->y);

    //
    // determine if triangle needs to be split
    //

    if (
         (
           (dx01 > MAX_EDGE_LENGTH) || (dy01 > MAX_EDGE_LENGTH) ||
           (dx02 > MAX_EDGE_LENGTH) || (dy02 > MAX_EDGE_LENGTH) ||
           (dx12 > MAX_EDGE_LENGTH) || (dy12 > MAX_EDGE_LENGTH)
         )
       )
    {
        //
        // make sure this is a triangle
        //

        if (lCalculateTriangleArea(pv0,pv1,pv2,NULL) != 0)
        {
            //
            // Find longest edge, swap verticies so edge 0-1 is
            // longest.
            //

            LONGLONG d01Max = dx01 * dx01 + dy01 * dy01;
            LONGLONG d02Max = dx02 * dx02 + dy02 * dy02;
            LONGLONG d12Max = dx12 * dx12 + dy12 * dy12;

            if (d01Max > d02Max)
            {
                if (d01Max > d12Max)
                {
                    //
                    // d01 largest, default
                    //

                }
                else
                {
                    //
                    // d12 largest, swap 0 and 2
                    //

                    pvT0  = pv2;
                    pvT2  = pv0;
                    ulTM0 = pMesh[CurrentMesh].Vertex3;
                    ulTM2 = pMesh[CurrentMesh].Vertex1;
                }
            }
            else
            {
                if (d02Max > d12Max)
                {
                    //
                    // d02 largest, swap 1,2
                    //

                    pvT1  = pv2;
                    pvT2  = pv1;
                    ulTM1 = pMesh[CurrentMesh].Vertex3;
                    ulTM2 = pMesh[CurrentMesh].Vertex2;
                }
                else
                {
                    //
                    // d12 largest, swap 0,2
                    //

                    pvT0  = pv2;
                    pvT2  = pv0;
                    ulTM0 = pMesh[CurrentMesh].Vertex3;
                    ulTM2 = pMesh[CurrentMesh].Vertex1;
                }
            }

            //
            // 2 new triangles 0,2,N and 1,2,N  (float)
            //

            {
                EFLOAT fpA,fpB;
                EFLOAT fTwo;
                LONG   lTemp;

                fTwo = (LONG)2;

                fpA = pvT0->x;
                fpB = pvT1->x;
                fpB-=(fpA);
                fpB/=(fTwo);
                fpA+=(fpB);

                fpA.bEfToL(triNew.x);

                fpA = pvT0->y;
                fpB = pvT1->y;
                fpB-=(fpA);
                fpB/=(fTwo);
                fpA+=(fpB);
                fpA.bEfToL(triNew.y);

                fpA = (LONG)pvT0->Red;
                fpB = (LONG)pvT1->Red;
                fpB-=(fpA);
                fpB/=(fTwo);
                fpA+=(fpB);
                fpA.bEfToL(lTemp);
                triNew.Red = (USHORT)lTemp;

                fpA = (LONG)pvT0->Green;
                fpB = (LONG)pvT1->Green;
                fpB-=(fpA);
                fpB/=(fTwo);
                fpA+=(fpB);
                fpA.bEfToL(lTemp);
                triNew.Green = (USHORT)lTemp;

                fpA = (LONG)pvT0->Blue;
                fpB = (LONG)pvT1->Blue;
                fpB-=(fpA);
                fpB/=(fTwo);
                fpA+=(fpB);
                fpA.bEfToL(lTemp);
                triNew.Blue = (USHORT)lTemp;

                fpA = (LONG)pvT0->Alpha;
                fpB = (LONG)pvT1->Alpha;
                fpB-=(fpA);
                fpB/=(fTwo);
                fpA+=(fpB);
                fpA.bEfToL(lTemp);
                triNew.Alpha = (USHORT)lTemp;
            }

            //
            // add new entry to vertex array and two new entries to mesh array
            //
            // 0,2,New and 1,2,New
            //

            ULONG FreeVert = *pFreeVert;
            ULONG FreeMesh = *pFreeMesh;

            pVert[FreeVert] = triNew;

            pMesh[FreeMesh].Vertex1   = ulTM0;
            pMesh[FreeMesh].Vertex2   = ulTM2;
            pMesh[FreeMesh].Vertex3   = FreeVert;

            pMesh[FreeMesh+1].Vertex1 = ulTM1;
            pMesh[FreeMesh+1].Vertex2 = ulTM2;
            pMesh[FreeMesh+1].Vertex3 = FreeVert;

            pRecurseLevel[FreeMesh]   = 1;
            pRecurseLevel[FreeMesh+1] = 0;

            *pFreeMesh += 2;
            *pFreeVert += 1;

            bStatus = TRUE;
        }
        else
        {
            WARNING("bSplitTriangle:Error: triangle area = 0\n\n");
        }
    }

    return(bStatus);
}

/**************************************************************************\
* bTriangleMesh
*
*   Draw each triangle. If triangle is too big, then split.
*
* Arguments:
*
*   pSurfDst        - destination surface
*   pxlo            - xlate
*   pVertex         - pointer to vertex array
*   nVertex         - elements in vertex array
*   pMesh           - pointer to mesh array
*   nMesh           - elements in mesh array
*   ulMode          - draw mode
*   prclClip        - clip rect
*   prclMeshExtents - triangle extents rect
*   pptlDitherOrg   - dither org
*
* Return Value:
*
*   Status
*
* History:
*
*    5/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bTriangleMesh(
    PSURFACE                pSurfDst,
    XLATEOBJ               *pxlo,
    PTRIVERTEX              pVertex,
    ULONG                   nVertex,
    PGRADIENT_TRIANGLE      pMesh,
    ULONG                   nMesh,
    ULONG                   ulMode,
    PRECTL                  prclClip,
    PRECTL                  prclMeshExtents,
    PPOINTL                 pptlDitherOrg
    )
{
    PFN_GRADIENT pfnG;
    PFN_GRADRECT pfnTemp;
    BOOL bStatus = TRUE;
    LONG   dyTri = prclClip->bottom - prclClip->top;
    PTRIANGLEDATA ptData;

    //
    // allocate structure to hold scan line data for all triangles
    // drawn during this call
    //

    ptData = (PTRIANGLEDATA)PALLOCMEM(sizeof(TRIANGLEDATA) + (dyTri-1) * sizeof(TRIEDGE),'gdEg');

    if (ptData)
    {
        //
        // find a palette for the output surface
        //

        XEPALOBJ epal(pSurfDst->ppal());

        if (!epal.bValid())
        {
            PDEVOBJ  pdo(pSurfDst->hdev());
            epal.ppalSet(pdo.ppalSurf());
        }

        if (epal.bValid())
        {
            //
            // find out scan line routine to use to draw pixels
            //

            bDetermineTriangleFillRoutine(pSurfDst,&epal,&pfnG,&pfnTemp);
             
            //
            // Init global data
            //

            ptData->rcl         = *prclClip;
            ptData->DrawMode    = ulMode;
            ptData->pxlo        = pxlo;
            ptData->ppalDstSurf = &epal;
            ptData->ptDitherOrg = *pptlDitherOrg;

            //
            // if triangle does not need to be split, draw each one.
            // Triangles need to be split if any edge exceeds a length
            // that will cause math problems.
            //

            if  (
                 ((prclMeshExtents->right  - prclMeshExtents->left) < MAX_EDGE_LENGTH) &&
                 ((prclMeshExtents->bottom - prclMeshExtents->top) < MAX_EDGE_LENGTH)
                 )
            {
                //
                // no split needed
                //

                ULONG ulIndex;
                for (ulIndex = 0;ulIndex<nMesh;ulIndex++)
                {
                    PTRIVERTEX pv0 = &pVertex[pMesh[ulIndex].Vertex1];
                    PTRIVERTEX pv1 = &pVertex[pMesh[ulIndex].Vertex2];
                    PTRIVERTEX pv2 = &pVertex[pMesh[ulIndex].Vertex3];

                    if (bIsTriangleInBounds(pv0,pv1,pv2,ptData))
                    {
                        bStatus = bCalculateAndDrawTriangle(pSurfDst,pv0,pv1,pv2,ptData,pfnG);
                    }
                }
            }
            else
            {
                //
                // some triangles exceed maximum length, need to scan through triangles
                // and split triangles that exceed maximum edge length. This routine
                // works in a pseudo recursive manner, by splitting one triangle, then
                // splitting one of those 2 and so on. maximum depth is:
                //
                // 2 * ((log(2)(max dx,dy)) - 10)
                //
                // 10 = log(2) MAX_EDGE_LENGTH (2^14)
                // LOG(2)(2^28) = 28
                //
                // 2 * (28 - 14) = 28
                //

                ULONG              ulMaxVertex = nVertex + 28;
                ULONG              ulMaxMesh   = nMesh   + 28;
                PBYTE              pAlloc      = NULL;
                ULONG              ulSizeAlloc = (sizeof(TRIVERTEX) * ulMaxVertex) +
                                                 (sizeof(GRADIENT_TRIANGLE) * ulMaxMesh) +
                                                 (sizeof(ULONG) * ulMaxMesh);

                pAlloc = (PBYTE)PALLOCNOZ(ulSizeAlloc,'tvtG');

                if (pAlloc != NULL)
                {
                    //
                    // assign buffers
                    //

                    PTRIVERTEX         pTempVertex = (PTRIVERTEX)pAlloc;
                    PGRADIENT_TRIANGLE pTempMesh   = (PGRADIENT_TRIANGLE)(pAlloc + (sizeof(TRIVERTEX) * ulMaxVertex));
                    PULONG             pRecurse    = (PULONG)((PBYTE)pTempMesh + (sizeof(GRADIENT_TRIANGLE) * ulMaxMesh));

                    //
                    // copy initial triangle information
                    //

                    memcpy(pTempVertex,pVertex,sizeof(TRIVERTEX) * nVertex);
                    memcpy(pTempMesh,pMesh,sizeof(TRIVERTEX) * nMesh);
                    memset(pRecurse,0,nMesh * sizeof(ULONG));

                    //
                    // next free location in vertex and mesh arrays
                    //

                    ASSERTGDI(nMesh > 0, "bTriangleMesh: bad nMesh\n");

                    ULONG FreeVertex    = nVertex;
                    ULONG FreeMesh      = nMesh;

                    do
                    {
                        BOOL bSplit = FALSE;

                        //
                        // always operate on the last triangle in array
                        //

                        ULONG CurrentMesh = FreeMesh - 1;


                        //
                        // validate mesh pointers
                        //

                        if (
                            (pTempMesh[CurrentMesh].Vertex1 >= ulMaxVertex) ||
                            (pTempMesh[CurrentMesh].Vertex2 >= ulMaxVertex) ||
                            (pTempMesh[CurrentMesh].Vertex3 >= ulMaxVertex)
                            )
                        {
                             RIP("Error in triangle split routine:Vertex out of range\n");
                             break;
                        }

                        PTRIVERTEX pv0 = &pTempVertex[pTempMesh[CurrentMesh].Vertex1];
                        PTRIVERTEX pv1 = &pTempVertex[pTempMesh[CurrentMesh].Vertex2];
                        PTRIVERTEX pv2 = &pTempVertex[pTempMesh[CurrentMesh].Vertex3];

                        //
                        // check if triangle boundary is inside clip rect
                        //

                        if (bIsTriangleInBounds(pv0,pv1,pv2,ptData))
                        {
                            bSplit = bSplitTriangle(pTempVertex,&FreeVertex,pTempMesh,&FreeMesh,pRecurse);

                            if (!bSplit)
                            {
                                //
                                // draw triangle
                                //

                                bStatus = bCalculateAndDrawTriangle(pSurfDst,pv0,pv1,pv2,ptData,pfnG);
                            }
                            else
                            {

                                //
                                // validate array indcies
                                //

                                if ((FreeVertex > ulMaxVertex) ||
                                    (FreeMesh   > ulMaxMesh))
                                {
                                    RIP("Error in triangle split routine: indicies out of range\n");
                                    break;
                                }
                            }
                        }

                        //
                        // if triangle was not split, then remove from list.
                        //

                        if (!bSplit)
                        {

                            //
                            // remove triangle just drawn. If this is the second triangle of a
                            // split, then remove the added vertex and the original triangle as
                            // well
                            //

                            do
                            {

                                FreeMesh--;

                                if (pRecurse[FreeMesh])
                                {
                                     FreeVertex--;
                                }

                            } while ((FreeMesh != 0) && (pRecurse[FreeMesh] == 1));
                        }

                    } while (FreeMesh != 0);

                    VFREEMEM(pAlloc);
                }
                else
                {
                    WARNING1("Memory allocation failed for temp triangle buffers\n");
                    bStatus = FALSE;
                }
            }
        }
        else
        {
            RIP("EngGradientFill:Error reading palette from surface\n");
            bStatus = FALSE;
        }

        //
        // free triangle data buffer
        //

        VFREEMEM(ptData);
    }
    else
    {
        bStatus = FALSE;
    }

    return(bStatus);
}


/**************************************************************************\
* vCalcRectOffsets
*
*   calc params for gradient rect
*
* Arguments:
*
*   pGradRect - gradietn rect data
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bCalcGradientRectOffsets(
    PGRADIENTRECTDATA pGradRect
    )
{
    LONG yScanTop     = MAX(pGradRect->rclClip.top,pGradRect->rclGradient.top);
    LONG yScanBottom  = MIN(pGradRect->rclClip.bottom,pGradRect->rclGradient.bottom);
    LONG yScanLeft    = MAX(pGradRect->rclClip.left,pGradRect->rclGradient.left);
    LONG yScanRight   = MIN(pGradRect->rclClip.right,pGradRect->rclGradient.right);

    //
    // calc actual widht, check for early out
    //

    pGradRect->ptDraw.x = yScanLeft;
    pGradRect->ptDraw.y = yScanTop;
    pGradRect->szDraw.cx = yScanRight  - yScanLeft;
    pGradRect->szDraw.cy = yScanBottom - yScanTop;

    LONG ltemp = pGradRect->rclClip.left - pGradRect->rclGradient.left;

    if (ltemp <= 0)
    {
        ltemp = 0;
    }

    pGradRect->xScanAdjust  = ltemp;

    ltemp = pGradRect->rclClip.top  - pGradRect->rclGradient.top;

    if (ltemp <= 0)
    {
        ltemp = 0;
    }

    pGradRect->yScanAdjust = ltemp;

    return((pGradRect->szDraw.cx > 0) && (pGradRect->szDraw.cy > 0));
}

/**************************************************************************\
* bRectangleMesh
*
*   Draw rectangle mesh
*
* Arguments:
*
*   pSurfDst      - destination surface
*   pxlo          - clip obj
*   pVertex       - vertex list
*   nVertex       - # in vertex list
*   pMesh         - mesh list
*   nMesh         - # in mesh list
*   ulMode        - draw mode and attributes
*   prclClip      - bounding rect
*   pptlDitherOrg - dither org
*
* Return Value:
*
*   status
*
* History:
*
*    2/17/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bRectangleMesh(
    PSURFACE        pSurfDst,
    XLATEOBJ       *pxlo,
    PTRIVERTEX      pVertex,
    ULONG           nVertex,
    PGRADIENT_RECT  pMesh,
    ULONG           nMesh,
    ULONG           ulMode,
    PRECTL          prclClip,
    PPOINTL         pptlDitherOrg
    )
{
    PFN_GRADIENT pfnTemp;
    PFN_GRADRECT pfnG;
    BOOL         bStatus = TRUE;
    LONG         dyTri   = prclClip->bottom - prclClip->top;

    GRADIENTRECTDATA grData;

    XEPALOBJ epal(pSurfDst->ppal());

    if (!epal.bValid())
    {
        PDEVOBJ  pdo(pSurfDst->hdev());
        epal.ppalSet(pdo.ppalSurf());
    }


    if (epal.bValid())
    {
        //
        // find out scan line routine to use to draw pixels
        //

        bDetermineTriangleFillRoutine(pSurfDst,&epal,&pfnTemp,&pfnG);

        grData.pxlo        = pxlo;
        grData.ppalDstSurf = &epal;
        grData.ptDitherOrg = *pptlDitherOrg;

        //
        // draw each rectangle
        //

        grData.rclClip   = *prclClip;

        ULONG ulIndex;

        for (ulIndex=0;ulIndex<nMesh;ulIndex++)
        {
            ULONG ulRect0 = pMesh[ulIndex].UpperLeft;
            ULONG ulRect1 = pMesh[ulIndex].LowerRight;

            //
            // make sure index are in array
            //

            if (
                (ulRect0 > (nVertex-1)) ||
                (ulRect1 > (nVertex-1))
            )
            {
                bStatus = FALSE;
                break;
            }

            TRIVERTEX  tvert0 = pVertex[ulRect0];
            TRIVERTEX  tvert1 = pVertex[ulRect1];
            PTRIVERTEX pv0 = &tvert0;
            PTRIVERTEX pv1 = &tvert1;
            PTRIVERTEX pvt;

            //
            // make sure rectangle endpoints are properly ordered
            //

            if (ulMode == GRADIENT_FILL_RECT_H)
            {

                if (pv0->x > pv1->x)
                {
                    SWAP_VERTEX(pv0,pv1,pvt);
                }

                if (pv0->y > pv1->y)
                {
                    //
                    // must swap y
                    //

                    LONG ltemp = pv1->y;
                    pv1->y = pv0->y;
                    pv0->y = ltemp;

                }
            }
            else
            {
                
                if (pv0->y > pv1->y)
                {
                    SWAP_VERTEX(pv0,pv1,pvt);
                }


                if (pv0->x > pv1->x)
                {

                    //
                    // must swap x
                    //

                    LONG ltemp = pv1->x;
                    pv1->x = pv0->x;
                    pv0->x = ltemp;
                }
            }

            //
            // gradient definition rectangle
            //

            grData.rclGradient.left   = pv0->x;
            grData.rclGradient.top    = pv0->y;

            grData.rclGradient.right  = pv1->x;
            grData.rclGradient.bottom = pv1->y;

            grData.ulMode  = ulMode;

            LONG dxGrad = grData.rclGradient.right  - grData.rclGradient.left;
            LONG dyGrad = grData.rclGradient.bottom - grData.rclGradient.top;

            //
            // make sure rect not empty
            //

            if ((dxGrad > 0) && (dyGrad > 0))
            {

                //
                // calculate color gradients for x and y
                //

                grData.llRed   = ((LONGLONG)pv0->Red)   << 40;
                grData.llGreen = ((LONGLONG)pv0->Green) << 40;
                grData.llBlue  = ((LONGLONG)pv0->Blue)  << 40;
                grData.llAlpha = ((LONGLONG)pv0->Alpha) << 40;

                if (ulMode == GRADIENT_FILL_RECT_H)
                {

                    grData.lldRdY = 0;
                    grData.lldGdY = 0;
                    grData.lldBdY = 0;
                    grData.lldAdY = 0;

                    LONGLONG lldRed   = (LONGLONG)(pv1->Red)   << 40;
                    LONGLONG lldGreen = (LONGLONG)(pv1->Green) << 40;
                    LONGLONG lldBlue  = (LONGLONG)(pv1->Blue)  << 40;
                    LONGLONG lldAlpha = (LONGLONG)(pv1->Alpha) << 40;

                    lldRed   -= (LONGLONG)(pv0->Red)   << 40;
                    lldGreen -= (LONGLONG)(pv0->Green) << 40;
                    lldBlue  -= (LONGLONG)(pv0->Blue)  << 40;
                    lldAlpha -= (LONGLONG)(pv0->Alpha) << 40;

                    grData.lldRdX = MDiv64(lldRed  ,(LONGLONG)1,(LONGLONG)dxGrad);
                    grData.lldGdX = MDiv64(lldGreen,(LONGLONG)1,(LONGLONG)dxGrad);
                    grData.lldBdX = MDiv64(lldBlue ,(LONGLONG)1,(LONGLONG)dxGrad);
                    grData.lldAdX = MDiv64(lldAlpha,(LONGLONG)1,(LONGLONG)dxGrad);
                }
                else
                {

                    grData.lldRdX = 0;
                    grData.lldGdX = 0;
                    grData.lldBdX = 0;
                    grData.lldAdX = 0;

                    LONGLONG lldRed   = (LONGLONG)(pv1->Red)   << 40;
                    LONGLONG lldGreen = (LONGLONG)(pv1->Green) << 40;
                    LONGLONG lldBlue  = (LONGLONG)(pv1->Blue)  << 40;
                    LONGLONG lldAlpha = (LONGLONG)(pv1->Alpha) << 40;

                    lldRed   -= (LONGLONG)(pv0->Red)   << 40;
                    lldGreen -= (LONGLONG)(pv0->Green) << 40;
                    lldBlue  -= (LONGLONG)(pv0->Blue)  << 40;
                    lldAlpha -= (LONGLONG)(pv0->Alpha) << 40;

                    grData.lldRdY = MDiv64(lldRed  ,(LONGLONG)1,(LONGLONG)dyGrad);
                    grData.lldGdY = MDiv64(lldGreen,(LONGLONG)1,(LONGLONG)dyGrad);
                    grData.lldBdY = MDiv64(lldBlue ,(LONGLONG)1,(LONGLONG)dyGrad);
                    grData.lldAdY = MDiv64(lldAlpha,(LONGLONG)1,(LONGLONG)dyGrad);
                }

                //
                // calculate common offsets
                //

                if (bCalcGradientRectOffsets(&grData))
                {

                    //
                    // call specific drawing routine if output
                    // not totally clipped
                    //

                    (*pfnG)(pSurfDst,&grData);
                }
            }
        }
    }
    else
    {
        WARNING("bRectangleMesh: can't get surface palette\n");
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* EngGradientFill
*
*   Draw gradient fill to memory surface. If complex clipping is used, then
*   draw to a temp dib and blt to destination through clip.
*
* Arguments:
*
*  psoDst   - destination surface
*  pco      - clip obj
*  pVertex  - vertex list
*  nVertex  - # in vertex list
*  pMesh    - mesh list
*  nMesh    - # in mesh list
*  ulMode   - draw mode and attributes
*
* Return Value:
*
*   Status
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
APIENTRY
EngGradientFill(
    SURFOBJ         *psoDst,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    TRIVERTEX       *pVertex,
    ULONG            nVertex,
    PVOID            pMesh,
    ULONG            nMesh,
    RECTL           *prclExtents,
    POINTL          *ptlDitherOrg,
    ULONG            ulMode
    )
{
    ASSERTGDI(psoDst != NULL, "ERROR EngGradientFill: No destination surface\n");

    BOOL     bStatus     = TRUE;
    PSURFACE pSurfDst    = SURFOBJ_TO_SURFACE(psoDst);
    PSURFACE pSurfDstTmp = NULL;
    ULONG    ulTri;
    BOOL     bForceDstAlloc = FALSE;
    BOOL     bAllocDstSurf = FALSE;
    RECTL    rclDstTrim;
    RECTL    rclDstWk;
    CLIPOBJ *pcoDstWk = pco;
    SURFMEM  surfTmpDst;
    ULONG    ulIndex;
    PDEVOBJ pdo(pSurfDst->hdev());
    BOOL     bCopyFromDst = TRUE;

    ASSERTGDI(pdo.bValid(), "Invalid HDEV");
    ASSERTGDI((ulMode == GRADIENT_FILL_TRIANGLE) ||
              (ulMode == GRADIENT_FILL_RECT_H)   ||
              (ulMode == GRADIENT_FILL_RECT_V),
        "Invalid gradient mode");

    //
    // sync with driver
    //

    {
        pdo.vSync(psoDst,NULL,0);
    }

    //
    // trim rclDst to clip bounding box
    //

    rclDstTrim = *prclExtents;

    //
    // clip extents to destination clip rect
    //

    if ((pco != NULL) && (pco->iDComplexity > DC_TRIVIAL))
    {
        if (rclDstTrim.left < pco->rclBounds.left)
        {
            rclDstTrim.left = pco->rclBounds.left;
        }

        if (rclDstTrim.right > pco->rclBounds.right)
        {
            rclDstTrim.right = pco->rclBounds.right;
        }

        if (rclDstTrim.top < pco->rclBounds.top)
        {
            rclDstTrim.top = pco->rclBounds.top;
        }

        if (rclDstTrim.bottom > pco->rclBounds.bottom)
        {
            rclDstTrim.bottom = pco->rclBounds.bottom;
        }
    }

    //
    // rclDstWk specifies size of temp surface needed (if temp surface is created)
    // coordinates in this temp surface are referenced to prclExtents, even though the
    // surface may be clipped to a smaller extent
    //

    rclDstWk = rclDstTrim;

    //
    // Force Complex clipping to go through temp surface
    //

    if ((pco != NULL) &&
        (pco->iDComplexity != DC_TRIVIAL) &&
        (pco->iDComplexity != DC_RECT))
    {
        bForceDstAlloc = TRUE;
    }

    //
    // get a dst surface that can be written to, remember since it will have to
    // be written back.
    //

    //
    // If the gradient fill shape is a rectangle, we don't need
    // to copy bits from the destination since they'll all
    // be overwritten
    //

    if ((ulMode == GRADIENT_FILL_RECT_H) || 
        (ulMode == GRADIENT_FILL_RECT_V))
    {
        bCopyFromDst = FALSE;
    }
 
    pSurfDstTmp = psSetupDstSurface(
                       pSurfDst,
                       &rclDstWk,
                       surfTmpDst,
                       bForceDstAlloc,
                       bCopyFromDst);


    if (pSurfDstTmp != NULL)
    {
        if (pSurfDstTmp != pSurfDst)
        {
            bAllocDstSurf = TRUE;
        }

        if (bAllocDstSurf)
        {
            //
            // drawing lies completely in temp rectangle, src surface is read
            // into tmp DIB before drawing, so no clipping is needed when this
            // is copied to destination surface
            //

            pcoDstWk = NULL;

            //
            // subtract rect origin
            //

            for (ulIndex=0;ulIndex<nVertex;ulIndex++)
            {
                pVertex[ulIndex].x -= rclDstTrim.left;
                pVertex[ulIndex].y -= rclDstTrim.top;
            }

            //
            // adjust dither org
            //

            ptlDitherOrg->x += rclDstTrim.left;
            ptlDitherOrg->y += rclDstTrim.top;
        }

        //
        // limit recorded triangle to clipped output
        //

        ERECTL *prclClip;
        LONG   dyTri = rclDstWk.bottom - rclDstWk.top;

        if ((pcoDstWk == NULL) || (pcoDstWk->iDComplexity == DC_TRIVIAL))
        {
            prclClip = NULL;
        }
        else
        {
            prclClip = (ERECTL *)&pcoDstWk->rclBounds;
        }

    //
    // draw gradients   
    //

    if (ulMode == GRADIENT_FILL_TRIANGLE)
    {
       bStatus = bTriangleMesh(pSurfDstTmp,
                   pxlo,
                   pVertex,
                   nVertex,
                   (PGRADIENT_TRIANGLE)pMesh,
                   nMesh,
                   ulMode,
                   &rclDstWk,
                   prclExtents,
                   ptlDitherOrg
                   );
        }
    else 
    {
       ASSERTGDI((ulMode == GRADIENT_FILL_RECT_H) ||
             (ulMode == GRADIENT_FILL_RECT_V),
                     "Unhandle 'ulMode'");

           bStatus = bRectangleMesh(
                   pSurfDstTmp,
                   pxlo,
                   pVertex,
                   nVertex,
                   (PGRADIENT_RECT)pMesh,
                   nMesh,
                   ulMode,
                   &rclDstWk,
                   ptlDitherOrg
                   );

    }

        //
        // write temp destination surface to real dst
        //

        if (bAllocDstSurf)
        {
            PDEVOBJ pdoDst(pSurfDst->hdev());

            ASSERTGDI(pdoDst.bValid(), "Invalid HDEV");

            POINTL ptlCopy = {0,0};

            (*PPFNGET(pdoDst,CopyBits,pSurfDst->flags()))(
                      pSurfDst->pSurfobj(),
                      pSurfDstTmp->pSurfobj(),
                      pco,
                      &xloIdent,
                      &rclDstTrim,
                      &ptlCopy);

            //
            // undo temporary offseting
            //

            for (ulIndex=0;ulIndex<nVertex;ulIndex++)
            {
                pVertex[ulIndex].x += rclDstTrim.left;
                pVertex[ulIndex].y += rclDstTrim.top;
            }

            ptlDitherOrg->x -= rclDstTrim.left;
            ptlDitherOrg->y -= rclDstTrim.top;
        }
    }
    else
    {
        EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        bStatus = FALSE;
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* vCalcMeshExtent
*
*   Verify mesh, calculate bounding rect of drawing.
*
* Arguments:
*
*  pVertex - vertex array
*  nVertex - number of vertex in array
*  pMesh   - array of rect or tri
*  nMesh   - number in mesh array
*  ulMode  - triangle or rectangle
*  prclExt - return extent rect
*
* Return Value:
*
*  TRUE if mesh is valid
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bCalcMeshExtent(
    PTRIVERTEX  pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    ULONG       ulMode,
    RECTL       *prclExt
    )
{
    LONG xmin = LONG_MAX;
    LONG xmax = LONG_MIN;
    LONG ymin = LONG_MAX;
    LONG ymax = LONG_MIN;

    BOOL bRet = TRUE;

    ULONG ulIndex;

    //
    // triangle or rectangle case
    //

    if (
         (ulMode ==GRADIENT_FILL_RECT_H) ||
         (ulMode == GRADIENT_FILL_RECT_V)
       )
    {
        //
        // verify rectangle mesh, remember extents
        //

        PGRADIENT_RECT pGradRect = (PGRADIENT_RECT)pMesh;

        for (ulIndex=0;ulIndex<nMesh;ulIndex++)
        {
            RECTL rcl;

            ULONG vul = pGradRect->UpperLeft;
            ULONG vlr = pGradRect->LowerRight;

            if ((vul <= nVertex) && (vlr <= nVertex))
            {
                LONG VertLeftX  = pVertex[vul].x;
                LONG VertLeftY  = pVertex[vul].y;
                LONG VertRightX = pVertex[vlr].x;
                LONG VertRightY = pVertex[vlr].y;

                if (VertLeftX < xmin)
                {
                    xmin = VertLeftX;
                }

                if (VertLeftX > xmax)
                {
                    xmax = VertLeftX;
                }

                if (VertLeftY < ymin)
                {
                    ymin = VertLeftY;
                }

                if (VertLeftY > ymax)
                {
                    ymax = VertLeftY;
                }

                if (VertRightX < xmin)
                {
                    xmin = VertRightX;
                }

                if (VertRightX > xmax)
                {
                    xmax = VertRightX;
                }

                if (VertRightY < ymin)
                {
                    ymin = VertRightY;
                }

                if (VertRightY > ymax)
                {
                    ymax = VertRightY;
                }
            }
            else
            {
                //
                // error in mesh/vertex array, return null
                // bounding rect
                //

                prclExt->left   = 0;
                prclExt->right  = 0;
                prclExt->top    = 0;
                prclExt->bottom = 0;

                return(FALSE);
            }

            pGradRect++;
        }
    }
    else if (ulMode == GRADIENT_FILL_TRIANGLE)
    {
        //
        // verify triangle mesh, remember extents
        //

        PGRADIENT_TRIANGLE pGradTri = (PGRADIENT_TRIANGLE)pMesh;

        for (ulIndex=0;ulIndex<nMesh;ulIndex++)
        {
            LONG lVertex[3];
            LONG vIndex;

            lVertex[0] = pGradTri->Vertex1;
            lVertex[1] = pGradTri->Vertex2;
            lVertex[2] = pGradTri->Vertex3;

            for (vIndex=0;vIndex<3;vIndex++)
            {
                ULONG TriVertex = lVertex[vIndex];

                if (TriVertex < nVertex)
                {
                    LONG VertX  = pVertex[TriVertex].x;
                    LONG VertY  = pVertex[TriVertex].y;

                    if (VertX < xmin)
                    {
                        xmin = VertX;
                    }

                    if (VertX > xmax)
                    {
                        xmax = VertX;
                    }

                    if (VertY < ymin)
                    {
                        ymin = VertY;
                    }

                    if (VertY > ymax)
                    {
                        ymax = VertY;
                    }
                }
                else
                {
                    //
                    // error in mesh/vertex array, return null
                    // bounding rect
                    //

                    prclExt->left   = 0;
                    prclExt->right  = 0;
                    prclExt->top    = 0;
                    prclExt->bottom = 0;

                    return(FALSE);
                }
            }

            pGradTri++;
        }
    }
    else
    {
        bRet = FALSE;
    }

    //
    // are any parameter out of coordinate space bounds 2^28
    //

    LONG lIntMax = 0x08000000;
    LONG lIntMin = -lIntMax;

    if (
            (xmin < lIntMin) || (xmin > lIntMax) ||
            (xmax < lIntMin) || (xmax > lIntMax) ||
            (ymin < lIntMin) || (ymin > lIntMax) ||
            (ymax < lIntMin) || (ymax > lIntMax)
       )
    {
        prclExt->left   = 0;
        prclExt->right  = 0;
        prclExt->top    = 0;
        prclExt->bottom = 0;

        return(FALSE);
    }

    prclExt->left   = xmin;
    prclExt->right  = xmax;
    prclExt->top    = ymin;
    prclExt->bottom = ymax;

    return(bRet);
}

/******************************Public*Routine******************************\
*   GreGradientFill
*
* Arguments:
*
*   hdc          - dc
*   pLocalVertex - Position and color
*   nVertex      - number of vertex
*   pLocalMesh   - each three USHORTs define 1 triangle
*   nMesh        - Number of triangles
*   ulMode       - drawing mode (rect/tri) and options
*
* Return Value:
*
*   Status
*
* History:
*
*    23-Jun-1997 Added rotation support for rectangles -by- Ori Gershony [orig]
*
*    16-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GreGradientFill(
    HDC        hdc,
    PTRIVERTEX pLocalVertex,
    ULONG      nVertex,
    PVOID      pLocalMesh,
    ULONG      nMesh,
    ULONG      ulMode
    )
{
    GDITraceHandle(GreGradientFill, "(%X, %p, %u, %p, %u, %u)\n", (va_list)&hdc,
                   hdc);

    BOOL  bStatus = FALSE;
    PTRIVERTEX pLocalVertexTmp=NULL;
    PVOID pLocalMeshTmp=NULL;

    //
    // limit ulMode (direct from user)
    //

    ulMode &= GRADIENT_FILL_OP_FLAG;

    //
    // validate DST DC
    //

    DCOBJ  dcoDst(hdc);

    if (dcoDst.bValid())
    {
        //
        // lock device
        //

        DEVLOCKBLTOBJ dlo;

        if (dlo.bLock(dcoDst))
        {
            EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);

            //
            // Break each rotated rectangle into two triangles.  This will double 
            // the number of vertices used (4 per two triangles).
            //
            
            if (xoDst.bRotation() && 
                ((ulMode == GRADIENT_FILL_RECT_H) || (ulMode == GRADIENT_FILL_RECT_V)))
            {
                //
                // Allocate two triangles for each rectangle 
                //
                ULONG ulSizeM = nMesh   * 2 * sizeof(GRADIENT_TRIANGLE);
                ULONG ulSizeV = nVertex * 2 * sizeof(TRIVERTEX);

                //
                // Let's make sure nMesh and nVertex are not so high as to cause overflow--this
                // can cause us to allocate too small a buffer and then commit an access 
                // violation.  Also make sure we have enough memory.
                //
                if ((nVertex > MAXULONG/2) ||
                    (nMesh > MAXULONG/2) ||
                    ((nVertex * 2) > (MAXIMUM_POOL_ALLOC / sizeof(TRIVERTEX))) ||
                    ((nMesh * 2)   > ((MAXIMUM_POOL_ALLOC - ulSizeV) / (sizeof(GRADIENT_TRIANGLE)))))
                {
                    WARNING("GreGradientFill: can't allocate input buffer\n");
                    EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return(FALSE);
                }
        
                //
                // Allocate memory and assign to the pointers
                //
                pLocalVertexTmp = (PTRIVERTEX)PALLOCNOZ(ulSizeV + ulSizeM,'pmtG');
                if (!pLocalVertexTmp)
                {
                    EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }
                pLocalMeshTmp = (PVOID)((PBYTE)pLocalVertexTmp + ulSizeV);
            
                //
                // First copy the old Vertices
                //
                ULONG vertexNum;
                for (vertexNum=0; vertexNum < nVertex; vertexNum++)
                {
                    ((PTRIVERTEX)pLocalVertexTmp)[vertexNum] = ((PTRIVERTEX) pLocalVertex)[vertexNum];
                }

                //
                // Now walk the rectangle list and generate triangles/vertices as needed:
                //
                //    v1              vertexNum 
                //    *------------------*
                //    |                  |
                //    |                  |
                //    *------------------*
                // vertexNum+1          v2
                //
                
                for (ULONG rectNum=0; rectNum < nMesh; rectNum++)
                {
                    ULONG v1,v2;
                    v1 = ((PGRADIENT_RECT)pLocalMesh)[rectNum].UpperLeft;
                    v2 = ((PGRADIENT_RECT)pLocalMesh)[rectNum].LowerRight;

                    if ((v1 >= nVertex) || (v2 >= nVertex))
                    {
                        WARNING("GreGradientFill: vertex is out of range\n");
                        EngSetLastError(ERROR_INVALID_PARAMETER);
                        VFREEMEM(pLocalVertexTmp);
                        return(FALSE);            
                    }                    

                    pLocalVertexTmp[vertexNum].x   = pLocalVertex[v2].x;
                    pLocalVertexTmp[vertexNum].y   = pLocalVertex[v1].y;

                    pLocalVertexTmp[vertexNum+1].x = pLocalVertex[v1].x;
                    pLocalVertexTmp[vertexNum+1].y = pLocalVertex[v2].y;

                    if (ulMode == GRADIENT_FILL_RECT_V)
                    {
                        //
                        // vertexNum has same color as v1, vertexNum+1 has same color as v2
                        //
                
                        pLocalVertexTmp[vertexNum].Red     = pLocalVertex[v1].Red;
                        pLocalVertexTmp[vertexNum].Green   = pLocalVertex[v1].Green;
                        pLocalVertexTmp[vertexNum].Blue    = pLocalVertex[v1].Blue;
                        pLocalVertexTmp[vertexNum].Alpha   = pLocalVertex[v1].Alpha;

                        pLocalVertexTmp[vertexNum+1].Red   = pLocalVertex[v2].Red;
                        pLocalVertexTmp[vertexNum+1].Green = pLocalVertex[v2].Green;
                        pLocalVertexTmp[vertexNum+1].Blue  = pLocalVertex[v2].Blue;
                        pLocalVertexTmp[vertexNum+1].Alpha = pLocalVertex[v2].Alpha;
                    }
                    else 
                    {
                        //
                        // vertexNum has same color as v2, vertexNum+1 has same color as v1
                        //
                
                        pLocalVertexTmp[vertexNum].Red     = pLocalVertex[v2].Red;
                        pLocalVertexTmp[vertexNum].Green   = pLocalVertex[v2].Green;
                        pLocalVertexTmp[vertexNum].Blue    = pLocalVertex[v2].Blue;
                        pLocalVertexTmp[vertexNum].Alpha   = pLocalVertex[v2].Alpha;

                        pLocalVertexTmp[vertexNum+1].Red   = pLocalVertex[v1].Red;
                        pLocalVertexTmp[vertexNum+1].Green = pLocalVertex[v1].Green;
                        pLocalVertexTmp[vertexNum+1].Blue  = pLocalVertex[v1].Blue;
                        pLocalVertexTmp[vertexNum+1].Alpha = pLocalVertex[v1].Alpha;
                    }
                    
                    //
                    // Now add vertices for the two triangles
                    //

                    ((PGRADIENT_TRIANGLE)pLocalMeshTmp)[rectNum*2].Vertex1   = v1;
                    ((PGRADIENT_TRIANGLE)pLocalMeshTmp)[rectNum*2].Vertex2   = vertexNum;
                    ((PGRADIENT_TRIANGLE)pLocalMeshTmp)[rectNum*2].Vertex3   = vertexNum+1;

                    ((PGRADIENT_TRIANGLE)pLocalMeshTmp)[rectNum*2+1].Vertex1 = v2;
                    ((PGRADIENT_TRIANGLE)pLocalMeshTmp)[rectNum*2+1].Vertex2 = vertexNum;
                    ((PGRADIENT_TRIANGLE)pLocalMeshTmp)[rectNum*2+1].Vertex3 = vertexNum+1;
                    
                    vertexNum += 2;
                }
 
                //
                // Now modify the arguments so that this change is transparent to the rest of the code
                //
                pLocalMesh   = pLocalMeshTmp;
                pLocalVertex = pLocalVertexTmp;
                ulMode       = GRADIENT_FILL_TRIANGLE;
                nVertex      = vertexNum;
                nMesh        *= 2;
            }


            //
            // should be able to rotate triangle with no problem.  Rotated 
            // rectangles should have already been converted to triangles.
            //

            ULONG     ulIndex;
            ERECTL    erclDst(POS_INFINITY,POS_INFINITY,NEG_INFINITY,NEG_INFINITY);
    
            //
            // Translate to device space. Use integer points, not fixed point
            //
    
            for (ulIndex=0;ulIndex<nVertex;ulIndex++)
            {
                EPOINTL eptl(pLocalVertex[ulIndex].x,pLocalVertex[ulIndex].y);
                xoDst.bXform(eptl);
                //Shift all the points one pixel to the right to include the right edge of the rect.
                if(MIRRORED_DC(dcoDst.pdc)) {
                    ++eptl.x;
                }
                pLocalVertex[ulIndex].x = eptl.x + dcoDst.eptlOrigin().x;
                pLocalVertex[ulIndex].y = eptl.y + dcoDst.eptlOrigin().y;
            }
    
            //
            // verify mesh and calc mesh extents
            //

            bStatus = bCalcMeshExtent(pLocalVertex,nVertex,pLocalMesh,nMesh,ulMode,&erclDst);

            if (bStatus)
            {
                //
                // set up clipping, check if totally excluded
                //
                
                ECLIPOBJ eco(dcoDst.prgnEffRao(), erclDst);
        
                if (!(eco.erclExclude().bEmpty()))
                {
                    //
                    // Accumulate bounds.  We can do this before knowing if the operation is
                    // successful because bounds can be loose.
                    //
                    //
                    
                    if (dcoDst.fjAccum())
                    { 
                        ERECTL erclBound = erclDst;
                        
                        //
                        // erclDst is adjusted from DC origin,
                        // so that it should be substracted.
                        //
                        erclBound -= dcoDst.eptlOrigin();
                        
                        dcoDst.vAccumulate(erclBound);
                    }

                    SURFACE *pSurfDst;

                    if ((pSurfDst = dcoDst.pSurface()) != NULL)
                    {
                        PDEVOBJ pdo(pSurfDst->hdev());
                        DEVEXCLUDEOBJ dxo(dcoDst,&erclDst,&eco);
                        EXLATEOBJ xlo;
                        XLATEOBJ *pxlo;

                        //
                        // Inc the target surface uniqueness
                        //

                        INC_SURF_UNIQ(pSurfDst);
                        
                        if ((pdo.bPrinter()) || (pSurfDst->iFormat() <= BMF_8BPP)) 
                        {
                            // 
                            // 16bpp or greater does not require a translation object. 
                            //
                            // color translate is from RGB (PAL_BGR) 32 to device
                            //
        
                            XEPALOBJ   palDst(pSurfDst->ppal());
                            XEPALOBJ   palDstDC(dcoDst.ppal());
                            XEPALOBJ   palSrc(gppalRGB);
        
                            bStatus = xlo.bInitXlateObj(
                                dcoDst.pdc->hcmXform(),
                                dcoDst.pdc->GetICMMode(),
                                palSrc,
                                palDst,
                                palDstDC,
                                palDstDC,
                                dcoDst.pdc->crTextClr(),
                                dcoDst.pdc->crBackClr(),
                                0
                                );
                        
                            pxlo = xlo.pxlo();
    
                        }
                        else
                        {
                            pxlo = NULL;
                        }

                        //
                        // must have window offset for dither org
                        //
    
                        POINTL ptlDitherOrg = dcoDst.pdc->eptlOrigin();
    
                        ptlDitherOrg.x = -ptlDitherOrg.x;
                        ptlDitherOrg.y = -ptlDitherOrg.y;

                        //
                        // call driver/engine drawing
                        //

                        PFN_DrvGradientFill pfnGradientFill;
                        if (pSurfDst->iFormat() == BMF_8BPP) 
                        {
                            // Drivers can't really support GradientFill at
                            // 8BPP.  Instead of calling them and running
                            // the risk of having them mess up, let's call
                            // the engine instead.

                            pfnGradientFill = EngGradientFill;
                        }
                        else
                        {
                            pfnGradientFill = 
                            PPFNGET(pdo,GradientFill, pSurfDst->flags());
                        }

                        bStatus  = bStatus && (*pfnGradientFill)(
                            pSurfDst->pSurfobj(),
                            &eco,
                            pxlo,
                            pLocalVertex,
                            nVertex,
                            pLocalMesh,
                            nMesh,
                            &erclDst,
                            &ptlDitherOrg,
                            ulMode
                            );

                    }
                    else
                    {
                        bStatus = TRUE;
                    }
                }
                else
                {
                    bStatus = TRUE;
                }
            }
            else
            {
                WARNING1("GreGradientFill: Invalid mesh or vertex\n");
            }
        }
        else
        {
            bStatus = dcoDst.bFullScreen();
        }
    }
    else
    {
        bStatus = FALSE;
    }

    //
    // If allocated memory to convert rectangles to triangles, free it before
    // leaving this function.
    //
    if (pLocalVertexTmp)
    {
        VFREEMEM(pLocalVertexTmp);
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* NtGdiTriangleMesh
*
*   Kernel mode stub for GradientFill
*
* Arguments:
*
*   hdc          - dc
*   pLocalVertex - Position and color
*   nVertex      - number of vertex
*   pLocalMesh   - triangle or rectangle mesh
*   nMesh        - Number of triangles
*   ulMode       - drawing mode (rect/tri) and options
*
* Return Value:
*
*   Status
*
* History:
*
*    17-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


BOOL
NtGdiGradientFill(
    HDC        hdc,
    PTRIVERTEX pVertex,
    ULONG      nVertex,
    PVOID      pMesh,
    ULONG      nMesh,
    ULONG      ulMode
    )
{
    PTRIVERTEX  pLocalVertex;
    PVOID       pLocalMesh;

    //
    // make sure ulMode is not being mis-used
    //

    if ((ulMode & ~GRADIENT_FILL_OP_FLAG)  != 0)
    {
        WARNING("NtGdiGradientFill: illegal parameter\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    ulMode &= GRADIENT_FILL_OP_FLAG;

    //
    // validate parameters, make sure one of the mode
    // flags is set, but no invalid mode is set
    //

    if (
         (pVertex == NULL)       || (pMesh == NULL)       ||
         (nVertex == 0)          || (nMesh == 0)          ||
         (nVertex >= 0x80000000) || (nMesh >= 0x80000000) ||
         (
            (ulMode != GRADIENT_FILL_RECT_H) &&
            (ulMode != GRADIENT_FILL_RECT_V) &&
            (ulMode != GRADIENT_FILL_TRIANGLE)
         )
       )
    {
        WARNING("NtGdiGradientFill: illegal parameter\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // attempt to allocate a buffer to copy entire vertex and mesh array
    //

    if (nVertex > (MAXIMUM_POOL_ALLOC / sizeof(TRIVERTEX)))
    {
        WARNING("NtGdiGradientFill: nVertex is too large\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    
    ULONG       ulSizeV = nVertex * sizeof(TRIVERTEX);
    ULONG       ulSizeM;
    BOOL        bRet = TRUE;

    if (ulMode == GRADIENT_FILL_TRIANGLE)
    {
        if (nMesh > ((MAXIMUM_POOL_ALLOC - ulSizeV) / (sizeof(GRADIENT_TRIANGLE))))
        {
            WARNING("NtGdiGradientFill: nMesh is too large\n");
            EngSetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);            
        }
        ulSizeM = nMesh * sizeof(GRADIENT_TRIANGLE);
    }
    else
    {
        if (nMesh > ((MAXIMUM_POOL_ALLOC - ulSizeV) / (sizeof(GRADIENT_RECT))))
        {
            WARNING("NtGdiGradientFill: nMesh is too large\n");
            EngSetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);            
        }
        ulSizeM = nMesh * sizeof(GRADIENT_RECT);
    }

    //
    //  alloc memory for data buffers
    //

    if ((ulSizeM + ulSizeV) >= MAXIMUM_POOL_ALLOC)
    {
        WARNING("NtGdiGradientFill: can't allocate input buffer\n");
        EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    pLocalVertex = (PTRIVERTEX)PALLOCNOZ(ulSizeV + ulSizeM,'pmtG');

    if (pLocalVertex)
    {
        pLocalMesh = (PVOID)((PBYTE)pLocalVertex + ulSizeV);

        //
        // probe then copy buffers
        //

        __try
        {
            ProbeForRead(pVertex,ulSizeV,sizeof(BYTE));
            RtlCopyMemory(pLocalVertex,pVertex,ulSizeV);

            ProbeForRead(pMesh,ulSizeM,sizeof(BYTE));
            RtlCopyMemory(pLocalMesh,pMesh,ulSizeM);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(2);
            bRet = FALSE;
        }

        if (bRet)
        {
            bRet = GreGradientFill(
                    hdc,
                    pLocalVertex,
                    nVertex,
                    pLocalMesh,
                    nMesh,
                    ulMode
                    );
        }

        VFREEMEM(pLocalVertex);
    }
    else
    {
        EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        bRet = FALSE;
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\ttgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: ttgdi.cxx
*
* These are TrueType specific calls introduced into GDI by Win 3.1.  They
* all assume the existence of the TrueType font driver (or rasterizer
* as it is known in Win 3.1).
*
* Created: 11-Feb-1992 15:03:45
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/*
;********************************Public*Routine********************************
;This function is used to create a font directory for a given engine font file
;in it's native format.  This font directory can be used to create .FON like
;DLLs.
;Returns:   DX:AX   # of bytes copied into lpFontDir buffer or -1L in case of
;                   some error.
;
; GDI uses the Serif Style value in the Panose record of the OS/2 table to
; drive the Font Family for Windows. This is based on a simple table look
; up and the current mapping is as follows:
;
; Serif Style                              Font Family
; ----------------------------------------------------------------
; 0 (Any)                                    FF_DONTCARE
; 1 (No Fit)                                 FF_DONTCARE
; 2 (Cove)                                   FF_ROMAN
; 3 (Obtuse Cove)                            FF_ROMAN
; 4 (Square Cove)                            FF_ROMAN
; 5 (Obtuse Square Cove)                     FF_ROMAN
; 6 (Square)                                 FF_ROMAN
; 7 (Thin)                                   FF_ROMAN
; 8 (Bone)                                   FF_ROMAN
; 9 (Exaggerated)                            FF_ROMAN
;10 (Triangle)                               FF_ROMAN
;11 (Normal Sans)                            FF_SWISS
;12 (Obtuse Sans)                            FF_SWISS
;13 (Perp Sans)                              FF_SWISS
;14 (Flared)                                 FF_SWISS
;15 (Rounded)                                FF_SWISS
;
;******************************************************************************
*/

// Generic FFH header information.

#define HEADERSTUFFLEN1     (5 * sizeof(USHORT))
#define COPYRIGHTLEN        60
#define MOREHEADERSTUFFLEN  (2 * sizeof(USHORT))
#define HEADERSTUFFLEN      (HEADERSTUFFLEN1 + COPYRIGHTLEN)

static USHORT ausHeaderStuff[5] = {
            1, 0, 0x0200, ((SIZEFFH)+4+LF_FACESIZE), 0
            };

static USHORT ausMoreHeaderStuff[2] = {
            WIN_VERSION, GDI_VERSION
            };


#define MAXPMWEIGHT 9

#define WOW_EMBEDING 2

/**************************************************************************\
 * NtGdiMakeFontDir
 *
 * Code is over here!
\**************************************************************************/

ULONG GreMakeFontDir(
    FLONG    flEmbed,            // mark file as "hidden"
    PBYTE    pjFontDir,          // pointer to structure to fill
    PWSZ     pwszPathname        // path of font file to use
    )
{
    ULONG  cjNames;         // localW   nNamesLength
    HFF    hff;             // localD   lhFontFile
    PIFIMETRICS pifi;       // localV   pIfiMetrics, %(size IFIMETRICS)
    ULONG_PTR  idifi;
    ULONG  cjIFI;

// If TrueType disabled, then fail.

    // Not needed since our TrueType driver is part of the engine DLL and
    // should never be disabled.  At least, not yet...

    if (gppdevTrueType == NULL)
    {
        return ( 0);
    }


// Use TrueType driver to load font file.

    PDEVOBJ pdo((HDEV)gppdevTrueType);

// Create a bogus PFF that only has the file name set.  This insures that
// the call to EngMapFontFile will suceed.

    FONTFILEVIEW fv, *pfv = &fv;

    memset( (PVOID) &fv, 0, sizeof(fv) );

    fv.pwszPath = pwszPathname;

    PVOID pvView;
    ULONG cjView;
    if (!EngMapFontFileFDInternal((ULONG_PTR)&fv, (PULONG *)&pvView, &cjView, FALSE))
    {
        WARNING("GreMakeFontDir: EngMapFontFile failed\n");
        return(FALSE);
    }

    hff = pdo.LoadFontFile(
              1
            , (ULONG_PTR *)&pfv
            , &pvView
            , &cjView
            , 0 // pdv
            , (ULONG) gusLanguageID
            , 0
            );
    if ( !hff )
    {
        KdPrint(("gdisrv!cjMakeFontDir(): failed to load TrueType file %ws\n", pwszPathname));
        return ( 0);
    }

    EngUnmapFontFileFD((ULONG_PTR)&fv);

// Grab a pointer to the IFIMETRICS as well as the size of the structure.

    if ( (pifi = pdo.QueryFont(
                    0,
                    hff,
                    1,                  // currently, only 1 .TTF per .FOT
                    &idifi)) == (PIFIMETRICS) NULL )
    {
    // Make sure to unload on error exit.

        if ( !pdo.UnloadFontFile(hff) )
        {
            WARNING("cjMakeFontDir(): IFI error--failed to unload file\n");
            return (FALSE);
        }

    // Error exit.

        WARNING("cjMakeFontDir(): IFI error in TrueType driver\n");
        return (FALSE);
    }
    cjIFI = pifi->cjThis;

// NOTE PERF: [GilmanW] 01-Nov-1992    A note to myself...
//
// Tsk-tsk!  Gilman, this is very inefficient.  You should create a stack
// object that loads the font file and ifimetrics.  Its destructor will
// automatically free the ifimetrics and unload the file.  That saves
// having to do the MALLOCOBJ and copy.

// Copy the IFIMETRICS so we can unload the font file NOW (and simplify
// error cleanup).

    MALLOCOBJ moIFI(cjIFI);

    if ( !moIFI.bValid() )
    {
    // Make sure to unload on error exit.

        if ( !pdo.UnloadFontFile(hff) )
        {
            WARNING("cjMakeFontDir(): IFI error--failed to unload file\n");
            return (0);
        }

    // Error exit.

        WARNING("cjMakeFontDir(): could not allocate buffer for IFIMETRICS\n");
        return ( 0);
    }

    RtlCopyMemory(moIFI.pv(), (PVOID) pifi, cjIFI);

// Tell the TrueType driver to free the IFIMETRICS.

    if ( PPFNVALID(pdo, Free) )
    {
        pdo.Free(pifi, idifi);
    }

    pifi = (PIFIMETRICS) moIFI.pv();

    IFIOBJ ifio(pifi);

// Tell the TrueType driver to unload the font file.

    if ( !pdo.UnloadFontFile(hff) )
    {
        WARNING("cjMakeFontDir(): IFI error--failed to unload file\n");
        return (0);
    }

// Copy header info into the font directory.

    PBYTE pjWritePointer = pjFontDir;

    RtlCopyMemory(pjWritePointer, ausHeaderStuff, HEADERSTUFFLEN1);
    pjWritePointer += HEADERSTUFFLEN1;

    //
    // Add the copyright string.
    //

    ULONG cjTmp = strlen("Windows! Windows! Windows!") + 1;
    RtlCopyMemory(pjWritePointer, "Windows! Windows! Windows!", cjTmp);

// If this is an embeded font we need to embed either a PID or TID depending on
// whether or not we were called from WOW.  If we were called from WOW then we
// expect flEmbeded to be WOW_EMBEDING.

    if( flEmbed )
    {
       ULONG pid = (flEmbed == WOW_EMBEDING) ?
            (ULONG) W32GetCurrentTID() : (ULONG) W32GetCurrentPID();

    // we are overwriting the copyright string with the PID or TID but
    // since this is an embeded font we don't care about the copyright
    // string

        //
        // Unaligned write
        //

        RtlCopyMemory( pjWritePointer,
                       &pid,
                       sizeof( ULONG ) );

    }

    RtlZeroMemory(pjWritePointer + cjTmp, COPYRIGHTLEN - cjTmp);
//    pjWritePointer += COPYRIGHTLEN;
    pjWritePointer += cjTmp;

    // Note: version stamps (Win version, Engine version) are put in the
    //       copyright field immediately after the copyright string.

    RtlCopyMemory(pjWritePointer, ausMoreHeaderStuff, MOREHEADERSTUFFLEN);

//    pjWritePointer += MOREHEADERSTUFFLEN;
    pjWritePointer += (COPYRIGHTLEN - cjTmp);

// Engine type and embedded flags.

    *pjWritePointer++ = (BYTE) ( PF_ENGINE_TYPE |
                                 ((flEmbed) ? PF_ENCAPSULATED : 0) |
                                 ((flEmbed == WOW_EMBEDING) ? PF_TID : 0));

// Selection type flag.

    *pjWritePointer++ = (BYTE) (ifio.fsSelection() & 0x00ff);

// Em square.

    WRITE_WORD(pjWritePointer, ifio.fwdUnitsPerEm());
    pjWritePointer += 2;

// Horizontal and vertical resolutions.

    WRITE_WORD(pjWritePointer, 72);
    pjWritePointer += 2;

    WRITE_WORD(pjWritePointer, 72);
    pjWritePointer += 2;

// Ascent.

    WRITE_WORD(pjWritePointer, ifio.fwdWinAscender());
    pjWritePointer += 2;

// Internal leading.

    WRITE_WORD(pjWritePointer, ifio.fwdInternalLeading());
    pjWritePointer += 2;

// External leading.

    WRITE_WORD(pjWritePointer, ifio.fwdExternalLeading());
    pjWritePointer += 2;

// Italic, strikeout, and underline flags.

    *pjWritePointer++ = ifio.bItalic() ? 0xffff : 0;
    *pjWritePointer++ = ifio.lfUnderline() ? 0xffff : 0;
    *pjWritePointer++ = ifio.lfStrikeOut() ? 0xffff : 0;

    WRITE_WORD(pjWritePointer, ifio.lfWeight());
    pjWritePointer += 2;

// Character set.

    // Old Comment:
    //  - is this right?  Maybe we should check.  At least make sure ttfd
    //    handles this so ifi.usCharSet is correct.

    *pjWritePointer++ = ifio.lfCharSet();

// Pix width (set to zero for some reason).     [Windows 3.1 compatibility]

    WRITE_WORD(pjWritePointer, 0);
    pjWritePointer += 2;

// Font height.

    WRITE_WORD(pjWritePointer, (WORD) ifio.lfHeight());
    pjWritePointer += 2;

// PitchAndFamily.

    *pjWritePointer++ = ifio.tmPitchAndFamily();

// Average character width (if zero, estimate as fwdMaxCharInc/2).

    WRITE_WORD(
        pjWritePointer,
        ifio.lfWidth() ? (WORD) ifio.lfWidth() : ifio.fwdMaxCharInc()/2
        );
    pjWritePointer += 2;

// Maximum width.

    WRITE_WORD(pjWritePointer, ifio.fwdMaxCharInc());
    pjWritePointer += 2;

// The special characters (first, last, default, break).

    *pjWritePointer++ = ifio.chFirstChar();
    *pjWritePointer++ = ifio.chLastChar();

    WRITE_WORD(pjWritePointer, DEF_BRK_CHARACTER);  // write it in one shot
    pjWritePointer += 2;

// Force WidthBytes entry to zero, no device name.

    *pjWritePointer++ = 0;
    *pjWritePointer++ = 0;
    *pjWritePointer++ = 0;
    *pjWritePointer++ = 0;
    *pjWritePointer++ = 0;
    *pjWritePointer++ = 0;

// Offset to facename.

    WRITE_DWORD(pjWritePointer, (DWORD) SIZEFFH + 4 + 1);
    pjWritePointer += 4;

// Store rasterization thresholds.

    WRITE_WORD(pjWritePointer, (WORD) ifio.fwdLowestPPEm());
    pjWritePointer += 2;

    WRITE_WORD(pjWritePointer, ifio.wCharBias());
    pjWritePointer += 2;

// Move pointer to where facenames belong.

    pjWritePointer = pjFontDir + SIZEFFH + 4 + 1;

// Write out family name.

    vToASCIIN((PSZ) pjWritePointer, LF_FACESIZE, ifio.pwszFamilyName(), wcslen(ifio.pwszFamilyName()) + 1);

// measure the ansi string again. If dbcs, it may be longer than cwcTmp

    cjNames = strlen((PSZ) pjWritePointer) + 1;
    pjWritePointer += cjNames;

// Write out face name.

    vToASCIIN((PSZ) pjWritePointer, LF_FULLFACESIZE, ifio.pwszFaceName(), wcslen(ifio.pwszFaceName()) + 1);

// measure the ansi string again. If dbcs, it may be longer than cwcTmp

    cjTmp = strlen((PSZ) pjWritePointer) + 1;
    cjNames += cjTmp;
    pjWritePointer += cjTmp;

// Write out style name.

    vToASCIIN((PSZ) pjWritePointer, LF_FACESIZE, ifio.pwszStyleName(), wcslen(ifio.pwszStyleName()) + 1);

    cjNames += (strlen((PSZ) pjWritePointer) + 1);

    return (cjNames + SIZEFFH + 4 + 1);
}

/******************************Public*Routine******************************\
* GreGetRasterizerCaps
*
* Fills the RASTERIZER_STATUS structure.
*
* Returns:
*   TRUE if successful; FALSE otherwise.
*
* History:
*  16-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL GreGetRasterizerCaps (
    LPRASTERIZER_STATUS praststat   // pointer to a RASTERIZER_STATUS struc
    )
{
// Parameter check.

    if (praststat == (LPRASTERIZER_STATUS) NULL)
    {
        WARNING("GreGetRasterizerCaps(): bad parameter\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

// Fill in size.

    praststat->nSize = sizeof(RASTERIZER_STATUS);

// Fill in TrueType driver flags.

    praststat->wFlags = (USHORT) ((gppdevTrueType != NULL) ? TT_ENABLED : 0);
    praststat->wFlags |= (gcTrueTypeFonts != 0) ? TT_AVAILABLE : 0;

// Fill in language id.

    praststat->nLanguageID = gusLanguageID;

    return (TRUE);
}


/******************************Public*Routine******************************\
*
* ulGetFontData2
*
* Effects:
*
* History:
*  17-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



ULONG ulGetFontData2 (
    DCOBJ&       dco,
    DWORD        dwTable,
    DWORD        dwOffset,
    PVOID       pvBuffer,
    ULONG        cjData
    )
{
    ULONG  cjRet = (ULONG) -1;

// Get RFONT user object.  Need this to realize font.

    // Old Comment:
    //  - This should get changed to an LFONTOBJ (paulb)

    RFONTOBJ rfo(dco, FALSE);
    if (!rfo.bValid())
    {
        WARNING("GetFontData(): could not lock HRFONT\n");
        return (cjRet);
    }

// Get PFE user object.  Need this for iFont.

    PFEOBJ pfeo(rfo.ppfe());
    if (!pfeo.bValid())
    {
        WARNING("GetFontData(): could not lock HPFE\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return (cjRet);
    }

// Get PFF user object.  Need this for HFF.

    PFFOBJ pffo(pfeo.pPFF());
    if (!pffo.bValid())
    {
        WARNING("GetFontData(): could not lock HPFF\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return (cjRet);
    }

// Get FDEV user object.

    PDEVOBJ pdo(rfo.hdevProducer());

// As long as the driver LOOKS like the TrueType driver, we will allow the
// call to succeed.  Otherwise, we quit right now!
//
// In this case, TrueType means supporting the TrueType Tagged File Format.

     cjRet = pdo.QueryTrueTypeTable (
                             pffo.hff(),
                             pfeo.iFont(),
                             (ULONG) dwTable,
                             (PTRDIFF) dwOffset,
                             (ULONG) cjData,
                             (PBYTE) pvBuffer,
                             0,
                             0
                             );

    return (cjRet);
}


/******************************Public*Routine******************************\
* GreGetFontData
*
* History:
*  16-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG ulGetFontData (
    HDC          hdc,
    DWORD        dwTable,
    DWORD        dwOffset,
    PVOID       pvBuffer,
    ULONG        cjData
    )
{
    ULONG  cjRet = (ULONG) -1;

// Get DC user object.

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        WARNING("GetFontData(): bad handle for DC\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return (cjRet);
    }

    return ulGetFontData2(dco, dwTable, dwOffset, pvBuffer, cjData);
}




/******************************Public*Routine******************************\
*
* vFixedToEf
*
* History:
*  Thu 17-Nov-1994 07:15:12 by Kirk Olynyk [kirko]
* Made it simpler.
*  11-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vFixedToEf (
    EFLOAT  *pef,
    FIXED&  fxd
    )
{
    *pef = *(LONG*) &fxd;
    pef->vMultByPowerOf2(-16);
}


/*********************************Class************************************\
* class RESETFCOBJ
*
*   (brief description)
*
* Public Interface:
*
* History:
*  10-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


#define B_ONE(e)  (((e).value == 1) &&  ((e).fract == 0))
#define B_ZERO(e) (((e).value == 0) &&  ((e).fract == 0))


class RESETFCOBJ    // resetfco
{
private:

    BOOL        bValid_;
    BOOL        bTrivialXform;
    RFONTOBJ   *prfo;


public:

    RESETFCOBJ(
        DCOBJ&      dco,
        RFONTOBJ&   rfo,
        LPMAT2      lpmat2, // "extra" xform applied after the existing xform in dc
        BOOL        bIgnoreRotation,
        FLONG       flType
        );

   ~RESETFCOBJ();

    BOOL bValid() {return bValid_;};
    BOOL bTrivXform() {return bTrivialXform;};

};


/******************************Public*Routine******************************\
*
* RESETFCOBJ::RESETFCOBJ
*
*
* resets the xform in rfo.hfc() to be what it used to be times lpma2
*
*
* History:
*  01-Nov-1992 Gilman Wong [gilmanw]
* IFI/DDI merge.
*
*  11-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

RESETFCOBJ::RESETFCOBJ(
DCOBJ&      dco,
RFONTOBJ&   rfo,
LPMAT2      lpmat2,  // "extra" xform applied after the existing xform in dc
BOOL        bIgnoreRotation,
FLONG       flType
)
{
    ASSERTGDI(lpmat2 != (LPMAT2)NULL, "RESETFCOBJ:lpmat2\n");

    bValid_       = TRUE;
    prfo          = &rfo;

    bTrivialXform = (
                     B_ONE(lpmat2->eM11)  && B_ONE(lpmat2->eM22) &&
                     B_ZERO(lpmat2->eM12) && B_ZERO(lpmat2->eM21)
                    );

// If the escapement or orientation values of the LOGFONT are non-zero and
// we are in compatible mode, we will need to recompute the NtoD transform
// while ingnoring these values.  This is for the sake of Win 3.1 compatablity.

    LFONTOBJ lfo(dco.pdc->hlfntNew());

    if (!lfo.bValid())
    {
        WARNING("GreGetGlyphOutline(): bad LFONTHANDLE\n");
        bValid_ = FALSE;
        return;
    }

    if( ( lfo.plfw()->lfEscapement || lfo.plfw()->lfOrientation ) &&
        ( bIgnoreRotation ) )
    {
        bTrivialXform = FALSE;
    }

    if (!bTrivialXform)
    {
    // Create an EXFORMOBJ.  We will use this to hold the transform passed
    // in via the LPMAT2.

        MATRIX mxExtra;
        EXFORMOBJ xoExtra(&mxExtra, XFORM_FORMAT_LTOL);

    // EXFORMOBJ should not be able to fail.

        ASSERTGDI (
            xoExtra.bValid(),
            "GreGetGlyphOutline(): EXFORMOBJ failed\n"
            );

    // Stuff lpMat2 into the "extra" EXFORMOBJ.

        EFLOAT  ef11, ef12, ef21, ef22;

        vFixedToEf(&ef11, lpmat2->eM11);
        vFixedToEf(&ef22, lpmat2->eM22);
        vFixedToEf(&ef12, lpmat2->eM12);
        vFixedToEf(&ef21, lpmat2->eM21);

        {
            ef12.vNegate();
            ef21.vNegate();
            xoExtra.vSetElementsLToL(ef11, ef12, ef21, ef22);
        }

// note that the section above is different from
//        xoExtra.vSetElementsLToL(ef11, ef12, ef21, ef22);
// because of our interpretation of NtoD xform. with our conventions
// ntod xform transforms notional space defined as having y axis pointing down
// to device space also with y axis down by left vector mult.
// vD = vN * N2D. The matrix passed by the user uses different convention:
// y axis up in both spaces. so we have to use
// Sigma_3 M Sigma_3 instead of M, (Sigma_3 = diag(1,-1)) to convert
// from app convetions to our conventions [bodind]

        xoExtra.vRemoveTranslation();   // don't leave translations uninitialized

    // Need these EXFORMOBJs to calculate the new CONTEXTINFO.

        MATRIX mxN2D;
        EXFORMOBJ xoN2D(&mxN2D, XFORM_FORMAT_LTOFX);

        MATRIX mxNewN2D;
        EXFORMOBJ xoNewN2D(&mxNewN2D, XFORM_FORMAT_LTOFX);

    // EXFORMOBJs should not be able to fail.

        ASSERTGDI (
            xoN2D.bValid() && xoNewN2D.bValid(),
            "GreGetGlyphOutline(): EXFORMOBJ failed\n"
            );

        FD_XFORM fdx;

        if( bIgnoreRotation )
        {
        // If bIgnoreRotation is set it means we've been called from WOW and
        // need toingore the orientation and escapment values in the LOGFONT.
        // To do this we will need to recompute the font driver transform.
        // This behavior is neccesary for Corel Draw 5.0 to be able to print
        // rotated text properly.

            PFEOBJ  pfeo(rfo.ppfe());

            ASSERTGDI(pfeo.bValid(), "gdisrv!RFONTOBJ(dco): bad ppfe from mapping\n");

            IFIOBJ  ifio(pfeo.pifi());
            POINTL ptlSim;

            ptlSim.x = ptlSim.y = 0;

            if (
                !pfeo.bSetFontXform(
                    dco, lfo.plfw(),
                    &fdx,
                    ND_IGNORE_ESC_AND_ORIENT,
                    0,
                    (POINTL* const) &ptlSim,
                    ifio,
                    FALSE
                    )
            )
            {
                WARNING("RESETFCOBJ: failed to compute font transform\n");
                bValid_ = FALSE;
                return;
            }

            xoN2D.vRemoveTranslation();

            xoN2D.vSetElementsLToFx( fdx.eXX, fdx.eXY, fdx.eYX, fdx.eYY );

            xoN2D.vComputeAccelFlags(XFORM_FORMAT_LTOFX);
        }
        else
        {
            rfo.vSetNotionalToDevice(xoN2D);
        }

    // Combine the transforms.

        if ( !xoNewN2D.bMultiply(xoN2D, xoExtra, DONT_COMPUTE_FLAGS | XFORM_FORMAT_LTOFX) )
        {
            WARNING("GreGetGlyphOutline(): EXFORMOBJ::bMultiply failed\n");
            bValid_ = FALSE;
            return;
        }

    // Get the new transform as an FD_XFORM.

        xoNewN2D.vGetCoefficient(&fdx);

    // Attempt to get an RFONT with the new transform.

        bValid_ = rfo.bSetNewFDX(dco, fdx, flType);
    }

}


/******************************Public*Routine******************************\
*
* RESETFCOBJ::~RESETFCOBJ()
*
* resets the xform in rfo.hfc to its original value
*
* History:
*  01-Nov-1992 Gilman Wong [gilmanw]
* IFI/DDI merge.
*
*  11-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

RESETFCOBJ::~RESETFCOBJ()
{
    if (bValid_ && !bTrivialXform)
    {
    // Release the cache semaphore and make inactive.

        prfo->vReleaseCache();

        prfo->vMakeInactive();

    }
}



#define BITS_OFFSET   (offsetof(GLYPHBITS,aj))

BOOL IsSingularEudcGlyph
(
    GLYPHDATA *wpgd, BOOL bSimulatedBold
);

/******************************Public*Routine******************************\
* GreGetGlyphOutline
*
* History:
*  05-Mar-1995 Kirk Olynyk [kirko]
* Added support for GGO_GRAY2_BITMAP, GGO_GRAY4_BITMAP, GGO_GRAY8_BITMAP.
* I have introduced new modes for DrvQueryFontData that require
* that the bitmaps have scans that begin and end on DWORD
* boundaries as required by GetGlyphOutline(). This is the
* natural format of the TrueType driver.
* I also rearranged the code to have a single return point.
*  01-Nov-1992 Gilman Wong [gilmanw]
* IFI/DDI merge.
*
*  16-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG GreGetGlyphOutlineInternal (
  HDC           hdc,
  WCHAR         wch,        // WCHAR or HGLYPH???
  UINT          ulFormat,   // data format
  GLYPHMETRICS *lpgm,       // glyph metrics
  ULONG         cjBuffer,   // size of buffer
  void         *pvBuffer,   // buffer for data in the format, ulFormat
  MAT2         *lpmat2,     // "extra" xform applied after existing Notional to Device xform
  BOOL          bIgnoreRotation
  )
{
  HGLYPH hg;
  GLYPHDATA gd;
  ULONG iMode, uRet, cjRet;
  BOOL bGlyphIndex, bBufferSizeWanted, flTTO;
  BOOL bUnhinted;
  FLONG flType;

  cjRet = GDI_ERROR;                                // assume error
  bGlyphIndex = (ulFormat & GGO_GLYPH_INDEX);       // record glyph index bit
  bUnhinted   = (ulFormat & GGO_UNHINTED);          // remember if unhinted outlines are wanted
  ulFormat &= ~(GGO_GLYPH_INDEX | GGO_UNHINTED);    // and then erase it from ulFormat
  bBufferSizeWanted = (pvBuffer == 0) || (cjBuffer == 0);

  flType = bGlyphIndex ? RFONT_TYPE_HGLYPH : RFONT_TYPE_UNICODE;

  if ( (lpgm == 0) || (lpmat2 == 0) )
  {
    WARNING("GreGetGlyphOutline(): bad parameter\n");
    SAVE_ERROR_CODE( ERROR_INVALID_PARAMETER );
  }
  else
  {
    DCOBJ dco(hdc);
    if ( !dco.bValid() )
    {
      WARNING("GreGetGlyphOutline(): bad handle for DC\n");
      SAVE_ERROR_CODE( ERROR_INVALID_HANDLE );
    }
    else
    {

        RFONTOBJ rfo(dco, FALSE);

        RFONTTMPOBJ rfoLinkSystem;
        RFONTTMPOBJ rfoLinkDefault;
        RFONTTMPOBJ rfoLinkFace;

        GLYPHDATA   *wpgdTemp;

        PRFONT      prfnt;
        PRFONT       prfntTmp;
        UINT        EudcType;
        UINT        numFaceName;
        BOOL        bEUDC = FALSE;

    // Set Basefont as default.

        RFONTOBJ *prfo = &rfo;

    // restructure this later

        if(!rfo.bValid())
        {
            goto GetGlyphOutlineData;
        }

    // Get the HGLYPH for the WCHAR.  Note we only check bGlyphIndex for the
    // original font. If this is an hglyph rfont then we wont allow linked
    // glyphs

        hg = (bGlyphIndex) ? (HGLYPH) wch : rfo.hgXlat(wch);

    // Check the target glyph is linked font or base font.

        if ((hg == rfo.hgDefault()) && !bGlyphIndex && rfo.bIsLinkedGlyph(wch))
        {
            prfnt          = rfo.prfntFont();

            GreAcquireSemaphore(prfnt->hsemEUDC);

            HGLYPH hgFound = HGLYPH_INVALID;
            HGLYPH hgLink  = HGLYPH_INVALID;

        // this value will be decremented in RFONTOBJ::dtHeler()

            INCREMENTEUDCCOUNT;
            FLINKMESSAGE2(DEBUG_FONTLINK_RFONT,
                             "GreGetGlyphOutlineInternal():No request to change EUDC \
                              data %d\n",gcEUDCCount);
        // initialize EUDC info

            rfo.vInitEUDC(dco);

        // if we have system wide eudc, lock the cache.

            if( prfnt->prfntSysEUDC != NULL )
            {
                RFONTTMPOBJ rfoTemp( prfnt->prfntSysEUDC );
                rfoTemp.vGetCache();
            }

        // The linked RFONT is initialized for Default EUDC grab the semaphore.

            if( prfnt->prfntDefEUDC != NULL )
            {
                RFONTTMPOBJ rfoTemp( prfnt->prfntDefEUDC );
                rfoTemp.vGetCache();
            }

        // if we have face name eudc, lock the cache for all the linked fonts

            for( UINT ii = 0; ii < prfnt->uiNumLinks; ii++ )
            {
                RFONTTMPOBJ rfoTemp( prfnt->paprfntFaceName[ii] );
                rfoTemp.vGetCache();
            }

        // Need to indicate that this RFONT's EUDC data has been initialized.

            prfnt->flEUDCState |= EUDC_INITIALIZED;

            GreReleaseSemaphore(prfnt->hsemEUDC);

        // First, try to find out target glyph from facename linked font.

            numFaceName = 0;

            for( ii = 0; ii < prfnt->uiNumLinks; ii++ )
            {
                rfoLinkFace.vInit( prfnt->paprfntFaceName[ii] );
                if ((hgLink = rfoLinkFace.hgXlat(wch)) != rfoLinkFace.hgDefault())
                {
                    RFONTTMPOBJ rfoTemp( prfnt->paprfntFaceName[ii] );
                    if (rfoTemp.bValid())
                    {
                        if( (wpgdTemp = rfoTemp.pgdGetEudcMetrics( wch,  &rfo)) != NULL )
                        {
                if( !IsSingularEudcGlyph(wpgdTemp, rfoTemp.pfo()->flFontType & FO_SIM_BOLD))
                            {
                                numFaceName = ii;
                                EudcType = EUDCTYPE_FACENAME;
                                hgFound = hgLink;
                                prfo    = &rfoLinkFace;
                                break;
                            }
                        }
                    }
                }
            }

        // Check if the glyph is in the DEFAULT EUDC font


            if( (hgFound == HGLYPH_INVALID) && (prfnt->prfntDefEUDC != NULL) )
            {
                rfoLinkDefault.vInit( prfnt->prfntDefEUDC );
                if ((hgLink = rfoLinkDefault.hgXlat(wch)) != rfoLinkDefault.hgDefault())
                {
                    RFONTTMPOBJ rfoTemp( prfnt->prfntDefEUDC );
                    if (rfoTemp.bValid())
                    {
                        if( (wpgdTemp = rfoTemp.pgdGetEudcMetrics( wch , &rfo)) != NULL )
                        {
                if( !IsSingularEudcGlyph(wpgdTemp, rfoTemp.pfo()->flFontType & FO_SIM_BOLD) )
                            {
                                numFaceName = 0;
                                EudcType = EUDCTYPE_DEFAULT;
                                hgFound = hgLink;
                                prfo    = &rfoLinkDefault;
                            }
                        }
                    }
                }
            }

        // Try to find out System EUDC.

            if( (hgFound == HGLYPH_INVALID) && (prfnt->prfntSysEUDC != NULL) )
            {
                rfoLinkSystem.vInit( prfnt->prfntSysEUDC );
                if ((hgLink = rfoLinkSystem.hgXlat(wch)) != rfoLinkSystem.hgDefault())
                {
                    numFaceName = 0;
                    EudcType = EUDCTYPE_SYSTEM_WIDE;
                    hgFound = hgLink;
                    prfo    = &rfoLinkSystem;
                }
            }

            if( hgFound != HGLYPH_INVALID )
            {
                hg = hgFound;
                bEUDC = TRUE;  // find any EUDC object. prfo is not rfo object.
            }
            else
            {
                rfo.dtHelper();
                prfnt->flEUDCState = FALSE;
            }
        }

GetGlyphOutlineData:

      if ( !prfo->bValid() )
      {
        WARNING("GreGetGlyphOutline(): could not lock HRFONT\n");
        SAVE_ERROR_CODE( ERROR_CAN_NOT_COMPLETE );
      }
      else
      {
          PDEVOBJ pdo( prfo->hdevProducer() );

        if ( !pdo.bValid() )
        {
          WARNING("GreGetGlyphOutline -- invalid PDEV\n");
          SAVE_ERROR_CODE( ERROR_CAN_NOT_COMPLETE );
        }
        else if ( !PPFNVALID(pdo, QueryTrueTypeOutline) )
        {
          WARNING1("GreGetGlyphOuline -- DrvQueryTrueTypeOutline\n");
          SAVE_ERROR_CODE( ERROR_CAN_NOT_COMPLETE );
        }
        else
        {
          // reset the xform in the rfo.hfc() if needed:

          RESETFCOBJ resetfco( dco, *prfo, lpmat2, bIgnoreRotation, flType );

          if ( !resetfco.bValid() )
          {
            WARNING("GreGetGlyphOutline(): resetfco\n");
            SAVE_ERROR_CODE( ERROR_CAN_NOT_COMPLETE );
          }
          else
          {

            prfntTmp = NULL;

            if (bEUDC && !resetfco.bTrivXform())
            {
                switch (EudcType)
                {
                    case EUDCTYPE_SYSTEM_WIDE:
                        prfntTmp = prfnt->prfntSysEUDC;
                        prfnt->prfntSysEUDC = NULL;
                        break;
                    case EUDCTYPE_DEFAULT:
                        prfntTmp = prfnt->prfntDefEUDC;
                        prfnt->prfntDefEUDC = NULL;
                        break;
                    case EUDCTYPE_FACENAME:
                        prfntTmp = prfnt->paprfntFaceName[numFaceName];
                        prfnt->paprfntFaceName[numFaceName] = NULL;
                        break;
                    default:
                        break;
                }
            }
            switch ( ulFormat )
            {
            case GGO_BITMAP:
            case GGO_GRAY2_BITMAP:
            case GGO_GRAY4_BITMAP:
            case GGO_GRAY8_BITMAP:

              switch ( ulFormat )
              {
              case GGO_BITMAP:
                iMode = QFD_TT_GRAY1_BITMAP;   // 8 pixels per byte
                break;
              case GGO_GRAY2_BITMAP:
                iMode = QFD_TT_GRAY2_BITMAP;   // one byte per pixel: 0..4
                break;
              case GGO_GRAY4_BITMAP:
                iMode = QFD_TT_GRAY4_BITMAP;   // one byte per pixel: 0..16
                break;
              case GGO_GRAY8_BITMAP:
                iMode = QFD_TT_GRAY8_BITMAP;   // one byte per pixel: 0..64
                break;
              }

              cjRet =
                pdo.QueryFontData(
                  0,          // device handle of PDEV
                  prfo->pfo(),
                  iMode,      // QFD_TT_GRAY[1248]_BITMAP
                  hg,         // glyph handle
                  &gd,        // pointer to GLYPHDATA structure
                  pvBuffer,   // pointer to dest buffer
                  cjBuffer    // size of dest buffer
                  );
              break;

            case GGO_NATIVE:
            case GGO_BEZIER:

              flTTO = 0;
              if (ulFormat == GGO_BEZIER)
                flTTO |= TTO_QUBICS;
              if (bUnhinted)
                flTTO |= TTO_UNHINTED;

              // We're lucky, FdQueryTrueTypeOutline will return size if EITHER
              // a NULL buffer or size of zero is passed in.  So we don't need
              // separate cases. Note that this assumes that the outline is
              // appropriate to a monochrome bitmap. There should be no scaling
              // for the case of antialiased fonts.

              cjRet =
                pdo.QueryTrueTypeOutline(
                  0,
                  prfo->pfo(),
                  hg,
                  flTTO,
                  &gd,
                  cjBuffer,
                  (TTPOLYGONHEADER *) pvBuffer
                  );
              if ( cjRet == FD_ERROR )
              {
                ASSERTGDI(cjRet == GDI_ERROR, "FD_ERROR != GDI_ERROR\n");
                WARNING(
                  "GreGetGlyphOutline(): FdQueryTrueTypeOutline()"
                  "--couldn't get buffer size\n"
                  );
              }

              break;

            case GGO_METRICS:

              // Call to get just the metrics.

              cjRet =
                pdo.QueryFontData(
                  0,                        // device handle of PDEV
                  prfo->pfo(),
                  QFD_TT_GLYPHANDBITMAP,    // mode of call
                  hg,                       // glyph handle
                  &gd,                      // pointer to GLYPHDATA structure
                  0,                        // pointer to destination buffer
                  0                         // size of destination buffer in bytes
                  );
              if ( cjRet == FD_ERROR )
              {
                ASSERTGDI(cjRet == GDI_ERROR, "FD_ERROR != GDI_ERROR\n");
                WARNING(
                  "GreGetGlyphOutline(): FdQueryFontData()"
                  "--couldn't get GLYPHMETRICS\n"
                  );
              }
              break;

            default:

              WARNING("GreGetGlyphOutline(): bad parameter, unknown format\n");
              break;
            }

          }


          if ( cjRet != GDI_ERROR )
          {
            // Convert the GLYPHDATA metrics to GLYPHMETRICS.

            lpgm->gmBlackBoxX = (UINT) (gd.rclInk.right  - gd.rclInk.left);
            lpgm->gmBlackBoxY = (UINT) (gd.rclInk.bottom - gd.rclInk.top);

            // this is true by virtue of the fact that for tt fonts bitmap
            // is of the same size as the black box. The exception to this
            // rule is the empty space char which is a blank 1x1 bitmap

            lpgm->gmptGlyphOrigin.x = gd.rclInk.left;
            lpgm->gmptGlyphOrigin.y = - gd.rclInk.top;

            lpgm->gmCellIncX = (WORD) FXTOLROUND(gd.ptqD.x.u.HighPart);
            lpgm->gmCellIncY = (WORD) FXTOLROUND(gd.ptqD.y.u.HighPart);
          }
        }

        if (bEUDC)
        {
            rfo.dtHelper(FALSE);
            prfnt->flEUDCState = FALSE;
            if (prfntTmp)
            {
                switch (EudcType)
                {
                    case EUDCTYPE_SYSTEM_WIDE:
                        prfnt->prfntSysEUDC = prfntTmp;
                        break;
                    case EUDCTYPE_DEFAULT:
                        prfnt->prfntDefEUDC = prfntTmp;
                        break;
                    case EUDCTYPE_FACENAME:
                        prfnt->paprfntFaceName[numFaceName] = prfntTmp;
                        break;
                    default:
                        break;
                }
            }

            ASSERTGDI(gcEUDCCount > 0, "gcEUDCCount <= 0");
            DECREMENTEUDCCOUNT;
        }

      }
    }
  }
  return( cjRet );
}



VOID vIFIMetricsToETM(
    EXTTEXTMETRIC    *petm,
    RFONTOBJ&         rfo,
    DCOBJ&            dco,
    IFIMETRICS       *pifi
    );

/******************************Public*Routine******************************\
*
* GreGetETM
*
* support for aldus escape
*
* History:
*  19-Oct-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetETM(
    HDC hdc,
    EXTTEXTMETRIC *petm
    )
{

    EXTTEXTMETRIC  kmETM;
    BOOL bRet = FALSE;

    // Get DC user object.

    DCOBJ dco(hdc);

    if (petm && dco.bValid())
    {
        RFONTOBJ rfo(dco, FALSE);
        if (rfo.bValid())
        {

        // see if we can dispatch the call directly to the device driver

            PDEVOBJ pdo(rfo.hdevProducer());

            if (PPFNDRV(pdo,FontManagement))
            {
                ULONG    iMode = GETEXTENDEDTEXTMETRICS;
                SURFOBJ  *pso = NULL;

                if (pdo.bUMPD())
                {
                    // we need to have a dhpdev when calling out to UMPD

                    pso = (SURFOBJ *)pdo.dhpdev();
                }

                BOOL bSupported = GetETMFontManagement(
                                      rfo,
                                      pdo,
                                      pso,
                                      NULL,
                                      QUERYESCSUPPORT,  // iMode
                                      sizeof(ULONG),    // cjIn
                                      (PVOID)&iMode,    // pvIn
                                      0,                // cjOut
                                      (PVOID)NULL       // pvOut
                                      );

                if (bSupported)
                {
                    SURFOBJ  soFake;
                    SURFOBJ *pso = pdo.pSurface()->pSurfobj();

                    if (pso == (SURFOBJ *) NULL) // create vanilla surfobj
                    {
                        RtlFillMemory((BYTE *) &soFake,sizeof(SURFOBJ),0);
                        soFake.dhpdev = rfo.prfnt->dhpdev;
                        soFake.hdev   = rfo.hdevConsumer();
                        soFake.iType  = (USHORT)STYPE_DEVICE;
                        pso = &soFake;
                    }

                    bRet = pdo.FontManagement(
                                pso,
                                rfo.pfo(),
                                GETEXTENDEDTEXTMETRICS,
                                0,
                                (PVOID)NULL,
                                (ULONG)sizeof(EXTTEXTMETRIC),
                                (PVOID)&kmETM
                                );
                }
            }

            // if GETEXTENDEDTEXTMETRIC is not supported do something:
            // Get PFE user object.

            if (!bRet)
            {
                PFEOBJ pfeo(rfo.ppfe());
                if (pfeo.bValid())
                {
                    if (pfeo.flFontType() & TRUETYPE_FONTTYPE)
                    {
                        vIFIMetricsToETM(&kmETM,rfo,dco,pfeo.pifi());
                        bRet = TRUE;
                    }
                }
            }
        }
    }

    if (bRet)
    {
        __try
        {
            ProbeForWrite(petm,sizeof(EXTTEXTMETRIC),sizeof(ULONG));
            RtlMoveMemory(petm,&kmETM,sizeof(EXTTEXTMETRIC));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // SetLastError(GetExceptionCode());
            bRet = FALSE;
        }
    }

    return bRet;
}



/******************************Public*Routine******************************\
* GreGetOutlineTextMetricsInternalW
*
* History:
*
*  20-Apr-1993 -by- Gerrit van Wingerden [gerritv]
* Added bTTOnly field so we can service the Aldus escape for Win 3.1 compat.
* Changed to GreGe...InternalW to avoid a header file change in wingdip.h
*
*  16-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

UINT   cjOTMAWSize (
    PIFIMETRICS  pifi,        // compute size of OTM produced by this buffer
    UINT        *pcjotmw
    );


ULONG
GreGetOutlineTextMetricsInternalW(
    HDC                  hdc,
    ULONG                cjotm,
    OUTLINETEXTMETRICW   *potmw,
    TMDIFF               *ptmd
    )
{
    ULONG  cjRet = 0;

// Early out test.  Zero data requested.

    if ( (cjotm == 0) && (potmw != (OUTLINETEXTMETRICW*) NULL) )
    {
        WARNING("GreGetOutlineTextMetrics(): bad parameter\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return (cjRet);
    }

// Get DC user object.

    DCOBJ dco(hdc);
    if (!dco.bValid())
    {
        WARNING("GreGetOutlineTextMetrics(): bad handle for DC\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return (cjRet);
    }

    // the following is a copy of what is done during GreGetCharSet(), to fix 735873
    // where bIFIMetricsToTextMetricWStrict() get called while DIRTY_CHARSET is set and 
    // copy an unitialized value from dco.pdc->iCS_CP to ptmw->tmCharSet
    // if the font is not mapped, we need to map it
    if (dco.ulDirty() & DIRTY_CHARSET)
    {
        // force mapping
        FLONG    flSim;
        POINTL   ptlSim;
        FLONG    flAboutMatch;
        PFE     *ppfe;

        PDEVOBJ pdo(dco.hdev());
        ASSERTGDI(pdo.bValid(), "GreGetOutlineTextMetrics: bad pdev in dc\n");

        if (!pdo.bGotFonts())
            pdo.bGetDeviceFonts();

        LFONTOBJ lfo(dco.pdc->hlfntNew(), &pdo);

        if (!lfo.bValid())
        {
            WARNING("GreGetOutlineTextMetrics!RFONTOBJ(dco): bad LFONT handle\n");
            return(cjRet);
        }
        {
        // Stabilize the public PFT for mapping.

            SEMOBJ  so(ghsemPublicPFT);

        // LFONTOBJ::ppfeMapFont returns a pointer to the physical font face and
        // a simulation type (ist)
        // also store charset to the DC

            ppfe = lfo.ppfeMapFont(dco, &flSim, &ptlSim, &flAboutMatch);

            ASSERTGDI(!(dco.ulDirty() & DIRTY_CHARSET),
                      "NtGdiGetCharSet, charset is dirty\n");

        }
    }

    // Get RFONT user object.

    // Old Comment:
    //  - This should really be an LFONTOBJ

    RFONTOBJ rfo(dco, FALSE);
    if (!rfo.bValid())
    {
        WARNING("GreGetOutlineTextMetrics(): could not lock HRFONT\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return (cjRet);
    }

// Get PFE user object.

    PFEOBJ pfeo(rfo.ppfe());
    if (!pfeo.bValid())
    {
        WARNING("GreGetOutlineTextMetrics(): could not lock HPFE\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return (cjRet);
    }

// Get LDEV user object for the font driver.

    PDEVOBJ pdo(rfo.hdevProducer());

// Check the font driver.  If we are in TT only mode, we will allow only
// the TrueType driver to succeed.  However, in this sense, the TrueType
// driver is any driver that exports DrvQueryTrueTypeOutline.  Afterall,
// if it can supply the actual outlines, it should be able to supply the
// metrics.
//
// Actually, it would be nice to allow this function to work for all
// drivers since all drivers supply the IFIMETRICS and therefore can
// answer this question.  However, we are much too afraid that this will
// break some obscure compatibility so we will let our TT driver and
// 3rd part TT-like drivers succeed.
//
// If we not in TT only mode, then everybody succeed this function! Yay!

    if (PPFNVALID(pdo, QueryTrueTypeOutline))
    {
        // Size if full OUTLINETEXTMETRICW (including strings) is copied.

        UINT cjotmw;

        // use cjotma field of tmd to ship cjotma to the client side, [bodind]

        ptmd->cjotma = (ULONG)cjOTMAWSize(pfeo.pifi(), &cjotmw);

        // If return buffer is NULL, then only size needs to be returned.

        if (potmw == NULL)
        {
            cjRet = cjotmw;
        }
        else
        {
            // Is return buffer big enough for the conversion routine (which is not
            // capable of converting a partial OUTLINETEXTMETRICW structure [unless,
            // of course, it's one without the strings]).

            if (cjotm <= sizeof(OUTLINETEXTMETRICW))
            {
                // Allocate a buffer for a full OUTLINETEXTMETRICW, since conversion
                // routine needs at least that much memory.

                OUTLINETEXTMETRICW otmwTmp;
                RtlZeroMemory(&otmwTmp, sizeof(OUTLINETEXTMETRICW));

                // Convert IFIMETRICS to OUTLINETEXTMETRICW using temp buffer.

                if (
                    (cjRet = cjIFIMetricsToOTMW(
                                   ptmd,
                                   &otmwTmp,
                                   rfo,
                                   dco,
                                   pfeo.pifi(),
                                   FALSE           // do not need strings
                                   )) == 0 )
                {
                    WARNING("GreGetOutlineTextMetrics(): error creating OUTLINETEXTMETRIC\n");
                    return (cjRet);
                }

                // Copy needed part of OUTLINETEXTMETRICW into return buffer.


                RtlCopyMemory((PVOID) potmw, (PVOID) &otmwTmp, cjotm);
                return cjotm;
            }

            // Otherwise asking for strings

            // We have to assume that all the strings are desired.  If
            // cjCopy > sizeof(OUTLINETEXTMETRICW) how can we
            // know how many strings are requested?  Afterall, the app is not
            // supposed to have apriori knowledge of the length of the strings.
            // Note that this is also a Win3.1 compatible assumption.  (They
            // assume the same thing).

            if ( cjotm >= cjotmw )
            {
                // Convert IFIMETRICS to OUTLINETEXTMETRICW using return buffer.

                cjRet = cjIFIMetricsToOTMW(ptmd,potmw, rfo, dco, pfeo.pifi(), TRUE);

                // clean up the rest of the buffer so that neilc - " Mr. c2 guy" is happy

                {
                    LONG lDiff = (LONG)cjotm - (LONG)cjRet;
                    ASSERTGDI(lDiff >= 0, "GetOTM, lDiff < 0");
                    if (lDiff > 0)
                        RtlZeroMemory(((BYTE*)potmw + cjRet), lDiff);
                }
            }
        }
    }

    return (cjRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\trig.cxx ===
/******************************Module*Header*******************************\
* Module Name: trig.cxx
*
* trigonometric functions
* adjusted andrew code so that it works with wendy's ELOATS
*
* Created: 05-Mar-1991 09:55:39
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
* (General description of its use)
*
* Dependencies:
*
\**************************************************************************/

#include "precomp.hxx"


/******************************Public*Data******************************\
* It's Hack-o-rama time.  The new 'C' compiler that runs on NT does
* not have support for floating point constants.  All floating point
* constants must be defined in HEX values.  In this file we have a
* variable for each of the HEX constants used in the engine.  flhack.hxx
* has some #defines for casting these into floating point values.
* The end result is a floating point constant like 3.0f get changed
* to FP_3_0.
*
* To add a new floating point constant do the following:
*
*       1) check if already in the list.  If so, no need to add
*          it again.
*       2) Create a definition for it below.  Figuring the exact
*          HEX constant is a little tricky.  See kentd for help.
*       3) Edit flhack.hxx, adding the proper defines.
*       4) Include flhack.hxx in the file with the constant.
*       5) Replace the constant X.Xf with FPX_X.
*
* the proper floating point support.
*
* History:
*  22-Jul-1991 -by- J. Andrew Goossen [andrewgo]
* Nuked all FLOATs.  Will eventually generate this file at compile time.
*
*  01-May-1991 -by- Kent Diamond [kentd]
* Wrote it.
\**************************************************************************/

#if defined(_AMD64_) || defined(_IA64_) || defined(BUILD_WOW6432)

    //
    // IEEE floats:
    //

extern "C" {
    ULONG gaefArctan[] =
    {
        0x0, 0x3fe51bca, 0x4064e2aa, 0x40ab62eb,
        0x40e40022, 0x410e172e, 0x4129ea1c, 0x41456ce7,
        0x41609474, 0x417b5695, 0x418ad50b, 0x4197c365,
        0x41a472c8, 0x41b0e026, 0x41bd08f7, 0x41c8eb2f,
        0x41d4853a, 0x41dfd5f7, 0x41eadcae, 0x41f59908,
        0x42000583, 0x4205197c, 0x420a08ba, 0x420ed3a7,
        0x42137ac6, 0x4217feb4, 0x421c601d, 0x42209fbe,
        0x4224be63, 0x4228bcdf, 0x422c9c0c, 0x42305ccb,
        0x42340000, 0x0
    };

    ULONG gaefSin[] =
    {
        0x0, 0x3d48fb30, 0x3dc8bd36, 0x3e164083,
        0x3e47c5c2, 0x3e78cfcc, 0x3e94a031, 0x3eac7cd4,
        0x3ec3ef15, 0x3edae880, 0x3ef15aea, 0x3f039c3d,
        0x3f0e39da, 0x3f187fc0, 0x3f226799, 0x3f2beb4a,
        0x3f3504f3, 0x3f3daef9, 0x3f45e403, 0x3f4d9f02,
        0x3f54db31, 0x3f5b941a, 0x3f61c598, 0x3f676bd8,
        0x3f6c835e, 0x3f710908, 0x3f74fa0b, 0x3f7853f8,
        0x3f7b14be, 0x3f7d3aac, 0x3f7ec46d, 0x3f7fb10f,
        0x3f800000
    };

    ULONG gaefAxisCoord[] =
    {
        0x0, 0x3f800000, 0x0, 0xbf800000
    };

    ULONG gaefAxisAngle[] =
    {
        0x0, 0x42b40000, 0x43340000, 0x43870000,
        0x43b40000
    };

    ULONG FP_0_0     = 0x0;
    ULONG FP_0_005   = 0x3ba3d70a;
    ULONG FP_0_5     = 0x3f000000;
    ULONG FP_1_0     = 0x3f800000;
    ULONG FP_2_0     = 0x40000000;
    ULONG FP_3_0     = 0x40400000;
    ULONG FP_4_0     = 0x40800000;
    ULONG FP_90_0    = 0x42b40000;
    ULONG FP_180_0   = 0x43340000;
    ULONG FP_270_0   = 0x43870000;
    ULONG FP_360_0   = 0x43b40000;
    ULONG FP_1000_0  = 0x447a0000;
    ULONG FP_3600_0  = 0x45610000;
    ULONG FP_M3600_0 = 0xc5610000;

    ULONG FP_QUADRANT_TAU = 0x3ee53aef;  // 0.44772...
    ULONG FP_ORIGIN_TAU   = 0x3f0d6289;  // 0.552...
    ULONG FP_SINE_FACTOR  = 0x3eb60b61;  // SINE_TABLE_SIZE / 90.0
    ULONG FP_4DIV3        = 0x3faaaaab;
    ULONG FP_1DIV90       = 0x3c360b61;
    ULONG FP_EPSILON      = 0x37800000;
    ULONG FP_ARCTAN_TABLE_SIZE = 0x42000000;
    ULONG FP_PI           = 0x40490fda;  // 3.1415926...
};

#else

    //
    // Internal EFloats:
    //

extern "C" {
    EFLOAT_S gaefArctan[] =
    {
        {0x0, 0}, {0x728de539, 2}, {0x727154c9, 3},
        {0x55b17599, 4}, {0x72001124, 4}, {0x470b9706, 5},
        {0x54f50dd3, 5}, {0x62b67364, 5}, {0x704a3a03, 5},
        {0x7dab4a4f, 5}, {0x456a856f, 6}, {0x4be1b295, 6},
        {0x523963eb, 6}, {0x5870133a, 6}, {0x5e847b98, 6},
        {0x64759746, 6}, {0x6a429cc6, 6}, {0x6feafb55, 6},
        {0x756e56f1, 6}, {0x7acc8411, 6}, {0x4002c196, 7},
        {0x428cbe1e, 7}, {0x45045d20, 7}, {0x4769d374, 7},
        {0x49bd6339, 7}, {0x4bff59db, 7}, {0x4e300e45, 7},
        {0x504fdf2e, 7}, {0x525f3195, 7}, {0x545e6f5a, 7},
        {0x564e0606, 7}, {0x582e65af, 7}, {0x5a000000, 7},
        {0x0, 0}
    };

    EFLOAT_S gaefSin[] =
    {
        {0x0, 0}, {0x647d97c4, -3}, {0x645e9af0, -2},
        {0x4b2041ba, -1}, {0x63e2e0f1, -1}, {0x7c67e5ec, -1},
        {0x4a5018bb, 0}, {0x563e69d6, 0}, {0x61f78a9a, 0},
        {0x6d744027, 0}, {0x78ad74e0, 0}, {0x41ce1e64, 1},
        {0x471cece6, 1}, {0x4c3fdff3, 1}, {0x5133cc94, 1},
        {0x55f5a4d2, 1}, {0x5a827999, 1}, {0x5ed77c89, 1},
        {0x62f201ac, 1}, {0x66cf811f, 1}, {0x6a6d98a4, 1},
        {0x6dca0d14, 1}, {0x70e2cbc6, 1}, {0x73b5ebd0, 1},
        {0x7641af3c, 1}, {0x78848413, 1}, {0x7a7d055b, 1},
        {0x7c29fbee, 1}, {0x7d8a5f3f, 1}, {0x7e9d55fc, 1},
        {0x7f62368f, 1}, {0x7fd8878d, 1}, {0x40000000, 2}
    };

    EFLOAT_S gaefAxisCoord[] =
    {
        {0x0, 0}, {0x40000000, 2}, {0x0, 0},
        {0xc0000000, 2}
    };

    EFLOAT_S gaefAxisAngle[] =
    {
        {0x0, 0}, {0x5a000000, 8}, {0x5a000000, 9},
        {0x43800000, 10}, {0x5a000000, 10}
    };

    EFLOAT_S FP_0_0     = {0x0, 0};
    EFLOAT_S FP_0_005   = {0x51eb851e, -6};
    EFLOAT_S FP_0_5     = {0x40000000, 1};
    EFLOAT_S FP_1_0     = {0x40000000, 2};
    EFLOAT_S FP_2_0     = {0x40000000, 3};
    EFLOAT_S FP_3_0     = {0x60000000, 3};
    EFLOAT_S FP_4_0     = {0x40000000, 4};
    EFLOAT_S FP_90_0    = {0x5a000000, 8};
    EFLOAT_S FP_180_0   = {0x5a000000, 9};
    EFLOAT_S FP_270_0   = {0x43800000, 10};
    EFLOAT_S FP_360_0   = {0x5a000000, 10};
    EFLOAT_S FP_1000_0  = {0x7d000000, 11};
    EFLOAT_S FP_3600_0  = {0x70800000, 13};
    EFLOAT_S FP_M3600_0 = {0x8f800000, 13};

    EFLOAT_S FP_QUADRANT_TAU = {0x729d7775, 0};  // 0.44772...
    EFLOAT_S FP_ORIGIN_TAU   = {0x46b14445, 1};  // 0.552...
    EFLOAT_S FP_SINE_FACTOR  = {0x5b05b05b, 0};  // SINE_TABLE_SIZE / 90.0
    EFLOAT_S FP_4DIV3        = {0x55555555, 2};
    EFLOAT_S FP_1DIV90       = {0x5b05b05b, -5};
    EFLOAT_S FP_EPSILON      = {0x40000000, -14};
    EFLOAT_S FP_ARCTAN_TABLE_SIZE = {0x40000000, 7};
    EFLOAT_S FP_PI           = {0x6487ed51, 3};  // 3.1415926...
};

#endif


/******************************Public*Routine******************************\
* EFLOAT functions                                                         *
*                                                                          *
* Wrote it.                                                                *
\**************************************************************************/

EFLOAT EFLOAT::eqCross(const POINTFL& ptflA, const POINTFL& ptflB)
{
    EFLOAT efTmp;

    efTmp.eqMul(ptflA.y,ptflB.x);
    eqMul(ptflA.x,ptflB.y);
    return(eqSub(*this,efTmp));
}

EFLOAT EFLOAT::eqDot(const POINTFL& ptflA, const POINTFL& ptflB)
{
    EFLOAT efTmp;

    efTmp.eqMul(ptflA.x,ptflB.x);
    eqMul(ptflA.y,ptflB.y);
    return(eqAdd(*this,efTmp));
}

EFLOAT EFLOAT::eqLength(const POINTFL& ptflA)
{
    return(eqSqrt(eqDot(ptflA,ptflA)));
}

/******************************Public*Routine******************************\
* lNormAngle (lAngle)                                                      *
*                                                                          *
* Given an angle in tenths of a degree, returns an equivalent positive     *
* angle of less than 360.0 degrees.                                        *
*                                                                          *
*  Sat 21-Mar-1992 12:27:18 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

LONG lNormAngle(LONG lAngle)
{
    if (lAngle >= 3600)
	return(lAngle % 3600);

    if (lAngle < 0)
	return(3599 - ((-lAngle-1) % 3600));
    else
	return(lAngle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\ugdiport.h ===
/******************************Module*Header*******************************\
* Module Name: ugdiport.h
*
* Macros to ease UGDI porting
*
* Copyright (c) 1998-1999 Microsoft Corporation
\**************************************************************************/

#if defined(_GDIPLUS_)

#define DEREFERENCE_FONTVIEW_SECTION DeleteMemoryMappedSection

#define ZwCreateKey     NtCreateKey
#define ZwQueryKey      NtQueryKey
#define ZwQueryValueKey NtQueryValueKey
#define ZwSetValueKey   NtSetValueKey
#define ZwCloseKey      NtClose

#else // !_GDIPLUS_

#define DEREFERENCE_FONTVIEW_SECTION Win32DestroySection
#define ZwCloseKey  ZwClose

#endif  // !_GDIPLUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\trivblt.cxx ===
/******************************Module*Header*******************************\
* Module Name: trivblt.cxx
*
* EngCopyBits does the bitmap simulations source copy blts.
* The Rop is 0xCCCC, no brush or mask required.  Dib src
* and Dib dest are required.
*
* Created: 05-Feb-1991 21:06:12
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

//
// The following table is used to lookup the function to be used for a
// particular type of copy operation. The table is indexed by a loosely
// encoded index composed of the source format, the destination format,
// the direction of the move, and whether the function is an identify
// function.
//
// This table is used in lieu of a doubly nested switch structure that
// not only takes more room, but requires more execution time.
//
// The index is formed as:
//
//     Index = (iFormatDst << 5) | (iFormatSrc << 2);
//     if (xDir < 0) {
//         Index += 2;
//     }
//
//     if (pxlo->bIsIdentity()) {
//         Index += 1;
//     }
//
// N.B. The entire table is filled. Entries that are illegal are tested
//     for using assertions. In free systems, dummy entries are used.
//



VOID
vSrcCopyDummy (
    PBLTINFO BltInfo
    );

PFN_SRCCPY SrcCopyFunctionTable[] = {
        vSrcCopyDummy,              // 000-000-0-0 Dst = ?, Src = ?
        vSrcCopyDummy,              // 000-000-0-1
        vSrcCopyDummy,              // 000-000-1-0
        vSrcCopyDummy,              // 000-000-1-1

        vSrcCopyDummy,              // 000-001-0-0 Dst = ?, Src = BMF_1BPP
        vSrcCopyDummy,              // 000-001-0-1
        vSrcCopyDummy,              // 000-001-1-0
        vSrcCopyDummy,              // 000-001-1-1

        vSrcCopyDummy,              // 000-010-0-0 Dst = ?, Src = BMF_4BPP
        vSrcCopyDummy,              // 000-010-0-1
        vSrcCopyDummy,              // 000-010-1-0
        vSrcCopyDummy,              // 000-010-1-1

        vSrcCopyDummy,              // 000-011-0-0 Dst = ?, Src = BMF_8BPP
        vSrcCopyDummy,              // 000-011-0-1
        vSrcCopyDummy,              // 000-011-1-0
        vSrcCopyDummy,              // 000-011-1-1

        vSrcCopyDummy,              // 000-100-0-0 Dst = ?, Src = BMF_16BPP
        vSrcCopyDummy,              // 000-100-0-1
        vSrcCopyDummy,              // 000-100-1-0
        vSrcCopyDummy,              // 000-100-1-1

        vSrcCopyDummy,              // 000-101-0-0 Dst = ?, Src = BMF_24BPP
        vSrcCopyDummy,              // 000-101-0-1
        vSrcCopyDummy,              // 000-101-1-0
        vSrcCopyDummy,              // 000-101-1-1

        vSrcCopyDummy,              // 000-110-0-0 Dst = ?, Src = BMF_32BPP
        vSrcCopyDummy,              // 000-110-0-1
        vSrcCopyDummy,              // 000-110-1-0
        vSrcCopyDummy,              // 000-110-1-1

        vSrcCopyDummy,              // 000-111-0-0 Dst = ?, Src = ?
        vSrcCopyDummy,              // 000-111-0-1
        vSrcCopyDummy,              // 000-111-1-0
        vSrcCopyDummy,              // 000-111-1-1

        vSrcCopyDummy,              // 001-000-0-0 Dst = BMF_1BPP, Src = ?
        vSrcCopyDummy,              // 001-000-0-1
        vSrcCopyDummy,              // 001-000-1-0
        vSrcCopyDummy,              // 001-000-1-1

        vSrcCopyS1D1LtoR,           // 001-001-0-0 Dst = BMF_1BPP, Src = BMF_1BPP
        vSrcCopyS1D1LtoR,           // 001-001-0-1
        vSrcCopyS1D1RtoL,           // 001-001-1-0
        vSrcCopyS1D1RtoL,           // 001-001-1-1

        vSrcCopyS4D1,               // 001-010-0-0 Dst = BMF_1BPP, Src = BMF_4BPP
        vSrcCopyS4D1,               // 001-010-0-1
        vSrcCopyS4D1,               // 001-010-1-0
        vSrcCopyS4D1,               // 001-010-1-1

        vSrcCopyS8D1,               // 001-011-0-0 Dst = BMF_1BPP, Src = BMF_8BPP
        vSrcCopyS8D1,               // 001-011-0-1
        vSrcCopyS8D1,               // 001-011-1-0
        vSrcCopyS8D1,               // 001-011-1-1

        vSrcCopyS16D1,              // 001-100-0-0 Dst = BMF_1BPP, Src = BMF_16BPP
        vSrcCopyS16D1,              // 001-100-0-1
        vSrcCopyS16D1,              // 001-100-1-0
        vSrcCopyS16D1,              // 001-100-1-1

        vSrcCopyS24D1,              // 001-101-0-0 Dst = BMF_1BPP, Src = BMF_24BPP
        vSrcCopyS24D1,              // 001-101-0-1
        vSrcCopyS24D1,              // 001-101-1-0
        vSrcCopyS24D1,              // 001-101-1-1

        vSrcCopyS32D1,              // 001-110-0-0 Dst = BMF_1BPP, Src = BMF_32BPP
        vSrcCopyS32D1,              // 001-110-0-1
        vSrcCopyS32D1,              // 001-110-1-0
        vSrcCopyS32D1,              // 001-110-1-1

        vSrcCopyDummy,              // 001-111-0-0 Dst = BMF_1BPP, Src = ?
        vSrcCopyDummy,              // 001-111-0-1
        vSrcCopyDummy,              // 001-111-1-0
        vSrcCopyDummy,              // 001-111-1-1

        vSrcCopyDummy,              // 010-000-0-0 Dst = BMF_4BPP, Src = ?
        vSrcCopyDummy,              // 010-000-0-1
        vSrcCopyDummy,              // 010-000-1-0
        vSrcCopyDummy,              // 010-000-1-1

        vSrcCopyS1D4,               // 010-001-0-0 Dst = BMF_4BPP, Src = BMF_1BPP
        vSrcCopyS1D4,               // 010-001-0-1
        vSrcCopyS1D4,               // 010-001-1-0
        vSrcCopyS1D4,               // 010-001-1-1

        vSrcCopyS4D4,               // 010-010-0-0 Dst = BMF_4BPP, Src =BMF_4BPP
        vSrcCopyS4D4Identity,       // 010-010-0-1
        vSrcCopyS4D4,               // 010-010-1-0
        vSrcCopyS4D4Identity,       // 010-010-1-1

        vSrcCopyS8D4,               // 010-011-0-0 Dst = BMF_4BPP, Src = BMF_8BPP
        vSrcCopyS8D4,               // 010-011-0-1
        vSrcCopyS8D4,               // 010-011-1-0
        vSrcCopyS8D4,               // 010-011-1-1

        vSrcCopyS16D4,              // 010-100-0-0 Dst = BMF_4BPP, Src = BMF_16BPP
        vSrcCopyS16D4,              // 010-100-0-1
        vSrcCopyS16D4,              // 010-100-1-0
        vSrcCopyS16D4,              // 010-100-1-1

        vSrcCopyS24D4,              // 010-101-0-0 Dst = BMF_4BPP, Src = BMF_24BPP
        vSrcCopyS24D4,              // 010-101-0-1
        vSrcCopyS24D4,              // 010-101-1-0
        vSrcCopyS24D4,              // 010-101-1-1

        vSrcCopyS32D4,              // 010-110-0-0 Dst = BMF_4BPP, Src = BMF_32BPP
        vSrcCopyS32D4,              // 010-110-0-1
        vSrcCopyS32D4,              // 010-110-1-0
        vSrcCopyS32D4,              // 010-110-1-1

        vSrcCopyDummy,              // 010-111-0-0 Dst = BMF_4BPP, Src = ?
        vSrcCopyDummy,              // 010-111-0-1
        vSrcCopyDummy,              // 010-111-1-0
        vSrcCopyDummy,              // 010-111-1-1

        vSrcCopyDummy,              // 011-000-0-0 Dst = BMF_8BPP, Src = ?
        vSrcCopyDummy,              // 011-000-0-1
        vSrcCopyDummy,              // 011-000-1-0
        vSrcCopyDummy,              // 011-000-1-1

        vSrcCopyS1D8,               // 011-001-0-0 Dst = BMF_8BPP, Src = BMF_1BPP
        vSrcCopyS1D8,               // 011-001-0-1
        vSrcCopyS1D8,               // 011-001-1-0
        vSrcCopyS1D8,               // 011-001-1-1

        vSrcCopyS4D8,               // 011-010-0-0 Dst = BMF_8BPP, Src = BMF_4BPP
        vSrcCopyS4D8,               // 011-010-0-1
        vSrcCopyS4D8,               // 011-010-1-0
        vSrcCopyS4D8,               // 011-010-1-1

        vSrcCopyS8D8,               // 011-011-0-0 Dst = BMF_8BPP, Src = BMF_8BPP
        vSrcCopyS8D8IdentityLtoR,   // 011-011-0-1
        vSrcCopyS8D8,               // 011-011-1-0
        vSrcCopyS8D8IdentityRtoL,   // 011-011-1-1

        vSrcCopyS16D8,              // 011-100-0-0 Dst = BMF_8BPP, Src = BMF_16BPP
        vSrcCopyS16D8,              // 011-100-0-1
        vSrcCopyS16D8,              // 011-100-1-0
        vSrcCopyS16D8,              // 011-100-1-1

        vSrcCopyS24D8,              // 011-101-0-0 Dst = BMF_8BPP, Src = BMF_24BPP
        vSrcCopyS24D8,              // 011-101-0-1
        vSrcCopyS24D8,              // 011-101-1-0
        vSrcCopyS24D8,              // 011-101-1-1

        vSrcCopyS32D8,              // 011-110-0-0 Dst = BMF_8BPP, Src = BMF_32BPP
        vSrcCopyS32D8,              // 011-110-0-1
        vSrcCopyS32D8,              // 011-110-1-0
        vSrcCopyS32D8,              // 011-110-1-1

        vSrcCopyDummy,              // 011-111-0-0 Dst = BMF_8BPP, Src = ?
        vSrcCopyDummy,              // 011-111-0-1
        vSrcCopyDummy,              // 011-111-1-0
        vSrcCopyDummy,              // 011-111-1-1

        vSrcCopyDummy,              // 100-000-0-0 Dst = BMF_16BPP, Src = ?
        vSrcCopyDummy,              // 100-000-0-1
        vSrcCopyDummy,              // 100-000-1-0
        vSrcCopyDummy,              // 100-000-1-1

        vSrcCopyS1D16,              // 100-001-0-0 Dst = BMF_16BPP, Src = BMF_1BPP
        vSrcCopyS1D16,              // 100-001-0-1
        vSrcCopyS1D16,              // 100-001-1-0
        vSrcCopyS1D16,              // 100-001-1-1

        vSrcCopyS4D16,              // 100-010-0-0 Dst = BMF_16BPP, Src = BMF_4BPP
        vSrcCopyS4D16,              // 100-010-0-1
        vSrcCopyS4D16,              // 100-010-1-0
        vSrcCopyS4D16,              // 100-010-1-1

        vSrcCopyS8D16,              // 100-011-0-0 Dst = BMF_16BPP, Src = BMF_8BPP
        vSrcCopyS8D16,              // 100-011-0-1
        vSrcCopyS8D16,              // 100-011-1-0
        vSrcCopyS8D16,              // 100-011-1-1

        vSrcCopyS16D16,             // 100-100-0-0 Dst = BMF_16BPP, Src = BMF_16BPP
        vSrcCopyS16D16Identity,     // 100-100-0-1
        vSrcCopyS16D16,             // 100-100-1-0
        vSrcCopyS16D16Identity,     // 100-100-1-1

        vSrcCopyS24D16,             // 100-101-0-0 Dst = BMF_16BPP, Src = BMF_24BPP
        vSrcCopyS24D16,             // 100-101-0-1
        vSrcCopyS24D16,             // 100-101-1-0
        vSrcCopyS24D16,             // 100-101-1-1

        vSrcCopyS32D16,             // 100-110-0-0 Dst = BMF_16BPP, Src = BMF_32BPP
        vSrcCopyS32D16,             // 100-110-0-1
        vSrcCopyS32D16,             // 100-110-1-0
        vSrcCopyS32D16,             // 100-110-1-1

        vSrcCopyDummy,              // 100-111-0-0 Dst = BMF_16BPP, Src = ?
        vSrcCopyDummy,              // 100-111-0-1
        vSrcCopyDummy,              // 100-111-1-0
        vSrcCopyDummy,              // 100-111-1-1

        vSrcCopyDummy,              // 101-000-0-0 Dst = BMF_24BPP, Src = ?
        vSrcCopyDummy,              // 101-000-0-1
        vSrcCopyDummy,              // 101-000-1-0
        vSrcCopyDummy,              // 101-000-1-1

        vSrcCopyS1D24,              // 101-001-0-0 Dst = BMF_24BPP, Src = BMF_1BPP
        vSrcCopyS1D24,              // 101-001-0-1
        vSrcCopyS1D24,              // 101-001-1-0
        vSrcCopyS1D24,              // 101-001-1-1

        vSrcCopyS4D24,              // 101-010-0-0 Dst = BMF_24BPP, Src = BMF_4BPP
        vSrcCopyS4D24,              // 101-010-0-1
        vSrcCopyS4D24,              // 101-010-1-0
        vSrcCopyS4D24,              // 101-010-1-1

        vSrcCopyS8D24,              // 101-011-0-0 Dst = BMF_24BPP, Src = BMF_8BPP
        vSrcCopyS8D24,              // 101-011-0-1
        vSrcCopyS8D24,              // 101-011-1-0
        vSrcCopyS8D24,              // 101-011-1-1

        vSrcCopyS16D24,             // 101-100-0-0 Dst = BMF_24BPP, Src = BMF_16BPP
        vSrcCopyS16D24,             // 101-100-0-1
        vSrcCopyS16D24,             // 101-100-1-0
        vSrcCopyS16D24,             // 101-100-1-1

        vSrcCopyS24D24,             // 101-101-0-0 Dst = BMF_24BPP, Src = BMF_24BPP
        vSrcCopyS24D24Identity,     // 101-101-0-1
        vSrcCopyS24D24,             // 101-101-1-0
        vSrcCopyS24D24Identity,     // 101-101-1-1

        vSrcCopyS32D24,             // 101-110-0-0 Dst = BMF_24BPP, Src = BMF_32BPP
        vSrcCopyS32D24,             // 101-110-0-1
        vSrcCopyS32D24,             // 101-110-1-0
        vSrcCopyS32D24,             // 101-110-1-1

        vSrcCopyDummy,              // 101-111-0-0 Dst = BMF_24BPP, Src = ?
        vSrcCopyDummy,              // 101-111-0-1
        vSrcCopyDummy,              // 101-111-1-0
        vSrcCopyDummy,              // 101-111-1-1

        vSrcCopyDummy,              // 110-000-0-0 Dst = BMF_32BPP, Src = ?
        vSrcCopyDummy,              // 110-000-0-1
        vSrcCopyDummy,              // 110-000-1-0
        vSrcCopyDummy,              // 110-000-1-1

        vSrcCopyS1D32,              // 110-001-0-0 Dst = BMF_32BPP, Src = BMF_1BPP
        vSrcCopyS1D32,              // 110-001-0-1
        vSrcCopyS1D32,              // 110-001-1-0
        vSrcCopyS1D32,              // 110-001-1-1

        vSrcCopyS4D32,              // 110-010-0-0 Dst = BMF_32BPP, Src = BMF_4BPP
        vSrcCopyS4D32,              // 110-010-0-1
        vSrcCopyS4D32,              // 110-010-1-0
        vSrcCopyS4D32,              // 110-010-1-1

        vSrcCopyS8D32,              // 110-011-0-0 Dst = BMF_32BPP, Src = BMF_8BPP
        vSrcCopyS8D32,              // 110-011-0-1
        vSrcCopyS8D32,              // 110-011-1-0
        vSrcCopyS8D32,              // 110-011-1-1

        vSrcCopyS16D32,             // 110-100-0-0 Dst = BMF_32BPP, Src = BMF_16BPP
        vSrcCopyS16D32,             // 110-100-0-1
        vSrcCopyS16D32,             // 110-100-1-0
        vSrcCopyS16D32,             // 110-100-1-1

        vSrcCopyS24D32,             // 110-101-0-0 Dst = BMF_32BPP, Src = BMF_24BPP
        vSrcCopyS24D32,             // 110-101-0-1
        vSrcCopyS24D32,             // 110-101-1-0
        vSrcCopyS24D32,             // 110-101-1-1

        vSrcCopyS32D32,             // 110-110-0-0 Dst = BMF_32BPP, Src = BMF_32BPP
        vSrcCopyS32D32Identity,     // 110-110-0-1
        vSrcCopyS32D32,             // 110-110-1-0
        vSrcCopyS32D32Identity,     // 110-110-1-1

        vSrcCopyDummy,              // 110-111-0-0 Dst = BMF_32BPP, Src = ?
        vSrcCopyDummy,              // 110-111-0-1
        vSrcCopyDummy,              // 110-111-1-0
        vSrcCopyDummy               // 110-111-1-1
};

/******************************Public*Routine******************************\
* EngCopyBits
*
* Purpose:  Does all 0xCCCC blts.  This includes RLE blts.
*
* Description:
*
*    Sets up for a blt from <psoSrc> to <psoDst>.  The actual copying of
*    the bits is performed by a function call.  The function to be used
*    is determined by the formats of the source & destination - and is
*    is selected by making a call to <pfnSrcCpy>.
*
*    The blt setup consists of filling a BLTINFO structure with
*       - offsets into the source and destination bitmaps
*       - intial values of the source and destination pointers
*       - ending points in source and destination.
*
*    This function also controls clipping:  In the complex clipping case,
*    the BLTINFO structure is set up and the blt function is called for
*    EACH rectangle in the clipping object <pco>.
*
*    NB:  RLE Sources are treated as a special case, since we can't cheat
*         and start copying from inside the source bitmap.  We must play
*         the RLE from the beginning for each clipping region.
*         An optimization to get around this is coming.
*
* History:
*  22-Jan-1992 - Andrew Milton (w-andym):
*      Isolated the RLE source cases and provided some RLE play
*      optimizations.
*
*  02-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
EngCopyBits(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    PRECTL      prclDst,
    PPOINTL     pptlSrc
)
{
    ASSERTGDI(psoDst != NULL, "ERROR EngCopyBits:  No Dst. Object\n");
    ASSERTGDI(psoSrc != NULL, "ERROR EngCopyBits:  No Src. Object\n");
    ASSERTGDI(prclDst != (PRECTL) NULL,  "ERROR EngCopyBits:  No Target Rect.\n");
    ASSERTGDI(pptlSrc != (PPOINTL) NULL, "ERROR EngCopyBits:  No Start Point.\n");
    ASSERTGDI(prclDst->left < prclDst->right, "ERROR EngCopyBits0\n");
    ASSERTGDI(prclDst->top < prclDst->bottom, "ERROR EngCopyBits1\n");

    ASSERTGDI(psoDst->iType == STYPE_BITMAP,
              "ERROR EngCopyBits:  Dst. Object is not a bitmap.\n");

    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);
    PSURFACE pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);

    ASSERTGDI(pSurfDst->iFormat() != BMF_JPEG,
              "ERROR EngCopyBits: dst BMF_JPEG\n");
    ASSERTGDI(pSurfDst->iFormat() != BMF_PNG,
              "ERROR EngCopyBits: dst BMF_PNG\n");
    ASSERTGDI(pSurfSrc->iFormat() != BMF_JPEG,
              "ERROR EngCopyBits: src BMF_JPEG\n");
    ASSERTGDI(pSurfSrc->iFormat() != BMF_PNG,
              "ERROR EngCopyBits: src BMF_PNG\n");

// If this is a device surface pass it off to the driver.

    if (psoSrc->iType != STYPE_BITMAP)
    {
        PDEVOBJ pdoSrc(pSurfSrc->hdev());

        PFN_DrvCopyBits pfnCopyBits = PPFNDRV(pdoSrc,CopyBits);

    // If the source is a mirrored surface, pass the read request back 
    // through the DDML.  This allows a driver like NetMeeting to read
    // from the screen:

        EXLATEOBJ xloParent;

        if (pSurfSrc->bMirrorSurface() &&
            (pdoSrc.hdev() != pdoSrc.hdevParent()))
        {
            PDEVOBJ pdoSrc(pSurfSrc->hdev());
            PDEVOBJ pdoParent(pdoSrc.hdevParent());
            SURFREF srParent((HSURF)pSurfSrc->hMirrorParent);
            if (!srParent.bValid()) return (FALSE);
            if (xloParent.bInitXlateObj(
                          NULL,DC_ICM_OFF,
                          pdoParent.ppalSurf(), pdoSrc.ppalSurf(),
                          ppalDefault, ppalDefault, 
                          0L,0L,0L, XLATE_USE_SURFACE_PAL))
                pxlo = xloParent.pxlo();
            else
                return (FALSE);

            psoSrc      = srParent.ps->pSurfobj();
            pfnCopyBits = PPFNDRV(pdoParent, CopyBits);
        }

        return(pfnCopyBits(psoDst,
                           psoSrc,
                           pco,
                           pxlo,
                           prclDst,
                           pptlSrc));
    }

// Synchronize with the device driver before touching the device surface.

    {
        PDEVOBJ po(psoDst->hdev);
        po.vSync(psoDst,NULL,0);
    }

    {
        PDEVOBJ po(psoSrc->hdev);
        po.vSync(psoSrc,NULL,0);
    }

// Local Variables required for the blt

    BOOL     bMore;            // True while more clip regions exist
    BOOL     bRLE = FALSE;     // True if the source is an RLE bitmap
    ULONG    ircl;             // Clip region index
    BLTINFO  bltinfo;          // Data passed to our vSrcCopySnDn fxn

    /* Compute the directions for the copy and clipping enumeration.  There
     * are two cases:  RLE & not.
     *
     * RLE's are always copied Left-Right, Bottom-Top; which is also their
     * clipping enumeration.
     *
     * For non-RLE's, the copy direction is dependant on overlap.  The
     * X and Y directions must be chosen so ensure no portion of the source
     * is clobbered by the copy operation.  If there is no overlap, the
     * copy and clipping enumeration is Left-Right, Top-Bottom.
     */

    LONG xDir = 1L, yDir = 1L;  /* X, Y Directions.  Positive = Left, Down */
    LONG iDir;                  // Order to fetch clip region rectangles

    /*
     * Are we going to do reads from BMF_NOTSYSMEM ie Video memory ?
     * If so set up bltinfo so the blitting routine wil do source aligned reads.
     */

    if ((psoSrc->iBitmapFormat == BMF_8RLE) || (psoSrc->iBitmapFormat == BMF_4RLE))
    {
        /* RLE Case. */

        iDir = CD_RIGHTUP;
        xDir =  1L;
        yDir = -1L;

        bltinfo.lDeltaDst = -psoDst->lDelta;
        bltinfo.lDeltaSrc = 0;

        bRLE = TRUE;
    }
    else
    {
        /* Non-RLE Case.  
         *
     * Check whether source and destination are the same by comparing
     * the pvScan0 pointers.  We can't simply compare surface pointers or
     * handles because some drivers punt this call to GDI, but pass us
     * different SURFOBJs for the source and destination even when
     * they're really the same surface.
     */

        if (psoSrc->pvScan0 == psoDst->pvScan0) 
        {
            if (pptlSrc->x < prclDst->left)
            {
                xDir = -1L;                   /* Copy Right to Left          */
                if (pptlSrc->y < prclDst->top)
                {
                    yDir = -1L;               /* Copy Bottom to Top          */
                    iDir = CD_LEFTUP;         /* Clip Left-Right, Bottom-Top */
                }
                else
                {
                    iDir = CD_LEFTDOWN;       /* Clip Left-Right, Top-Bottom */
                }
            }
            else
            {
                if (pptlSrc->y < prclDst->top)
                {
                    yDir = -1L;               /* Copy Bottom to Top          */
                    iDir = CD_RIGHTUP;        /* Clip Right-Left, Bottom-Top */
                }
                else
                    iDir = CD_RIGHTDOWN;
            }
        }
        else
            iDir = CD_ANY;

        bltinfo.lDeltaSrc  = (yDir > 0) ?  psoSrc->lDelta :
                                          -psoSrc->lDelta;
        bltinfo.lDeltaDst  = (yDir > 0) ?  psoDst->lDelta :
                                          -psoDst->lDelta;
    }

    /* Determine the clipping region complexity. */

    CLIPENUMRECT    clenr;           /* buffer for storing clip rectangles */
    if (pco != (CLIPOBJ *) NULL)
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:
            bMore = FALSE;
            clenr.c = 1;
            clenr.arcl[0] = *prclDst;    // Use the target for clipping
            break;

        case DC_RECT:
            bMore = FALSE;
            clenr.c = 1;
            clenr.arcl[0] = pco->rclBounds;
            break;

        case DC_COMPLEX:
            bMore = TRUE;
            ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, iDir,
                                           CLIPOBJ_ENUM_LIMIT);
            break;

        default:
            RIP("ERROR EngCopyBits bad clipping type");

        } /* switch */
    }
    else
    {
        bMore = FALSE;                   /* Default to TRIVIAL for no clip */
        clenr.c = 1;
        clenr.arcl[0] = *prclDst;        // Use the target for clipping
    } /* if */


    /* Set up the static blt information into the BLTINFO structure -
     * The colour translation, & the copy directions.
     */

    /* pxlo is NULL implies identity colour translation. */
    if (pxlo == NULL)
        bltinfo.pxlo = &xloIdent;
    else
        bltinfo.pxlo = (XLATE *) pxlo;

    bltinfo.xDir = xDir;
    bltinfo.yDir = yDir;

    /* Use a seperate loop for RLE bitmaps.  This way, we won't slow down
     * an iteration with an IF on each pass.  The trade-off is to duplicate
     * a portion of the code.
     */

    if (bRLE)
    {
        /* Fetch our blt function.  Die if NULL */

        PFN_RLECPY pfnRLECopy = pfnGetRLESrcCopy(psoSrc->iBitmapFormat,
                                                 psoDst->iBitmapFormat);
        if (pfnRLECopy == (PFN_RLECPY) NULL)
            return (FALSE);

        BOOL bBytesRemain = TRUE;

        /* Since an RLE bitmap must be played from its beginning,
         * we do not need to calculate offsets into the source bitmap.
         * This way, most of the information required for the BLTINFO
         * can be read off the Source & Destination objects.
         */

        bltinfo.ptlSrc    = *pptlSrc;
        bltinfo.pdioSrc   = pSurfSrc;
        bltinfo.yDstStart = (LONG)(prclDst->top + psoSrc->sizlBitmap.cy -
                                   pptlSrc->y - 1);

        bltinfo.xDstStart = (LONG)(prclDst->left - pptlSrc->x);
        bltinfo.ulOutCol  = bltinfo.xDstStart;

        bltinfo.pjSrc   = (PBYTE) psoSrc->pvScan0;
        bltinfo.pjDst   = (PBYTE) (((PBYTE) psoDst->pvScan0) +
                          bltinfo.yDstStart*psoDst->lDelta);
        bltinfo.ulConsumed = 0;
        bltinfo.rclDst.top = 0;

        do
        {
            PRECTL prcl;
            if (bMore)
                bMore = ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr),
                                                  (PVOID) &clenr);

            for (ircl = 0; ircl < clenr.c; ircl++)
            {

                prcl = &clenr.arcl[ircl];

                /* Insersect the clip rectangle with the target rectangle to
                 * determine our visible rectangle
                 */

                if (prcl->left < prclDst->left)
                    prcl->left = prclDst->left;
                if (prcl->right > prclDst->right)
                    prcl->right = prclDst->right;
                if (prcl->top < prclDst->top)
                    prcl->top = prclDst->top;
                if (prcl->bottom > prclDst->bottom)
                    prcl->bottom = prclDst->bottom;

                /* Process the result if it's a valid rectangle.       */

                if ((prcl->top  < prcl->bottom) && (prcl->left < prcl->right))
                {
                    /* Adjust our starting position based on previous clips */

                    if (prcl->bottom <= bltinfo.rclDst.top)
                    {
                        if ((ULONG)prcl->top > bltinfo.ulEndRow)
                            continue;

                        if (!bBytesRemain)
                        {
                            bMore = FALSE; // Force us out of the outer loop
                            break;         // Force us out of the inner loop
                        }

                        bltinfo.pjSrc = bltinfo.pjSrcEnd;
                        bltinfo.pjDst = bltinfo.pjDstEnd;
                        bltinfo.yDstStart  = bltinfo.ulEndRow;
                        bltinfo.ulOutCol   = bltinfo.ulEndCol;
                        bltinfo.ulConsumed = bltinfo.ulEndConsumed;
                    }

                    bltinfo.rclDst = *prcl;
                    bBytesRemain = (*pfnRLECopy)(&bltinfo);

                }

            } /* for */

        } while(bMore);

    }
    else
    {
        /* Non-RLE Case */

        ULONG Index;
        PFN_SRCCPY pfnSrcCopy;

        ASSERTGDI(BMF_1BPP == 1, "ERROR EngCopyBits:  BMF_1BPP not eq 1");
        ASSERTGDI(BMF_4BPP == 2, "ERROR EngCopyBits:  BMF_1BPP not eq 2");
        ASSERTGDI(BMF_8BPP == 3, "ERROR EngCopyBits:  BMF_1BPP not eq 3");
        ASSERTGDI(BMF_16BPP == 4, "ERROR EngCopyBits:  BMF_1BPP not eq 4");
        ASSERTGDI(BMF_24BPP == 5, "ERROR EngCopyBits:  BMF_1BPP not eq 5");
        ASSERTGDI(BMF_32BPP == 6, "ERROR EngCopyBits:  BMF_1BPP not eq 6");
        ASSERTGDI(psoDst->iBitmapFormat <= BMF_32BPP, "ERROR EngCopyBits:  bad destination format");
        ASSERTGDI(psoSrc->iBitmapFormat <= BMF_32BPP, "ERROR EngCopyBits:  bad source format");
        ASSERTGDI(psoDst->iBitmapFormat != 0, "ERROR EngCopyBits:  bad destination format");
        ASSERTGDI(psoSrc->iBitmapFormat != 0, "ERROR EngCopyBits:  bad source format");

        //
        // Compute the function table index and select the source copy
        // function.
        //

        Index = (psoDst->iBitmapFormat << 5) | (psoSrc->iBitmapFormat << 2);
        if (xDir < 0) {
            Index += 2;
        }

        KFLOATING_SAVE fpState;
        BOOL bRestoreFP = FALSE;
        if (((XLATE *)(bltinfo.pxlo))->bIsIdentity())
        {
            Index += 1;
            if(psoSrc->fjBitmap & BMF_NOTSYSMEM)
            {
                bltinfo.fSrcAlignedRd = TRUE;
#if i386
                if(HasMMX)
                {
                    bRestoreFP = TRUE;
                    if(!NT_SUCCESS(KeSaveFloatingPointState(&fpState)))
                    {
                        bltinfo.fSrcAlignedRd = FALSE;
                        bRestoreFP = FALSE;
                    }
                }
#endif
            }
        }

        pfnSrcCopy = SrcCopyFunctionTable[Index];
        do {

            if (bMore)
                bMore = ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr),
                                                  (PVOID) &clenr);

            for (ircl = 0; ircl < clenr.c; ircl++)
            {
                PRECTL prcl = &clenr.arcl[ircl];

                /* Insersect the clip rectangle with the target rectangle to
                 * determine our visible recangle
                 */

                if (prcl->left < prclDst->left)
                    prcl->left = prclDst->left;
                if (prcl->right > prclDst->right)
                    prcl->right = prclDst->right;
                if (prcl->top < prclDst->top)
                    prcl->top = prclDst->top;
                if (prcl->bottom > prclDst->bottom)
                    prcl->bottom = prclDst->bottom;

                /* Process the result if it's a valid rectangle.       */

                if ((prcl->top < prcl->bottom) && (prcl->left < prcl->right))
                {
                    /* These variables are used for computing where the
                     * scanlines start.
                     */
                    LONG   xSrc;
                    LONG   ySrc;
                    LONG   xDst;
                    LONG   yDst;

                    // Figure out the upper-left coordinates of rects to blt
                    xDst = prcl->left;
                    yDst = prcl->top;
                    xSrc = pptlSrc->x + xDst - prclDst->left;
                    ySrc = pptlSrc->y + yDst - prclDst->top;

                    // Figure out the width and height of this rectangle
                    bltinfo.cx = prcl->right  - xDst;
                    bltinfo.cy = prcl->bottom - yDst;

                    /* # of pixels offset to first pixel for src and dst
                     * from start of scan
                     */
                    bltinfo.xSrcStart = (xDir > 0) ? xSrc :
                                                     (xSrc + bltinfo.cx - 1);
                    bltinfo.xSrcEnd   = bltinfo.xSrcStart +
                                         (bltinfo.cx * xDir);
                    bltinfo.xDstStart = (xDir > 0) ? xDst :
                                                     (xDst + bltinfo.cx - 1);
                    bltinfo.yDstStart = prcl->top;

                    // Src scanline begining
                    // Destination scanline begining
                    if (yDir > 0)
                    {
                        bltinfo.pjSrc = ((PBYTE) psoSrc->pvScan0) +
                                                 ySrc*(psoSrc->lDelta);
                        bltinfo.pjDst = ((PBYTE) psoDst->pvScan0) +
                                                 yDst * (psoDst->lDelta);
                    }
                    else
                    {
                        bltinfo.pjSrc = ((PBYTE) psoSrc->pvScan0) +
                                 (ySrc + bltinfo.cy - 1) * (psoSrc->lDelta);
                        bltinfo.pjDst = ((PBYTE) psoDst->pvScan0) +
                                 (yDst + bltinfo.cy - 1) * (psoDst->lDelta);
                    } /* if */

                    /* Do the blt */

                    (*pfnSrcCopy)(&bltinfo);

                } /* if */

            } /* for */

        } while (bMore);
#if i386
        if(HasMMX)
        {
            if(bRestoreFP)
            {
                KeRestoreFloatingPointState(&fpState);
            }
        }
#endif

    } /* if */
    return(TRUE);

} /* EngCopyBits */

/******************************Private*Routine*****************************\
* vSrcCopyDummy
*
* This gets the correct function to dispatch to for Src Copy Bitblt.
*
* History:
*  02-Sep-1992 -by- David N. Cutler davec
* Wrote it.
\**************************************************************************/

VOID
vSrcCopyDummy (
    PBLTINFO BltInfo
    )

{

    ASSERTGDI(FALSE, "ERROR EngCopyBits: dummy function called");
    return;
}

/******************************Public*Routine******************************\
* pfnGetRLESrcCopy
*
* This gets the correct function to dispatch to for Src Copy Bitblt,
* assuming that the source is an RLE bitmap.
*
* History:
*
*  05 Mar 1992 - Andrew Milton (w-andym):
*     Creation.
*
\**************************************************************************/

PFN_RLECPY
pfnGetRLESrcCopy(
    ULONG iFormatSrc,
    ULONG iFormatDst)
{

    switch(iFormatDst) {

    case BMF_1BPP:

        switch(iFormatSrc)
        {
        case BMF_8RLE:
            return(bSrcCopySRLE8D1);

        case BMF_4RLE:
            return(bSrcCopySRLE4D1);

        default:
            RIP("ERROR: Invalid iFormatSrc in XlateList");
        }

    case BMF_4BPP:

        switch(iFormatSrc)
        {
        case BMF_8RLE:
            return(bSrcCopySRLE8D4);

        case BMF_4RLE:
            return(bSrcCopySRLE4D4);

        default:
            RIP("ERROR: Invalid iFormatSrc in XlateList");
        }

    case BMF_8BPP:

        switch(iFormatSrc)
        {
        case BMF_8RLE:
            return(bSrcCopySRLE8D8);

        case BMF_4RLE:
            return(bSrcCopySRLE4D8);

        default:
            RIP("ERROR: Invalid iFormatSrc in XlateList");
        }

    case BMF_16BPP:

        switch(iFormatSrc)
        {
        case BMF_8RLE:
            return(bSrcCopySRLE8D16);

        case BMF_4RLE:
            return(bSrcCopySRLE4D16);

        default:
            RIP("ERROR: Invalid iFormatSrc in XlateList");
        }

    case BMF_24BPP:

        switch(iFormatSrc)
        {
        case BMF_8RLE:
            return(bSrcCopySRLE8D24);

        case BMF_4RLE:
            return(bSrcCopySRLE4D24);

        default:
            RIP("ERROR: Invalid iFormatSrc in XlateList");
        }

    case BMF_32BPP:
        switch(iFormatSrc)
        {
        case BMF_8RLE:
            return(bSrcCopySRLE8D32);

        case BMF_4RLE:
            return(bSrcCopySRLE4D32);

        default:
            RIP("ERROR: Invalid iFormatSrc in XlateList");
        }

    default:
        RIP("ERROR: Invalid iFormatDst in XlateList");
    } /* switch */

    return(NULL);
} /* pfnGetRLESrcCopy */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\usersrv.cxx ===
/******************************Module*Header*******************************\
* Module Name: usersrv.c
*
* Copyright (c) 1996-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

//
// The following methods are thunks to support calls to user mode
// font drivers
//

#define DEFINE_FUNCTION(x, y)     \
    union {                       \
        PFN Generic;              \
        PFN_Drv##x Kernel;        \
    } y = { ppfn(INDEX_Drv##x) };


class ATTACHOBJ {
public:
    PDEVOBJ *pObject;

    ATTACHOBJ(PDEVOBJ *pObject_);
    ~ATTACHOBJ();
};

ATTACHOBJ::ATTACHOBJ(PDEVOBJ *pObject_)
{
    if (pObject_->bFontDriver())
    {
        pObject = pObject_;
        KeAttachProcess(PsGetProcessPcb(gpepCSRSS));
    }
    else
    {
        pObject = 0;
    }
}

ATTACHOBJ::~ATTACHOBJ()
{
    if (pObject)
    {
        KeDetachProcess();
    }
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::EnablePDEV
*
\**************************************************************************/

DHPDEV PDEVOBJ::EnablePDEV(
    DEVMODEW *pdm
  ,   LPWSTR  pwszLogAddress
  ,    ULONG  cPat
  ,    HSURF *phsurfPatterns
  ,    ULONG  cjCaps
  ,  GDIINFO *pGdiInfo
  ,    ULONG  cjDevInfo
  ,  DEVINFO *pdi
  ,     HDEV  hdev
  ,   LPWSTR  pwszDeviceName
  ,   HANDLE  hDriver
    )
{
    DHPDEV ReturnValue;
    DEFINE_FUNCTION(EnablePDEV, pfn);

    ReturnValue = (*pfn.Kernel)(pdm,
                                pwszLogAddress,
                                cPat,
                                phsurfPatterns,
                                cjCaps,
                                pGdiInfo,
                                cjDevInfo,
                                pdi,
                                hdev,
                                pwszDeviceName,
                                hDriver);

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::DisablePDEV
*
\**************************************************************************/

VOID PDEVOBJ::DisablePDEV( DHPDEV dhpdev)
{
    DEFINE_FUNCTION(DisablePDEV, pfn);

    (*pfn.Kernel)(dhpdev);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::CompletePDEV
*
\**************************************************************************/

VOID PDEVOBJ::CompletePDEV( DHPDEV dhpdev, HDEV hdev)
{
    DEFINE_FUNCTION(CompletePDEV, pfn);

    (*pfn.Kernel)(dhpdev, hdev);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryFont
*
\**************************************************************************/

IFIMETRICS* PDEVOBJ::QueryFont(
    DHPDEV      dhpdev
  ,  ULONG_PTR  iFile
  ,  ULONG      iFace
  ,  ULONG_PTR      *pid
  )
{
    IFIMETRICS *ReturnValue = NULL;
    DEFINE_FUNCTION(QueryFont, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);
    
        ReturnValue = (*pfn.Kernel)(dhpdev, iFile, iFace, pid);
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryFontTree
*
\**************************************************************************/

PVOID PDEVOBJ::QueryFontTree(
    DHPDEV     dhpdev
  ,  ULONG_PTR  iFile
  ,  ULONG     iFace
  ,  ULONG     iMode
  ,  ULONG_PTR     *pid
    )
{
    PVOID ReturnValue = NULL;
    DEFINE_FUNCTION(QueryFontTree, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);
        ReturnValue = (*pfn.Kernel)(dhpdev, iFile, iFace, iMode, pid);
    }
    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryFontData
*
\**************************************************************************/

LONG PDEVOBJ::QueryFontData(
       DHPDEV  dhpdev
  ,   FONTOBJ *pfo
  ,     ULONG  iMode
  ,    HGLYPH  hg
  , GLYPHDATA *pgd
  ,     PVOID  pv
  ,     ULONG  cjSize
    )
{
    LONG ReturnValue = FD_ERROR; 
    DEFINE_FUNCTION(QueryFontData, pfn);
    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        ReturnValue = (*pfn.Kernel)(dhpdev, pfo, iMode, hg, pgd, pv, cjSize);
    }
    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::DestroyFont
*
\**************************************************************************/

VOID PDEVOBJ::DestroyFont(FONTOBJ *pfo)
{
    BOOL  bUnmap = FALSE;

    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));
    
    // check ref count
    {
        SEMOBJ  so(ghsemPublicPFT);
        
        if (rfo.pPFF()->cRFONT == 1)
            bUnmap = TRUE;
    }

    if (bUnmap)
    {
        UnmapPrintKView(rfo.pPFF()->hff);
    }

    DEFINE_FUNCTION(DestroyFont, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        (*pfn.Kernel)(pfo);
    }
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryFontCaps
*
\**************************************************************************/

LONG PDEVOBJ::QueryFontCaps(
    ULONG  culCaps
  , ULONG *pulCaps
    )
{
    LONG ReturnValue;
    DEFINE_FUNCTION(QueryFontCaps, pfn);

    ReturnValue = (*pfn.Kernel)(culCaps, pulCaps);
    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::LoadFontFile
*
\**************************************************************************/

HFF PDEVOBJ::LoadFontFile(
    ULONG    cFiles
  , ULONG_PTR *piFile
  , PVOID    *ppvView
  , ULONG    *pcjView
  , DESIGNVECTOR *pdv
  , ULONG    ulLangID
  , ULONG    ulFastCheckSum
    )
{
    HFF ReturnValue = 0;
    DEFINE_FUNCTION(LoadFontFile, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        ReturnValue = (*pfn.Kernel)(cFiles, piFile, ppvView, pcjView, pdv, ulLangID, ulFastCheckSum);
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::UnloadFontFile
*
\**************************************************************************/

BOOL PDEVOBJ::UnloadFontFile(ULONG_PTR iFile)
{
    BOOL ReturnValue = FALSE;
    DEFINE_FUNCTION(UnloadFontFile, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        ReturnValue = (*pfn.Kernel)(iFile);
    }
    else{
    	return(-1);
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryFontFile
*
\**************************************************************************/

LONG PDEVOBJ::QueryFontFile(
    ULONG_PTR  iFile
  , ULONG     ulMode
  , ULONG     cjBuf
  , ULONG     *pulBuf
    )
{
    LONG ReturnValue = FD_ERROR;
    DEFINE_FUNCTION(QueryFontFile, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        ReturnValue = (*pfn.Kernel)(iFile, ulMode, cjBuf, pulBuf);
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryAdvanceWidths
*
\**************************************************************************/

BOOL PDEVOBJ::QueryAdvanceWidths(
     DHPDEV  dhpdev
  , FONTOBJ *pfo
  ,   ULONG  iMode
  ,  HGLYPH *phg
  ,   PVOID  pvWidths
  ,   ULONG  cGlyphs
    )
{
    BOOL ReturnValue = FALSE;
    DEFINE_FUNCTION(QueryAdvanceWidths, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        ReturnValue = (*pfn.Kernel)(dhpdev, pfo, iMode, phg, pvWidths, cGlyphs);
    }
    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::Free
*
\**************************************************************************/

VOID PDEVOBJ::Free(PVOID pv, ULONG_PTR id)
{
    DEFINE_FUNCTION(Free, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        (*pfn.Kernel)(pv, id);
    }
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::bQueryGlyphAttrs
*
\**************************************************************************/

PFD_GLYPHATTR  PDEVOBJ::QueryGlyphAttrs(
    FONTOBJ     *pfo,
    ULONG       iMode
)
{
    DEFINE_FUNCTION(QueryGlyphAttrs, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        if (pfn.Kernel)
        {
            return (*pfn.Kernel)(pfo, iMode);
        }
    }

    return NULL;
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryTrueTypeTable
*
\**************************************************************************/

LONG PDEVOBJ::QueryTrueTypeTable(
      ULONG_PTR  iFile
  ,   ULONG     ulFont
  ,   ULONG     ulTag
  , PTRDIFF     dpStart
  ,   ULONG     cjBuf
  ,    BYTE     *pjBuf
  ,    BYTE     **ppjTable
  ,   ULONG     *pcjTable
    )
{
    LONG ReturnValue = FD_ERROR;
    DEFINE_FUNCTION(QueryTrueTypeTable, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        if (pjBuf)
        {
            *pjBuf = 0;
        }
        if (pfn.Kernel)
        {
            ReturnValue = (*pfn.Kernel)(iFile,
                                        ulFont,
                                        ulTag,
                                        dpStart,
                                        cjBuf,
                                        pjBuf,
                                        ppjTable,
                                        pcjTable);
        }
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryTrueTypeOutline
*
\**************************************************************************/

LONG PDEVOBJ::QueryTrueTypeOutline(
             DHPDEV  dhpdev
  ,         FONTOBJ *pfo
  ,          HGLYPH  hglyph
  ,            BOOL  bMetricsOnly
  ,       GLYPHDATA *pgldt
  ,           ULONG  cjBuf
  , TTPOLYGONHEADER *ppoly
    )
{
    LONG ReturnValue = FD_ERROR;
    DEFINE_FUNCTION(QueryTrueTypeOutline, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        ReturnValue = (*pfn.Kernel)(dhpdev,
                                    pfo,
                                    hglyph,
                                    bMetricsOnly,
                                    pgldt,
                                    cjBuf,
                                    ppoly);
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::GetTrueTypeFile
*
\**************************************************************************/

PVOID PDEVOBJ::GetTrueTypeFile(ULONG_PTR iFile, ULONG *pcj)
{
    PVOID ReturnValue = 0;
    DEFINE_FUNCTION(GetTrueTypeFile, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        *pcj = 0;
        if (pfn.Kernel)
        {
            ReturnValue = (*pfn.Kernel)(iFile, pcj);
        }
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::FontManagement
*
\**************************************************************************/

BOOL PDEVOBJ::FontManagement(
       	SURFOBJ *pso,
        FONTOBJ *pfo,
        ULONG    iEsc,
        ULONG    cjIn,
       	PVOID    pvIn,
        ULONG    cjOut,
       	PVOID    pvOut
    )
{
    BOOL ReturnValue = FALSE;
    DEFINE_FUNCTION(FontManagement, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        if (pfn.Kernel)
        {
            ReturnValue = (*pfn.Kernel)(pso, pfo, iEsc, cjIn, pvIn, cjOut, pvOut);
        }
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::Escape
*
\**************************************************************************/

ULONG PDEVOBJ::Escape(
        SURFOBJ *pso
      ,   ULONG  iEsc
      ,   ULONG  cjIn
      ,   PVOID  pvIn
      ,   ULONG  cjOut
      ,   PVOID  pvOut
        )
{
    ULONG ReturnValue = 0;
    DEFINE_FUNCTION(Escape, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        ReturnValue = (*pfn.Kernel)(pso, iEsc, cjIn, pvIn, cjOut, pvOut);
    }

    return(ReturnValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\verifier.cxx ===
/******************************Module*Header*******************************\
* Module Name: verifier.cxx
*
* GRE DriverVerifier support.
*
* If DriverVerifier is enabled for a particular component, the loader will
* substitute VerifierEngAllocMem for EngAllocMem, etc.  The VerifierEngXX
* functions will help test the robustness of components that use EngXX calls
* by injecting random failures and using special pool (i.e., test low-mem
* behavior and check for buffer overruns).
*
* See ntos\mm\verifier.c for further details on DriverVerifier support in
* the memory manager.
*
* See sdk\inc\ntexapi.h for details on the DriverVerifier flags.
*
* Created: 19-Jan-1999 11:51:51
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"
#include "muclean.hxx"
#include "verifier.hxx"

extern BOOL G_fConsole;                 // gre\misc.cxx

//
// Amount of elapsed time before we begin random failures.
// Gives system time to stabilize.
//
// Taken from ntos\mm\verifier.c
//

LARGE_INTEGER GreBootTime;
const LARGE_INTEGER VerifierRequiredTimeSinceBoot = {(ULONG)(40 * 1000 * 1000 * 10), 1};

//
// Global verifier state.
//

VSTATE gvs = {
    0,                  // fl
    FALSE,              // bSystemStable
    0,                  // ulRandomSeed
    0xf,                // ulFailureMask
    0,                  // ulDebugLevel
    (HSEMAPHORE) NULL   // hsemPoolTracker
};

//
// Put initialization functions in the INIT segment.
//

#pragma alloc_text(INIT, VerifierInitialization)


/******************************Public*Routine******************************\
* VerifierInitialization
*
* Initializes the DriverVerifier support in GRE.  The loader will actually
* handle the fixup of the EngAllocMem, etc. during the loading of components
* listed as under the verifier.
*
* History:
*  19-Jan-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define VERIFIERFUNC(pfn)   ((PDRIVER_VERIFIER_THUNK_ROUTINE)(pfn))

const DRIVER_VERIFIER_THUNK_PAIRS gaVerifierFunctionTable[] = {
    {VERIFIERFUNC(EngAllocMem           ), VERIFIERFUNC(VerifierEngAllocMem           )},
    {VERIFIERFUNC(EngFreeMem            ), VERIFIERFUNC(VerifierEngFreeMem            )},
    {VERIFIERFUNC(EngAllocUserMem       ), VERIFIERFUNC(VerifierEngAllocUserMem       )},
    {VERIFIERFUNC(EngFreeUserMem        ), VERIFIERFUNC(VerifierEngFreeUserMem        )},
    {VERIFIERFUNC(EngCreateBitmap       ), VERIFIERFUNC(VerifierEngCreateBitmap       )},
    {VERIFIERFUNC(EngCreateDeviceSurface), VERIFIERFUNC(VerifierEngCreateDeviceSurface)},
    {VERIFIERFUNC(EngCreateDeviceBitmap ), VERIFIERFUNC(VerifierEngCreateDeviceBitmap )},
    {VERIFIERFUNC(EngCreatePalette      ), VERIFIERFUNC(VerifierEngCreatePalette      )},
    {VERIFIERFUNC(EngCreateClip         ), VERIFIERFUNC(VerifierEngCreateClip         )},
    {VERIFIERFUNC(EngCreatePath         ), VERIFIERFUNC(VerifierEngCreatePath         )},
    {VERIFIERFUNC(EngCreateWnd          ), VERIFIERFUNC(VerifierEngCreateWnd          )},
    {VERIFIERFUNC(EngCreateDriverObj    ), VERIFIERFUNC(VerifierEngCreateDriverObj    )},
    {VERIFIERFUNC(BRUSHOBJ_pvAllocRbrush), VERIFIERFUNC(VerifierBRUSHOBJ_pvAllocRbrush)},
    {VERIFIERFUNC(CLIPOBJ_ppoGetPath    ), VERIFIERFUNC(VerifierCLIPOBJ_ppoGetPath    )}
};

BOOL
VerifierInitialization()
{
    BOOL bRet = FALSE;
    NTSTATUS Status;
    ULONG Level;

#ifdef VERIFIER_STATISTICS
    //
    // Clear statistics.
    //

    RtlZeroMemory((VOID *) gvs.avs, sizeof(VSTATS) * VERIFIER_INDEX_LAST);

#endif

    //
    // Get the DriverVerifier flags.  No point in going on if we can't
    // get this.
    //

    Status = MmIsVerifierEnabled (&Level);

    if ((NT_SUCCESS(Status) || (Status == STATUS_INFO_LENGTH_MISMATCH)) &&
        (Level & DRIVER_VERIFIER_GRE_MASK))
    {
        //
        // Some things should only be done once, during system initalization.
        // So don't do them for Hydra sessions.
        //

        if (G_fConsole)
        {
            //
            // Remember the boot time.  We do not allow random failures for
            // a period time right after boot to allow the system time to
            // become quiescent.
            //

            KeQuerySystemTime(&GreBootTime);

            //
            // Give loader Verifier function substitution table.
            //

            Status = MmAddVerifierThunks ((VOID *) gaVerifierFunctionTable,
                                          sizeof(gaVerifierFunctionTable));

            if (NT_SUCCESS(Status))
            {
                VERIFIERWARNING(1, "VerifierInitialization: thunks accepted\n");
                bRet = TRUE;
            }
        }
        else
        {
            //
            // On Hydra systems, allow failures during GRE initialization.
            // So disable the check that allows the system time to stabilize.
            //

            gvs.bSystemStable = TRUE;
            Level &= ~DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS;
            bRet = TRUE;
        }
    }
    else
    {
        WARNING("VerifierInitialization: failed to get info from ntoskrnl\n");
    }

    //
    // Disable pool tracking always for graphic drivers. (NTBUG:421768)
    //

    Level &= ~DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS;

    // //
    // // Initialize pool tracking if needed.
    // //
    // if (Level & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS)
    // {
    //     //
    //     // Initialize doubly linked list used to track pool allocations.
    //     //
    //
    //     InitializeListHead(&gvs.lePoolTrackerHead);
    //
    //     //
    //     // Initialize the tracking list lock.  Turn off pool allocations
    //     // if semaphore creation fails.
    //     //
    //
    //     gvs.hsemPoolTracker = GreCreateSemaphore();
    //     if (!gvs.hsemPoolTracker)
    //         Level &= ~DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS;
    // }

    //
    // Keep a local copy of the DriverVerifier flags.
    //
    // Note that the DriverVerifier flags can change on the fly without
    // rebooting so this is a very transient copy.
    //
    // Wait until we know everthing is OK.
    //

    gvs.fl = (bRet) ? Level : 0;

    return bRet;
}


/******************************Public*Routine******************************\
* VerifierRandomFailure
*
* Occasionally returns TRUE, indicating that Verifier should inject an
* allocation failure.
*
* See ntos\mm\verifier.c for further details.
*
* History:
*  19-Jan-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL
VerifierRandomFailure(ULONG ulEntry)
{
    BOOL bRet = FALSE;
    LARGE_INTEGER CurrentTime;

    #ifdef VERIFIER_STATISTICS
        ASSERTGDI(ulEntry < VERIFIER_INDEX_LAST,
                  "VerifierRandomFailure: bad index\n");
    #else
        DONTUSE(ulEntry);
    #endif

    //
    // Check if random failures enabled.
    //

    if (gvs.fl & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES)
    {
        //
        // Don't fail any requests in the first 7 or 8 minutes as we want to
        // give the system enough time to boot.
        //

        if (gvs.bSystemStable == FALSE)
        {
            KeQuerySystemTime(&CurrentTime);
            if (CurrentTime.QuadPart > (GreBootTime.QuadPart + VerifierRequiredTimeSinceBoot.QuadPart))
            {
                //
                // Enough time has elapsed to begin failures.
                //

                VERIFIERWARNING(1, "VerifierRandomFailure: injected failures enabled\n");
                gvs.bSystemStable = TRUE;
                gvs.ulRandomSeed  = CurrentTime.LowPart;

            #ifdef VERIFIER_STATISTICS
                //
                // Reset statistics.
                //

                RtlZeroMemory((VOID *) gvs.avs, sizeof(VSTATS) * VERIFIER_INDEX_LAST);

            #endif
            }
        }

    #ifdef VERIFIER_STATISTICS
        //
        // Record number of attempts.
        //

        InterlockedIncrement((LONG *) &gvs.avs[ulEntry].ulAttempts);

    #endif

        //
        // Once system is stable, randomly enable failure.
        //

        if (gvs.bSystemStable)
        {
            if ((RtlRandom(&gvs.ulRandomSeed) & gvs.ulFailureMask) == 0)
            {
                bRet = TRUE;

            #ifdef VERIFIER_STATISTICS
                //
                // Record number of injected failures.
                //

                InterlockedIncrement((LONG *) &gvs.avs[ulEntry].ulFailures);

            #endif
            }
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* VerifierEngAllocMem
*
* VerifierEngAllocMem can put allocations under special pool, track
* allocations, and inject random allocation failures.
*
* History:
*  19-Jan-1999 -by-  Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PVOID APIENTRY
VerifierEngAllocMem(
    ULONG fl,
    ULONG cj,
    ULONG tag
    )
{
    PVOID pvRet;
    POOL_TYPE poolType;
    EX_POOL_PRIORITY poolPriority;
    ULONG cjOrig = cj;

    //
    // Inject random failures.
    //

    if (VerifierRandomFailure(VERIFIER_INDEX_EngAllocMem))
    {
        VERIFIERWARNING(1, "VerifierEngAllocMem: inject failure\n");
        return NULL;
    }

    //
    // Check if special pool is enabled.
    //

    if (gvs.fl & DRIVER_VERIFIER_SPECIAL_POOLING)
        poolPriority = (EX_POOL_PRIORITY) (HighPoolPrioritySpecialPoolOverrun | POOL_SPECIAL_POOL_BIT);
    else
        poolPriority = HighPoolPrioritySpecialPoolOverrun;

    //
    // Don't trust the driver to only ask for non-zero length buffers.
    //

    if (cj == 0)
        return NULL;

    //
    // Adjust size to include VERIFIERTRACKHDR.
    //

    if (gvs.fl & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS)
    {
        if (cj <= (MAXULONG - sizeof(VERIFIERTRACKHDR)))
            cj += ((ULONG) sizeof(VERIFIERTRACKHDR));
        else
            return NULL;
    }

    //
    // Adjust size to include ENGTRACKHDR header.
    //
    // Sundown note: sizeof(ENGTRACKHDR) will fit in 32-bit, so ULONG cast OK
    //


    if (cj <= (MAXULONG - sizeof(ENGTRACKHDR)))
        cj += ((ULONG) sizeof(ENGTRACKHDR));
    else
        return NULL;

    if (cj >= (PAGE_SIZE * 10000))
    {
        WARNING("EngAllocMem: temp buffer >= 10000 pages");
        return NULL;
    }

    //
    // Need to call GdiAllocPoolNonPagedWithPriority or GdiAllocPoolWithPriority, which allows for
    // special pool allocations.
    //
    if (fl & FL_NONPAGED_MEMORY) {
        pvRet = GdiAllocPoolNonPagedWithPriority(cj, tag, poolPriority);
    } else {
        pvRet = GdiAllocPoolWithPriority(cj, tag, poolPriority);
    }

    if (pvRet)
    {
        if (fl & FL_ZERO_MEMORY)
        {
            RtlZeroMemory(pvRet, cj);
        }

        //
        // Hydra pool tracking.
        //

        //
        // Add allocation to the tracking list.
        //

        ENGTRACKHDR *pethNew = (ENGTRACKHDR *) pvRet;
        MultiUserGreTrackAddEngResource(pethNew, ENGTRACK_VERIFIERALLOCMEM);

        //
        // Adjust return pointer to hide the LIST_ENTRY header.
        //

        pvRet = (PVOID) (pethNew + 1);

        //
        // Verifier pool tracking.  Separate from Hydra
        // pool tracking which handles session cleanup.
        //

        if (gvs.fl & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS)
        {
            //
            // Add to the tracking list.
            //

            VERIFIERTRACKHDR *pvthNew = (VERIFIERTRACKHDR *) pvRet;

            pvthNew->ulSize = cjOrig;
            pvthNew->ulTag = tag;

            GreAcquireSemaphore(gvs.hsemPoolTracker);
            InsertTailList(&gvs.lePoolTrackerHead, ((PLIST_ENTRY) pvthNew));
            GreReleaseSemaphore(gvs.hsemPoolTracker);

            //
            // Adjust return pointer to hide the header.
            //

            pvRet = (PVOID) (pvthNew + 1);
        }

    }

    return pvRet;
}


/******************************Public*Routine******************************\
* VerifierEngFreeMem
*
* History:
*  19-Jan-1999 -by-  Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY
VerifierEngFreeMem(
    PVOID pv
    )
{
    if (pv)
    {
        //
        // Verifier pool tracking.
        //

        if (gvs.fl & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS)
        {
            //
            // Remove victim from tracking list.
            //

            VERIFIERTRACKHDR *pvthVictim = ((VERIFIERTRACKHDR *) pv) - 1;

            GreAcquireSemaphore(gvs.hsemPoolTracker);
            RemoveEntryList(((PLIST_ENTRY) pvthVictim));
            GreReleaseSemaphore(gvs.hsemPoolTracker);

            //
            // Adjust pointer to the header.  This is base of allocation
            // if not hydra.
            //

            pv = (PVOID) pvthVictim;
        }

        //
        // Hydra pool tracking.
        //

        //
        // Remove victim from tracking list.
        //

        ENGTRACKHDR *pethVictim = ((ENGTRACKHDR *) pv) - 1;
        MultiUserGreTrackRemoveEngResource(pethVictim);

        //
        // Adjust pointer to the header.  This is base of allocation if
        // hydra.
        //

        pv = (PVOID) pethVictim;

        GdiFreePool(pv);
    }

    return;
}


/******************************Public*Routine******************************\
* VerififierEngAllocUserMem
*
* This routine allocates a piece of memory for USER mode and locks it
* down.  A driver must be very careful with this memory as it is only
* valid for this process.
*
* History:
*  19-Jan-1999 -by-  Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PVOID APIENTRY
VerifierEngAllocUserMem(
    SIZE_T cj,
    ULONG tag
    )
{
    //
    // Inject random failures.
    //

    if (VerifierRandomFailure(VERIFIER_INDEX_EngAllocUserMem))
    {
        VERIFIERWARNING(1, "VerifierEngAllocUserMem: inject failure\n");
        return NULL;
    }
    else
        return EngAllocUserMem(cj, tag);
}


/******************************Public*Routine******************************\
* VerifierEngFreeUserMem
*
* History:
*  19-Jan-1999 -by-  Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY
VerifierEngFreeUserMem(
    PVOID pv
    )
{
    //
    // Right now, there is no difference between this and EngFreeUserMem.
    // However, we may soon add some tracking info, so here is a stub.
    //

    EngFreeUserMem(pv);

    return;
}

/******************************Public*Routine******************************\
* VerifierEngCreateBitmap
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HBITMAP APIENTRY VerifierEngCreateBitmap(
    SIZEL sizl,
    LONG  lWidth,
    ULONG iFormat,
    FLONG fl,
    PVOID pvBits
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreateBitmap))
    {
        VERIFIERWARNING(1, "VerifierEngCreateBitmap: inject failure\n");
        return NULL;
    }
    else
        return EngCreateBitmap(sizl, lWidth, iFormat, fl, pvBits);
}

/******************************Public*Routine******************************\
* VerifierEngCreateDeviceSurface
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HSURF APIENTRY VerifierEngCreateDeviceSurface(
    DHSURF dhsurf,
    SIZEL sizl,
    ULONG iFormatCompat
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreateDeviceSurface))
    {
        VERIFIERWARNING(1, "VerifierEngCreateDeviceSurface: inject failure\n");
        return NULL;
    }
    else
        return EngCreateDeviceSurface(dhsurf, sizl, iFormatCompat);
}

/******************************Public*Routine******************************\
* VerifierEngCreateDeviceBitmap
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HBITMAP APIENTRY VerifierEngCreateDeviceBitmap(
    DHSURF dhsurf,
    SIZEL sizl,
    ULONG iFormatCompat
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreateDeviceBitmap))
    {
        VERIFIERWARNING(1, "VerifierEngCreateDeviceBitmap: inject failure\n");
        return NULL;
    }
    else
        return EngCreateDeviceBitmap(dhsurf, sizl, iFormatCompat);
}

/******************************Public*Routine******************************\
* VerifierEngCreatePalette
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HPALETTE APIENTRY VerifierEngCreatePalette(
    ULONG  iMode,
    ULONG  cColors,
    ULONG *pulColors,
    FLONG  flRed,
    FLONG  flGreen,
    FLONG  flBlue
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreatePalette))
    {
        VERIFIERWARNING(1, "VerifierEngCreatePalette: inject failure\n");
        return NULL;
    }
    else
        return EngCreatePalette(iMode, cColors, pulColors,
                                flRed, flGreen, flBlue);
}

/******************************Public*Routine******************************\
* VerifierEngCreateClip
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

CLIPOBJ * APIENTRY VerifierEngCreateClip()
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreateClip))
    {
        VERIFIERWARNING(1, "VerifierEngCreateClip: inject failure\n");
        return NULL;
    }
    else
        return EngCreateClip();
}

/******************************Public*Routine******************************\
* VerifierEngCreatePath
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PATHOBJ * APIENTRY VerifierEngCreatePath()
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreatePath))
    {
        VERIFIERWARNING(1, "VerifierEngCreatePath: inject failure\n");
        return NULL;
    }
    else
        return EngCreatePath();
}

/******************************Public*Routine******************************\
* VerifierEngCreateWnd
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

WNDOBJ * APIENTRY VerifierEngCreateWnd(
    SURFOBJ         *pso,
    HWND             hwnd,
    WNDOBJCHANGEPROC pfn,
    FLONG            fl,
    int              iPixelFormat
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreateWnd))
    {
        VERIFIERWARNING(1, "VerifierEngCreateWnd: inject failure\n");
        return NULL;
    }
    else
        return EngCreateWnd(pso, hwnd, pfn, fl, iPixelFormat);
}

/******************************Public*Routine******************************\
* VerifierEngCreateDriverObj
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HDRVOBJ APIENTRY VerifierEngCreateDriverObj(
    PVOID pvObj,
    FREEOBJPROC pFreeObjProc,
    HDEV hdev
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreateDriverObj))
    {
        VERIFIERWARNING(1, "VerifierEngCreateDriverObj: inject failure\n");
        return NULL;
    }
    else
        return EngCreateDriverObj(pvObj, pFreeObjProc, hdev);
}

/******************************Public*Routine******************************\
* VerifierBRUSHOBJ_pvAllocRbrush
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PVOID APIENTRY VerifierBRUSHOBJ_pvAllocRbrush(
    BRUSHOBJ *pbo,
    ULONG     cj
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_BRUSHOBJ_pvAllocRbrush))
    {
        VERIFIERWARNING(1, "VerifierBRUSHOBJ_pvAllocRbrush: inject failure\n");
        return NULL;
    }
    else
        return BRUSHOBJ_pvAllocRbrush(pbo, cj);
}

/******************************Public*Routine******************************\
* VerifierCLIPOBJ_ppoGetPath
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PATHOBJ* APIENTRY VerifierCLIPOBJ_ppoGetPath(
    CLIPOBJ* pco
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_CLIPOBJ_ppoGetPath))
    {
        VERIFIERWARNING(1, "VerifierCLIPOBJ_ppoGetPath: inject failure\n");
        return NULL;
    }
    else
        return CLIPOBJ_ppoGetPath(pco);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\umpddrv.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    umpddrv.cxx

Abstract:

    User-mode printer driver support for Drv callback functions

Environment:

    Windows NT 5.0

Revision History:

    07/8/97 -lingyunw-
        Created it.

    09/17/97 -davidx-
        Clean up km-um thunking.

--*/

#include "precomp.hxx"

#if !defined(_GDIPLUS_)

extern BOOL GreCopyFD_GLYPHSET(FD_GLYPHSET *dst, FD_GLYPHSET *src, ULONG cjSize, BOOL bFromKernel);
extern HSEMAPHORE ghsemEUDC2;

DWORD
UMPDOBJ::Thunk(PVOID pvIn, ULONG cjIn, PVOID pvOut, ULONG cjOut)
{
    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemPalette),
                "ghsemPalette is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemHmgr),
               "ghsemHmgr is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemDriverMgmt),
               "ghsemDriverMgmt is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemRFONTList),
               "ghsemRFONTList is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemPublicPFT),
               "ghsemPublicPFT is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemGdiSpool),
               "ghsemGdiSpool is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemWndobj),
               "ghsemWndobj is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemGlyphSet),
               "ghsemGlyphSet is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemWndobj),
               "ghsemWndobj is held calling back to user mode driver\n");
    
    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemPrintKView),
               "ghsemPrintKView is held calling back to user mode driver\n");
    
    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemShareDevLock),
               "ghsemShareDevLock is held calling back to user mode driver\n");
    
    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemEUDC1),
               "ghsemEUDC1 is held calling back to user mode driver\n");
    
    // WINBUG #214225 we should enable these assertion when 214225 is fixed.
    //ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemEUDC2),
    //           "ghsemEUDC2 is held calling back to user mode driver\n");
    
    //ASSERTGDI(KeAreApcsDisabled() == 0,
    //           "UMPDOBJ::Thunk(): holding some semaphore(s) while calling back to user mode\n");

    if (KeAreApcsDisabled())
    {
        WARNING("UMPDOBJ:Thunk(): holding kernel semaphore(s) while calling into user mode\n");
    }
    
#if defined(_WIN64)
    if(bWOW64())
    {
        // pvIn and pvOut are pointers to stack ... fix this
        UM64_PVOID      umIn = AllocUserMem(cjIn);
        UM64_PVOID      umOut = AllocUserMem(cjOut);
        KERNEL_PVOID    kmIn = GetKernelPtr(umIn);
        KERNEL_PVOID    kmOut = GetKernelPtr(umOut);
        NTSTATUS        status;
        ULONG           ulType = ((UMPDTHDR*)pvIn)->umthdr.ulType;

        if(umIn == NULL || umOut == NULL) return -1;

        RtlCopyMemory(kmIn, pvIn, cjIn);

        if ((ulType == INDEX_DrvQueryFont && ((QUERYFONTINPUT*)pvIn)->iFace) ||
            (ulType == INDEX_DrvQueryFontTree && (((QUERYFONTINPUT*)pvIn)->iMode & (QFT_GLYPHSET | QFT_KERNPAIRS))))
        {
            ((QUERYFONTINPUT*)pvIn)->cjMaxData = ((QUERYFONTINPUT*)kmIn)->cjMaxData = ulGetMaxSize();
            ((QUERYFONTINPUT*)pvIn)->pv = ((QUERYFONTINPUT*)kmIn)->pv = (PVOID)((PBYTE)umOut + cjOut);
        }

        PROXYPORT proxyport(m_proxyPort);

        status = proxyport.SendRequest(umIn, cjIn, umOut, cjOut);
        RtlCopyMemory(pvOut, kmOut, cjOut);

        if(!status)
            return 0;
        else
            return -1;

    }
    else
#endif
    {
        return ClientPrinterThunk(pvIn, cjIn, pvOut, cjOut);
    }
}

BOOL bIsFreeHooked(DHPDEV dhpdev, PUMPDOBJ pumpdobj)
{
    BOOL bRet = TRUE;

    PUMDHPDEV  pUMdhpdev = (PUMDHPDEV) dhpdev;

    if (!pumpdobj->bWOW64())
    {
        __try
        {
            PUMPD  pUMPD;

            ProbeForRead (pUMdhpdev, sizeof(UMDHPDEV), sizeof(BYTE));
            pUMPD = pUMdhpdev->pUMPD;

            ProbeForRead (pUMPD, sizeof(UMPD), sizeof(BYTE));

            if (pUMPD->apfn[INDEX_DrvFree] == NULL)
            {
                bRet = FALSE;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING ("fail to read dhpdev\n");
            bRet = FALSE;;
        }
    }
    return bRet;
}

//
// BOOL UMPDDrvEnableDriver
//      UMPD DrvEnableDriver thunk.
//
// Returns
//      BOOLEAN
//
// Arguments:
//      pswzDriver       Driver Path Name
//      ppUMPD           Pointer to a buffer receiving a PUMPD pointer
//                       which should be filled by the client UMPD thunk
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.

BOOL UMPDDrvDriverFn(
    PVOID          cookie,
    BOOL *         pbDrvFn
    )
{
    DRVDRIVERFNINPUT    Input;
    XUMPDOBJ            XUMObjs;

    if(XUMObjs.bValid())
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_UMDriverFN;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.cookie = cookie;

        return XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), (BOOL *) pbDrvFn, (sizeof(BOOL) * INDEX_LAST)) != 0xffffffff;
    }
    else
    {
        return FALSE;
    }
}

//
// BOOL UMPDDrvEnableDriver
//      UMPD DrvEnableDriver thunk.
//
// Returns
//      BOOLEAN
//
// Arguments:
//      pswzDriver       Driver Path Name
//      ppUMPD           Pointer to a buffer receiving a PUMPD pointer
//                       which should be filled by the client UMPD thunk
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.

BOOL UMPDDrvEnableDriver(
    LPWSTR         pwszDriver,
    PVOID         *pCookie
    )
{
    DRVENABLEDRIVERINPUT Input;
    XUMPDOBJ             XUMObjs;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        if (pwszDriver == NULL)
        {
            WARNING ("null pwszDriver passed in UMPDDrvEnableDriver\n");
            return FALSE;
        }

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_UMPDDrvEnableDriver;   //index for DrvEnableDriver
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pwszDriver = pwszDriver;

        return pumpdobj->ThunkStringW(&Input.pwszDriver) &&
               pumpdobj->Thunk(&Input, sizeof(Input), pCookie, sizeof(PVOID)) != 0xffffffff;
    }
    else
    {
        return FALSE;
    }
}

//
//
// BOOL UMPDDrvDisablePDEV
//      UMPD DrvDisablePDEV thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      VOID
//
// Arguments:
//      refer to DrvDisablePDEV
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

VOID
UMPDDrvDisablePDEV(
    DHPDEV  dhpdev
    )
{
    XUMPDOBJ   XUMObjs;

    if(XUMObjs.bValid())
    {
        DHPDEVINPUT Input;

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvDisablePDEV;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.dhpdev = dhpdev;

        XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), NULL, 0);

        PW32THREAD pThread = W32GetCurrentThread();

        if (pThread->pUMPDObjs == NULL)
        {
            DestroyUMPDHeap((PUMPDHEAP) pThread->pUMPDHeap);
            pThread->pUMPDHeap = NULL;
        }
    }

}

//
// BOOL UMPDDrvEnablePDEV
//      UMPD DrvEnablePDEV thunk.  This routine pack up the input parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOLEAN
//
// Arguments:
//      refer to DrvEnablePDEV
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

DHPDEV
UMPDDrvEnablePDEV(
    PDEVMODEW pdm,
    PWSTR     pLogAddress,
    ULONG     cPatterns,
    HSURF    *phsurfPatterns,
    ULONG     cjCaps,
    ULONG    *pdevcaps,
    ULONG     cjDevInfo,
    DEVINFO  *pDevInfo,
    HDEV      hdev,        // passed in as ppdev
    PWSTR     pDeviceName,
    HANDLE    hPrinter
    )
{
    DRVENABLEPDEVINPUT  Input;
    ULONG               dmSize;
    DHPDEV              dhpdev;
    XUMPDOBJ            XUMObjs;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvEnablePDEV;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.umpdCookie = (PVOID) (((PPDEV) hdev)->dhpdev);
        Input.pdm = pdm;
        Input.pLogAddress = pLogAddress;
        Input.cPatterns = cPatterns;
        Input.phsurfPatterns = phsurfPatterns;
        Input.cjCaps = cjCaps;
        Input.cjDevInfo = cjDevInfo;
        Input.hdev = hdev;
        Input.pDeviceName = pDeviceName;
        Input.hPrinter = hPrinter;
        Input.bWOW64 = pumpdobj->bWOW64();
        Input.clientPid = Input.bWOW64 ? W32GetCurrentPID() : 0;

        dmSize = pdm ? pdm->dmSize + pdm->dmDriverExtra : 0;

        //
        // Allocate temporary output buffers
        //

        if (phsurfPatterns &&
            !(Input.phsurfPatterns = (HSURF *) pumpdobj->AllocUserMemZ(sizeof(HSURF)*cPatterns)) ||
            pdevcaps && !(Input.pdevcaps = (ULONG *) pumpdobj->AllocUserMemZ(cjCaps)) ||
            pDevInfo && !(Input.pDevInfo = (DEVINFO *) pumpdobj->AllocUserMemZ(cjDevInfo)))
        {
            return NULL;
        }

#if defined (_WIN64)
        if (Input.bWOW64)
        {
            PBYTE pHtPat = (PBYTE)pumpdobj->AllocUserMemZ(HT_USERPAT_CX_MAX*HT_USERPAT_CY_MAX*3);

            if (pHtPat)
            {
                Input.pHTPatA = &pHtPat[HT_USERPAT_CX_MAX*HT_USERPAT_CY_MAX*0];
                Input.pHTPatB = &pHtPat[HT_USERPAT_CX_MAX*HT_USERPAT_CY_MAX*1];
                Input.pHTPatC = &pHtPat[HT_USERPAT_CX_MAX*HT_USERPAT_CY_MAX*2];
            }
            else
            {
                return NULL;
            }
        }
#endif
        //
        // Thunk to user mode
        //

        if (!pumpdobj->ThunkMemBlock((PVOID *) &Input.pdm, dmSize) ||
            !pumpdobj->ThunkStringW(&Input.pLogAddress) ||
            !pumpdobj->ThunkStringW(&Input.pDeviceName) ||
            pumpdobj->Thunk(&Input, sizeof(Input), &dhpdev, sizeof(dhpdev)) == 0xffffffff)
        {
            return NULL;
        }

        if (phsurfPatterns)
            RtlCopyMemory(phsurfPatterns, pumpdobj->GetKernelPtr(Input.phsurfPatterns), cPatterns*sizeof(HSURF));

        if (pdevcaps)
            RtlCopyMemory(pdevcaps, pumpdobj->GetKernelPtr(Input.pdevcaps), cjCaps);
#if defined(_WIN64)

        if (Input.bWOW64 && pdevcaps)
        {
            GDIINFO *pGdiInfo = (GDIINFO*)pdevcaps;

            if (pGdiInfo->ulHTPatternSize == HT_PATSIZE_USER &&
                pGdiInfo->cxHTPat <= HT_USERPAT_CX_MAX &&
                pGdiInfo->cyHTPat <= HT_USERPAT_CY_MAX)
            {
                // Mark the PDEV so we can cleanup the allocations in
                // case of a failure in pdevobj.cxx

                PDEVOBJ pdo(hdev);
                pdo.setfl(TRUE, PDEV_WOW64_HTPATSIZE_USER);

                pGdiInfo->pHTPatA = 0;
                pGdiInfo->pHTPatB = 0;
                pGdiInfo->pHTPatC = 0;
                
                LPBYTE pHTPatA = (LPBYTE)pumpdobj->GetKernelPtr(Input.pHTPatA);
                LPBYTE pHTPatB = (LPBYTE)pumpdobj->GetKernelPtr(Input.pHTPatB);
                LPBYTE pHTPatC = (LPBYTE)pumpdobj->GetKernelPtr(Input.pHTPatC);

                LPBYTE pHTPatACopy = NULL;
                LPBYTE pHTPatBCopy = NULL;
                LPBYTE pHTPatCCopy = NULL;


                if (Input.bHTPatA)
                    pHTPatACopy = (LPBYTE)EngAllocUserMem(pGdiInfo->cxHTPat*pGdiInfo->cyHTPat, UMPD_MEMORY_TAG);
                if (Input.bHTPatB)
                    pHTPatBCopy = (LPBYTE)EngAllocUserMem(pGdiInfo->cxHTPat*pGdiInfo->cyHTPat, UMPD_MEMORY_TAG); 
                if (Input.bHTPatC)
                    pHTPatCCopy = (LPBYTE)EngAllocUserMem(pGdiInfo->cxHTPat*pGdiInfo->cyHTPat, UMPD_MEMORY_TAG);

                // The DDI requires at least pHTPatA to be set. PatB and PatC
                // are optional.

                if (pHTPatACopy)
                {
                    __try
                    {
                        ProbeAndReadBuffer(pHTPatACopy,
                                           pHTPatA,
                                           pGdiInfo->cxHTPat*
                                           pGdiInfo->cyHTPat);

                       if (pHTPatBCopy)
                       {
                           ProbeAndReadBuffer(pHTPatBCopy,
                                              pHTPatB,
                                              pGdiInfo->cxHTPat*
                                              pGdiInfo->cyHTPat);
                       }

                       if (pHTPatCCopy)
                       {
                           ProbeAndReadBuffer(pHTPatCCopy,
                                              pHTPatC,
                                              pGdiInfo->cxHTPat*
                                              pGdiInfo->cyHTPat);
                       }
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        EngFreeUserMem(pHTPatACopy);
                        EngFreeUserMem(pHTPatBCopy);
                        EngFreeUserMem(pHTPatCCopy);

                        pHTPatACopy = NULL;
                        pHTPatBCopy = NULL;
                        pHTPatCCopy = NULL;

                        // Do not set the ulHTPatternSize to HTPAT_SIZE_USER.
                        // Use the default which is super cell.

                        pGdiInfo->ulHTPatternSize = HTPAT_SIZE_DEFAULT; 
                    }

                    pGdiInfo->pHTPatA = pHTPatACopy;
                    pGdiInfo->pHTPatB = pHTPatBCopy;
                    pGdiInfo->pHTPatC = pHTPatCCopy;
                }
                else
                {
                    pGdiInfo->ulHTPatternSize = HTPAT_SIZE_DEFAULT;
                }
            }
        }
#endif

        if (pDevInfo)
        {
            //
            // fail the call if driver gives us back a NULL hpalDefault
            //
            DEVINFO *   kmDevInfo = (DEVINFO *) pumpdobj->GetKernelPtr(Input.pDevInfo);

            if (kmDevInfo->hpalDefault == NULL)
            {
               if (dhpdev)
                   UMPDDrvDisablePDEV(dhpdev);
               return NULL;
            }

            RtlCopyMemory(pDevInfo, kmDevInfo, cjDevInfo);
        }

        return (dhpdev);
    }
    else
    {
        return NULL;
    }
}

//
// BOOL UMPDDrvCompletePDEV
//      UMPD DrvCompletePDEV thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      VOID
//
// Arguments:
//      refer to DrvCompletePDEV
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


VOID
UMPDDrvCompletePDEV(
    DHPDEV  dhpdev,
    HDEV    hdev
    )
{
    DRVCOMPLETEPDEVINPUT Input;
    XUMPDOBJ             XUMObjs;

    if(XUMObjs.bValid())
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvCompletePDEV;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.dhpdev = dhpdev;
        Input.hdev = hdev;

        XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), NULL, 0);
    }
}

//
//
// BOOL UMPDDrvResetPDEV
//      UMPD DrvResetPDEV thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvResetPDEV
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL
UMPDDrvResetPDEV(
    DHPDEV  dhpdevOld,
    DHPDEV  dhpdevNew
    )
{
    DRVRESETPDEVINPUT Input;
    BOOL              bRet;
    XUMPDOBJ          XUMObjs;

    if(XUMObjs.bValid())
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvResetPDEV;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.dhpdevOld = dhpdevOld;
        Input.dhpdevNew = dhpdevNew;

        return XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }
    else
    {
        return FALSE;
    }
}


//
//
// BOOL UMPDDrvEnableSurface
//      UMPD DrvEnableSurface thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      HSURF
//
// Arguments:
//      refer to DrvEnableSurface
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//



HSURF
UMPDDrvEnableSurface(
    DHPDEV dhpdev
    )
{
    DHPDEVINPUT Input;
    HSURF       hSurf;
    XUMPDOBJ    XUMObjs;

    if(XUMObjs.bValid())
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvEnableSurface;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.dhpdev = dhpdev;

        if (XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), &hSurf, sizeof(HSURF)) == 0xffffffff)
            hSurf = NULL;

        if (hSurf)
        {
           SURFREF sr(hSurf);

           if (sr.bValid())
           {
              // According to the DDK:
              // If the surface is device-managed, at a minimum,
              // the driver must handle DrvTextOut, DrvStrokePath, and DrvCopyBits
              //

              if (sr.ps->iType() == STYPE_DEVICE)
              {
                 if (!(sr.ps->SurfFlags & HOOK_BITBLT) ||
                     !(sr.ps->SurfFlags & HOOK_STROKEPATH) ||
                     !(sr.ps->SurfFlags & HOOK_TEXTOUT))
                 {
                     hSurf = 0;
                 }
              }
           }
           else
           {
              hSurf = 0;
           }
        }
        return (hSurf);
    }
    else
    {
        return NULL;
    }
}

//
//
// BOOL UMPDDrvDisableSurface
//      UMPD DrvEnableSurface thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      VOID
//
// Arguments:
//      refer to DrvDisableSurface
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

VOID
UMPDDrvDisableSurface(
    DHPDEV dhpdev
    )
{
    DHPDEVINPUT Input;
    XUMPDOBJ    XUMObjs;

    if(XUMObjs.bValid())
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvDisableSurface;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.dhpdev = dhpdev;

        XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), NULL, 0);
    }
}

//
//
// BOOL UMPDDrvDisableDriver
//      UMPD DrvDisableDriver thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      VOID
//
// Arguments:
//      refer to DrvDisableDriver
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

VOID
UMPDDrvDisableDriver(
    )
{
#if 0
    UMPDTHDR    umpdthdr;
    XUMPDOBJ    XUMObjs;

    if(XUMObjs.bValid())
    {
        umpdthdr.umthdr.cjSize = sizeof(umpdthdr);
        umpdthdr.umthdr.ulType = INDEX_DrvDisableDriver;
        umpdthdr.humpd = XUMObjs.hUMPD();

        XUMObjs.pumpdobjs()->Thunk(&umpdthdr, sizeof(umpdthdr), NULL, 0);
    }
#else
    WARNING("Unsupported UMPD entry point being called\n");
    DbgBreakPoint();
#endif
}


#define  UMPD_SIZEINOUTPUT(Input, Output)                                           \
            ALIGN_UMPD_BUFFER(sizeof(Input)) + ALIGN_UMPD_BUFFER(sizeof(Output))

#define  UMPD_SIZESURFOBJ                           \
            ALIGN_UMPD_BUFFER(sizeof(SURFOBJ))

#define  UMPD_SIZEBITMAP(pso)                       \
            ALIGN_UMPD_BUFFER(pso->cjBits)

#define  UMPD_SIZEXLATEOBJ(pxlo)                                                    \
            (pxlo ? (ALIGN_UMPD_BUFFER(pxlo->cEntries * sizeof(ULONG)) + ALIGN_UMPD_BUFFER(sizeof(XLATEOBJ))) : 0)

#define  UMPD_SIZESTROBJ(pstro)                                                         \
            pstro ? ALIGN_UMPD_BUFFER(sizeof(WCHAR) * pstro->cGlyphs) +                 \
                    ALIGN_UMPD_BUFFER(sizeof(GLYPHPOS) * pstro->cGlyphs) +              \
                    ALIGN_UMPD_BUFFER(sizeof(STROBJ))                                   \
                  : 0

#define  UMPD_SIZELINEATTRS(plineattrs)                                                     \
            plineattrs ? ALIGN_UMPD_BUFFER(plineattrs->cstyle * sizeof(FLOAT_LONG)) +       \
                         ALIGN_UMPD_BUFFER(sizeof(LINEATTRS))                               \
                       : 0

#define  UMPD_SIZEXFORMOBJ      ALIGN_UMPD_BUFFER(sizeof(XFORMOBJ))
#define  UMPD_SIZERECTL         ALIGN_UMPD_BUFFER(sizeof(RECTL))
#define  UMPD_SIZECLIPOBJ       ALIGN_UMPD_BUFFER(sizeof(CLIPOBJ))
#define  UMPD_SIZEPOINTL        ALIGN_UMPD_BUFFER(sizeof(POINTL))
#define  UMPD_SIZEPERBANDI      ALIGN_UMPD_BUFFER(sizeof(PERBANDINFO))
#define  UMPD_SIZECOLORADJ      ALIGN_UMPD_BUFFER(sizeof(COLORADJUSTMENT))
#define  UMPD_SIZEBRUSHOBJ      ALIGN_UMPD_BUFFER(sizeof(BRUSHOBJ))
#define  UMPD_SIZEFONTOBJ       ALIGN_UMPD_BUFFER(sizeof(FONTOBJ))
#define  UMPD_SIZEBLENDOBJ      ALIGN_UMPD_BUFFER(sizeof(BLENDOBJ))
#define  UMPD_SIZEPATHOBJ       ALIGN_UMPD_BUFFER(sizeof(PATHOBJ))

/*
    BOOL UMPDOBJ::bDeleteLargeBitmaps

    Delete the duplicated bitmaps for WOW64 printing only
*/

BOOL UMPDOBJ::bDeleteLargeBitmaps(SURFOBJ *psoTrg, SURFOBJ *psoSrc, SURFOBJ *psoMsk)
{
    UMPDFREEMEMINPUT     Input;
    BOOL                    bRet;

    if (!psoTrg && !psoSrc && !psoMsk)
        return TRUE;

    ASSERTGDI(ulAllocSize() == 0, "bDeleteLargeBitmap ulAllocSize is not 0\n");

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_UMPDFreeMemory;
    Input.umpdthdr.humpd = (HUMPD) this->hGet();

    Input.pvTrg = psoTrg ? psoTrg->pvBits : NULL;
    Input.pvSrc = psoSrc ? psoSrc->pvBits : NULL;
    Input.pvMsk = psoMsk ? psoMsk->pvBits : NULL;

    bRet = (Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff) && bRet;

    ResetHeap();
    return bRet;
}

/*
    KERNEL_PVLID UMPDOBJ::UMPDAllocUserMem

    Used for WOW64 printing. Allocate user mode memory via LPC calls.
*/

KERNEL_PVOID  UMPDOBJ::UMPDAllocUserMem(ULONG cjSize)
{
    UMPDALLOCUSERMEMINPUT   Input;
    KERNEL_PVOID            pvRet = NULL;

    ASSERTGDI(ulAllocSize() == 0, "UMPDAllocUserMem ulAllocSize is not 0\n");

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_UMPDAllocUserMem;
    Input.umpdthdr.humpd = (HUMPD) this->hGet();
    Input.cjSize = cjSize;

    if (Thunk(&Input, sizeof(Input), &pvRet, sizeof(KERNEL_PVOID)) == 0xffffffff)
    {
        ASSERTGDI(pvRet == NULL, "not NULL pvRet returned\n");
    }

    ResetHeap();
    return pvRet;
}

/*  BOOL UMPDOBJ::bSendLargeBitmap

    Used for WOW64 printing when the bitmap size is bigger than 8M.
    The bitmap will be copied into the user mode address returned by UMPDOBJ::UMPDAllocUserMem call.
*/

BOOL UMPDOBJ::bSendLargeBitmap(
    SURFOBJ *pso,
    BOOL    *pbLargeBitmap
)
{
    UMPDCOPYMEMINPUT  Input;
    KERNEL_PVOID    pvRet = NULL, pvDest;
    PVOID       pvSrc, pvBits;
    ULONG   cjBmpSize, cjBuffSize, offset = 0;
    BOOL    bRet = FALSE;

    if (!(pvDest = UMPDAllocUserMem(pso->cjBits)))
        return FALSE;

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_UMPDCopyMemory;
    Input.umpdthdr.humpd = (HUMPD) this->hGet();
    Input.pvDest = pvDest;

    ASSERTGDI(ulAllocSize() == 0, "bSendLargeBitmap ulAllocSize is not 0\n");

    cjBuffSize = ulGetMaxSize() - ALIGN_UMPD_BUFFER(sizeof(Input)) - ALIGN_UMPD_BUFFER(sizeof(KERNEL_PVOID));
    cjBmpSize = pso->cjBits;
    pvBits = pso->pvBits;

    while(cjBmpSize)
    {
        Input.cjSize = (cjBmpSize > cjBuffSize) ? cjBuffSize : cjBmpSize;

        if ((Input.pvSrc = AllocUserMem(Input.cjSize)) == NULL)
            break;

        pvSrc = GetKernelPtr(Input.pvSrc);
        RtlCopyMemory(pvSrc, pvBits, Input.cjSize);

        if ((Thunk(&Input, sizeof(Input), &pvRet, sizeof(pvRet)) == 0xffffffff) || pvRet == NULL)
            break;

        offset += Input.cjSize;
        cjBmpSize -= Input.cjSize;

        Input.pvDest = (PBYTE)pvDest + offset;
        pvBits = (PBYTE)pso->pvBits + offset;

        ResetHeap();
    }

    offset = (ULONG)(LONG_PTR)((PBYTE)pso->pvScan0 - (PBYTE)pso->pvBits);

    pso->pvBits = pvDest;
    pso->pvScan0 = (PBYTE)pso->pvBits + offset;

    if (cjBmpSize == 0)
    {
        *pbLargeBitmap = TRUE;
        bRet = TRUE;
    }
    else
    {
        ResetHeap();
        bDeleteLargeBitmaps(pso, NULL, NULL);
    }

    return bRet;
}


/*
  BOOL UMPDOBJ::bThunkLargeBitmap

  Unsed only for WOW64 printing.

  Save the orignal pvBits and pvScan0 pointers.

  Check to see whether this is a big bitmap that can't fit into the heap.
  If so, send the request to allocate user mode space in the print server
  and copy the bitmap into the new address.

  pcjSize
        At the entry point, it contains the size needed, excluding the SURFOBJ sturct and the bitmap, to thunk the current DDI call.
        When exist, it contains the size needed to thunk the current DDI call, including the SURFOBJ and the bitmap.
*/

BOOL  UMPDOBJ::bThunkLargeBitmap(
    SURFOBJ  *pso,
    PVOID    *ppvBits,
    PVOID    *ppvScan0,
    BOOL     *pbSavePtr,
    BOOL     *pbLargeBitmap,
    ULONG    *pcjSize
)
{
    BOOL    bRet = TRUE;

    ASSERTGDI(bWOW64(), "bThunkLargeBitmap called during NONE wow64 printing\n");

    if (pso && pso->pvBits)
    {
        ULONG   cjSizeNeed, cjMaxSize;

        ASSERTGDI(ulAllocSize() == 0, "bThunkLargeBitmap: ulAllocSize is not 0\n");

        *pbSavePtr = TRUE;
        *ppvBits = pso->pvBits;
        *ppvScan0 = pso->pvScan0;

        cjMaxSize = ulGetMaxSize();
        cjSizeNeed = *pcjSize + UMPD_SIZESURFOBJ;

        if (pso->pvBits)
        {
            if ((cjSizeNeed + UMPD_SIZEBITMAP(pso)) > cjMaxSize)
            {
                bRet = bSendLargeBitmap(pso, pbLargeBitmap);
            }
            else
                cjSizeNeed += UMPD_SIZEBITMAP(pso);
        }

        if (bRet)
            *pcjSize = cjSizeNeed;
    }

    return bRet;
}

/*
    BOOL UMPDOBJ::bThunkLargeBitmaps()

    Only used for WOW64 printing.

    Thunk the large bitmaps by calling UMPDOBJ::bThunkLargeBitmap().

    pbLargeTrg
    pbLargeSrc
    pbLargeMsk
        are all initialized as FALSE before calling this routine.

    cjSize
        Heap size needed, excluding the surfobj's, to thunk the DDI call.

*/

BOOL  UMPDOBJ::bThunkLargeBitmaps(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMsk,
    PVOID    *ppvBitTrg,
    PVOID    *ppvScanTrg,
    PVOID    *ppvBitSrc,
    PVOID    *ppvScanSrc,
    PVOID    *ppvBitMsk,
    PVOID    *ppvScanMsk,
    BOOL     *pbSaveTrg,
    BOOL     *pbLargeTrg,
    BOOL     *pbSaveSrc,
    BOOL     *pbLargeSrc,
    BOOL     *pbSaveMsk,
    BOOL     *pbLargeMsk,
    ULONG    *pcjSize
)
{
    ULONG   cjSizeNeed, cjMaxSize;
    BOOL    bRet = TRUE;

    ASSERTGDI(bWOW64(), "bThunkLargeBitmaps called during NONE wow64 printing\n");

    if (!psoTrg && !psoSrc && !psoMsk)
        return TRUE;

    if (bRet = bThunkLargeBitmap(psoTrg, ppvBitTrg, ppvScanTrg, pbSaveTrg, pbLargeTrg, pcjSize))
        if (bRet = bThunkLargeBitmap(psoSrc, ppvBitSrc, ppvScanSrc, pbSaveSrc, pbLargeSrc, pcjSize))
            bRet = bThunkLargeBitmap(psoMsk, ppvBitMsk, ppvScanMsk, pbSaveMsk, pbLargeMsk, pcjSize);

    if (!bRet)
    {
        bDeleteLargeBitmaps((pbLargeTrg && *pbLargeTrg) ? psoTrg : NULL,
                            (pbLargeSrc && *pbLargeSrc) ? psoSrc : NULL,
                            (pbLargeMsk && *pbLargeMsk) ? psoMsk : NULL);
    }

    return bRet;
}


/* VOID UMPDOBJ::RestoreBitmap

    Used only for the WOW64 printing.

    Restore the orignal pvBits and pvScan0 pointers in SURFOBJ

*/

VOID UMPDOBJ::RestoreBitmap(
    SURFOBJ *pso,
    PVOID   pvBits,
    PVOID   pvScan0,
    BOOL    bSavePtr,
    BOOL    bLargeBitmap
)
{
    ASSERTGDI(bWOW64(), "UMPDOBJ:RestoreBitmap bSavePtr is TRUE during NONE wow64 printing\n");

    if (bLargeBitmap)
        bDeleteLargeBitmaps(pso, NULL, NULL);

    pso->pvBits = pvBits;
    pso->pvScan0 = pvScan0;
}


/* VOID UMPDOBJ::RestoreBitmaps

    Used only for the WOW64 printing.

    Save as RestoreBitmap but takes three SURFOBJ instead of one.
*/

VOID UMPDOBJ::RestoreBitmaps(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMsk,
    PVOID    pvBitTrg,
    PVOID    pvScanTrg,
    PVOID    pvBitSrc,
    PVOID    pvScanSrc,
    PVOID    pvBitMsk,
    PVOID    pvScanMsk,
    BOOL     bSaveTrg,
    BOOL     bLargeTrg,
    BOOL     bSaveSrc,
    BOOL     bLargeSrc,
    BOOL     bSaveMsk,
    BOOL     bLargeMsk
)
{
    ASSERTGDI(bWOW64(), "RestoreBitmaps called during NONE wow64 printing\n");

    if (bSaveTrg || bSaveSrc || bSaveMsk)
    {
        bDeleteLargeBitmaps(bLargeTrg ? psoTrg : NULL, bLargeSrc ? psoSrc : NULL, bLargeMsk ? psoMsk : NULL);

        if (bSaveTrg)
        {
            psoTrg->pvBits  = pvBitTrg;
            psoTrg->pvScan0 = pvScanTrg;
        }

        if (bSaveSrc)
        {
            psoSrc->pvBits  = pvBitSrc;
            psoSrc->pvScan0 = pvScanSrc;
        }

        if (bSaveMsk)
        {
            psoMsk->pvBits  = pvBitMsk;
            psoMsk->pvScan0 = pvScanMsk;
        }
    }
}


//
//
// BOOL UMPDDrvStartDoc
//      UMPD DrvStartDoc thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvStartDoc
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

BOOL  UMPDDrvStartDoc(
    SURFOBJ *pso,
    LPWSTR   pwszDocName,
    DWORD    dwJobId
    )
{
    DRVSTARTDOCINPUT Input;
    BOOL             bRet = TRUE;
    BOOL             bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ         XUMObjs;
    PVOID            pvBits, pvScan0;
    PUMPDOBJ         pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) +
                             (pwszDocName ? ALIGN_UMPD_BUFFER((wcslen(pwszDocName) + 1) * sizeof(WCHAR)) : 0));

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvStartDoc;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.pwszDocName = pwszDocName;
        Input.dwJobId = dwJobId;

        bRet =  pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
                pumpdobj->ThunkStringW(&Input.pwszDocName) &&
                (pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff) &&
                bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
//
// BOOL UMPDDrvEndDoc
//      UMPD DrvEndDoc thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvEndDoc
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvEndDoc(
    SURFOBJ *pso,
    FLONG fl
    )
{
    DRVENDDOCINPUT  Input;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet);

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvEndDoc;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.fl = fl;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
//
// BOOL UMPDDrvStartPage
//      UMPD DrvStartPage thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvStartPage
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvStartPage(
    SURFOBJ *pso
    )
{
    SURFOBJINPUT    Input;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet);

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvStartPage;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
//
// BOOL UMPDDrvSendPage
//      UMPD DrvSendPage thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvSendPage
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

BOOL UMPDDrvSendPage(
    SURFOBJ *pso
    )
{
    SURFOBJINPUT    Input;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet);

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvSendPage;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}


//
//
// BOOL UMPDDrvEscape
//      UMPD DrvEscape thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvEscape
//
// History:
//      8/14/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


ULONG UMPDDrvEscape(
    SURFOBJ *pso,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
    )
{
    DRVESCAPEINPUT  Input;
    ULONG           ulRet = GDI_ERROR;
    XUMPDOBJ        XUMObjs;
    BOOL            bContinue = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return GDI_ERROR;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, ulRet) + UMPD_SIZEXFORMOBJ +
                             ALIGN_UMPD_BUFFER(cjIn) + ALIGN_UMPD_BUFFER(cjOut);

        bContinue = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0,
                                                &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bContinue)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvEscape;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;

        if (cjIn == 0)
            pvIn = NULL;

        if (cjOut == 0)
            pvOut = NULL;

        Input.iEsc = iEsc;
        Input.cjIn = cjIn;
        Input.pvIn = pvIn;
        Input.cjOut = cjOut;
        Input.pvOut = pvOut;

        //
        // If the input buffer is not empty and the address is in system
        // address space, then we need to make a copy of the input
        // buffer into temporary user mode buffer.
        //

        if (iEsc == DRAWPATTERNRECT)
        {
           PDEVOBJ pdo(pso->hdev);

           if (pdo.flGraphicsCaps() & GCAPS_NUP)
           {
               XFORMOBJ *pxo = ((DRAWPATRECTP *)Input.pvIn)->pXformObj;

               if (!pumpdobj->pxo(&pxo))
               {
                   bContinue = FALSE;
               }
               else
               {
                   ((DRAWPATRECTP *)Input.pvIn)->pXformObj = pxo;
               }
           }
        }

        if (bContinue)
        {
           if (cjIn && pumpdobj->bNeedThunk(pvIn) && !pumpdobj->ThunkMemBlock(&Input.pvIn, cjIn) ||
               cjOut && !(Input.pvOut = pumpdobj->AllocUserMemZ(cjOut)) ||
               !pumpdobj->psoDest(&Input.pso, bLargeBitmap) ||
               pumpdobj->Thunk(&Input, sizeof(Input), &ulRet, sizeof(ulRet)) == 0xffffffff)
           {
               ulRet = GDI_ERROR;
           }
           else
           {
               if (cjOut)
                   RtlCopyMemory(pvOut, pumpdobj->GetKernelPtr(Input.pvOut), cjOut);
           }
        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return (ulRet);
}

//
//
// BOOL UMPDDrvDrawEscape
//      UMPD DrvDrawEscape thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvDrawEscape
//
// History:
//      10/3/98 -- Lingyun Wang [lingyunw] -- Wrote it.
//


ULONG UMPDDrvDrawEscape(
    SURFOBJ *pso,
    ULONG    iEsc,
    CLIPOBJ  *pco,
    RECTL    *prcl,
    ULONG    cjIn,
    PVOID    pvIn
    )
{
    DRVDRAWESCAPEINPUT  Input;
    ULONG           ulRet = GDI_ERROR;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    BOOL            bContinue = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return GDI_ERROR;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, ulRet) + UMPD_SIZERECTL +
                             UMPD_SIZECLIPOBJ + ALIGN_UMPD_BUFFER(cjIn);

        bContinue = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr,
                                                &bLargeBitmap, &cjSizeNeed);
    }

    if (bContinue)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvDrawEscape;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;

        if (cjIn == 0)
            pvIn = NULL;

        Input.iEsc = iEsc;
        Input.pco = pco;
        Input.prcl = prcl;
        Input.cjIn = cjIn;
        Input.pvIn = pvIn;

        //
        // If the input buffer is not empty and the address is in system
        // address space, then we need to make a copy of the input
        // buffer into temporary user mode buffer.
        //

        if (cjIn && pumpdobj->bNeedThunk(pvIn) && !pumpdobj->ThunkMemBlock(&Input.pvIn, cjIn) ||
            !pumpdobj->psoDest(&Input.pso, bLargeBitmap) || !pumpdobj->pco(&Input.pco) ||
            !pumpdobj->ThunkRECTL(&Input.prcl) ||
            pumpdobj->Thunk(&Input, sizeof(Input), &ulRet, sizeof(ulRet)) == 0xffffffff)
        {
            ulRet = GDI_ERROR;
        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return (ulRet);
}


//
//
// BOOL UMPDDrvStartBanding
//      UMPD DrvStartBanding thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvStartBanding
//
// History:
//      8/13/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

BOOL UMPDDrvStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    )
{
    DRVBANDINGINPUT Input;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZEPOINTL;

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvStartBanding;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.pptl = pptl;

        if (pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
            pumpdobj->ThunkPOINTL(&Input.pptl) &&
            pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff)
        {
            if (pptl != NULL)
                RtlCopyMemory(pptl, pumpdobj->GetKernelPtr(Input.pptl), sizeof(POINTL));
        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
//
// BOOL UMPDDrvNextBand
//      UMPD DrvNextBand thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvNextBand
//
// History:
//      8/13/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    )
{
    DRVBANDINGINPUT Input;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZEPOINTL;

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvNextBand;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.pptl = pptl;

        if (pumpdobj->psoDest(&Input.pso, bLargeBitmap)         &&
            pumpdobj->ThunkPOINTL(&Input.pptl)                  &&
            pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff)
        {
            if (pptl != NULL)
                RtlCopyMemory(pptl, pumpdobj->GetKernelPtr(Input.pptl), sizeof(POINTL));
        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}


ULONG UMPDDrvQueryPerBandInfo(
    SURFOBJ *pso,
    PERBANDINFO *pbi
    )
{
    DRVPERBANDINPUT Input;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZEPERBANDI;

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvQueryPerBandInfo;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;

        if (pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
            (Input.pbi = (PERBANDINFO *) pumpdobj->AllocUserMem(sizeof(PERBANDINFO))) != NULL)
        {
            if (pbi != NULL)
                RtlCopyMemory(pumpdobj->GetKernelPtr(Input.pbi), pbi, sizeof(PERBANDINFO));
            if (pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff)
            {
                if (pbi != NULL)
                    RtlCopyMemory(pbi, pumpdobj->GetKernelPtr(Input.pbi), sizeof(PERBANDINFO));
            }
        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

BOOL UMPDDrvQueryDeviceSupport(
    SURFOBJ *pso,
    XLATEOBJ *pxlo,
    XFORMOBJ *pxo,
    ULONG iType,
    ULONG cjIn,
    PVOID pvIn,
    ULONG cjOut,
    PVOID pvOut)
{
    DRVQUERYDEVICEINPUT  Input;
    BOOL                 bRet = TRUE;
    BOOL                 bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ             XUMObjs;
    PVOID                pvBits, pvScan0;
    PUMPDOBJ             pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZEXFORMOBJ + UMPD_SIZEXLATEOBJ(pxlo) +
                             ALIGN_UMPD_BUFFER(cjIn) + ALIGN_UMPD_BUFFER(cjOut));

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvQueryDeviceSupport;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.pxlo = pxlo;
        Input.pxo = pxo;

        if (cjIn == 0)
            pvIn = NULL;

        if (cjOut == 0)
            pvOut = NULL;

        Input.iType = iType;
        Input.cjIn = cjIn;
        Input.pvIn = pvIn;
        Input.cjOut = cjOut;
        Input.pvOut = pvOut;

        //
        // If the input buffer is not empty and the address is in system
        // address space, then we need to make a copy of the input
        // buffer into temporary user mode buffer for x86.
        //
        // For WOW64, we have to always copy the input buffer.
        //

        if (cjIn && !pumpdobj->ThunkMemBlock(&Input.pvIn, cjIn) ||
            cjOut && !(Input.pvOut = pumpdobj->AllocUserMemZ(cjOut)) ||
            !pumpdobj->psoDest(&Input.pso, bLargeBitmap) || !pumpdobj->pxlo(&Input.pxlo) || !pumpdobj->pxo(&Input.pxo) ||
            pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(bRet)) == 0xffffffff)
        {
            bRet = FALSE;
        }
        else
        {
            if (cjOut)
                RtlCopyMemory(pvOut, pumpdobj->GetKernelPtr(Input.pvOut), cjOut);
        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
//
// BOOL UMPDDrvPlgBlt
//      UMPD DrvPlgBlt thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvPlgBlt
//
// History:
//      8/13/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvPlgBlt(
    SURFOBJ         *psoTrg,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMsk,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfx,
    RECTL           *prcl,
    POINTL          *pptl,
    ULONG            iMode
    )
{
    DRVPLGBLTINPUT Input;
    BOOL           bRet = TRUE;
    BOOL           bSaveTrg = FALSE, bSaveSrc = FALSE ,bSaveMsk = FALSE;
    BOOL           bLargeTrg = FALSE, bLargeSrc = FALSE, bLargeMsk = FALSE;
    XUMPDOBJ       XUMObjs;
    PVOID          pvBitTrg, pvBitSrc, pvBitMsk;
    PVOID          pvScanTrg, pvScanSrc, pvScanMsk;
    PUMPDOBJ       pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEXLATEOBJ(pxlo) +
                             UMPD_SIZECOLORADJ + 2 * UMPD_SIZEPOINTL + ALIGN_UMPD_BUFFER(sizeof(POINTFIX)*3) + UMPD_SIZERECTL);

        bRet = pumpdobj->bThunkLargeBitmaps(psoTrg, psoSrc, psoMsk,
                                            &pvBitTrg, &pvScanTrg,
                                            &pvBitSrc, &pvScanSrc,
                                            &pvBitMsk, &pvScanMsk,
                                            &bSaveTrg, &bLargeTrg,
                                            &bSaveSrc, &bLargeSrc,
                                            &bSaveMsk, &bLargeMsk,
                                            &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvPlgBlt;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.psoTrg = psoTrg;
        Input.psoSrc = psoSrc;
        Input.psoMask = psoMsk;
        Input.pco = pco;
        Input.pxlo = pxlo;
        Input.pca = pca;
        Input.pptlBrushOrg = pptlBrushOrg;
        Input.pptfx = pptfx;
        Input.prcl = prcl;
        Input.pptl = pptl;
        Input.iMode = iMode;

        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeTrg) &&
               pumpdobj->psoSrc(&Input.psoSrc, bLargeSrc) &&
               pumpdobj->psoMask(&Input.psoMask, bLargeMsk) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkCOLORADJUSTMENT(&Input.pca) &&
               pumpdobj->ThunkPOINTL(&Input.pptlBrushOrg) &&
               pumpdobj->ThunkMemBlock((PVOID*) &Input.pptfx, sizeof(POINTFIX)*3) &&
               pumpdobj->ThunkRECTL(&Input.prcl) &&
               pumpdobj->ThunkPOINTL(&Input.pptl) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoTrg, psoSrc, psoMsk,
                                 pvBitTrg, pvScanTrg, pvBitSrc, pvScanSrc, pvBitMsk, pvScanMsk,
                                 bSaveTrg, bLargeTrg, bSaveSrc, bLargeSrc, bSaveMsk, bLargeMsk);
    }

    return bRet;
}


HBITMAP UMPDDrvCreateDeviceBitmap(
    DHPDEV dhpdev,
    SIZEL  sizl,
    ULONG  iFormat
    )
{
    return 0;
}

//
// need to pass in a dhpdev here from the calling routine
//
VOID UMPDDrvDeleteDeviceBitmap(
    DHPDEV dhpdev,
    DHSURF dhsurf
    )
{
    XUMPDOBJ       XUMObjs;

    if(XUMObjs.bValid())
    {
        DRVDELETEDEVBITMAP Input;

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvDeleteDeviceBitmap;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.dhpdev = dhpdev;
        Input.dhsurf = dhsurf;

        XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), NULL, 0);
    }
}


//
//
// BOOL UMPDDrvDitherColor
//      UMPD DrvDitherColo thunk.  This routine pack up the input parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      ULONG
//
// Arguments:
//      refer to DrvDitherColor
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

INT
GetBitDepthFromBMF(
    INT bmf
    )

#define MIN_BMF_INDEX   BMF_1BPP
#define MAX_BMF_INDEX   BMF_8RLE
#define BMF_COUNT       (MAX_BMF_INDEX - MIN_BMF_INDEX + 1)

{
    static const INT bitdepths[BMF_COUNT] =
    {
        1,  // BMF_1BPP
        4,  // BMF_4BPP
        8,  // BMF_8BPP
        16, // BMF_16BPP
        24, // BMF_24BPP
        32, // BMF_32BPP
        4,  // BMF_4RLE
        8   // BMF_8RLE
    };

    if (bmf < MIN_BMF_INDEX || bmf > MAX_BMF_INDEX)
        return 0;
    else
        return bitdepths[bmf - MIN_BMF_INDEX];
}

ULONG UMPDDrvDitherColor(
    DHPDEV dhpdevIn,      // the first parameter is actually a ppdev
    ULONG  iMode,
    ULONG  rgb,
    ULONG  *pul
    )
{
    DRVDITHERCOLORINPUT Input;
    ULONG               ulRet;
    XUMPDOBJ            XUMObjs;
    PDEV                *ppdev;
    DHPDEV              dhpdev;
    INT                 cj;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        ppdev = (PDEV *)dhpdevIn;
        dhpdev = ppdev->dhpdev;

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvDitherColor;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.dhpdev = dhpdev;
        Input.iMode = iMode;
        Input.rgb = rgb;

        if ((cj = GetBitDepthFromBMF(ppdev->devinfo.iDitherFormat)) <= 0)
            return DCR_SOLID;

        cj = ((ppdev->devinfo.cxDither * cj + 7) / 8) * ppdev->devinfo.cyDither;

        if ((Input.pul = (ULONG *) pumpdobj->AllocUserMem(cj)) == NULL ||
            pumpdobj->Thunk(&Input, sizeof(Input), &ulRet, sizeof(ULONG)) == 0xffffffff)
        {
            return DCR_SOLID;
        }

        if (Input.pul != NULL)
            RtlCopyMemory(pul, pumpdobj->GetKernelPtr(Input.pul), cj);

        return ulRet;
    }
    else
    {
        return FALSE;
    }
}


//
//
// BOOL UMPDDrvRealizeBrush
//      UMPD DrvRealizeBrush thunk.  This routine pack up the input parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      ULONG
//
// Arguments:
//      refer to DrvRealizeBrush
//
// History:
//      8/13/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

BOOL UMPDDrvRealizeBrush(
    BRUSHOBJ *pbo,
    SURFOBJ  *psoTarget,
    SURFOBJ  *psoPattern,
    SURFOBJ  *psoMask,
    XLATEOBJ *pxlo,
    ULONG    iHatch
    )
{
    DRVREALIZEBRUSHINPUT Input;
    BOOL                 bRet = TRUE;
    BOOL                 bSaveTrg = FALSE, bSavePat = FALSE, bSaveMsk = FALSE;
    BOOL                 bLargeTrg = FALSE, bLargePat = FALSE, bLargeMsk = FALSE;
    XUMPDOBJ             XUMObjs;
    PVOID                pvBitTrg, pvBitPat, pvBitMsk;
    PVOID                pvScanTrg, pvScanPat, pvScanMsk;
    PUMPDOBJ             pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZEBRUSHOBJ + UMPD_SIZEXLATEOBJ(pxlo));

        bRet = pumpdobj->bThunkLargeBitmaps(psoTarget, psoPattern, psoMask,
                                            &pvBitTrg, &pvScanTrg,
                                            &pvBitPat, &pvScanPat,
                                            &pvBitMsk, &pvScanMsk,
                                            &bSaveTrg, &bLargeTrg,
                                            &bSavePat, &bLargePat,
                                            &bSaveMsk, &bLargeMsk,
                                            &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvRealizeBrush;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pbo = pbo;
        Input.psoTrg = psoTarget;
        Input.psoPat = psoPattern;
        Input.psoMsk = psoMask;
        Input.pxlo = pxlo;
        Input.iHatch = iHatch;

        bRet = pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->psoDest(&Input.psoTrg, bLargeTrg)  &&
               pumpdobj->psoSrc(&Input.psoPat, bLargePat)   &&
               pumpdobj->psoMask(&Input.psoMsk, bLargeMsk)  &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoTarget, psoPattern, psoMask,
                                 pvBitTrg, pvScanTrg, pvBitPat, pvScanPat, pvBitMsk, pvScanMsk,
                                 bSaveTrg, bLargeTrg, bSavePat, bLargePat, bSaveMsk, bLargeMsk);
    }

    return bRet;
}

// private
VOID UMPDMyDrvFree(
   PUMPDOBJ pumpdobj,
   DHPDEV  dhpdev,
   PVOID   pv,
   ULONG   id)
{
    DRVFREEINPUT Input;

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_DrvFree;
    Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

    Input.dhpdev = dhpdev;
    Input.pv = pv;
    Input.id = id;

    pumpdobj->Thunk(&Input, sizeof(Input), NULL, NULL);
}


PIFIMETRICS UMPDDrvQueryFont(
    DHPDEV    dhpdev,
    ULONG_PTR  iFile,
    ULONG     iFace,
    ULONG     *pid
    )
{
    QUERYFONTINPUT  Input;
    PIFIMETRICS     pifi, pifiKM = NULL;
    XUMPDOBJ        XUMObjs;
    ULONG           cj = 0;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvQueryFont;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.dhpdev = dhpdev;
        Input.iFile = iFile;
        Input.iFace = iFace;
        Input.pid = (ULONG *) pumpdobj->AllocUserMemZ(sizeof(ULONG));
        Input.cjMaxData = 0;
        Input.pv = NULL;

        if (Input.pid == NULL ||
            pumpdobj->Thunk(&Input, sizeof(Input), &pifi, sizeof(pifi)) == 0xffffffff)
        {
            return NULL;
        }

        *pid = *((ULONG *) pumpdobj->GetKernelPtr(Input.pid));

        if (pifi)
        {
           if (iFace)
           {
              if (Input.pv)
              {
                  if (Input.cjMaxData)
                  {
                      PIFIMETRICS  kmpifi = (PIFIMETRICS) pumpdobj->GetKernelPtr(Input.pv);

                      cj = kmpifi->cjThis;

                      ASSERTGDI(Input.cjMaxData >= cj, "UMPDDrvQueryFont: not enough buffer\n");

                      if (pifiKM = (PIFIMETRICS)PALLOCMEM(cj, UMPD_MEMORY_TAG))
                        RtlCopyMemory(pifiKM, kmpifi, cj);
                  }
                  else
                  {
                      WARNING("UMPDDrvQueryFont: not enough buffer\n");
                  }
              }
              else
              {
                  __try
                 {
                     ProbeForRead(pifi, sizeof(DWORD), sizeof(BYTE));
                     cj = pifi->cjThis;

                     //
                     // pifiKM is returned to the font code, it will call
                     // on DrvFree to free it later
                     //
                     if (pifiKM = (PIFIMETRICS)PALLOCMEM(cj, UMPD_MEMORY_TAG))
                     {
                        ProbeForRead(pifi, cj, sizeof(BYTE));
                        RtlCopyMemory(pifiKM, pifi, cj);
                     }
                 }
                 __except(EXCEPTION_EXECUTE_HANDLER)
                 {
                     WARNING ("fail to read pifi\n");
                     return NULL;
                 }
              }

              //
              // call DrvFree to free the user mode copy
              //

              if (bIsFreeHooked(dhpdev, pumpdobj))
                  UMPDMyDrvFree(pumpdobj, dhpdev, pifi, *pid);
           }
           else
           {
              //
              // if iFace == 0, it comes from PDEVOBJ__cFonts when cFonts==-1
              // to query number of fonts supported.
              //
              // In this case, pifi will contain the number of fonts supported
              //

              return pifi;
           }
        }


        //
        // we use the lower part of pifiKM pointer as the id,
        // to make sure no one is going to over-write any fields we returned
        //
        *pid = (ULONG)(ULONG_PTR)pifiKM;

        return pifiKM;
    }
    else
    {
        return NULL;
    }
}

BOOL GreFixAndCopyFD_GLYPHSET(
    FD_GLYPHSET *dst,
    FD_GLYPHSET *src,
    ULONG       cjSize,
    PUMPDOBJ    pumpdobj
    )
{
    ULONG   index, offset;

    RtlCopyMemory(dst, src, cjSize);

    for (index=0; index < src->cRuns; index++)
    {
        if (src->awcrun[index].phg != NULL)
        {
            offset = (ULONG) ((PBYTE)(pumpdobj->GetKernelPtr(src->awcrun[index].phg)) - (PBYTE)src);

            if (offset >= cjSize)
            {
                WARNING("GreFixAndCopyFD_GLYPHSET failed.\n");
                return FALSE;
            }

            dst->awcrun[index].phg = (HGLYPH*) ((PBYTE) dst + offset);
        }
    }
    return TRUE;
}

PVOID UMPDDrvQueryFontTree(
    DHPDEV    dhpdev,
    ULONG_PTR  iFile,
    ULONG     iFace,
    ULONG     iMode,
    ULONG     *pid
    )
{
    QUERYFONTINPUT  Input;
    PVOID           pv = NULL, kmpv = NULL;
    PVOID           pvKM = NULL;
    XUMPDOBJ        XUMObjs;
    ULONG           cjSize;
    BOOL            bProxyBuffer = FALSE;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvQueryFontTree;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.dhpdev = dhpdev;
        Input.iFile = iFile;
        Input.iFace = iFace;
        Input.iMode = iMode;
        Input.pid = (ULONG *) pumpdobj->AllocUserMemZ(sizeof(ULONG));
        Input.cjMaxData = 0;
        Input.pv = NULL;

        if (Input.pid == NULL ||
            pumpdobj->Thunk(&Input, sizeof(Input), &pv, sizeof(pv)) == 0xffffffff ||
            pv == NULL)
        {
            return NULL;
        }

        *pid = *((ULONG *) pumpdobj->GetKernelPtr(Input.pid));

        cjSize = 0;
        bProxyBuffer = pumpdobj->bWOW64() && Input.pv && Input.cjMaxData;
        kmpv = pumpdobj->GetKernelPtr(Input.pv);

        if (iMode == QFT_GLYPHSET)
        {
            // using proxy

            if (bProxyBuffer)
            {
                cjSize = ((PFD_GLYPHSET)kmpv)->cjThis;
            }
            else if (!pumpdobj->bWOW64())
            {
                __try
                {
                    cjSize = offsetof(FD_GLYPHSET, awcrun) + ((PFD_GLYPHSET)pv)->cRuns * sizeof(WCRUN) + ((PFD_GLYPHSET)pv)->cGlyphsSupported * sizeof(HGLYPH);
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING ("fail to read pv\n");
                    return NULL;
                }
            }
        }
        else if (iMode == QFT_KERNPAIRS)
        {
            // Find the end of the kerning pair array (indicated by a zeroed out
            // FD_KERNINGPAIR structure).

            FD_KERNINGPAIR *pkpEnd;

            if (bProxyBuffer)
            {
                pkpEnd = (FD_KERNINGPAIR*)kmpv;
                while ((pkpEnd->wcFirst) || (pkpEnd->wcSecond) || (pkpEnd->fwdKern))
                {
                    pkpEnd += 1;
                    cjSize++;
                }
            }
            else if (!pumpdobj->bWOW64())
            {
                pkpEnd = (FD_KERNINGPAIR *)pv;
                __try
                {
                    while ((pkpEnd->wcFirst) || (pkpEnd->wcSecond) || (pkpEnd->fwdKern))
                    {
                        pkpEnd += 1;
                        cjSize++;
                    }
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                   WARNING ("fail to read kerning pair\n");
                   return NULL;
                }
            }
            cjSize = (cjSize + 1) * sizeof(FD_KERNINGPAIR);
        }

        if (cjSize && (pvKM = PALLOCMEM(cjSize, UMPD_MEMORY_TAG)))
        {
            if (iMode == QFT_GLYPHSET)
            {
                if (bProxyBuffer)
                {
                    if (!GreFixAndCopyFD_GLYPHSET((FD_GLYPHSET*)pvKM, (FD_GLYPHSET*)kmpv, cjSize, pumpdobj))
                    {
                        VFREEMEM(pvKM);
                        pvKM = NULL;
                    }
                }
                else if (!pumpdobj->bWOW64())
                {
                    __try
                    {
                        if (!GreCopyFD_GLYPHSET((FD_GLYPHSET*)pvKM, (FD_GLYPHSET*)pv, cjSize, FALSE))
                        {
                            VFREEMEM(pvKM);
                            pvKM = NULL;
                        }
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                       WARNING ("fail to copy pv\n");
                       if (pvKM)
                           VFREEMEM(pvKM);
                       return NULL;
                    }
                }
            }
            else if (iMode == QFT_KERNPAIRS)
            {
                if (bProxyBuffer)
                {
                    RtlCopyMemory(pvKM, kmpv, cjSize);
                }
                else if (!pumpdobj->bWOW64())
                {
                    __try
                    {
                        ProbeForRead(pv, cjSize, sizeof(BYTE));
                        RtlCopyMemory(pvKM, pv, cjSize);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                       WARNING ("fail to copy pv\n");
                       if (pvKM)
                           VFREEMEM(pvKM);
                       return NULL;
                    }
                }
            }
        }

        //
        // free the user mode copy
        //

        if (bIsFreeHooked(dhpdev, pumpdobj))
            UMPDMyDrvFree(pumpdobj, dhpdev, pv, *pid);

        //
        // we use the lower part of pifiKM pointer as the id,
        // to make sure no one is going to over-write any fields we returned
        //
        *pid = (ULONG)(ULONG_PTR)pvKM;
    }
    return pvKM;
}

LONG UMPDDrvQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )
{
    QUERYFONTDATAINPUT  Input;
    LONG                lRet;
    XUMPDOBJ            XUMObjs;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvQueryFontData;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        if (cjSize == 0)
            pv = NULL;

        Input.dhpdev = dhpdev;
        Input.pfo = pfo;
        Input.iMode = iMode;
        Input.hg = hg;
        Input.pgd = pgd;
        Input.pv = pv;
        Input.cjSize = cjSize;

        if (!pumpdobj->ThunkMemBlock((PVOID *) &Input.pgd, sizeof(GLYPHDATA)) ||
            !pumpdobj->ThunkMemBlock((PVOID *) &Input.pv, cjSize) ||
            !pumpdobj->pfo(&Input.pfo))
        {
            return FD_ERROR;
        }
        else
        {
            RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));

            UMPDReleaseRFONTSem(rfto, pumpdobj, NULL, NULL, NULL);

            if (pumpdobj->Thunk(&Input, sizeof(Input), &lRet, sizeof(lRet)) == 0xffffffff)
                lRet = FD_ERROR;

            UMPDAcquireRFONTSem(rfto, pumpdobj, 0, 0, NULL);
        }

        if ((lRet != FD_ERROR) && (pv != NULL))
            RtlCopyMemory(pv, pumpdobj->GetKernelPtr(Input.pv), cjSize);

        if ((lRet != FD_ERROR) && pgd)
            RtlCopyMemory(pgd, pumpdobj->GetKernelPtr(Input.pgd), sizeof(GLYPHDATA));

        return lRet;
    }
    else
    {
        return FD_ERROR;
    }
}

//
// DrvGetGlyphMode is only called from RFONTOBJ::bRealizeFont before the rfont semaphore is
// intialized, no need to release the rfont sem here
//
ULONG UMPDDrvGetGlyphMode(
    DHPDEV dhpdev,
    FONTOBJ *pfo
    )
{
    GETGLYPHMODEINPUT   Input;
    ULONG               ulRet;
    XUMPDOBJ            XUMObjs;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvGetGlyphMode;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.dhpdev = dhpdev;
        Input.pfo = pfo;

        if (!pumpdobj->pfo(&Input.pfo) ||
            pumpdobj->Thunk(&Input, sizeof(Input), &ulRet, sizeof(ULONG)) == 0xffffffff)
        {
            ulRet = FO_GLYPHBITS;
        }

        return (ulRet);
    }
    else
    {
        return(FO_GLYPHBITS);
    }
}

ULONG UMPDDrvFontManagement(
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG    iMode,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
    )
{
    FONTMANAGEMENTINPUT Input;
    ULONG               ulRet = 0xffffffff;
    XUMPDOBJ            XUMObjs;
    PVOID               pvBits, pvScan0;
    BOOL                bContinue = TRUE;
    BOOL                bSavePtr = FALSE, bLargeBitmap = FALSE;
    PUMPDOBJ            pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return 0xffffffff;

    if (pumpdobj->bWOW64() && iMode != QUERYESCSUPPORT && pso && pso->pvBits)
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, ulRet) + UMPD_SIZEFONTOBJ +
                             ALIGN_UMPD_BUFFER(cjIn) + ALIGN_UMPD_BUFFER(cjOut);

        bContinue = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr,
                                                &bLargeBitmap, &cjSizeNeed);
    }

    if (bContinue)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvFontManagement;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        if (cjIn == 0)
            pvIn = NULL;

        if (cjOut == 0)
            pvOut = NULL;

        if (iMode == QUERYESCSUPPORT)
        {
            Input.pso = NULL;
            Input.dhpdev = (DHPDEV) pso;
        }
        else
            Input.pso = pso;

        Input.pfo = pfo;
        Input.iMode = iMode;
        Input.cjIn = cjIn;
        Input.pvIn = pvIn;
        Input.cjOut = cjOut;
        Input.pvOut = pvOut;

        if ((pvOut && !(Input.pvOut = pumpdobj->AllocUserMemZ(cjOut))) ||
            !pumpdobj->psoDest(&Input.pso, bLargeBitmap) ||
            !pumpdobj->pfo(&Input.pfo) ||
            !pumpdobj->ThunkMemBlock(&Input.pvIn, cjIn))
        {
            ulRet = 0xffffffff;
        }
        else
        {
            RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));

            UMPDReleaseRFONTSem(rfto, pumpdobj, NULL, NULL, NULL);

            if (pumpdobj->Thunk(&Input, sizeof(Input), &ulRet, sizeof(ulRet)) == 0xffffffff)
                ulRet = 0xffffffff;

            UMPDAcquireRFONTSem(rfto, pumpdobj, 0, 0, NULL);

            if ((ulRet != 0xffffffff) && pvOut)
                RtlCopyMemory(pvOut, pumpdobj->GetKernelPtr(Input.pvOut), cjOut);
        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return (ulRet);
}


VOID UMPDDrvFree(
   PVOID   pv,
   ULONG   id)
{

    if (pv)
    {
       //
       // id field is used to keep pv value to make
       // sure pv/pid are returned from umpd
       //
       if (IS_SYSTEM_ADDRESS(pv) && (id == (ULONG)(ULONG_PTR)pv))
       {
           VFREEMEM(pv);
       }
       else
       {
          ASSERTGDI (id == (ULONG)(ULONG_PTR)pv, "UMPDDrvFree -- bad address passed in\n");
       }
    }
}


BOOL UMPDDrvQueryAdvanceWidths(
    DHPDEV   dhpdev,
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    PVOID    pvWidths,
    ULONG    cGlyphs
    )
{
    QUERYADVWIDTHSINPUT Input;
    BOOL                bRet;
    XUMPDOBJ            XUMObjs;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        if (phg == NULL || pvWidths == NULL)
        {
            WARNING("invalid parameter in UMPDDrvQueryAdvanceWidths\n");
            return FALSE;
        }

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvQueryAdvanceWidths;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.dhpdev = dhpdev;
        Input.pfo = pfo;
        Input.iMode = iMode;
        Input.phg = phg;
        Input.pvWidths = pvWidths;
        Input.cGlyphs = cGlyphs;

        if (!(Input.pvWidths = pumpdobj->AllocUserMemZ(sizeof(USHORT)*cGlyphs)) ||
            !pumpdobj->pfo(&Input.pfo) ||
            !pumpdobj->ThunkMemBlock((PVOID *) &Input.phg, sizeof(HGLYPH)*cGlyphs))
        {
            return FALSE;
        }
        else
        {
            // DrvQueryAdvancedWidth is called from NtGdiGetWidthTable with rfo lcok.

            RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));

            UMPDReleaseRFONTSem(rfto, pumpdobj, NULL, NULL, NULL);

            if (pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(bRet)) == 0xffffffff)
                bRet = FALSE;

            UMPDAcquireRFONTSem(rfto, pumpdobj, 0, 0, NULL);
        }

        RtlCopyMemory(pvWidths, pumpdobj->GetKernelPtr(Input.pvWidths), sizeof(USHORT)*cGlyphs);

        return (bRet);
    }
    else
    {
        return FALSE;
    }
}


//
//
// BOOL UMPDDrvBitBlt
//      UMPD DrvBitBlt thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvBitBlt
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvBitBlt(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMask,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    POINTL   *pptlMask,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    ROP4      rop4
    )
{
    DRVBITBLTINPUT Input;
    BOOL           bRet = TRUE;
    BOOL           bSaveTrg = FALSE, bSaveSrc = FALSE, bSaveMsk = FALSE;
    BOOL           bLargeTrg = FALSE, bLargeSrc = FALSE, bLargeMsk = FALSE;
    XUMPDOBJ       XUMObjs;
    PVOID          pvBitTrg, pvBitSrc, pvBitMsk;
    PVOID          pvScanTrg, pvScanSrc, pvScanMsk;
    PUMPDOBJ       pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEXLATEOBJ(pxlo) +
                             UMPD_SIZERECTL + 3 * UMPD_SIZEPOINTL + UMPD_SIZEBRUSHOBJ);

        bRet = pumpdobj->bThunkLargeBitmaps(psoTrg, psoSrc, psoMask,
                                            &pvBitTrg, &pvScanTrg,
                                            &pvBitSrc, &pvScanSrc,
                                            &pvBitMsk, &pvScanMsk,
                                            &bSaveTrg, &bLargeTrg,
                                            &bSaveSrc, &bLargeSrc,
                                            &bSaveMsk, &bLargeMsk,
                                            &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvBitBlt;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.psoTrg = psoTrg;
        Input.psoSrc = psoSrc;
        Input.psoMask = psoMask;
        Input.pco = pco;
        Input.pxlo = pxlo;
        Input.prclTrg = prclTrg;
        Input.pptlSrc = pptlSrc;
        Input.pptlMask = pptlMask;
        Input.pbo = pbo;
        Input.pptlBrush = pptlBrush;
        Input.rop4 = rop4;

        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeTrg) &&
               pumpdobj->psoSrc(&Input.psoSrc, bLargeSrc) &&
               pumpdobj->psoMask(&Input.psoMask, bLargeMsk) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkRECTL(&Input.prclTrg) &&
               pumpdobj->ThunkPOINTL(&Input.pptlSrc) &&
               pumpdobj->ThunkPOINTL(&Input.pptlMask) &&
               pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->ThunkPOINTL(&Input.pptlBrush) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoTrg, psoSrc, psoMask,
                                 pvBitTrg, pvScanTrg, pvBitSrc, pvScanSrc, pvBitMsk, pvScanMsk,
                                 bSaveTrg, bLargeTrg, bSaveSrc, bLargeSrc, bSaveMsk, bLargeMsk);
    }

    return bRet;
}

//
//
// BOOL UMPDDrvStretchBlt
//      UMPD DrvStretchBlt thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvStretchBlt
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    )
{
    DRVSTRETCHBLTINPUT Input;
    BOOL               bRet = TRUE;
    BOOL               bSaveDst = FALSE, bSaveSrc = FALSE, bSaveMsk = FALSE;
    BOOL               bLargeDst = FALSE, bLargeSrc = FALSE, bLargeMsk = FALSE;
    XUMPDOBJ           XUMObjs;
    PVOID              pvBitDst, pvBitSrc, pvBitMsk;
    PVOID              pvScanDst, pvScanSrc, pvScanMsk;
    PUMPDOBJ           pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEXLATEOBJ(pxlo) +
                             UMPD_SIZECOLORADJ + 2 * UMPD_SIZERECTL + 2 * UMPD_SIZEPOINTL);

        bRet = pumpdobj->bThunkLargeBitmaps(psoDest, psoSrc, psoMask,
                                            &pvBitDst, &pvScanDst,
                                            &pvBitSrc, &pvScanSrc,
                                            &pvBitMsk, &pvScanMsk,
                                            &bSaveDst, &bLargeDst,
                                            &bSaveSrc, &bLargeSrc,
                                            &bSaveMsk, &bLargeMsk,
                                            &cjSizeNeed);
    }

    if (bRet)
    {

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvStretchBlt;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.psoTrg = psoDest;
        Input.psoSrc = psoSrc;
        Input.psoMask = psoMask;
        Input.pco = pco;
        Input.pxlo = pxlo;
        Input.pca = pca;
        Input.pptlHTOrg = pptlHTOrg;
        Input.prclTrg = prclDest;
        Input.prclSrc = prclSrc;
        Input.pptlMask = pptlMask;
        Input.iMode = iMode;

        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeDst) &&
               pumpdobj->psoSrc(&Input.psoSrc, bLargeSrc) &&
               pumpdobj->psoMask(&Input.psoMask, bLargeMsk) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkCOLORADJUSTMENT(&Input.pca) &&
               pumpdobj->ThunkPOINTL(&Input.pptlHTOrg) &&
               pumpdobj->ThunkRECTL(&Input.prclTrg) &&
               pumpdobj->ThunkRECTL(&Input.prclSrc) &&
               pumpdobj->ThunkPOINTL(&Input.pptlMask) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoDest, psoSrc, psoMask,
                                 pvBitDst, pvScanDst, pvBitSrc, pvScanSrc, pvBitMsk, pvScanMsk,
                                 bSaveDst, bLargeDst, bSaveSrc, bLargeSrc, bSaveMsk, bLargeMsk);
    }

    return bRet;
}

//
//
// BOOL UMPDDrvStretchBltROP
//      UMPD DrvStretchBltROP thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvStretchBltROP
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

BOOL UMPDDrvStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    DWORD            rop4
    )
{
    DRVSTRETCHBLTINPUT Input;
    BOOL               bRet = TRUE;
    BOOL               bSaveDst = FALSE, bSaveSrc = FALSE, bSaveMsk = FALSE;
    BOOL               bLargeDst = FALSE, bLargeSrc = FALSE, bLargeMsk = FALSE;
    XUMPDOBJ           XUMObjs;
    PVOID              pvBitDst, pvBitSrc, pvBitMsk;
    PVOID              pvScanDst, pvScanSrc, pvScanMsk;
    PUMPDOBJ           pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEXLATEOBJ(pxlo) +
                             UMPD_SIZECOLORADJ + 2 * UMPD_SIZEPOINTL + 2 * UMPD_SIZERECTL + UMPD_SIZEBRUSHOBJ);

        bRet = pumpdobj->bThunkLargeBitmaps(psoDest, psoSrc, psoMask,
                                            &pvBitDst, &pvScanDst,
                                            &pvBitSrc, &pvScanSrc,
                                            &pvBitMsk, &pvScanMsk,
                                            &bSaveDst, &bLargeDst,
                                            &bSaveSrc, &bLargeSrc,
                                            &bSaveMsk, &bLargeMsk,
                                            &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvStretchBltROP;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.psoTrg = psoDest;
        Input.psoSrc = psoSrc;
        Input.psoMask = psoMask;
        Input.pco = pco;
        Input.pxlo = pxlo;
        Input.pca = pca;
        Input.pptlHTOrg = pptlHTOrg;
        Input.prclTrg = prclDest;
        Input.prclSrc = prclSrc;
        Input.pptlMask = pptlMask;
        Input.iMode = iMode;
        Input.pbo = pbo;
        Input.rop4 = rop4;

        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeDst)  &&
               pumpdobj->psoSrc(&Input.psoSrc, bLargeSrc)   &&
               pumpdobj->psoMask(&Input.psoMask, bLargeMsk) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkCOLORADJUSTMENT(&Input.pca) &&
               pumpdobj->ThunkPOINTL(&Input.pptlHTOrg) &&
               pumpdobj->ThunkRECTL(&Input.prclTrg) &&
               pumpdobj->ThunkRECTL(&Input.prclSrc) &&
               pumpdobj->ThunkPOINTL(&Input.pptlMask) &&
               pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoDest, psoSrc, psoMask,
                                 pvBitDst, pvScanDst, pvBitSrc, pvScanSrc, pvBitMsk, pvScanMsk,
                                 bSaveDst, bLargeDst, bSaveSrc, bLargeSrc, bSaveMsk, bLargeMsk);
    }

    return bRet;
}

BOOL UMPDDrvAlphaBlend(
    SURFOBJ       *psoDest,
    SURFOBJ       *psoSrc,
    CLIPOBJ       *pco,
    XLATEOBJ      *pxlo,
    RECTL         *prclDest,
    RECTL         *prclSrc,
    BLENDOBJ      *pBlendObj
    )
{
    ALPHAINPUT     Input;
    BOOL           bRet = TRUE;
    BOOL           bSaveDst = FALSE, bSaveSrc = FALSE;
    BOOL           bLargeDst = FALSE, bLargeSrc = FALSE;
    XUMPDOBJ       XUMObjs;
    PVOID          pvBitDst, pvBitSrc;
    PVOID          pvScanDst, pvScanSrc;
    PUMPDOBJ       pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEXLATEOBJ(pxlo) +
                             2 * UMPD_SIZERECTL + UMPD_SIZEBLENDOBJ);

        bRet = pumpdobj->bThunkLargeBitmaps(psoDest, psoSrc, NULL,
                                            &pvBitDst, &pvScanDst,
                                            &pvBitSrc, &pvScanSrc,
                                            NULL, NULL,
                                            &bSaveDst, &bLargeDst,
                                            &bSaveSrc, &bLargeSrc,
                                            NULL, NULL,
                                            &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvAlphaBlend;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.psoTrg = psoDest;
        Input.psoSrc = psoSrc;
        Input.pco = pco;
        Input.pxlo = pxlo;
        Input.prclDest = prclDest;
        Input.prclSrc = prclSrc;
        Input.pBlendObj = pBlendObj;

        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeDst) &&
               pumpdobj->psoSrc(&Input.psoSrc, bLargeSrc) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkRECTL(&Input.prclDest) &&
               pumpdobj->ThunkRECTL(&Input.prclSrc) &&
               pumpdobj->ThunkBLENDOBJ(&Input.pBlendObj) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoDest, psoSrc, NULL,
                                 pvBitDst, pvScanDst, pvBitSrc, pvScanSrc, NULL, NULL,
                                 bSaveDst, bLargeDst, bSaveSrc, bLargeSrc, FALSE, FALSE);
    }

    return bRet;
}

BOOL UMPDDrvGradientFill(
    SURFOBJ         *psoDest,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    TRIVERTEX       *pVertex,
    ULONG            nVertex,
    PVOID            pMesh,
    ULONG            nMesh,
    RECTL           *prclExtents,
    POINTL          *pptlDitherOrg,
    ULONG            ulMode
    )
{
    GRADIENTINPUT   Input;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    ULONG           cjMesh;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_DrvGradientFill;
    Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

    Input.psoTrg = psoDest;
    Input.pco = pco;
    Input.pxlo = pxlo;
    Input.pVertex = pVertex;
    Input.nVertex = nVertex;
    Input.pMesh = pMesh;
    Input.nMesh = nMesh;
    Input.prclExtents = prclExtents;
    Input.pptlDitherOrg = pptlDitherOrg;
    Input.ulMode = ulMode;

    //
    // Figure out the size of pMesh input buffer
    //

    switch (ulMode)
    {
    case GRADIENT_FILL_RECT_H:
    case GRADIENT_FILL_RECT_V:

        cjMesh = sizeof(GRADIENT_RECT);
        break;

    case GRADIENT_FILL_TRIANGLE:

        cjMesh = sizeof(GRADIENT_TRIANGLE);
        break;

    default:

        RIP("Invalid ulMode in DrvGradientFill\n");
        return FALSE;
    }

    cjMesh *= nMesh;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEXLATEOBJ(pxlo) +
                             ALIGN_UMPD_BUFFER(sizeof(TRIVERTEX)*nVertex) + ALIGN_UMPD_BUFFER(cjMesh) +
                             UMPD_SIZERECTL + UMPD_SIZEPOINTL);

        bRet = pumpdobj->bThunkLargeBitmap(psoDest, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeBitmap) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkMemBlock((PVOID *)&Input.pVertex, sizeof(TRIVERTEX)*nVertex) &&
               pumpdobj->ThunkMemBlock(&Input.pMesh, cjMesh) &&
               pumpdobj->ThunkRECTL(&Input.prclExtents) &&
               pumpdobj->ThunkPOINTL(&Input.pptlDitherOrg) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(psoDest, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

BOOL UMPDDrvTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      TransColor,
    UINT       ulReserved
)
{
    TRANSPARENTINPUT     Input;
    BOOL                 bRet = TRUE;
    BOOL                 bSaveDst = FALSE, bSaveSrc = FALSE;
    BOOL                 bLargeDst = FALSE, bLargeSrc = FALSE;
    XUMPDOBJ             XUMObjs;
    PVOID                pvBitDst, pvBitSrc, pvScanDst, pvScanSrc;
    PUMPDOBJ             pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ +
                             UMPD_SIZEXLATEOBJ(pxlo) + 2 * UMPD_SIZERECTL);

        bRet = pumpdobj->bThunkLargeBitmaps(psoDst, psoSrc, NULL,
                                            &pvBitDst, &pvScanDst,
                                            &pvBitSrc, &pvScanSrc,
                                            NULL, NULL,
                                            &bSaveDst, &bLargeDst,
                                            &bSaveSrc, &bLargeSrc,
                                            NULL, NULL,
                                            &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvTransparentBlt;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.psoTrg = psoDst;
        Input.psoSrc = psoSrc;
        Input.pco = pco;
        Input.pxlo = pxlo;
        Input.prclDst = prclDst;
        Input.prclSrc = prclSrc;
        Input.TransColor = TransColor;
        Input.ulReserved = ulReserved;

        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeDst) &&
               pumpdobj->psoSrc(&Input.psoSrc, bLargeSrc) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkRECTL(&Input.prclDst) &&
               pumpdobj->ThunkRECTL(&Input.prclSrc) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoDst, psoSrc, NULL,
                                 pvBitDst, pvScanDst, pvBitSrc, pvScanSrc, NULL, NULL,
                                 bSaveDst, bLargeDst, bSaveSrc, bLargeSrc, FALSE, FALSE);
    }

    return bRet;
}

//
//
// BOOL UMPDDrvCopyBits
//      UMPD DrvCopyBits thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvCopyBits
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvCopyBits(
    SURFOBJ  *psoDest,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDest,
    POINTL   *pptlSrc
    )
{
    DRVCOPYBITSINPUT Input;
    BOOL             bRet = TRUE;
    BOOL             bSaveDst = FALSE, bSaveSrc = FALSE;
    BOOL             bLargeDst = FALSE, bLargeSrc = FALSE;
    XUMPDOBJ         XUMObjs;
    PVOID            pvBitDst, pvBitSrc, pvScanDst, pvScanSrc;
    PUMPDOBJ         pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ +
                             UMPD_SIZEXLATEOBJ(pxlo) + UMPD_SIZERECTL + UMPD_SIZEPOINTL);

        bRet = pumpdobj->bThunkLargeBitmaps(psoDest, psoSrc, NULL,
                                            &pvBitDst, &pvScanDst,
                                            &pvBitSrc, &pvScanSrc,
                                            NULL, NULL,
                                            &bSaveDst, &bLargeDst,
                                            &bSaveSrc, &bLargeSrc,
                                            NULL, NULL,
                                            &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvCopyBits;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.psoTrg = psoDest;
        Input.psoSrc = psoSrc;
        Input.pco = pco;
        Input.pxlo = pxlo;
        Input.prclTrg = prclDest;
        Input.pptlSrc = pptlSrc;

        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeDst) &&
               pumpdobj->psoSrc(&Input.psoSrc, bLargeSrc)  &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkRECTL(&Input.prclTrg) &&
               pumpdobj->ThunkPOINTL(&Input.pptlSrc) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoDest, psoSrc, NULL,
                                 pvBitDst, pvScanDst, pvBitSrc, pvScanSrc, NULL, NULL,
                                 bSaveDst, bLargeDst, bSaveSrc, bLargeSrc, FALSE, FALSE);
    }

    return bRet;
}

//
//
// BOOL UMPDDrvTextOut
//      UMPD DrvTextOut thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvTextOut
//
// History:
//      8/14/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

BOOL UMPDDrvTextOut(
    SURFOBJ  *pso,
    STROBJ   *pstro,
    FONTOBJ  *pfo,
    CLIPOBJ  *pco,
    RECTL    *prclExtra,
    RECTL    *prclOpaque,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    POINTL   *pptlOrg,
    MIX       mix
    )
{
    TEXTOUTINPUT    Input;
    ULONG           cjprclExtra;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    //
    // find out the number of rclextra rectangles
    //

    if (prclExtra != (PRECTL) NULL)
    {
        RECTL *prcl;

        cjprclExtra = 1;
        prcl = prclExtra;

        while (prcl->left != prcl->right)
            cjprclExtra++, prcl++;

        cjprclExtra *= sizeof(RECTL);
    }
    else
        cjprclExtra = 0;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEFONTOBJ +
                             UMPD_SIZESTROBJ(pstro) + ALIGN_UMPD_BUFFER(cjprclExtra) +
                             UMPD_SIZERECTL + UMPD_SIZEPOINTL + 2 * UMPD_SIZEBRUSHOBJ;
        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_DrvTextOut;
    Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

    Input.pso = pso;
    Input.pstro = pstro;
    Input.pfo = pfo;
    Input.pco = pco;
    Input.prclExtra = prclExtra;
    Input.prclOpaque = prclOpaque;
    Input.pboFore = pboFore;
    Input.pboOpaque = pboOpaque;
    Input.pptlOrg = pptlOrg;
    Input.mix = mix;

    if (bRet)
    {
        if (pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
            pumpdobj->pstro(&Input.pstro) &&
            pumpdobj->pfo(&Input.pfo) &&
            pumpdobj->pco(&Input.pco) &&
            pumpdobj->ThunkMemBlock((PVOID *) &Input.prclExtra, cjprclExtra) &&
            pumpdobj->ThunkRECTL(&Input.prclOpaque) &&
            pumpdobj->pbo(&Input.pboFore) &&
            pumpdobj->pboFill(&Input.pboOpaque) &&
            pumpdobj->ThunkPOINTL(&Input.pptlOrg))
        {
            RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));

            UMPDReleaseRFONTSem(rfto, pumpdobj, NULL, NULL, NULL);

            if (pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) == 0xffffffff)
                bRet = FALSE;

            UMPDAcquireRFONTSem(rfto, pumpdobj, 0, 0, NULL);

        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}


//
//
// BOOL UMPDDrvLineTo
//      UMPD DrvLineTo thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvLineTo
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//



BOOL UMPDDrvLineTo(
    SURFOBJ   *pso,
    CLIPOBJ   *pco,
    BRUSHOBJ  *pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL     *prclBounds,
    MIX        mix
    )
{
    DRVLINETOINPUT Input;
    BOOL           bRet = TRUE;
    BOOL           bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ       XUMObjs;
    PVOID          pvBits, pvScan0;

    PUMPDOBJ       pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZERECTL + UMPD_SIZECLIPOBJ + UMPD_SIZEBRUSHOBJ;

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvLineTo;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.pco = pco;
        Input.pbo = pbo;
        Input.x1 = x1;
        Input.y1 = y1;
        Input.x2 = x2;
        Input.y2 = y2;
        Input.prclBounds = prclBounds;
        Input.mix = mix;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->ThunkRECTL(&Input.prclBounds) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
//
// BOOL UMPDDrvStrokePath
//      UMPD DrvStrokePath thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvStrokePath
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvStrokePath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pbo,
    POINTL    *pptlBrushOrg,
    LINEATTRS *plineattrs,
    MIX        mix
    )
{
    STORKEANDFILLINPUT Input;
    BOOL               bRet = TRUE;
    BOOL               bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ           XUMObjs;
    PVOID              pvBits, pvScan0;
    PUMPDOBJ           pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEPATHOBJ +
                             UMPD_SIZEXFORMOBJ + UMPD_SIZEBRUSHOBJ + UMPD_SIZEPOINTL + UMPD_SIZELINEATTRS(plineattrs);

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvStrokePath;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.ppo = ppo;
        Input.pco = pco;
        Input.pxo = pxo;
        Input.pbo = pbo;
        Input.pptlBrushOrg = pptlBrushOrg;
        Input.plineattrs = plineattrs;
        Input.mix = mix;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->ppo(&Input.ppo) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxo(&Input.pxo) &&
               pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->ThunkPOINTL(&Input.pptlBrushOrg) &&
               pumpdobj->ThunkLINEATTRS(&Input.plineattrs) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
//
// BOOL UMPDDrvFillPath
//      UMPD DrvFillPath thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvFillPath
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvFillPath(
    SURFOBJ  *pso,
    PATHOBJ  *ppo,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrushOrg,
    MIX       mix,
    FLONG     flOptions
    )
{
    STORKEANDFILLINPUT Input;
    BOOL               bRet = TRUE;
    BOOL               bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ           XUMObjs;
    PVOID              pvBits, pvScan0;
    PUMPDOBJ           pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZEPATHOBJ + UMPD_SIZECLIPOBJ +
                             UMPD_SIZEBRUSHOBJ + UMPD_SIZEPOINTL;
        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvFillPath;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.ppo = ppo;
        Input.pco = pco;
        Input.pbo = pbo;
        Input.pptlBrushOrg = pptlBrushOrg;
        Input.mix = mix;
        Input.flOptions = flOptions;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->ppo(&Input.ppo) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->ThunkPOINTL(&Input.pptlBrushOrg) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
// BOOL UMPDStrokeAndFillPath
//      UMPD DrvStrokeAndFillPath thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvStrokeAndFillPath
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvStrokeAndFillPath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pboStroke,
    LINEATTRS *plineattrs,
    BRUSHOBJ  *pboFill,
    POINTL    *pptlBrushOrg,
    MIX        mix,
    FLONG      flOptions
    )
{
    STORKEANDFILLINPUT Input;
    BOOL               bRet = TRUE;
    BOOL               bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ           XUMObjs;
    PVOID              pvBits, pvScan0;
    PUMPDOBJ           pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZEPATHOBJ + UMPD_SIZECLIPOBJ +
                             UMPD_SIZEXFORMOBJ + UMPD_SIZELINEATTRS(plineattrs) + 2 * UMPD_SIZEBRUSHOBJ + UMPD_SIZEPOINTL;
        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvStrokeAndFillPath;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.ppo = ppo;
        Input.pco = pco;
        Input.pxo = pxo;
        Input.pbo = pboStroke;
        Input.plineattrs = plineattrs;
        Input.pboFill = pboFill;
        Input.pptlBrushOrg = pptlBrushOrg;
        Input.mix = mix;
        Input.flOptions = flOptions;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->ppo(&Input.ppo) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxo(&Input.pxo) &&
               pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->ThunkLINEATTRS(&Input.plineattrs) &&
               pumpdobj->pboFill(&Input.pboFill) &&
               pumpdobj->ThunkPOINTL(&Input.pptlBrushOrg) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}


BOOL APIENTRY
UMPDDrvPaint(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix
    )

{
    STORKEANDFILLINPUT Input;
    BOOL               bRet = TRUE;
    BOOL               bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ           XUMObjs;
    PVOID              pvBits, pvScan0;
    PUMPDOBJ           pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
       return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEPOINTL + UMPD_SIZEBRUSHOBJ;

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvPaint;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.pco = pco;
        Input.pbo = pbo;
        Input.pptlBrushOrg = pptlBrushOrg;
        Input.mix = mix;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->ThunkPOINTL(&Input.pptlBrushOrg) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}


BOOL UMPDDrvQuerySpoolType(
    DHPDEV  dhpdev,
    LPWSTR  pwszDataType
    )
{
    WARNING("UMPDDrvQuerySpoolType not needed\n");
    return 0;
}


HANDLE UMPDDrvIcmCreateColorTransform(
    DHPDEV           dhpdev,
    LPLOGCOLORSPACEW pLogColorSpace,
    PVOID            pvSourceProfile,
    ULONG            cjSourceProfile,
    PVOID            pvDestProfile,
    ULONG            cjDestProfile,
    PVOID            pvTargetProfile,
    ULONG            cjTargetProfile,
    DWORD            dwReserved
    )
{
    DRVICMCREATECOLORINPUT    Input;
    HANDLE                    hRet;
    XUMPDOBJ                  XUMObjs;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvIcmCreateColorTransform;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.dhpdev = dhpdev;
        Input.pLogColorSpace = pLogColorSpace;
        Input.pvSourceProfile = pvSourceProfile;
        Input.cjSourceProfile = cjSourceProfile;
        Input.pvDestProfile = pvDestProfile;
        Input.cjDestProfile = cjDestProfile;
        Input.pvTargetProfile = pvTargetProfile;
        Input.cjTargetProfile = cjTargetProfile;
        Input.dwReserved = dwReserved;

        if (!pumpdobj->ThunkMemBlock((PVOID *) &Input.pLogColorSpace, sizeof(LOGCOLORSPACE)) ||
            !pumpdobj->ThunkMemBlock((PVOID *)&Input.pvSourceProfile, cjSourceProfile) ||
            !pumpdobj->ThunkMemBlock((PVOID *)&Input.pvDestProfile, cjDestProfile) ||
            !pumpdobj->ThunkMemBlock((PVOID *)&Input.pvTargetProfile, cjTargetProfile))
        {
            hRet = 0;
        }
        else
        {
            if (pumpdobj->Thunk(&Input, sizeof(Input), &hRet, sizeof(HANDLE)) == 0xffffffff)
                hRet = 0;
        }

        return (hRet);

    }
    else
    {
        return FALSE;
    }
}

BOOL UMPDDrvIcmDeleteColorTransform(
    DHPDEV dhpdev,
    HANDLE hcmXform
    )
{
    XUMPDOBJ               XUMObjs;
    DRVICMDELETECOLOR      Input;
    BOOL                   bRet;

    if(XUMObjs.bValid())
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvIcmDeleteColorTransform;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.dhpdev = dhpdev;
        Input.hcmXform = hcmXform;

        return XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }
    else
    {
        return FALSE;
    }
}

BOOL UMPDDrvIcmCheckBitmapBits(
    DHPDEV   dhpdev,
    HANDLE   hColorTransform,
    SURFOBJ *pso,
    PBYTE    paResults
    )
{
    DRVICMCHECKBITMAPINPUT Input;
    BOOL                   bRet = TRUE;
    BOOL                   bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ               XUMObjs;
    ULONG                  cjSize;
    PVOID                  pvBits, pvScan0;
    PUMPDOBJ               pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_DrvIcmCheckBitmapBits;
    Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

    Input.dhpdev = dhpdev;
    Input.hColorTransform = hColorTransform;
    Input.pso = pso;
    Input.paResults = paResults;

    //
    // Hideyuki says that paResults size is based on the number of pixels in pso,
    // one byte for each pixel
    //
    cjSize = pso->sizlBitmap.cx * pso->sizlBitmap.cy;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + ALIGN_UMPD_BUFFER(sizeof(BYTE) * cjSize);

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               (Input.paResults = (PBYTE)pumpdobj->AllocUserMemZ(sizeof(BYTE) * cjSize)) &&
               (pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff) &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}


BOOL UMPDEngFreeUserMem(KERNEL_PVOID pv)
{
    UMPDFREEMEMINPUT    Input;
    BOOL                bRet;
    XUMPDOBJ            XUMObjs;
    PUMPDOBJ            pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid() || !pumpdobj->bWOW64())
        return FALSE;

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_UMPDEngFreeUserMem;
    Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

    Input.pvTrg = pv;
    Input.pvSrc = NULL;
    Input.pvMsk = NULL;

    bRet = (pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff) && bRet;

    return bRet;
}
//
//
// gpUMDriverFunc
//      Our kernel mode thunk functions table.
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

PFN gpUMDriverFunc[INDEX_LAST] =
{
   (PFN)UMPDDrvEnablePDEV,
   (PFN)UMPDDrvCompletePDEV,
   (PFN)UMPDDrvDisablePDEV,
   (PFN)UMPDDrvEnableSurface,
   (PFN)UMPDDrvDisableSurface,
   (PFN)NULL,
   (PFN)NULL,
   (PFN)UMPDDrvResetPDEV,
   (PFN)UMPDDrvDisableDriver,
   (PFN)NULL,
   (PFN)UMPDDrvCreateDeviceBitmap,
   (PFN)UMPDDrvDeleteDeviceBitmap,
   (PFN)UMPDDrvRealizeBrush,
   (PFN)UMPDDrvDitherColor,
   (PFN)UMPDDrvStrokePath,
   (PFN)UMPDDrvFillPath,
   (PFN)UMPDDrvStrokeAndFillPath,
   (PFN)UMPDDrvPaint,
   (PFN)UMPDDrvBitBlt,
   (PFN)UMPDDrvCopyBits,
   (PFN)UMPDDrvStretchBlt,
   (PFN)NULL,
   (PFN)NULL, //UMPDDrvSetPalette,
   (PFN)UMPDDrvTextOut,
   (PFN)UMPDDrvEscape,
   (PFN)UMPDDrvDrawEscape,
   (PFN)UMPDDrvQueryFont,
   (PFN)UMPDDrvQueryFontTree,
   (PFN)UMPDDrvQueryFontData,
   (PFN)NULL, //UMPDDrvSetPointerShape,
   (PFN)NULL, //UMPDDrvMovePointer,
   (PFN)UMPDDrvLineTo,
   (PFN)UMPDDrvSendPage,
   (PFN)UMPDDrvStartPage,
   (PFN)UMPDDrvEndDoc,
   (PFN)UMPDDrvStartDoc,
   (PFN)NULL,
   (PFN)UMPDDrvGetGlyphMode,
   (PFN)NULL, //DrvSync
   (PFN)NULL,
   (PFN)NULL, //UMPDDrvSaveScreenBits
   (PFN)NULL,
   (PFN)UMPDDrvFree,
   (PFN)NULL, //UMPDDrvDestroyFont,
   (PFN)NULL, //UMPDDrvQueryFontCaps,
   (PFN)NULL, //UMPDDrvLoadFontFile,
   (PFN)NULL, //UMPDDrvUnloadFontFile,
   (PFN)UMPDDrvFontManagement,
   (PFN)NULL, //UMPDDrvQueryTrueTypeTable,
   (PFN)NULL, //UMPDDrvQueryTrueTypeOutline,
   (PFN)NULL, //UMPDDrvGetTrueTypeFile,
   (PFN)NULL, //UMPDDrvQueryFontFile,
   (PFN)NULL, //UMPDDrvMovePanning
   (PFN)UMPDDrvQueryAdvanceWidths,
   (PFN)NULL, //UMPDDrvSetPixelFormat,
   (PFN)NULL, //UMPDDrvDescribePixelFormat,
   (PFN)NULL, //UMPDDrvSwapBuffers,
   (PFN)UMPDDrvStartBanding,
   (PFN)UMPDDrvNextBand,
   (PFN)NULL, //UMPDDrvGetDirectDrawInfo,
   (PFN)NULL, //UMPDDrvEnableDirectDraw,
   (PFN)NULL, //UMPDDrvDisableDirectDraw,
   (PFN)UMPDDrvQuerySpoolType,
   (PFN)NULL, //UMPDDrvCreateLayerBitmap,
   (PFN)UMPDDrvIcmCreateColorTransform,
   (PFN)UMPDDrvIcmDeleteColorTransform,
   (PFN)UMPDDrvIcmCheckBitmapBits,
   (PFN)NULL, //UMPDDrvIcmSetDeviceGammaRamp,
   (PFN)UMPDDrvGradientFill,
   (PFN)UMPDDrvStretchBltROP,
   (PFN)UMPDDrvPlgBlt,
   (PFN)UMPDDrvAlphaBlend,
   (PFN)NULL, //UMPDDrvSynthesizeFont,
   (PFN)NULL, //UMPDDrvGetSynthesizedFontFiles,
   (PFN)UMPDDrvTransparentBlt,
   (PFN)UMPDDrvQueryPerBandInfo,
   (PFN)UMPDDrvQueryDeviceSupport,
};

#endif // !_GDIPLUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\umpd.cxx ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    umpd.cxx

Abstract:

    User-mode printer driver support

Environment:

    Windows NT 5.0

Revision History:

    07/8/97 -lingyunw-
        Created it.


--*/

#include "precomp.hxx"


#if !defined(_GDIPLUS_)

extern PFN gpUMDriverFunc[];

static const ULONG aiFuncRequired[] =
{
    INDEX_DrvEnablePDEV,
    INDEX_DrvCompletePDEV,
    INDEX_DrvDisablePDEV,
};


//
//                     ()---()
//                     / o o \
//                ___-(       )-___
// --------------(,,,----\_/----,,,)--------------------------------------
//                        O
//
// BOOL UMPD_ldevFillTable
//      Fill the ldev function dispatch table for user mode printer drivers
//
// Returns
//      BOOLEAN
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//
// -----------------------------------------------------------------------
//                    | |---| |
//                  _-+ |   | +-_
//                 (,,,/     \,,,)

UMPD_ldevFillTable(
    PLDEV   pldev,
    BOOL *  pbDrvFn)
{
    //
    // Put the UMPD kernel stubs in the function table.
    //

    ULONG  i;
    PFN   *ppfnTable = pldev->apfn;
    BOOL   bRet = TRUE;

    //
    // fill with zero pointers to avoid possibility of accessing
    // incorrect fields later
    //

    RtlZeroMemory(ppfnTable, INDEX_LAST*sizeof(PFN));

    //
    // Set UMPD thunk pointers in pldev->apfn.
    //

    for (i = 0; i < INDEX_LAST; i++)
    {
         if (pbDrvFn[i])
         {
             ppfnTable[i] = gpUMDriverFunc[i];
         }
    }

    if (bRet)
    {
       //
       // Check for required driver functions.
       //

       i = sizeof(aiFuncRequired) / sizeof(ULONG);
       while (i--)
       {
           if (ppfnTable[aiFuncRequired[i]] == (PFN) NULL)
           {
               ASSERTGDI(FALSE,"UMPDldevFillTable: a required function is missing from driver\n");
               return(FALSE);
           }
       }
    }

    //
    // Always hook up UMPDDRVFREE so we can free our kernel copies
    //
    ppfnTable[INDEX_DrvFree] = gpUMDriverFunc[INDEX_DrvFree];

    return(bRet);
}

//
//                     ()---()
//                     / o o \
//                ___-(       )-___
// --------------(,,,----\_/----,,,)--------------------------------------
//                        O
//
// BOOL UMPD_ldevLoadDriver
//      User mode printer drivers load driver routine.  Create a ldev and
//      fill up the function table.
//
// Returns
//      BOOLEAN
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//
// -----------------------------------------------------------------------
//                    | |---| |
//                  _-+ |   | +-_
//                 (,,,/     \,,,)

PLDEV
UMPD_ldevLoadDriver(
    LPWSTR pwszDriver,
    LDEVTYPE ldt)
{
    PLDEV pldev;
    PFN   *ppdrvfn;

    TRACE_INIT(("ldevLoadInternal ENTERING\n"));

    //
    // Allocate memory for the LDEV.
    //

    pldev = (PLDEV) EngAllocMem(FL_ZERO_MEMORY, sizeof(LDEV), UMPD_MEMORY_TAG);

    if (pldev)
    {
        //
        // Call the Enable entry point.
        //
        PVOID           umpdCookie;
        BOOL            bRet = FALSE;

        bRet =  UMPDDrvEnableDriver (pwszDriver, &umpdCookie);

        if (bRet)
        {
            //
            // fill info and apfn into pldev
            //
            pldev->pldevNext = NULL;
            pldev->pldevPrev = NULL;
            pldev->ldevType = ldt;
            pldev->cldevRefs = 1;
            pldev->pGdiDriverInfo = NULL;
            pldev->umpdCookie = umpdCookie;
            pldev->pid = (PW32PROCESS)W32GetCurrentProcess();

            BOOL    bDrvfn[INDEX_LAST];

            if(!UMPDDrvDriverFn(umpdCookie, bDrvfn))
            {
                WARNING("UMPD -- unable to get driver fn support\n");
                bRet = FALSE;
            }

            if(bRet)
            {
                bRet = UMPD_ldevFillTable(pldev, bDrvfn);
            }


        }

        if (!bRet)
        {
            EngFreeMem(pldev);
            pldev = NULL;
        }
    }

    return pldev;
}

PPORT_MESSAGE
PROXYPORT::InitMsg(
    PPROXYMSG       Msg,
    UM64_PVOID      pvIn,
    ULONG           cjIn,
    UM64_PVOID      pvOut,
    ULONG           cjOut
    )
{
    Msg->h.u1.s1.DataLength = (short) (sizeof(*Msg) - sizeof(Msg->h));
    Msg->h.u1.s1.TotalLength = (short) (sizeof(*Msg));

    Msg->h.u2.ZeroInit = 0;

    if(pvOut == NULL) cjOut = 0;

    Msg->cjIn = cjIn;
    Msg->pvIn = pvIn;
    
    Msg->cjOut = cjOut;
    Msg->pvOut = pvOut;

    return( (PPORT_MESSAGE)Msg );
}

BOOL
PROXYPORT::CheckMsg(
    NTSTATUS        Status,
    PPROXYMSG       Msg,
    UM64_PVOID      pvOut,
    ULONG           cjOut
    )
{
    ULONG       cbData = Msg->h.u1.s1.DataLength;

    if (cbData == (sizeof(*Msg) - sizeof(Msg->h)))
    {
        if(pvOut != Msg->pvOut)
        {
            return(FALSE);
        }

        if(cjOut != Msg->cjOut)
        {
            return(FALSE);
        }
    }
    else
    {
        return(FALSE);
    }

    return( TRUE );
}

NTSTATUS
PROXYPORT::SendRequest(
    UM64_PVOID      pvIn,
    ULONG           cjIn,
    UM64_PVOID      pvOut,
    ULONG           cjOut
    )
{
    NTSTATUS        Status;
    PROXYMSG        Request;
    PROXYMSG        Reply;

    InitMsg( &Request, pvIn, cjIn, pvOut, cjOut );
    
    Status = ZwRequestWaitReplyPort( pp->PortHandle,
                                     (PPORT_MESSAGE)&Request,
                                     (PPORT_MESSAGE)&Reply
                                   );

    if (!NT_SUCCESS( Status ))
    {
        return( Status );
    }

    if (Reply.h.u2.s2.Type == LPC_REPLY)
    {
        if (!CheckMsg( Status, &Reply, pvOut, cjOut ))
        {
            return(STATUS_UNSUCCESSFUL);
        }
    }
    else
    {
        return(STATUS_UNSUCCESSFUL);
    }

    return( Status );
}

UM64_PVOID
PROXYPORT::HeapAlloc(ULONG inSize)
{
    SSIZE_T ptr;

    if(pp->ClientMemoryAllocSize + inSize > pp->ClientMemorySize)
        return NULL;

    ptr = pp->ClientMemoryBase + (SSIZE_T)pp->ClientMemoryAllocSize + pp->ServerMemoryDelta;

    pp->ClientMemoryAllocSize += inSize;

    return (UM64_PVOID)ptr;
}


PROXYPORT::PROXYPORT(ULONGLONG inMaxSize)
{
    NTSTATUS                        Status;
    PORT_VIEW                       ClientView;
    ULONG                           MaxMessageLength;
    LARGE_INTEGER                   MaximumSize;
    UNICODE_STRING                  PortName;
    SECURITY_QUALITY_OF_SERVICE     DynamicQos;
    PROCESS_SESSION_INFORMATION     Info;
    WCHAR                           awcPortName[MAX_PATH] = {0};
    DWORD                           CurrSessionId;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    
    pp = NULL;

    if (NT_SUCCESS(Status = ZwQueryInformationProcess(NtCurrentProcess(),
                                       ProcessSessionInformation,
                                       &Info,
                                       sizeof(Info),
                                       NULL)))
    {
        CurrSessionId = Info.SessionId;
        swprintf(awcPortName, L"%s_%x",L"\\RPC Control\\UmpdProxy", CurrSessionId);
         
        DynamicQos.Length = 0;
        DynamicQos.ImpersonationLevel = SecurityImpersonation;
        DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        DynamicQos.EffectiveOnly = TRUE;
    
        pp = (ProxyPort *) PALLOCMEM(sizeof(ProxyPort), 'tppG');
    
        if(pp != NULL)
        {
            pp->ClientMemoryBase = 0;
            pp->ClientMemorySize = 0;
            pp->ClientMemoryAllocSize = 0;
            pp->PortHandle = NULL;
            pp->ServerMemoryBase = 0;
            pp->ServerMemoryDelta = 0;
            pp->hSecure = 0;
    
            Status = STATUS_SUCCESS;
    
            RtlInitUnicodeString( &PortName, awcPortName );
    
            MaximumSize.QuadPart = inMaxSize;
            ClientView.SectionHandle = 0;

            InitializeObjectAttributes(&ObjectAttributes,
                                       0,
                                       OBJ_KERNEL_HANDLE,
                                       0,
                                       0);

            Status = ZwCreateSection( &ClientView.SectionHandle,
                                      SECTION_MAP_READ | SECTION_MAP_WRITE,
                                      &ObjectAttributes,
                                      &MaximumSize,
                                      PAGE_READWRITE,
                                      SEC_COMMIT,
                                      NULL
                                    );
    
            if (NT_SUCCESS( Status ))
            {
                ClientView.Length = sizeof( ClientView );
                ClientView.SectionOffset = 0;
                ClientView.ViewSize = (LPC_SIZE_T) inMaxSize;
                ClientView.ViewBase = 0;
                ClientView.ViewRemoteBase = 0;
    
                Status = ZwConnectPort( &pp->PortHandle,
                                        &PortName,
                                        &DynamicQos,
                                        &ClientView,
                                        NULL,
                                        (PULONG)&MaxMessageLength,
                                        NULL,
                                        0
                                      );
    
                if (NT_SUCCESS( Status ))
                {

                    pp->hSecure = MmSecureVirtualMemory(ClientView.ViewBase, ClientView.ViewSize, PAGE_READWRITE);

                    if (pp->hSecure)
                    {
                        pp->SectionHandle = ClientView.SectionHandle;
                        pp->ClientMemoryBase = (SSIZE_T)ClientView.ViewBase;
                        pp->ClientMemorySize = ClientView.ViewSize;
                        pp->ServerMemoryBase = (SSIZE_T)ClientView.ViewRemoteBase;
                        pp->ServerMemoryDelta = pp->ServerMemoryBase - pp->ClientMemoryBase;
                    }
    
                }
                else
                {
                    WARNING("PROXYPORT::PROXYPORT failed to connect lpc port\n");
                }
            }
            else
            {
                WARNING("PROXYPORT::PROXYPORT failed to create section\n");
            }
    
            if(!NT_SUCCESS( Status ) || pp->hSecure == 0)
            {
                if (ClientView.SectionHandle)
                {
                    ZwClose(ClientView.SectionHandle);
                }

                if (pp->PortHandle)
                {
                    ZwClose( pp->PortHandle );
                }
                
                VFREEMEM(pp);
                pp = NULL;
            }
        }
    }
}

VOID
PROXYPORT::Close()
{
    ASSERTGDI(pp->PortHandle, "PROXYPORT::Close() invalid port handle\n");
    ASSERTGDI(pp->SectionHandle, "PROXYPORT::Close() invalid shared section handle\n");
    ASSERTGDI(pp->hSecure, "PROXYPORT::Close() invalid hSecure handle\n");
   
    if (pp->hSecure)
    {
        MmUnsecureVirtualMemory(pp->hSecure);
    }

    if (pp->SectionHandle)
    {
        if (!ZwClose(pp->SectionHandle))
        {
            WARNING("ZwClose failed to close the shred section handle in PROXYPORT::Close\n");
        }
    }

    if (pp->PortHandle != NULL)
    {
        if (!ZwClose( pp->PortHandle ))
        {
            WARNING("ZwClose failed to close the lpc port handle in PROXYPORT::Close\n");
        }
    }

    VFREEMEM(pp);
}

/*
BOOL UMPDReleaseRFONTSem()
   Used by umpd printing, releasing RFONT caching semaphores
*/

BOOL UMPDReleaseRFONTSem(
    RFONTOBJ& rfo,
    PUMPDOBJ pumpdobj,
    ULONG* pfl,
    ULONG* pnumLinks,
    BOOL** ppFaceLink
)
{
    BOOL bUMPDOBJ, *pFaceLink = NULL;
    ULONG numLinks = 0;

    if (!rfo.bValid())
        return FALSE;

    if (pumpdobj && pfl == NULL && pnumLinks == NULL && ppFaceLink == NULL)
    {
        bUMPDOBJ = TRUE;
    }
    else if (pumpdobj == NULL && pfl && pnumLinks && ppFaceLink)
    {
        bUMPDOBJ = FALSE;
        *pfl = 0;
        *pnumLinks = 0;
    }
    else
    {
        ASSERTGDI(0, "UMPD_ReleaseRFONTSem: it neither umpdobj nor TextOutDrvBitBlt\n");
        return FALSE;
    }

    if (rfo.prfnt->hsemEUDC)
    {
        GreAcquireSemaphore(rfo.prfnt->hsemEUDC);

        if (rfo.prfnt->prfntSystemTT && rfo.prfnt->prfntSystemTT->hsemCache &&
            GreIsSemaphoreOwnedByCurrentThread(rfo.prfnt->prfntSystemTT->hsemCache))
        {
            GreReleaseSemaphore(rfo.prfnt->prfntSystemTT->hsemCache);
            
            if (bUMPDOBJ)
                pumpdobj->vSetFlags(RELEASE_SYSTTFONT);
            else
                *pfl |= RELEASE_SYSTTFONT;
        }
        
        if (rfo.prfnt->prfntSysEUDC && rfo.prfnt->prfntSysEUDC->hsemCache &&
            GreIsSemaphoreOwnedByCurrentThread(rfo.prfnt->prfntSysEUDC->hsemCache))
        {
            GreReleaseSemaphore(rfo.prfnt->prfntSysEUDC->hsemCache);

            if (bUMPDOBJ)
                pumpdobj->vSetFlags(RELEASE_SYSEUDCFONT);
            else
                *pfl |= RELEASE_SYSEUDCFONT;
        }
                                                                                       
        if (rfo.prfnt->prfntDefEUDC && rfo.prfnt->prfntDefEUDC->hsemCache &&
            GreIsSemaphoreOwnedByCurrentThread(rfo.prfnt->prfntDefEUDC->hsemCache))
        {
            GreReleaseSemaphore(rfo.prfnt->prfntDefEUDC->hsemCache);
            
            if(bUMPDOBJ)
                pumpdobj->vSetFlags(RELEASE_DEFEUDCFONT);
            else
                *pfl |= RELEASE_DEFEUDCFONT;
        }
        
        if (numLinks = rfo.uiNumFaceNameLinks())
        {
            BOOL bContinue = FALSE;
            
            if (bUMPDOBJ)
            {
                bContinue = pumpdobj->bAllocFontLinks(numLinks);
            }
            else
            {
                pFaceLink = numLinks > UMPD_MAX_FONTFACELINK ?
                                            (BOOL*)PALLOCNOZ(sizeof(BOOL) * numLinks, UMPD_MEMORY_TAG) :
                                            *ppFaceLink;
                *ppFaceLink = pFaceLink;
                
                if (pFaceLink)
                {
                    bContinue = TRUE;
                    *pnumLinks = numLinks;
                    RtlZeroMemory(pFaceLink, sizeof(BOOL) * numLinks);
                }
            }

            if (bContinue)
            {
                for(ULONG ii = 0; ii < numLinks; ii++)
                {
                    if(rfo.prfnt->paprfntFaceName[ii] &&
                       rfo.prfnt->paprfntFaceName[ii]->hsemCache &&
                       GreIsSemaphoreOwnedByCurrentThread(rfo.prfnt->paprfntFaceName[ii]->hsemCache))
                    {
                        GreReleaseSemaphore(rfo.prfnt->paprfntFaceName[ii]->hsemCache);

                        if (bUMPDOBJ)
                            pumpdobj->vSetFontLink(ii);
                        else
                            pFaceLink[ii] = TRUE;
                    }
                }
            }
        }
        
        GreReleaseSemaphore(rfo.prfnt->hsemEUDC);
    }

    if (rfo.prfnt->hsemCache != NULL &&
        GreIsSemaphoreOwnedByCurrentThread(rfo.prfnt->hsemCache))
    {
        GreReleaseSemaphore(rfo.prfnt->hsemCache);
        
        if (bUMPDOBJ)
            pumpdobj->vSetFlags(RELEASE_BASEFONT);
        else
            *pfl |= RELEASE_BASEFONT;
    }

    return TRUE;
}

/*
VOID UMPDAcquireRFONTSem()
    Used by umpd printing, acquire all the RFONT caching semaphores.
*/

VOID  UMPDAcquireRFONTSem(
    RFONTOBJ&  rfo,
    PUMPDOBJ   pumpdobj,
    ULONG      fl,
    ULONG      numLinks,
    BOOL*      pFaceLink
)
{
    BOOL  bUMPDOBJ = FALSE;

    if (!rfo.bValid())
        return;

    if (pumpdobj)
    {
        bUMPDOBJ = TRUE;
        fl = pumpdobj->GetFlags();
        numLinks = pumpdobj->bLinkedFonts() ? pumpdobj->numLinkedFonts() : 0;
    }
    
    if ((fl & RELEASE_BASEFONT) && rfo.prfnt->hsemCache != NULL)
    {
        GreAcquireSemaphore(rfo.prfnt->hsemCache);
        if (bUMPDOBJ)
            pumpdobj->vClearFlags(RELEASE_BASEFONT);
    }

    if (rfo.prfnt->hsemEUDC)
    {
        GreAcquireSemaphore(rfo.prfnt->hsemEUDC);

        if ((fl & RELEASE_SYSTTFONT) && rfo.prfnt->prfntSystemTT)
        {
            GreAcquireSemaphore(rfo.prfnt->prfntSystemTT->hsemCache);
            if (bUMPDOBJ)
                pumpdobj->vClearFlags(RELEASE_SYSTTFONT);
        }
        
        if ((fl & RELEASE_SYSEUDCFONT) && rfo.prfnt->prfntSysEUDC)
        {
            GreAcquireSemaphore(rfo.prfnt->prfntSysEUDC->hsemCache);
            if (bUMPDOBJ)
                pumpdobj->vClearFlags(RELEASE_SYSEUDCFONT);
        }
        
        if ((fl & RELEASE_DEFEUDCFONT) && rfo.prfnt->prfntDefEUDC)
        {
            GreAcquireSemaphore(rfo.prfnt->prfntDefEUDC->hsemCache);
            if (bUMPDOBJ)
                pumpdobj->vClearFlags(RELEASE_DEFEUDCFONT);
        }
        
        if (numLinks)
        {
            BOOL bAcquire;

            numLinks =(numLinks > rfo.uiNumFaceNameLinks()) ? rfo.uiNumFaceNameLinks() : numLinks;

            for (ULONG ii = 0; ii < numLinks; ii++)
            {
                bAcquire = rfo.prfnt->paprfntFaceName[ii] &&
                           (bUMPDOBJ ? pumpdobj->bLinkedFont(ii) : pFaceLink[ii]);

                if (bAcquire)
                {
                    GreAcquireSemaphore(rfo.prfnt->paprfntFaceName[ii]->hsemCache);
                    if (bUMPDOBJ)
                        pumpdobj->vClearFontLink(ii);
                }
            }
        }

        GreReleaseSemaphore(rfo.prfnt->hsemEUDC);
    }
}


VOID TextOutBitBlt(
    SURFACE     *pSurf,
    RFONTOBJ&   rfo,
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoMask,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    RECTL       *prclTrg,
    POINTL      *pptlSrc,
    POINTL      *pptlMask,
    BRUSHOBJ    *pbo,
    POINTL      *pptlBrush,
    ROP4        rop4
)
{
    BOOL bSem = FALSE;
    ULONG fl = 0, numLinks = 0;
    BOOL  aFaceLink[UMPD_MAX_FONTFACELINK], *pFaceLink = aFaceLink;
    
    //
    // Release rfont semaphores, otherwise holding rfont semaphores can
    // disable APC queue while calling to the user mode.
    //

    //
    //  WINBUG #214225 tessiew 10-27-2000 Blackcomb: re-visit the RFONT.hsemCache acquiring/releasing issue
    // Need to revisit the font semaphore problem in Blackcomb
    //  It seems that a thread doesn't need to hold the font caching semaphore
    //  during the whole GreExtTextOutWLocked call.
    //

    PDEVOBJ po(pSurf->hdev());
    
    if (po.bPrinter() && po.bUMPD() && rfo.bValid())
    {
        bSem = UMPDReleaseRFONTSem(rfo, NULL, &fl, &numLinks, &pFaceLink);
    }
    
    // call driver BitBlt

    (*(pSurf->pfnBitBlt())) (pSurf->pSurfobj(),
                             psoSrc,
                             psoMask,
                             pco,
                             pxlo,
                             prclTrg,
                             pptlSrc,
                             pptlMask,
                             pbo,
                             pptlBrush,
                             rop4);
    
    // acquire the font semaphore(s)

    if (bSem)
    {
        UMPDAcquireRFONTSem(rfo, NULL, fl, numLinks, pFaceLink);
        
        if (pFaceLink && pFaceLink != aFaceLink)
        {
            VFREEMEM(pFaceLink);
        }        
    }
}

BOOL GetETMFontManagement(
    RFONTOBJ& rfo,
    PDEVOBJ pdo,
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
)
{
    BOOL bRet;
    BOOL bSem = FALSE;

    ULONG fl = 0, numLinks = 0;
    BOOL  aFaceLink[UMPD_MAX_FONTFACELINK], *pFaceLink = aFaceLink;
    
    //
    // Release rfont semaphores, otherwise holding rfont semaphores can
    // disable APC queue while calling to the user mode.
    //

    //
    //  WINBUG #214225 tessiew 10-27-2000 Blackcomb: re-visit the RFONT.hsemCache acquiring/releasing issue
    // Need to revisit the font semaphore problem in Blackcomb
    //  It seems that a thread doesn't need to hold the font caching semaphore
    //  during the whole GreExtTextOutWLocked call.
    
    if (pdo.bPrinter() && pdo.bUMPD() && rfo.bValid())
    {
        bSem = UMPDReleaseRFONTSem(rfo, NULL, &fl, &numLinks, &pFaceLink);
    }
    
    bRet = pdo.FontManagement(pso,
                              pfo,
                              iEsc,
                              cjIn,
                              pvIn,
                              cjOut,
                              pvOut);

    // acquire the font semaphore(s)

    if (bSem)
    {
        UMPDAcquireRFONTSem(rfo, NULL, fl, numLinks, pFaceLink);
        
        if (pFaceLink && pFaceLink != aFaceLink)
        {
            VFREEMEM(pFaceLink);
        }        
    }
    
    return bRet;
}

#else // _GDIPLUS_

extern "C" PUMPD UMPDDrvEnableDriver(PWSTR, ULONG);

PLDEV
UMPD_ldevLoadDriver(
    PWSTR pwszDriver,
    LDEVTYPE ldt
    )

{
    PLDEV   pldev = NULL;
    PUMPD   pUMPD;

    if ((pUMPD = UMPDDrvEnableDriver(pwszDriver, DDI_DRIVER_VERSION_NT5_01_SP1)) &&
        (pldev = (PLDEV) PALLOCMEM(sizeof(LDEV), UMPD_MEMORY_TAG)))
    {
        pldev->pldevNext = (PLDEV)pUMPD;
        pldev->pldevPrev = NULL;
        pldev->ldevType = ldt;
        pldev->cldevRefs = 1;
        pldev->pGdiDriverInfo = NULL;

        RtlCopyMemory(pldev->apfn, pUMPD->apfn, sizeof(pldev->apfn));

        return pldev;
    }
    else
    {
        if (pldev)
            VFREEMEM(pldev);

        return NULL;
    }
}

#endif // _GDIPLUS_


VOID UMPD_ldevUnloadImage(PLDEV pldev)
{
    if (pldev)
        EngFreeMem(pldev);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\umpdeng.cxx ===
/******************************Module*Header*******************************\
* Module Name: umpdeng.c
*   This file contains stubs for calls made by umpdeng.c from gdi32.dll
*
* Created: 8/5/97
* Author:  Lingyun Wang [lingyunw]
*
* Copyright (c) 1997-1999 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

#if !defined(_GDIPLUS_)

//
// Macro for extracting the topmost UMPDOBJS structure
// associated with the current thread.
//
// Put the following line at the beginning of each NtGdi...
// function (after all other local variable declarations):
//
//  EXTRACT_THREAD_UMPDOBJS retVal;
//
// where retVal is the error return value. If the function doesn't return
// any value, simply omit the retVal.
//

#define EXTRACT_THREAD_UMPDOBJS \
        PUMPDOBJ pUMObjs = (PUMPDOBJ) W32GetCurrentThread()->pUMPDObj; \
        if (pUMObjs)                                                   \
            pUMObjs->vSetFlags(UMPDOBJ_ENGCALL);                       \
        else                                                           \
            return

#define FIXUP_THREAD_UMPDOBJS   \
        if (pUMObjs)                                                   \
            pUMObjs->vClearFlags(UMPDOBJ_ENGCALL);


//
// determine whether a BRUSHOBJ is a pattern brush
//

#define ISPATBRUSH(_pbo) ((_pbo) && (_pbo)->iSolidColor == 0xffffffff)
#define MIXNEEDMASK(_mix) (((_mix) & 0xf) != (((_mix) >> 8) & 0xf))

//
// Map a user-mode BRUSHOBJ to its kernel-mode counterpart
//

#define MAP_UM_BRUSHOBJ(pUMObjs, pbo, pboTemp) \
        { \
            BRUSHOBJ   *tempVar; \
            tempVar = (pUMObjs)->GetDDIOBJ(pbo); \
            pbo = tempVar ? tempVar : CaptureAndFakeBRUSHOBJ(pbo, pboTemp); \
        }

inline BOOL
PROBEDISPATBRUSH(BRUSHOBJ *pbo)
{
    BRUSHOBJ tmpBo;
    BOOL bRet = FALSE;
    __try
    {
        tmpBo = ProbeAndReadStructure(pbo, BRUSHOBJ);
        if (ISPATBRUSH(&tmpBo))
            bRet = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return bRet;
}
            
//
// "Manufacture" a kernel-mode BRUSHOBJ structure using
// the user-mode BRUSHOBJ as template
//

BRUSHOBJ *
CaptureAndFakeBRUSHOBJ(
    BRUSHOBJ   *pboUm,
    BRUSHOBJ   *pboKm
    )

{
    if (pboUm)
    {
        __try
        {
            // Copy user-mode BRUSHOBJ structure into kernel-mode memory

            *pboKm = ProbeAndReadStructure(pboUm, BRUSHOBJ);

            // Succeed only if BRUSHOBJ represents a solid color brush

            if (!ISPATBRUSH(pboKm))
                pboKm->pvRbrush = NULL;
            else
                pboKm = NULL;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            pboKm = NULL;
        }
    }
    else
        pboKm = NULL;

    return pboKm;
}


//
// Capture a user-mode CLIPOBJ that orignated from EngCreateClip
//

CLIPOBJ *
CaptureAndMungeCLIPOBJ(
    CLIPOBJ *pcoUm,
    CLIPOBJ *pcoKm,
    SIZEL   *szLimit
    )

{
    CLIPOBJ co;

    //
    // Capture user-mode CLIPOBJ structure into a temporary buffer
    //

    if (pcoUm)
    {
        __try
        {
            co = ProbeAndReadStructure(pcoUm, CLIPOBJ);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            pcoKm = NULL;
        }

        //
        // Munge the relevant fields in kernel-mode CLIPOBJ
        //

        if (pcoKm)
        {
            switch (co.iDComplexity)
            {
            case DC_RECT:

                if (szLimit)
                {
                    co.rclBounds.left = max(0, co.rclBounds.left);
                    co.rclBounds.top = max(0, co.rclBounds.top);
                    co.rclBounds.right = min(szLimit->cx, co.rclBounds.right);
                    co.rclBounds.bottom = min(szLimit->cy, co.rclBounds.bottom);
                }

                pcoKm->rclBounds = co.rclBounds;

                // fall through

            case DC_TRIVIAL:

                pcoKm->iDComplexity = co.iDComplexity;
                break;

            default:

                WARNING("User-mode CLIPOBJ is not DC_TRIVIAL or DC_RECT\n");
                pcoKm = NULL;
                break;
            }
        }
    }
    else
    {
        ASSERTGDI(pcoKm == NULL, "CaptureAndMungeCLIPOBJ: invalid pcoKm\n");
    }

    return pcoKm;
}


/******************************Public*Routine******************************\
* GetSTROBJGlyphMode
*
* helper function to determine the Glyphmode based on strobj
*
* History:
*  26-Sept-1997 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
__inline
ULONG GetSTROBJGlyphMode (STROBJ *pstro)
{
      return (((ESTROBJ*)pstro)->prfo->prfnt->ulContent);
}

__inline
BOOL bOrder (RECTL *prcl)
{
    return ((prcl->left < prcl->right) && (prcl->top < prcl->bottom));
}

/******************************Public*Routine******************************\
* helper functions to copy user memory
*
* CaptureRECTL CapturePOINTL  CapturePOINTFIX
* CaptureLINEATTRS  CaptureCOLORADJUSTMENT
*
* Note: prclFrom points to the captured rect on the way back
* Note: Needs to be called within try/except
*
* History:
*  26-Sept-1997 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
__inline
VOID CaptureRECTL (RECTL **pprclFrom, RECTL *prclTo)
{
    if (*pprclFrom)
    {
        *prclTo = ProbeAndReadStructure(*pprclFrom,RECTL);

        //
        // repoint pprclFrom to prclTo
        //
        *pprclFrom = prclTo;
    }

    return;
}

__inline
VOID CapturePOINTL (POINTL **ppptlFrom, POINTL *pptlTo)
{
    if (*ppptlFrom)
    {
        *pptlTo = ProbeAndReadStructure(*ppptlFrom,POINTL);

        *ppptlFrom = pptlTo;
    }
    return;
}

__inline
VOID CapturePOINTFIX (POINTFIX **ppptfxFrom, POINTFIX *pptfxTo)
{
    if (*ppptfxFrom)
    {
       *pptfxTo = ProbeAndReadStructure(*ppptfxFrom,POINTFIX);

       *ppptfxFrom = pptfxTo;
    }

    return;
}

//
// the calling routine needs to free pStyle
//
// Note: plineFrom will be changed to plineTo upon returning from this routine
// so to save some changes into the lower level calls
//
__inline
BOOL bCaptureLINEATTRS (LINEATTRS **pplineFrom, LINEATTRS *plineTo)
{
    BOOL bRet = TRUE;

    if (*pplineFrom)
    {
        PFLOAT_LONG pstyle = NULL;

        __try
        {

          *plineTo = ProbeAndReadStructure(*pplineFrom,LINEATTRS);

          if (plineTo->pstyle)
          {
              if (BALLOC_OVERFLOW1(plineTo->cstyle, FLOAT_LONG))
                  return FALSE;

              ProbeForRead(plineTo->pstyle, plineTo->cstyle*sizeof(FLOAT_LONG), sizeof(BYTE));

              pstyle = (PFLOAT_LONG)PALLOCNOZ(plineTo->cstyle*sizeof(FLOAT_LONG), UMPD_MEMORY_TAG);

              if (!pstyle)
              {
                  //
                  // so we won't free it later
                  //
                  plineTo->pstyle = NULL;
                  bRet = FALSE;
              }
              else
              {
                 RtlCopyMemory(pstyle, plineTo->pstyle, plineTo->cstyle*sizeof(FLOAT_LONG));

                 plineTo->pstyle = pstyle;
              }
          }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING ("bCaptureLINEATTRS -- exception in try/except \n");

            if (pstyle)
                VFREEMEM(pstyle);

            bRet = FALSE;
        }

       *pplineFrom = plineTo;
    }

    return bRet;
}

__inline
VOID CaptureCOLORADJUSTMENT (COLORADJUSTMENT **ppcaFrom, COLORADJUSTMENT *pcaTo)
{
    if (*ppcaFrom)
    {
       *pcaTo = ProbeAndReadStructure(*ppcaFrom,COLORADJUSTMENT);

       *ppcaFrom = pcaTo;
    }

    return;
}

__inline
VOID CaptureDWORD (DWORD **ppdwFrom, DWORD *pdwTo)
{
    if (*ppdwFrom)
    {
        *pdwTo = ProbeAndReadStructure(*ppdwFrom,DWORD);

        //
        // repoint pprclFrom to prclTo
        //
        *ppdwFrom = pdwTo;
    }
    return;
}

__inline
VOID CaptureBits (PVOID pv, PVOID pvTmp, ULONG cj)
{
     if (pv && pvTmp)
     {
         ProbeAndReadBuffer(pv, pvTmp, cj);
     }
     return;
}

/******************************Public*Routine******************************\
* bSecureBits bSafeReadBits bSafeCopyBits
*
* helper functions to secure or copy user memory
* These donot need to be called from within try/except
*
* History:
*  26-Sept-1997 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
__inline
BOOL bSecureBits (PVOID pv, ULONG cj, HANDLE *phSecure)
{
    BOOL bRet = TRUE;

    *phSecure = 0;

    if (pv)
    {
        __try
        {
            ProbeForRead(pv,cj,sizeof(BYTE));
            *phSecure = MmSecureVirtualMemory(pv, cj, PAGE_READONLY);

            if (*phSecure == 0)
            {
                bRet = FALSE;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING ("bSecureBits -- exception in try/except \n");
            bRet = FALSE;
        }
    }

    return (bRet);
}

__inline
BOOL bSafeCopyBits (PVOID pv, PVOID pvTmp, ULONG cj)
{
     BOOL bRet = TRUE;

     if (pv && pvTmp)
     {
        __try
        {
            ProbeAndWriteBuffer(pv, pvTmp, cj);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING ("fail in try/except to write into buffer\n");
            bRet = FALSE;
        }

     }
     return bRet;
}

__inline
BOOL bSafeReadBits (PVOID pv, PVOID pvTmp, ULONG cj)
{
     BOOL bRet = TRUE;

     if (pv && pvTmp)
     {
        __try
        {
            ProbeAndReadBuffer(pv, pvTmp, cj);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING ("fail in try/except to read from buffer\n");
            bRet = FALSE;
        }
     }
     return bRet;
}




/******************************Public*Routine******************************\
* bCheckSurfaceRect bCheckSurfaceRectSize
*
* Check rect and pco against the surface, make sure we are not going to
* draw outside the surface
*
* bCheckSurfacePath
*
* Check the path against the surface, make sure not going to draw outside
* the surface
*
* bCheckSurfacePoint
*
* Check the point against the surface
*
* History:
*  26-Sept-1997 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

__inline
BOOL bCheckSurfaceRect(SURFOBJ *pso, RECTL *prcl, CLIPOBJ *pco)
{
    BOOL bRet = TRUE;
    BOOL bTrivial;

    if (pso)
    {
       if (pco)
       {
          bTrivial = (pco->iDComplexity == DC_TRIVIAL) ? TRUE : FALSE;
       }
       else
       {
          bTrivial = TRUE;
       }

       //
       // if no clipping, check against the rectangle.
       //
       if (!bTrivial)
       {
           //
           // there is clipping invloved, check against pco->rclBounds.
           //
           prcl = &(pco->rclBounds);
       }

       if (prcl)
       {
          if ((prcl->left > prcl->right) || (prcl->top > prcl->bottom))
          {
              WARNING ("prcl not well ordered, returing failure\n");
              bRet = FALSE;
          }

          if (bRet && ((prcl->right > pso->sizlBitmap.cx) || (prcl->left < 0)||
              (prcl->bottom > pso->sizlBitmap.cy)|| (prcl->top < 0)))
          {
              WARNING ("we might draw outside the surface, returning failure\n");
              bRet = FALSE;
          }
       }
    }

    return bRet;
}


__inline
BOOL bCheckSurfaceRectSize(SURFOBJ *pso, RECTL *prcl, CLIPOBJ *pco,
                   ULONG *pcx, ULONG *pcy, BOOL bOrder = TRUE)
{
    BOOL bRet = TRUE;
    BOOL bTrivial;
    ERECTL rcl(0, 0, 0, 0);
    PRECTL prclBounds = NULL;

    if (pso)
    {
       if (pco)
       {
          bTrivial = (pco->iDComplexity == DC_TRIVIAL) ? TRUE : FALSE;
       }
       else
       {
          bTrivial = TRUE;
       }

       //
       // if no clipping, check against the rectangle.
       //
       if (!bTrivial)
       {
           //
           // there is clipping invloved, check against pco->rclBounds.
           //
           prclBounds = &(pco->rclBounds);
           rcl = *prclBounds;
       }
       else
       {
           if (prcl)
           {
               rcl = *prcl;
           }
       }

       //
       // check the rectangle
       //
       if (bOrder && ((rcl.left > rcl.right) || (rcl.top > rcl.bottom)))
       {
           WARNING ("rcl not well ordered, returing failure\n");
           return FALSE;
       }

       //
       // check that we are not going outside the surface
       //
       if ((rcl.right > pso->sizlBitmap.cx) || (rcl.left < 0)||
           (rcl.bottom > pso->sizlBitmap.cy)|| (rcl.top < 0))
       {
           WARNING ("we might draw outside the surface, returning failure\n");
           return FALSE;
       }

       //
       // figure out the size
       //
       if (prclBounds && prcl)
       {
           RECTL rclIntersect;

           rclIntersect.left = MAX(prclBounds->left, prcl->left);
           rclIntersect.right = MIN(prclBounds->right, prcl->right);
           rclIntersect.top = MAX(prclBounds->top, prcl->top);
           rclIntersect.bottom = MAX(prclBounds->bottom, prcl->bottom);

           *pcx = (rclIntersect.right - rclIntersect.left) > 0 ?
                  rclIntersect.right - rclIntersect.left : 0;

           *pcy = (rclIntersect.bottom - rclIntersect.top) > 0 ?
                   rclIntersect.bottom - rclIntersect.top : 0 ;
        }
        else if (prcl)
        {
            *pcx = (prcl->right - prcl->left) > 0 ?
                    prcl->right - prcl->left : 0;
            *pcy = (prcl->bottom - prcl->top) > 0 ?
                    prcl->bottom - prcl->top : 0;
        }
        else if (prclBounds)
        {
            *pcx = (prclBounds->right - prclBounds->left) > 0 ?
                    prclBounds->right - prclBounds->left : 0;
            *pcy = (prclBounds->bottom - prclBounds->top) > 0 ?
                    prclBounds->bottom - prclBounds->top : 0;

        }
    }

    return bRet;
}

__inline
BOOL bCheckDestSurfaceOverlap(SURFOBJ *pso, RECTL* prcl)
{
    ERECTL ercl = *prcl;

    // If we need to mirror do it. 
    if (ercl.bottom < ercl.top)
    {
        LONG lTemp = ercl.top;
        ercl.top = ercl.bottom;
        ercl.bottom = lTemp;
    }
    if (ercl.right < ercl.left)
    {
        LONG lTemp = ercl.left;
        ercl.left = ercl.right;
        ercl.right = lTemp;
    }

    ERECTL erclTrg(0, 0, pso->sizlBitmap.cx, pso->sizlBitmap.cy);

    ercl *= erclTrg;

    if (ercl.bEmpty())
        return(FALSE);

    return(TRUE);
}

__inline
BOOL bCheckSurfacePath(SURFOBJ *pso, PATHOBJ *ppo, CLIPOBJ *pco)
{
    BOOL bRet = TRUE;
    BOOL bTrivial;
    RECTL *prcl;

    if (pso && ppo)
    {
       if (pco)
       {
          bTrivial = (pco->iDComplexity == DC_TRIVIAL) ? TRUE : FALSE;
       }
       else
       {
          bTrivial = TRUE;
       }

       if (bTrivial)
       {
          //
          // no clipping, check against ppo->rcfxBoundBox.
          //
          RECTFX rcfx;

          rcfx = ((EPATHOBJ *)ppo)->ppath->rcfxBoundBox;

          prcl = (RECTL *)&rcfx;

          prcl->left = FXTOL(rcfx.xLeft);
          prcl->top = FXTOL(rcfx.yTop);
          prcl->right = FXTOL(rcfx.xRight);
          prcl->bottom = FXTOL(rcfx.yBottom);
       }
       else
       {
           //
           // there is clipping invloved, check against pco->rclBounds.
           //
           prcl = &(pco->rclBounds);
       }

       if (prcl)
       {
          if ((prcl->left > prcl->right) || (prcl->top > prcl->bottom))
          {
              WARNING ("prcl not well ordered, returing failure\n");
              bRet = FALSE;
          }

          if (bRet && (prcl->right > pso->sizlBitmap.cx) || (prcl->left < 0) ||
              (prcl->bottom > pso->sizlBitmap.cy)|| (prcl->top < 0))
          {
              bRet = FALSE;
          }
       }
    }
    else
    {
        WARNING("bCheckSurfacePath either pso or ppo is NULL\n");
        bRet = FALSE;
    }

    return bRet;
}

__inline
BOOL bCheckSurfacePoint(SURFOBJ *pso, POINTL *ptl)
{
    BOOL bRet = TRUE;

    if (pso && ptl)
    {
       if ((pso->sizlBitmap.cx < ptl->x) || (ptl->x < 0) ||
           (pso->sizlBitmap.cy < ptl->y)|| (ptl->y < 0))
       {
           bRet = FALSE;
       }
    }

    return bRet;
}

__inline
BOOL bCheckMask(SURFOBJ *psoMask, RECTL *prcl)
{
    BOOL bRet = TRUE;

    if (psoMask)
    {
       if (psoMask->iBitmapFormat != BMF_1BPP)
           bRet = FALSE;

       if (bRet)
           bRet = bCheckSurfaceRect(psoMask, prcl, NULL);
    }

    return bRet;
}

//
// Make sure the we are not going to access pulXlate when there is no one
// Any other checks on xlateobj?
//
__inline
BOOL bCheckXlate(SURFOBJ *pso, XLATEOBJ *pxlo)
{
    BOOL bRet = TRUE;

    if (pso)
    {
       if (pxlo && !(pxlo->flXlate & XO_TRIVIAL))
       {
           switch (pso->iBitmapFormat)
           {
               case BMF_1BPP:
               {
                   bRet = (pxlo->cEntries == 2) ? TRUE : FALSE;
                   break;
               }

               case BMF_4BPP:
               {
                   //we can have a halftone palette of 8 entries
                   bRet = ((pxlo->cEntries == 16) || (pxlo->cEntries == 8)) ? TRUE : FALSE;
                   break;
               }

               case BMF_8BPP:
               {
                   // halftone palette can be any combination
                   bRet = (pxlo->cEntries <= 256) ? TRUE : FALSE;
                   break;
               }
           }
       }
    }

    return bRet;
}


__inline
PRECTL pRect(POINTL *pptl, RECTL *prcl, ULONG cx, ULONG cy)
{
    PRECTL prclRet;

    if (pptl)
    {
       prcl->left = pptl->x;
       prcl->right = pptl->x + cx;
       prcl->top = pptl->y;
       prcl->bottom = pptl->y + cy;
       prclRet = prcl;
    }
    else
    {
       prclRet = NULL;
    }

    return prclRet;
}


//
// check the order of a rectangle
//
__inline
BOOL bCheckRect(RECTL *prcl)
{
    BOOL bRet = TRUE;

    if (prcl)
    {
       if ((prcl->left > prcl->right) || (prcl->top > prcl->bottom))
       {
           WARNING ("prcl not well ordered, returing failure\n");
           bRet = FALSE;
       }
    }

    return bRet;
}

//
// Validate an HSURF and make sure it refers to a UMPD surface
//

__inline BOOL
ValidUmpdHsurf(
    HSURF   hsurf
    )

{
    SURFREF so(hsurf);

    //
    // Make sure hsurf is valid and it refers to a UMPD surface
    //

    return (so.bValid() && so.ps->bUMPD());
}

//
// Validate an HSURF and Unsecure hSecure
//

__inline BOOL
ValidUmpdHsurfAndUnSecure(
    HSURF   hsurf
    )

{
    SURFREF so(hsurf);

    //
    // Make sure hsurf is valid and it refers to a UMPD surface
    //

    if (so.bValid() && so.ps->bUMPD())
    {
        if (so.ps->hSecureUMPD)
        {
            ASSERTGDI(so.ps->iType() == STYPE_BITMAP, "surf type != STYPE_BITMAP\n");
            MmUnsecureVirtualMemory(so.ps->hSecureUMPD);
        }

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//
// Validate an HDEV belongs to us
//

BOOL
ValidUmpdHdev(
    HDEV    hdev
    )
{
    BOOL bRet = FALSE;

    if (hdev == NULL)
        return FALSE;

    if (!IS_SYSTEM_ADDRESS(hdev))
        return FALSE;

    PPDEV   ppdev;

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

    for (ppdev = gppdevList; ppdev != NULL; ppdev = ppdev->ppdevNext)
    {
        if ((HDEV)ppdev == hdev)
        {
            bRet = TRUE;
            break;
        }
    }

    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    return bRet;
}

//
// Make sure for each HOOK_XXX flag set, we actually
// has the driver function in ppfn
//

BOOL
ValidUmpdHooks (
    HDEV hdev,
    FLONG   flHooks
    )
{
   PDEVOBJ po(hdev);

   return (PPFNGET(po, BitBlt, flHooks) &&
           PPFNGET(po, StretchBlt, flHooks) &&
           PPFNGET(po, PlgBlt, flHooks) &&
           PPFNGET(po, TextOut, flHooks) &&
           PPFNGET(po, StrokePath, flHooks) &&
           PPFNGET(po, FillPath, flHooks) &&
           PPFNGET(po, StrokeAndFillPath, flHooks) &&
           PPFNGET(po, Paint, flHooks) &&
           PPFNGET(po, CopyBits, flHooks) &&
           PPFNGET(po, LineTo, flHooks) &&
           PPFNGET(po, StretchBltROP, flHooks) &&
           PPFNGET(po, TransparentBlt, flHooks) &&
           PPFNGET(po, AlphaBlend, flHooks) &&
           PPFNGET(po, GradientFill, flHooks));
}


//
// Valid size for bitmap/surface creation
//

BOOL
ValidUmpdSizl(
    SIZEL  sizl
    )
{
    if ((sizl.cx <= 0) || (sizl.cy <= 0))
    {
        WARNING("ValidUmpdSizl failed - cx or cy <=0 \n");
        return FALSE;
    }
    else
    {
        ULONGLONG cj = ((ULONGLONG)sizl.cx) * sizl.cy;

        if (cj > MAXULONG)
        {
            WARNING("ValidUmpdSizl failed - cx*cy overflow\n");
            return FALSE;
        }
    }

    return TRUE;
}

ULONG
ValidUmpdOverflow(LONG cx, LONG cy)
{
    ULONGLONG cj = ((ULONGLONG)cx) * cy;

    if (cj > MAXULONG)
        return FALSE;
    else
        return (ULONG)cj;

}

BOOL APIENTRY NtGdiEngAssociateSurface(
    IN HSURF  hsurf,    
    IN HDEV   hdev, 
    IN FLONG  flHooks   
   )
{
    return ValidUmpdHsurf(hsurf) &&
           ValidUmpdHdev(hdev) &&
           (!(flHooks & ~HOOK_FLAGS))&&
           ValidUmpdHooks (hdev, flHooks) &&
           EngAssociateSurface(hsurf, hdev, flHooks);
}

BOOL APIENTRY NtGdiEngDeleteSurface(
    IN HSURF  hsurf 
   )
{
    return ValidUmpdHsurfAndUnSecure(hsurf) &&
           EngDeleteSurface(hsurf);
}


BOOL APIENTRY NtGdiEngMarkBandingSurface(
     HSURF hsurf
     )
{
    return ValidUmpdHsurf(hsurf) &&
           EngMarkBandingSurface(hsurf);
}


HBITMAP APIENTRY NtGdiEngCreateBitmap(
    IN SIZEL  sizl, 
    IN LONG   lWidth,   
    IN ULONG  iFormat,  
    IN FLONG  fl,   
    IN PVOID  pvBits    
   )
{
    HBITMAP hbm = NULL;
    HANDLE  hSecure = NULL;
    ULONG   cj;
    BOOL    bSuccess = TRUE;

    TRACE_INIT (("Entering NtGdiEngCreateBitmap\n"));

    // check sizl.x and y
    if (!ValidUmpdSizl(sizl))
        return 0;

    cj = ValidUmpdOverflow(lWidth, sizl.cy);

    //
    // set the high bit of iFormat to indicate umpd driver
    //
    iFormat |= UMPD_FLAG;

    if (pvBits)
    {
        fl &= ~BMF_USERMEM;
        __try
        {
            ProbeForRead(pvBits,cj,sizeof(BYTE));
            hSecure = MmSecureVirtualMemory(pvBits, cj, PAGE_READWRITE);

            if (!hSecure)
                bSuccess = FALSE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING ("EngCreateBitmap -- exception in try/except \n");
            bSuccess = FALSE;
        }
    }
    else
    {
        fl |= BMF_USERMEM;
#if defined(_WIN64)
        // wow64 printing

        PW32THREAD    pw32thread = W32GetCurrentThread();
        
        if (pw32thread->pClientID)
            fl |= BMF_UMPDMEM;
#endif
    }

    if (bSuccess)
    {
        hbm = EngCreateBitmap(sizl, lWidth, iFormat, fl, pvBits);
    }

    if (hSecure != NULL)
    {
        if (hbm != NULL)
        {
            //
            // set hSecure into hSecureUMPD, at EngDeleteSurface time,
            // we unsecure it
            //

            SURFREF so((HSURF) hbm);

            if (so.bValid())
            {
                so.ps->hSecureUMPD = hSecure;
            }
            else
            {
                MmUnsecureVirtualMemory(hSecure);

                EngDeleteSurface((HSURF)hbm);

                hbm = NULL;
            }
        }
        else
        {
            //
            // We secured caller's memory but EngCreateBitmap failed.
            //

            MmUnsecureVirtualMemory(hSecure);
        }
    }

    return (hbm);
}

BOOL APIENTRY NtGdiEngCopyBits(
    IN SURFOBJ   *psoDst,   
    OUT SURFOBJ  *psoSrc,   
    IN CLIPOBJ   *pco,  
    IN XLATEOBJ  *pxlo, 
    IN RECTL    *prclDst,   
    IN POINTL   *pptlSrc    
   )
{
    RECTL   rcl;
    POINTL  ptl;
    ULONG   cx, cy;
    BOOL    bRet = TRUE;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoDst(psoDst, pUMObjs);
    UMPDSURFOBJ umsoSrc(psoSrc, pUMObjs);

    psoDst = umsoDst.pso();
    psoSrc = umsoSrc.pso();

    if (psoDst && psoSrc && (psoDst->iType == STYPE_BITMAP) && prclDst && pptlSrc)
    {
       __try
       {
           CaptureRECTL(&prclDst, &rcl);
           CapturePOINTL(&pptlSrc, &ptl);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngCopyBits failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet && bOrder(prclDst))
       {
           pco = pUMObjs->GetDDIOBJ(pco, &psoDst->sizlBitmap);
           pxlo = pUMObjs->GetDDIOBJ(pxlo);

           if (bRet = (bCheckSurfaceRectSize(psoDst, prclDst, pco, &cx, &cy) && bCheckXlate(psoSrc, pxlo)))
           {
               RECTL rclSrc, *prclSrc;

               prclSrc = psoSrc ? pRect(pptlSrc, &rclSrc, cx, cy) : NULL;

               if (bRet = bCheckSurfaceRect(psoSrc, prclSrc, NULL))
               {
                  bRet = EngCopyBits(psoDst,
                                     psoSrc,
                                     pco,
                                     pxlo,
                                     prclDst,
                                     pptlSrc);
               }
           }
       }
    }
    else
    {
        bRet = FALSE;
    }

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}

BOOL APIENTRY NtGdiEngStretchBlt(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    )
{
    BOOL   bRet = TRUE;
    RECTL  rclDst, rclSrc;
    POINTL ptlMask, ptlHTOrg;
    COLORADJUSTMENT ca;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoDest(psoDest, pUMObjs);
    UMPDSURFOBJ umsoSrc(psoSrc, pUMObjs);
    UMPDSURFOBJ umsoMask(psoMask, pUMObjs);

    psoDest = umsoDest.pso();
    psoSrc = umsoSrc.pso();
    psoMask = umsoMask.pso();

    if (!pptlHTOrg && (iMode == HALFTONE))
    {
        WARNING ("pptlHTOrg is NULL for HALFTONE mode\n");
        FIXUP_THREAD_UMPDOBJS;
        return (FALSE);
    }

    if (psoDest && psoSrc && prclDest && prclSrc)
    {
       __try
       {
           CaptureRECTL(&prclDest, &rclDst);
           CapturePOINTL(&pptlMask, &ptlMask);
           CaptureRECTL(&prclSrc, &rclSrc);
           CaptureCOLORADJUSTMENT(&pca, &ca);
           CapturePOINTL(&pptlHTOrg, &ptlHTOrg);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngStretchBlt failed in try/except\n");
           bRet = FALSE;
       }

       if (!bCheckDestSurfaceOverlap(psoDest,prclDest))
       {
           FIXUP_THREAD_UMPDOBJS;
           return(TRUE);
       }

       if (bRet)
       {
           pco = pUMObjs->GetDDIOBJ(pco, &psoDest->sizlBitmap);
           pxlo = pUMObjs->GetDDIOBJ(pxlo);

           //
           // EngStretchBlt does trimming and checking of the dest and src rectangles,
           // but it assumes the src rect is well-ordered.  Check here.
           //
           bRet = bOrder(prclSrc) && bCheckXlate(psoSrc, pxlo);

           if (bRet && psoMask)
           {
              RECTL rclMask, *prclMask;

              ULONG cx, cy;

              if (bRet = bCheckSurfaceRectSize(psoSrc, prclSrc, NULL, &cx, &cy))
              {
                 prclMask = pRect(pptlMask, &rclMask, cx, cy);
                 bRet = bCheckMask(psoMask, prclMask);
              }
            }

            if (bRet)
                bRet = EngStretchBlt(psoDest,
                                   psoSrc,
                                   psoMask,
                                   pco,
                                   pxlo,
                                   pca,
                                   pptlHTOrg,
                                   prclDest,
                                   prclSrc,
                                   pptlMask,
                                   iMode);
       }
    }
    else
    {
        bRet = FALSE;
    }

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);

}

BOOL APIENTRY NtGdiEngStretchBltROP(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    DWORD            rop4
    )
{
    BOOL   bRet = TRUE;
    RECTL  rclDst, rclSrc;
    POINTL ptlMask, ptlHTOrg;
    COLORADJUSTMENT ca;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoDest(psoDest, pUMObjs);
    UMPDSURFOBJ umsoSrc(psoSrc, pUMObjs);
    UMPDSURFOBJ umsoMask(psoMask, pUMObjs);

    psoDest = umsoDest.pso();
    psoSrc = umsoSrc.pso();
    psoMask = umsoMask.pso();

    if (!pptlHTOrg && (iMode == HALFTONE))
    {
        WARNING ("pptlHTOrg is NULL for HALFTONE mode\n");
        FIXUP_THREAD_UMPDOBJS;
        return (FALSE);
    }

    if (psoDest && psoSrc && prclDest && prclSrc)
    {
       __try
       {
           CaptureRECTL(&prclDest, &rclDst);
           CaptureRECTL(&prclSrc, &rclSrc);
           CapturePOINTL(&pptlMask, &ptlMask);
           CapturePOINTL(&pptlHTOrg, &ptlHTOrg);
           CaptureCOLORADJUSTMENT(&pca, &ca);

       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngStretchBltTROP failed in try/except\n");
           bRet = FALSE;
       }

       if (!bCheckDestSurfaceOverlap(psoDest,prclDest))
       {
           FIXUP_THREAD_UMPDOBJS;
           return(TRUE);
       }

       if (bRet)
       {
           ULONG    cx, cy;
           BRUSHOBJ boTemp;

           pco = pUMObjs->GetDDIOBJ(pco, &psoDest->sizlBitmap);
           pxlo = pUMObjs->GetDDIOBJ(pxlo);

           //
           // EngStretchBlt does trimming and checking of the rectangles,
           // but it assumes the src rect is well-ordered, check here.
           //

           bRet = (!ROP4NEEDSRC(rop4) || bOrder(prclSrc)) && bCheckXlate(psoSrc, pxlo) &&
                  (!ROP4NEEDMASK(rop4) || psoMask || PROBEDISPATBRUSH(pbo));

           if (ROP4NEEDMASK(rop4) && (!psoMask || !pptlMask))
               bRet = FALSE;
           if (bRet && (rop4 == 0XAACC) && psoMask)
           {
              RECTL rclMask, *prclMask;

              ULONG cx, cy;

              if (bRet = bCheckSurfaceRectSize(psoSrc, prclSrc, NULL, &cx, &cy))
              {
                 prclMask = pRect(pptlMask, &rclMask, cx, cy);
                 bRet = bCheckMask(psoMask, prclMask);
              }
            }

            MAP_UM_BRUSHOBJ(pUMObjs, pbo, &boTemp);

            bRet = bRet &&
                   EngStretchBltROP(psoDest,
                                psoSrc,
                                psoMask,
                                pco,
                                pxlo,
                                pca,
                                pptlHTOrg,
                                prclDest,
                                prclSrc,
                                pptlMask,
                                iMode,
                                pbo,
                                rop4);
       }
    }
    else
    {
        bRet = FALSE;
    }

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}

BOOL APIENTRY NtGdiEngPlgBlt(
    SURFOBJ         *psoTrg,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMsk,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfxDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    )
{
    BOOL     bRet = TRUE;
    RECTL    rcl;
    POINTL   ptl, ptlBrushOrg;
    POINTFIX pptfx[3];
    COLORADJUSTMENT ca;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoTrg(psoTrg, pUMObjs);
    UMPDSURFOBJ umsoSrc(psoSrc, pUMObjs);
    UMPDSURFOBJ umsoMsk(psoMsk, pUMObjs);

    psoTrg = umsoTrg.pso();
    psoSrc = umsoSrc.pso();
    psoMsk = umsoMsk.pso();

    if (psoTrg && psoSrc && prclSrc && pptfxDest)
    {
       __try
       {
           CaptureRECTL(&prclSrc, &rcl);
           CaptureCOLORADJUSTMENT(&pca, &ca);
           CapturePOINTL(&pptlMask, &ptl);
           CapturePOINTL(&pptlBrushOrg, &ptlBrushOrg);
           CaptureBits(pptfx, pptfxDest, sizeof(POINTFIX)*3);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngPlgBlt failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
       {
           ULONG cx, cy;

           pco = pUMObjs->GetDDIOBJ(pco, &psoTrg->sizlBitmap);
           pxlo = pUMObjs->GetDDIOBJ(pxlo);

           //
           // EngPlgBlt does the rectangle trimming and checking of dest and src
           //

           if (bRet = (bCheckRect(prclSrc) && bCheckXlate(psoSrc, pxlo)))
           {
              if (psoMsk)
              {
                 RECTL rclMask, *prclMask;

                 ULONG cx, cy;

                 if (bRet = bCheckSurfaceRectSize(psoSrc, prclSrc, NULL, &cx, &cy))
                 {
                    prclMask = pRect(pptlMask, &rclMask, cx, cy);
                    bRet = bCheckMask(psoMsk, prclMask);
                 }
               }

               if (bRet)
                  bRet = EngPlgBlt(psoTrg,
                                   psoSrc,
                                   psoMsk,
                                   pco,
                                   pxlo,
                                   pca,
                                   &ptlBrushOrg,
                                   pptfx,
                                   prclSrc,
                                   pptlMask,
                                   iMode);
          }
       }
    }
    else
    {
        bRet = FALSE;
    }

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}

SURFOBJ  *APIENTRY NtGdiEngLockSurface(
    IN HSURF  hsurf 
   )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);   
    
    SURFOBJ *surfRet = pUMObjs->LockSurface(hsurf);

    FIXUP_THREAD_UMPDOBJS;

    return (surfRet);
}

VOID APIENTRY NtGdiEngUnlockSurface(
    IN SURFOBJ  *pso    
   )
{
    EXTRACT_THREAD_UMPDOBJS;

    pUMObjs->UnlockSurface(pso);

    FIXUP_THREAD_UMPDOBJS;
}

BOOL APIENTRY NtGdiEngBitBlt(
    IN SURFOBJ  *psoDst,    
    IN SURFOBJ  *psoSrc,    
    IN SURFOBJ  *psoMask,   
    IN CLIPOBJ  *pco,   
    IN XLATEOBJ *pxlo,  
    IN RECTL    *prclDst,   
    IN POINTL   *pptlSrc,   
    IN POINTL   *pptlMask,  
    IN BRUSHOBJ *pbo,   
    IN POINTL   *pptlBrush, 
    IN ROP4     rop4    
   )
{
    BOOL        bRet = TRUE;
    RECTL       rclDst;
    POINTL      ptlSrc, ptlMask, ptlBrush;
    BRUSHOBJ    boTemp;

    TRACE_INIT (("Entering NtGdiEngBitBlt\n"));

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoDst(psoDst, pUMObjs);
    UMPDSURFOBJ umsoSrc(psoSrc, pUMObjs);
    UMPDSURFOBJ umsoMask(psoMask, pUMObjs);

    psoDst = umsoDst.pso();
    psoSrc = umsoSrc.pso();
    psoMask = umsoMask.pso();

    MAP_UM_BRUSHOBJ(pUMObjs, pbo, &boTemp);
    pxlo = pUMObjs->GetDDIOBJ(pxlo);

    if (((rop4 & 0xffff0000) != 0) ||
        !prclDst ||
        (ROP4NEEDPAT(rop4) && (!pbo || ISPATBRUSH(pbo) && !pptlBrush)) ||
        (ROP4NEEDSRC(rop4) && !(pptlSrc && psoSrc)) ||
        (ROP4NEEDMASK(rop4) && !(psoMask || ISPATBRUSH(pbo))))
    {
        WARNING ("NtGdiEngBitBlt invalid parameters passed in\n");
        FIXUP_THREAD_UMPDOBJS;
        return FALSE;
    }

    if (psoDst)
    {
       __try
       {
           CaptureRECTL(&prclDst, &rclDst);
           CapturePOINTL(&pptlSrc, &ptlSrc);
           CapturePOINTL(&pptlMask, &ptlMask);
           CapturePOINTL(&pptlBrush, &ptlBrush);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngBitBlt failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
       {
           ULONG cx, cy;

           pco = pUMObjs->GetDDIOBJ(pco, &psoDst->sizlBitmap);

           if (bRet = bCheckSurfaceRectSize(psoDst, prclDst, pco, &cx, &cy) &&
                      bCheckXlate(psoSrc, pxlo))
           {
               RECTL    rclSrc, *prclSrc;
               RECTL    rclMask, *prclMask;

               prclSrc = psoSrc ? pRect(pptlSrc, &rclSrc, cx, cy) : NULL;
               prclMask = psoMask ? pRect(pptlMask, &rclMask, cx, cy) : NULL;

               if (bRet = (bCheckSurfaceRect(psoSrc, prclSrc, NULL) &&
                           bCheckMask(psoMask, prclMask)))
               {
                  bRet = EngBitBlt(psoDst,
                                   psoSrc,
                                   psoMask,
                                   pco,
                                   pxlo,
                                   prclDst,
                                   pptlSrc,
                                   pptlMask,
                                   pbo,
                                   pptlBrush,
                                   rop4);
               }
           }
       }
    }
    else
        bRet = FALSE;

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}


BOOL APIENTRY NtGdiEngStrokePath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pbo,
    POINTL    *pptlBrushOrg,
    LINEATTRS *plineattrs,
    MIX        mix
    )
{
    BOOL        bRet = TRUE;
    POINTL      ptl;
    LINEATTRS   line;
    BRUSHOBJ    boTemp;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    TRACE_INIT (("Entering NtGdiEngStrokePath\n"));

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();
    ppo = pUMObjs->GetDDIOBJ(ppo);

    MAP_UM_BRUSHOBJ(pUMObjs, pbo, &boTemp);

    if (pso && pbo && ppo && plineattrs && pptlBrushOrg)
    {
       __try
       {
           CapturePOINTL(&pptlBrushOrg, &ptl);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngStrokePath failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
           bRet = bCaptureLINEATTRS(&plineattrs, &line);

       if (bRet)
       {
           pco = pUMObjs->GetDDIOBJ(pco, &pso->sizlBitmap);
           pxo = pUMObjs->GetDDIOBJ(pxo);
           if ((plineattrs->fl & LA_GEOMETRIC) && pxo == 0)
              bRet = FALSE;

           bRet = bRet && bCheckSurfacePath(pso, ppo, pco) &&
                  (!MIXNEEDMASK(mix) || ISPATBRUSH(pbo)) &&
                  EngStrokePath(pso,
                                ppo,
                                pco,
                                pxo,
                                pbo,
                                pptlBrushOrg,
                                plineattrs,
                                mix);

           if (plineattrs && plineattrs->pstyle)
               VFREEMEM(plineattrs->pstyle);
       }
    }
    else
        bRet = FALSE;

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}


BOOL APIENTRY NtGdiEngFillPath(
    SURFOBJ  *pso,
    PATHOBJ  *ppo,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrushOrg,
    MIX       mix,
    FLONG     flOptions
    )
{
    BOOL        bRet = FALSE;
    POINTL      ptlBrushOrg;
    BRUSHOBJ    boTemp;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();
    ppo = pUMObjs->GetDDIOBJ(ppo);
    pco = pso ? pUMObjs->GetDDIOBJ(pco, &pso->sizlBitmap) : NULL;

    MAP_UM_BRUSHOBJ(pUMObjs, pbo, &boTemp);

    if (pso && pbo && ppo && pco && (pco->iMode == TC_RECTANGLES) && pptlBrushOrg)
    {
        __try
        {
            CapturePOINTL(&pptlBrushOrg, &ptlBrushOrg);
                bRet = TRUE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING ("NtGdiEngFillPath failed in try/except\n");
        }

        bRet = bRet &&
               bCheckSurfacePath(pso, ppo, pco) &&
               (!MIXNEEDMASK(mix) || ISPATBRUSH(pbo)) &&
               EngFillPath(pso,
                           ppo,
                           pco,
                           pbo,
                           pptlBrushOrg,
                           mix,
                           flOptions);
    }

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}


BOOL APIENTRY NtGdiEngStrokeAndFillPath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pboStroke,
    LINEATTRS *plineattrs,
    BRUSHOBJ  *pboFill,
    POINTL    *pptlBrushOrg,
    MIX        mixFill,
    FLONG      flOptions
    )
{
    BOOL        bRet = FALSE;
    POINTL      ptl;
    LINEATTRS   line;
    BRUSHOBJ    boTempStroke, boTempFill;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();
    ppo = pUMObjs->GetDDIOBJ(ppo);
    pco = pso ? pUMObjs->GetDDIOBJ(pco, &pso->sizlBitmap) : NULL;

    MAP_UM_BRUSHOBJ(pUMObjs, pboStroke, &boTempStroke);
    MAP_UM_BRUSHOBJ(pUMObjs, pboFill, &boTempFill);

    if (pso && pboStroke && pboFill && ppo && plineattrs && pco && pptlBrushOrg)
    {
       __try
       {
           CapturePOINTL(&pptlBrushOrg, &ptl);
               bRet = TRUE;
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngStrokeAndFillPath failed in try/except\n");
       }

       if (bRet)
           bRet = bCaptureLINEATTRS(&plineattrs, &line);

       if (bRet)
       {
           pxo = pUMObjs->GetDDIOBJ(pxo);
           if ((plineattrs->fl & LA_GEOMETRIC) && pxo == 0)
              bRet = FALSE;

           bRet = bRet && bCheckSurfacePath(pso, ppo, pco) &&
                  (!MIXNEEDMASK(mixFill) || ISPATBRUSH(pboFill)) &&
                  EngStrokeAndFillPath(pso,
                                       ppo,
                                       pco,
                                       pxo,
                                       pboStroke,
                                       plineattrs,
                                       pboFill,
                                       pptlBrushOrg,
                                       mixFill,
                                       flOptions);

           if (plineattrs && plineattrs->pstyle)
               VFREEMEM(plineattrs->pstyle);
       }
    }

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}


BOOL APIENTRY
NtGdiEngPaint(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix
    )
{
    POINTL      ptlBrushOrg;
    BOOL        bRet = TRUE;
    BRUSHOBJ    boTemp;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();
    pco = pso ? pUMObjs->GetDDIOBJ(pco, &pso->sizlBitmap) : NULL;

    MAP_UM_BRUSHOBJ(pUMObjs, pbo, &boTemp);

    if (pso && pco && (pco->iMode == TC_RECTANGLES) && (mix & 0xff00))
    {
       
        __try
       {
           CapturePOINTL(&pptlBrushOrg, &ptlBrushOrg);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngPaint failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet && (bRet = bCheckSurfaceRect(pso, NULL, pco)))
       {
           bRet = EngPaint(pso, pco, pbo, pptlBrushOrg, mix);
       }
    }
    else
        bRet = FALSE;

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}


BOOL APIENTRY NtGdiEngLineTo(
    SURFOBJ   *pso,
    CLIPOBJ   *pco,
    BRUSHOBJ  *pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL     *prclBounds,
    MIX        mix
    )
{
    BOOL        bRet = TRUE;
    RECTL       rcl;
    RECTL       rclline = {x1,y1,x2,y2};
    BRUSHOBJ    boTemp;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();

    MAP_UM_BRUSHOBJ(pUMObjs, pbo, &boTemp);

    if (pso && pbo)
    {
       __try
       {
           CaptureRECTL(&prclBounds, &rcl);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngLineTo failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
       {
           pco = pUMObjs->GetDDIOBJ(pco, &pso->sizlBitmap);

           if (bRet = bCheckSurfaceRect(pso, &rclline, pco))
           {
              bRet = EngLineTo(pso,
                               pco,
                               pbo,
                               x1,
                               y1,
                               x2,
                               y2,
                               prclBounds,
                               mix);
          }
       }
    }
    else
        bRet = FALSE;

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}


BOOL APIENTRY NtGdiEngAlphaBlend(
    SURFOBJ       *psoDest,
    SURFOBJ       *psoSrc,
    CLIPOBJ       *pco,
    XLATEOBJ      *pxlo,
    RECTL         *prclDest,
    RECTL         *prclSrc,
    BLENDOBJ      *pBlendObj
    )
{
    BOOL        bRet = TRUE;
    RECTL       rclDest, rclSrc;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoDest(psoDest, pUMObjs);
    UMPDSURFOBJ umsoSrc(psoSrc, pUMObjs);

    pBlendObj = pUMObjs->GetDDIOBJ(pBlendObj);

    psoDest = umsoDest.pso();
    psoSrc = umsoSrc.pso();

    if (psoDest && psoSrc && pBlendObj && prclDest && prclSrc)
    {
       __try
       {
           CaptureRECTL(&prclSrc, &rclSrc);
           CaptureRECTL(&prclDest, &rclDest);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngAlphaBlend failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet && bOrder(prclSrc) && bOrder(prclDest))
       {
           pco = pUMObjs->GetDDIOBJ(pco, &psoDest->sizlBitmap);
           pxlo = pUMObjs->GetDDIOBJ(pxlo);

           if (bRet = (bCheckSurfaceRect(psoSrc, prclSrc, NULL) && bCheckXlate(psoSrc, pxlo)))
           {
              bRet = EngAlphaBlend(psoDest,
                                   psoSrc,
                                   pco,
                                   pxlo,
                                   prclDest,
                                   prclSrc,
                                   pBlendObj);
          }
       }
    }
    else
        bRet = FALSE;

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}

//
// Make sure the Vertex and Mesh data are valid. i.e that they are bounded
// within each other.
//

__inline
BOOL bValidVertexMeshData(
    TRIVERTEX *pVertex,
    PVOID pMeshIn,
    ULONG nVertex,
    ULONG nMesh,
    ULONG ulMode)
{
    ULONG ulIndex;

    if (nVertex <= 1)
        return FALSE;

    PTRIVERTEX pTVb = pVertex;
    PTRIVERTEX pTVe = pVertex + nVertex - 1;
    PTRIVERTEX pTV;

    switch (ulMode)
    {
    case GRADIENT_FILL_RECT_H:
    case GRADIENT_FILL_RECT_V:
        {
            PGRADIENT_RECT pMesh = (PGRADIENT_RECT)pMeshIn;
            for (ulIndex = 0; ulIndex < nMesh; ulIndex++)
            {
                pTV = pTVb + pMesh[ulIndex].UpperLeft;
                if (!(pTV >= pTVb && pTV <= pTVe))
                    return FALSE;
                pTV = pTVb + pMesh[ulIndex].LowerRight;
                if (!(pTV >= pTVb && pTV <= pTVe))
                    return FALSE;
            }
        }
        break;

    case GRADIENT_FILL_TRIANGLE:
        {
            PGRADIENT_TRIANGLE pMesh = (PGRADIENT_TRIANGLE)pMeshIn;
            for (ulIndex = 0; ulIndex < nMesh; ulIndex++)
            {
                pTV = pTVb + pMesh[ulIndex].Vertex1;
                if (!(pTV >= pTVb && pTV <= pTVe))
                    return FALSE;
                pTV = pTVb + pMesh[ulIndex].Vertex2;
                if (!(pTV >= pTVb && pTV <= pTVe))
                    return FALSE;
                pTV = pTVb + pMesh[ulIndex].Vertex3;
                if (!(pTV >= pTVb && pTV <= pTVe))
                    return FALSE;
            }
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL APIENTRY NtGdiEngGradientFill(
    SURFOBJ         *psoDest,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    TRIVERTEX       *pVertex,
    ULONG            nVertex,
    PVOID            pMesh,
    ULONG            nMesh,
    RECTL           *prclExtents,
    POINTL          *pptlDitherOrg,
    ULONG            ulMode
    )
{
    BOOL           bRet = TRUE;
    RECTL          rcl;
    POINTL         ptl;
    TRIVERTEX      *pVertexTmp = (TRIVERTEX *)NULL;
    PVOID          pMeshTmp = NULL;
    ULONG          cjMesh;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoDest(psoDest, pUMObjs);
    psoDest = umsoDest.pso();

    switch (ulMode)
    {
    case GRADIENT_FILL_RECT_H:
    case GRADIENT_FILL_RECT_V:

        cjMesh = sizeof(GRADIENT_RECT);

        if (BALLOC_OVERFLOW1(nMesh, GRADIENT_RECT))
        {
            FIXUP_THREAD_UMPDOBJS;
            return FALSE;
        }

        break;

    case GRADIENT_FILL_TRIANGLE:

        cjMesh = sizeof(GRADIENT_TRIANGLE);

        if (BALLOC_OVERFLOW1(nMesh, GRADIENT_TRIANGLE))
        {
            FIXUP_THREAD_UMPDOBJS;
            return FALSE;
        }

        break;

    default:

        WARNING ("Invalid ulMode in DrvGradientFill\n");
        FIXUP_THREAD_UMPDOBJS;
        return FALSE;
    }

    if (nMesh == 0 || nVertex == 0)
    {
        FIXUP_THREAD_UMPDOBJS;
        return TRUE;
    }

    cjMesh *= nMesh;

    if (BALLOC_OVERFLOW1(nVertex, TRIVERTEX))
    {
        FIXUP_THREAD_UMPDOBJS;
        return FALSE;
    }

    pVertexTmp = (TRIVERTEX *)PALLOCNOZ (sizeof(TRIVERTEX)*nVertex, UMPD_MEMORY_TAG);

    pMeshTmp = PALLOCNOZ (cjMesh, UMPD_MEMORY_TAG);

    if (psoDest && pVertex && pMesh && pVertexTmp && pMeshTmp && prclExtents && pptlDitherOrg)
    {
       __try
       {
           CaptureRECTL(&prclExtents, &rcl);
           CapturePOINTL(&pptlDitherOrg, &ptl);
           CaptureBits(pVertexTmp, pVertex, sizeof(TRIVERTEX)*nVertex);
           CaptureBits(pMeshTmp, pMesh, cjMesh);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngAlphaBlend failed in try/except\n");
           bRet = FALSE;
       }

       bRet = bRet && bValidVertexMeshData(pVertexTmp,pMeshTmp,nVertex,nMesh,ulMode);

       if (bRet)
       {
           pco = pUMObjs->GetDDIOBJ(pco, &psoDest->sizlBitmap);

           bRet = EngGradientFill(psoDest,
                                  pco,
                                  pUMObjs->GetDDIOBJ(pxlo),
                                  pVertexTmp,
                                  nVertex,
                                  pMeshTmp,
                                  nMesh,
                                  prclExtents,
                                  pptlDitherOrg,
                                  ulMode);
       }
    }
    else
        bRet = FALSE;

    if (pVertexTmp)
        VFREEMEM(pVertexTmp);

    if (pMeshTmp)
        VFREEMEM(pMeshTmp);

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}


BOOL APIENTRY NtGdiEngTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved
    )
{
    BOOL bRet = TRUE;
    RECTL rclDst, rclSrc;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoDst(psoDst, pUMObjs);
    UMPDSURFOBJ umsoSrc(psoSrc, pUMObjs);

    psoDst = umsoDst.pso();
    psoSrc = umsoSrc.pso();

    if (psoDst && psoSrc && prclDst && prclSrc)
    {
       __try
       {
           CaptureRECTL(&prclSrc, &rclSrc);
           CaptureRECTL(&prclDst, &rclDst);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngTransparentBlt failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet && bOrder(prclDst) && bOrder(prclSrc))
       {
           pco = pUMObjs->GetDDIOBJ(pco, &psoDst->sizlBitmap);
           pxlo = pUMObjs->GetDDIOBJ(pxlo);

           if (bRet = (bCheckSurfaceRect(psoSrc, prclSrc, NULL) && bCheckXlate(psoSrc, pxlo)))
           {
               bRet = EngTransparentBlt(psoDst,
                                        psoSrc,
                                        pco,
                                        pxlo,
                                        prclDst,
                                        prclSrc,
                                        iTransColor,
                                        ulReserved);
           }
        }
     }
     else
         bRet = FALSE;

     FIXUP_THREAD_UMPDOBJS;
     return (bRet);
}


BOOL APIENTRY NtGdiEngTextOut(
    SURFOBJ  *pso,
    STROBJ   *pstro,
    FONTOBJ  *pfo,
    CLIPOBJ  *pco,
    RECTL    *prclExtra,
    RECTL    *prclOpaque,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    POINTL   *pptlOrg,
    MIX       mix
    )
{
    BOOL        bRet = TRUE;
    RECTL       rclExtra, rclOpaque;
    POINTL      ptlOrg;
    BRUSHOBJ    boTempFore, boTempOpaque;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();
    pstro = pUMObjs->GetDDIOBJ(pstro);
    pfo = pUMObjs->GetDDIOBJ(pfo);

    MAP_UM_BRUSHOBJ(pUMObjs, pboFore, &boTempFore);
    MAP_UM_BRUSHOBJ(pUMObjs, pboOpaque, &boTempOpaque);

    if (pso && pstro && pfo && pboFore && pptlOrg)
    {
       __try
       {
           CaptureRECTL(&prclExtra, &rclExtra);
           CaptureRECTL(&prclOpaque, &rclOpaque);
           CapturePOINTL(&pptlOrg, &ptlOrg);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngTextOut failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
       {
           pco = pUMObjs->GetDDIOBJ(pco, &pso->sizlBitmap);

           if (bRet = (!MIXNEEDMASK(mix) || ISPATBRUSH(pboFore)) &&
                      bCheckSurfaceRect(pso, prclOpaque, pco))
           {

                RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
                
                UMPDAcquireRFONTSem(rfto, pUMObjs, 0, 0, NULL);

                bRet = EngTextOut(pso,
                                  pstro,
                                  pfo,
                                  pco,
                                  prclExtra,
                                  prclOpaque,
                                  pboFore,
                                  pboOpaque,
                                  pptlOrg,
                                  mix);

                UMPDReleaseRFONTSem(rfto, pUMObjs, NULL, NULL, NULL);
           }
       }
    }
    else
        bRet = FALSE;

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}

HPALETTE APIENTRY NtGdiEngCreatePalette(
    ULONG  iMode,   
    ULONG  cColors, 
    ULONG  *pulColors,  
    FLONG  flRed,   
    FLONG  flGreen, 
    FLONG  flBlue   
   )
{
    HPALETTE hpal = (HPALETTE)1;
    ULONG    pulColorsTmp[256];
    HANDLE hSecure = 0;

    TRACE_INIT (("Entering NtGdiEngCreatePalette\n"));

    //
    // cColors has a limit of 64k
    //
    if (cColors > 64 * 1024)
        return 0;

    if ((iMode == PAL_INDEXED) && cColors)
    {
        if (cColors > 256)
            hpal = (HPALETTE)(ULONG_PTR)bSecureBits(pulColors, cColors*sizeof(ULONG), &hSecure);
        else
        {
            hpal = (HPALETTE)(ULONG_PTR)bSafeReadBits(pulColorsTmp, pulColors, cColors*sizeof(ULONG));
        }
    }

    if (hpal)
    {
        //
        // set the high bit of iMode to indicate umpd driver
        //
        iMode |= UMPD_FLAG;

        hpal = EngCreatePalette(iMode, cColors, pulColors, flRed, flGreen, flBlue);
    }

    if (hSecure)
    {
        MmUnsecureVirtualMemory(hSecure);
    }

    return hpal;
}

BOOL APIENTRY NtGdiEngDeletePalette(
    IN HPALETTE  hpal   
   )
{
    TRACE_INIT (("Entering NtGdiEngDeletePalette\n"));

    //
    // EngDeletePalette will check if hpal is valid
    // so we don't need to check hpal here
    //
    return (EngDeletePalette(hpal));
}

BOOL APIENTRY NtGdiEngEraseSurface(
    IN SURFOBJ  *pso,   
    IN RECTL    *prcl,  
    IN ULONG    iColor  
   )
{
    BOOL  bRet = TRUE;
    RECTL rcl;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();

    if (pso)
    {
       __try
       {
           CaptureRECTL(&prcl, &rcl);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngEraseSurface failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
       {
           if (bRet = bCheckSurfaceRect(pso, prcl, NULL))
           {
               bRet = EngEraseSurface(pso, prcl, iColor);
           }
       }
    }
    else
        bRet = FALSE;

    FIXUP_THREAD_UMPDOBJS;

    return bRet;
}

PATHOBJ* APIENTRY NtGdiCLIPOBJ_ppoGetPath(
    CLIPOBJ  *pco   
   )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    PATHOBJ* poRet = pUMObjs->GetCLIPOBJPath(pco);

    FIXUP_THREAD_UMPDOBJS;

    return poRet;
}

VOID APIENTRY NtGdiEngDeletePath(
    IN PATHOBJ  *ppo    
   )
{
    EXTRACT_THREAD_UMPDOBJS;

    pUMObjs->DeleteCLIPOBJPath(ppo);

    FIXUP_THREAD_UMPDOBJS;    
}

CLIPOBJ* APIENTRY NtGdiEngCreateClip()

{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    CLIPOBJ* clipRet = pUMObjs->CreateCLIPOBJ();
    
    FIXUP_THREAD_UMPDOBJS;

    return clipRet;
}

VOID APIENTRY NtGdiEngDeleteClip(
    CLIPOBJ *pco
    )

{
    EXTRACT_THREAD_UMPDOBJS;

    pUMObjs->DeleteCLIPOBJ(pco);

    FIXUP_THREAD_UMPDOBJS;
}

ULONG APIENTRY NtGdiCLIPOBJ_cEnumStart(
    CLIPOBJ *pco,
    BOOL     bAll,
    ULONG    iType,
    ULONG    iDirection,
    ULONG    cLimit
    )
{
    EXTRACT_THREAD_UMPDOBJS(0xffffffff);

    ULONG ulRet = 0xffffffff;

    pco = pUMObjs->GetDDIOBJ(pco);

    if (pco)
    {
       ulRet = CLIPOBJ_cEnumStart(pco,
                                 bAll,
                                 iType,
                                 iDirection,
                                 cLimit);
    }

    FIXUP_THREAD_UMPDOBJS;

    return ulRet;
}

BOOL APIENTRY NtGdiCLIPOBJ_bEnum(
    CLIPOBJ *pco,
    ULONG    cj,
    ULONG   *pul
    )
{
    BOOL    bRet = DDI_ERROR;
    ULONG   *pulTmp;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    pco = pUMObjs->GetDDIOBJ(pco);

    if (pco)
    {
       pulTmp = (PULONG)PALLOCNOZ(cj, UMPD_MEMORY_TAG);

       if (pulTmp)
       {
          ULONG cjFilled = 0;

          bRet = (*(XCLIPOBJ *)pco).bEnum(cj, pulTmp, &cjFilled);

          if (bRet != DDI_ERROR)
              if (!bSafeCopyBits(pul, pulTmp, cjFilled))
                  bRet = DDI_ERROR;

           VFREEMEM(pulTmp);
       }
    }

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}

PVOID APIENTRY NtGdiBRUSHOBJ_pvAllocRbrush(
    BRUSHOBJ *pbo,
    ULONG     cj
    )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    PVOID pvRet =  ((pbo = pUMObjs->GetDDIOBJ(pbo)) != NULL) ?
                BRUSHOBJ_pvAllocRbrushUMPD(pbo, cj) :
                NULL;

    FIXUP_THREAD_UMPDOBJS;
    return pvRet;
}

PVOID APIENTRY NtGdiBRUSHOBJ_pvGetRbrush(
    BRUSHOBJ *pbo
    )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    PVOID pvRet =  ((pbo = pUMObjs->GetDDIOBJ(pbo)) != NULL) ?
                BRUSHOBJ_pvGetRbrushUMPD(pbo) :
                NULL;

    FIXUP_THREAD_UMPDOBJS;
    return pvRet;
}


ULONG APIENTRY NtGdiBRUSHOBJ_ulGetBrushColor(
    BRUSHOBJ *pbo
    )
{
    EXTRACT_THREAD_UMPDOBJS(0);

    ULONG   ulRet = 0;
    BRUSHOBJ  *pbokm;

    if (pbokm = pUMObjs->GetDDIOBJ(pbo))
    {
        if ((pbo->flColorType & BR_ORIGCOLOR) && ((EBRUSHOBJ*)pbokm)->bIsSolid())
        {
            pbokm->flColorType |= BR_ORIGCOLOR;
        }
        ulRet = BRUSHOBJ_ulGetBrushColor(pbokm);
        pbo->flColorType &= ~BR_ORIGCOLOR;
    }

    FIXUP_THREAD_UMPDOBJS;

    return ulRet;
}

HANDLE APIENTRY NtGdiBRUSHOBJ_hGetColorTransform(
    BRUSHOBJ *pbo
    )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    HANDLE hRet = ((pbo = pUMObjs->GetDDIOBJ(pbo)) != NULL) ?
                BRUSHOBJ_hGetColorTransform(pbo) :
                NULL;

    FIXUP_THREAD_UMPDOBJS;

    return hRet;
}

BOOL APIENTRY NtGdiXFORMOBJ_bApplyXform(
    XFORMOBJ *pxo,
    ULONG     iMode,
    ULONG     cPoints,
    PVOID     pvIn,
    PVOID     pvOut
    )

#define APPLYXFORM_STACK_POINTS 4

{
    POINTL  ptlIn[APPLYXFORM_STACK_POINTS];
    POINTL  ptlOut[APPLYXFORM_STACK_POINTS];
    PVOID   pvInTmp, pvOutTmp;
    BOOL    bRet = FALSE;

    if (BALLOC_OVERFLOW1(cPoints, POINTL))
        return FALSE;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    pxo = pUMObjs->GetDDIOBJ(pxo);

    if (pxo && pvIn && pvOut && cPoints)
    {
        if (cPoints <= APPLYXFORM_STACK_POINTS)
        {
            pvInTmp  = ptlIn;
            pvOutTmp = ptlOut;
        }
        else
        {
            pvInTmp  = PALLOCNOZ(sizeof(POINTL)*cPoints, UMPD_MEMORY_TAG);
            pvOutTmp = PALLOCNOZ(sizeof(POINTL)*cPoints, UMPD_MEMORY_TAG);
        }

        if (pvInTmp != NULL &&
            pvOutTmp != NULL &&
            bSafeReadBits(pvInTmp, pvIn, cPoints*sizeof(POINTL)))
        {
            bRet = XFORMOBJ_bApplyXform(pxo, iMode, cPoints, pvInTmp, pvOutTmp) &&
                   bSafeCopyBits(pvOut, pvOutTmp, cPoints*sizeof(POINTL));
        }

        if (cPoints > APPLYXFORM_STACK_POINTS)
        {
            if (pvInTmp != NULL)
                VFREEMEM(pvInTmp);

            if (pvOutTmp != NULL)
                VFREEMEM(pvOutTmp);
        }

    }

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}

ULONG APIENTRY NtGdiXFORMOBJ_iGetXform(
    XFORMOBJ *pxo,
    XFORML   *pxform
    )
{
    ULONG   ulRet = DDI_ERROR;
    XFORML  xform;

    EXTRACT_THREAD_UMPDOBJS(DDI_ERROR);

    pxo = pUMObjs->GetDDIOBJ(pxo);

    if (pxo)
    {
       ulRet = XFORMOBJ_iGetXform(pxo, pxform? &xform : NULL);

       if ((ulRet != DDI_ERROR) && pxform)
       {
           __try
          {
              ProbeAndWriteStructure (pxform, xform, XFORML);
          }
          __except(EXCEPTION_EXECUTE_HANDLER)
          {
              ulRet = DDI_ERROR;
          }
       }
    }

    FIXUP_THREAD_UMPDOBJS;
    return (ulRet);
}

VOID APIENTRY NtGdiFONTOBJ_vGetInfo(
    FONTOBJ  *pfo,
    ULONG     cjSize,
    FONTINFO *pfi
    )
{
    FONTINFO *pfiTmp = NULL;

    EXTRACT_THREAD_UMPDOBJS;

    pfo = pUMObjs->GetDDIOBJ(pfo);

    if (pfo)
    {
       if (cjSize && pfi)
       {
           if (pfiTmp = (FONTINFO *)PALLOCNOZ(cjSize, UMPD_MEMORY_TAG))
           {
              FONTOBJ_vGetInfo(pfo, cjSize, pfiTmp);

              bSafeCopyBits(pfi, pfiTmp, cjSize);

              VFREEMEM(pfiTmp);
           }
       }
    }

    FIXUP_THREAD_UMPDOBJS;
}

//
// FONTOBJ_cGetGlyphs is a service to the font consumer that translates glyph handles into
// pointers to glyph data. These pointers are valid until the next call to FONTOBJ_cGetGlyphs.
// this means that we only need to attache one ppvGlyph onto the thread at any time.
//
// Note: another way to do this is to pre-allocate a reasonable size of User memory and
// use that memory for all temporary data buffers, and grow it when we are reaching the limit
// Thus we save the memory allocation calls.
//
ULONG APIENTRY NtGdiFONTOBJ_cGetGlyphs(
    FONTOBJ *pfo,
    ULONG    iMode,
    ULONG    cGlyph,
    HGLYPH  *phg,
    PVOID   *ppvGlyph
    )
{
    GLYPHDATA  *pgd, *pgdkm;
    HGLYPH      hg;
    ULONG       ulRet = 1;

    EXTRACT_THREAD_UMPDOBJS(0);

    if ((pfo = pUMObjs->GetDDIOBJ(pfo)) == NULL ||
        (iMode != FO_GLYPHBITS && iMode != FO_PATHOBJ))
    {
        WARNING("Invalid parameter passed to NtGdiFONTOBJ_cGetGlyphs\n");
        FIXUP_THREAD_UMPDOBJS;
        return 0;
    }

    //
    // Call the engine to retrive glyph data
    //
    // NOTE: DDK documentation is bogus.
    // Font driver only supports cGlyph == 1 case.
    //
    __try
    {
        CaptureDWORD (&phg, &hg);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING ("NtGdiFONTOBJ_cGetGlyphs failed in try/except\n");
        ulRet = 0;
    }

    if (ulRet)
    {
       RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
       
       UMPDAcquireRFONTSem(rfto, pUMObjs, 0, 0, NULL);

       if ((ulRet = FONTOBJ_cGetGlyphs(pfo, iMode, 1, phg, (PVOID *) &pgd)) == 1)
       {
           //
           // Thunk GLYPHDATA structure
           //
    
           pgdkm = pgd;
    
           if (!pUMObjs->ThunkMemBlock((PVOID *) &pgd, sizeof(GLYPHDATA)))
           {
               WARNING("Couldn't thunk GLYPHDATA structure\n");
               ulRet = 0;
           }
           else if (iMode == FO_GLYPHBITS)
           {
               //
               // Thunk GLYPHBITS structure
               //
    
               if (pgdkm->gdf.pgb != NULL &&
                   (pgd->gdf.pgb = pUMObjs->CacheGlyphBits(pgdkm->gdf.pgb)) == NULL)
               {
                   WARNING("Couldn't thunk GLYPHBITS structure\n");
                   ulRet = 0;
               }
           }
           else
           {
               //
               // Thunk PATHOBJ
               //
    
               if (pgdkm->gdf.ppo != NULL &&
                   (pgd->gdf.ppo = pUMObjs->CacheGlyphPath(pgdkm->gdf.ppo)) == NULL)
               {
                   WARNING("Couldn't thunk PATHOBJ structure\n");
                   ulRet = 0;
               }
           }
       }

       UMPDReleaseRFONTSem(rfto, pUMObjs, NULL, NULL, NULL);

       if (ulRet != 0)
       {
           __try
           {
               ProbeAndWriteStructure (ppvGlyph, (PVOID)pgd, PVOID);
           }
           __except(EXCEPTION_EXECUTE_HANDLER)
           {
               WARNING ("fail to write in ppvGlyph\n");
               ulRet = 0;
           }
       }
    }

    FIXUP_THREAD_UMPDOBJS;
    return ulRet;
}


ULONG APIENTRY NtGdiFONTOBJ_cGetAllGlyphHandles(
    IN FONTOBJ  *pfo,   
    OUT HGLYPH  *phg    
   )
{
    ULONG ulCount = 0;
    HGLYPH *phgTmp = NULL;
    ULONG ulRet = 0;

    EXTRACT_THREAD_UMPDOBJS(0);

    pfo = pUMObjs->GetDDIOBJ(pfo);

    if (pfo)
    {
       if (phg)
       {
           if (ulCount = FONTOBJ_cGetAllGlyphHandles(pfo, NULL))
           {
               // we are a little bit over cautious here,well...
               if (BALLOC_OVERFLOW1(ulCount, HGLYPH))
               {
                   FIXUP_THREAD_UMPDOBJS;
                   return NULL;
               }

               phgTmp = (HGLYPH *)PALLOCNOZ(ulCount*sizeof(HGLYPH), UMPD_MEMORY_TAG);
           }
       }

       ulRet = FONTOBJ_cGetAllGlyphHandles(pfo, phgTmp);
       ASSERTGDI(phg == NULL || ulRet == ulCount, "NtGdiFONTOBJ_cGetAllGlyphHandles: inconsistent return values from FONTOBJ_cGetAllGlyphHandles\n");

       if (ulRet && phg && phgTmp)
       {
           if (!bSafeCopyBits(phg, phgTmp, ulCount * sizeof(HGLYPH)))
               ulRet = NULL;
       }

       if (phgTmp)
       {
           VFREEMEM(phgTmp);
       }
    }

    FIXUP_THREAD_UMPDOBJS;
    return ulRet;
}

XFORMOBJ* APIENTRY NtGdiFONTOBJ_pxoGetXform(
    FONTOBJ *pfo
    )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    XFORMOBJ* xoRet= pUMObjs->GetFONTOBJXform(pfo);

    FIXUP_THREAD_UMPDOBJS;
    return xoRet;
}


//
// If the return value is a system address, we copy it into user memory
//
// IMPORTANT!!
//  We assume FD_GLYPHSET information is stored in one contiguous block
//  of memory and FD_GLYPHSET.cjThis field is the size of the entire block.
//  HGLYPH arrays in each WCRUN are part of the block, placed just after
//  FD_GLYPHSET structure itself.
//
BOOL
GreCopyFD_GLYPHSET(
    FD_GLYPHSET *dst,
    FD_GLYPHSET *src,
    ULONG       cjSize,
    BOOL        bFromKernel
    )

{
    ULONG   size;
    PBYTE   phg, pbMax;

    //
    // bFromKernel TRUE: we are copying from kernel mode address(src) to user mode address (dst)
    //                   the src should contain everything in one chunk of memory
    //
    //             FALSE: copying from user mode (src) to kernel mode (dst)
    //                   glyph indices in src might be stored in a different chunk of memory from src
    //
    
    size = bFromKernel ? cjSize : offsetof(FD_GLYPHSET, awcrun) + src->cRuns * sizeof(WCRUN);
    RtlCopyMemory(dst, src, size);

    dst->cjThis = cjSize;
    pbMax = (PBYTE)dst + cjSize;
    phg = (PBYTE)dst + size;
    
    //
    // Patch up memory pointers in each WCRUN structure
    //

    ULONG   index, offset;
    
    for (index=0; index < src->cRuns; index++)
    {
        if (src->awcrun[index].phg != NULL)
        {
            if (bFromKernel)
            {
                offset = (ULONG)((PBYTE) src->awcrun[index].phg - (PBYTE) src);
                
                if (offset >= cjSize)
                {
                    WARNING("GreCopyFD_GLYPHSET failed.\n");
                    return FALSE;
                }
                dst->awcrun[index].phg = (HGLYPH*) ((PBYTE) dst + offset);
            }
            else
            {
                size = src->awcrun[index].cGlyphs * sizeof(HGLYPH);

                if (phg + size <= pbMax)
                {
                    RtlCopyMemory(phg, src->awcrun[index].phg, size);
                    dst->awcrun[index].phg = (HGLYPH*) phg;
                    phg += size;
                }
                else
                    return FALSE;
            }
        }
    }

    return TRUE;
}

FD_GLYPHSET * APIENTRY NtGdiFONTOBJ_pfdg(
    FONTOBJ *pfo
    )
{
    FD_GLYPHSET  *pfdg = NULL, *pfdgTmp;
    ULONG        cjSize;

    EXTRACT_THREAD_UMPDOBJS(NULL);

    //
    // Check if this function has already been
    // called during the current DDI entrypoint
    //

    if (! (pfo = pUMObjs->GetDDIOBJ(pfo)) ||
        (pfdg = pUMObjs->pfdg()) != NULL)
    {
        FIXUP_THREAD_UMPDOBJS;
        return pfdg;
    }

    //
    // Call FONTOBJ_pifi and cache the pointer in UMPDOBJ
    //

    RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
    
    UMPDAcquireRFONTSem(rfto, pUMObjs, 0, 0, NULL);

    pfdgTmp = NULL;

    if ((pfdg = FONTOBJ_pfdg(pfo)) != NULL)
    {
        if (IS_SYSTEM_ADDRESS(pfdg))
        {
            if ((cjSize = SZ_GLYPHSET(pfdg->cRuns, pfdg->cGlyphsSupported)) &&
                (pfdgTmp = (FD_GLYPHSET *) pUMObjs->AllocUserMem(cjSize)))
            {
                if (GreCopyFD_GLYPHSET(pfdgTmp, pfdg, cjSize, TRUE))
                    pUMObjs->pfdg(pfdgTmp);
                else
                    pfdgTmp = NULL;
            }
        }
        else
        {
            pfdgTmp = pfdg;
            pUMObjs->pfdg(pfdgTmp);
        }
    }

    UMPDReleaseRFONTSem(rfto, pUMObjs, NULL, NULL, NULL);

    FIXUP_THREAD_UMPDOBJS;
    return pfdgTmp;
}

PFD_GLYPHATTR  APIENTRY NtGdiFONTOBJ_pQueryGlyphAttrs(
    FONTOBJ *pfo,
    ULONG   iMode
)
{
    PFD_GLYPHATTR   pfdga, pfdgaTmp;
    ULONG   i;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    if ((pfo = pUMObjs->GetDDIOBJ(pfo)) == NULL)
    {
        WARNING("Invalid parameter passed to NtGdiFONTOBJ_pQueryGlyphAttrs\n");
        FIXUP_THREAD_UMPDOBJS;
        return FALSE;
    }

    pfdga = NULL;

    if ((pfdgaTmp = pUMObjs->pfdga()) == NULL)
    {

        RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
        
        UMPDAcquireRFONTSem(rfto, pUMObjs, 0, 0, NULL);

        pfdgaTmp = FONTOBJ_pQueryGlyphAttrs(pfo, iMode);

        if (pfdgaTmp)
        {
            ULONG   cjSize;

            cjSize = ((PFD_GLYPHATTR)pfdgaTmp)->cjThis;
            pfdga = (PFD_GLYPHATTR) pUMObjs->AllocUserMem(cjSize);

            if (pfdga)
            {
                RtlCopyMemory((PVOID) pfdga, (PVOID) pfdgaTmp, cjSize);
                pUMObjs->pfdga(pfdga);
            }
        }

        UMPDReleaseRFONTSem(rfto, pUMObjs, NULL, NULL, NULL);

    }
    else
        pfdga = pfdgaTmp;

    FIXUP_THREAD_UMPDOBJS;
    return pfdga;
}

//
// if the return value is a system address, we copy it into user memory
//
IFIMETRICS * APIENTRY NtGdiFONTOBJ_pifi(
    FONTOBJ *pfo
    )
{
    IFIMETRICS  *pifi = NULL, *pifiTmp;

    EXTRACT_THREAD_UMPDOBJS(NULL);

    //
    // Check if this function has already been
    // called during the current DDI entrypoint
    //

    if (! (pfo = pUMObjs->GetDDIOBJ(pfo)) ||
        (pifi = pUMObjs->pifi()) != NULL)
    {
        FIXUP_THREAD_UMPDOBJS;
        return pifi;
    }

    //
    // Call FONTOBJ_pifi and cache the pointer in UMPDOBJ
    //

    RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
    
    UMPDAcquireRFONTSem(rfto, pUMObjs, 0, 0, NULL);

    if ((pifi = FONTOBJ_pifi(pfo)) != NULL &&
        IS_SYSTEM_ADDRESS(pifi))
    {
        pifiTmp = pifi;
        pifi = (PIFIMETRICS) pUMObjs->AllocUserMem(pifi->cjThis);

        if (pifi != NULL)
        {
            RtlCopyMemory (pifi, pifiTmp, pifiTmp->cjThis);
            pUMObjs->pifi(pifi);
        }
    }

    UMPDReleaseRFONTSem(rfto, pUMObjs, NULL, NULL, NULL);
    
    FIXUP_THREAD_UMPDOBJS;
    return pifi;
}


BOOL APIENTRY NtGdiSTROBJ_bEnumInternal(
    STROBJ    *pstro,
    ULONG     *pc,
    PGLYPHPOS *ppgpos,
    BOOL       bPositionsOnly
    )
{
    GLYPHPOS    *pgp, *pgpTmp;
    ULONG       c;
    BOOL        bRet;

    EXTRACT_THREAD_UMPDOBJS(DDI_ERROR);

    //
    // bRet from STROBJ_bEnum could have 3 different values:
    // TRUE: more glyphs remained to be enumurated
    // FALSE: no more glyphs to be enumrated
    // DDI_ERROR: failure
    //

    if ((pstro = pUMObjs->GetDDIOBJ(pstro)) == NULL ||
        ((bRet = bPositionsOnly ? STROBJ_bEnumPositionsOnly(pstro, &c, &pgp) : STROBJ_bEnum(pstro, &c, &pgp)) == DDI_ERROR))
    {
        FIXUP_THREAD_UMPDOBJS;
        return DDI_ERROR;
    }
    else
    {
        // over cautious here
        if (BALLOC_OVERFLOW1(c, GLYPHPOS) ||
            (!(pgpTmp = (GLYPHPOS *) pUMObjs->AllocUserMem(sizeof(GLYPHPOS) * c))))
        {
            FIXUP_THREAD_UMPDOBJS;
            return DDI_ERROR;
        }
    }

    RtlCopyMemory(pgpTmp, pgp, sizeof(GLYPHPOS)*c);

    __try
    {
        ProbeAndWriteStructure(ppgpos, pgpTmp, PVOID);
        ProbeAndWriteUlong(pc, c);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("fail to write in ppgpos or pc\n");
        c = 0;
        bRet = FALSE;
    }

    //
    // NULL out GLYPHPOS.pgdf field to force the driver
    // to call FONTOBJ_cGetGlyphs.
    //

    for (ULONG i=0; i < c; i++)
        pgpTmp[i].pgdf = NULL;

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}

BOOL APIENTRY NtGdiSTROBJ_bEnum(
    STROBJ    *pstro,
    ULONG     *pc,
    PGLYPHPOS *ppgpos
    )
{
    return NtGdiSTROBJ_bEnumInternal(pstro, pc, ppgpos, FALSE);
}

BOOL APIENTRY NtGdiSTROBJ_bEnumPositionsOnly(
    STROBJ    *pstro,
    ULONG     *pc,
    PGLYPHPOS *ppgpos
    )
{
    return NtGdiSTROBJ_bEnumInternal(pstro, pc, ppgpos, TRUE);
}


BOOL APIENTRY NtGdiSTROBJ_bGetAdvanceWidths(
    STROBJ   *pstro,
    ULONG     iFirst,
    ULONG     c,
    POINTQF  *pptqD
)
{

    BOOL      bRet = FALSE;
    POINTQF  *pptqDTmp;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    if ((pstro = pUMObjs->GetDDIOBJ(pstro)) == NULL ||
        BALLOC_OVERFLOW1(c, POINTQF) ||
        !(pptqDTmp = (POINTQF *) pUMObjs->AllocUserMem(sizeof(POINTQF) * c)))
    {
        FIXUP_THREAD_UMPDOBJS;
        return bRet;
    }

    // kernel mode can not fail

    bRet = STROBJ_bGetAdvanceWidths(pstro, iFirst, c,  pptqDTmp);

    if (bRet)
    {
        __try
        {
            ProbeAndWriteAlignedBuffer( pptqD, pptqDTmp, sizeof(POINTQF) * c, sizeof(LARGE_INTEGER));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("fail to write in ppgpos or pc\n");
            bRet = FALSE;
        }
    }
    
    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}



VOID APIENTRY NtGdiSTROBJ_vEnumStart(
    IN STROBJ  *pstro   
   )
{
    EXTRACT_THREAD_UMPDOBJS;

    if ((pstro = pUMObjs->GetDDIOBJ(pstro)) != NULL)
        STROBJ_vEnumStart(pstro);

    FIXUP_THREAD_UMPDOBJS;
}

DWORD APIENTRY NtGdiSTROBJ_dwGetCodePage(
    STROBJ  *pstro
    )

{
    EXTRACT_THREAD_UMPDOBJS(0);

    DWORD dwRet = ((pstro = pUMObjs->GetDDIOBJ(pstro)) != NULL) ?
               STROBJ_dwGetCodePage(pstro) :
               0;

    FIXUP_THREAD_UMPDOBJS;
    return dwRet;
}

//
// private
//
DHPDEV NtGdiGetDhpdev(HDEV hdev)
{
    return ValidUmpdHdev(hdev) ? ((PPDEV)hdev)->dhpdev : NULL;
}

BOOL NtGdiSetPUMPDOBJ(
    HUMPD   humpd,
    BOOL    bStoreID,
    HUMPD   *phumpd,
    BOOL    *pbWOW64
)
{
    UMPDREF umpdRef(humpd);
    
    if (
        (bStoreID && humpd == NULL)     ||
        (bStoreID && umpdRef.pumpdGet() == NULL) ||
        (!bStoreID && phumpd == NULL)
       )
    {
        return FALSE;
    }

    PW32THREAD      pw32thread = W32GetCurrentThread();
    HUMPD           hSaved = pw32thread->pUMPDObj ? (HUMPD)((PUMPDOBJ)pw32thread->pUMPDObj)->hGet() : 0;
    HUMPD           humpdTmp;
    
    if (!bStoreID)
    {
        __try
        {
            ProbeAndReadBuffer(&humpdTmp,phumpd,sizeof(HUMPD));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiSetPUMPDOBJ probe phumpd failed\n");
            return FALSE;
        }
    }
    
    if (bStoreID) 
    {
        BOOL        bWOW64;

        bWOW64 = umpdRef.bWOW64();
        
        __try
        {
            if (pbWOW64)
            {
                ProbeAndWriteBuffer(pbWOW64, &bWOW64, sizeof(BOOL));
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiSetPUMPDOBJ: bad pumpdobj or probe pbWOW64 failed\n");
            return FALSE;
        }
#if defined(_WIN64)
        if (bWOW64)
        {
            ASSERTGDI(pw32thread->pClientID == NULL, "NtGdiSetPUMPDOBJ: existing non-null pClientID\n");

            if (pw32thread->pClientID == NULL)
            {
                KERNEL_PVOID  pclientID = (KERNEL_PVOID)PALLOCMEM(sizeof(PRINTCLIENTID), 'dipG');
                
                if (pclientID)
                {
                    __try
                    {
                        ((PRINTCLIENTID*)pclientID)->clientTid = umpdRef.clientTid();
                        ((PRINTCLIENTID*)pclientID)->clientPid = umpdRef.clientPid();
                        pw32thread->pClientID = pclientID;
    
                        ProbeAndWriteBuffer(phumpd, &hSaved, sizeof(HUMPD));
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        WARNING("NtGdiSetPUMPDOBJ: wow64 failed to access pumpdobj or ppumpdobj\n");
                        pw32thread->pClientID = NULL;
                        VFREEMEM(pclientID);
                        return FALSE;
                    }
                }
                else
                {
                    WARNING("NtGdiSetPUMPDOBJ: failed to allocate pclientID\n");
                    return FALSE;
                }
            }
            else
            {
                WARNING("NtGdiSetPUMPDOBJ: bWOW64 and existing pClientID\n");
                return FALSE;
            }
        }
        else
#endif
        {
            __try
            {
                ProbeAndWriteBuffer(phumpd, &hSaved, sizeof(HUMPD));
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("NtGdiSetPUMPDOBJ: failed to access ppumpdobj\n");
                return FALSE;
            }           
        }
    }
    else
    {
        if (humpdTmp != hSaved)
        {
            WARNING("NtGdiSetPUMPDOBJ: mismatched pumpdobj\n");
            return FALSE;
        }
#if defined(_WIN64)        
        UMPDREF    umpdSaved(hSaved);
        
        ASSERTGDI(umpdSaved.pumpdGet(), "NtGdiSetPUMPDOBJ: saved pumpdobj is NULL\n");

        if (umpdSaved.bWOW64() && pw32thread->pClientID)
        {
            VFREEMEM(pw32thread->pClientID);
            pw32thread->pClientID = NULL;
        }
#endif
    }

    pw32thread->pUMPDObj = umpdRef.pumpdGet();

    return TRUE;
}

//
// private, called only for WOW64 printing
//

BOOL  NtGdiBRUSHOBJ_DeleteRbrush(BRUSHOBJ *pbo, BRUSHOBJ *pboB)
{
    EXTRACT_THREAD_UMPDOBJS(FALSE);
    
    BRUSHOBJ *pbokm;

    if (pbo)
    {
        pbokm = pUMObjs->GetDDIOBJ(pbo);

        if (pbokm && pbokm->pvRbrush && !IS_SYSTEM_ADDRESS(pbokm->pvRbrush))
        {
            EngFreeUserMem(DBRUSHSTART(pbokm->pvRbrush));
            pbokm->pvRbrush = NULL;
        }
    }

    if (pboB)
    {
        pbokm = pUMObjs->GetDDIOBJ(pboB);

        if (pbokm && pbokm->pvRbrush && !IS_SYSTEM_ADDRESS(pbokm->pvRbrush))
        {
            EngFreeUserMem(DBRUSHSTART(pbokm->pvRbrush));
            pbokm->pvRbrush = NULL;
        }
    }

    FIXUP_THREAD_UMPDOBJS;
    return TRUE;
}

// Private, used only for WOW64 printing

BOOL APIENTRY NtGdiUMPDEngFreeUserMem(KERNEL_PVOID *ppv)
{
#if defined(_WIN64)    
    PVOID pv = NULL, pvTmp;

    __try
    {
        if (ppv)
        {
            ProbeAndReadBuffer(&pv, ppv, sizeof(PVOID));            
            ProbeForRead(pv, sizeof(ULONG), sizeof(ULONG));

            // Winbug 397346
            // We are doing the following probing since EngFreeUserMem
            // does NOT try-except/probe while accessing pvTmp.

            pvTmp = (PBYTE)pv - sizeof(ULONG_PTR)*4;
            ProbeForRead(pvTmp, sizeof(ULONG_PTR)*4, sizeof(ULONG_PTR));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("NtGdiUMPDEngFreeUserMem: bad input pointer\n"); 
        return FALSE;
    }
    
    if (pv)
       EngFreeUserMem(pv);
#endif
    
    return TRUE;
    
}


HSURF APIENTRY NtGdiEngCreateDeviceSurface(
    DHSURF  dhsurf, 
    SIZEL  sizl,    
    ULONG  iFormatCompat    
   )
{
    TRACE_INIT (("Entering NtGdiEngCreateDeviceSurface\n"));

    if ((iFormatCompat > BMF_8RLE) || (iFormatCompat < BMF_1BPP))
        return 0;

    //
    // set high bit of iFormatCompat to indicate umpd driver
    //
    return (EngCreateDeviceSurface(dhsurf, sizl, iFormatCompat|= UMPD_FLAG));
}

HBITMAP APIENTRY NtGdiEngCreateDeviceBitmap(
    DHSURF dhsurf,
    SIZEL sizl,
    ULONG iFormatCompat
    )
{
    if (!ValidUmpdSizl(sizl))
        return 0;

    if ((iFormatCompat > BMF_8RLE) || (iFormatCompat < BMF_1BPP))
        return 0;

    return EngCreateDeviceBitmap(dhsurf, sizl, iFormatCompat | UMPD_FLAG);
}

VOID APIENTRY NtGdiPATHOBJ_vGetBounds(
    IN PATHOBJ  *ppo,   
    OUT PRECTFX  prectfx    
   )
{
    RECTFX     rectfx;
    EXTRACT_THREAD_UMPDOBJS;

    ppo = pUMObjs->GetDDIOBJ(ppo);

    if (ppo)
    {
       PATHOBJ_vGetBounds(ppo, &rectfx);

       __try
       {
           ProbeAndWriteStructure(prectfx, rectfx, RECTFX);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING("fail to write into prectfx\n");
       }
    }

    FIXUP_THREAD_UMPDOBJS;
}

BOOL APIENTRY NtGdiPATHOBJ_bEnum(
    IN PATHOBJ  *ppo,   
    OUT PATHDATA  *ppd  
   )
{
    PATHDATA    pathdata;
    BOOL        bRet = FALSE;
    PVOID       pvTmp = NULL;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    if (ppo = pUMObjs->GetDDIOBJ(ppo))
    {
        bRet = PATHOBJ_bEnum(ppo, &pathdata);

        // over cautious
        if (BALLOC_OVERFLOW1(pathdata.count, POINTFIX))
        {
            FIXUP_THREAD_UMPDOBJS;
            return FALSE;
        }

        if (pvTmp = pUMObjs->AllocUserMem(sizeof(POINTFX) * pathdata.count))
        {
            RtlCopyMemory(pvTmp, pathdata.pptfx, sizeof(POINTFX) * pathdata.count);
            pathdata.pptfx = (POINTFIX *) pvTmp;
        }
        else
            bRet = FALSE;
    }

    if (pvTmp == NULL)
        RtlZeroMemory(&pathdata, sizeof(pathdata));

    __try
    {
        ProbeAndWriteStructure(ppd, pathdata, PATHDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("fail to write into ppd\n");
        bRet = FALSE;
    }

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}


VOID APIENTRY NtGdiPATHOBJ_vEnumStart(
    IN PATHOBJ  *ppo    
   )
{
    EXTRACT_THREAD_UMPDOBJS;

    if ((ppo = pUMObjs->GetDDIOBJ(ppo)) != NULL)
        PATHOBJ_vEnumStart(ppo);

    FIXUP_THREAD_UMPDOBJS;
}

VOID APIENTRY NtGdiPATHOBJ_vEnumStartClipLines(
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    SURFOBJ   *pso,
    LINEATTRS *pla
    )

{
    LINEATTRS   lineattrs;

    EXTRACT_THREAD_UMPDOBJS;

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();
    ppo = pUMObjs->GetDDIOBJ(ppo);

    if (pso && ppo && bCaptureLINEATTRS(&pla, &lineattrs))
    {
        pco = pUMObjs->GetDDIOBJ(pco, &pso->sizlBitmap);
        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        if (pla && pla->pstyle)
            VFREEMEM(pla->pstyle);
    }

    FIXUP_THREAD_UMPDOBJS;
}


BOOL APIENTRY NtGdiPATHOBJ_bEnumClipLines(
    PATHOBJ  *ppo,
    ULONG     cb,
    CLIPLINE *pcl
    )

{
    BOOL    bRet = FALSE;
    PVOID   pvTmp = NULL;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    if (cb <= sizeof(CLIPLINE))
    {
        FIXUP_THREAD_UMPDOBJS;
        return(FALSE);
    }

    if ((ppo = pUMObjs->GetDDIOBJ(ppo)) != NULL &&
        (pvTmp = PALLOCNOZ(cb, UMPD_MEMORY_TAG)) != NULL)
    {
        bRet = PATHOBJ_bEnumClipLines(ppo, cb, (CLIPLINE *) pvTmp);
    }

    __try
    {
        ProbeForWrite(pcl, cb, sizeof(ULONG));

        if (pvTmp != NULL)
            RtlCopyMemory(pcl, pvTmp, cb);
        else
            RtlZeroMemory(pcl, cb);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
    }

    if (pvTmp != NULL)
        VFREEMEM(pvTmp);

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}


PVOID APIENTRY  NtGdiFONTOBJ_pvTrueTypeFontFile(
    IN FONTOBJ  *pfo,   
    OUT ULONG  *pcjFile 
   )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    PVOID   pBase, p = NULL;
    ULONG   size;

    if ((pfo = pUMObjs->GetDDIOBJ(pfo)) != NULL &&
        (p = pUMObjs->pvFontFile(&size)) == NULL &&
        (p = FONTOBJ_pvTrueTypeFontFileUMPD(pfo, &size, &pBase)) != NULL)
    {
        pUMObjs->pvFontFile(p, pBase, size);
    }

    if (p == NULL)
        size = 0;

    if (pcjFile != NULL)
    {
        __try
        {
            ProbeAndWriteStructure(pcjFile, size, DWORD);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("fail to write into pcjFilie\n");
            p = NULL;
        }
    }

    FIXUP_THREAD_UMPDOBJS;
    return p;
}

HANDLE APIENTRY NtGdiXLATEOBJ_hGetColorTransform(
    XLATEOBJ *pxlo
    )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    HANDLE hRet = ((pxlo = pUMObjs->GetDDIOBJ(pxlo)) != NULL) ?
                XLATEOBJ_hGetColorTransform(pxlo) :
                NULL;

    FIXUP_THREAD_UMPDOBJS;
    return hRet;
}

ULONG APIENTRY NtGdiXLATEOBJ_cGetPalette(
    IN XLATEOBJ* pxlo,  
    IN ULONG     iPal,  
    IN ULONG     cPal,  
    IN ULONG     *pPal  
   )
{
    ULONG       ulRet = 0;
    ULONG       *pPalTmp = NULL;

    EXTRACT_THREAD_UMPDOBJS(0);

    pxlo = pUMObjs->GetDDIOBJ(pxlo);

    if (pxlo)
    {
       if (pPal)
       {
           if (BALLOC_OVERFLOW1(cPal, DWORD))
           {
               FIXUP_THREAD_UMPDOBJS;
               return 0;
           }

           pPalTmp = (PULONG)PALLOCNOZ(sizeof(DWORD)*cPal, UMPD_MEMORY_TAG);
       }

       if (pPalTmp)
       {
          ulRet = XLATEOBJ_cGetPalette(pxlo, iPal, cPal, pPalTmp);

          if (ulRet)
          {
              if (!bSafeCopyBits(pPal, pPalTmp, sizeof(DWORD)*cPal))
              ulRet = 0;
          }

          VFREEMEM(pPalTmp);
       }
    }

    FIXUP_THREAD_UMPDOBJS;
    return ulRet;
}

ULONG APIENTRY NtGdiXLATEOBJ_iXlate(
    IN XLATEOBJ  *pxlo, 
    IN ULONG  iColor    
   )
{
    EXTRACT_THREAD_UMPDOBJS(0xffffffff);

    ULONG ulRet = ((pxlo = pUMObjs->GetDDIOBJ(pxlo)) != NULL ? XLATEOBJ_iXlate(pxlo, iColor) : NULL);

    FIXUP_THREAD_UMPDOBJS;

    return ulRet;
}

BOOL APIENTRY NtGdiEngCheckAbort(
    SURFOBJ *pso
    )

{
    EXTRACT_THREAD_UMPDOBJS(TRUE);

    UMPDSURFOBJ umso(pso, pUMObjs);
    pso = umso.pso();

    BOOL bRet = pso ? EngCheckAbort(pso) : TRUE;

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}

//
// Ported from EngComputeGlyphSet with necessary changes
//

FD_GLYPHSET* APIENTRY NtGdiEngComputeGlyphSet(
    INT nCodePage,
    INT nFirstChar,
    INT cChars
    )

{
    FD_GLYPHSET *pGlyphSet, *pGlyphSetTmp = NULL;
    ULONG       cjSize;

    EXTRACT_THREAD_UMPDOBJS(NULL);

    //
    // Call kernel-mode EngComputeGlyphSet first and then copy
    // the FD_GLYPHSET structure into a temporary user-mode buffer
    //

    if ((pGlyphSet = EngComputeGlyphSet(nCodePage, nFirstChar, cChars)) &&
        (cjSize = pGlyphSet->cjThis) &&
        (pGlyphSetTmp = (PFD_GLYPHSET) pUMObjs->AllocUserMem(cjSize)))
    {
        if (!GreCopyFD_GLYPHSET(pGlyphSetTmp, pGlyphSet, cjSize, TRUE))
            pGlyphSetTmp = NULL;
    }

    //
    // Free the kernel copy of the FD_GLYPHSET structure right away
    //

    if (pGlyphSet)
        EngFreeMem(pGlyphSet);

    FIXUP_THREAD_UMPDOBJS;

    return (pGlyphSetTmp);
}

LONG APIENTRY NtGdiHT_Get8BPPFormatPalette(
    LPPALETTEENTRY  pPaletteEntry,
    USHORT          RedGamma,
    USHORT          GreenGamma,
    USHORT          BlueGamma
    )
{
    if (pPaletteEntry)
    {
       LPPALETTEENTRY  pPal = NULL;
       ULONG ulRet = 0;
       ULONG c = HT_Get8BPPFormatPalette(NULL, RedGamma, GreenGamma, BlueGamma);

       if (c)
       {
           if (BALLOC_OVERFLOW1(c, PALETTEENTRY))
               return 0;

           pPal = (LPPALETTEENTRY)PALLOCNOZ(c*sizeof(PALETTEENTRY), UMPD_MEMORY_TAG);
       }

       if (pPal)
       {
           ulRet = HT_Get8BPPFormatPalette(pPal, RedGamma, GreenGamma, BlueGamma);

           if (!bSafeCopyBits(pPaletteEntry, pPal, c*sizeof(PALETTEENTRY)))
               ulRet = 0;

           VFREEMEM(pPal);
       }

       return ulRet;
    }
    else
        return  HT_Get8BPPFormatPalette(NULL, RedGamma, GreenGamma, BlueGamma);

}


LONG APIENTRY NtGdiHT_Get8BPPMaskPalette(
    LPPALETTEENTRY  pPaletteEntry,
    BOOL            Use8BPPMaskPal,
    BYTE            CMYMask,
    USHORT          RedGamma,
    USHORT          GreenGamma,
    USHORT          BlueGamma
    )
{
    LONG    c = HT_Get8BPPMaskPalette(NULL, Use8BPPMaskPal, CMYMask, RedGamma, GreenGamma, BlueGamma);

    if (pPaletteEntry) {

        LPPALETTEENTRY  pPal = NULL;
        LONG            cbPal;

        if (((cbPal = c * sizeof(PALETTEENTRY)) > 0)                    &&
            (!BALLOC_OVERFLOW1(c, PALETTEENTRY))                        &&
            (pPal = (LPPALETTEENTRY)PALLOCNOZ(cbPal, UMPD_MEMORY_TAG))  &&
            (bSafeReadBits(pPal, pPaletteEntry, cbPal))                 &&
            (c = HT_Get8BPPMaskPalette(pPal,
                                       Use8BPPMaskPal,
                                       CMYMask,
                                       RedGamma,
                                       GreenGamma,
                                       BlueGamma))                      &&
            (bSafeCopyBits(pPaletteEntry, pPal, cbPal))) {

            NULL;

        } else {

            c = 0;
        }

        if (pPal) {

           VFREEMEM(pPal);
        }
    }

    return(c);
}

#endif // !_GDIPLUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\umpdobj.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    umpdobj.cxx

Abstract:

    Object and memory management for um-km thunking

Environment:

    Windows NT user mode driver support

Revision History:

    09/16/97 -davidx-
        Created it.

--*/

#include "precomp.hxx"


#if !defined(_GDIPLUS_)

//
// Maximum number of pages for UMPD user mode memory heap
//

#define MAX_UMPD_HEAP   1024

//
// Create or initialize a UMPD user mode memory heap
//

PUMPDHEAP
UMPDOBJ::CreateUMPDHeap(void)
{
    PUMPDHEAP   pHeap;

    //
    // Allocate memory to hold the UMPDHEAP structure if necessary
    //

    if (!(pHeap = (PUMPDHEAP) PALLOCMEM(sizeof(UMPDHEAP), UMPD_MEMORY_TAG)))
        return NULL;

    //
    // Reserve the maximum address range if needed
    //

    NTSTATUS    Status;
    PVOID       p = NULL;
    SIZE_T      cj = MAX_UMPD_HEAP * PAGE_SIZE;

    Status = ZwAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &p,
                    0,
                    &cj,
                    MEM_RESERVE,
                    PAGE_READWRITE);

    if (NT_SUCCESS(Status))
        pHeap->pAddress = p;
    else
    {
        VFREEMEM(pHeap);
        return NULL;
    }

    pHeap->AllocSize = 0;

    return pHeap;
}

VOID
UMPDOBJ::ResetHeap()
{
    ASSERTGDI(bWOW64(), "UMPDOBJ__ResetHeap called by none WOW64 printing\n");

    PROXYPORT proxyport(m_proxyPort);

    proxyport.HeapInit();
}

PUMPDHEAP
UMPDOBJ::InitUMPDHeap(
    PUMPDHEAP   pHeap
    )

{
    pHeap->AllocSize = 0;
    return pHeap;
}

//
// Grow a UMPD user mode memory heap by one more page
//

BOOL
UMPDOBJ::GrowUMPDHeap(
    PUMPDHEAP   pHeap,
    ULONG       ulBytesNeeded
    )

{
    PVOID       p;
    SIZE_T      NewCommitSize;
    HANDLE      hNewSecure;
    NTSTATUS    Status;

    NewCommitSize = ROUNDUP_MULTIPLE(pHeap->CommitSize + ulBytesNeeded, PAGE_SIZE);

    if (NewCommitSize > MAX_UMPD_HEAP * PAGE_SIZE)
    {
        WARNING("Not enough space for UMPD user mode memory heap\n");
        return FALSE;
    }

    //
    // Commit one more page and secure it
    //

    p = pHeap->pAddress;

    Status = ZwAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &p,
                    0,
                    &NewCommitSize,
                    MEM_COMMIT,
                    PAGE_READWRITE);

    hNewSecure = NT_SUCCESS(Status) ?
                    MmSecureVirtualMemory(p, NewCommitSize, PAGE_READWRITE) :
                    NULL;

    if (hNewSecure == NULL)
    {
        WARNING("Failed to commit/secure more UMPD user mode memory\n");
        return FALSE;
    }

    if (pHeap->hSecure)
        MmUnsecureVirtualMemory(pHeap->hSecure);

    pHeap->hSecure = hNewSecure;
    pHeap->CommitSize = NewCommitSize;

    return TRUE;
}

//
// Destroy a UMPD user mode memory heap
//

VOID
DestroyUMPDHeap(
    PUMPDHEAP   pHeap
    )

{
    if (pHeap != NULL)
    {
        if (pHeap->hSecure)
            MmUnsecureVirtualMemory(pHeap->hSecure);

        if (pHeap->pAddress != NULL)
        {
            PVOID   pv = pHeap->pAddress;
            SIZE_T  cj = MAX_UMPD_HEAP * PAGE_SIZE;

            ZwFreeVirtualMemory(NtCurrentProcess(), &pv, &cj, MEM_RELEASE);
        }

        VFREEMEM(pHeap);
    }
}


//
// UMPDOBJ constructor
//

BOOL
UMPDOBJ::Init()
{
    PW32THREAD pThread;
    PW32PROCESS pw32Process;
    ULONG_PTR pPeb32;
#if defined(_WIN64)
    BOOL    bWOW64 = TRUE;
#endif
    RtlZeroMemory(this, sizeof(UMPDOBJ));

    m_magic = UMPD_MEMORY_TAG;

    pThread = W32GetCurrentThread();

    m_pNext = (PUMPDOBJ) pThread->pUMPDObjs;
#if defined(_WIN64)    
    if (pThread->pProxyPort == NULL)
    {
        pw32Process = W32GetCurrentProcess();

        if (pw32Process->W32PF_Flags & W32PF_WOW64)
        {
            PROXYPORT proxyport(MAX_UMPD_HEAP * PAGE_SIZE);

            if (proxyport.bValid())
            {
                pThread->pProxyPort = proxyport.GetProxyPort();
            }
            else
            {
                return FALSE;
            }
        }
        else
            bWOW64 = FALSE;
    }

    if (bWOW64)
    {
        m_proxyPort = (ProxyPort *) pThread->pProxyPort;

        ResetHeap();
    }
    else
#endif
    {
        // WINBUG 364408 what happens if these heaps fail to initialize?
        if (m_pNext == NULL)
        {
            if(pThread->pUMPDHeap == NULL)
            {
                pThread->pUMPDHeap = m_pHeap = CreateUMPDHeap();
            }
            else
            {
                m_pHeap = InitUMPDHeap((PUMPDHEAP) pThread->pUMPDHeap);
            }
        }
        else
        {
            m_pHeap = CreateUMPDHeap();
        }
    }
    
    m_clientTid = (PW32THREAD)PsGetCurrentThread();
    m_clientPid = W32GetCurrentPID();

    if (HmgInsertObject(this, HMGR_ALLOC_ALT_LOCK, UMPD_TYPE) == NULL)
    {
        return FALSE;
    }

    pThread->pUMPDObjs = (PVOID) this;

    return TRUE;
}

//
// UMPDOBJ destructor
//

VOID UMPDOBJ::Cleanup()
{
    W32GetCurrentThread()->pUMPDObjs = (PVOID) m_pNext;

    if (HmgRemoveObject((HOBJ)hGet(), 0, 1, TRUE, UMPD_TYPE))
    {
        //
        // Delete any PATHOBJ's returned by CLIPOBJ_ppoGetPath
        //
    
        if (m_poClip.kmobj != NULL)
            EngDeletePath((PATHOBJ *) m_poClip.kmobj);
    
        //
        // Destroy UMPD user mode memory heap if necessary
        //
    
        if(!bWOW64())
        {
            if (m_pNext != NULL && m_pHeap != NULL)
                    DestroyUMPDHeap(m_pHeap);
        }
    
        //
        // Unmap any cached font file view
        //
    
        if (m_pvFontBase != NULL)
            MmUnmapViewOfSection(m_pFontProcess, m_pvFontBase);
    
        vFreeFontLinks();
    }
    else
    {
        ASSERTGDI(FALSE, "UMPDOBJ::Cleanup() leaking UMPD handle\n");
    }    
}



BOOL UMPDOBJ::pxlo(
    XLATEOBJ   **ppxlo
    )

/*++

Routine Description:

    Thunk an XLATEOBJ to user mode

Arguments:

    ppxlo - Address of the variable containing the pointer to the kernel mode
        XLATEOBJ to be thunked. Upon returning from this function, the variable
        contains the user mode object corresponding to the specified kernel mode object.

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    XLATEOBJ    *kmobj;
    PULONG      pulXlate;

    if ((kmobj = *ppxlo) == NULL)
        return TRUE;

    //
    // Copy the color lookup table
    //

    if (kmobj->cEntries)
    {
        PULONG  pulSrc;

        if ((pulXlate = (PULONG) AllocUserMem(kmobj->cEntries * sizeof(ULONG))) == NULL ||
            (pulSrc = kmobj->pulXlate) == NULL &&
            (pulSrc = XLATEOBJ_piVector(kmobj)) == NULL)
        {
            WARNING("Couldn't get XLATEOBJ color lookup table\n");
            return FALSE;
        }

        RtlCopyMemory(GetKernelPtr(pulXlate), pulSrc, kmobj->cEntries * sizeof(ULONG));
    }
    else
        pulXlate = NULL;

    //
    // Perform the standard object thunk
    //

    if (!ThunkDDIOBJ(&m_xlo, (PVOID *) ppxlo, sizeof(XLATEOBJ)))
        return FALSE;

    XLATEOBJ * pxlo = (XLATEOBJ *) GetKernelPtr(*ppxlo);

    pxlo->pulXlate = pulXlate;

    return TRUE;
}



BOOL UMPDOBJ::pso(
    PDDIOBJMAP  pMap,
    SURFOBJ     **ppso,
    BOOL        bLargeBitmap
    )

/*++

Routine Description:

    Thunk an SURFOBJ to user mode

Arguments:

    pMap - Address of the um-to-km object mapping structure

    ppso - Address of the variable containing the pointer to the kernel mode
        SURFOBJ to be thunked. Upon returning from this function, the variable
        contains the user mode object corresponding to the specified kernel mode object.

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    SURFOBJ     *kmobj;
    PVOID       pvBits;

    if ((kmobj = *ppso) == NULL)
        return TRUE;

    //
    // If we're thunking a bitmap surface and the bitmap memory
    // is in kernel address space, we need to make a copy of it
    // in user address space.
    //

    if ((pvBits = kmobj->pvBits) != NULL &&
        (kmobj->iType == STYPE_BITMAP) &&
        bNeedThunk(kmobj->pvBits) &&
        !(bWOW64() && bLargeBitmap))
    {
        if (! ThunkMemBlock(&pvBits, kmobj->cjBits))
            return FALSE;
    }

    //
    // Perform the standard object thunk
    //

    if (! ThunkDDIOBJ(pMap, (PVOID *) ppso, sizeof(SURFOBJ)))
        return FALSE;

    SURFOBJ * pso = (SURFOBJ *) GetKernelPtr(*ppso);

    if (pvBits != kmobj->pvBits)
    {
        pso->pvBits = pvBits;
        pso->pvScan0 = (PBYTE) pvBits + ((PBYTE) kmobj->pvScan0 - (PBYTE) kmobj->pvBits);

        //
        //  umpd64 only
        //

        if (bWOW64())
        {
            kmobj->pvBits = pvBits;
            kmobj->pvScan0 = pso->pvScan0;
        }
    }

    return TRUE;
}


BOOL UMPDOBJ::pstro(
    STROBJ  **ppstro
    )

/*++

Routine Description:

    Thunk an STROBJ to user mode

Arguments:

    ppstro - Address of the variable containing the pointer to the kernel mode
        STROBJ to be thunked. Upon returning from this function, the variable
        contains the user mode object corresponding to the specified kernel mode object.

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    STROBJ      *kmobj;
    PWSTR       pwszOrg;
    GLYPHPOS    *pgp;

    if ((kmobj = *ppstro) == NULL)
        return TRUE;

    //
    // Thunk STROBJ.pwszOrg field
    //

    if ((pwszOrg = kmobj->pwszOrg) != NULL &&
        !ThunkMemBlock((PVOID *) &pwszOrg, sizeof(WCHAR) * kmobj->cGlyphs))
    {
        return FALSE;
    }

    //
    // Thunk STROBJ.pgp field
    //

    if ((pgp = kmobj->pgp) != NULL)
    {
        if (! ThunkMemBlock((PVOID *) &pgp, sizeof(GLYPHPOS) * kmobj->cGlyphs))
            return FALSE;

        //
        // NULL out GLYPHPOS.pgdf field to force the driver
        // to call FONTOBJ_cGetGlyphs.
        //
        GLYPHPOS    *kmpgp = (GLYPHPOS *) GetKernelPtr(pgp);

        for (ULONG i=0; i < kmobj->cGlyphs; i++)
            kmpgp[i].pgdf = NULL;
    }

    //
    // Perform the standard object thunk
    //

    if (!ThunkDDIOBJ(&m_stro, (PVOID *) ppstro, sizeof(STROBJ)))
        return FALSE;

    STROBJ * pstro = (STROBJ *) GetKernelPtr(*ppstro);

    pstro->pwszOrg = pwszOrg;
    pstro->pgp = pgp;

    return TRUE;
}



BOOL UMPDOBJ::ThunkLINEATTRS(
    PLINEATTRS *pplineattrs
    )

/*++

Routine Description:

    Thunk a LINEATTRS structure from kernel mode to user mode

Arguments:

    pplineattrs - On input, contains the address of the kernel mode
        LINEATTRS structure to be thunked. On output, contains the
        address of the thunked user mode copy of LINEATTRS structure.

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PLINEATTRS  plineattrsKM;
    PVOID       pStyle;
    ULONG       ulStyleSize;

    if ((plineattrsKM = *pplineattrs) == NULL)
        return TRUE;

    pStyle = plineattrsKM->pstyle;
    ulStyleSize = plineattrsKM->cstyle * sizeof(FLOAT_LONG);

    if (! ThunkMemBlock((PVOID *) pplineattrs, sizeof(LINEATTRS)) ||
        ! ThunkMemBlock(&pStyle, ulStyleSize))
    {
        return FALSE;
    }
    else
    {
        PLINEATTRS plineattrs = (PLINEATTRS) GetKernelPtr(*pplineattrs);

        plineattrs->pstyle = (PFLOAT_LONG) pStyle;
        return TRUE;
    }
}


PATHOBJ *UMPDOBJ::GetCLIPOBJPath(
    CLIPOBJ *pco
    )

/*++

Routine Description:

    Implement CLIPOBJ_ppoGetPath for user mode printer driver

Arguments:

    pco - Points to a user mode CLIPOBJ

Return Value:

    Pointer to user mode PATHOBJ structure
    NULL if there is an error

--*/

{
    PATHOBJ *ppokm, *ppoum;

    //
    // Note: During the same DDI entrypoint, drivers must
    // call EngDeletePath after each CLIPOBJ_ppoGetPath.
    //

    if (m_poClip.umobj ||
        ! (ppokm = ppoum = (pco = GetDDIOBJ(pco)) ? CLIPOBJ_ppoGetPath(pco) : NULL))
    {
        return NULL;
    }

    if (! ppoClip(&ppoum))
    {
        EngDeletePath(ppokm);
        return NULL;
    }

    return ppoum;
}



VOID UMPDOBJ::DeleteCLIPOBJPath(
    PATHOBJ *ppo
    )

/*++

Routine Description:

    Implement EngDeletePath for user mode printer driver

Arguments:

    ppo - Points to user mode PATHOBJ to be deleted.
        This pointer must come from GetCLIPOBJPath.

Return Value:

    NONE

--*/

{
    if (ppo != NULL && ppo == m_poClip.umobj)
    {
        EngDeletePath((PATHOBJ *) m_poClip.kmobj);
        m_poClip.umobj = m_poClip.kmobj = NULL;
    }
}



CLIPOBJ *UMPDOBJ::CreateCLIPOBJ()

/*++

Routine Description:

    Implement EngCreateClip for user-mode drivers

Arguments:

    NONE

Return Value:

    Pointer to user mode CLIPOBJ structure
    NULL if there is an error

--*/

{
    CLIPOBJ *pcokm, *pcoum;

    //
    // Note: During the same DDI entrypoint, drivers must
    // call EngDeleteClip after each EngCreateClip.
    //

    if (m_coCreated.umobj ||
        ! (pcokm = pcoum = EngCreateClip()))
    {
        return NULL;
    }

    if (! pcoCreated(&pcoum))
    {
        EngDeleteClip(pcokm);
        return NULL;
    }

    return pcoum;
}



VOID UMPDOBJ::DeleteCLIPOBJ(
    CLIPOBJ *pco
    )

/*++

Routine Description:

    Implement EngDeleteClip for user-mode drivers

Arguments:

    pco - Points to user-mode CLIPOBJ to be deleted
        This must have come from EngCreateClip.

Return Value:

    NONE

--*/

{
    if (pco != NULL && pco == m_coCreated.umobj)
    {
        EngDeleteClip((CLIPOBJ *) m_coCreated.kmobj);
        m_coCreated.umobj = m_coCreated.kmobj = NULL;
    }
}



XFORMOBJ *UMPDOBJ::GetFONTOBJXform(
    FONTOBJ *pfo
    )

/*++

Routine Description:

    Implement FONTOBJ_pxoGetXform for user mode printer driver

Arguments:

    pfo - Points to a user mode FONTOBJ

Return Value:

    Pointer to a user mode XFORMOBJ structure
    NULL if there is an error

--*/

{
    XFORMOBJ *pxo;

    //
    // Check if this function has been called already
    // during the current DDI entrypoint
    //

    if (! (pfo = GetDDIOBJ(pfo)))
        return NULL;

    if (m_xoFont.umobj != NULL)
        pxo = (XFORMOBJ *) m_xoFont.umobj;
    else
    {
        RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
        
        UMPDAcquireRFONTSem(rfto, this, 0, 0, NULL);

        if (!(pxo = FONTOBJ_pxoGetXform(pfo)) || !pxoFont(&pxo))
            pxo = NULL;

        UMPDReleaseRFONTSem(rfto, this, NULL, NULL, NULL);
    }

    return pxo;
}



GLYPHBITS *UMPDOBJ::CacheGlyphBits(
    GLYPHBITS *pgb
    )

/*++

Routine Description:

    Thunk and cache GLYPHBITS structure returned by FONTOBJ_cGetGlyphs

Arguments:

    pgb - Points to kernel mode GLYPHBITS structure

Return Value:

    Pointer to user mode GLYPHBITS structure
    NULL if there is an error

--*/

{
    GLYPHBITS  *pgbum = NULL;
    ULONG       ulSize;

    ASSERTGDI(pgb != NULL, "No glyph bits!\n");

    ulSize = offsetof(GLYPHBITS, aj) +
             ((pgb->sizlBitmap.cx + 7) / 8) * pgb->sizlBitmap.cy;

    if (ulSize <= m_gbSize)
    {
        //
        // Reuse previous GLYPHBITS buffer if possible
        //

        pgbum = m_pgb;
    }
    else
    {
        if ((pgbum = (GLYPHBITS *) AllocUserMem(ulSize)) != NULL)
        {
            m_pgb = pgbum;
            m_gbSize = ulSize;
        }
    }

    if (pgbum != NULL)
        RtlCopyMemory(pgbum, pgb, ulSize);

    return pgbum;
}



PATHOBJ *UMPDOBJ::CacheGlyphPath(
    PATHOBJ *ppo
    )

/*++

Routine Description:

    Thunk and cache PATHOBJ structure returned by FONTOBJ_cGetGlyphs

Arguments:

    pgb - Points to kernel mode PATHOBJ structure

Return Value:

    Pointer to user mode PATHOBJ structure
    NULL if there is an error

--*/

{
    ASSERTGDI(ppo != NULL, "No glyph path!\n");

    if (m_poGlyph.umobj != NULL)
    {
        //
        // Reuse the previous PATHOBJ if possible
        //

        *((PATHOBJ *) m_poGlyph.umobj) = *ppo;
        m_poGlyph.kmobj = ppo;

        ppo = (PATHOBJ *) m_poGlyph.umobj;
    }
    else if (! ppoGlyph(&ppo))
        ppo = NULL;

    return ppo;
}



//
// User mode data structure used for storing the surface object
// thunked by UMPDOBJ::LockSurface.
//

typedef struct _UMSO {

    DWORD   dwSignature;
    HSURF   hsurf;
    SURFOBJ so;

} UMSO, *PUMSO;

#define UMSO_SIGNATURE  'UMSO'



SURFOBJ *UMPDOBJ::LockSurface(
    HSURF   hsurf
    )

/*++

Routine Description:

    Implement EngLockSurface for user mode printer driver

Arguments:

    hsurf - Handle to the surface to be locked

Return Value:

    Pointer to a user-mode SURFOBJ structure corresponding to
    the specified surface handle. NULL if there is an error.

--*/

{
    SURFOBJ *psokm;
    PUMSO   pumso = NULL;

    if (hsurf == NULL || (psokm = EngLockSurface(hsurf)) == NULL)
        return NULL;

    //
    // Check if the surface bitmap uses kernel mode memory
    //

    if (psokm->pvBits != NULL &&
        psokm->iType == STYPE_BITMAP &&
        IS_SYSTEM_ADDRESS(psokm->pvBits))
    {
        WARNING("EngLockSurface can't handle kernel mode bitmap\n");
    }
    else if (pumso = (PUMSO) EngAllocUserMem(sizeof(UMSO), UMPD_MEMORY_TAG))
    {
        //
        // We're can't allocate memory from our cache here because
        // pso returned by EngLockSurface may potentially out-live
        // the current DDI entrypoint and/or the current thread.
        //

        pumso->dwSignature = UMSO_SIGNATURE;
        pumso->hsurf = hsurf;
        pumso->so = *psokm;

        //
        // if this is a surface that has been called by EngAssociateSurface,
        // we give them back the original dhpdev
        //
        if (pumso->so.dhpdev)
        {
            PUMDHPDEV pUMdhpdev = (PUMDHPDEV)pumso->so.dhpdev;
            pumso->so.dhpdev = pUMdhpdev->dhpdev;
        }
    }

    EngUnlockSurface(psokm);

    return pumso ? &pumso->so : NULL;
}



VOID UMPDOBJ::UnlockSurface(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Implement EngUnlockSurface for user mode printer driver

Arguments:

    pso - Pointer to user mode SURFOBJ to be unlocked

Return Value:

    NONE

--*/

{
    PUMSO   pumso;

    if (pso != NULL)
    {
        __try
        {
           pumso = (PUMSO) ((PBYTE) pso - offsetof(UMSO, so));

           ProbeForRead (pumso, sizeof(UMSO), sizeof(BYTE));

           if (pumso->dwSignature != UMSO_SIGNATURE ||
               pumso->hsurf == NULL)
           {
               WARNING("Invalid surface in EngUnlockSurface\n");
               return;
           }

           EngFreeUserMem(pumso);

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("Bad user mode SURFOBJ\n");
        }

    }
}



SURFOBJ *UMPDSURFOBJ::GetLockedSURFOBJ(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Map a user mode SURFOBJ to its kernel mode counterpart.
    This pointer must be returned by a previous called to
    UMPDOBJ::LockSurface.

Arguments:

    pso - Pointer to user mode SURFOBJ

Return Value:

    Pointer to kernel mode SURFOBJ corresponding to the specified
    user mode SURFOBJ. NULL if there is an error.

--*/

{
    PUMSO   pumso;
    HSURF   hsurf = NULL;

    if (pso != NULL)
    {
        __try
        {
            pumso = (PUMSO) ((PBYTE) pso - offsetof(UMSO, so));

            ProbeForRead (pumso, sizeof(UMSO), sizeof(BYTE));

            if (pumso->dwSignature == UMSO_SIGNATURE)
                hsurf = pumso->hsurf;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("Bad user mode SURFOBJ\n");
            hsurf = NULL;
        }
    }

    return hsurf ? EngLockSurface(hsurf) : NULL;
}

#endif // !_GDIPLUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\xformddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: xformddi.cxx
*
* Transform DDI callback routines.
*
* Created: 13-May-1991 19:08:43
* Author: Wendy Wu [wendywu]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* BOOL XFORMOBJ_bApplyXform(
*  XFORMOBJ    *pxo,
*  ULONG       iMode,
*  ULONG       cPoints,
*  PVOID       pvIn,
* PVOID       pvOut)
*
* Applies the transform or its inverse to the given array of points.
*
* History:
*  13-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL XFORMOBJ_bApplyXform(
 XFORMOBJ    *pxo,
 ULONG       iMode,
 ULONG       cPoints,
 PVOID       pvIn,
 PVOID       pvOut)
{
    if (pxo == NULL)
        return(FALSE);

    if ((pvIn == NULL) || (pvOut == NULL))
        return(FALSE);

    if (iMode == XF_LTOL)
    {
        if (pvIn == pvOut)
            return(((EXFORMOBJ *)pxo)->bXform((PPOINTL)pvIn,(UINT)cPoints));

        if (((EXFORMOBJ *)pxo)->bXform((PPOINTL)pvIn, (PPOINTFIX)pvOut,
                                       (UINT)cPoints))
        {
            PPOINTL pptl = (PPOINTL)pvOut;
            PPOINTL pptlEnd = pptl + cPoints;
            while (pptl < pptlEnd)
            {
                pptl->x = (pptl->x + 8) >> 4;       // FXTOLROUND
                pptl->y = (pptl->y + 8) >> 4;       // FXTOLROUND
                pptl++;
            }
            return(TRUE);
        }
        return(FALSE);
    }

    if (iMode == XF_LTOFX)
        return(((EXFORMOBJ *)pxo)->bXform((PPOINTL)pvIn, (PPOINTFIX)pvOut,
                                          (UINT)cPoints));

    MATRIX  mx;
    EXFORMOBJ xo(&mx, DONT_COMPUTE_FLAGS);

    if (xo.bInverse(*((EXFORMOBJ *)pxo)))
    {
        if (iMode == XF_INV_LTOL)
        {
            if (pvIn == pvOut)
                return(xo.bXform((PPOINTL)pvIn,(UINT)cPoints));

            PPOINTL pptl = (PPOINTL)pvIn;
            PPOINTL pptlEnd = pptl + cPoints;
            while (pptl < pptlEnd)
            {
                pptl->x <<= 4;
                pptl->y <<= 4;
                pptl++;
            }

            BOOL bRet = xo.bXform((PPOINTFIX)pvIn, (PPOINTL)pvOut, (UINT)cPoints);

            pptl = (PPOINTL)pvIn;
            while (pptl < pptlEnd)
            {
                pptl->x >>= 4;
                pptl->y >>= 4;
                pptl++;
            }
            return(bRet);
        }

        if (iMode == XF_INV_FXTOL)
            return(xo.bXform((PPOINTFIX)pvIn, (PPOINTL)pvOut, (UINT)cPoints));
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* ULONG XFORMOBJ_iGetXform(XFORMOBJ *pxo,XFORM *pxform)
*
*  Get the coefficients of the given transform.
*
* History:
*  13-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

ULONG XFORMOBJ_iGetXform(XFORMOBJ *pxo, XFORML *pxform)
{
    if (pxo == NULL)
        return(DDI_ERROR);

    if  (pxform != NULL)
        ((EXFORMOBJ *)pxo)->vGetCoefficient((XFORML *)pxform);

    switch(((EXFORMOBJ *)pxo)->flAccel() &
           (XFORM_SCALE|XFORM_UNITY|XFORM_NO_TRANSLATION))
    {
        case (XFORM_SCALE|XFORM_UNITY|XFORM_NO_TRANSLATION):
            return(GX_IDENTITY);

        case (XFORM_SCALE|XFORM_UNITY):
            return(GX_OFFSET);

        case (XFORM_SCALE):
            return(GX_SCALE);

        default:
            return(GX_GENERAL);
    }
}

/******************************Public*Routine******************************\
* ULONG XFORMOBJ_iGetXform(XFORMOBJ *pxo,XFORM *pxform)
*
*  Get the coefficients of the given transform.
*
* History:
*  13-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

ULONG XFORMOBJ_iGetFloatObjXform(XFORMOBJ *pxo, FLOATOBJ_XFORM *pxform)
{
    if (pxo == NULL)
        return(DDI_ERROR);

    if  (pxform != NULL)
        ((EXFORMOBJ *)pxo)->vGetCoefficient(pxform);

    switch(((EXFORMOBJ *)pxo)->flAccel() &
           (XFORM_SCALE|XFORM_UNITY|XFORM_NO_TRANSLATION))
    {
        case (XFORM_SCALE|XFORM_UNITY|XFORM_NO_TRANSLATION):
            return(GX_IDENTITY);

        case (XFORM_SCALE|XFORM_UNITY):
            return(GX_OFFSET);

        case (XFORM_SCALE):
            return(GX_SCALE);

        default:
            return(GX_GENERAL);
    }
}




/******************************Public*Routine******************************\
*
* a few wrapper functions for EFLOATS.  See winddi for the list.
*
* Note that currently these are only defined for x86 since we allow floating
* point operations in the kernel for MIPS, ALPHA, and PPC where these are macros.
*
* History:
*  16-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

#if defined(_X86_) && !defined(BUILD_WOW6432)

VOID  FLOATOBJ_SetFloat(
    PFLOATOBJ pf,
    FLOATL f)
{
    *(EFLOAT*)pf = f;
}

VOID  FLOATOBJ_SetLong(
    PFLOATOBJ pf,
    LONG      l)
{
    *(EFLOAT*)pf = l;
}

LONG FLOATOBJ_GetFloat(
    PFLOATOBJ pf)
{
    return(((EFLOAT*)pf)->lEfToF());
}

LONG  FLOATOBJ_GetLong(
    PFLOATOBJ pf)
{
    LONG l;
    ((EFLOAT*)pf)->bEfToLTruncate(l);
    return(l);
}

VOID  FLOATOBJ_AddFloat(
    PFLOATOBJ pf,
    FLOATL f)
{
    EFLOAT ef;
    ef = f;
    *(EFLOAT*)pf += ef;
}

VOID  FLOATOBJ_AddLong(
    PFLOATOBJ pf,
    LONG l)
{
    EFLOAT ef;
    ef = l;
    *(EFLOAT*)pf += ef;
}

VOID  FLOATOBJ_Add(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf += *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_AddFloatObj(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf += *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_SubFloat(
    PFLOATOBJ pf,
    FLOATL    f)
{
    EFLOAT ef;
    ef = f;
    *(EFLOAT*)pf -= ef;
}

VOID  FLOATOBJ_SubLong(
    PFLOATOBJ pf,
    LONG      l)
{
    EFLOAT ef;
    ef = l;
    *(EFLOAT*)pf -= ef;
}

VOID  FLOATOBJ_Sub(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf -= *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_SubFloatObj(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf -= *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_MulFloat(
    PFLOATOBJ pf,
    FLOATL    f)
{
    EFLOAT ef;
    ef = f;
    *(EFLOAT*)pf *= ef;
}

VOID  FLOATOBJ_MulLong(
    PFLOATOBJ pf,
    LONG      l)
{
    EFLOAT ef;
    ef = l;
    *(EFLOAT*)pf *= ef;
}

VOID  FLOATOBJ_MulFloatObj(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf *= *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_Mul(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf *= *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_DivFloat(
    PFLOATOBJ pf,
    FLOATL    f)
{
    EFLOAT ef;
    ef = f;
    *(EFLOAT*)pf /= ef;
}

VOID  FLOATOBJ_DivLong(
    PFLOATOBJ pf,
    LONG      l)
{
    EFLOAT ef;
    ef = l;
    *(EFLOAT*)pf /= ef;
}

VOID  FLOATOBJ_Div(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf /= *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_DivFloatObj(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf /= *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_Neg(PFLOATOBJ pf)
{
    ((EFLOAT*)pf)->vNegate();
}

BOOL  FLOATOBJ_EqualLong(
    PFLOATOBJ pf,
    LONG      l)
{
    if (l == 0)
    {
        return(((EFLOAT*)pf)->bIsZero());
    }
    else
    {
        EFLOAT ef;
        ef = l;
        return(*(EFLOAT*)pf == ef);
    }
}

BOOL  FLOATOBJ_GreaterThanLong(
    PFLOATOBJ pf,
    LONG      l)
{
    if (l == 0)
    {
        return(!((EFLOAT*)pf)->bIsNegative() && !((EFLOAT*)pf)->bIsZero());
    }
    else
    {
        EFLOAT ef;
        ef = l;
        return(*(EFLOAT*)pf > ef);
    }
}

BOOL  FLOATOBJ_LessThanLong(
    PFLOATOBJ pf,
    LONG      l)
{
    if (l == 0)
    {
        return(((EFLOAT*)pf)->bIsNegative());
    }
    else
    {
        EFLOAT ef;
        ef = l;
        return(*(EFLOAT*)pf < ef);
    }
}

BOOL  FLOATOBJ_Equal(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    return(*(EFLOAT*)pf == *(EFLOAT*)pf1);
}

BOOL  FLOATOBJ_GreaterThan(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    return(*(EFLOAT*)pf > *(EFLOAT*)pf1);
}

BOOL  FLOATOBJ_LessThan(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    return(*(EFLOAT*)pf < *(EFLOAT*)pf1);
}


#endif _x86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\xformgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: xformgdi.cxx
*
* Contains all the mapping and coordinate functions.
*
* Created: 09-Nov-1990 16:49:36
* Author: Wendy Wu [wendywu]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

#define UNITS_PER_MILLIMETER_LOMETRIC     10    // .1 mm/unit
#define UNITS_PER_MILLIMETER_HIMETRIC    100    // .01 mm/unit
#define UNITS_PER_METER_LOENGLISH       3937    // (100 units/in) / (0.0254 m/in)
#define UNITS_PER_METER_HIENGLISH      39370    // (1000 units/in) / (0.0254 mm/in)
#define UNITS_PER_METER_TWIPS          56693    // (1440 units/in) / (0.0254 mm/in)

#if DBG
int giXformLevel = 0;
#endif

extern "C" BOOL
ProbeAndConvertXFORM(
      XFORML     *kpXform,
      XFORML     *pXform
      );



/******************************Public*Routine******************************\
* GreGetMapMode(hdc)
*
* Get the mapping mode of the specified dc.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

int APIENTRY GreGetMapMode(
    HDC hdc)
{
    DWORD dw = 0;
    XDCOBJ dco( hdc );

    if(dco.bValid())
    {
        dw = dco.ulMapMode();
        dco.vUnlockFast();
    }
    else
    {
        WARNING("Invalid DC passed to GreGetMapMode\n");
    }

    return(dw);
}

/******************************Public*Routine******************************\
* GreGetViewportExt(hdc,pSize)
*
* Get the viewport extents of the specified dc.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreGetViewportExt(
    HDC     hdc,
    PSIZE   pSize)
{
    return(GreGetDCPoint(hdc,DCPT_VPEXT,(PPOINTL)pSize));
}

/******************************Public*Routine******************************\
* GreGetViewportOrg(hdc,pPoint)
*
* Get the viewport origin of the specified dc.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreGetViewportOrg(
    HDC     hdc,
    LPPOINT pPoint)
{
    return(GreGetDCPoint(hdc,DCPT_VPORG,(PPOINTL)pPoint));
}

/******************************Public*Routine******************************\
* GreGetWindowExt(hdc,pSize)
*
* Get the window extents of the specified dc.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreGetWindowExt(
    HDC     hdc,
    PSIZE   pSize)
{
    return(GreGetDCPoint(hdc,DCPT_WNDEXT,(PPOINTL)pSize));
}

/******************************Public*Routine******************************\
* GreGetWindowOrg(hdc,pPoint)
*
* Get the window origin of the specified dc.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreGetWindowOrg(
    HDC     hdc,
    LPPOINT pPoint)
{
    return(GreGetDCPoint(hdc,DCPT_WNDORG,(PPOINTL)pPoint));
}

/******************************Public*Routine******************************\
* GreSetViewportOrg(hdc,x,y,pPoint)
*
* Set the viewport origin of the specified dc.
*
*  15-Sep-1992 -by- Gerrit van Wingerden [gerritv]
* Modified since xforms have moved to client side and this routine is
* now only called by usersrv.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreSetViewportOrg(
 HDC     hdc,
 int     x,
 int     y,
LPPOINT pPoint)
{


    DCOBJ    dcox(hdc);                 // lock the dc object

    if (!dcox.bValid())                 // check if lock is valid
        return(FALSE);

    if (MIRRORED_DC(dcox.pdc))
        x = -x;

    if (BLTOFXOK(x) && BLTOFXOK(y))
    {
        if (!dcox.pdc->bValidPtlCurrent())
        {
            ASSERTGDI(dcox.pdc->bValidPtfxCurrent(), "Both CPs invalid?");

            EXFORMOBJ exoDtoW(dcox, DEVICE_TO_WORLD);

            if (exoDtoW.bValid())
                exoDtoW.bXform(&dcox.ptfxCurrent(), &dcox.ptlCurrent(), 1);

            dcox.pdc->vValidatePtlCurrent();
        }

    // After the transform, the device space CP will be invalid:

        dcox.pdc->vInvalidatePtfxCurrent();

    // x, y of viewport origin can fit into 28 bits.

    // If we get here it means we've been called by USER and Viewport
    // and Window extents should be (1,1) and Window Orgs should be zero,
    // and the world transform shouldn't be set either.

        DONTUSE(pPoint);    // pPoint is now ignored

        EXFORMOBJ xoWtoD(dcox, WORLD_TO_DEVICE);
        EFLOATEXT efDx((LONG) x);
        EFLOATEXT efDy((LONG) y);

        efDx.vTimes16();
        efDy.vTimes16();
        
        ASSERTGDI(xoWtoD.efM11().bIs16() ||
                  (MIRRORED_DC(dcox.pdc) && xoWtoD.efM11().bIsNeg16()),
                  "efM11 not 16 in GreSetViewportOrg or -16 in Mirroring Mode" );
        ASSERTGDI( xoWtoD.efM22().bIs16(),
                   "efM22 not 16 in GreSetViewportOrg" );

        dcox.pdc->flSet_flXform( DEVICE_TO_WORLD_INVALID | PAGE_XLATE_CHANGED);
        //xoWtoD.vSetTranslations( efDx, efDy );
        dcox.pdc->lViewportOrgX(x);
        dcox.pdc->lViewportOrgY(y);

        xoWtoD.vInit(dcox, DEVICE_TO_WORLD);

        return(TRUE);

    }
    else
        return(FALSE);
}


/******************************Public*Routine******************************\
* GreSetWindowOrg(hdc,x,y,pPoint)
*
* Set the window origin of the specified dc.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreSetWindowOrg(
 HDC     hdc,
 int     x,
 int     y,
LPPOINT pPoint)
{


    DCOBJ    dcox(hdc);                 // lock the dc object

    if (!dcox.bValid())                 // check if lock is valid
        return(FALSE);

// If we get here it means we've been called by USER and Viewport
// and Window extents should be (1,1) and Viewport Orgs should be zero,
// and the world transform shouldn't be set either.

    DONTUSE(pPoint);    // pPoint is now ignored

    EXFORMOBJ xoWtoD(dcox, WORLD_TO_DEVICE);
    EFLOATEXT efDx((LONG) -x);
    EFLOATEXT efDy((LONG) -y);

    efDx.vTimes16();
    efDy.vTimes16();

    ASSERTGDI( xoWtoD.efM11().bIs16() ||
               (MIRRORED_DC(dcox.pdc) && xoWtoD.efM11().bIsNeg16()),
               "efM11 not 16 in GreSetViewportOrg" );

    ASSERTGDI( xoWtoD.efM22().bIs16(),
               "efM22 not 16 in GreSetViewportOrg" );

    if (!dcox.pdc->bValidPtlCurrent())
    {
        ASSERTGDI(dcox.pdc->bValidPtfxCurrent(), "Both CPs invalid?");

        EXFORMOBJ exoDtoW(dcox, DEVICE_TO_WORLD);

        if (exoDtoW.bValid())
            exoDtoW.bXform(&dcox.ptfxCurrent(), &dcox.ptlCurrent(), 1);

        dcox.pdc->vValidatePtlCurrent();
    }

// After the transform, the device space CP will be invalid:

    dcox.pdc->vInvalidatePtfxCurrent();

    dcox.pdc->flSet_flXform( DEVICE_TO_WORLD_INVALID | PAGE_XLATE_CHANGED);
    //xoWtoD.vSetTranslations( efDx, efDy );

    //
    // save in DC for USER. Caution: these valuse must be restored before app
    // uses DC again
    //

    dcox.pdc->lWindowOrgX(x);
    dcox.pdc->lWindowOrgY(y);
    dcox.pdc->SetWindowOrgAndMirror(x);

    xoWtoD.vInit(dcox, DEVICE_TO_WORLD);

    return( TRUE );

}


/******************************Public*Routine******************************\
* NtGdiConvertMetafileRect:
*
*   Transform a RECT from inclusive-exclusive to inclusive-inclusive for
*   a rectangle recorded in a metafile.
*
* Arguments:
*
*   hdc   - current device context
*   rect  - rtectangle to convert
*
* Return Value:
*
*   MRI_OK,MRI_NULLBOX,MRI_ERROR
*
* History:
*
*    9-Apr-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

LONG APIENTRY
NtGdiConvertMetafileRect(
    HDC    hdc,
    PRECTL prect
    )
{
    LONG lResult = MRI_ERROR;
    RECTL rclMeta;

    //
    // copy in rect structure
    //

    __try
    {
        rclMeta = ProbeAndReadStructure(prect,RECTL);
        lResult = MRI_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(22);
    }

    if (lResult == MRI_OK)
    {
        //
        //  attempt to lock DC
        //

        DCOBJ  dco(hdc);

        if (dco.bValid())
        {
            ERECTFX rectFX;
            BOOL bResult;

            //
            // DC must be in compatible mode
            //

            ASSERTGDI(dco.pdc->iGraphicsMode() == GM_COMPATIBLE,
                        "NtGdiConvertMetafileRect: Map Mode is not GM_COMPATIBLE");

            //
            // transform rectangle points to device FX
            //

            {
                EXFORMOBJ xo(dco,XFORM_WORLD_TO_DEVICE);

                bResult = xo.bXform((PPOINTL)&rclMeta,(PPOINTFIX)&rectFX,2);
            }

            if (bResult)
            {
                //
                // order device point rectangle
                //

                rectFX.vOrder();

                //
                // adjust lower and right points for exclusive to inclusive
                //

                rectFX.xRight  -= 16;
                rectFX.yBottom -= 16;

                //
                // check for empty rectFX
                //

                if ((rectFX.xRight  < rectFX.xLeft) ||
                    (rectFX.yBottom < rectFX.yTop))
                {
                    lResult = MRI_NULLBOX;
                }

                //
                // convert back to logical space
                //

                EXFORMOBJ xoDev(dco,XFORM_DEVICE_TO_WORLD);

                bResult = xoDev.bXform((PPOINTFIX)&rectFX,(PPOINTL)&rclMeta,2);

                //
                // Write results to caller's buffer
                //

                if (bResult)
                {
                    __try
                    {
                        ProbeAndWriteStructure(prect,rclMeta,RECT);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        WARNINGX(8);
                        lResult = MRI_ERROR;
                    }
                }
                else
                {
                    lResult = MRI_ERROR;
                }
            }
            else
            {
                lResult = MRI_ERROR;
            }
        }
        else
        {
            lResult = MRI_ERROR;
        }
    }

    if (lResult == MRI_ERROR)
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return(lResult);
}

/******************************Public*Routine******************************\
*
*
* History:
*  02-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreTransformPoints(
    HDC    hdc,
    PPOINT pptIn,
    PPOINT pptOut,
    int    c,
    int    iMode
    )
{
    XFORMPRINT(1,"GreTransformPoints, iMode = %ld\n",iMode);

    BOOL bResult = FALSE;

    DCOBJ  dco(hdc);                    // lock the dc object

    if (dco.bValid())                  // check if lock is valid
    {
        if (c <= 0)                    // check if there are points to convert
        {
            bResult = TRUE;
        }
        else
        {
            EXFORMOBJ xo(dco, (iMode == XFP_DPTOLP) ? XFORM_DEVICE_TO_WORLD : XFORM_WORLD_TO_DEVICE);

            if (xo.bValid())
            {
                switch (iMode)
                {
                case XFP_DPTOLP:
                case XFP_LPTODP:
                    bResult = xo.bXform((PPOINTL)pptIn, (PPOINTL)pptOut, c);
                    break;

                case XFP_LPTODPFX:
                    bResult = xo.bXform((PPOINTL)pptIn, (PPOINTFIX)pptOut, c);
                    break;

                default:
                    WARNING("Invalid mode passed to GreTranformPoints\n");
                    break;
                }
            }
        }
    }
    return(bResult);
}

/******************************Public*Routine******************************\
* GreDPtoLP(hdc,ppt,nCount)
*
* Convert the given device points into logical points.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreDPtoLP(
HDC     hdc,
LPPOINT ppt,
int     nCount)
{
    return(GreTransformPoints(hdc,ppt,ppt,nCount,XFP_DPTOLP));
}

/******************************Public*Routine******************************\
* GreLPtoDP(hdc,ppt,nCount)
*
* Convert the given logical points into device points.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreLPtoDP(
HDC     hdc,
LPPOINT ppt,
int     nCount)
{
    return(GreTransformPoints(hdc,ppt,ppt,nCount,XFP_LPTODP));
}

/******************************Private*Routine*****************************\
* bWorldMatrixInRange(pmx)
*
* See if the coefficients of the world transform matrix are within
* our minimum and maximum range.
*
* History:
*  27-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL bWorldMatrixInRange(PMATRIX pmx)
{

    BOOL bRet;

#if defined(_AMD64_) || defined(_IA64_) || defined(BUILD_WOW6432)
/*
    EFLOAT ef = pmx->efM11;
    ef.vAbs();
    if ((ef < (FLOAT)MIN_WORLD_XFORM) || (ef > (FLOAT)MIN_WORLD_XFORM))
        return(FALSE);

    ef = pmx->efM12;
    ef.vAbs();
    if ((ef < (FLOAT)MIN_WORLD_XFORM) || (ef > (FLOAT)MIN_WORLD_XFORM))
        return(FALSE);

    ef = pmx->efM21;
    ef.vAbs();
    if ((ef < (FLOAT)MIN_WORLD_XFORM) || (ef > (FLOAT)MIN_WORLD_XFORM))
        return(FALSE);

    ef = pmx->efM22;
    ef.vAbs();
    if ((ef < (FLOAT)MIN_WORLD_XFORM) || (ef > (FLOAT)MIN_WORLD_XFORM))
        return(FALSE);

    ef = pmx->efDx;
    ef.vAbs();
    if ((ef < (FLOAT)MIN_WORLD_XFORM) || (ef > (FLOAT)MIN_WORLD_XFORM))
        return(FALSE);

    ef = pmx->efDy;
    ef.vAbs();
    if ((ef < (FLOAT)MIN_WORLD_XFORM) || (ef > (FLOAT)MIN_WORLD_XFORM))
        return(FALSE);
*/

    bRet = TRUE;

#else


    bRet =
    ((pmx->efM11.bExpLessThan(MAX_WORLD_XFORM_EXP)) &&
     (pmx->efM12.bExpLessThan(MAX_WORLD_XFORM_EXP)) &&
     (pmx->efM21.bExpLessThan(MAX_WORLD_XFORM_EXP)) &&
     (pmx->efM22.bExpLessThan(MAX_WORLD_XFORM_EXP)) &&
     (pmx->efDx.bExpLessThan(MAX_WORLD_XFORM_EXP)) &&
     (pmx->efDy.bExpLessThan(MAX_WORLD_XFORM_EXP)))
     ;

#endif

    if (bRet)
    {
    // at this point bRet == TRUE. We have to figure out the cases
    // when the determinant is zero and set bRet to FALSE;

    // We do what we can to avoid multiplications in common cases
    // when figuring out if this is a singular trasform

        if (pmx->efM12.bIsZero() && pmx->efM21.bIsZero())
        {
            if (pmx->efM11.bIsZero() || pmx->efM22.bIsZero())
                bRet = FALSE;
        }
        else if (pmx->efM11.bIsZero() && pmx->efM22.bIsZero())
        {
            if (pmx->efM12.bIsZero() || pmx->efM21.bIsZero())
                bRet = FALSE;
        }
        else // general case, have to do multiplications
        {
            EFLOAT ef = pmx->efM11;
            ef *= pmx->efM22;

            EFLOAT ef1 = pmx->efM12;
            ef1 *= pmx->efM21;

            ef -= ef1; // determinant.

            if (ef.bIsZero())
            {
                bRet = FALSE;
            }
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* GreGetDeviceWidth(hdc)
*
* Get the device surface width of the specified dc.
*
* History:
*  26-Jan-1998 -by- Mohamed Hassanin [mhamid]
* Wrote it.
\**************************************************************************/
LONG  APIENTRY
GreGetDeviceWidth(HDC hdc)
{
    DCOBJ dco(hdc);

    if (dco.bValid() != FALSE)
    {
        return (dco.pdc->GetDeviceWidth());
    }
    else
    {
        WARNING("Invalid DC passed to GreGetDeviceWidth\n");
    }

    return (GDI_ERROR);
}

/******************************Public*Routine******************************\
* GreMirrorWindowOrg(hdc)
*
* Mirror the Window X Org. By calling MirrorWindowOrg
*
* History:
*  26-Jan-1998 -by- Mohamed Hassanin [mhamid]
* Wrote it.
\**************************************************************************/
BOOL  APIENTRY
GreMirrorWindowOrg(HDC hdc)
{
    DCOBJ dco(hdc);

    if (dco.bValid() != FALSE)
    {
        dco.pdc->MirrorWindowOrg();
        return (TRUE);
    }

    return (FALSE);
}
/******************************Public*Routine******************************\
* GreGetLayout
*
*
* History:
*  Fri 12-Sep-1991 11:29    -by- Mohamed Hassanin [MHamid]
* Wrote it.
\**************************************************************************/
DWORD APIENTRY
GreGetLayout(HDC hdc)
{
    DWORD dwRet = GDI_ERROR;

    DCOBJ dco(hdc);

    if (dco.bValid() != FALSE)
    {
        dwRet = dco.pdc->dwLayout();
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* GreSetLayout
*
*
* History:
*  Fri 12-Sep-1991 11:29    -by- Mohamed Hassanin [MHamid]
* Wrote it.
\**************************************************************************/
DWORD APIENTRY
GreSetLayout
( HDC    hdc,
  LONG   wox,
  DWORD  dwLayout)
{
    DCOBJ dco( hdc );
    if( !dco.bValid() )
    {
       WARNING("Xform update invalid hdc\n");
       return(GDI_ERROR);
    }
    return dco.pdc->dwSetLayout(wox, dwLayout);
}

/******************************Public*Routine******************************\
* GreXformUpdate
*
* Updates the server's copy of the WtoD transform, transform related flags,
* and viewport and window extents.
*
* History:
*  6-Aug-1992 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/


BOOL GreXformUpdate
( HDC hdc,
  FLONG flXform,
  LONG wex,
  LONG wey,
  LONG vex,
  LONG vey,
  LONG mapMode,
  PVOID pvMatrix
)
{
    DCOBJ dco( hdc );

    if( !dco.bValid() )
    {
       WARNING("Xform update invalid hdc\n");
       return(FALSE);
    }

// Copy window and viewport extents
    dco.pdc->vSet_szlWindowExt( wex, wey );
    dco.pdc->vSet_szlViewportExt( vex, vey );
    dco.pdc->ulMapMode( mapMode );

// Save current position

    ASSERTGDI(dco.bValid(), "DC not valid");

    if (!dco.pdc->bValidPtlCurrent())
    {
        ASSERTGDI(dco.pdc->bValidPtfxCurrent(), "Both CPs invalid?");

        EXFORMOBJ exoDtoW(dco, DEVICE_TO_WORLD);

        if (exoDtoW.bValid())
            exoDtoW.bXform(&dco.ptfxCurrent(), &dco.ptlCurrent(), 1);

        dco.pdc->vValidatePtlCurrent();
    }

// Set the flags

    dco.pdc->flResetflXform( flXform );
    dco.pdc->flSet_flXform( DEVICE_TO_WORLD_INVALID );

// Set the new world transform

    RtlCopyMemory( (PVOID) &dco.pdc->mxWorldToDevice(), pvMatrix, sizeof( MATRIX ));
    RtlCopyMemory( (PVOID) &dco.pdc->mxUserWorldToDevice(), pvMatrix, sizeof( MATRIX ));

// After the transform, the device space CP will be invalid:

    dco.pdc->vInvalidatePtfxCurrent();

    if( flXform & INVALIDATE_ATTRIBUTES )
    {
        EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

        dco.pdc->vRealizeLineAttrs(exo);
        dco.pdc->vXformChange(TRUE);
    }

    return (TRUE);
}

/******************************Member*Function*****************************\
* vConvertXformToMatrix
*
* Convert a xform structure into a matrix struct.
*
* History:
*  27-Mar-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID vConvertXformToMatrix(CONST XFORML *pxf, PMATRIX pmx)
{
    pmx->efM11 = pxf->eM11;         // overloading operator = which covert
    pmx->efM12 = pxf->eM12;         // IEEE float to our internal EFLOAT
    pmx->efM21 = pxf->eM21;
    pmx->efM22 = pxf->eM22;
    pmx->efDx = pxf->eDx;
    pmx->efDy = pxf->eDy;
#if DBG
    if (!pmx->efDx.bEfToL(pmx->fxDx))
        WARNING("vConvertXformToMatrix:translation dx overflowed\n");
    if (!pmx->efDy.bEfToL(pmx->fxDy))
        WARNING("vConvertXformToMatrix:translation dy overflowed\n");
#else
    pmx->efDx.bEfToL(pmx->fxDx);
    pmx->efDy.bEfToL(pmx->fxDy);
#endif
    pmx->flAccel = XFORM_FORMAT_LTOL;

    if ((pmx->efDx == pmx->efDy) && pmx->efDy.bIsZero())
        pmx->flAccel |= XFORM_NO_TRANSLATION;

    if (pmx->efM12.bIsZero() && pmx->efM21.bIsZero())
    {
        pmx->flAccel |= XFORM_SCALE;
        if (pmx->efM11.bIs1() && pmx->efM22.bIs1())
            pmx->flAccel |= XFORM_UNITY;
    }

}

/******************************Private*Routine*****************************\
* vMakeIso()
*
* Shrink viewport extents in one direction to match the aspect ratio of
* the window.
*
* History:
*
*  05-Dec-1994 -by-  Eric Kutter [erick]
* Moved back to the server
*
*  6-Aug-1992 -by- Gerrit van Wingerden [gerritv]
* Modified for client side use.
*
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID DC::vMakeIso()
{
    LONG    lVpExt;
    EFLOAT  efRes, efTemp, efTemp1;

// Calculate the pixel aspect ratio efRes = ASPECTY / ASPECTX.

    if(lVirtualDevicePixelCx() != 0)
    {
        //
        // if lVirtualDeviceCx/Cy are set, use these, they are in micrometers
        // Otherwise use their millimeters counter part
        //
        if ((lVirtualDeviceCx()) != 0 && (lVirtualDeviceCy() != 0))
        {
           efTemp = lVirtualDevicePixelCx();
           efTemp1 = lVirtualDeviceCy();

           LONG lTemp = EngMulDiv(lVirtualDevicePixelCy(), lVirtualDeviceCx(), lVirtualDevicePixelCx());
           efRes = lTemp;
           efRes /= efTemp1;
        }
        else
        {
           efRes = lVirtualDevicePixelCy() * lVirtualDeviceMmCx();
           efTemp = lVirtualDevicePixelCx();
           efTemp1 = lVirtualDeviceMmCy();

           efRes /= efTemp;
           efRes /= efTemp1;
        }
    }
    else
    {
        PDEVOBJ po(hdev());
        ASSERTGDI(po.bValid(), "Invalid PDEV\n");

        efRes  = (LONG)po.ulLogPixelsY();
        efTemp = (LONG)po.ulLogPixelsX();
        efRes /= efTemp;
    }

// Our goal is to make the following formula true
// VpExt.cy / VpExt.cx = (WdExt.cy / WdExt.cx) * (ASPECTY / ASPECTX)

// Let's calculate VpExt.cy assuming VpExt.cx is the limiting factor.
// VpExt.cy = (WdExt.cy * VpExt.cx) / WdExt.cx * efRes

    EFLOATEXT efVpExt = lWindowExtCy();
    efTemp   = lViewportExtCx();
    efTemp1  = lWindowExtCx();
    efVpExt *= efTemp;
    efVpExt /= efTemp1;
    efVpExt *= efRes;
    efVpExt.bEfToL(lVpExt);             // convert efloat to long

    lVpExt = ABS(lVpExt);

// Shrink y if the |original VpExt.cy| > the |calculated VpExt.cy|
// The original signs of the extents are preserved.

    if (lViewportExtCy() > 0)
    {
        if (lViewportExtCy() >= lVpExt)
        {
            lViewportExtCy(lVpExt);
            return;
        }
    }
    else
    {
        if (-lViewportExtCy() >= lVpExt)
        {
            lViewportExtCy(-lVpExt);
            return;
        }
    }

// We know VpExt.cy is the real limiting factor.  Let's calculate the correct
// VpExt.cx.
// VpExt.cx = (WdExt.cx * VpExt.cy) / WdExt.cy / Res

    efVpExt  = lWindowExtCx();
    efTemp   = lViewportExtCy();
    efTemp1  = lWindowExtCy();
    efVpExt *= efTemp;
    efVpExt /= efTemp1;
    efVpExt /= efRes;
    efVpExt.bEfToL(lVpExt);

    lVpExt = ABS(lVpExt);

    if(lViewportExtCx() > 0 )
        lViewportExtCx(lVpExt);
    else
        lViewportExtCx(-lVpExt);

}


/**************************************************************************\
* NtGdiScaleViewportExtEx()
*
* History:
*  07-Jun-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

BOOL
NtGdiScaleViewportExtEx(
    HDC    hdc,
    int    xNum,
    int    xDenom,
    int    yNum,
    int    yDenom,
    LPSIZE pszOut
    )
{
    BOOL bRet = FALSE;

    DCOBJ dcox(hdc);

    if (dcox.bValid())
    {
        BOOL bNoExcept = TRUE;

        //
        // NOTE: NT 3.51 compatibility.
        // Even if the API failed (returned FALSE), the viewport was returned
        // properly - stay compatible with this.
        //

        if (pszOut)
        {
            __try
            {
                ProbeForWrite(pszOut,sizeof(SIZE), sizeof(DWORD));
                *pszOut = dcox.pdc->szlViewportExt();
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                // SetLastError(GetExceptionCode());

                bNoExcept = FALSE;
            }
        }

        if (bNoExcept == TRUE)
        {
            // can't change extent if fixed scale

            if (dcox.ulMapMode() <= MM_MAX_FIXEDSCALE)
            {
                bRet = TRUE;
            }
            else
            {
                LONG lx, ly;
                if ((xDenom != 0) &&
                    (yDenom != 0) &&
                    ((lx = (dcox.pdc->lViewportExtCx() * xNum) / xDenom) != 0) &&
                    ((ly = (dcox.pdc->lViewportExtCy() * yNum) / yDenom) != 0))
                {
                    dcox.pdc->lViewportExtCx(lx);
                    dcox.pdc->lViewportExtCy(ly);
                    dcox.pdc->MirrorWindowOrg();
                    dcox.pdc->vPageExtentsChanged();
                    bRet = TRUE;
                }
            }
        }
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* GreScaleWindowExtEx()
*
* History:
*  02-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL GreScaleWindowExtEx(
    HDC hdc,
    int xNum,
    int xDenom,
    int yNum,
    int yDenom,
    PSIZE psizl)
{
    BOOL bRet = FALSE;

    DCOBJ dcox(hdc);                   // lock the dc object

    if (dcox.bValid())                 // check if lock is valid
    {
        if (psizl != (LPSIZE)NULL)
        {
            *psizl = dcox.pdc->szlWindowExt();      // fetch old extent
            if (MIRRORED_DC(dcox.pdc))
                psizl->cx = -psizl->cx;
        }

    // can't change extent if fixed scale

        if (dcox.ulMapMode() <= MM_MAX_FIXEDSCALE)
        {
            bRet = TRUE;
        }
        else
        {
            LONG lx, ly;
            if ((xDenom != 0) &&
                (yDenom != 0) &&
                ((lx = (dcox.pdc->lWindowExtCx() * xNum) / xDenom) != 0) &&
                ((ly = (dcox.pdc->lWindowExtCy() * yNum) / yDenom) != 0))
            {
                dcox.pdc->lWindowExtCx(lx);
                dcox.pdc->lWindowExtCy(ly);
                dcox.pdc->MirrorWindowOrg();
                dcox.pdc->vPageExtentsChanged();
                bRet = TRUE;
            }
        }
    }
    return(bRet);
}

/******************************Private*Routine*****************************\
* vComputePageXform
*
* Compute the page to device scaling factors.
*
* History:
*  05-Dec-1994 -by-  Eric Kutter [erick]
* Moved back to the server
*
*
*  15-Dec-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID DC::vComputePageXform()
{
    EFLOAT ef;
    EFLOATEXT efTemp;

    ef     = LTOFX(lViewportExtCx());
    efTemp = lWindowExtCx();
    ef    /= efTemp;
    efM11PtoD(ef);

    ef     = LTOFX(lViewportExtCy());
    efTemp = lWindowExtCy();
    ef    /= efTemp;
    efM22PtoD(ef);
}

/******************************Public*Routine******************************\
*
* int EngMulDiv
* I am surprised that there is no system service routine to do this.
* anyway I am just fixing the old routine
*
* History:
*  15-Dec-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int EngMulDiv(
    int a,
    int b,
    int c)
{
    LONGLONG ll;
    int iSign = 1;

    if (a < 0)
    {
        iSign = -iSign;
        a = -a;
    }
    if (b < 0)
    {
        iSign = -iSign;
        b = -b;
    }

    if (c != 0)
    {
        if (c < 0)
        {
            iSign = -iSign;
            c = -c;
        }

        ll = (LONGLONG)a;
        ll *= b;
        ll += (c/2); // used to add (c+1)/2 which is wrong
        ll /= c;

    // at this point ll is guaranteed to be > 0. Thus we will do
    // unsigned compare in the next step which generates two less instructions
    // on x86 [bodind]

        if ((ULONGLONG)ll > (ULONG)INT_MAX) // check for overflow:
        {
            if (iSign > 0)
                return INT_MAX;
            else
                return INT_MIN;
        }
        else
        {
            if (iSign > 0)
                return ((int)ll);
            else
                return (-(int)ll);
        }
    }
    else
    {
        ASSERTGDI(c, "EngMulDiv - c == 0\n");
        ASSERTGDI(a | b, "EngMulDiv - a|b == 0\n");

        if (iSign > 0)
            return INT_MAX;
        else
            return INT_MIN;
    }
}
/******************************Public*Routine******************************\
* dwSetLayout
*
* Mirror the dc, by offsetting the window origin. If wox == -1, then the
* window origin becomes mirrored by the DC window width as follows :
* -((Device_Surface_Width * WindowExtX) / ViewportExtX) + LogicalWindowOrgX
*
* Otherwise mirroring is done by the specified wox amount :
* (wox - Current Window X-Origin)
*
* The function also changes windowExt.cx to be -1 so that positive x will
* go from right to left.
*
* History:
*  09-Dec-1997 -by- Mohammed Abdel-Hamid  [mhamid]
* Wrote it.
\**************************************************************************/

DWORD DC::dwSetLayout(LONG   wox, DWORD dwDefLayout)
{

    POINTL ptWOrg, ptVOrg;
    SIZEL  SzWExt, SzVExt;
    DWORD  dwOldLayout;

    dwOldLayout = dwLayout();
    dwLayout(dwDefLayout);
    if ((dwOldLayout & LAYOUT_ORIENTATIONMASK) == (dwDefLayout & LAYOUT_ORIENTATIONMASK)) {
        return dwOldLayout;
    }

    vGet_szlWindowExt(&SzWExt);
    vGet_ptlViewportOrg(&ptVOrg);

    if (dwDefLayout & LAYOUT_RTL) {
        //Set the rtl layout
        ulMapMode(MM_ANISOTROPIC);
        ASSERTGDI((SzWExt.cx > 0), "GreSetLayout WExt.cx < 0 Check it");
    } else {
        ASSERTGDI((SzWExt.cx < 0), "GreSetLayout WExt.cx > 0 Check it");
    }

    SzWExt.cx = -SzWExt.cx;
    vSet_szlWindowExt(&SzWExt);

    ptVOrg.x = -ptVOrg.x;
    vSet_ptlViewportOrg(&ptVOrg);

    if (wox == -1) {
        MirrorWindowOrg();
    } else {
        vGet_ptlWindowOrg(&ptWOrg);
        ptWOrg.x = wox - ptWOrg.x;
        vSet_ptlWindowOrg(&ptWOrg);
    }

    //
    // TA_CENTER equals 6 (0110 Bin) and TA_RIGHT equals 2 (0010 Binary) numerically.
    // so be careful not to do 'flTextAlign() & TA_CENTER'
    // since this will succeed for RIGHT aligned DCs
    // and as a result, the TA_RIGHT bit won't get cleared. [samera]
    //
    if ((flTextAlign()&TA_CENTER) != TA_CENTER) {
        flTextAlign(flTextAlign() ^ (TA_RIGHT));
    }
    if (bClockwise()) {
        vClearClockwise();
    } else {
        vSetClockwise();
    }
    vPageExtentsChanged();
    return dwOldLayout;
}

EFLOAT ef16 = {EFLOAT_16};

/******************************Public*Routine******************************\
* DC::iSetMapMode()
*
* History:
*  07-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int DC::iSetMapMode(
    int iMode)
{
    int iOldMode;
    DWORD dwOldLayout = 0;

    // If the new map mode is not MM_ANISOTROPIC
    // And the DC in a mirrored mode
    // Then Turn off the mirroring and turn it on back after
    // Setting the new mode.

    if (iMode != MM_ANISOTROPIC) {
        dwOldLayout = dwLayout();
        if (dwOldLayout & LAYOUT_ORIENTATIONMASK) {
            dwSetLayout(-1 , 0);
        }
    }

// If set to the old map mode, don't bother setting it again except
// with MM_ISOTROPIC in which the extents might have been changed.

    iOldMode = ulMapMode();

    if ((iMode != iOldMode) || (iMode == MM_ISOTROPIC))
    {
        if (iMode == MM_TEXT)
        {
            lWindowExtCx(1);
            lWindowExtCy(1);
            lViewportExtCx(1);
            lViewportExtCy(1);
            ulMapMode(iMode);

        // We don't want to recalculate M11 and M22 in vUpdateWtoDXform().
        // Set them correctly here so we can just recalculate translations
        // in vUpdateWtoDXform().

            efM11PtoD(ef16);
            efM22PtoD(ef16);
            mxWorldToDevice().efM11 = ef16;
            mxWorldToDevice().efM22 = ef16;
            mxWorldToDevice().flAccel = XFORM_FORMAT_LTOFX | XFORM_UNITY | XFORM_SCALE;
            RtlCopyMemory(
                  (PVOID) &mxUserWorldToDevice(),
                  (PVOID) &mxWorldToDevice(),
                  sizeof( MATRIX ));

            vSetFlagsMM_TEXT();
        }
        else if (iMode == MM_ANISOTROPIC)
        {
            ulMapMode(iMode);
            vSetFlagsMM_ISO_OR_ANISO();
        }
        else if ((iMode < MM_MIN) || (iMode > MM_MAX))
        {
            return(0);
        }
        else if (lVirtualDevicePixelCx() == 0)
        {
            PDEVOBJ po(hdev());
            ASSERTGDI(po.bValid(), "Invalid PDEV\n");

        // Protect against dynamic mode changes while we compute values
        // using ulHorzSize and ulVertSize:

            DEVLOCKOBJ dlo(po);

        // Get the size of the surface

            lViewportExtCx(po.GdiInfo()->ulHorzRes);
            lViewportExtCy(-(LONG)po.GdiInfo()->ulVertRes);

        // Get the size of the device

            switch (iMode)
            {
            case MM_LOMETRIC:
            //
            // n um. * (1 mm. / 1000 um.) * (10 LoMetric units/1 mm.) = y LoMet
            //
                lWindowExtCx((po.GdiInfo()->ulHorzSize + 50)/100);
                lWindowExtCy((po.GdiInfo()->ulVertSize + 50)/100);
                vSetFlagsMM_FIXED();
                break;

            case MM_HIMETRIC:
            //
            // n um. * (1 mm. / 1000 um.) * (100 HiMetric units/1 mm.) = y HiMet
            //
                lWindowExtCx((po.GdiInfo()->ulHorzSize + 5)/10);
                lWindowExtCy((po.GdiInfo()->ulVertSize + 5)/10);
                vSetFlagsMM_FIXED();
                break;

            case MM_LOENGLISH:
            //
            // n um. * (1 in. / 25400 um.) * (100 LoEng units/1 in.) = y LoEng
            //
                lWindowExtCx((po.GdiInfo()->ulHorzSize + 127)/254);
                lWindowExtCy((po.GdiInfo()->ulVertSize + 127)/254);
                vSetFlagsMM_FIXED();
                break;

            case MM_HIENGLISH:
            //
            // n um. * (1 in. / 25400 um.) * (1000 HiEng units/1 in.) = m HiEng
            //
                lWindowExtCx(EngMulDiv(po.GdiInfo()->ulHorzSize, 10, 254));
                lWindowExtCy(EngMulDiv(po.GdiInfo()->ulVertSize, 10, 254));
                vSetFlagsMM_FIXED();
                break;

            case MM_TWIPS:
            //
            // n um. * (1 in. / 25400 um.) * (1440 Twips/1 in.) = m Twips
            //
                lWindowExtCx(EngMulDiv(po.GdiInfo()->ulHorzSize, 144, 2540));
                lWindowExtCy(EngMulDiv(po.GdiInfo()->ulVertSize, 144, 2540));

            // If it's cached earlier, use it.

            #if defined(_AMD64_) || defined(_IA64_) || defined(BUILD_WOW6432)
                if (efM11_TWIPS().e == (FLOAT)0)
            #else
                if (efM11_TWIPS().i.lMant == 0)
            #endif
                {
                    vComputePageXform();
                    efM11_TWIPS(efM11PtoD());
                    efM22_TWIPS(efM22PtoD());
                }
                ulMapMode(MM_TWIPS);

            // We don't want to recalculate M11 and M22 in vUpdateWtoDXform().
            // Set them correctly here so we can just recalculate translations
            // in vUpdateWtoDXform().

                efM11PtoD(efM11_TWIPS());
                efM22PtoD(efM22_TWIPS());
                mxWorldToDevice().efM11 = efM11_TWIPS();
                mxWorldToDevice().efM22 = efM22_TWIPS();
                mxWorldToDevice().flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE;
                   RtlCopyMemory(
                         (PVOID) &mxUserWorldToDevice(),
                         (PVOID) &mxWorldToDevice(),
                         sizeof( MATRIX ));

                vSetFlagsMM_FIXED_CACHED();
                goto JUST_RETURN;
                //
                // we need to pass thru mirroring code if
                // it is enabled so the followingis commented for
                // the above line
                // return(iOldMode);
                //

            case MM_ISOTROPIC:
                lWindowExtCx((po.GdiInfo()->ulHorzSize + 50)/100);
                lWindowExtCy((po.GdiInfo()->ulVertSize + 50)/100);
                vSetFlagsMM_ISO_OR_ANISO();
                break;

            default:
                return(0);
            }

            ulMapMode(iMode);
            vPageExtentsChanged();
        }
        else
        {
        // Get the size of the virtual surface

            lViewportExtCx(lVirtualDevicePixelCx());
            lViewportExtCy(-lVirtualDevicePixelCy());

        // Get the size of the virtual device

            switch (iMode)
            {
            case MM_LOMETRIC:
            //
            // n mm. * (10 LoMetric units/1 mm.) = y LoMet
            //
                lWindowExtCx(10 * lVirtualDeviceMmCx());
                lWindowExtCy(10 * lVirtualDeviceMmCy());
                vSetFlagsMM_FIXED();
                break;

            case MM_HIMETRIC:
            //
            // n mm. * (100 HiMetric units/1 mm.) = y HiMet
            //
                lWindowExtCx(100 * lVirtualDeviceMmCx());
                lWindowExtCy(100 * lVirtualDeviceMmCy());
                vSetFlagsMM_FIXED();
                break;

            case MM_LOENGLISH:
            //
            // n mm. * (10 in./254 mm.) * (100 LoEng/1 in.) = y LoEng
            //
                lWindowExtCx(EngMulDiv(lVirtualDeviceMmCx(),1000, 254));
                lWindowExtCy(EngMulDiv(lVirtualDeviceMmCy(),1000, 254));
                vSetFlagsMM_FIXED();
                break;

            case MM_HIENGLISH:
            //
            // n mm. * (10 in./254 mm.) * (1000 LoEng/1 in.) = y LoEng
            //
                lWindowExtCx(EngMulDiv(lVirtualDeviceMmCx(),10000, 254));
                lWindowExtCy(EngMulDiv(lVirtualDeviceMmCy(),10000, 254));
                vSetFlagsMM_FIXED();
                break;

            case MM_TWIPS:
            //
            // n mm. * (10 in./254 mm.) * (1440 Twips/1 in.) = y Twips
            //
                lWindowExtCx(EngMulDiv(lVirtualDeviceMmCx(),14400, 254));
                lWindowExtCy(EngMulDiv(lVirtualDeviceMmCy(),14400, 254));
                vSetFlagsMM_FIXED();
                break;

            case MM_ISOTROPIC:
            //
            // n mm. * (10 LoMetric units/1 mm.) = y LoMet
            //
                lWindowExtCx(10 * lVirtualDeviceMmCx());
                lWindowExtCy(10 * lVirtualDeviceMmCy());
                vSetFlagsMM_ISO_OR_ANISO();
                break;

            default:
                return(0);
            }

            ulMapMode(iMode);
            vPageExtentsChanged();

        }
JUST_RETURN:
        // If turned the mirroring off then turn it on back.
        if (dwOldLayout & LAYOUT_ORIENTATIONMASK) {
            //And then set it again.
            dwSetLayout(-1 , dwOldLayout);
        }
    }

    return(iOldMode);
}

/******************************Public*Routine******************************\
* NtGdiSetVirtualResolution()
*
* Set the virtual resolution of the specified dc.
* The virtual resolution is used to compute transform matrix only.
* If the virtual units are all zeros, the default physical units are used.
* Otherwise, non of the units can be zero.
*
* Currently used by metafile component only.
*
* History:
*
*  05-Dec-1994 -by-  Eric Kutter [erick]
* Moved back to the server
*
*  6-Aug-1992 -by- Gerrit van Wingerden [gerritv]
* Modified for client side use.
*
*  Tue Aug 27 13:04:11 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiSetVirtualResolution(
    HDC    hdc,
    int    cxVirtualDevicePixel,    // Width of the virtual device in pels
    int    cyVirtualDevicePixel,    // Height of the virtual device in pels
    int    cxVirtualDeviceMm,       // Width of the virtual device in millimeters
    int    cyVirtualDeviceMm)       // Height of the virtual device in millimeters
{
    XFORMPRINT(1,"GreSetVirtualResolution\n",0);

    BOOL bRet = FALSE;

// The units must be all zeros or all non-zeros.

    if ((cxVirtualDevicePixel != 0 && cyVirtualDevicePixel != 0 &&
         cxVirtualDeviceMm    != 0 && cyVirtualDeviceMm != 0)
        ||
        (cxVirtualDevicePixel == 0 && cyVirtualDevicePixel == 0 &&
         cxVirtualDeviceMm    == 0 && cyVirtualDeviceMm    == 0))
    {
    // now lock down the DC

        DCOBJ dcox(hdc);                   // lock the dc object

        if (dcox.bValid())                 // check if lock is valid
        {

            dcox.pdc->lVirtualDevicePixelCx(cxVirtualDevicePixel);
            dcox.pdc->lVirtualDevicePixelCy(cyVirtualDevicePixel);

            dcox.pdc->lVirtualDeviceMmCx(cxVirtualDeviceMm);
            dcox.pdc->lVirtualDeviceMmCy(cyVirtualDeviceMm);

            bRet = TRUE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiSetSizeDevice()
*
* This is to compensate insufficient precision in SetVirtualResolution
*
* Modified for client side use.
*
*  5/17/99 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL APIENTRY NtGdiSetSizeDevice(
    HDC    hdc,
    int    cxVirtualDevice,       // Width of the virtual device in micrometers
    int    cyVirtualDevice)       // Height of the virtual device in micrometers
{
    BOOL bRet = FALSE;

// The units must be all zeros or all non-zeros.

    if ((cxVirtualDevice != 0) && (cyVirtualDevice != 0))
    {
    // now lock down the DC

        DCOBJ dcox(hdc);                   // lock the dc object

        if (dcox.bValid())                 // check if lock is valid
        {

            dcox.pdc->lVirtualDeviceCx(cxVirtualDevice);
            dcox.pdc->lVirtualDeviceCy(cyVirtualDevice);

            bRet = TRUE;
        }
    }

    return(bRet);
}



/******************************Public*Routine******************************\
* GreGetTransform()
*
* History:
*  05-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL GreGetTransform(
    HDC     hdc,
    DWORD   iXform,
    XFORML *pxf)
{
    XFORMPRINT(1,"GreGetTransform - iXform = %ld\n",iXform);

    BOOL bRet = FALSE;

    // now lock down the DC

    DCOBJ dcox(hdc);

    if (dcox.bValid())
    {

        EXFORMOBJ xo(dcox,iXform);
        MATRIX mx;

        if (!xo.bValid() && (iXform == XFORM_PAGE_TO_DEVICE))
        {
            xo.vInitPageToDevice(dcox,&mx);
        }

        if (xo.bValid())
        {
            xo.vGetCoefficient(pxf);

            bRet = TRUE;
        }
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* XformUpdate
*
*  Sends update transform information to the server.
*
* History:
*  6-Aug-1992 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

VOID EXFORMOBJ::vInit(
    XDCOBJ& dco,
    ULONG iXform)
{
    XFORMPRINT(1,"EXFORMOBJ::vInit - iXform = %lx\n",iXform);

    if (dco.pdc->bDirtyXform())
    {
    // Save current position

        if (!dco.pdc->bValidPtlCurrent())
        {
            ASSERTGDI(dco.pdc->bValidPtfxCurrent(), "Both CPs invalid?");

            EXFORMOBJ exoDtoW(dco.pdc->mxDeviceToWorld());

            if (exoDtoW.bValid())
                exoDtoW.bXform(&dco.ptfxCurrent(), &dco.ptlCurrent(), 1);

            dco.pdc->vValidatePtlCurrent();
        }

    // update the transforms

        dco.pdc->vUpdateWtoDXform();

    // After the transform, the device space CP will be invalid:

        dco.pdc->vInvalidatePtfxCurrent();

        if( dco.pdc->flXform() & INVALIDATE_ATTRIBUTES)
        {

            EXFORMOBJ exoWtoD(dco.pdc->mxWorldToDevice());

            dco.pdc->vRealizeLineAttrs(exoWtoD);
            dco.pdc->vXformChange(TRUE);
            dco.pdc->flClr_flXform(INVALIDATE_ATTRIBUTES);
        }

        dco.pdc->flSet_flXform(DEVICE_TO_WORLD_INVALID);
    }

    switch (iXform)
    {
    case XFORM_WORLD_TO_DEVICE:
        pmx = &dco.pdc->mxWorldToDevice();
        XFORMPRINT(2,"EXFORM::vInit - WtoD, pmx = %p\n",pmx);
        break;

    case XFORM_DEVICE_TO_WORLD:
        pmx = &dco.pdc->mxDeviceToWorld();

        if (dco.pdc->flXform() & DEVICE_TO_WORLD_INVALID)
        {
            if (bInverse(dco.pdc->mxWorldToDevice()))
            {
               dco.pdc->flClr_flXform(DEVICE_TO_WORLD_INVALID);
               RtlCopyMemory(
                              (PVOID)&dco.pdc->mxUserDeviceToWorld(),
                              (PVOID)pmx,
                              sizeof( MATRIX )
                            );

            }
            else
            {
               pmx = (PMATRIX)NULL;
            }
            XFORMPRINT(2,"EXFORM::vInit - DtoW was dirty, pmx = %p\n",pmx);
        }
        break;

    case XFORM_WORLD_TO_PAGE:
        XFORMPRINT(2,"EXFORM::vInit - WtoP, pmx = %p\n",pmx);
        pmx = &dco.pdc->mxWorldToPage();
        break;

    default:
        XFORMPRINT(2,"EXFORM::vInit - NULL",pmx);
        pmx = NULL;
        break;
    }
}

/******************************Public*Routine******************************\
* EXFORMOBJ::vInitPageToDevice()
*
* History:
*  05-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID EXFORMOBJ::vInitPageToDevice(
    XDCOBJ& dco,
    PMATRIX pmx_)
{
    pmx = pmx_;

    pmx->efM11 = dco.pdc->efM11PtoD();
    pmx->efM12.vSetToZero();
    pmx->efM21.vSetToZero();
    pmx->efM22 = dco.pdc->efM22PtoD();
    pmx->efDx  = dco.pdc->efDxPtoD();
    pmx->efDy  = dco.pdc->efDyPtoD();
    pmx->efDx.bEfToL(pmx->fxDx);
    pmx->efDy.bEfToL(pmx->fxDy);

    vComputeWtoDAccelFlags();
}

/******************************Private*Routine*****************************\
* vUpdateWtoDXform
*
* Update the world to device transform.
*
* History:
*
*  15-Dec-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID DC::vUpdateWtoDXform()
{
    PMATRIX pmx = &mxWorldToDevice();

    if (bDirtyXlateOrExt())
    {
        if (bPageExtentsChanged())
        {
        // Recalculate the scaling factors for the page to device xform.

        // M11 = ViewportExt.cx / WindowExt.cx
        // M22 = ViewportExt.cy / WindowExt.cy

            if (ulMapMode() == MM_ISOTROPIC)
                vMakeIso();

            if ((lWindowExtCx() == lViewportExtCx()) &&
                (lWindowExtCy() == lViewportExtCy()))
            {
                efM11PtoD(ef16);
                efM22PtoD(ef16);

                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_UNITY | XFORM_SCALE;

                flSet_flXform(PAGE_TO_DEVICE_SCALE_IDENTITY);
            }
            else
            {
                EFLOATEXT ef1;
                EFLOATEXT ef2;
                ef1 = LTOFX(lViewportExtCx());
                ef2 = lWindowExtCx();
                ef1 /= ef2;
                efM11PtoD(ef1);

                ef1 = LTOFX(lViewportExtCy());
                ef2 = lWindowExtCy();
                ef1 /= ef2;
                efM22PtoD(ef1);

                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE;
                flClr_flXform(PAGE_TO_DEVICE_SCALE_IDENTITY | PAGE_TO_DEVICE_IDENTITY);
            }

            if (efM11PtoD().bIsNegative())
                flSet_flXform(PTOD_EFM11_NEGATIVE);
            else
                flClr_flXform(PTOD_EFM11_NEGATIVE);

            if (efM22PtoD().bIsNegative())
                flSet_flXform(PTOD_EFM22_NEGATIVE);
            else
                flClr_flXform(PTOD_EFM22_NEGATIVE);
        }

    // Recalculate the translations for the page to device xform.

    // Dx = ViewportOrg.x - (ViewportExt.cx / WindowExt.cx) * WindowOrg.x
    // (ViewportExt.cx / WindowExt.cx) = efM11

    // Dy = ViewportOrg.y - (ViewportExt.cy / WindowExt.cy) * WindowOrg.cy
    // (ViewportExt.cy / WindowExt.cy) = efM22

        if ((lWindowOrgX() == 0) &&
            (lWindowOrgY() == 0))
        {
            if ((lViewportOrgX() == 0) &&
                (lViewportOrgY() == 0))
            {
                EFLOAT efZ;
                efZ.vSetToZero();

                efDxPtoD(efZ);
                efDyPtoD(efZ);
                pmx->fxDx = 0;
                pmx->fxDy = 0;
                pmx->flAccel |= XFORM_NO_TRANSLATION;

                if (bPageToDeviceScaleIdentity())
                    flSet_flXform(PAGE_TO_DEVICE_IDENTITY);
            }
            else
            {
                efDxPtoD(LTOFX(lViewportOrgX()));
                efDyPtoD(LTOFX(lViewportOrgY()));

                pmx->fxDx = LTOFX(lViewportOrgX());
                pmx->fxDy = LTOFX(lViewportOrgY());

                pmx->flAccel &= ~XFORM_NO_TRANSLATION;
                flClr_flXform(PAGE_TO_DEVICE_IDENTITY);
            }
        }
        else
        {
            flClr_flXform(PAGE_TO_DEVICE_IDENTITY);
            pmx->flAccel &= ~XFORM_NO_TRANSLATION;
            if (bPageToDeviceScaleIdentity())
            {
                efDxPtoD(LTOFX(-lWindowOrgX()));
                efDyPtoD(LTOFX(-lWindowOrgY()));

                if ((lViewportOrgX() != 0) ||
                    (lViewportOrgY() != 0))
                {
                    goto ADD_VIEWPORT_ORG;
                }

                pmx->fxDx = LTOFX(-lWindowOrgX());
                pmx->fxDy = LTOFX(-lWindowOrgY());
            }
            else
            {
                {
                    EFLOATEXT ef;
                    ef = -lWindowOrgX();
                    ef *= efrM11PtoD();
                    efDxPtoD(ef);

                    ef = -lWindowOrgY();
                    ef *= efrM22PtoD();
                    efDyPtoD(ef);
                }

                if ((lViewportOrgX()!= 0) ||
                    (lViewportOrgY() != 0))
                {
                ADD_VIEWPORT_ORG:

                    EFLOATEXT efXVO(LTOFX(lViewportOrgX()));
                    efXVO += efrDxPtoD();
                    efDxPtoD(efXVO);

                    EFLOATEXT efYVO(LTOFX(lViewportOrgY()));
                    efYVO += efrDyPtoD();
                    efDyPtoD(efYVO);
                }

                efDxPtoD().bEfToL(pmx->fxDx);
                efDyPtoD().bEfToL(pmx->fxDy);
            }
        }

        if (bWorldToPageIdentity())
        {
        // Copy the PAGE_TO_DEVICE xform to WORLD_TO_DEVICE.
        // pmx->fxDx, fxDy and flAccel has been set earlier in this routine.

            pmx->efM11 = efM11PtoD();
            pmx->efM22 = efM22PtoD();
            pmx->efM12.vSetToZero();
            pmx->efM21.vSetToZero();
            pmx->efDx  = efDxPtoD();
            pmx->efDy  = efDyPtoD();

            if (bPageToDeviceIdentity())
                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE | XFORM_UNITY |
                               XFORM_NO_TRANSLATION;
            else if (bPageToDeviceScaleIdentity())
                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE | XFORM_UNITY;
            else
                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE;

            flClr_flXform(PAGE_XLATE_CHANGED | PAGE_EXTENTS_CHANGED |
                          WORLD_XFORM_CHANGED);


            RtlCopyMemory( (PVOID) &mxUserWorldToDevice(), pmx, sizeof( MATRIX ));

            return;
        }
    }
    else
    {
        if (bWorldToPageIdentity())
        {
        // World transform has changed to identity.

            pmx->efM11 = efM11PtoD();
            pmx->efM22 = efM22PtoD();
            pmx->efM12.vSetToZero();
            pmx->efM21.vSetToZero();
            pmx->efDx  = efDxPtoD();
            pmx->efDy  = efDyPtoD();

            efDxPtoD().bEfToL(pmx->fxDx);
            efDyPtoD().bEfToL(pmx->fxDy);

            if (bPageToDeviceIdentity())
                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE | XFORM_UNITY |
                               XFORM_NO_TRANSLATION;
            else if (bPageToDeviceScaleIdentity())
                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE | XFORM_UNITY;
            else
                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE;

            flClr_flXform(PAGE_XLATE_CHANGED | PAGE_EXTENTS_CHANGED |
                          WORLD_XFORM_CHANGED);

            RtlCopyMemory( (PVOID) &mxUserWorldToDevice(), pmx, sizeof( MATRIX ));
            return;
        }
    }

// Multiply the world to page and page to device xform together.

    PMATRIX pmxWtoP = &mxWorldToPage();

    if (bPageToDeviceScaleIdentity())
    {
        RtlCopyMemory(pmx, pmxWtoP, offsetof(MATRIX, flAccel));
        pmx->efM11.vTimes16();
        pmx->efM12.vTimes16();
        pmx->efM21.vTimes16();
        pmx->efM22.vTimes16();
        pmx->efDx.vTimes16();
        pmx->efDy.vTimes16();
    }
    else
    {
        pmx->efM11.eqMul(pmxWtoP->efM11,efM11PtoD());
        pmx->efM21.eqMul(pmxWtoP->efM21,efM11PtoD());
        pmx->efM12.eqMul(pmxWtoP->efM12,efM22PtoD());
        pmx->efM22.eqMul(pmxWtoP->efM22,efM22PtoD());

        pmx->efDx.eqMul(pmxWtoP->efDx,efM11PtoD());
        pmx->efDy.eqMul(pmxWtoP->efDy,efM22PtoD());
    }

    pmx->efDx += efrDxPtoD();
    pmx->efDx.bEfToL(pmx->fxDx);

    pmx->efDy += efrDyPtoD();
    pmx->efDy.bEfToL(pmx->fxDy);

    if (pmx->efM12.bIsZero() && pmx->efM21.bIsZero())
    {
        if (pmx->efM11.bIs16() && pmx->efM22.bIs16())
            pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE | XFORM_UNITY;
        else
            pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE;
    }
    else
    {
        pmx->flAccel = XFORM_FORMAT_LTOFX;
    }

    if ((pmx->fxDx == 0) && (pmx->fxDy == 0))
        pmx->flAccel |= XFORM_NO_TRANSLATION;

    flClr_flXform(PAGE_XLATE_CHANGED | PAGE_EXTENTS_CHANGED |
                 WORLD_XFORM_CHANGED);

    RtlCopyMemory((PVOID)&mxUserWorldToDevice(),pmx,sizeof(MATRIX));

}


/******************************Private*Routine*****************************\
* bWordXformIdentity
*
* See is a world transform matrix is identity.
*
* History:
*
*  6-Aug-1992 -by- Gerrit van Wingerden [gerritv]
* Modified for client side use.
*
*  26-Dec-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL bWorldXformIdentity(CONST XFORML *pxf)
{
    return((pxf->eM11 == IEEE_1_0F) && (pxf->eM12 == IEEE_0_0F) &&
           (pxf->eM21 == IEEE_0_0F) && (pxf->eM22 == IEEE_1_0F) &&
           (pxf->eDx  == IEEE_0_0F) && (pxf->eDy  == IEEE_0_0F));
}


/******************************Public*Routine******************************\
* NtGdiModifyWorldTransform()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiModifyWorldTransform(
    HDC     hdc,
    LPXFORM pxf,
    DWORD   iXform
    )
{
    XFORMPRINT(1,"GreModifyWorldTransform - iXform = %ld\n",iXform);

    ASSERTGDI(sizeof(XFORM) == sizeof(XFORML),"sizeof(XFORM) != sizeof(XFORML)\n");

    BOOL bRet = FALSE;

    DCOBJ dcox(hdc);

    if (dcox.bValid())
    {
        XFORML xf;

        if (pxf)
        {
            bRet = ProbeAndConvertXFORM((XFORML *)pxf, &xf);
        }
        else
        {
            // must be identity to allow pxf == NULL

            bRet = (iXform == MWT_IDENTITY);
        }

        if (bRet)
        {
            bRet = dcox.bModifyWorldTransform(&xf,iXform);
        }
    }

    return(bRet);
}



/******************************Public*Routine******************************\
* XDCOBJ::bModifyWorldTransform()
*
* History:
*  07-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XDCOBJ::bModifyWorldTransform(
    CONST XFORML *pxf,
    ULONG         iMode)
{
    BOOL bRet = FALSE;
    MATRIX  mx;

    switch (iMode)
    {
    case MWT_SET:
        if (!bWorldXformIdentity(pxf))
        {
            vConvertXformToMatrix(pxf, &mx);

            if (bWorldMatrixInRange(&mx))       // check if the new world xform is
            {                                   // within the min, max range.
                RtlCopyMemory(&pdc->mxWorldToPage(), &mx, offsetof(MATRIX, flAccel));
                RtlCopyMemory(&pdc->mxUserWorldToPage(), &mx, offsetof(MATRIX, flAccel));
                pdc->vClrWorldXformIdentity();
                bRet = TRUE;
            }
            break;
        }
    //MWT_IDENTITY must follow MWT_SET.  This will fall through if it is identity

    case MWT_IDENTITY:
        if (!pdc->bWorldToPageIdentity())
        {
            RtlCopyMemory(&pdc->mxWorldToPage(), &gmxIdentity_LToL, offsetof(MATRIX, flAccel));
            RtlCopyMemory(&pdc->mxUserWorldToPage(), &gmxIdentity_LToL, offsetof(MATRIX, flAccel));
            pdc->vSetWorldXformIdentity();
        }
        bRet = TRUE;
        break;

    case MWT_LEFTMULTIPLY:
    case MWT_RIGHTMULTIPLY:
        vConvertXformToMatrix(pxf,&mx);

        if (!pdc->bWorldToPageIdentity())
        {
            EXFORMOBJ xoWtoP(*this,XFORM_WORLD_TO_PAGE);

            if (!xoWtoP.bMultToWorld(&mx, iMode))
                break;
        }

        if (!bWorldMatrixInRange(&mx))      // check if the new world xform is
            break;                          // within the min, max range.

        RtlCopyMemory( &pdc->mxWorldToPage(), &mx, offsetof(MATRIX, flAccel));
        RtlCopyMemory( &pdc->mxUserWorldToPage(), &mx, offsetof(MATRIX, flAccel));

    // Check if the resultant matrix is identity.

        if (memcmp(&mx, &gmxIdentity_LToL, offsetof(MATRIX, flAccel)))
        {
            pdc->vClrWorldXformIdentity();
        }
        else
        {
            pdc->vSetWorldXformIdentity();
        }
        bRet = TRUE;
        break;

    default:
        WARNING("invalid mode passed to GreModifyWorldTransform\n");
        break;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GreCombineTransform
*
*  Concatenate two transforms together by (*pxfSrc1) x (*pxfSrc2).
*
* History:
*
*  6-Aug-1992 -by- Gerrit van Wingerden [gerritv]
* Modified for client side use.
*
*  24-Jan-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL GreCombineTransform(
    XFORML *pxfDst,
    XFORML *pxfSrc1,
    XFORML *pxfSrc2)
{
    MATRIX  mx1,mx2,mxDst;

    vConvertXformToMatrix(pxfSrc1, &mx1);
    vConvertXformToMatrix(pxfSrc2, &mx2);

    EXFORMOBJ xoDst(mxDst);

    if (!xoDst.bMultiply(&mx1, &mx2))
        return(FALSE);

    xoDst.flAccel(XFORM_FORMAT_LTOL);

    xoDst.vGetCoefficient(pxfDst);
    return(TRUE);
}

/******************************Public*Routine******************************\
* NtGdiUpdateTransform
*
*     This routine flushes the current transform
*
* History:
* 7/2/98 -by- Lingyun Wang [lingyunw]
\**************************************************************************/

BOOL NtGdiUpdateTransform(HDC hdc)
{
    BOOL bRet = TRUE;

    // update the transforms
    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
       dco.pdc->vUpdateWtoDXform();

       dco.vUnlock();
    }
    else
    {
        bRet = FALSE;
    }

    return (bRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\wndobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: wndobj.cxx
*
* WNDOBJ support routines.
*
* Created: 22-Sep-1993 17:42:20
* Author: Wendy Wu [wendywu]
*         Hock San Lee [hockl]
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

#if DBG

long glDebugLevel = 0;
#define DBGINFO(str)  if (glDebugLevel >= 2) DbgPrint("GLSRVL: " str)
#define DBGENTRY(str) if (glDebugLevel >= 8) DbgPrint("GLSRVL: " str)

#else

#define DBGINFO(str)
#define DBGENTRY(str)

#endif


// Global tracking object (TRACKOBJ) pointer.
// If this is non-null, we are tracking some WNDOBJs in the system.

PTRACKOBJ gpto = (PTRACKOBJ)NULL;

// Global that indicates whether to notify driver with the new WNDOBJ
// states following a WNDOBJ creation.  User has not changed the window
// states but this is required to initialize the driver.  The update is
// done in the parent gdi functions (e.g. SetPixelFormat) that allow
// the DDI to create a WNDOBJ.

BOOL gbWndobjUpdate;

// The following is a global uniqueness that gets bumped up anytime USER
// changes anyone's VisRgn:

ULONG giVisRgnUniqueness = 0;

// Maximum region rectangle

RECTL grclMax = {
    MIN_REGION_COORD,
    MIN_REGION_COORD,
    MAX_REGION_COORD,
    MAX_REGION_COORD
};

// Here is a brief description of the semaphore usage.
//
// There are 3 semaphores that this module uses/references.
//
// 1. User critical section.
//    The user critical section ensures that no window moves when a new
//    update occurs.  It is only relevent to the display DCs to ensure a
//    consistent window client regions state.  For example, GreSetClientRgn
//    assumes that no window can move until GreClientRgnUpdated is called.
//
// 2. Display devlock and DC/surface locks.
//    The display devlock must be entered when a WNDOBJ is being used or
//    updated.  This prevents a WNDOBJ from being modified when it is
//    being used in the DDI.  The display devlock applies to the display
//    DCs only.  For memory and printer DCs, the surface is locked when
//    a WNDOBJ is used.  This is the current GDI design to prevent a
//    different thread from deleting a surface while it is being used.
//    Note that this precludes any multi-thread access to the printer or
//    memory DCs.
//
// 3. Window object semaphore.
//    The window object semaphore is used to protect access to the window
//    object data structures.  Note that a semaphore is used instead of
//    a mutex here to allow for process cleanup of the semaphore.  The
//    process cleanup is done in the user process cleanup code.
//
// The above 3 semaphores must be entered in the given order.  Otherwise,
// a deadlock may occur.


/******************************Member*Function*****************************\
* VOID TRACKOBJ::vUpdateDrvDelta
*
* Update driver function for delta regions.  fl must have
* WOC_RGN_CLIENT_DELTA or WOC_RGN_SURFACE_DELTA set.
* Note that if the delta is empty, we do not need to call the driver.
* The compiler does not allow this function to be inline because or forward
* reference.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID TRACKOBJ::vUpdateDrvDelta(EWNDOBJ *pwo, FLONG fl)
{
    ASSERTGDI(fl & (WOC_RGN_CLIENT_DELTA|WOC_RGN_SURFACE_DELTA),
        "TRACKOBJ::vUpdateDrvDelta, Bad flags\n");

    if (!pwo->erclExclude().bEmpty())
        (*pfn)((WNDOBJ *)pwo, fl);
}

/******************************Public*Function*****************************\
* EngCreateWnd
*
* Create a WNDOBJ from a HWND.  This function should only be called
* when the calling thread has the usercrit and devlock in that order.
* GDI will ensure that the thread acquires both locks before calling the
* DDIs that allow EngCreateWnd to be called.  The driver should only call
* this function from those DDI entry points.  Currently, GreSetPixelFormat
* acquires both locks before calling DrvSetPixelFormat; GreExtEscape for
* WNDOBJ_SETUP escape also acquires both locks before calling DrvEscape.
*
* This function allows tracking multiple surfaces (screen, bitmaps and
* printers).  For each display surface being tracked, it further allows
* multiple TRACKOBJs to be created for each driver function.  The TRACKOBJs
* on a device surface are identified by unique pfn function pointers.
* This allows a live video driver and an OpenGL driver to track windows
* independently of each other.  The only restriction is that a window on
* a surface cannot be tracked by more than one TRACKOBJs on that surface.
*
* A WNDOBJ has an associated pixel format.  Once a WNDOBJ is created with
* a given pixel format, it cannot be set to a different pixel format.  If
* there is no pixel format associated with a WNDOBJ, e.g. live video,
* it should be set to zero.
*
* The WNDOBJ created in this function does not have the current states
* until the first driver update function is called.  However, the driver
* may immediately associate its own data with the WNDOBJ by calling the
* WNDOBJ_vSetConsumer function.
*
* Once a WNDOBJ is created, it cannot be deleted by the driver.  Gdi will
* will notifiy the driver of the deletion when the window goes away or
* when the associated surface is deleted.
*
* The given hwnd identifies the user window to be tracked.  It must be 0
* if the surface is a printer or memory bitmap.
*
* Returns the new WNDOBJ pointer if a WNDOBJ is created; 0 if an error
* occurs; -1 if hwnd is already being tracked by this driver function.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  27-Sep-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

// This is a private clean up class for this function.

class WO_CLEANUP
{
private:
    BOOL      bKeep;            // TRUE if resouces should not be freed
    PTRACKOBJ pto;
    PEWNDOBJ  pwoSurf;
    PEWNDOBJ  pwoClient;
    PREGION   prgnSurf;
    PREGION   prgnClient;
    HSEMAPHORE hsemClient;

public:
    WO_CLEANUP()
    {
        bKeep      = FALSE;
        pto        = (PTRACKOBJ)NULL;
        pwoSurf    = (PEWNDOBJ)NULL;
        pwoClient  = (PEWNDOBJ)NULL;
        prgnSurf   = (PREGION)NULL;
        prgnClient = (PREGION)NULL;
        hsemClient = NULL;
    }

    VOID vSetTrackobj(PTRACKOBJ pto1)           { pto        = pto1; }
    VOID vSetSurfWndobj(PEWNDOBJ pwo)           { pwoSurf    = pwo; }
    VOID vSetClientWndobj(PEWNDOBJ pwo)         { pwoClient  = pwo; }
    VOID vSetSurfRegion(RGNMEMOBJ &rmo)         { prgnSurf   = rmo.prgnGet();}
    VOID vSetClientRegion(RGNMEMOBJ &rmo)       { prgnClient = rmo.prgnGet();}
    VOID vSetClientSem(HSEMAPHORE hsem)         { hsemClient = hsem; }
    PTRACKOBJ ptoGet()                          { return(pto); }

    VOID vKeepAll()                             { bKeep = TRUE; }

   ~WO_CLEANUP()
    {
        if (bKeep)      return;

        DBGINFO("EngCreateWnd: no WNDOBJ created\n");
        if (pto)        { pto->ident = 0; VFREEMEM(pto); }
        if (pwoSurf)    { pwoSurf->ident = 0; VFREEMEM(pwoSurf); }
        if (pwoClient)  { pwoClient->ident = 0; VFREEMEM(pwoClient); }
        if (prgnSurf)   prgnSurf->vDeleteREGION();
        if (prgnClient) prgnClient->vDeleteREGION();
        if (hsemClient) GreDeleteSemaphore(hsemClient);
    }
};

WNDOBJ * APIENTRY EngCreateWnd
(
    SURFOBJ          *pso,
    HWND             hwnd,
    WNDOBJCHANGEPROC pfn,
    FLONG            fl,
    int              iPixelFormat
)
{
    WO_CLEANUP cleanup;         // prepare for clean up
    PEWNDOBJ   pwoClient;
    PEWNDOBJ   pwoSurf;
    PEWNDOBJ   pwo;
    PTRACKOBJ  pto;
    PEWNDOBJ   pwoGenericSibling = NULL;

    DBGENTRY("EngCreateWnd\n");

    PSURFACE   pSurf = SURFOBJ_TO_SURFACE(pso);

// Assert that we are in user critical section and also hold the devlock.
// This ensures that no one is updating the hwnd.

    if (!UserIsUserCritSecIn())
    {
        RIP("Driver may call EngCreateWnd only from WNDOBJ_SETUP escape\n"
            "(or from OpenGL MCD or ICD escapes)");
        return(NULL);
    }

    CHECKUSERCRITIN;
    if (hwnd)
    {
        CHECKDEVLOCKIN2(pSurf);
    }

// Validate flags.

#if ((WO_VALID_FLAGS & WO_INTERNAL_VALID_FLAGS) != 0)
#error "bad WO_INTERNAL_VALID_FLAGS"
#endif

    if ((fl & ~WO_VALID_FLAGS) != 0)
        return((WNDOBJ *)0);

// If this is the first time we need to track window object, create the
// semaphore for synchronization.  We use a semaphore instead of mutex
// so that we can perform process cleanup of the semaphore.

// Enter the semphore for window object.

    SEMOBJ so(ghsemWndobj);

// If the window is already being tracked by the same TRACKOBJ and the
// pixel format is the same, return -1.  If the window is being tracked
// by a different TRACKOBJ, return 0.  There may be multiple TRACKOBJs
// on the same device surface but a window can be tracked by only one
// TRACKOBJ.  In addition, pixel format in a window cannot be modified
// once it is set.

    for (pto = gpto; pto; pto = pto->ptoNext)
    {
        for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
        {
            if (pwo->hwnd == hwnd)
            {
                KdPrint(("Failing EngCreateWnd -- hwnd already has a WNDOBJ\n"));

                if (pto->pfn == pfn && pwo->ipfd == iPixelFormat)
                    return((WNDOBJ *)-1);   // return -1
                else
                    return((WNDOBJ *)0);    // tracked by a diff TRACKOBJ
            }
        }
    }

// If this is the first time we track a device surface for this driver
// function, we have to allocate space for the TRACKOBJ.  We determine
// if this is a new TRACKOBJ by comparing the pfn with those of the
// existing ones.  This allows the live video, installable opengl, and
// generic opengl windows to be tracked separately.

    for (pto = gpto; pto; pto = pto->ptoNext)
        if (pto->pSurface == pSurf && pto->pfn == pfn)
                break;
    if (!pto)
    {
// Allocate a new TRACKOBJ.

        if (!(pto = (PTRACKOBJ) PALLOCMEM(sizeof(TRACKOBJ), 'dnwG')))
            return((WNDOBJ *)0);
        cleanup.vSetTrackobj(pto);

        pto->ident   = TRACKOBJ_IDENTIFIER;
        // pto->ptoNext
        pto->pwoSurf  = (PEWNDOBJ)NULL;
        pto->pwo      = (PEWNDOBJ)NULL;
        pto->pSurface = pSurf;
        pto->pfn      = pfn;
        pto->fl       = fl;
        pto->erclSurf.left   = 0;
        pto->erclSurf.top    = 0;
        pto->erclSurf.right  = pSurf->sizl().cx;
        pto->erclSurf.bottom = pSurf->sizl().cy;

// Create a surface WNDOBJ for the TRACKOBJ if it requests WO_RGN_SURFACE or
// WO_RGN_SURFACE_DELTA.

        if (fl & (WO_RGN_SURFACE|WO_RGN_SURFACE_DELTA))
        {
            if (!(pwoSurf = (PEWNDOBJ) PALLOCMEM(sizeof(EWNDOBJ), 'dnwG')))
                return((WNDOBJ *)0);
            cleanup.vSetSurfWndobj(pwoSurf);

// Create a surface client region that is the entire surface.

            RGNMEMOBJ rmoSurf((BOOL)FALSE);
            if (!rmoSurf.bValid())
                return((WNDOBJ *)0);
            cleanup.vSetSurfRegion(rmoSurf);
            rmoSurf.vSet((RECTL *)&pto->erclSurf);

// Initialize the surface WNDOBJ.

            pwoSurf->pto        = pto;                  // pto used by vSetClip
            rmoSurf.prgnGet()->vStamp();                // init iUniq
            pwoSurf->vSetClip(rmoSurf.prgnGet(), pto->erclSurf);
            pwoSurf->pvConsumer = 0;
            pwoSurf->psoOwner   = pSurf->pSurfobj();
            pwoSurf->ident      = EWNDOBJ_IDENTIFIER;
            pwoSurf->pwoNext    = (PEWNDOBJ)NULL;       // no next pointer
            pwoSurf->hwnd       = 0;                    // no hwnd
            pwoSurf->fl         = fl | WO_SURFACE;
            pwoSurf->ipfd       = 0;                    // no pixel format

// Add WNDOBJ to the TRACKOBJ.

            pto->pwoSurf = pwoSurf;
        }
    }

// The tracking flags must be consistent.

    if ((pto->fl & ~WO_INTERNAL_VALID_FLAGS) != fl)
        return((WNDOBJ *)0);

// Allocate a new client WNDOBJ.

    if (!(pwoClient = (PEWNDOBJ) PALLOCMEM(sizeof(EWNDOBJ), 'dnwG')))
        return((WNDOBJ *)0);
    cleanup.vSetClientWndobj(pwoClient);

// Create an empty window client region.  The client region is still being
// created.  The driver window region update will be done in the parent gdi
// function.

    ERECTL    erclClient(0,0,0,0);
    RGNMEMOBJ rmoClient((BOOL)FALSE);
    if (!rmoClient.bValid())
        return((WNDOBJ *)0);
    cleanup.vSetClientRegion(rmoClient);
    rmoClient.vSet((RECTL *)&erclClient);

// Initialize the per-WNDOBJ semaphore once per window.

    {
        pwoClient->hsem = GreCreateSemaphore();
        if (pwoClient->hsem == NULL)
        {
            return NULL;
        }
        cleanup.vSetClientSem(pwoClient->hsem);
        fl |= WO_HSEM_OWNER;
    }

// Initialize the WNDOBJ.

    pwoClient->pto        = pto;        // pto used by vSetClip
    rmoClient.prgnGet()->vStamp();      // init iUniq
    pwoClient->vSetClip(rmoClient.prgnGet(), erclClient);
    pwoClient->pvConsumer = 0;          // to be set by the driver
    pwoClient->psoOwner   = pSurf->pSurfobj();
    pwoClient->ident      = EWNDOBJ_IDENTIFIER;
    pwoClient->hwnd       = hwnd;
    pwoClient->fl         = fl;
    pwoClient->ipfd       = iPixelFormat;

// Add WNDOBJ to TRACKOBJ.

    pwoClient->pwoNext = pto->pwo;
    pto->pwo = pwoClient;

    ASSERTGDI(offsetof(EWNDOBJ, pvConsumer) == offsetof(WNDOBJ, pvConsumer),
              "EngCreateWnd: rclClient wrong offset\n");

// Add TRACKOBJ to global linked list.

    if (cleanup.ptoGet())
    {
        pto->ptoNext = gpto;
        gpto = pto;
    }

// If hwnd is given, attach the WNDOBJ to the window in user.
// Otherwise, it is a printer surface or memory bitmap.  Attach it to
// the surface.

    if (hwnd)
    {
        UserAssociateHwnd(hwnd, (PVOID) pwoClient);
    }
    else
    {
// Only one WNDOBJ per memory bitmap or printer surface.

        ASSERTGDI(!pSurf->pwo(),
                  "EngCreateWnd: multiple WNDOBJs unexpected in memory DCs\n");
        pSurf->pwo(pwoClient);
    }

// Inform the parent gdi function that it needs to update the new WNDOBJ
// in the driver.

    pto->fl       |= WO_NEW_WNDOBJ;
    pwoClient->fl |= WO_NEW_WNDOBJ;
    gbWndobjUpdate = TRUE;

// Don't free the PDEV until the WNDOBJ is destroyed.

    PDEVOBJ po(pSurf->hdev());
    po.vReferencePdev();

// Everything is golden.  Keep the created objects and return the new WNDOBJ.

    cleanup.vKeepAll();
    return((WNDOBJ *)pwoClient);
}

/******************************Public*Function*****************************\
* GreDeleteWnd
*
* This function is called when the window that is being tracked is deleted
* in user, or when the device surface (printer or memory bitmap) that
* is begin tracked is deleted.  It deletes the WNDOBJ and notifies the
* driver that the WNDOBJ is going away.
*
* This function does not update the driver with the new client regions
* following the WNDOBJ deletion.  It assumes that if the deletion is a
* window, user will update or has updated the client regions; and if the
* deleteion is a printer or memory bitmap, the TRACKOBJ is going away
* and therefore no need to notify driver.
*
* If the deletion is a window, the calling thread must have the usercrit.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID APIENTRY GreDeleteWnd(PVOID _pwoDelete)
{
    PEWNDOBJ  pwoDelete = (PEWNDOBJ)_pwoDelete;
    PEWNDOBJ  pwo;
    PTRACKOBJ pto;

    DBGENTRY("GreDeleteWnd\n");

// Validate pwoDelete.

    if (!pwoDelete->bValid())
    {
        ASSERTGDI(FALSE, "GreDeleteWnd: Invalid pwoDelete\n");
        return;
    }

// If hwnd is non 0, the user calling thread must hold the usercrit.
// This ensures that no one is updating the hwnd.

    if (pwoDelete->hwnd)
    {
        CHECKUSERCRITIN;
        CHECKDEVLOCKIN2(pwoDelete->pto->pSurface);
    }

    pto = pwoDelete->pto;


// Acquire the device lock.  Note that this may be different from the
// device lock that USER is holding if the PDEV is marked as 'deleted':

    PDEVOBJ po(pto->pSurface->hdev());

    {
        DEVLOCKOBJ dlo(po);

// Enter the semaphore for window object.

        ASSERTGDI(ghsemWndobj, "GreDeleteWnd: bad ghsemWndobj\n");
        SEMOBJ so(ghsemWndobj);

// Notify driver that the WNDOBJ is going away.
// Hold the WNDOBJ stable while doing so by grabbing the per-WNDOBJ semaphore.

        {
            SEMOBJ soClient(pwoDelete->hsem);

            pto->vUpdateDrv(pwoDelete, WOC_DELETE);
        }

// Unlink pwoDelete from chain.

        if (pto->pwo == pwoDelete)
            pto->pwo = pwoDelete->pwoNext;
        else
            for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
            {
                if (pwo->pwoNext == pwoDelete)
                {
                    pwo->pwoNext = pwoDelete->pwoNext;
                    break;
                }
            }

// Free pwoDelete.

        pwoDelete->bDelete();       // delete RGNOBJ
        pwoDelete->ident = 0;
        VFREEMEM(pwoDelete);        // free memory

// Delete the tracking object if there are no more windows to track.

        if (pto->pwo == (PEWNDOBJ)NULL)
        {
// Unlink pto from chain.

            if (pto == gpto)
                gpto = pto->ptoNext;
            else
                for (PTRACKOBJ ptoTmp = gpto; ptoTmp; ptoTmp = ptoTmp->ptoNext)
                {
                    if (ptoTmp->ptoNext == pto)
                    {
                        ptoTmp->ptoNext = pto->ptoNext;
                        break;
                    }
                }

// Delete the pwoSurf if it exists.

            if (pto->pwoSurf)
            {
                ASSERTGDI(pto->fl & (WO_RGN_SURFACE|WO_RGN_SURFACE_DELTA),
                    "GreDeleteWnd: WO_RGN_SURFACE or WO_RGN_SURFACE_DELTA not set\n");

                pto->pwoSurf->bDelete();    // delete RGNOBJ
                pto->pwoSurf->ident = 0;
                VFREEMEM(pto->pwoSurf);     // free memory
            }

            pto->ident = 0;
            VFREEMEM(pto);
        }

// Inform the sprite code that a WNDOBJ has been deleted.

        vSpWndobjChange(po.hdev(), NULL);
    }

// Remove the reference to the PDEV.

    po.vUnreferencePdev();
}

/******************************Public*Function*****************************\
* EngDeleteWnd
*
* Driver-callable entry point to delete a WNDOBJ.
*
\**************************************************************************/

VOID EngDeleteWnd(WNDOBJ* _pwoDelete)
{
    EWNDOBJ* pwoDelete = (EWNDOBJ*)_pwoDelete;

    if (!UserIsUserCritSecIn())
    {
        RIP("Driver may call EngDeleteWnd only from WNDOBJ_SETUP escape\n"
            "(or from OpenGL MCD or ICD escapes)");
    }
    else
    {
// Tell USER to disassociate this WNDOBJ from its window:

        if (pwoDelete->hwnd)
        {
            UserAssociateHwnd(pwoDelete->hwnd, NULL);
        }

        GreDeleteWnd(pwoDelete);
    }
}

/******************************Public*Routine******************************\
* VOID vChangeWndObjs
*
* Transfers ownership of WNDOBJs between PDEVs.
*
* History:
*  8-Feb-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vChangeWndObjs(
SURFACE* pSurfaceOld,
HDEV     hdevOld,
SURFACE* pSurfaceNew,
HDEV     hdevNew)
{
    TRACKOBJ*   pto;
    EWNDOBJ*    pwo;
    EWNDOBJ*    pwoNext;

    CHECKUSERCRITIN;

    SEMOBJ so(ghsemWndobj);

// Note that we shouldn't use pSurfaceOld->hdev() or pSurfaceNew->hdev()
// becuase they haven't been updated yet:

    PDEVOBJ poOld(hdevOld);
    PDEVOBJ poNew(hdevNew);

// Changing drivers.  Delete all WNDOBJs belonging to the old
// surface:

    for (pto = gpto; pto != NULL; pto = pto->ptoNext)
    {
        if (pto->pSurface == pSurfaceOld)
        {
// For every WNDOBJ belonging to this TRACKOBJ, transfer
// ownership to the new PDEV:

            for (pwo = pto->pwo; pwo != NULL; pwo = pwo->pwoNext)
            {
                ASSERTGDI(pwo->psoOwner == pSurfaceOld->pSurfobj(),
                    "Old psoOwner mismatch");

                poNew.vReferencePdev();
                poOld.vUnreferencePdev();
            }
        }
        else if (pto->pSurface == pSurfaceNew)
        {
            for (pwo = pto->pwo; pwo != NULL; pwo = pwo->pwoNext)
            {
                ASSERTGDI(pwo->psoOwner == pSurfaceNew->pSurfobj(),
                    "New psoOwner mismatch");

                poOld.vReferencePdev();
                poNew.vUnreferencePdev();
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID vTransferWndObjs
*
* Transfers ownership of WNDOBJs from PDEV to other PDEV.
*
* History:
*  2-16-1999 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

VOID vTransferWndObjs(
SURFACE* pSurface,
HDEV     hdevOld,
HDEV     hdevNew)
{
    TRACKOBJ*   pto;
    EWNDOBJ*    pwo;
    EWNDOBJ*    pwoNext;

    CHECKUSERCRITIN;

    SEMOBJ so(ghsemWndobj);

    PDEVOBJ poOld(hdevOld);
    PDEVOBJ poNew(hdevNew);

    for (pto = gpto; pto != NULL; pto = pto->ptoNext)
    {
        if (pto->pSurface == pSurface)
        {
            for (pwo = pto->pwo; pwo != NULL; pwo = pwo->pwoNext)
            {
                ASSERTGDI(pwo->psoOwner == pSurface->pSurfobj(),
                    "New psoOwner mismatch");

                KdPrint(("Transfer wndobj %x - hdevNew %x hdevOld %x \n",
                          pwo,hdevNew,hdevOld));

                poNew.vReferencePdev();
                poOld.vUnreferencePdev();
            }
        }
    }
}

/******************************Public*Function*****************************\
* vForceClientRgnUpdate
*
* This function is called by gdi to force an update of the new WNDOBJ
* that is just created.
*
* This function should only be called when the calling thread has the
* usercrit and devlock in that order.  Currently, it is called from
* GreSetPixelFormat and GreExtEscape for WNDOBJ_SETUP escape after
* they detected that the driver has created a new WNDOBJ.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID vForceClientRgnUpdate()
{
    PTRACKOBJ pto;
    PEWNDOBJ  pwo = (PEWNDOBJ)NULL;

    DBGENTRY("vForceClientRgnUpdate\n");

// Assert that we are in user critical section and also hold the devlock.
// This ensures that no one is updating the hwnd.

    CHECKUSERCRITIN;

// Update the new WNDOBJ that was just created.
// User has not changed the client regions because we are still in the
// user critical section.  We are updating the client regions ourselves.

    {
// Enter the semphore for window object.

        SEMOBJ so(ghsemWndobj);

// Find the newly created WNDOBJ.

        for (pto = gpto; pto; pto = pto->ptoNext)
        {
            if (!(pto->fl & WO_NEW_WNDOBJ))
                continue;

            pto->fl &= ~WO_NEW_WNDOBJ;
            pto->fl |= WO_NOTIFIED;

            for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
            {
                if (!(pwo->fl & WO_NEW_WNDOBJ))
                    continue;

                pwo->fl &= ~WO_NEW_WNDOBJ;
                pwo->fl |= WO_NOTIFIED;
                break;          // found it
            }
            break;              // found it
        }

        if (!pwo)
        {
            ASSERTGDI(FALSE, "vForceClientRgnUpdate: no new WNDOBJ found\n");
            return;
        }

// We need to ensure that the caller holds the devlock before calling this
// function.  Otherwise, some other threads may be drawing into the wrong
// client region.  We do the check here because we don't have any pSurf
// information earlier.

        if (pwo->hwnd)
        {
            CHECKDEVLOCKIN2(pto->pSurface);
        }

// If hwnd exists, get the client region from user.

        HRGN   hrgnClient;
        ERECTL erclClient;

        if (pwo->hwnd)
        {
            hrgnClient = UserGetClientRgn(pwo->hwnd,
                                          (LPRECT)&erclClient,
                                          pwo->fl & WO_RGN_WINDOW);
        }
        else
        {
// If hwnd does not exist, this is a memory bitmap or printer surface.
// The client region is the whole surface.

            erclClient = pto->erclSurf;
            hrgnClient = GreCreateRectRgnIndirect((LPRECT)&erclClient);
        }

        if (!hrgnClient)
        {
            ASSERTGDI(FALSE, "vForceClientRgnUpdate: hwnd has no rgn\n");
            return;
        }

// Update client region in the WNDOBJ.

        GreSetRegionOwner(hrgnClient, OBJECT_OWNER_PUBLIC);
        RGNOBJAPI roClient(hrgnClient,FALSE);
        ASSERTGDI(roClient.bValid(), "vForceClientRgnUpdate: invalid hrgnClient\n");

#ifdef OPENGL_MM

// Under Multi-mon we need to adjust the client region and
// client rectangle by the offset of the surface.
// Additionally we need to clip the client region to the
// surface of the TRACKOBJ.

        if (!(pwo->fl & WO_RGN_DESKTOP_COORD))
        {
            PDEVOBJ pdo(pwo->pto->pSurface->hdev());

            if (pdo.bValid())
            {
                if (pdo.bPrimary(pwo->pto->pSurface))
                {
                    POINTL ptlOrigin;

                    ptlOrigin.x = -pdo.pptlOrigin()->x;
                    ptlOrigin.y = -pdo.pptlOrigin()->y;

                    if ((ptlOrigin.x != 0) || (ptlOrigin.y != 0))
                    {
// offset the region and window rect if necessary

                        roClient.bOffset(&ptlOrigin);
                        erclClient += ptlOrigin;      /* this offsets by ptl */
                    }
                }
            }

            RGNMEMOBJTMP rmoTmp;
            RGNMEMOBJTMP rmoRcl;

            if (rmoTmp.bValid() && rmoRcl.bValid())
            {
// this clips the client region to the pto surface

                rmoRcl.vSet((RECTL *) &pto->erclSurf);
                rmoTmp.bCopy(roClient);
                roClient.iCombine(rmoTmp, rmoRcl, RGN_AND);
                if (rmoTmp.iCombine(roClient,rmoRcl,RGN_AND) != ERROR)
                {
                    roClient.bSwap(&rmoTmp);
                }
            }
        }

#endif // OPENGL_MM

// We're going to modify the WNDOBJ now.  Grab the per-WNDOBJ semaphore to
// keep it stable.  Don't release until after the driver is called.

        SEMOBJ soClient(pwo->hsem);

        roClient.bSwap(pwo);
        pwo->prgn->vStamp();                 // init iUniq
        pwo->vSetClip(pwo->prgn, erclClient);
        roClient.bDeleteRGNOBJAPI();         // delete handle too

// Call driver with the new WNDOBJ.

        if (pto->fl & WO_RGN_CLIENT_DELTA)
            pto->vUpdateDrvDelta(pwo, WOC_RGN_CLIENT_DELTA);
        if (pto->fl & WO_RGN_CLIENT)
            pto->vUpdateDrv(pwo, WOC_RGN_CLIENT);

// Let the sprite code know that there's a new WNDOBJ, now completely
// formed.        

        vSpWndobjChange(pto->pSurface->hdev(), pwo);
    }

// Update the remaining window client regions.

    GreClientRgnUpdated(GCR_WNDOBJEXISTS);
}

/******************************Member*Function*****************************\
* GreWindowInsteadOfClient
*
* Returns TRUE if the window area instead of the client area should be
* used for the WNDOBJ regions.
*
\**************************************************************************/

BOOL GreWindowInsteadOfClient(PVOID _pwo)
{
    PEWNDOBJ pwo = (PEWNDOBJ) _pwo;

    return(pwo->fl & WO_RGN_WINDOW);
}

/******************************Member*Function*****************************\
* GreClientRgnUpdated
*
* User calls this function after having updated all the vis/client
* region changes and before releasing the devlock.  We have to complete
* the remaining client region update operation.
*
* Gdi calls vForceClientRgnUpdate and this function after a new WNDOBJ
* is created to update the driver.
*
* This function should only be called when the calling thread has the
* usercrit and devlock in that order.
*
* If the GCR_DELAYFINALUPDATE flag is specified, the caller must
* subsequently call GreClientRgnDone.  If the driver specified
* the WO_DRAW_NOTIFY flag, the GCR_DELAYFINALUPDATE will suppress
* the WOC_DRAWN notification until GreClientRgnDone is called (or
* the next time GreClientRgnUpdated is called without
* GCR_DELAYFINALUPDATE).
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  11-Nov-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID APIENTRY GreClientRgnUpdated(FLONG flUpdate)
{
    PTRACKOBJ pto;
    PEWNDOBJ  pwo;

    DBGENTRY("GreClientRgnUpdated\n");

// Since we are holding the DEVLOCK to the active display, we can
// increment the VisRgn count here without doing an atomic increment.

    giVisRgnUniqueness++;

// Go any further only if some WNDOBJs exist.

    if (!(flUpdate & GCR_WNDOBJEXISTS))
    {
        return;
    }

// Assert that we are in user critical section and also hold the devlock.
// This ensures that no one is updating the hwnd.

    CHECKUSERCRITIN;

// Enter the semphore for window object.

    SEMOBJ so(ghsemWndobj);

// The surface client regions have changed.  Complete the remaining
// client region update.

    for (pto = gpto; pto; pto = pto->ptoNext)
    {
        if (!(pto->fl & WO_NOTIFIED))
            continue;

        pto->fl &= ~WO_NOTIFIED;

// We need to ensure that user holds the devlock before calling this function.
// Otherwise, some other threads may be drawing into the wrong client region.
// We do the check here because we don't have any pSurface information earlier.
//
// Also, we exclude the entire screen since we are going to touch windows all
// over the place and end with calling driver with WOC_COMPLETE which
// can have an effect anywhere on the screen.

        DEVEXCLUDEOBJ dxo;
        if (pto->pwo->hwnd)
        {
            RECTL rclSurf;
            HDEV  hdev = pto->pSurface->hdev();
            PDEVOBJ po(hdev);

            CHECKDEVLOCKIN2(pto->pSurface);

            ASSERTGDI(po.bValid(), "GreClientRgnUpdated: invalid pdevobj\n");

            if (po.bValid() && !po.bDisabled())
            {
                rclSurf.left = 0;
                rclSurf.top = 0;
                rclSurf.right = pto->pSurface->sizl().cx;
                rclSurf.bottom = pto->pSurface->sizl().cy;

                dxo.vExclude(hdev, &rclSurf, (ECLIPOBJ *) NULL);
            }
        }

// Traverse the chain and call the driver with un-changed windows if
// the WO_RGN_UPDATE_ALL and WO_RGN_CLIENT flags are set.

        if ((pto->fl & (WO_RGN_CLIENT|WO_RGN_UPDATE_ALL))
         == (WO_RGN_CLIENT|WO_RGN_UPDATE_ALL))
        {
            for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
                if (pwo->fl & WO_NOTIFIED)
                    pwo->fl &= ~WO_NOTIFIED;
                else
                {
                // Make WNDOBJ stable by holding the per-WNDOBJ semaphore
                // while we call the driver.

                    SEMOBJ soClient(pwo->hsem);

                    pto->vUpdateDrv(pwo, WOC_RGN_CLIENT);
                }
        }

// Update the surface WNDOBJ if requested.

        if (pto->fl & (WO_RGN_SURFACE|WO_RGN_SURFACE_DELTA))
        {
            PEWNDOBJ     pwoSurf = pto->pwoSurf;
            RGNMEMOBJTMP rmoTmp((BOOL)FALSE);
            RGNMEMOBJTMP rmoSurfNew((BOOL)FALSE);

            if (rmoTmp.bValid() && rmoSurfNew.bValid())
            {
// Construct the new surface region which is the entire surface minus
// the combined client regions.

                rmoSurfNew.vSet(&pwoSurf->rclClient);
                for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
                {
                    RGNOBJ  ro(pwo->prgn);
                    if (rmoTmp.iCombine(rmoSurfNew, ro, RGN_DIFF) != ERROR)
                        rmoSurfNew.bSwap(&rmoTmp);
                }

// If WO_RGN_SURFACE_DELTA is set, update the driver with the new surface delta.

                if (pto->fl & WO_RGN_SURFACE_DELTA)
                {
                    RGNOBJ  roSurf(pwoSurf->prgn);
                    if (rmoTmp.iCombine(rmoSurfNew, roSurf, RGN_DIFF) != ERROR)
                    {
                        pwoSurf->bSwap(&rmoTmp);
                        pwoSurf->prgn->vStamp();        // new iUniq
                        pwoSurf->vSetClip(pwoSurf->prgn, *(ERECTL *)&pwoSurf->rclClient);

                        pto->vUpdateDrvDelta(pwoSurf, WOC_RGN_SURFACE_DELTA);
                    }
                }

// Save the new surface region.
// The surface region may be the same as previous one here.  This code can be
// optimized a little.

                pwoSurf->bSwap(&rmoSurfNew);
                pwoSurf->prgn->vStamp();        // new iUniq
                pwoSurf->vSetClip(pwoSurf->prgn, *(ERECTL *)&pwoSurf->rclClient);

// Give the driver the new surface region.

                if (pto->fl & WO_RGN_SURFACE)
                    pto->vUpdateDrv(pwoSurf, WOC_RGN_SURFACE);
            }

        } // if (pto->fl & (WO_RGN_SURFACE|WO_RGN_SURFACE_DELTA))

// Send down the WOC_CHANGED to signify notification complete.

        pto->vUpdateDrv((PEWNDOBJ)NULL, WOC_CHANGED);

// Need WOC_DRAWN notification if requested.  Notification is delayed
// if GCR_DELAYFINALUPDATE is set.  Delayed notification is signaled
// by setting the WO_NEED_DRAW_NOTIFY flag in the trackobj and is
// handled in GreClientRgnDone.

        if (pto->fl & WO_DRAW_NOTIFY)
        {
            if (flUpdate & GCR_DELAYFINALUPDATE)
            {
                pto->fl |= WO_NEED_DRAW_NOTIFY;
            }
            else
            {
                pto->vUpdateDrv((PEWNDOBJ)NULL, WOC_DRAWN);
                pto->fl &= ~WO_NEED_DRAW_NOTIFY;
            }
        }
    } // for (pto = gpto; pto; pto = pto->ptoNext)
}

/******************************Public*Routine******************************\
* GreClientRgnDone
*
* If USER calls GreClientRgnUpdated with the GCR_DELAYFINALUPDATE flag
* set, it must subsequently call this function to complete the update.
*
* If the driver calls EngCreateWnd with the WO_NEED_DRAW_NOTIFY flag,
* the GreClientRgnUpdated function will complete the notification with
* a WOC_CHANGED followed by a WOC_DRAWN.  However, if the
* GCR_DELAYFINALUPDATE flag is specified when calling GreClientRgnUpdated,
* the WOC_DRAWN message is suppressed until GreClientRgnDone is called.
*
* If the driver does not call EngCreateWnd with the WO_NEED_DRAW_NOTIFY
* flag, GreClientRgnDone will only send the WOC_CHANGED notification and
* this function will have no effect.
*
* This function should only be called when the calling thread has the
* usercrit and devlock in that order.
*
* Note: Currently this function does not do anything if GCR_WNDOBJEXISTS
* is not set (GreClientRgnUpdated will update the vis rgn uniqneness and
* so must be called even if there are not WNDOBJs).  Therefore, for now
* it is acceptable for the caller to skip GreClientRgnDone if no WNDOBJs
* exist.
*
* History:
*  19-Dec-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY GreClientRgnDone(FLONG flUpdate)
{
    PTRACKOBJ pto;
    PEWNDOBJ pwo;

    DBGENTRY("GreClientRgnDone\n");

// Go any further only if some WNDOBJs exist.

    if (!(flUpdate & GCR_WNDOBJEXISTS))
    {
        return;
    }

// Assert that we are in user critical section.
// This ensures that no one is updating the hwnd.

    CHECKUSERCRITIN;

// Enter the semphore for window object.

    SEMOBJ so(ghsemWndobj);

// Check which tracking objects need WOC_DRAWN notification.

    for (pto = gpto; pto; pto = pto->ptoNext)
    {
        if (pto->pwo->hwnd)
        {
            CHECKDEVLOCKIN2(pto->pSurface);
        }

        if (pto->fl & WO_NEED_DRAW_NOTIFY)
        {
            pto->fl &= ~WO_NEED_DRAW_NOTIFY;

            pto->vUpdateDrv((PEWNDOBJ)NULL, WOC_DRAWN);
        }

// Inform the sprite code of the change in the WNDOBJ.

        for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
        {
            vSpWndobjChange(pto->pSurface->hdev(), pwo);
        }

    } // for (pto = gpto; pto; pto = pto->ptoNext)
}

/******************************Public*Function*****************************\
* GreSetClientRgn
*
* User calls this function to update the client region in a WNDOBJ.
* After all the regions have been updated, user must call GreClientRgnUpdated
* to complete the update.
*
* User creates a new region to give to this function.  This function must
* delete the region before it returns!
*
* This function should only be called when the calling thread has the
* usercrit and devlock in that order.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID GreSetClientRgn(PVOID _pwoClient, HRGN hrgnClient, LPRECT prcClient)
{
    PEWNDOBJ pwoClient = (PEWNDOBJ)_pwoClient;

    DBGENTRY("GreSetClientRgn\n");

// Assert that we are in user critical section and also hold the devlock.
// This ensures that no one is updating the hwnd.

    CHECKUSERCRITIN;
    if (pwoClient->hwnd)
    {
        CHECKDEVLOCKIN2(pwoClient->pto->pSurface);
    }

// Validate hrgnClient.

    if (!hrgnClient)
    {
        ASSERTGDI(FALSE, "GreSetClientRgn: hrgnClient is NULL\n");
        return;
    }

// Validate pwoClient.

    if (!pwoClient->bValid())
    {
        ASSERTGDI(FALSE, "GreSetClientRgn: Invalid pwoClient\n");
        bDeleteRegion(hrgnClient);
        return;
    }

// The WNDOBJ should only be modified once per update.  A complete
// update includes a call to GreClientRgnUpdated.

#if DBG
    if ((pwoClient->fl & (WO_RGN_CLIENT|WO_RGN_UPDATE_ALL))
     == (WO_RGN_CLIENT|WO_RGN_UPDATE_ALL))
        if (pwoClient->fl & WO_NOTIFIED)
            DbgPrint("GreSetClientRgn: WNDOBJ updated more than once!\n");
#endif // DBG

// Get new and old regions.

    GreSetRegionOwner(hrgnClient, OBJECT_OWNER_PUBLIC);
    RGNOBJAPI roClient(hrgnClient,FALSE);
    ASSERTGDI(roClient.bValid(), "GreSetClientRgn: invalid hrgnClient\n");
    RGNOBJ    roOld(pwoClient->prgn);
    ERECTL    erclClient(prcClient->left,  prcClient->top,
                         prcClient->right, prcClient->bottom);

#ifdef OPENGL_MM

// Under Multi-mon we need to adjust the client region and
// client rectangle by the offset of the surface.
// Additionally we need to clip the client region to the
// surface of the TRACKOBJ.

    if (!(pwoClient->fl & WO_RGN_DESKTOP_COORD))
    {
        PDEVOBJ pdo(pwoClient->pto->pSurface->hdev());

        if (pdo.bValid())
        {
            if (pdo.bPrimary(pwoClient->pto->pSurface))
            {
                POINTL ptlOrigin;

                ptlOrigin.x = -pdo.pptlOrigin()->x;
                ptlOrigin.y = -pdo.pptlOrigin()->y;

                if ((ptlOrigin.x != 0) || (ptlOrigin.y != 0))
                {
// offset the region and window rect if necessary

                    roClient.bOffset(&ptlOrigin);
                    erclClient += ptlOrigin;      /* this offsets by ptl */
                }
            }
        }

        RGNMEMOBJTMP rmoTmp;
        RGNMEMOBJTMP rmoRcl;

        if (rmoTmp.bValid() && rmoRcl.bValid())
        {
// this clips the client region to the pto surface

            rmoRcl.vSet((RECTL *) &pwoClient->pto->erclSurf);
            rmoTmp.bCopy(roClient);
            roClient.iCombine(rmoTmp,rmoRcl,RGN_AND);

            if (rmoTmp.iCombine(roClient,rmoRcl,RGN_AND) != ERROR)
            {
                roClient.bSwap(&rmoTmp);
            }
        }
    }

#endif // OPENGL_MM

// If the regions are equal, no need to notify driver here.

    if (roOld.bEqual(roClient)
     && ((ERECTL *)&pwoClient->rclClient)->bEqual(erclClient))
    {
        roClient.bDeleteRGNOBJAPI();     // delete handle too
        return;
    }

// Enter the semphore for window object.

    SEMOBJ so(ghsemWndobj);

// Now the WNDOBJ is going to get updated.  Hold the per-WNDOBJ semaphore
// and keep it until we are done modifying and the driver update call has
// been made.

    SEMOBJ soClient(pwoClient->hsem);

// Give the driver the client region delta.
// The delta is valid for this call only!

    if (pwoClient->fl & WO_RGN_CLIENT_DELTA)
    {
        RGNMEMOBJTMP rmoDiff((BOOL)FALSE);
        if (rmoDiff.bValid() &&
            (rmoDiff.iCombine(roClient, roOld, RGN_DIFF) != ERROR))
        {
            pwoClient->bSwap(&rmoDiff);
            pwoClient->prgn->vStamp();          // new iUniq
            pwoClient->vSetClip(pwoClient->prgn, erclClient);

            pwoClient->pto->vUpdateDrvDelta(pwoClient, WOC_RGN_CLIENT_DELTA);
        }
    }

// Update the new client region in WNDOBJ.

    roClient.bSwap(pwoClient);
    pwoClient->prgn->vStamp();       // new iUniq
    pwoClient->vSetClip(pwoClient->prgn, erclClient);
    roClient.bDeleteRGNOBJAPI();     // delete handle too

// Give the driver the new client region.

    if (pwoClient->fl & WO_RGN_CLIENT)
    {
        pwoClient->pto->vUpdateDrv(pwoClient, WOC_RGN_CLIENT);
    }

// Mark that we have visited this WNDOBJ and TRACKOBJ.

    pwoClient->fl      |= WO_NOTIFIED;
    pwoClient->pto->fl |= WO_NOTIFIED;

    return;
}

/******************************Member*Function*****************************\
* WNDOBJ_cEnumStart
*
* Start the window client region enumeration for the window object.
*
* This function can be called from the wndobjchangeproc that is passed to
* EngCreateWnd.  It can also be called from DDI function where a WNDOBJ
* is given.
*
* This function should only be called when the calling thread has the
* devlock to ensure that there is no client region change.
*
* In future, we may want to add the pvConsumer and WNDOBJ pointer to the
* CLIPOBJ that is passed to the existing DDI.  In this way, the WNDOBJ
* is always available to the DDI instead of the selected few.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  11-Nov-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

extern "C" ULONG WNDOBJ_cEnumStart(
WNDOBJ  *pwo,
ULONG    iType,
ULONG    iDir,
ULONG    cLimit)
{
    DBGENTRY("WNDOBJ_cEnumStart\n");

    ASSERTGDI(((PEWNDOBJ)pwo)->bValid(), "WNDOBJ_cEnumStart: Invalid pwo\n");

// We need to ensure that the caller holds the devlock before calling this
// function.  Otherwise, some other threads may be drawing into the wrong
// client region.

    if (((PEWNDOBJ)pwo)->hwnd)
    {
        CHECKDEVLOCKIN2(((PEWNDOBJ)pwo)->pto->pSurface);
    }

    return (*(XCLIPOBJ *)pwo).cEnumStart(TRUE, iType, iDir, cLimit);
}

/******************************Member*Function*****************************\
* WNDOBJ_bEnum
*
* Enumerate the client region object in the window object.
*
* This function can be called from the wndobjchangeproc that is passed to
* EngCreateWnd.  It can also be called from DDI function where a WNDOBJ
* is given.
*
* This function should only be called when the calling thread has the
* devlock to ensure that there is no client region change.
*
* In future, we may want to add the pvConsumer and WNDOBJ pointer to the
* CLIPOBJ that is passed to the existing DDI.  In this way, the WNDOBJ
* is always available to the DDI instead of the selected few.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  11-Nov-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

extern "C" BOOL WNDOBJ_bEnum(
WNDOBJ  *pwo,
ULONG   cj,
ULONG   *pul)
{
    DBGENTRY("WNDOBJ_bEnum\n");

    ASSERTGDI(((PEWNDOBJ)pwo)->bValid(), "WNDOBJ_bEnum: Invalid pwo\n");

// We need to ensure that the caller holds the devlock before calling this
// function.  Otherwise, some other threads may be drawing into the wrong
// client region.

    if (((PEWNDOBJ)pwo)->hwnd)
    {
        CHECKDEVLOCKIN2(((PEWNDOBJ)pwo)->pto->pSurface);
    }

    return (*(XCLIPOBJ *)pwo).bEnum(cj, (VOID *)pul);
}

/******************************Member*Function*****************************\
* WNDOBJ_vSetConsumer
*
* Set the driver pvConsumer value in the window object.  It should be
* used to modify the existing pvConsumer value.
*
* This function can be called from the wndobjchangeproc that is passed to
* EngCreateWnd.  It can also be called from DDI function where a WNDOBJ
* is g