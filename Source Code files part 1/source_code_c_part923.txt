[or, at least something bad].
    // die a horrible fiery mangled painful death.
    //
    QUICK_RELEASE(pIPSEx);
    m_fInPlaceActive = FALSE;
    return hr;

}

//=--------------------------------------------------------------------------=
// COleControl::InPlaceDeactivate    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Deactivates an active in-place object and discards the object's undo state.
//
// Output:
//    HRESULT        - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::InPlaceDeactivate
(
    void
)
{
    // if we're not in-place active yet, then this is easy.
    //
    if (!m_fInPlaceActive)
        return S_OK;

    // transition from UIActive back to active
    //
    if (m_fUIActive)
        UIDeactivate();

    // tell the host we're going away
    //
    GetInPlaceSite()->OnInPlaceDeactivate();

    m_fInPlaceActive = FALSE;
    m_fInPlaceVisible = FALSE;


    // if we have a window, tell it to go away.
    //
    if (m_hwnd) {
        ASSERT(!m_pInPlaceSiteWndless, "internal state really messed up");
        
        DestroyWindow(m_hwnd);

        if (m_hwndReflect) {
            SetWindowLong(m_hwndReflect, GWL_USERDATA, 0);
            DestroyWindow(m_hwndReflect);
            m_hwndReflect = NULL;
        }
    }

    RELEASE_OBJECT(m_pInPlaceFrame);
    RELEASE_OBJECT(m_pInPlaceUIWindow);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::UIDeactivate    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// transitions us from UI Active to merely being active [visible]  for
// a control, this doesn't mean all that much.
//
// Output:
//    HRESULT         - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::UIDeactivate
(
    void
)
{
    // if we're not UIActive, not much to do.
    //
    if (!m_fUIActive)
        return S_OK;

    m_fUIActive = FALSE;

    // notify frame windows, if appropriate, that we're no longer ui-active.
    //
    if (m_pInPlaceUIWindow) m_pInPlaceUIWindow->SetActiveObject(NULL, NULL);
    m_pInPlaceFrame->SetActiveObject(NULL, NULL);

    // we don't need to explicitly release the focus here since somebody
    // else grabbing the focus is what is likely to cause us to get lose it
    //
    GetInPlaceSite()->OnUIDeactivate(FALSE);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetObjectRects    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Indicates how much of the control is visible.
//
// Parameters:
//    LPCRECT        - [in] position of the control.
//    LPCRECT        - [in] clipping rectangle for the control.
//
// Output:
//    HRESULT        - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::SetObjectRects
(
    LPCRECT prcPos,
    LPCRECT prcClip
)
{

#ifdef DEBUG
    RECT rcDebug;
    POINT ptDebug;
#endif

    BOOL fRemoveWindowRgn;

    // save out our current location.  windowless controls want this more
    // that windowed ones do, but everybody can have it just in case
    //
	// VEGAS#25109: a-cmai 3/9/98 -- Update m_rcLocation prior to doing
	// work for windowed controls.  This is because the SetWindowPos call
	// may reenter when the control resizes itself.  SetExtent requires that
	// m_rcLocation contains the recent window location
	//
    m_rcLocation = *prcPos;

    // move our window to the new location and handle clipping. not applicable
    // for windowless controls, since the container will be responsible for all
    // clipping.
    //
    if (m_hwnd) {
        fRemoveWindowRgn = m_fUsingWindowRgn;
        if (prcClip) {
            // the container wants us to clip, so figure out if we really
            // need to
            //
            RECT rcIXect;
            if ( IntersectRect(&rcIXect, prcPos, prcClip) ) {
                if (!EqualRect(&rcIXect, prcPos)) {
                    OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));
                    SetWindowRgn(GetOuterWindow(), CreateRectRgnIndirect(&rcIXect), TRUE);
                    m_fUsingWindowRgn = TRUE;
                    fRemoveWindowRgn  = FALSE;
                }
            }
        }

        if (fRemoveWindowRgn) {
            SetWindowRgn(GetOuterWindow(), NULL, TRUE);
            m_fUsingWindowRgn = FALSE;
        }

        RECT rc;
        POINT pt;

        pt.x = pt.y = 0;

        ClientToScreen(GetParent(GetOuterWindow()), &pt);
        GetWindowRect(GetOuterWindow(), &rc);

        OffsetRect(&rc, - pt.x, - pt.y);

        DWORD dwFlags = SWP_NOZORDER | SWP_NOACTIVATE;

        if (rc.left == prcPos->left && rc.top == prcPos->top)
            dwFlags |= SWP_NOMOVE;
        if ((rc.right - rc.left) == (prcPos->right - prcPos->left) && 
            (rc.bottom - rc.top) == (prcPos->bottom - prcPos->top))
            dwFlags |= SWP_NOSIZE;

        // We don't support zooming.  Instead we resize the window
        // to the given size and redraw within the new size.
        //
        // Note: The OuterWindow is either the reflector or control window
        //
        SetWindowPos(GetOuterWindow(), NULL, prcPos->left, 
			prcPos->top, 
			prcPos->right - prcPos->left, 
			prcPos->bottom - prcPos->top, 
			dwFlags);
#if DEBUG

        // Make sure we caused a size change
        //
        if (!(dwFlags & SWP_NOSIZE))
        {
            ptDebug.x = ptDebug.y = 0;

            ClientToScreen(GetParent(GetOuterWindow()), &ptDebug);
            GetWindowRect(GetOuterWindow(), &rcDebug);

            OffsetRect(&rcDebug, - ptDebug.x, - ptDebug.y);

            // If these asserts get tripped that means the size changed between the SetWindowPos call and here
            // Note: SetWindowPos will generate WM_NCCALCSIZE, WM_WINDOWPOSCHANGING and WM_WINDOWPOSCHANGED along with
            //       possible WM_NCPAINT, WM_PAINT and WM_SIZE.  If in response to any of these messages we end up changing
            //       the size, then we may have a problem.
            //        
            if ((prcPos->right - prcPos->left) != (rcDebug.right - rcDebug.left))
                OutputDebugString("Width not set to expected value");
            if ((prcPos->bottom - prcPos->top) != (rcDebug.bottom - rcDebug.top))
                OutputDebugString("Height not set to expected value");            
        }
            
#endif            
	
        // VEGAS#25109: a-cmai 3/9/98 -- Update m_rcLocation
		// after the call to SetWindowPos, since the window pos
		// and or size may have been altered by the control
		//
		GetWindowRect(GetOuterWindow(), &m_rcLocation);
        OffsetRect(&m_rcLocation, - pt.x, - pt.y);

        // No need to resize the window again if GetOuterWindow is the same
        //
        if (m_hwnd && GetOuterWindow() != m_hwnd)
            // We're position within the reflector window, so set position to 0, 0 
            //
            SetWindowPos(m_hwnd, 0, 0, 0, 
                m_rcLocation.right - m_rcLocation.left, 
                m_rcLocation.bottom - m_rcLocation.top,
                SWP_NOZORDER | SWP_NOACTIVATE);				
    }
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ReactivateAndUndo    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Reactivates a previously deactivated object, undoing the last state of the object.
//
// Output:
//    HRESULT        - S_OK, E_NOTUNDOABLE
//
// Notes:
//
STDMETHODIMP COleControl::ReactivateAndUndo
(
    void
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::OnWindowMessage    [IOleInPlaceObjectWindowless]
//=--------------------------------------------------------------------------=
// this method lets the container dispatch a message to a windowless OLE
// object.
//
// Parameters:
//    UINT                - [in]  the message
//    WPARAM              - [in]  the messages wparam
//    LPARAM              - [in]  duh.
//    LRESULT *           - [out] the output value
//
// Output:
//    HRESULT             - S_OK
//
// Notes:
//    - people should call m_pInPlaceSiteWndless->OnDefWindowMessage [control
//      writers should just call OcxDefWindowProc(msg, wparam, lparam)];
//
STDMETHODIMP COleControl::OnWindowMessage
(
    UINT     msg,
    WPARAM   wParam,
    LPARAM   lParam,
    LRESULT *plResult
)
{
    // little bit of pre-processing -- we need to handle some cases here
    // before passing the messages on
    //
    switch (msg) {
        // make sure our UI Activation correctly matches the focus
        //
        case WM_KILLFOCUS:
        case WM_SETFOCUS:
            // give the control site focus notification
            //
            if (m_fInPlaceActive && m_pControlSite)
                m_pControlSite->OnFocus(msg == WM_SETFOCUS);
            break;
    }

    // just pass it to the control's window proc.
    //
    *plResult = WindowProc(msg, wParam, lParam);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetDropTarget    [IOleInPlaceObjectWindowless]
//=--------------------------------------------------------------------------=
// this method returns a pointer to the objects IDropTarget interface.  since
// they do not have a window, windowless objects cannot register an IDropTarget
// interface.
//
// Parameters:
//    IDropTarget **        - [out]
//
// Output:
//    HRESULT               - S_OK, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::GetDropTarget
(
    IDropTarget **ppDropTarget
)
{
    // OVERRIDE: if you want to do drag and drop and you're windowless,
    // override me.
    //
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::TranslateAccelerator    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Processes menu accelerator-key messages from the container's message queue.
//
// Parameters:
//    LPMSG            - [in] the message that has the special key in it.
//
// Output:
//    HRESULT          - S_OK, S_FALSE, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::TranslateAccelerator
(
    LPMSG    pmsg
)
{
    // see if we want it or not.
    //
    if (OnSpecialKey(pmsg))
        return S_OK;

    // if not, then we want to forward it back to the site for further processing
    //
    if (m_pControlSite)
        return m_pControlSite->TranslateAccelerator(pmsg, _SpecialKeyState());

    // we didn't want it.
    //
    return S_FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::OnFrameWindowActivate    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Notifies the control when the container's top-level frame window is
// activated or deactivated.
//
// Parameters:
//    BOOL        - [in] state of containers top level window.
//
// Output:
//    HRESULT     - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnFrameWindowActivate
(
    BOOL fActivate
)
{
    // OVERRIDE:  override this routine if you want floating toolbars,
    // toolboxes, etc.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnDocWindowActivate    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Notifies the active control when the container's document window is
// activated or deactivated.
//
// Parameters:
//    BOOL            - state of mdi child window.
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnDocWindowActivate
(
    BOOL fActivate
)
{
    // OVERRIDE: override this routine if you want floating toolbars,
    // toolboxes, etc.

    // if we're supposed to activate and we're UI active, then just go and
    // default to clearing out the toolbar space.
    //
    if (m_fUIActive && fActivate)
        m_pInPlaceFrame->SetBorderSpace(NULL);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ResizeBorder    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Alerts the control that it needs to resize its border space.
//
// Parameters:
//    LPCRECT               - [in] new outer rectangle for border space
//    IOleInPlaceUIWindow * - [in] the document or frame who's border has changed
//    BOOL                  - [in] true if it was the fram window taht called.
//
// Output:
//    HRESULT               - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::ResizeBorder
(
    LPCRECT              prcBorder,
    IOleInPlaceUIWindow *pInPlaceUIWindow,
    BOOL                 fFrame
)
{
    // this is largely uninteresting to us, since we have no border.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::EnableModeless    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Enables or disables modeless dialog boxes when the container creates or
// destroys a modal dialog box.
//
// Parameters:
//    BOOL            - [in] enable or disable modeless dialogs.
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::EnableModeless
(
    BOOL fEnable
)
{
    // phenomenally uninteresting
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClassInfo    [IProvideClassInfo]
//=--------------------------------------------------------------------------=
// returns the TypeInfo for the control's coclass.
//
// Parameters:
//    ITypeInfo **        - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetClassInfo
(
    ITypeInfo **ppTypeInfo
)
{
    ITypeLib *pTypeLib;
    HRESULT hr;

    CHECK_POINTER(ppTypeInfo);
    *ppTypeInfo = NULL;

    // go and get our type library.
    // CONSIDER: - go to the same sorta scheme that we use for TypeInfo caching.
    // CONSIDER: - consider trying to register our typelib if this fails.
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);  // This is for g_lcidlocale.
    hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType), 
			(USHORT)VERSIONMINOROFOBJECT(m_ObjectType),
                        LANGIDFROMLCID(g_lcidLocale), &pTypeLib);
    LEAVECRITICALSECTION1(&g_CriticalSection);
    RETURN_ON_FAILURE(hr);

    // got the typelib.  get typeinfo for our coclass.
    //
    hr = pTypeLib->GetTypeInfoOfGuid((REFIID)CLSIDOFOBJECT(m_ObjectType), ppTypeInfo);
    pTypeLib->Release();
    RETURN_ON_FAILURE(hr);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ViewChange    [callable]
//=--------------------------------------------------------------------------=
// called whenever the view of the object has changed.
//
// Notes:
//
void COleControl::ViewChanged
(
    void
)
{
    // send the view change notification to anybody listening.
    //
    if (m_pViewAdviseSink) {
        m_pViewAdviseSink->OnViewChange(DVASPECT_CONTENT, -1);

        // if they only asked to be advised once, kill the connection
        //
        if (m_fViewAdviseOnlyOnce)
            SetAdvise(DVASPECT_CONTENT, 0, NULL);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::SetInPlaceVisible    [helper]
//=--------------------------------------------------------------------------=
// controls the visibility of the control window.
//
// Parameters:
//    BOOL        - TRUE shows FALSE hides.
//
// Notes:
//
void COleControl::SetInPlaceVisible
(
    BOOL fShow
)
{
    BOOL fVisible;

    m_fInPlaceVisible = fShow;

    // don't do anything if we don't have a window.  otherwise, set it
    //
    if (m_hwnd) {
        fVisible = ((GetWindowLong(GetOuterWindow(), GWL_STYLE) & WS_VISIBLE) != 0);

        if (fVisible && !fShow)
            ShowWindow(GetOuterWindow(), SW_HIDE);
        else if (!fVisible && fShow)
            ShowWindow(GetOuterWindow(), SW_SHOWNA);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::AmbientPropertyChanged    [overridable]
//=--------------------------------------------------------------------------=
// a method that derived controls can override to do whatever they want.
// we don't particularily care about this event.
//
// Parameters:
//    DISPID            - [in] dispid of prop that changed.
//
// Notes:
//
void COleControl::AmbientPropertyChanged
(
    DISPID dispid
)
{
    // do nothing
}

//=--------------------------------------------------------------------------=
// COleControl::DoCustomVerb    [overridable]
//=--------------------------------------------------------------------------=
// we were asked to execute a verb we don't know about right away.  see if
// it's a verb that the dervied-control defined.
//
// Parameters:
//    LONG            - [in] the verb.
//
// Output:
//    HRESULT         - S_OK, OLEOBJ_S_INVALIDVERB
//
// Notes:
//
HRESULT COleControl::DoCustomVerb
(
    LONG    lVerb
)
{
    return OLEOBJ_S_INVALIDVERB;
}

//=--------------------------------------------------------------------------=
// COleControl::OnSetExtent    [overridable]
//=--------------------------------------------------------------------------=
// let the user do something in the resize, if they care.
//
// Parameters:
//    SIZEL *        - [in] new values.
//
// Output:
//    BOOL           - FALSE means keep current size
//
// Notes:
//
BOOL COleControl::OnSetExtent
(
    SIZEL *pSizeL
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::OnSpecialKey    [overridable]
//=--------------------------------------------------------------------------=
// allows controls to handle special keys such as arrows, CTRL+, etc ...
//
// Parameters:
//    LPMSG        - [in] the special key msg.
//
// Output:
//    BOOL         - TRUE we processed it, FALSE we didn't.
//
// Notes:
//
BOOL COleControl::OnSpecialKey
(
    LPMSG pmsg
)
{
    // do nothing.
    //
    return FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::ModalDialog    [callable, utility]
//=--------------------------------------------------------------------------=
// should be called when the control is about to show and hide a modal dialog.
//
// Parameters:
//    BOOL        - [in] true means showing a modal dialog, false means done
//
// Notes:
//
void COleControl::ModalDialog
(
    BOOL fShow
)
{
    // notify the container of our intention to show a modal dialog...
    //
    if (m_pInPlaceFrame)
        m_pInPlaceFrame->EnableModeless(!fShow);
}

//=--------------------------------------------------------------------------=
// COleControl::BeforeDestroyWindow    [overridable]
//=--------------------------------------------------------------------------=
// called just before we destroy a window.  gives the user the opportunity to
// save information out, especially if they're a subclassed control, and this
// is an interesting thing to do.
//
// Notes:
//
void COleControl::BeforeDestroyWindow
(
    void
)
{
    // fweeee
}

//=--------------------------------------------------------------------------=
// COleControl::OnSetClientSite    [overrideable]
//=--------------------------------------------------------------------------=
// controls should implement this if they hold on to anything off the site.
// this is important to correctly support aggregation.  they must free up
// everything they hold on to, and if m_pClientSite is not NULL, then they
// can re-establish things as they wish.
//
// Parameters:
//    none
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::OnSetClientSite
(
    void
)
{
    // by default, the framework frees up everything in SetClientSite
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\classf.cpp ===
//=--------------------------------------------------------------------------=
// ClassFactory.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the implementation of the ClassFactory object. we support 
// IClassFactory and IClassFactory2
//
#include "pch.h"
#include "LocalSrv.H"

#include "ClassF.H"
#include "Unknown.H"                    // for CREATEFNOFOBJECT

//=--------------------------------------------------------------------------=
// private module level data
//=--------------------------------------------------------------------------=
//

// ASSERT and FAIL require this
//
SZTHISFILE

// private routines for this file
//
HRESULT   CreateOleObjectFromIndex(IUnknown *, int Index, void **, REFIID);

// This is the GUID for a "phantom" interface which VB5 UserControls query
// for to determine if the control doesn't require its license key to be
// present if it's part of a composite UserControl being used in the
// design environment.
//
static const GUID IID_ILicOnCompositeCtl =
{ 0x6e6e9780, 0x165d, 0x11d0, { 0xb3, 0xe6, 0x00, 0xa0, 0xc9, 0x0f, 0x27, 0x31 } };

//=--------------------------------------------------------------------------=
// CClassFactory::CClassFactory
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    int            - [in] index into our global table of objects for this guy
//
// Notes:
//
CClassFactory::CClassFactory
(
    int iIndex
)
: m_iIndex(iIndex)
{
    InterlockedIncrement(&g_cLocks);
    m_cRefs = 1;
}


//=--------------------------------------------------------------------------=
// CClassFactory::~CClassFactory
//=--------------------------------------------------------------------------=
// "Life levels all men.  Death reveals the eminent."
// - George Bernard Shaw (1856 - 1950)
//
// Notes:
//
CClassFactory::~CClassFactory ()
{
    ASSERT(m_cRefs == 0, "Object being deleted with refs!");
    InterlockedDecrement(&g_cLocks);
    return;
}

//=--------------------------------------------------------------------------=
// CClassFactory::QueryInterface
//=--------------------------------------------------------------------------=
// the user wants another interface.  we won't give 'em. very many.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CClassFactory::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    void *pv;

    CHECK_POINTER(ppvObjOut);

    // we support IUnknown, and the two CF interfaces
    //
    if (DO_GUIDS_MATCH(riid, IID_IClassFactory)) {
        pv = (void *)(IClassFactory *)this;
    } else if (DO_GUIDS_MATCH(riid, IID_IClassFactory2)) {
        pv = (void *)(IClassFactory2 *)this;
    } else if (DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        pv = (void *)(IUnknown *)this;
    } else if (g_fUseRuntimeLicInCompositeCtl && riid == IID_ILicOnCompositeCtl) {
        pv = (void *)(IUnknown *)this;
    } else {
        *ppvObjOut = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)pv)->AddRef();
    *ppvObjOut = pv;
    return S_OK;
}




//=--------------------------------------------------------------------------=
// CClassFactory::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CClassFactory::AddRef
(
    void
)
{
    return ++m_cRefs;
}

//=--------------------------------------------------------------------------=
// CClassFactory::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CClassFactory::Release
(
    void
)
{
    ASSERT(m_cRefs, "No Refs, and we're being released!");
    if(--m_cRefs)
        return m_cRefs;

    delete this;
    return 0;
}

//=--------------------------------------------------------------------------=
// CClassFactory::CreateInstance
//=--------------------------------------------------------------------------=
// create an instance of some sort of object.
//
// Parameters:
//    IUnknown *        - [in]  controlling IUknonwn for aggregation
//    REFIID            - [in]  interface id for new object
//    void **           - [out] pointer to new interface object.
//
// Output:
//    HRESULT           - S_OK, E_NOINTERFACE, E_UNEXPECTED,
//                        E_OUTOFMEMORY, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP CClassFactory::CreateInstance
(
    IUnknown *pUnkOuter,
    REFIID    riid,
    void    **ppvObjOut
)
{
    // check args
    //
    if (!ppvObjOut)
        return E_INVALIDARG;

    // check to see if we've done our licensing work.  we do this as late
    // as possible that people calling CreateInstanceLic don't suffer from
    // a performance hit here.
    //
    // crit sect this for apartment threading, since it's global
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!g_fCheckedForLicense) {
        g_fMachineHasLicense = CheckForLicense();
        g_fCheckedForLicense = TRUE;
    }
    LEAVECRITICALSECTION1(&g_CriticalSection);

    // check to see if they have the appropriate license to create this stuff
    //
    if (!g_fMachineHasLicense)
        return CLASS_E_NOTLICENSED;

    // try to create one of the objects that we support
    //
    return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid);
}

//=--------------------------------------------------------------------------=
// CClassFactory::LockServer
//=--------------------------------------------------------------------------=
// lock the server so we can't unload
//
// Parameters:
//    BOOL        - [in] TRUE means addref, false means release lock count.
//
// Output:
//    HRESULT     - S_OK, E_FAIL, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP CClassFactory::LockServer
(
    BOOL fLock
)
{
    // update the lock count.  crit sect these in case of another thread.
    //
    if (fLock)  
        InterlockedIncrement(&g_cLocks);
    else {
        ASSERT(g_cLocks, "D'oh! Lock Counting Problem");
        InterlockedDecrement(&g_cLocks);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CClassFactory::GetLicInfo
//=--------------------------------------------------------------------------=
// IClassFactory2 GetLicInfo
//
// Parameters:
//    LICINFO *          - unclear
//
// Output:
//    HRESULT            - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::GetLicInfo
(
    LICINFO *pLicInfo
)
{
    CHECK_POINTER(pLicInfo);

    // crit sect this for apartment threading, since it's global
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!g_fCheckedForLicense) {
        g_fMachineHasLicense = CheckForLicense();
        g_fCheckedForLicense = TRUE;
    }
    LEAVECRITICALSECTION1(&g_CriticalSection);

    // This says whether RequestLicKey will work
    //
    pLicInfo->fRuntimeKeyAvail = g_fMachineHasLicense;

    // This says whether the standard CreateInstance will work
    //
    pLicInfo->fLicVerified = g_fMachineHasLicense;

    return S_OK;
}


//=--------------------------------------------------------------------------=
// CClassFactory::RequestLicKey
//=--------------------------------------------------------------------------=
// IClassFactory2 RequestLicKey
//
// Parameters:
//    DWORD             - [in]  reserved
//    BSTR *            - [out] unclear
//
// Output:
//    HRESULT           - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::RequestLicKey
(
    DWORD  dwReserved,
    BSTR  *pbstr
)
{
    // crit sect this for apartment threading, since it's global
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!g_fCheckedForLicense) {
        g_fMachineHasLicense = CheckForLicense();
        g_fCheckedForLicense = TRUE;
    }
    LEAVECRITICALSECTION1(&g_CriticalSection);

    // if the machine isn't licensed, then we're not about to give this to them !
    //
    if (!g_fMachineHasLicense)
        return CLASS_E_NOTLICENSED;

    *pbstr = GetLicenseKey();
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
}


//=--------------------------------------------------------------------------=
// CClassFactory::CreateInstanceLic
//=--------------------------------------------------------------------------=
// create a new instance given a licensing key, etc ...
//
// Parameters:
//    IUnknown *        - [in]  controlling IUnknown for aggregation
//    IUnknown *        - [in]  reserved, must be NULL
//    REFIID            - [in]  IID We're looking for.
//    BSTR              - [in]  license key
//    void **           - [out] where to put the new object.
//
// Output:
//    HRESULT           - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::CreateInstanceLic
(
    IUnknown *pUnkOuter,
    IUnknown *pUnkReserved,
    REFIID    riid,
    BSTR      bstrKey,
    void    **ppvObjOut
)
{
    *ppvObjOut = NULL;

    // crit sect this for apartment threading, since it's global
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!g_fCheckedForLicense) {
        g_fMachineHasLicense = CheckForLicense();
        g_fCheckedForLicense = TRUE;
    }
    LEAVECRITICALSECTION1(&g_CriticalSection);

    // go and see if the key they gave us matches.
    //
    if (!CheckLicenseKey(bstrKey))
        return CLASS_E_NOTLICENSED;

    // if it does, then go and create the object.
    //
    return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid);
}

//=--------------------------------------------------------------------------=
// CreateOleObjectFromIndex
//=--------------------------------------------------------------------------=
// given an index in our object table, create an object from it.
//
// Parameters:
//    IUnknown *       - [in]  Controlling Unknown, if any, for aggregation
//    int              - [in]  index into our global table
//    void **          - [out] where to put resulting object.
//    REFIID           - [in]  the interface they want resulting object to be.
//
// Output:
//    HRESULT          - S_OK, E_OUTOFMEMORY, E_NOINTERFACE
//
// Notes:
//
HRESULT CreateOleObjectFromIndex
(
    IUnknown *pUnkOuter,
    int       iIndex,
    void    **ppvObjOut,
    REFIID    riid
)
{
    IUnknown *pUnk = NULL;
    HRESULT   hr;

    // If the object specifies a pre-Create static function call that first.
    //
    if (PRECREATEFNOFOBJECT(iIndex) != NULL) {
        hr = PRECREATEFNOFOBJECT(iIndex)();
        IfFailRet(hr);
    }
      
    // go and create the object
    //
    ASSERT(CREATEFNOFOBJECT(iIndex), "WARNING: Attempt to create an object that doesn't have a Create function.");
	if (!CREATEFNOFOBJECT(iIndex))
		return E_FAIL;

    pUnk = CREATEFNOFOBJECT(iIndex)(pUnkOuter);

    // sanity check and make sure the object actually got allocated.
    //
    RETURN_ON_NULLALLOC(pUnk);

    // make sure we support aggregation here properly -- if they gave us
    // a controlling unknown, then they -must- ask for IUnknown, and we'll
    // give them the private unknown the object gave us.
    //
    if (pUnkOuter) {
        if (!DO_GUIDS_MATCH(riid, IID_IUnknown)) {
            pUnk->Release();
            return E_INVALIDARG;
        }

        *ppvObjOut = (void *)pUnk;
        hr = S_OK;
    } else {

        // QI for whatever the user wants.
        //
        hr = pUnk->QueryInterface(riid, ppvObjOut);
        pUnk->Release();
        RETURN_ON_FAILURE(hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\ctlhelp.cpp ===
//=--------------------------------------------------------------------------=
// CtlHelper.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// helper routines for our COleControl implementation
//
#include "pch.h"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include <windowsx.h>

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// this is used by the window reflection code.
//
extern BYTE g_fRegisteredReflect;
extern const char g_szReflectClassName [];


// define this here, since it's the only guid we really need to define in the
// framework -- the user control defines all other interesting guids.
//
static const GUID IID_IControlPrv =
{ 0xd97180, 0xfcf7, 0x11ce, { 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57 } };


//=--------------------------------------------------------------------------=
// _SpecialKeyState
//=--------------------------------------------------------------------------=
// returns a short with some information on which of the SHIFT, ALT, and CTRL
// keys are set.
//
// Output:
//    short        - bit 0 is shift, bit 1 is ctrl, bit 2 is ALT.
//
// Notes:
//
short _SpecialKeyState()
{
    // don't appear to be able to reduce number of calls to GetKeyState
    //
    BOOL bShift = (GetKeyState(VK_SHIFT) < 0);
    BOOL bCtrl  = (GetKeyState(VK_CONTROL) < 0);
    BOOL bAlt   = (GetKeyState(VK_MENU) < 0);

    return (short)(bShift + (bCtrl << 1) + (bAlt << 2));
}

//=--------------------------------------------------------------------------=
// CopyOleVerb    [helper]
//=--------------------------------------------------------------------------=
// copies an OLEVERB structure.  used in CStandardEnum
//
// Parameters:
//    void *        - [out] where to copy to
//    const void *  - [in]  where to copy from
//    DWORD         - [in]  bytes to copy
//
// Notes:
//
void WINAPI CopyOleVerb
(
    void       *pvDest,
    const void *pvSrc,
    DWORD       cbCopy
)
{
    VERBINFO * pVerbDest = (VERBINFO *) pvDest;
    const VERBINFO * pVerbSrc = (const VERBINFO *) pvSrc;

    *pVerbDest = *pVerbSrc;
    ((OLEVERB *)pVerbDest)->lpszVerbName = OLESTRFROMRESID((WORD)((VERBINFO *)pvSrc)->idVerbName);
}

//=--------------------------------------------------------------------------=
// ControlFromUnknown    [helper, callable]
//=--------------------------------------------------------------------------=
// given an unknown, get the COleControl pointer for it.
//
// Parameters:
//    IUnknown *        - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
COleControl *ControlFromUnknown
(
    IUnknown *pUnk
)
{
	HRESULT hr;
    IControlPrv *pControlPrv = NULL;
	COleControl *pCtl = NULL;

    if (!pUnk) return NULL;
    hr = pUnk->QueryInterface(IID_IControlPrv, (void **)&pControlPrv);
	ASSERT(SUCCEEDED(hr), "Failed to get IControlPrv interface");

	hr = pControlPrv->GetControl(&pCtl);
	ASSERT(SUCCEEDED(hr), "Failed to get COleControl pointer");
	QUICK_RELEASE(pControlPrv);
	
    return pCtl;
}

//=--------------------------------------------------------------------------=
// CreateReflectWindow    [blech]
//=--------------------------------------------------------------------------=
// unfortunately, in certain cases, we have to create two windows, one of
// which exists strictly to reflect messages on to the control.  Majorly
// lame.  Fortunately, the number of hosts which require this is quite small.
//
// Parameters:
//    BOOL        - [in] should it be created visible?
//    HWND        - [in] parent window
//    int         - [in] x pos
//    int         - [in] y pos
//    SIZEL *     - [in] size
//
// Output:
//    HWND        - reflecting hwnd or NULL if it failed.
//
// Notes:
//
HWND CreateReflectWindow
(
    BOOL   fVisible,
    HWND   hwndParent,
    int    x,
    int    y,
    SIZEL *pSize
)
{
    WNDCLASS wndclass;

    // first thing to do is register the window class.  crit sect this
    // so we don't have to move it into the control
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!g_fRegisteredReflect) {

        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.lpfnWndProc = COleControl::ReflectWindowProc;
        wndclass.hInstance   = g_hInstance;
        wndclass.lpszClassName = g_szReflectClassName;

        if (!RegisterClass(&wndclass)) {
            FAIL("Couldn't Register Parking Window Class!");
            LEAVECRITICALSECTION1(&g_CriticalSection);
            return NULL;
        }
        g_fRegisteredReflect = TRUE;
    }

    LEAVECRITICALSECTION1(&g_CriticalSection);

    // go and create the window.
    //
    return CreateWindowEx(0, g_szReflectClassName, NULL,
                          WS_CHILD | WS_CLIPSIBLINGS |((fVisible) ? WS_VISIBLE : 0),
                          x, y, pSize->cx, pSize->cy,
                          hwndParent,
                          NULL, g_hInstance, NULL);
}

//=--------------------------------------------------------------------------=
// in case the user doesn't want our default window proc, we support
// letting them specify one themselves. this is defined in their main ipserver
// file.
//
// Note: As of VB6 we added ParkingWindowProc to the framework.
//       The ParkingWindowProc supports message reflection which is normally
//       the code you add to your implementation of ParkingWindowProc.
//       In most cases you can probably set this to NULL in your control's
//       implementation 
//
extern WNDPROC g_ParkingWindowProc;

//=--------------------------------------------------------------------------=
// GetParkingWindow
//=--------------------------------------------------------------------------=
// creates the global parking window that we'll use to parent things, or
// returns the already existing one
//
// Output:
//    HWND                - our parking window
//
// Notes:
//
HWND GetParkingWindow
(
    void
)
{
    WNDCLASS wndclass;

    // crit sect this creation for apartment threading support.
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (g_hwndParking)
        goto CleanUp;

    ZeroMemory(&wndclass, sizeof(wndclass));
    
    wndclass.lpfnWndProc = (g_ParkingWindowProc) ? g_ParkingWindowProc : COleControl::ParkingWindowProc;
    wndclass.hInstance   = g_hInstance;
    wndclass.lpszClassName = "CtlFrameWork_Parking";

    if (!RegisterClass(&wndclass)) {
        FAIL("Couldn't Register Parking Window Class!");
        goto CleanUp;
    }

    g_hwndParking = CreateWindow("CtlFrameWork_Parking", NULL, WS_POPUP, 0, 0, 0, 0, NULL, NULL, g_hInstance, NULL);
    ASSERT(g_hwndParking, "Couldn't Create Global parking window!!");


  CleanUp:
    LEAVECRITICALSECTION1(&g_CriticalSection);
    return g_hwndParking;
}

//=--------------------------------------------------------------------------=
// ParkingWindowProc
//=--------------------------------------------------------------------------=
// Provides default processing for the parking window.  Since your control
// may be parented by the parking window, we provide message reflection.
//
LRESULT CALLBACK COleControl::ParkingWindowProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LRESULT lResult;

    // If the message is reflected then return the result of the OCM_ message
    //
    if (ReflectOcmMessage(hwnd, msg, wParam, lParam, &lResult))
        return lResult;
    
    return DefWindowProc(hwnd, msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\ctlhelp.h ===
//=--------------------------------------------------------------------------=
// CtlHelper.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// routines to help out our implementation of COleControl.
//


//=--------------------------------------------------------------------------=
// misc functions
//
short       _SpecialKeyState(void);
void WINAPI CopyOleVerb(void *, const void *, DWORD);

HWND        CreateReflectWindow(BOOL fVisible, HWND hwndParent, int, int, SIZEL *);
void        CleanupReflection();

//=--------------------------------------------------------------------------=
// little private guid we'll use to help identify our objects
// {00D97180-FCF7-11ce-A09E-00AA0062BE57}
//
#define Data1_IControlPrv	0xd97180

DEFINE_GUID(IID_IControlPrv, 0xd97180, 0xfcf7, 0x11ce, 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\ctlmisc.cpp ===
//=--------------------------------------------------------------------------=
// ControlMisc.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// things that aren't elsewhere, such as property pages, and connection
// points.
//
#include "pch.h"
#include "CtrlObj.H"
#include "CtlHelp.H"

#include <stdarg.h>

// for ASSERT and FAIL
//
SZTHISFILE

// this is used in our window proc so that we can find out who was last created
//
static COleControl *s_pLastControlCreated;

//=--------------------------------------------------------------------------=
// COleControl::COleControl
//=--------------------------------------------------------------------------=
// constructor
//
// Parameters:
//    IUnknown *          - [in] controlling Unknown
//    int                 - [in] type of primary dispatch interface OBJECT_TYPE_*
//    void *              - [in] pointer to entire object
//
// Notes:
//
COleControl::COleControl
(
    IUnknown *pUnkOuter,
    int       iPrimaryDispatch,
    void     *pMainInterface
)
: CAutomationObjectWEvents(pUnkOuter, iPrimaryDispatch, pMainInterface)
{
    // initialize all our variables -- we decided against using a memory-zeroing
    // memory allocator, so we sort of have to do this work now ...
    //
    m_pClientSite = NULL;
    m_pControlSite = NULL;
    m_pInPlaceSite = NULL;
    m_pInPlaceFrame = NULL;
    m_pInPlaceUIWindow = NULL;


    m_pInPlaceSiteWndless = NULL;

    // certain hosts don't like 0,0 as your initial size, so we're going to set
    // our initial size to 100,50 [so it's at least sort of visible on the screen]
    //
    m_Size.cx = 100;
    m_Size.cy = 50;
    memset(&m_rcLocation, 0, sizeof(m_rcLocation));

    m_hwnd = NULL;
    m_hwndParent = NULL;
    m_hwndReflect = NULL;
    m_fHostReflects = TRUE;
    m_fCheckedReflecting = FALSE;

    m_pSimpleFrameSite = NULL;
    m_pOleAdviseHolder = NULL;
    m_pViewAdviseSink = NULL;
    m_pDispAmbient = NULL;

    m_fDirty = FALSE;
    m_fModeFlagValid = FALSE;
    m_fInPlaceActive = FALSE;
    m_fInPlaceVisible = FALSE;
    m_fUIActive = FALSE;
    m_fSaveSucceeded = FALSE;
    m_fViewAdvisePrimeFirst = FALSE;
    m_fViewAdviseOnlyOnce = FALSE;
    m_fRunMode = FALSE;
    m_fChangingExtents = FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::~COleControl
//=--------------------------------------------------------------------------=
// "We are all of us resigned to death; it's life we aren't resigned to."
//    - Graham Greene (1904-91)
//
// Notes:
//
COleControl::~COleControl()
{
    ASSERT(!m_hwnd, "We shouldn't have a window any more!");

    if (m_hwndReflect) {
        SetWindowLong(m_hwndReflect, GWL_USERDATA, 0);
        DestroyWindow(m_hwndReflect);
    }

    // clean up all the pointers we're holding around.
    //
    QUICK_RELEASE(m_pClientSite);
    QUICK_RELEASE(m_pControlSite);
    QUICK_RELEASE(m_pInPlaceSite);
    QUICK_RELEASE(m_pInPlaceFrame);
    QUICK_RELEASE(m_pInPlaceUIWindow);
    QUICK_RELEASE(m_pSimpleFrameSite);
    QUICK_RELEASE(m_pOleAdviseHolder);
    QUICK_RELEASE(m_pViewAdviseSink);
    QUICK_RELEASE(m_pDispAmbient);

    QUICK_RELEASE(m_pInPlaceSiteWndless);
}

#ifndef DEBUG
#pragma optimize("t", on)
#endif // DEBUG

//=--------------------------------------------------------------------------=
// COleControl::InternalQueryInterface
//=--------------------------------------------------------------------------=
// derived-controls should delegate back to this when they decide to support
// additional interfaces
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//    - NOTE: this function is speed critical!!!!
//
HRESULT COleControl::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    switch (riid.Data1) 
	{
        // private interface for prop page support
        QI_INHERITS(this, IOleControl);
        QI_INHERITS(this, IPointerInactive);
        QI_INHERITS(this, IQuickActivate);
        QI_INHERITS(this, IOleObject);
        QI_INHERITS((IPersistStorage *)this, IPersist);
        QI_INHERITS(this, IPersistStreamInit);
        QI_INHERITS(this, IOleInPlaceObject);
        QI_INHERITS(this, IOleInPlaceObjectWindowless);
        QI_INHERITS((IOleInPlaceActiveObject *)this, IOleWindow);
        QI_INHERITS(this, IOleInPlaceActiveObject);
        QI_INHERITS(this, IViewObject);
        QI_INHERITS(this, IViewObject2);
        QI_INHERITS(this, IViewObjectEx);
        QI_INHERITS(this, ISpecifyPropertyPages);
        QI_INHERITS(this, IPersistStorage);
        QI_INHERITS(this, IPersistPropertyBag);
        QI_INHERITS(this, IProvideClassInfo);
		QI_INHERITS(this, IControlPrv);

        default:
            goto NoInterface;
    }

    // we like the interface, so addref and return
    //
    ((IUnknown *)(*ppvObjOut))->AddRef();
    return S_OK;

  NoInterface:
    // delegate to super-class for automation interfaces, etc ...
    //
    return CAutomationObjectWEvents::InternalQueryInterface(riid, ppvObjOut);
}

#ifndef DEBUG
#pragma optimize("s", on)
#endif // DEBUG

//=--------------------------------------------------------------------------=
// COleControl::BeforeDestroyObject   [overridden]
//=--------------------------------------------------------------------------=
// if we're in the process of shutting down and destroying ourselves, then we
// need to trash our window here so we can avoid pure virtual calls from 
// within colecontol's destructor
//
// Notes:
//
void COleControl::BeforeDestroyObject
(
    void
)
{
    if (m_hwnd) {
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }
}

//=--------------------------------------------------------------------------=
// COleControl::GetPages    [ISpecifyPropertyPages]
//=--------------------------------------------------------------------------=
// returns a counted array with the guids for our property pages.
//
// parameters:
//    CAUUID *    - [out] where to put the counted array.
//
// Output:
//    HRESULT
//
// NOtes:
//
STDMETHODIMP COleControl::GetPages
(
    CAUUID *pPages
)
{
    const GUID **pElems;
    void *pv;
    WORD  x;

    // if there are no property pages, this is actually pretty easy.
    //
    if (!CPROPPAGESOFCONTROL(m_ObjectType)) {
        pPages->cElems = 0;
        pPages->pElems = NULL;
        return S_OK;
    }

    // fill out the Counted array, using IMalloc'd memory.
    //
    pPages->cElems = CPROPPAGESOFCONTROL(m_ObjectType);
    pv = CoTaskMemAlloc(sizeof(GUID) * (pPages->cElems));
    RETURN_ON_NULLALLOC(pv);
    pPages->pElems = (GUID *)pv;

    // loop through our array of pages and get 'em.
    //
    pElems = PPROPPAGESOFCONTROL(m_ObjectType);
    for (x = 0; x < pPages->cElems; x++)
        pPages->pElems[x] = *(pElems[x]);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CreateInPlaceWindow
//=--------------------------------------------------------------------------=
// creates the window with which we will be working.
// yay.
//
// Parameters:
//    int            - [in] left
//    int            - [in] top
//    BOOL           - [in] can we skip redrawing?
//
// Output:
//    HWND
//
// Notes:
//    - DANGER! DANGER!  this function is protected so that anybody can call it
//      from their control.  however, people should be extremely careful of when
//      and why they do this.  preferably, this function would only need to be
//      called by an end-control writer in design mode to take care of some
//      hosting/painting issues.  otherwise, the framework should be left to
//      call it when it wants.
//
HWND COleControl::CreateInPlaceWindow
(
    int  x,
    int  y,
    BOOL fNoRedraw
)
{
    BOOL    fVisible;
    DWORD   dwWindowStyle, dwExWindowStyle;
    char    szWindowTitle[128];

    // if we've already got a window, do nothing.
    //
    if (m_hwnd)
        return m_hwnd;

    // get the user to register the class if it's not already
    // been done.  we have to critical section this since more than one thread
    // can be trying to create this control
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!CTLWNDCLASSREGISTERED(m_ObjectType)) {
        if (!RegisterClassData()) {
            LEAVECRITICALSECTION1(&g_CriticalSection);
            return NULL;
        } else 
            CTLWNDCLASSREGISTERED(m_ObjectType) = TRUE;
    }
    LEAVECRITICALSECTION1(&g_CriticalSection);

    // let the user set up things like the window title, the
    // style, and anything else they feel interested in fiddling
    // with.
    //
    dwWindowStyle = dwExWindowStyle = 0;
    szWindowTitle[0] = '\0';
    if (!BeforeCreateWindow(&dwWindowStyle, &dwExWindowStyle, szWindowTitle))
        return NULL;

    dwWindowStyle |= (WS_CHILD | WS_CLIPSIBLINGS);

    // create window visible if parent hidden (common case)
    // otherwise, create hidden, then shown.  this is a little subtle, but
    // it makes sense eventually.
    //
    if (!m_hwndParent)
        m_hwndParent = GetParkingWindow();

    fVisible = IsWindowVisible(m_hwndParent);

    // This one kinda sucks -- if a control is subclassed, and we're in
    // a host that doesn't support Message Reflecting, we have to create
    // the user window in another window which will do all the reflecting.
    // VERY blech. [don't however, bother in design mode]
    //
    if (SUBCLASSWNDPROCOFCONTROL(m_ObjectType) && (m_hwndParent != GetParkingWindow())) {
        // determine if the host supports message reflecting.
        //
        if (!m_fCheckedReflecting) {
            VARIANT_BOOL f;
            if (!GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, VT_BOOL, &f) || !f)
                m_fHostReflects = FALSE;
            m_fCheckedReflecting = TRUE;
        }

        // if the host doesn't support reflecting, then we have to create
        // an extra window around the control window, and then parent it
        // off that.
        //
        if (!m_fHostReflects) {
            ASSERT(m_hwndReflect == NULL, "Where'd this come from?");
            m_hwndReflect = CreateReflectWindow(!fVisible, m_hwndParent, x, y, &m_Size);
            if (!m_hwndReflect)
                return NULL;
            SetWindowLong(m_hwndReflect, GWL_USERDATA, (long)this);
            dwWindowStyle |= WS_VISIBLE;
        }
    } else {
        if (!fVisible)
            dwWindowStyle |= WS_VISIBLE;
    }

    // we have to mutex the entire create window process since we need to use
    // the s_pLastControlCreated to pass in the object pointer.  nothing too
    // serious
    //
    ENTERCRITICALSECTION2(&g_CriticalSection);
    s_pLastControlCreated = this;
    m_fCreatingWindow = TRUE;

    // finally, go create the window, parenting it as appropriate.
    //
    m_hwnd = CreateWindowEx(dwExWindowStyle,
                            WNDCLASSNAMEOFCONTROL(m_ObjectType),
                            szWindowTitle,
                            dwWindowStyle,
                            (m_hwndReflect) ? 0 : x,
                            (m_hwndReflect) ? 0 : y,
                            m_Size.cx, m_Size.cy,
                            (m_hwndReflect) ? m_hwndReflect : m_hwndParent,
                            NULL, g_hInstance, NULL);

    // clean up some variables, and leave the critical section
    //
    m_fCreatingWindow = FALSE;
    s_pLastControlCreated = NULL;
    LEAVECRITICALSECTION2(&g_CriticalSection);

    if (m_hwnd) {
        // let the derived-control do something if they so desire
        //
        if (!AfterCreateWindow()) {
            DestroyWindow(m_hwnd);
            return NULL;
        }

        // if we didn't create the window visible, show it now.
        //
        if (fVisible)
            SetWindowPos(m_hwnd, NULL, 0, 0, 0, 0,
                         SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW | ((fNoRedraw) ? SWP_NOREDRAW : 0));
    }

    return m_hwnd;
}

//=--------------------------------------------------------------------------=
// COleControl::SetInPlaceParent    [helper]
//=--------------------------------------------------------------------------=
// sets up the parent window for our control.
//
// Parameters:
//    HWND            - [in] new parent window
//
// Notes:
//
void COleControl::SetInPlaceParent
(
    HWND hwndParent
)
{
#ifdef DEBUG
    HWND hwndOld;
    DWORD dw;
#endif

    ASSERT(!m_pInPlaceSiteWndless, "This routine should only get called for windowed OLE controls");

    if (m_hwndParent == hwndParent)
        return;

    m_hwndParent = hwndParent;
    if (m_hwnd)
    {

#ifdef DEBUG
        hwndOld = 
#endif
            SetParent(GetOuterWindow(), hwndParent);


    #ifdef DEBUG

        if (hwndOld == NULL)
        {
            dw = GetLastError();            
            ASSERT(dw == 0, "SetParent failed");
        }

    #endif

    }
}

//=--------------------------------------------------------------------------=
// COleControl::ControlWindowProc
//=--------------------------------------------------------------------------=
// default window proc for an OLE Control.   controls will have their own
// window proc called from this one, after some processing is done.
//
// Parameters:
//    - see win32sdk docs.
//
// Notes:
//
LRESULT CALLBACK COleControl::ControlWindowProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    COleControl *pCtl = ControlFromHwnd(hwnd);
    HRESULT hr;
    LRESULT lResult = 0;
    DWORD   dwCookie;
    BYTE    fSimpleFrame = FALSE;

    // if the value isn't a positive value, then it's in some special
    // state [creation or destruction]  this is safe because under win32,
    // the upper 2GB of an address space aren't available.
    //
    if ((LONG)pCtl == 0) {
        pCtl = s_pLastControlCreated;
        SetWindowLong(hwnd, GWL_USERDATA, (LONG)pCtl);
        pCtl->m_hwnd = hwnd;
    } else if ((ULONG)pCtl == 0xffffffff) {
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    // this is unfortunate.  if the control gets destroyed while processing a
    // message [ie, 'End' in an event, etc ....], we need to be able to
    // contine through to the end of this routine, past the post-processing.
    // to do this, we need to force a ref count on the control to keep it
    // around.  blech
    //
    pCtl->ExternalAddRef();

    // message preprocessing
    //
    if (pCtl->m_pSimpleFrameSite) {
        hr = pCtl->m_pSimpleFrameSite->PreMessageFilter(hwnd, msg, wParam, lParam, &lResult, &dwCookie);
        if (hr == S_FALSE) goto Done;
    }

    // for certain messages, do not call the user window proc. instead,
    // we have something else we'd like to do.
    //
    switch (msg) {
      case WM_PAINT:
        {
        // call the user's OnDraw routine.
        //
        PAINTSTRUCT ps;
        RECT        rc;
        HDC         hdc;

        // if we're given an HDC, then use it
        //
        if (!wParam)
        {
            hdc = BeginPaint(hwnd, &ps);
        }
        else
            hdc = (HDC)wParam;

        GetClientRect(hwnd, &rc);
        pCtl->OnDraw(DVASPECT_CONTENT, hdc, (RECTL *)&rc, NULL, NULL, TRUE);

        if (!wParam)
        {
            EndPaint(hwnd, &ps);
        }
        }
        break;

      case WM_DESTROY:        
        pCtl->BeforeDestroyWindow();        		

        // fall through so that controls will send this to the parent window class.

      default:
        // call the derived-control's window proc
        //
        lResult = pCtl->WindowProc(msg, wParam, lParam);

        break;

    }

    // message postprocessing
    //
    switch (msg) {

      case WM_NCDESTROY:
        
        // after this point, the window doesn't exist any more
        //
        SetWindowLong(hwnd, GWL_USERDATA, 0xffffffff);

        // We've been destroyed so reset our parent to NULL, so that it gets regenerated when we're recreated
        //
        pCtl->m_hwndParent = NULL;		
        pCtl->m_hwnd = NULL;
        break;

      case WM_SETFOCUS:
      case WM_KILLFOCUS:
        // give the control site focus notification
        //
        if (pCtl->m_fInPlaceActive && pCtl->m_pControlSite)
            pCtl->m_pControlSite->OnFocus(msg == WM_SETFOCUS);
        break;

      case WM_SIZE:
        // a change in size is a change in view
        //
        if (!pCtl->m_fCreatingWindow)
            pCtl->ViewChanged();
        break;
    }

    // lastly, simple frame postmessage processing
    //
    if (pCtl->m_pSimpleFrameSite)
        pCtl->m_pSimpleFrameSite->PostMessageFilter(hwnd, msg, wParam, lParam, &lResult, dwCookie);

  Done:
    pCtl->ExternalRelease();
    return lResult;
}

//=--------------------------------------------------------------------------=
// COleControl::SetFocus
//=--------------------------------------------------------------------------=
// we have to override this routine to get UI Activation correct.
//
// Parameters:
//    BOOL              - [in] true means take, false release
//
// Output:
//    BOOL
//
// Notes:
//    - CONSIDER: this is pretty messy, and it's still not entirely clear
//      what the ole control/focus story is.
//
BOOL COleControl::SetFocus
(
    BOOL fGrab
)
{
    HRESULT hr;
    HWND    hwnd;

    // first thing to do is check out UI Activation state, and then set
    // focus [either with windows api, or via the host for windowless
    // controls]
    //
    if (m_pInPlaceSiteWndless) {
        if (!m_fUIActive && fGrab)
            if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE))) return FALSE;

        hr = m_pInPlaceSiteWndless->SetFocus(fGrab);
        return (hr == S_OK) ? TRUE : FALSE;
    } else {

        // we've got a window.
        //
        if (m_fInPlaceActive) {
            hwnd = (fGrab) ? m_hwnd : m_hwndParent;
            if (!m_fUIActive && fGrab)
                return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE));
            else
                return (::SetFocus(hwnd) == hwnd);
        } else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// ReflectOcmMessage
//=--------------------------------------------------------------------------=
// Reflects window messages on to the child window.
//
// Parameters and Output:
//    - see win32 sdk docs
//
// Returns: TRUE if an OCM_ message was reflect
//          FALSE if no OCM_ message was reflected
//
// The return value from SendMessage is stored is returned in pLResult
//
// Notes:
//
BOOL COleControl::ReflectOcmMessage
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam,
    LRESULT *pLResult
)
{
    COleControl *pCtl;    

    ASSERT(pLResult, "RESULT pointer is NULL");    
    *pLResult = 0;

    switch(msg)
    {
        case WM_COMMAND:
        case WM_NOTIFY:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
        case WM_DRAWITEM:
        case WM_MEASUREITEM:
        case WM_DELETEITEM:
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_COMPAREITEM:
        case WM_HSCROLL:
        case WM_VSCROLL:
        case WM_PARENTNOTIFY:
            pCtl = (COleControl *)GetWindowLong(hwnd, GWL_USERDATA);
            if (pCtl)            
            {
                *pLResult = SendMessage(pCtl->m_hwnd, OCM__BASE + msg, wParam, lParam);
                return TRUE;
            }
            break;
    }

    return FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::ReflectWindowProc
//=--------------------------------------------------------------------------=
// reflects window messages on to the child window.
//
// Parameters and Output:
//    - see win32 sdk docs
//
// Notes:
//
LRESULT CALLBACK COleControl::ReflectWindowProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LRESULT lResult;
    COleControl *pCtl;
    
    switch (msg) {

        case WM_SETFOCUS:
            pCtl = (COleControl *)GetWindowLong(hwnd, GWL_USERDATA);
            if (pCtl)
	        {
                return pCtl->SetFocus(TRUE);
	        }
            break;

	case WM_SIZE:
		pCtl = (COleControl *)GetWindowLong(hwnd, GWL_USERDATA);
		if (pCtl != NULL)
			::MoveWindow(pCtl->m_hwnd, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
		// continue with default processing
		break;
    }

    // If the message is reflected then return the result of the OCM_ message
    //    
    if (ReflectOcmMessage(hwnd, msg, wParam, lParam, &lResult))
        return lResult;

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//=--------------------------------------------------------------------------=
// COleControl::GetAmbientProperty    [callable]
//=--------------------------------------------------------------------------=
// returns the value of an ambient property
//
// Parameters:
//    DISPID        - [in]  property to get
//    VARTYPE       - [in]  type of desired data
//    void *        - [out] where to put the data
//
// Output:
//    BOOL          - FALSE means didn't work.
//
// Notes:
//
BOOL COleControl::GetAmbientProperty
(
    DISPID  dispid,
    VARTYPE vt,
    void   *pData
)
{
    DISPPARAMS dispparams;
    VARIANT v, v2;
    HRESULT hr;

    v.vt = VT_EMPTY;
    v.lVal = 0;
    v2.vt = VT_EMPTY;
    v2.lVal = 0;

    // get a pointer to the source of ambient properties.
    //
    if (!m_pDispAmbient) {
        if (m_pClientSite)
            m_pClientSite->QueryInterface(IID_IDispatch, (void **)&m_pDispAmbient);

        if (!m_pDispAmbient)
            return FALSE;
    }

    // now go and get the property into a variant.
    //
    memset(&dispparams, 0, sizeof(DISPPARAMS));
    hr = m_pDispAmbient->Invoke(dispid, IID_NULL, 0, DISPATCH_PROPERTYGET, &dispparams,
                                &v, NULL, NULL);
    if (FAILED(hr)) return FALSE;

    // we've got the variant, so now go an coerce it to the type that the user
    // wants.  if the types are the same, then this will copy the stuff to
    // do appropriate ref counting ...
    //
    hr = VariantChangeType(&v2, &v, 0, vt);
    if (FAILED(hr)) {
        VariantClear(&v);
        return FALSE;
    }

    // copy the data to where the user wants it
    //
    CopyMemory(pData, &(v2.lVal), g_rgcbDataTypeSize[vt]);
    VariantClear(&v);
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::GetAmbientFont    [callable]
//=--------------------------------------------------------------------------=
// gets the current font for the user.
//
// Parameters:
//    IFont **         - [out] where to put the font.
//
// Output:
//    BOOL             - FALSE means couldn't get it.
//
// Notes:
//
BOOL COleControl::GetAmbientFont
(
    IFont **ppFont
)
{
    IDispatch *pFontDisp;

    // we don't have to do much here except get the ambient property and QI
    // it for the user.
    //
    *ppFont = NULL;
    if (!GetAmbientProperty(DISPID_AMBIENT_FONT, VT_DISPATCH, &pFontDisp))
        return FALSE;

    pFontDisp->QueryInterface(IID_IFont, (void **)ppFont);
    pFontDisp->Release();
    return (*ppFont) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::DesignMode
//=--------------------------------------------------------------------------=
// returns TRUE if we're in Design mode.
//
// Output:
//    BOOL            - true is design mode, false is run mode
//
// Notes:
//
BOOL COleControl::DesignMode
(
    void
)
{
    VARIANT_BOOL f;

    // if we don't already know our run mode, go and get it.  we'll assume
    // it's true unless told otherwise
    //
    if (!m_fModeFlagValid) {
        f = TRUE;
        if (!GetAmbientProperty(DISPID_AMBIENT_USERMODE, VT_BOOL, &f))
            return FALSE;
        m_fModeFlagValid = TRUE;
        m_fRunMode = f;
    }

    return !m_fRunMode;
}

//=--------------------------------------------------------------------------=
// COleControl::AfterCreateWindow    [overridable]
//=--------------------------------------------------------------------------=
// something the user can pay attention to
//
// Output:
//    BOOL             - false means fatal error, can't continue
// Notes:
//
BOOL COleControl::AfterCreateWindow
(
    void
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::BeforeCreateWindow    [overridable]
//=--------------------------------------------------------------------------=
// called just before we create a window.  the user should register their
// window class here, and set up any other things, such as the title of
// the window, and/or sytle bits, etc ...
//
// Parameters:
//    DWORD *            - [out] dwWindowFlags
//    DWORD *            - [out] dwExWindowFlags
//    LPSTR              - [out] name of window to create
//
// Output:
//    BOOL               - false means fatal error, can't continue
//
// Notes:
//
BOOL COleControl::BeforeCreateWindow
(
    DWORD *pdwWindowStyle,
    DWORD *pdwExWindowStyle,
    LPSTR  pszWindowTitle
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::InvalidateControl    [callable]
//=--------------------------------------------------------------------------=
void COleControl::InvalidateControl
(
    LPCRECT lpRect
)
{
    if (m_fInPlaceActive)
        OcxInvalidateRect(lpRect, TRUE);
    else
        ViewChanged();

    // CONSIDER: one might want to call pOleAdviseHolder->OnDataChanged() here
    // if there was support for IDataObject
}

//=--------------------------------------------------------------------------=
// COleControl::SetControlSize    [callable]
//=--------------------------------------------------------------------------=
// sets the control size. they'll give us the size in pixels.  we've got to
// convert them back to HIMETRIC before passing them on!
//
// Parameters:
//    SIZEL *        - [in] new size
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::SetControlSize
(
    SIZEL *pSize
)
{
    HRESULT hr;
    SIZEL slHiMetric;

    PixelToHiMetric(pSize, &slHiMetric);
    hr = SetExtent(DVASPECT_CONTENT, &slHiMetric);
    return (FAILED(hr)) ? FALSE : TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::RecreateControlWindow    [callable]
//=--------------------------------------------------------------------------=
// called by a [subclassed, typically] control to recreate it's control
// window.
//
// Parameters:
//    none
//
// Output:
//    HRESULT
//
// Notes:
//    - NOTE: USE ME EXTREMELY SPARINGLY! THIS IS AN EXTREMELY EXPENSIVE
//      OPERATION!
//
HRESULT COleControl::RecreateControlWindow
(
    void
)
{
    HRESULT hr;
    HWND    hwndPrev;
    BYTE    fUIActive = m_fUIActive;

    // we need to correctly preserve the control's position within the
    // z-order here.
    //
    if (m_hwnd)
        hwndPrev = ::GetWindow(m_hwnd, GW_HWNDPREV);

    // if we're in place active, then we have to deactivate, and reactivate
    // ourselves with the new window ...
    //
    if (m_fInPlaceActive) {

        hr = InPlaceDeactivate();
        RETURN_ON_FAILURE(hr);
        hr = InPlaceActivate((fUIActive) ? OLEIVERB_UIACTIVATE : OLEIVERB_INPLACEACTIVATE);
        RETURN_ON_FAILURE(hr);

    } else if (m_hwnd) {
        DestroyWindow(m_hwnd);
        if (m_hwndReflect) {
            DestroyWindow(m_hwndReflect);
            m_hwndReflect = NULL;
        }

        CreateInPlaceWindow(0, 0, FALSE);
    }

    // restore z-order position
    //
    if (m_hwnd)
        SetWindowPos(m_hwnd, hwndPrev, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

    return m_hwnd ? S_OK : E_FAIL;
}

// from Globals.C. don't need to mutex it here since we only read it.
//
extern HINSTANCE g_hInstResources;

//=--------------------------------------------------------------------------=
// COleControl::GetResourceHandle    [callable]
//=--------------------------------------------------------------------------=
// gets the HINSTANCE of the DLL where the control should get resources
// from.  implemented in such a way to support satellite DLLs.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE COleControl::GetResourceHandle
(
    void
)
{
    if (!g_fSatelliteLocalization)
        return g_hInstance;

    // if we've already got it, then there's not all that much to do.
    // don't need to crit sect this one right here since even if they do fall
    // into the ::GetResourceHandle call, it'll properly deal with things.
    //
    if (g_hInstResources)
        return g_hInstResources;

    // we'll get the ambient localeid from the host, and pass that on to the
    // automation object.
    //
    // crit sect this for apartment threading support.
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!g_fHaveLocale)
        // if we can't get the ambient locale id, then we'll just continue
        // with the globally set up value.
        //
        if (!GetAmbientProperty(DISPID_AMBIENT_LOCALEID, VT_I4, &g_lcidLocale))
            goto Done;

    g_fHaveLocale = TRUE;

  Done:
    LEAVECRITICALSECTION1(&g_CriticalSection);
    return ::GetResourceHandle();
}

//=--------------------------------------------------------------------------=
// COleControl::GetControl    [IControlPrv]
//=--------------------------------------------------------------------------=
// Returns a pointer to the COleControl class
//
HRESULT COleControl::GetControl(COleControl **ppOleControl)
{
	CHECK_POINTER(ppOleControl);
	*ppOleControl = this;
	(*ppOleControl)->AddRef();
	return S_OK;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\ctlocx96.cpp ===
//=--------------------------------------------------------------------------=
// CtlOcx96.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the OCX 96 interfaces that don't quite fit in to the
// categories covered by embedding, persistence, and ctlmisc.cpp
//
//
#include "pch.h"

#include "CtrlObj.H"

SZTHISFILE

//=--------------------------------------------------------------------------=
// COleControl::GetActivationPolicy    [IPointerInactive]
//=--------------------------------------------------------------------------=
// returns the present activation policy for this object.  for non-subclassed
// windows controls, this means we can put off in-place activation for quite
// a while.
//
// Parameters:
//    DWORD *        - [out] activation policy
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetActivationPolicy
(
    DWORD *pdwPolicy
)
{
    CHECK_POINTER(pdwPolicy);

    // just get the policy in the global structure describing this control.
    //
    *pdwPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnInactiveMouseMove    [IPointerInactive]
//=--------------------------------------------------------------------------=
// indicates to an inactive oobject that the mouse pointer has moved over the
// object.
//
// Parameters:
//    LPCRECT            - [in]
//    long               - [in]
//    long               - [in]
//    DWORD              - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::OnInactiveMouseMove
(
    LPCRECT pRectBounds,
    long    x,
    long    y,
    DWORD   dwMouseMsg
)
{
    // OVERRIDE: end control writers should just override this if they want
    // to have a control that is never in-place active.
    //
    return S_OK;
}
    
//=--------------------------------------------------------------------------=
// COleControl::OnInactiveSetCursor    [IPointerInactive]
//=--------------------------------------------------------------------------=
// called by the container for the inactive object under the mouse pointer on
// recept of a WM_SETCURSOR message.
//
// Parameters:
//    LPCRECT            - [in]
//    long               - [in]
//    long               - [in]
//    DWORD              - [in]
//    BOOL               - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::OnInactiveSetCursor
(
    LPCRECT pRectBounds,
    long    x,
    long    y,
    DWORD   dwMouseMsg,
    BOOL    fSetAlways
)
{
    // OVERRIDE:  just get the user to override this if they want to never
    // be activated
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QuickActivate    [IQuickActivate]
//=--------------------------------------------------------------------------=
// allows the container to activate the control.
//
// Parameters:
//    QACONTAINER *        - [in]  info about the container
//    QACONTROL *          - [out] info about the control
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QuickActivate
(
    QACONTAINER *pContainer,
    QACONTROL *pControl
)
{
    HRESULT hr;

    // we need these guys.
    //
    if (!pContainer) return E_UNEXPECTED;
    if (!pControl) return E_UNEXPECTED;

    // start grabbing things from the QACONTAINER structure and apply them
    // as relevant
    //
    // We do the size comparison against the original (VC 4.2) 
    // size of the structures in OCIDL.H.  These _OLD structure definitions
    // are cached away by us in ctrlobj.h.  If we were to compile against
    // arbitrary VC header files containing new, larger structures then 
    // we'd begin to inadvertently fail.  We'd be comparing the original 
    // structure size passed in by a container against an inflated (sizeof) size.
    //
    if (pContainer->cbSize < sizeof(QACONTAINER_OLD)) return E_UNEXPECTED;
    if (pControl->cbSize < sizeof(QACONTROL_OLD)) return E_UNEXPECTED;

    // save out the client site, of course.
    //
    if (pContainer->pClientSite) {
        hr = SetClientSite(pContainer->pClientSite);
        RETURN_ON_FAILURE(hr);
    }

    // if the lcid is not LANG_NEUTRAL, score!
    //
    if (pContainer->lcid) {
        ENTERCRITICALSECTION1(&g_CriticalSection);  // Should have crit sect
        g_lcidLocale = pContainer->lcid;
        g_fHaveLocale = TRUE;
        LEAVECRITICALSECTION1(&g_CriticalSection);
    }

    // pay attention to some ambients
    //
    if (pContainer->dwAmbientFlags & QACONTAINER_MESSAGEREFLECT) {
        m_fHostReflects = TRUE;
        m_fCheckedReflecting = TRUE;
    }

    // hook up some notifications.  first property notifications.
    //
    if (pContainer->pPropertyNotifySink) {
        pContainer->pPropertyNotifySink->AddRef();
        hr = m_cpPropNotify.AddSink((void *)pContainer->pPropertyNotifySink, &pControl->dwPropNotifyCookie);
        if (FAILED(hr)) {
            pContainer->pPropertyNotifySink->Release();
            return hr;
        }
    }

    // then the event sink.
    //
    if (pContainer->pUnkEventSink) {
        hr = m_cpEvents.Advise(pContainer->pUnkEventSink, &pControl->dwEventCookie);
        if (FAILED(hr)) {
            pContainer->pUnkEventSink->Release();
            return hr;
        }
    }

    // finally, the advise sink.
    //
    if (pContainer->pAdviseSink) {
        // don't need to pass the cookie back since there can only be one
        // person advising at a time.
        //
        hr = SetAdvise(DVASPECT_CONTENT, 0, pContainer->pAdviseSink);
        RETURN_ON_FAILURE(hr);
    }

    // set up a few things in the QACONTROL structure.  we're opaque by default
    //
    pControl->dwMiscStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType);
    pControl->dwViewStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0;
    pControl->dwPointerActivationPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType);

    // that's pretty much all we're interested in.  we will, however, pass on the
    // rest of the things to the end control writer and see if they want to do
    // anything with them. they shouldn't touch any of the above except for the
    // ambients.
    //
    return OnQuickActivate(pContainer, &(pControl->dwViewStatus));
}

//=--------------------------------------------------------------------------=
// COleControl::SetContentExtent    [IQuickActivate]
//=--------------------------------------------------------------------------=
// the container calls this to set the content extent of the control.
//
// Parameters:
//    LPSIZEL            - [in] the size of the content extent
//
// Output:
//    HRESULT            - S_OK, or E_FAIL for fixed size control
//
// Notes:
//
STDMETHODIMP COleControl::SetContentExtent
(
    LPSIZEL pSize
)
{
    return SetExtent(DVASPECT_CONTENT, pSize);
}

//=--------------------------------------------------------------------------=
// COleControl::GetContentExtent    [IQuickActivate]
//=--------------------------------------------------------------------------=
// the container calls this to get the content extent of the control
//
// Parameters:
//    LPSIZEL        - [out] returns current size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetContentExtent
(
    LPSIZEL pSize
)
{
    return GetExtent(DVASPECT_CONTENT, pSize);
}

//=--------------------------------------------------------------------------=
// COleControl::OnQuickActivate    [overridable]
//=--------------------------------------------------------------------------=
// not all the of the members of the QACONTAINER need to be consumed by the
// framework, but are, at least, extremely interesting.  thus, we will pass
// on the struture to the end control writer, and let them consume these.
//
// Parameters:
//    QACONTAINER *            - [in]  contains additional information
//    DWORD *                  - [out] put ViewStatus flags here.
//
// Output:
//    HRESULT
//
// Notes:
//    - control writers should only look at/consume:
//        a. dwAmbientFlags
//        b. colorFore/colorBack
//        c. pFont
//        d. pUndoMgr
//        e. dwAppearance
//        f. hpal
//
//    - all the others are set up the for the user by the framework.
//    - control writers should set up the pdwViewStatus with flags as per
//      IViewObjectEx::GetViewStatus.  if you don't know what this is or don't
//      care, then don't touch.
//
HRESULT COleControl::OnQuickActivate
(
    QACONTAINER *pContainer,
    DWORD       *pdwViewStatus
)
{
    // by default, nuthin much to do!
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\ctlpsst.cpp ===
//=--------------------------------------------------------------------------=
// ControlPersistence.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of persistence interfaces for COleControl.
//
#include "pch.h"
#include "CtrlObj.H"

#include "CtlHelp.H"

// for ASSERT and FAIL
//
SZTHISFILE


// this is the name of the stream we'll save our ole controls to.
//
const WCHAR wszCtlSaveStream [] = L"Contents";	


//=--------------------------------------------------------------------------=
// to help with out stream save implementation ...
//
#define STREAMHDR_SIGNATURE 0x12344321  // Signature to identify our format (avoid crashes!)
#define IPROP_END 0xFF                  // Marker at end of property list
#define MAXAUTOBUF 3800                 // Best if < 1 page.

typedef struct tagSTREAMHDR {

    DWORD  dwSignature;     // Signature.
    size_t cbWritten;       // Number of bytes written

} STREAMHDR;

//=--------------------------------------------------------------------------=
// COleControl persistence interfaces
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistPropertyBag]
//=--------------------------------------------------------------------------=
// IPersistPropertyBag.  we've got a property bag, so let's load our properties
// from it.
//
// Parameters:
//    IPropertyBag *      - [in] pbag from which to read props.
//    IErrorLog *         - [in] error log to write to
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load
(
    IPropertyBag *pPropertyBag,
    IErrorLog    *pErrorLog
)
{
    HRESULT hr;

    // load in our standard state first.  nothing serious here ... currently,
    // we've just got two properties, for cx and cy.
    //
    hr = LoadStandardState(pPropertyBag, pErrorLog);
    RETURN_ON_FAILURE(hr);

    // now call the user text load function, and get them to load in whatever
    // they're interested in.
    //
    hr = LoadTextState(pPropertyBag, pErrorLog);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistPropertyBag]
//=--------------------------------------------------------------------------=
// given a property bag, save out all the relevant state information.
//
// Parameters:
//    IPropertyBag *        - [in] property to write to
//    BOOL                  - [in] do we clear the dirty bit?
//    BOOL                  - [in] do we write out default values anyhoo?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IPropertyBag *pPropertyBag,
    BOOL          fClearDirty,
    BOOL          fWriteDefault
)
{
    HRESULT hr;

    // save out standard state information
    //
    hr = SaveStandardState(pPropertyBag);
    RETURN_ON_FAILURE(hr);

    // now call the user function and get them to save out
    // all of their properties.
    //
    hr = SaveTextState(pPropertyBag, fWriteDefault);
    RETURN_ON_FAILURE(hr);

    // now clear the dirty flag and send out notification that we're
    // done.
    //
    if (fClearDirty)
        m_fDirty = FALSE;

    if (m_pOleAdviseHolder)
        m_pOleAdviseHolder->SendOnSave();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClassID    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// returns the classid of this mamma
//
// Parameters:
//    CLSID *         - [out] where to put the clsid
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetClassID
(
    CLSID *pclsid
)
{
    CHECK_POINTER(pclsid);

    // copy the thing over
    //
    *pclsid = CLSIDOFOBJECT(m_ObjectType);
    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::IsDirty    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// asks if we're dirty or not.  duh.
//
// Output:
//    HRESULT        - S_OK: dirty, S_FALSE: not dirty
//
// Notes:
//
STDMETHODIMP COleControl::IsDirty
(
    void
)
{
    return (m_fDirty) ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::InitNew    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// causes the control to intialize itself with a new bunch of state information
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::InitNew
(
    void
)
{
    BOOL f;

    // call the overridable function to do this work
    //
    f = InitializeNewState();

    // make sure we mark ourselves as dirty
    //
    m_fDirty = TRUE;
    return (f) ? S_OK : E_FAIL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetSizeMax    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ULARGE_INTEGER *    - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetSizeMax
(
    ULARGE_INTEGER *pulMaxSize
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// load from an IStream
//
// Parameters:
//    IStream *    - [in] stream from which to load
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load
(
    IStream *pStream
)
{
    HRESULT hr;

    // first thing to do is read in standard properties the user don't
    // persist themselves.
    //
    hr = LoadStandardState(pStream);
    RETURN_ON_FAILURE(hr);

    // load in the user properties.  this method is one they -have- to implement
    // themselves.
    //
    hr = LoadBinaryState(pStream);
    
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// saves out our state using streams
//
// Parameters:
//    IStream *        - [in]
//    BOOL             - [in] clear dirty bit?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IStream *pStream,
    BOOL     fClearDirty
)
{
    HRESULT hr;

    // use our helper routine that we share with the IStorage persistence
    // code.
    //
    hr = m_SaveToStream(pStream);
    RETURN_ON_FAILURE(hr);

    // clear out dirty flag [if appropriate] and notify that we're done
    // with save.
    //
    if (fClearDirty)
        m_fDirty = FALSE;
    if (m_pOleAdviseHolder)
        m_pOleAdviseHolder->SendOnSave();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::InitNew    [IPersistStorage]
//=--------------------------------------------------------------------------=
// ipersiststorage version of this.  fweee
//
// Parameters:
//    IStorage *    - [in] we don't use this
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::InitNew
(
    IStorage *pStorage
)
{
    // we already have an implementation of this [for IPersistStreamInit]
    //
    return InitNew();
}

//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistStorage]
//=--------------------------------------------------------------------------=
// Ipersiststorage version of this
//
// Parameters:
//    IStorage *    - [in] DUH.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load(IStorage *pStorage)
{
    IStream *pStream;
    HRESULT  hr;

    // we're going to use IPersistStream::Load from the CONTENTS stream.
    //
    hr = pStorage->OpenStream(wszCtlSaveStream, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStream);
    RETURN_ON_FAILURE(hr);

    // IPersistStreamInit::Load
    //
    hr = Load(pStream);
    pStream->Release();
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistStorage]
//=--------------------------------------------------------------------------=
// save into the contents stream of the given storage object.
//
// Parameters:
//    IStorage *        - [in] 10 points if you figure it out
//    BOOL              - [in] is the storage the same as the load storage?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IStorage *pStorage,
    BOOL      fSameAsLoad
)
{
    IStream *pStream;
    HRESULT  hr;

    // we're just going to save out to the CONTENTES stream.
    //
    hr = pStorage->CreateStream(wszCtlSaveStream, STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                0, 0, &pStream);
    RETURN_ON_FAILURE(hr);

    // use our helper routine.
    //
    hr = m_SaveToStream(pStream);
    m_fSaveSucceeded = (FAILED(hr)) ? FALSE : TRUE;
    pStream->Release();
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveCompleted    [IPersistStorage]
//=--------------------------------------------------------------------------=
// lets us clear out our flags.
//
// Parameters:
//    IStorage *    - ignored
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::SaveCompleted
(
    IStorage *pStorageNew
)
{
    // if our save succeeded, then we can do our post save work.
    //
    if (m_fSaveSucceeded) {
        m_fDirty = FALSE;
        if (m_pOleAdviseHolder)
            m_pOleAdviseHolder->SendOnSave();
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::HandsOffStorage    [IPersistStorage]
//=--------------------------------------------------------------------------=
// not interesting
//
// Output:
//    S_OK
//
// Notes:
//
STDMETHODIMP COleControl::HandsOffStorage
(
    void
)
{
    // we don't ever hold on to  a storage pointer, so this is remarkably
    // uninteresting to us.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::m_SaveToStream    [helper: IPersistStreamInit/IPersistStorage]
//=--------------------------------------------------------------------------=
// save ourselves to a stream
//
// Parameters:
//    IStream *        - figure it out
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::m_SaveToStream
(
    IStream *pStream
)
{
    HRESULT hr;

    // save out standard state information that the user has no control
    // over
    //
    hr = SaveStandardState(pStream);
    RETURN_ON_FAILURE(hr);

    // save out user-specific satte information.  they MUST implement this
    // function
    //
    hr = SaveBinaryState(pStream);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::LoadStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// reads in standard properties that all controls are going to have, using
// text persistence APIs.  there is another version for streams.
//
// Parameters:
//    IPropertyBag *    - [in]
//    IErrorLog *       - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::LoadStandardState
(
    IPropertyBag *pPropertyBag,
    IErrorLog    *pErrorLog
)
{
    VARIANT v;
    HRESULT hr;
    SIZEL   slHiMetric = { 100, 50 };

    // currently, our only standard properties are related to size.
    // if we can't find them, then we'll just use some defaults.
    //
    v.vt = VT_I4;
    v.lVal = 0;
    hr = pPropertyBag->Read(L"_ExtentX", &v, pErrorLog);
    if (FAILED(hr)) goto DefaultSize;
    
    slHiMetric.cx = v.lVal;

    v.lVal = 0;
    hr = pPropertyBag->Read(L"_ExtentY", &v, pErrorLog);
    if (FAILED(hr)) goto DefaultSize;
    slHiMetric.cy = v.lVal;

    HiMetricToPixel(&slHiMetric, &m_Size);
    return S_OK;

  DefaultSize:
    m_Size.cx = 100;
    m_Size.cy = 50;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::LoadStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// reads in standard properties that all controls are going to have, using
// stream persistence APIs.  there is another version for text.
//
// Parameters:
//    IStream *         - [in] 
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::LoadStandardState
(
    IStream *pStream
)
{
    STREAMHDR stmhdr;
    HRESULT hr;
    SIZEL   slHiMetric;

    // look for our header structure, so we can verify stream validity.
    //
    hr = pStream->Read(&stmhdr, sizeof(STREAMHDR), NULL);
    RETURN_ON_FAILURE(hr);

    if (stmhdr.dwSignature != STREAMHDR_SIGNATURE)
        return E_UNEXPECTED;

    // currently, the only standard state we're writing out is
    // a SIZEL structure describing the control's size.
    //
    if (stmhdr.cbWritten != sizeof(m_Size))
        return E_UNEXPECTED;

    // we like the stream.  let's go load in our two properties.
    //
    hr = pStream->Read(&slHiMetric, sizeof(slHiMetric), NULL);
    RETURN_ON_FAILURE(hr);

    HiMetricToPixel(&slHiMetric, &m_Size);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// saves out standard properties that we're managing for a control using text
// persistence APIs.  there is another version for stream persistence.
//
// Parameters:
//    IPropertyBag *        - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::SaveStandardState
(
    IPropertyBag *pPropertyBag
)
{
    HRESULT hr;
    VARIANT v;
    SIZEL   slHiMetric;

    // currently, the only standard proprerties we persist are Size related
    //
    PixelToHiMetric(&m_Size, &slHiMetric);

    v.vt = VT_I4;
    v.lVal = slHiMetric.cx;

    hr = pPropertyBag->Write(L"_ExtentX", &v);
    RETURN_ON_FAILURE(hr);

    v.lVal = slHiMetric.cy;

    hr = pPropertyBag->Write(L"_ExtentY", &v);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// saves out standard properties that we're managing for a control using stream
// persistence APIs.  there is another version for text persistence.
//
// Parameters:
//    IStream *            - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::SaveStandardState
(
    IStream *pStream
)
{
    STREAMHDR streamhdr = { STREAMHDR_SIGNATURE, sizeof(SIZEL) };
    HRESULT hr;
    SIZEL   slHiMetric;


    // first thing to do is write out our stream hdr structure.
    //
    hr = pStream->Write(&streamhdr, sizeof(STREAMHDR), NULL);
    RETURN_ON_FAILURE(hr);

    // the only properties we're currently persisting here are the size
    // properties for this control.  make sure we do that in HiMetric
    //
    PixelToHiMetric(&m_Size, &slHiMetric);

    hr = pStream->Write(&slHiMetric, sizeof(slHiMetric), NULL);
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::InitializeNewState    [overridable]
//=--------------------------------------------------------------------------=
// the user can override this to initialize variables
//
// Output:
//    BOOL        - FALSE means couldn't do it.
//
// Notes:
//
BOOL COleControl::InitializeNewState
(
    void
)
{
    // we find this largely uninteresting
    //
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\ctlview.cpp ===
//=--------------------------------------------------------------------------=
// CtlView.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the IViewObjectEx interface, which is a moderately
// non-trivial bunch of code.
//
#include "pch.h"

#include "CtrlObj.H"

// for ASSERT and FAIL
//
SZTHISFILE



// local functions we're going to find useful
//
HDC _CreateOleDC(DVTARGETDEVICE *ptd);

//=--------------------------------------------------------------------------=
// COleControl::Draw    [IViewObject2]
//=--------------------------------------------------------------------------=
// Draws a representation of an object onto the specified device context. 
//
// Parameters:
//    DWORD                - [in] draw aspect
//    LONG                 - [in] part of object to draw [not relevant]
//    void *               - NULL
//    DVTARGETDEVICE *     - [in] specifies the target device
//    HDC                  - [in] information context for target device
//    HDC                  - [in] target device context
//    LPCRECTL             - [in] rectangle in which the object is drawn
//    LPCRECTL             - [in] window extent and origin for metafiles
//    BOOL (*)(DWORD)      - [in] callback for continuing or cancelling drawing
//    DWORD                - [in] parameter to pass to callback.
//
// Output:
//    HRESULT
//
// Notes:
//    - we support the following OCX 96 extensions
//        a. flicker free drawing [multi-pass drawing]
//        b. pvAspect != NULL for optimized DC handling
//        c. prcBounds == NULL for windowless inplace active objects
//
STDMETHODIMP COleControl::Draw
(
    DWORD            dwDrawAspect,
    LONG             lIndex,
    void            *pvAspect,
    DVTARGETDEVICE  *ptd,
    HDC              hicTargetDevice,
    HDC              hdcDraw,
    LPCRECTL         prcBounds,
    LPCRECTL         prcWBounds,
    BOOL (__stdcall *pfnContinue)(DWORD dwContinue),
    DWORD            dwContinue
)
{
    HRESULT hr;
    RECTL rc;
    POINT pVp, pW;
    BOOL  fOptimize = FALSE;
    int iMode;
    BYTE fMetafile = FALSE;
    BYTE fDeleteDC = FALSE;
    SIZE sWindowExt, sViewportExt;

    // support the aspects required for multi-pass drawing
    //
    switch (dwDrawAspect) {
        case DVASPECT_CONTENT:
        case DVASPECT_OPAQUE:
        case DVASPECT_TRANSPARENT:
            break;
        default:
            return DV_E_DVASPECT;
    }

    // first, have to do a little bit to support printing.
    //
    if (GetDeviceCaps(hdcDraw, TECHNOLOGY) == DT_METAFILE) {

        // We are dealing with a metafile.
        //
        fMetafile = TRUE;

        // If attributes DC is NULL, create one, based on ptd.
        //
        if (!hicTargetDevice) {

            // Does _CreateOleDC have to return an hDC
            // or can it be flagged to return an hIC 
            // for this particular case?
            //
            hicTargetDevice = _CreateOleDC(ptd);
            fDeleteDC = TRUE;
        }
    }

    // check to see if we have any flags passed in the pvAspect parameter.
    //
    if (pvAspect && ((DVASPECTINFO *)pvAspect)->cb == sizeof(DVASPECTINFO))
        fOptimize = (((DVASPECTINFO *)pvAspect)->dwFlags & DVASPECTINFOFLAG_CANOPTIMIZE) ? TRUE : FALSE;

    // if they didn't give us a rectangle, just copy over ours
    //
    if (!prcBounds) {

        memcpy(&rc, &m_rcLocation, sizeof(rc));

    } else {

        // first -- convert the DC back to MM_TEXT mapping mode so that the
        // window proc and OnDraw can share the same painting code.  save
        // some information on it, so we can restore it later [without using
        // a SaveDC/RestoreDC]
        //
        rc = *prcBounds;

        // Don't do anything to hdcDraw if it's a metafile.
        // The control's Draw method must make the appropriate
        // accomodations for drawing to a metafile
        //
        if (!fMetafile) {
            LPtoDP(hdcDraw, (POINT *)&rc, 2);
            SetViewportOrgEx(hdcDraw, 0, 0, &pVp);
            SetWindowOrgEx(hdcDraw, 0, 0, &pW);
            GetWindowExtEx(hdcDraw, &sWindowExt);
            GetViewportExtEx(hdcDraw, &sViewportExt);
            iMode = SetMapMode(hdcDraw, MM_TEXT);
        }
    }

    // prcWBounds is NULL and not used if we are not dealing with a metafile.
    // For metafiles, we pass on rc as *prcBounds, we should also include
    // prcWBounds
    //
    hr = OnDraw(dwDrawAspect, hdcDraw, &rc, prcWBounds, hicTargetDevice, fOptimize);

    // clean up the DC when we're done with it, if appropriate.
    //
    if (prcBounds && !fMetafile) {
        SetWindowOrgEx(hdcDraw, pW.x, pW.y, NULL);
        SetViewportOrgEx(hdcDraw, pVp.x, pVp.y, NULL);
        SetWindowExtEx(hdcDraw, sWindowExt.cx, sWindowExt.cy, NULL);
        SetViewportExtEx(hdcDraw, sViewportExt.cx, sViewportExt.cy, NULL);
        SetMapMode(hdcDraw, iMode);
    }

    // if we created a dc, blow it away now
    //
    if (fDeleteDC) DeleteDC(hicTargetDevice);
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::DoSuperClassPaint
//=--------------------------------------------------------------------------=
// design time painting of a subclassed control.
//
// Parameters:
//    HDC                - [in]  dc to work with
//    LPCRECTL           - [in]  rectangle to paint to.  should be in pixels
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::DoSuperClassPaint
(
    HDC      hdc,
    LPCRECTL prcBounds
)
{
    HWND hwnd;
    RECT rcClient;
    int  iMapMode;
    POINT ptWOrg, ptVOrg;
    SIZE  sWOrg, sVOrg;

    // make sure we have a window.
    //
    hwnd = CreateInPlaceWindow(0,0, FALSE);
    if (!hwnd)
        return E_FAIL;

    GetClientRect(hwnd, &rcClient);

    // set up the DC for painting.  this code largely taken from the MFC CDK
    // DoSuperClassPaint() fn.  doesn't always get things like command
    // buttons quite right ...
    //
    // NOTE: there is a windows 95 problem in which the font instance manager
    // will leak a bunch of bytes in the global GDI pool whenever you 
    // change your extents and have an active font.  this code gets around
    // this for on-screen cases, but not for printing [which shouldn't be
    // too serious, because you're not often changing your control size and
    // printing rapidly in succession]
    //
    if ((rcClient.right - rcClient.left != prcBounds->right - prcBounds->left)
        && (rcClient.bottom - rcClient.top != prcBounds->bottom - prcBounds->top)) {

        iMapMode = SetMapMode(hdc, MM_ANISOTROPIC);
        SetWindowExtEx(hdc, rcClient.right, rcClient.bottom, &sWOrg);
        SetViewportExtEx(hdc, prcBounds->right - prcBounds->left, prcBounds->bottom - prcBounds->top, &sVOrg);
    }

    SetWindowOrgEx(hdc, 0, 0, &ptWOrg);
    SetViewportOrgEx(hdc, prcBounds->left, prcBounds->top, &ptVOrg);

#if STRICT
    CallWindowProc((WNDPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0));
#else
    CallWindowProc((FARPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0));
#endif // STRICT

    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::GetColorSet    [IViewObject2]
//=--------------------------------------------------------------------------=
// Returns the logical palette that the control will use for drawing in its
// IViewObject::Draw method with the corresponding parameters.
//
// Parameters:
//    DWORD                - [in]  how the object is to be represented
//    LONG                 - [in]  part of the object to draw [not relevant]
//    void *               - NULL
//    DVTARGETDEVICE *     - [in]  specifies the target device
//    HDC                  - [in]  information context for the target device
//    LOGPALETTE **        - [out] where to put palette
//
// Output:
//    S_OK                 - Control has a palette, and returned it through the out param.
//    S_FALSE              - Control does not currently have a palette.
//    E_NOTIMPL            - Control will never have a palette so optimize handling of this control.
//
// Notes:
//
STDMETHODIMP COleControl::GetColorSet
(
    DWORD            dwDrawAspect,
    LONG             lindex,
    void            *IgnoreMe,
    DVTARGETDEVICE  *ptd,
    HDC              hicTargetDevice,
    LOGPALETTE     **ppColorSet
)
{
    if (dwDrawAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *ppColorSet = NULL;
    return (OnGetPalette(hicTargetDevice, ppColorSet)) ? ((*ppColorSet) ? S_OK : S_FALSE) : E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Freeze    [IViewObject2]
//=--------------------------------------------------------------------------=
// Freezes a certain aspect of the object's presentation so that it does not
// change until the IViewObject::Unfreeze method is called.
//
// Parameters:
//    DWORD            - [in] aspect
//    LONG             - [in] part of object to draw
//    void *           - NULL
//    DWORD *          - [out] for Unfreeze
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Freeze
(
    DWORD   dwDrawAspect,
    LONG    lIndex,
    void   *IgnoreMe,
    DWORD  *pdwFreeze
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Unfreeze    [IVewObject2]
//=--------------------------------------------------------------------------=
// Releases a previously frozen drawing. The most common use of this method
// is for banded printing.
//
// Parameters:
//    DWORD        - [in] cookie from freeze
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Unfreeze
(
    DWORD dwFreeze
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::SetAdvise    [IViewObject2]
//=--------------------------------------------------------------------------=
// Sets up a connection between the control and an advise sink so that the
// advise sink can be notified about changes in the control's view.
//
// Parameters:
//    DWORD            - [in] aspect
//    DWORD            - [in] info about the sink
//    IAdviseSink *    - [in] the sink
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::SetAdvise
(
    DWORD        dwAspects,
    DWORD        dwAdviseFlags,
    IAdviseSink *pAdviseSink
)
{
    // if it's not a content aspect, we don't support it.
    //
    if (!(dwAspects & DVASPECT_CONTENT)) {
        return DV_E_DVASPECT;
    }

    // set up some flags  [we gotta stash for GetAdvise ...]
    //
    m_fViewAdvisePrimeFirst = (dwAdviseFlags & ADVF_PRIMEFIRST) ? TRUE : FALSE;
    m_fViewAdviseOnlyOnce = (dwAdviseFlags & ADVF_ONLYONCE) ? TRUE : FALSE;

    RELEASE_OBJECT(m_pViewAdviseSink);
    m_pViewAdviseSink = pAdviseSink;
    ADDREF_OBJECT(m_pViewAdviseSink);

    // prime them if they want it [we need to store this so they can get flags later]
    //
    if (m_fViewAdvisePrimeFirst)
        ViewChanged();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetAdvise    [IViewObject2]
//=--------------------------------------------------------------------------=
// Retrieves the existing advisory connection on the control if there is one.
// This method simply returns the parameters used in the most recent call to
// the IViewObject::SetAdvise method.
//
// Parameters:
//    DWORD *            - [out]  aspects
//    DWORD *            - [out]  advise flags
//    IAdviseSink **     - [out]  the sink
//
// Output:
//    HRESULT
//
// Notes;
//
STDMETHODIMP COleControl::GetAdvise
(
    DWORD        *pdwAspects,
    DWORD        *pdwAdviseFlags,
    IAdviseSink **ppAdviseSink
)
{
    // if they want it, give it to them
    //
    if (pdwAspects)
        *pdwAspects = DVASPECT_CONTENT;

    if (pdwAdviseFlags) {
        *pdwAdviseFlags = 0;
        if (m_fViewAdviseOnlyOnce) *pdwAdviseFlags |= ADVF_ONLYONCE;
        if (m_fViewAdvisePrimeFirst) *pdwAdviseFlags |= ADVF_PRIMEFIRST;
    }

    if (ppAdviseSink) {
        *ppAdviseSink = m_pViewAdviseSink;
        ADDREF_OBJECT(*ppAdviseSink);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetExtent    [IViewObject2]
//=--------------------------------------------------------------------------=
// Returns the size that the control will be drawn on the
// specified target device.
//
// Parameters:
//    DWORD            - [in] draw aspect
//    LONG             - [in] part of object to draw
//    DVTARGETDEVICE * - [in] information about target device
//    LPSIZEL          - [out] where to put the size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetExtent
(
    DWORD           dwDrawAspect,
    LONG            lindex,
    DVTARGETDEVICE *ptd,
    LPSIZEL         psizel
)
{
    // we already have an implementation of this [from IOleObject]
    //
    return GetExtent(dwDrawAspect, psizel);
}


//=--------------------------------------------------------------------------=
// COleControl::OnGetPalette    [overridable]
//=--------------------------------------------------------------------------=
// called when the host wants palette information.  ideally, people should use
// this sparingly and carefully.
//
// Parameters:
//    HDC            - [in]  HIC for the target device
//    LOGPALETTE **  - [out] where to put the palette
//
// Output:
//    BOOL           - TRUE means we processed it, false means nope.
//
// Notes:
//
BOOL COleControl::OnGetPalette
(
    HDC          hicTargetDevice,
    LOGPALETTE **ppColorSet
)
{
    return FALSE;
}


//=--------------------------------------------------------------------------=
// COleControl::GetRect    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// returns a rectnagle describing a given drawing aspect
//
// Parameters:
//    DWORD             - [in]  aspect
//    LPRECTL           - [out] region rectangle
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetRect
(
    DWORD    dvAspect,
    LPRECTL  prcRect
)
{
    RECTL rc;
    BOOL  f;

    // call the user routine and let them return the size
    //
    f = OnGetRect(dvAspect, &rc);
    if (!f) return DV_E_DVASPECT;

    // transform these dudes.
    //
    PixelToHiMetric((LPSIZEL)&rc, (LPSIZEL)prcRect);
    PixelToHiMetric((LPSIZEL)((LPBYTE)&rc + sizeof(SIZEL)), (LPSIZEL)((LPBYTE)prcRect + sizeof(SIZEL)));
    
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetViewStatus    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// returns information about the opactiy of the object and what drawing
// aspects are supported
//
// Parameters:
//    DWORD *            - [out] the status
//
/// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetViewStatus
(
    DWORD *pdwStatus
)
{
    // depending on the flag in the CONTROLOBJECTINFO structure, indicate our
    // transparency vs opacity.
    // OVERRIDE:  controls that wish to support multi-pass drawing should
    // override this routine and return, in addition to the flags indication
    // opacity, flags indicating what sort of drawing aspects they support.
    //
    *pdwStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QueryHitPoint    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// indicates whether a point is within a given aspect of an object.
//
// Parameters:
//    DWORD                - [in]  aspect
//    LPCRECT              - [in]  Bounds rectangle
//    POINT                - [in]  hit location client coordinates
//    LONG                 - [in]  what the container considers close
//    DWORD *              - [out] info about the hit
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QueryHitPoint
(
    DWORD    dvAspect,
    LPCRECT  prcBounds,
    POINT    ptLocation,
    LONG     lCloseHint,
    DWORD   *pdwHitResult
)
{
    // OVERRIDE: override me if you want to provide additional [non-opaque]
    // functionality
    //
    if (dvAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *pdwHitResult = PtInRect(prcBounds, ptLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QueryHitRect    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// indicates wheter any point in a rectangle is within a given drawing aspect
// of an object.
//
// Parameters:
//    DWORD            - [in]  aspect
//    LPCRECT          - [in]  bounds
//    LPCRECT          - [in]  location
//    LONG             - [in]  what host considers close
//    DWORD *          - [out] hit result
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QueryHitRect
(
    DWORD     dvAspect,
    LPCRECT   prcBounds,
    LPCRECT   prcLocation,
    LONG      lCloseHint,
    DWORD    *pdwHitResult
)
{
    RECT rc;

    // OVERRIDE: override this for additional behaviour
    //
    if (dvAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *pdwHitResult = IntersectRect(&rc, prcBounds, prcLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetNaturalExtent    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// supports two types of control sizing, content and integral.
//
// Parameters:
//    DWORD            - [in]  aspect
//    LONG             - [in]  index
//    DVTARGETDEVICE * - [in]  target device information
//    HDC              - [in]  HIC
//    DVEXTENTINFO *   - [in]  sizing data
//    LPSIZEL          - [out] sizing data retunred by control
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetNaturalExtent
(
    DWORD           dvAspect,
    LONG            lIndex,
    DVTARGETDEVICE *ptd,
    HDC             hicTargetDevice,
    DVEXTENTINFO   *pExtentInfo,
    LPSIZEL         pSizel
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::OnGetRect    [overridable
//=--------------------------------------------------------------------------=
// returns our rectangle
//
// Parameters:
//    DWORD              - [in]  aspect they want the rect for
//    RECTL *            - [out] the rectangle that matches this aspect
//
// Output:
//    BOOL               - false means we don't like the aspect
//
// Notes:
//
BOOL COleControl::OnGetRect
(
    DWORD   dvAspect,
    RECTL  *pRect
)
{
    // by default, we only support content drawing.
    //
    if (dvAspect != DVASPECT_CONTENT)
        return FALSE;

    // just give them our bounding rectangle
    //
    *((LPRECT)pRect) = m_rcLocation;
    return TRUE;
}

//=--------------------------------------------------------------------------=
// _CreateOleDC
//=--------------------------------------------------------------------------=
// creates an HDC given a DVTARGETDEVICE structure.
//
// Parameters:
//    DVTARGETDEVICE *              - [in] duh.
//
// Output:
//    HDC
//
// Notes:
//
HDC _CreateOleDC
(
    DVTARGETDEVICE *ptd
)
{
    LPDEVMODEW   pDevModeW;
    DEVMODEA     DevModeA, *pDevModeA;
    LPOLESTR     lpwszDriverName;
    LPOLESTR     lpwszDeviceName;
    LPOLESTR     lpwszPortName;
    HDC          hdc;

    // return screen DC for NULL target device
    //
    if (!ptd)
        return CreateDC("DISPLAY", NULL, NULL, NULL);

    if (ptd->tdExtDevmodeOffset == 0)
        pDevModeW = NULL;
    else
        pDevModeW = (LPDEVMODEW)((LPSTR)ptd + ptd->tdExtDevmodeOffset);

    lpwszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
    lpwszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
    lpwszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

    MAKE_ANSIPTR_FROMWIDE(pszDriverName, lpwszDriverName);
    MAKE_ANSIPTR_FROMWIDE(pszDeviceName, lpwszDeviceName);
    MAKE_ANSIPTR_FROMWIDE(pszPortName,   lpwszPortName);

    // wow, this sucks.
    //
    if (pDevModeW) {
        WideCharToMultiByte(CP_ACP, 0, pDevModeW->dmDeviceName, -1, (LPSTR)DevModeA.dmDeviceName, CCHDEVICENAME, NULL, NULL);
	memcpy(&DevModeA.dmSpecVersion, &pDevModeW->dmSpecVersion,
		offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion));
        WideCharToMultiByte(CP_ACP, 0, pDevModeW->dmFormName, -1, (LPSTR)DevModeA.dmFormName, CCHFORMNAME, NULL, NULL);
	memcpy(&DevModeA.dmLogPixels, &pDevModeW->dmLogPixels, sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels));
        if (pDevModeW->dmDriverExtra) {
            pDevModeA = (DEVMODEA *)CtlHeapAlloc(g_hHeap, 0, sizeof(DEVMODEA) + pDevModeW->dmDriverExtra);
            if (!pDevModeA) return NULL;
            memcpy(pDevModeA, &DevModeA, sizeof(DEVMODEA));
            memcpy(pDevModeA + 1, pDevModeW + 1, pDevModeW->dmDriverExtra);
        } else
            pDevModeA = &DevModeA;

	DevModeA.dmSize = sizeof(DEVMODEA);
    } else
        pDevModeA = NULL;

    hdc = CreateDC(pszDriverName, pszDeviceName, pszPortName, pDevModeA);
    if (pDevModeA != &DevModeA) CtlHeapFree(g_hHeap, 0, pDevModeA);
    return hdc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\fguids.cpp ===
//=--------------------------------------------------------------------------=
// FGuids.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of Visual Studio Html help CLSID/interface guids
//
    #include "pch.h"
    #include <initguid.h>

    DEFINE_GUID(IID_IVsHelpInit,        0x854d7ac3, 0xbc3d, 0x11d0, 0xb4, 0x21, 0x00, 0xa0, 0xc9, 0x0f, 0x9d, 0xc4);        
    DEFINE_GUID(CLSID_VsHelpServices,   0x854d7ac5, 0xbc3d, 0x11d0, 0xb4, 0x21, 0x00, 0xa0, 0xc9, 0x0f, 0x9d, 0xc4);
    DEFINE_GUID(IID_IVsHelpSystem,      0x854d7ac0, 0xbc3d, 0x11d0, 0xb4, 0x21, 0x00, 0xa0, 0xc9, 0x0f, 0x9d, 0xc4);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\ctlwrap.cpp ===
//=--------------------------------------------------------------------------=
// CtlWrap.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// wrappers for various routines that have slightly different implementations
// for windowed and windowless controls.
//
#include "pch.h"

#include "CtrlObj.H"


// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// COleControl::OcxGetFocus    [wrapper]
//=--------------------------------------------------------------------------=
// indicates whether or not we have the focus.
//
// Parameters:
//    none
//
// Output:
//    TRUE if we have focus, else false
//
// Notes:
//
BOOL COleControl::OcxGetFocus
(
    void
)
{
    // if we're windowless, the site provides this functionality
    //
    if (m_pInPlaceSiteWndless) {
        return (m_pInPlaceSiteWndless->GetFocus() == S_OK);
    } else {

        // we've got a window.  just let the APIs do our work
        //
        if (m_fInPlaceActive)
            return (GetFocus() == m_hwnd);
        else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetWindowRect    [wrapper]
//=--------------------------------------------------------------------------=
// returns the current rectangle for this control, and correctly handles
// windowless vs windowed.
//
// Parameters:
//    LPRECT                - [out]  duh.
//
// Output:
//    BOOL                  - false means unexpected.
//
// Notes:
//
BOOL COleControl::OcxGetWindowRect
(
    LPRECT prc
)
{
    // if we're windowless, then we have this information already!
    //
    if (Windowless()) {
        *prc = m_rcLocation;
        return TRUE;
    } else
        return GetWindowRect(m_hwnd, prc);

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxDefWindowProc    [wrapper]
//=--------------------------------------------------------------------------=
// default window processing
//
// Parameters:
//    UINT           - [in] duh.
//    WPARAM         - [in] duh.
//    LPARAM         - [in] DUH.
//
// Output:
//    LRESULT
//
// Notes:
//
LRESULT COleControl::OcxDefWindowProc
(
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    LRESULT l;

    // if we're windowless, this is a site provided pointer
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->OnDefWindowMessage(msg, wParam, lParam, &l);
    else
        // we've got a window -- just pass it along
        //
        l = DefWindowProc(m_hwnd, msg, wParam, lParam);

    return l;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetDC    [wrapper]
//=--------------------------------------------------------------------------=
// wraps the functionality of GetDC, and correctly handles windowless controls
//
// Parameters:
//    none
//
// Output:
//    HDC            - null means we couldn't get one
//
// Notes:
//    - we don't bother with a bunch of the IOleInPlaceSiteWindowless::GetDc
//      parameters, since the windows GetDC doesn't expose these either. users
//      wanting that sort of fine tuned control can call said routine
//      explicitly
//
HDC COleControl::OcxGetDC
(
    void
)
{
    HDC hdc = NULL;

    // if we're windowless, the site provides this functionality.
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->GetDC(NULL, 0, &hdc);
    else
        hdc = GetDC(m_hwnd);

    return hdc;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxReleaseDC    [wrapper]
//=--------------------------------------------------------------------------=
// releases a DC returned by OcxGetDC
//
// Parameters:
//    HDC             - [in] release me
//
// Output:
//    none
//
// Notes:
//
void COleControl::OcxReleaseDC
(
    HDC hdc
)
{
    // if we're windowless, the site does this for us
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->ReleaseDC(hdc);
    else
        ReleaseDC(m_hwnd, hdc);
}

//=--------------------------------------------------------------------------=
// COleControl::OcxSetCapture    [wrapper]
//=--------------------------------------------------------------------------=
// provides a means for the control to get or release capture.
//
// Parameters:
//    BOOL            - [in] true means take, false release
//
// Output:
//    BOOL            - true means it's yours, false nuh-uh
//
// Notes:
//
BOOL COleControl::OcxSetCapture
(
    BOOL fGrab
)
{
    HRESULT hr;

    // the host does this for us if we're windowless [i'm getting really bored
    // of typing that]
    //
    if (m_pInPlaceSiteWndless) {
        hr = m_pInPlaceSiteWndless->SetCapture(fGrab);
        return (hr == S_OK);
    } else {
        // people shouldn't call this when they're not in-place active, but
        // just in case...
        //
        if (m_fInPlaceActive) {
            if (fGrab)
                SetCapture(m_hwnd);
            else
                ReleaseCapture();
            return TRUE;
        } else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetCapture    [wrapper]
//=--------------------------------------------------------------------------=
// tells you whether or not you have the capture.
//
// Parameters:
//    none
//
// Output:
//    BOOL         - true it's yours, false it's not
//
// Notes:
//
BOOL COleControl::OcxGetCapture
(
    void
)
{
    // host does this for windowless dudes
    //
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->GetCapture() == S_OK;
    else {
        // people shouldn't call this when they're not in-place active, but
        // just in case.
        //
        if (m_fInPlaceActive)
            return GetCapture() == m_hwnd;
        else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxInvalidateRect    [wrapper]
//=--------------------------------------------------------------------------=
// invalidates the control's rectangle
//
// Parameters:
//    LPCRECT            - [in] rectangle to invalidate
//    BOOL               - [in] do we erase background first?
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::OcxInvalidateRect
(
    LPCRECT prcInvalidate,
    BOOL    fErase
)
{
    // if we're windowless, then we need to get the site to do all this for
    // us
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->InvalidateRect(prcInvalidate, fErase) == S_OK;
    else {
        // otherwise do something different depending on whether or not we're
        // in place active or not
        //
        if (m_fInPlaceActive && m_hwnd)
            return InvalidateRect(m_hwnd, prcInvalidate, fErase);
        else
            ViewChanged();
    }

    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxScrollRect    [wrapper]
//=--------------------------------------------------------------------------=
// does some window scrolling for the control
//
// Parameters:
//    LPCRECT             - [in] region to scroll
//    LPCRECT             - [in] region to clip
//    int                 - [in] dx to scroll
//    int                 - [in] dy to scroll
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::OcxScrollRect
(
    LPCRECT  prcBounds,
    LPCRECT  prcClip,
    int      dx,
    int      dy
)
{
    // if we're windowless, the site provides this functionality, otherwise
    // APIs do the job
    //
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->ScrollRect(dx, dy, prcBounds, prcClip) == S_OK;
    else {
        if (m_fInPlaceActive) 
            ScrollWindowEx(m_hwnd, dx, dy, prcBounds, prcClip, NULL, NULL, SW_INVALIDATE);
        else
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\dbgcrit.cpp ===
////
// DbgCrit.cpp
// ~~~~~~~~~~~
//
// This file holds the critical section class for tracking down whether the
// critical section has correctly left within the routine.

#include "pch.h"

#if DEBUG

SZTHISFILE

//////
//  CCritSec::CCritSec
//
//  The constructor calls EnterCriticalSection and sets up the variables
//
CCritSec::CCritSec
(
  CRITICAL_SECTION *CritSec
)
{
  EnterCriticalSection(CritSec);

  m_fLeft     = FALSE;
  m_pCriticalSection = CritSec;
} //CCritSec


//////
//  CCritSec::~CCritSec
//
//  The destructor checks the flag that tells us whether or not the
//  critical section was left properly or not.
//
CCritSec::~CCritSec
(
)
{
  if(m_fLeft == FALSE)
    FAIL("CriticalSection was not left properly.");
} //~CCritSec


//////
//  CCritSec::Left
//
//  A method that sets the flag to TRUE and also calls LeaveCriticalSection
//
void CCritSec::Left
(
  void
)
{
  LeaveCriticalSection(m_pCriticalSection);
  m_fLeft = TRUE;
} //Left

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\macros.cpp ===
//=--------------------------------------------------------------------------=
// Macros.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
// Handy macros like the ones we use in the VB code base.
//=--------------------------------------------------------------------------=
#include "pch.h"

#ifdef DEBUG
#include <winuser.h>

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
//  Debug control switches
//=--------------------------------------------------------------------------=
DEFINE_SWITCH(fTraceCtlAllocs);	//  Trace all Heap allocations and frees
				//  fOutputFile should also be on with this switch
DEFINE_SWITCH(fOutputFile);	//  Logs all debug info in file: 
				//    %CurrentDir%\ctldebug.log
DEFINE_SWITCH(fNoLeakAsserts);	//  No Heap memory leak asserts are displayed 
				//    when turned on.



//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//                            !DEBUGGING HEAP MEMORY LEAKS!
// To debug a leak you need to figure out where and when the allocation was made.
// The top of the assert dialog will give you the OCX/DLL causing the leak.
// Goto Project/Build...Settings.
// On the Debug tab, select "additional DLLs"
// Locate and select the OCX/DLL causing the leak.
// Put a breakpoint on the noted line below. 
// Goto Edit...Breakpoints.
// Select the new breakpoint.
// Press 'Condition'
// In the 'Enter number of times to skip before breaking' put the value of nAlloc-1.
// (if the leak was nAlloc=267 then you want to skip the breapoint 266 times, enter 266)
//
// WARNING: Each control (OCX/DLL) will have its own instance of the framewrk, and thus
//	    its own instance of the memory leak implementaion.  Adding a breakpoint 
//	    anywhere in the framewrk will actually add multiple breakpoints - one for 
//	    each control.
//          Go back to Edit...Breakpoints.
//	    Deselect or remove the breakpoints for the OCX's/DLL's not causing leaks
//
// Run your scenario.
// When you hit this breakpoint verify that pvAddress and nByteCount are correct and then
// look down the callstack to see where the allocation was made.
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
void PutBreakPointHere(void * pvAddress, ULONG nByteCount, ULONG  nAlloc, char * szFile, ULONG uLine)
{
  pvAddress=pvAddress;  nAlloc=nAlloc;  nByteCount=nByteCount;
  szFile=szFile;
  uLine=uLine;
  HINSTANCE hInstance = g_hInstance;  //  hInstance of the OCX/DLL calling this breakpoint
  int PutBreakPointOnThisLine = 1;                              // <--- breakpoint here.
} //  PutBreakPointHere



//=--------------------------------------------------------------------------=
//
//  Debug Heap Memory Leak implementations
//

class CAddressNode
{
public:
  void * m_pv;		    //	Address of memory block allocated
  ULONG  m_cb;		    //	Size of allocation in BYTES
  ULONG  m_cAlloc;	    //	Allocation pass count.  
  LPSZ   m_szFile;	    //	Source file where the allocation was made
  ULONG  m_uLine;	    //	Source line number where the allocation was made
  CAddressNode * m_pnNext;  //	Nodes are stored in a linked list

  void * operator new(size_t cb);
  void operator delete(void * pv);

  //  We maintain a freelist to speed up allocation of AddressNodes.
  static CAddressNode * m_pnFreeList;
};


CAddressNode *	m_rInstTable[NUM_INST_TABLE_ENTRIES];  // Hashing table of all instances of 
						       // mem alloc

CAddressNode *	m_pnEnumNode;	      //  Next node for enumerator to return
UINT		m_uEnumIndex;	      //  Current index into m_rInstTable for enumerator
static ULONG	m_cGlobalPassCount;   //  Pass count of allocation.  Common to all heaps    

ULONG m_cCurNumAllocs;		  // Current number of allocations
ULONG m_cNumAllocs;		  // Total number of allocations ever done.
ULONG m_cCurNumBytesAllocated;	  // Current number of bytes allocated.
ULONG m_cNumBytesAllocated;	  // Total bytes allocated.
ULONG m_HWAllocs;		  // High water allocations.
ULONG m_HWBytes;		  // High water bytes.
static ULONG m_OverallCurAlloc;   // These are overall statistics to since we
static ULONG m_OverallCurBytes;   // wouldn't mind the overall high water.
static ULONG m_OverallHWAlloc;
static ULONG m_OverallHWBytes;


//  Forward declarations
VOID AddInst(VOID * pv, DWORD dwBytes, LPSZ szFile, UINT uLine);
VOID DebugInst(ULONG cb);
VOID AnalyzeInst(LPVOID pv);
VOID DumpInst(CAddressNode * pn, LPTSTR lpTypeofAlloc);
LPSTR DumpInstTable(LPSTR lpLeak);
VOID DeleteInst(LPVOID pv);
VOID VerifyHeaderTrailer(CAddressNode * pn);
VOID CheckForLeaks(VOID);
VOID HeapCheck(VOID);
VOID OutputToFile(LPSTR szOutput);
CAddressNode * FindInst(LPVOID pv);
CAddressNode * EnumReset();
CAddressNode * EnumNext();


//  Initialize a header and trailer for all memory to be allocated.
//  Use 8 bytes so it is also compatible with RISC machines.
char * g_szHeader  = "HEADHEAD";
char * g_szTrailer = "END!END!";

#define HEADERSIZE 8	    // # of bytes of block header
			    // 0 ==> no block header signature
#define TRAILERSIZE 8	    // # of bytes of block trailer
			    // 0 ==> no block trailer signature



//=--------------------------------------------------------------------------=
//  CtlHeapAllocImpl:
//	Debug wrapper for HeapAlloc to track memory leaks:
//=--------------------------------------------------------------------------=
LPVOID CtlHeapAllocImpl(
			HANDLE g_hHeap, 
			DWORD dwFlags, 
			DWORD dwBytesRequested, 
			LPSTR lpszFile, 
			UINT line
		       )
{
  LPVOID lpvRet;
  DWORD dwBytes;
  LPTSTR lpTypeofAlloc = "HeapAlloc   ";
  

  //  If someone tries to allocate memory before PROCCESS_ATTATCH (such as in a 
  //  global constructor), do not track it because neither our heap nor our 
  //  hInstance have been initialized yet.
  //
  if (!g_fInitCrit)
    {
    g_flagConstructorAlloc = TRUE;
    return HeapAlloc(g_hHeap, dwFlags, dwBytesRequested);
    }


  //  Increase size to make space for header and trailer signatures
  dwBytes = dwBytesRequested + HEADERSIZE + TRAILERSIZE;

  //  Allocate memory
  lpvRet = HeapAlloc(g_hHeap, dwFlags, dwBytes);
  if (lpvRet)
    {
    //	Initialize memory (non-zero)
    if (!(dwFlags & HEAP_ZERO_MEMORY))
      memset(lpvRet, 0xAF, dwBytes);

    //	Add instance to hash table
    AddInst(lpvRet, dwBytesRequested, lpszFile, line);

    //	Trace allocations if switch is on
    if (FSWITCH(fTraceCtlAllocs))
      {
      CAddressNode *pn = FindInst(lpvRet);
      DumpInst(pn, lpTypeofAlloc);
      }

    //	Advance pointer past header signature.
    lpvRet = (LPVOID) ((char *)lpvRet + HEADERSIZE);
    }
  return lpvRet;
} //  CtlHeapAllocImpl



//=--------------------------------------------------------------------------=
// CtlHeapReAllocImpl:
//   
//=--------------------------------------------------------------------------=
LPVOID CtlHeapReAllocImpl(
			  HANDLE g_hHeap, 
			  DWORD dwFlags, 
			  LPVOID lpvMem, 
			  DWORD dwBytesRequested, 
			  LPSTR lpszFile, 
			  UINT line
			 )
{
  LPVOID lpvRet;
  CAddressNode * pn;
  int byte;
  DWORD cbOffset, dwBytes;
  LPTSTR lpTypeofAlloc = "HeapReAlloc ";

  //  Move pointer to beginning of header
  lpvMem = (LPVOID)((char *)lpvMem - HEADERSIZE);

  //  Find instance in hash table
  pn = FindInst(lpvMem);
  if (!pn)
    {
    FAIL("CtlHeapReAllocImpl - could not find lpvMem in the instance table.  See debug \
          output for more info.");
    AnalyzeInst(lpvMem);
    return 0;
    }

  //  Increase size to make space for header and trailer signatures
  dwBytes = dwBytesRequested + HEADERSIZE + TRAILERSIZE;
  lpvRet = HeapReAlloc(g_hHeap, dwFlags, lpvMem, dwBytes);
  if (lpvRet)
    {
    //	If the reallocation grew, we must intialize new memory
    if (dwBytesRequested > pn->m_cb)
      {
      if (dwFlags & HEAP_ZERO_MEMORY)
        byte = 0x0;
      else
        byte = 0xAF;

      //  Get the byte offset of trailer in the old allocation
      cbOffset = pn->m_cb + HEADERSIZE;
      memset((char *)lpvRet + cbOffset, byte, dwBytes - cbOffset);
      }
    //	Update hash table
    EnterCriticalSection(&g_csHeap);
    DeleteInst(lpvMem);
    AddInst(lpvRet, dwBytesRequested, lpszFile, line);
    LeaveCriticalSection(&g_csHeap); 

    //	Trace Allocations if switch is on
    if (FSWITCH(fTraceCtlAllocs))
      {
      CAddressNode *pn = FindInst(lpvRet);
      DumpInst(pn, lpTypeofAlloc);
      }

    //	Advance pointer past header signature.
    lpvRet = (LPVOID)((char *)lpvRet + HEADERSIZE);
    }
  return lpvRet;
} //  CtlHeapReAllocImpl

			       

//=--------------------------------------------------------------------------=
//  CtlHeapFreeImpl:
//	Debug wrapper for HeapFree
//=--------------------------------------------------------------------------=
BOOL CtlHeapFreeImpl(
		     HANDLE g_hHeap, 
		     DWORD dwFlags,
		     LPVOID lpvMem
		    )
{
  BOOL fRet = FALSE;
  CAddressNode * pn;
  LPTSTR lpTypeofAlloc = "HeapFree    ";


  //  If someone tries to de-allocate memory after PROCCESS_DETATCH (such as in a 
  //  global destructor), Re-initialize critical section and free memory.
  //
  if (!g_fInitCrit)
    InitializeCriticalSection(&g_csHeap);
	

  //  Move pointer to beginning of header
  lpvMem = (LPVOID) ((char *)lpvMem - HEADERSIZE);

  //  Find the instance in the hash table
  pn = FindInst(lpvMem);
  if (pn)
    {
    //	Verify the memory has not been overwritten 
    VerifyHeaderTrailer(pn);

    //	Trace allocations if switch is on
    if (FSWITCH(fTraceCtlAllocs))
      {
      CAddressNode *pn = FindInst(lpvMem);
      DumpInst(pn, lpTypeofAlloc);
      }

    //	Free memory  -- NOTE: WinNT will set free memory to 0xEEFEEEFE which is ""
    fRet = HeapFree(g_hHeap, 0, lpvMem);
    if (!fRet)
      FAIL("CtlHeapFreeImpl - lpvMem was found to be allocated in the heap passed in \
	    but HeapFree() failed.  Maybe the pointer was already freed.");
    }

  //  Remove instance from hash table
  if (fRet)
    DeleteInst(lpvMem);  

  //  Make sure this memory wasn't allocated in a global constructor
  else if (!g_flagConstructorAlloc)
    {
    FAIL("CtlHeapFreeImpl - could not find lpvMem in the instance table.  See debug \
          output for more info.");
    AnalyzeInst(lpvMem);
    }
  else
    fRet = TRUE;
  
  //  If called after PROCESS_DETATCH delete critical section and Check for leaks again
  //  NOTE:  Only the LAST Assert will have the exact leak information.  All previous
  //	     Asserts will not take into account a HeapFree which occurs after PROCESS_DETACH.
  //	     This only occurs in controls using global static destructors.
  if (!g_fInitCrit)
    {
    CheckForLeaks();
    DeleteCriticalSection(&g_csHeap);
    }

  return fRet;
} //  CtlHeapFreeImpl



//=--------------------------------------------------------------------------=
//  CheckForLeaks:
//    We are calling PROCESS_DETATCH so check if hash table is empty.  If not
//    dump info on memory that has been leaked.
//=--------------------------------------------------------------------------=
VOID CheckForLeaks(VOID)
{
  CAddressNode * pn = EnumReset();
  BOOL IsEmpty = (pn == NULL);	  //  FALSE if there are leaks

  //  First check for memory trashing of any leaked memory
  HeapCheck();
  
  if (!IsEmpty)
    {

    //	First find out which OCX/DLL is leaking
    TCHAR lpCtlName[128];
    DWORD nSize = 128;
    DWORD fValidPath;
    fValidPath = GetModuleFileName(g_hInstance, (LPTSTR)lpCtlName, nSize);

    LPSTR lpLeaks;
    // Allocate some memory to hold the data but use GlobalAlloc since we
    // don't want to use the vb memory stuff since it will muck things up.
    lpLeaks = (LPSTR)GlobalLock(GlobalAlloc(GMEM_MOVEABLE,128));

    lstrcpy(lpLeaks, lpCtlName);
    lstrcat(lpLeaks, " has leaked memory.\nUse PutBreakPointHere() in macros.cpp to debug.\r\n");

    //  Collect all leak info
    lpLeaks = DumpInstTable(lpLeaks);
    
    //  Dump output to file if "fOutputFile" switch is on
    if (FSWITCH(fOutputFile))
      OutputToFile(lpLeaks);

    //  Dump output to an assert as long as "fNoLeakAsserts" is off
    else if (!FSWITCH(fNoLeakAsserts))
      {
      //  Truncate output so it fits into DisplayAssert (512 Max)
      if (lstrlen(lpLeaks) > 500)
	{
	lstrcpyn(lpLeaks, lpLeaks, 500);
	lstrcat(lpLeaks, "\nMore...");
	}
      DisplayAssert(lpLeaks, "FAIL", NULL, 0);
      }

    //	Release memory used to store leak info
    GlobalUnlock((HGLOBAL)GlobalHandle(lpLeaks)), 
	      (BOOL)GlobalFree((HGLOBAL)GlobalHandle(lpLeaks));

    }
  return;
} //  CheckForLeaks



//=--------------------------------------------------------------------------=
//  AddInst:
//    A heap allocation occured so here we add the allocation information to 
//    the instance table.  To debug memory leaks where you need to use pass 
//    counts, set a passcount breakpoint in this function using the passcount 
//    value given in the debug output.
//=--------------------------------------------------------------------------=
VOID AddInst(
	     VOID * pv, 
	     DWORD dwBytes, 
	     LPSZ szFile, 
	     UINT uLine
	    )
{
  UINT uHash;
  CAddressNode * pn = new CAddressNode();
  ASSERT(pn,"");
  
  EnterCriticalSection(&g_csHeap);

  m_cGlobalPassCount++;

  pn->m_pv = pv;                        //  Memory address of allocation
  pn->m_cb = dwBytes;                   //  Bytes requested to be allocated
  pn->m_cAlloc = m_cGlobalPassCount;    //  This is the pass count value in debug output.
  pn->m_szFile = szFile;                //  Source file the allocation call was made
  pn->m_uLine = uLine;                  //  Line number in source file.

  PutBreakPointHere(pv, dwBytes, m_cGlobalPassCount, szFile, uLine);

  //  Add instance to proper position in table
  uHash = HashInst(pv);
  pn->m_pnNext = m_rInstTable[uHash];
  m_rInstTable[uHash] = pn;

  //  Copy header and trailer signatures.
  memcpy((char *)pv, g_szHeader, HEADERSIZE);
  memcpy((char *)pv + HEADERSIZE + dwBytes, g_szTrailer, TRAILERSIZE);

  LeaveCriticalSection(&g_csHeap);

  //  Track extra memory debug info
  DebugInst( dwBytes );
} //  AddInst



//=--------------------------------------------------------------------------=
//  DebugInst:
//    Updates the memory debug information
//=--------------------------------------------------------------------------=
VOID DebugInst(
	       ULONG cb
	      )
{
  EnterCriticalSection(&g_csHeap);

  ++m_cCurNumAllocs;
  ++m_cNumAllocs;
  ++m_OverallCurAlloc;
  m_cCurNumBytesAllocated+=cb;
  m_cNumBytesAllocated+=cb;
  m_OverallCurBytes+=cb;

  m_HWAllocs = (m_HWAllocs < m_cCurNumAllocs) ? m_cCurNumAllocs : m_HWAllocs;
  m_HWBytes = (m_HWBytes < m_cCurNumBytesAllocated) ? m_cCurNumBytesAllocated : m_HWBytes;
  m_OverallHWAlloc = (m_OverallHWAlloc < m_OverallCurAlloc) 
						    ? m_OverallCurAlloc : m_OverallHWAlloc;
  m_OverallHWBytes = (m_OverallHWBytes < m_OverallCurBytes) 
						    ? m_OverallCurBytes : m_OverallHWBytes;

  LeaveCriticalSection(&g_csHeap);

} //  DebugInst



//=--------------------------------------------------------------------------=
//  FindInst:
//    Give a pointer to an allocation, return a pointer to the debug 
//    allocation information.
//=--------------------------------------------------------------------------=
CAddressNode * FindInst(
			LPVOID pv
		       )
{
  CAddressNode * pn;

  EnterCriticalSection(&g_csHeap);

  pn = m_rInstTable[HashInst(pv)];
  while (pn && pn->m_pv != pv)
    pn = pn->m_pnNext;

  LeaveCriticalSection(&g_csHeap);
  return pn;

} //  FindInst



//=--------------------------------------------------------------------------=
//  AnalyzeInst:
//    Given a pointer try determine if it is a valid Read and Write pointer
//    and if it was allocated.
//=--------------------------------------------------------------------------=
VOID AnalyzeInst(
		 LPVOID pv
		)
{
  LPTSTR lpTypeofAlloc = "Bad lpvMem ";
  CAddressNode * pn = NULL;

  //  Either we have a bad pointer or the pointer does not point to any
  //  known heap allocations.   Here we check if it points to readable or 
  //  writable memory.
  BOOL fBadPointer = (IsBadReadPtr(pv, 4) || IsBadWritePtr(pv, 4));
    
  // Report what we know about the memory address
  if (fBadPointer)
    DebugPrintf("AnalyzeInst found that pointer pv=0x%lX is not writable\n\r" \
		"or readable.  The allocation is either outside the addressable range\n\r" \
		"for this operating system or the allocation was already freed.\n\r",pv);
  else
    DebugPrintf("AnalyzeInst found that pointer pv=0x%lX is readable and writable,\n\r"  \
		"so the allocation was made without being added to instance table\n\r" \
		"(prior to PROCESS_ATTATCH), or the memory was already freed.\n\r",pv);
    
} //  AnanlyzeInst



//=--------------------------------------------------------------------------=
//  DumpInst:
//    Dump instance information out to an assert window.
//=--------------------------------------------------------------------------=
VOID DumpInst(
	      CAddressNode * pn,
	      LPTSTR lpTypeofAlloc
	     )
{  
  char szOutput[255];

  //  Format output
  wsprintf(szOutput, "%s: %s(%u) Address=0x%lx  nAlloc=%ld  Bytes=%ld\r\n", lpTypeofAlloc,
	   pn->m_szFile, pn->m_uLine, (ULONG)pn->m_pv, (ULONG)pn->m_cAlloc, (ULONG)pn->m_cb);
  
  //  Dump output to file if switch is turned on
  if (FSWITCH(fOutputFile))
    OutputToFile(szOutput);
  else if (FSWITCH(fNoLeakAsserts))
    DebugPrintf(szOutput);
      
  //  Else display output in assert
  else
    DisplayAssert(szOutput, "FAIL", _szThisFile, __LINE__);;

} //  DumpInst



//=--------------------------------------------------------------------------=
//  DumpInstTable:
//    Memory leak has been detected so dump the entire instance table.
//=--------------------------------------------------------------------------=
LPSTR DumpInstTable(
		    LPSTR lpLeak
		   )
{
  CAddressNode * pn = EnumReset();
  DWORD sizeoflpLeak;
  LPSTR lpTemp;

  EnterCriticalSection(&g_csHeap);

  DebugPrintf(lpLeak);

  while (pn)
    {
    //	Format the leak info
    char szOut[250] = {NULL};
    wsprintf(szOut, "\t%s(%u) Address=0x%lx  nAlloc=%ld  Bytes=%ld\r\n", pn->m_szFile,
           pn->m_uLine, (ULONG)pn->m_pv, (ULONG)pn->m_cAlloc, (ULONG)pn->m_cb);

    DebugPrintf(szOut);
    
    //  Convert lpLeak to a handle and get its current allocation size
    sizeoflpLeak = GlobalSize(GlobalHandle(lpLeak));

    //	Reallocate memory to make space for more leak info
    lpTemp = (LPSTR) (GlobalUnlock((HGLOBAL)GlobalHandle(lpLeak)), 
	      GlobalLock(GlobalReAlloc((HGLOBAL)GlobalHandle(lpLeak), 
	      sizeoflpLeak + lstrlen(szOut) + 1, GMEM_MOVEABLE)));

    //	Add new leak info to lpLeak
    if(lpTemp)
      {
      lpLeak = lpTemp;
      lstrcat(lpLeak, szOut);
      }

    //	Get the next leak
    pn = EnumNext();
    }
  LeaveCriticalSection(&g_csHeap);
  return lpLeak;

} //  DumpInstTable



//=--------------------------------------------------------------------------=
//  DeleteInst:
//    A heap allocation got free or was reallocated so remove the
//    information from the instance table and check for memory trashing.
//=--------------------------------------------------------------------------=
VOID DeleteInst(
		LPVOID pv
	       )
{
  CAddressNode ** ppn, * pnDead;
  ppn = &m_rInstTable[HashInst(pv)];

  EnterCriticalSection(&g_csHeap);
  
  //  Find allocation instance 
  while (*ppn != NULL)
    {
    if ((*ppn)->m_pv == pv)
      {
      pnDead = *ppn;
      *ppn = (*ppn)->m_pnNext;

      //  Correct memory debug info
      --m_cCurNumAllocs;
      m_cCurNumBytesAllocated -= pnDead->m_cb;
      --m_OverallCurAlloc;
      m_OverallCurBytes -= pnDead->m_cb;

      //  Remove instance
      delete pnDead;
		  LeaveCriticalSection(&g_csHeap);
      return;
      }	//  if

    ppn = &((*ppn)->m_pnNext);
    } //  while

    FAIL("DeleteInst - memory instance not found");
} //  DeleteInst



//=--------------------------------------------------------------------------=
//  VerifyHeaderTrailer:
//    Inspect allocation for header and trailer signature overwrites
//=--------------------------------------------------------------------------=
VOID VerifyHeaderTrailer(
			 CAddressNode * pn
			)
{
  LPTSTR lpTypeofAlloc = "Memory trashed ";

  //Verify the header
  if (memcmp((char *)pn->m_pv, g_szHeader, HEADERSIZE) != 0)
    {
    FAIL("Heap block header has been trashed.");
    DebugPrintf("Heap block header trashed.");
    DebugPrintf("\r\n");
    DumpInst(pn, lpTypeofAlloc);
    }

  //Verify the trailer
  if (memcmp((char *)pn->m_pv + pn->m_cb + HEADERSIZE, g_szTrailer, TRAILERSIZE) != 0)
    {
    FAIL("Heap block trailer has been trashed.");
    DebugPrintf("Heap block trailer trashed.");
    DebugPrintf("\r\n");
    DumpInst(pn, lpTypeofAlloc);
    }
  return;

} //  VerifyHeaderTrailer




//=--------------------------------------------------------------------------=
//  HeapCheck:
//    Inspect all of the allocations for header and trailer signature 
//    overwrites.
//=--------------------------------------------------------------------------=
VOID HeapCheck(VOID)
{
  ASSERT(HeapValidate(g_hHeap, 0, NULL) != 0, "OS Says heap is corrupt");

  CAddressNode * pn = EnumReset();
  while (pn)
    {
    VerifyHeaderTrailer(pn);
    pn = EnumNext();
    }
  return;
} //  HeapCheck



//=-------------------------------------------------------------------------=
//  For use with CAddresssNode
//=-------------------------------------------------------------------------=
#define MEM_cAddressNodes 128		  //  Nodes are block allocated
#define UNUSED(var)	  ((var) = (var)) //  Used to avoid warnings

//  The free list is common
CAddressNode * CAddressNode::m_pnFreeList = NULL;

//=--------------------------------------------------------------------------=
//  CAddressNode::operator new:
//    Returns a pointer to an allocated address node. If there are none on 
//    the free list then we allocate a block of address nodes, chain them 
//    together and add them to the free list.   These nodes are never 
//    actually freed so it is ok to allocate them in blocks.
//=--------------------------------------------------------------------------=
void * CAddressNode::operator new(
				  size_t cb
				 )
{
  CAddressNode * pn;
  UNUSED(cb);

  EnterCriticalSection(&g_csHeap); // needed for static m_pnFreeList

  if (m_pnFreeList == NULL)
    {
    UINT cbSize = sizeof(CAddressNode) * MEM_cAddressNodes;  //allocate a block
    pn = (CAddressNode *) HeapAlloc(g_hHeap, 0, cbSize);
    //chain all except the first node together.  the first node
    //is the one returned
    for (int i = 1; i < MEM_cAddressNodes - 1; ++i)
      pn[i].m_pnNext = &pn[i+1];
    pn[MEM_cAddressNodes - 1].m_pnNext = NULL;
    m_pnFreeList = &pn[1];
    }
  else
    {
    pn = m_pnFreeList;
    m_pnFreeList = pn->m_pnNext;
    }

  LeaveCriticalSection(&g_csHeap);
  return pn;
} //  CAddressNode::operator new



//=--------------------------------------------------------------------------=
//  CAddressNode::operator delete
//    Return the address node to the free list.  We never actually free
//    the node since nodes are allocated in blocks.
//=--------------------------------------------------------------------------=
void CAddressNode::operator delete(
				   void * pv
				  )
{
  EnterCriticalSection(&g_csHeap); // needed for static m_pnFreeList

  CAddressNode * pn = (CAddressNode *) pv;
  pn->m_pnNext = m_pnFreeList;
  m_pnFreeList = pn;

  LeaveCriticalSection(&g_csHeap);
} //  CAddressNode::operator delete



//=--------------------------------------------------------------------------=
//  EnumReset:
//    Reset the enumerator and return the first node.  NULL if empty.
//=--------------------------------------------------------------------------=
CAddressNode * EnumReset()
{
  m_pnEnumNode = NULL;
  for (m_uEnumIndex = 0; m_uEnumIndex < NUM_INST_TABLE_ENTRIES; ++m_uEnumIndex)
    {
    m_pnEnumNode = m_rInstTable[m_uEnumIndex];
    if (m_pnEnumNode != NULL)
      return m_pnEnumNode;
    }
  return NULL;  //Instance table is empty
} //  EnumReset



//=--------------------------------------------------------------------------=
//  EnumNext:
//    Return the next node in the enumeration.  m_pnEnumNode points to the last
//    node returned.  It is NULL if no more left.
//=--------------------------------------------------------------------------=
CAddressNode * EnumNext()
{
  ASSERT(m_uEnumIndex <= NUM_INST_TABLE_ENTRIES, "");

  if (m_pnEnumNode == NULL)
    return NULL;    //end of enumeration

  m_pnEnumNode = m_pnEnumNode->m_pnNext;
  if (m_pnEnumNode == NULL)
    {
    //at end of this linked list so search for next list
    m_uEnumIndex++;
    while (m_uEnumIndex < NUM_INST_TABLE_ENTRIES && m_rInstTable[m_uEnumIndex] == NULL)
      m_uEnumIndex++;
    if (m_uEnumIndex < NUM_INST_TABLE_ENTRIES)
      m_pnEnumNode = m_rInstTable[m_uEnumIndex];
    }
  return m_pnEnumNode;
} //  EnumNext



//=---------------------------------------------------------------------------=
//  OutputToFile:
//    Dumps output to file "ctldebug.log"
//=---------------------------------------------------------------------------=
VOID OutputToFile
(
    LPSTR szOutput
)
{
    DWORD nPathSize;
    DWORD nDirPathSize = 128;
    TCHAR lpFilePath[128];
    LPCTSTR lpFileName = "\\CtlDebug.log";
    HANDLE hFile;
    BOOL fWritten, fClosed = FALSE;
    DWORD nBytesWritten;

    //	Create path to output file
    nPathSize = GetCurrentDirectory(nDirPathSize, (LPTSTR)lpFilePath);
    if (nPathSize == 0)
      FAIL("Unable to get current directory...");
    lstrcat(lpFilePath, lpFileName);

    //	Open and write to file
    hFile = CreateFile((LPCTSTR)lpFilePath, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 
			                                FILE_ATTRIBUTE_NORMAL, NULL);
    DWORD SetPtr = SetFilePointer(hFile, NULL, NULL, FILE_END);
    fWritten = WriteFile(hFile, (LPCVOID)szOutput, (DWORD)strlen(szOutput), 
			                                        &nBytesWritten, NULL); 
    if (!fWritten)
      FAIL("Unable to write output to file...");

    //	Close file handle
    fClosed = CloseHandle(hFile);
    if (!fClosed)
      FAIL("Unable to close output file...");

} //  OutputToFile


//
//  End of Debug Memory Leak implemntation
//
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// This routine outputs through DebugPrintf some information if the 
// given hr fails to succeed.  This is used by RRETURN to output where
// a function that returns a failing error code.
//=--------------------------------------------------------------------------=
HRESULT HrDebugTraceReturn
(
  HRESULT hr,
  char *pszFile,
  int iLine
)
{
  // We only output information if the hr fails.
  if (FAILED(hr))
    {
    char szMessageError[128];
    szMessageError[0] = '\0';
    BOOL fMessage;

#if RBY_MAC
    fMessage = FALSE; // FormatMessage not available on the mac
#else
    // Get the message from the system
    // CONSIDER, t-tshort 10/95: Getting some messages from us instead 
    //                           of the system?
    fMessage = FormatMessage(FORMAT_MESSAGE_MAX_WIDTH_MASK
			      | FORMAT_MESSAGE_FROM_SYSTEM,
			     NULL, hr,
			     MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),
			     szMessageError, sizeof(szMessageError), NULL);
#endif

    // Erps didn't get a message.
    if(!fMessage)
      lstrcpy(szMessageError,"Unknown Hresult");

    // Output the information that we want.
    DebugPrintf("FAILED RETURN: %s(%d) : 0x%08lx, %s\n", 
                pszFile, iLine, hr, szMessageError);
    }

  return hr;
}

//---------------------------------------------------------------------
// The following is a common output formatting buffer shared by several
// of the following debug routines.
//---------------------------------------------------------------------
char s_rgchOutput[2048]; // pretty big...


//=--------------------------------------------------------------------------=
// Emit debugging information
//=--------------------------------------------------------------------------=
void _DebugOutput(char* pszOutput)
{
  OutputDebugString(pszOutput);
}


//=--------------------------------------------------------------------------=
// Emit a formatted debugging string to the location specified in
// the debug options dialog.
//=--------------------------------------------------------------------------=
void _DebugPrintf(char* pszFmt, ...) 
{
  va_list  args;

  va_start(args, pszFmt);
  wvsprintf(s_rgchOutput, pszFmt, args);
  va_end(args);

  // sqwak if we overrun the formatting buffer!
  ASSERT(strlen(s_rgchOutput) < sizeof(s_rgchOutput), "");

  _DebugOutput(s_rgchOutput);
}

//=--------------------------------------------------------------------------=
// Conditional form of DebugPrintf
//=--------------------------------------------------------------------------=
void _DebugPrintIf(BOOL fPrint, char* pszFmt, ...)
{
  va_list  args;

  if (!fPrint)
    return;

  va_start(args, pszFmt);
  wvsprintf(s_rgchOutput, pszFmt, args);
  va_end(args);

  // sqwak if we overrun the formatting buffer!
  ASSERT(strlen(s_rgchOutput) < sizeof(s_rgchOutput), "");

  _DebugOutput(s_rgchOutput);
}


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\debug.cpp ===
//=--------------------------------------------------------------------------=
// Debug.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains various methods that will only really see any use in DEBUG builds
//
#include "pch.h"

#ifdef DEBUG
#include <stdlib.h>

//=--------------------------------------------------------------------------=
// Private Constants
//---------------------------------------------------------------------------=
//
static const char szFormat[]  = "%s\nFile %s, Line %d";
static const char szFormat2[] = "%s\n%s\nFile %s, Line %d";

#define _SERVERNAME_ "ActiveX Framework"
#define CTL_INI_SIZE 14

static const char szTitle[]  = _SERVERNAME_ " Assertion  (Abort = UAE, Retry = INT 3, Ignore = Continue)";


//=--------------------------------------------------------------------------=
// Local functions
//=--------------------------------------------------------------------------=
int NEAR _IdMsgBox(LPSTR pszText, LPCSTR pszTitle, UINT mbFlags);

//=--------------------------------------------------------------------------=
// DisplayAssert
//=--------------------------------------------------------------------------=
// Display an assert message box with the given pszMsg, pszAssert, source
// file name, and line number. The resulting message box has Abort, Retry,
// Ignore buttons with Abort as the default.  Abort does a FatalAppExit;
// Retry does an int 3 then returns; Ignore just returns.
//
VOID DisplayAssert
(
    LPSTR	 pszMsg,
    LPSTR	 pszAssert,
    LPSTR	 pszFile,
    UINT	 line
)
{
    LPTSTR lpszText;
    
    char  szMsg[512];

    lpszText = pszMsg;		// Assume no file & line # info

    // If C file assert, where you've got a file name and a line #
    //
    if (pszFile) {

        // Then format the assert nicely
        //
        wsprintf(szMsg, szFormat, (pszMsg&&*pszMsg) ? pszMsg : pszAssert, pszFile, line);
        lpszText = szMsg;
    }

    // Put up a dialog box
    //
    switch (_IdMsgBox(lpszText, szTitle, MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SYSTEMMODAL)) {
        case IDABORT:
            FatalAppExit(0, lpszText);
            return;

        case IDRETRY:
            // call the win32 api to break us.
            //
            DebugBreak();
            return;
    }

    return;
}


//=---------------------------------------------------------------------------=
// Beefed-up version of WinMessageBox.
//=---------------------------------------------------------------------------=
//
int NEAR _IdMsgBox
(
    LPSTR	pszText,
    LPCSTR	pszTitle,
    UINT	mbFlags
)
{
    HWND hwndActive;
    MSG  msg;
    int  id;

    hwndActive = GetActiveWindow();

    id = MessageBox(hwndActive, pszText, pszTitle, mbFlags);
    if(PeekMessage(&msg, NULL, WM_QUIT, WM_QUIT, PM_REMOVE))
    {
      id = MessageBox(hwndActive, pszText, pszTitle, mbFlags);
      PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam);
    }

    return id;
}


//---------------------------------------------------------------------------
// Implementation for class CtlSwitch
//---------------------------------------------------------------------------

CtlSwitch* CtlSwitch::g_pctlswFirst = NULL;

//=---------------------------------------------------------------------------=
//  CtlSwitch::InitSwitch - Initialize members and add new object to 
//			    linked-list
//=---------------------------------------------------------------------------=
void CtlSwitch::InitSwitch
(
 char * pszName
)
{
  // set fields
  m_pszName = pszName;
  m_fSet = FALSE;

  // link into global list of switches
  this->m_pctlswNext = g_pctlswFirst;
  g_pctlswFirst = this;
  
}


//=---------------------------------------------------------------------------=
//  SetCtlSwitches:
//    Initialize linked-list control switches to those values set in the 
//    corresponding .ini files
//=---------------------------------------------------------------------------=
VOID SetCtlSwitches 
(
    LPSTR    lpCtlPath
)
{    
    TCHAR lpWindowsDir[128];	  //  Path to Windows directory
    UINT uMaxWinPathSize = 128;	  //  Max size for Win path
    UINT uPathSize;		  //  Actual Win path size

    LPCTSTR lpAllSwitch = "allctls";	    //	Name of section which applies to all ctls
    char lpszCtlName[128];		    //	Name of ctl (minus extension) to act as section name in INI	  
    LPCTSTR lpFileName = "\\CtlSwtch.ini";  //	Name of INI file
    char lpStatus[4];			    //	Status of switch (on/off)
    LPCTSTR lpDefaultStatus = "set";	    //	Default status
    LPCTSTR lpTurnOff = "off";
    LPCTSTR lpTurnOn = "on";
    DWORD nSizeStatus = 4;		    //	Size of status switch
    DWORD fSet;				    //	If switch is set in INI

    //  Create path to CtlSwtch.ini in the Windows directory
    uPathSize = GetWindowsDirectory(lpWindowsDir, uMaxWinPathSize) + CTL_INI_SIZE;
    lstrcat(lpWindowsDir, lpFileName);

    //	Create section name for control (control name minus extension)
    lstrcpyn(lpszCtlName, lpCtlPath, strlen(lpCtlPath) - 3);
    int curChar = strlen(lpszCtlName);
    int charCount = 0;
    while (lpszCtlName[curChar] != '\\')
      {
      curChar--;
      charCount++;
      }
    curChar++;
    lstrcpyn(lpszCtlName, &lpCtlPath[curChar], charCount);

    //  Use CTLSWTCH.INI to set switches.  If not defined in INI file, create switch
    for (CtlSwitch* pctlsw = CtlSwitch::g_pctlswFirst; pctlsw; pctlsw = pctlsw->m_pctlswNext)
      {
      //  Specific control switches override the "allctls" switch
      fSet = GetPrivateProfileString(lpszCtlName, (LPCTSTR)pctlsw->m_pszName, lpDefaultStatus, (LPTSTR)lpStatus, nSizeStatus, (LPCTSTR)lpWindowsDir);

      // If switch is not set for control, use "allctls" switch
      if ((fSet == 0) || (strcmp(lpStatus, "set") == 0))
	{
        fSet = GetPrivateProfileString(lpAllSwitch, (LPCTSTR)pctlsw->m_pszName, lpDefaultStatus, (LPTSTR)lpStatus, nSizeStatus, (LPCTSTR)lpWindowsDir);

        // If INI file or switch do not exist, create one...
        if ((fSet == 0) || (strcmp(lpStatus, "set") == 0))
	  {
	  // If switch was initialized TRUE, turn it on
	  if (pctlsw->m_fSet != 0)
	    WritePrivateProfileString(lpszCtlName, (LPCTSTR)pctlsw->m_pszName, (LPTSTR)lpTurnOn, (LPCTSTR)lpWindowsDir); 
	  //  Else turn it off
	  else
	    {
	    WritePrivateProfileString(lpAllSwitch, (LPCTSTR)pctlsw->m_pszName, (LPTSTR)lpTurnOff, (LPCTSTR)lpWindowsDir); 
	    WritePrivateProfileString(lpszCtlName, (LPCTSTR)pctlsw->m_pszName, (LPTSTR)lpTurnOff, (LPCTSTR)lpWindowsDir); 
	    pctlsw->m_fSet = FALSE;
	    }
	  }
	else if ((strcmp(lpStatus, "on") == 0))
	  {
	  WritePrivateProfileString(lpszCtlName, (LPCTSTR)pctlsw->m_pszName, (LPTSTR)lpStatus, (LPCTSTR)lpWindowsDir); 
	  pctlsw->m_fSet = TRUE;
	  }
	else
	  {
	  WritePrivateProfileString(lpszCtlName, (LPCTSTR)pctlsw->m_pszName, (LPTSTR)lpTurnOff, (LPCTSTR)lpWindowsDir); 
	  pctlsw->m_fSet = FALSE;
	  }
	}
      else if ((strcmp(lpStatus, "on") == 0))
	pctlsw->m_fSet = TRUE;
      else 
	pctlsw->m_fSet = FALSE;

      }
      
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\globals.cpp ===
//=--------------------------------------------------------------------------=
// Globals.cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains global variables and strings and the like that just don't fit
// anywhere else.
//
#include "pch.h"

//=--------------------------------------------------------------------------=
// support for licensing
//
BOOL g_fMachineHasLicense;
BOOL g_fCheckedForLicense;

//=--------------------------------------------------------------------------=
// does our server have a type library?
//
BOOL g_fServerHasTypeLibrary = TRUE;

#ifdef MDAC_BUILD

    // Satellite .DLL name includes 2 or 3 letter language abbreviation
    //
    VARIANT_BOOL g_fSatelliteLangExtension =  TRUE;

#endif

//=--------------------------------------------------------------------------=
// our instance handles
//
HINSTANCE    g_hInstance;
HINSTANCE    g_hInstResources;
VARIANT_BOOL g_fHaveLocale;

//=--------------------------------------------------------------------------=
// OleAut Library Handle
//
#ifdef MDAC_BUILD
HINSTANCE g_hOleAutHandle;
#else
HANDLE 	 g_hOleAutHandle;
#endif

//=--------------------------------------------------------------------------=
// our global memory allocator and global memory pool
//
HANDLE   g_hHeap;

//=--------------------------------------------------------------------------=
// apartment threading support.
//
CRITICAL_SECTION    g_CriticalSection;

//=--------------------------------------------------------------------------=
// critical section for our heap memory leak detection.
//
CRITICAL_SECTION    g_csHeap;
BOOL g_fInitCrit = FALSE;
BOOL g_flagConstructorAlloc = FALSE;

//=--------------------------------------------------------------------------=
// global parking window for parenting various things.
//
HWND     g_hwndParking;

//=--------------------------------------------------------------------------=
// system information
//
BOOL    g_fSysWin95;                    // we're under Win95 system, not just NT SUR
BOOL    g_fSysWinNT;                    // we're under some form of Windows NT
BOOL    g_fSysWin95Shell;               // we're under Win95 or Windows NT SUR { > 3/51)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\makefile.inc ===
THUNDER55=..\..\vb98
TOOLS=TOOLS
C32=C32
MAKEVERS=$(THUNDER55)\$(TOOLS)\BIN\makevers /MajorVer 6 /MinorVer 0

JulianDate:
    $(THUNDER55)\$(TOOLS)\BIN\jdate -newline -terse > $(O)\dwinvers.txt

$(O)\dwinvers.h: JulianDate
    $(MAKEVERS) > $(O)\dwinvers.h < $(O)\dwinvers.txt
    $(THUNDER55)\$(TOOLS)\bin\getver $(THUNDER55)\$(C32)\dll\vba6\vba6.dll VBA >> $(O)\dwinvers.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\ipserver.cpp ===
//=--------------------------------------------------------------------------=
// InProcServer.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implements all exported DLL functions for the program, as well as a few
// others that will be used by same
//
#include "pch.h"
#include "LocalSrv.H"

#include "AutoObj.H"
#include "ClassF.H"
#include "CtrlObj.H"
#include "Unknown.H"
#include "ComCat.H"

#ifdef DEBUG 
#include "debug.h"
#include <winbase.h>
#endif // DEBUG

// for ASSERT and FAIL
//
SZTHISFILE

#ifdef VS_HELP
    #include "vshelp.h"
    extern IVsHelpSystem *g_pIVsHelpSystem;
#endif

//=--------------------------------------------------------------------------=
// Private module level data
//

//=--------------------------------------------------------------------------=
// These are used for reflection in OLE Controls.  Not that big of a hit that
// we mind defining them for all servers, including automation or generic
// COM.
//
// Make this a constant.
extern const char g_szReflectClassName [] = "CtlFrameWork_ReflectWindow";
BYTE g_fRegisteredReflect = FALSE;
BOOL g_fDBCSEnabled = FALSE;

extern HINSTANCE g_hInstResources;
extern HINSTANCE g_hinstVersion;

#ifdef MDAC_BUILD
extern HINSTANCE g_hOleAutHandle;
#else
extern HANDLE 	 g_hOleAutHandle;
#endif

extern const int    g_ctCATIDImplemented;
extern const CATID* g_rgCATIDImplemented[];

// ref count for LockServer
//
LONG  g_cLocks;


// private routines for this file.
//
int       IndexOfOleObject(REFCLSID);
HRESULT   RegisterAllObjects(void);
HRESULT   UnregisterAllObjects(void);
void      CleanupGlobalObjects(void);

//=--------------------------------------------------------------------------=
// DllMain
//=--------------------------------------------------------------------------=
// yon standard LibMain.
//
// Parameters and Output:
//    - see SDK Docs on DllMain
//
// Notes:
//
BOOL WINAPI DllMain
(
    HANDLE hInstance,
    DWORD  dwReason,
    void  *pvReserved
)
{
//    int i;

    switch (dwReason) {
      // set up some global variables, and get some OS/Version information
      // set up.
      //
      case DLL_PROCESS_ATTACH:
        {
        DWORD dwVer = GetVersion();
        DWORD dwWinVer;

        //  swap the two lowest bytes of dwVer so that the major and minor version
        //  numbers are in a usable order.
        //  for dwWinVer: high byte = major version, low byte = minor version
        //     OS               Sys_WinVersion  (as of 5/2/95)
        //     =-------------=  =-------------=
        //     Win95            0x035F   (3.95)
        //     WinNT ProgMan    0x0333   (3.51)
        //     WinNT Win95 UI   0x0400   (4.00)
        //
        dwWinVer = (UINT)(((dwVer & 0xFF) << 8) | ((dwVer >> 8) & 0xFF));
        g_fSysWinNT = FALSE;
        g_fSysWin95 = FALSE;
        g_fSysWin95Shell = FALSE;

        if (dwVer < 0x80000000) {
            g_fSysWinNT = TRUE;
            g_fSysWin95Shell = (dwWinVer >= 0x0334);
        } else  {
            g_fSysWin95 = TRUE;
            g_fSysWin95Shell = TRUE;
        }
        
		// initialize a critical seciton for our apartment threading support
        //
        InitializeCriticalSection(&g_CriticalSection);

        // create an initial heap for everybody to use.
        // currently, we're going to let the system make things thread-safe,
        // which will make them a little slower, but hopefully not enough
        // to notice
        //
        if (!g_hHeap)
            g_hHeap = GetProcessHeap();
        if (!g_hHeap) {
            FAIL("Couldn't get Process Heap.  Not good!");
            return FALSE;
        }

        g_hInstance = (HINSTANCE)hInstance;

        // this causes DllMain to NOT get called for DLL_THREAD_ATTACH and DETACH.
        // if you are interested in these notifications, please remove this line.
        //
        DisableThreadLibraryCalls(g_hInstance);

        g_fDBCSEnabled = GetSystemMetrics(SM_DBCSENABLED);

        // Initialize OleAut
		//
        g_hOleAutHandle = LoadLibrary("oleaut32.dll");
 
        // give the user a chance to initialize whatever
        //
        InitializeLibrary();


#ifdef DEBUG

	TCHAR lpCtlName[255];
	DWORD nSize = 255;
	DWORD fValidPath;

	// set all ctl debug switches
	//
	fValidPath = GetModuleFileName(g_hInstance, (LPTSTR)lpCtlName, nSize);
	if (fValidPath != 0)
	  SetCtlSwitches((LPSTR)lpCtlName);

        // initialize a critical seciton for our heap memory leak detection
        //
	InitializeCriticalSection(&g_csHeap);
	g_fInitCrit = TRUE; 
	
#endif // DEBUG
  
        return TRUE;
        }

      // do  a little cleaning up!
      //
      case DLL_PROCESS_DETACH:

  #ifdef VS_HELP
        ASSERT(g_pIVsHelpSystem == NULL, "IVsHelpSystem didn't get released");
  #endif
        
        // clean up some stuff
        //
        DeleteCriticalSection(&g_CriticalSection);
        CleanupGlobalObjects();

        // give the user a chance to do some cleaning up
        //
        UninitializeLibrary();

        // Deinitialize OleAut, But not in Win95.
		// Calling FreeLibrary under Win95 for OleAut
		// will sometimes cause a crash (It seems that 
		// there can be a rpoblem in which OleAut is called
		// from OleUnitnitialize and causes a problem with FreeLibrary.
		//
        if (g_hOleAutHandle && !g_fSysWin95)
        {
            FreeLibrary((HINSTANCE)g_hOleAutHandle);
            g_hOleAutHandle = NULL;
        }

		// Make sure we free up our cached resource handle for localized resources
		//
		if (g_hInstResources && g_hInstResources != g_hInstance)
			FreeLibrary(g_hInstResources);

		// Free up VERSION.DLL
		//
		if (g_hinstVersion)
		{
			FreeLibrary(g_hinstVersion);
			g_hinstVersion = NULL;
		}
			
#ifdef DEBUG

		// check for memory leaks
		//
		CheckForLeaks();

		// free critical section used for leak checking
		//
		DeleteCriticalSection(&g_csHeap);
		g_fInitCrit = FALSE;
        
#endif //  DEBUG

        return TRUE;
    }

    return TRUE;
}


//=--------------------------------------------------------------------------=
// CleanupGlobalObjects
//=--------------------------------------------------------------------------=
// duh
//
// Notes:
//
void CleanupGlobalObjects(void)
{
    int i = 0;

    while (!ISEMPTYOBJECT(i)) {
        if (g_ObjectInfo[i].usType == OI_CONTROL) {
            if (CTLWNDCLASSREGISTERED(i))
                UnregisterClass(WNDCLASSNAMEOFCONTROL(i), g_hInstance);
        }
        i++;
    }

    // clean up our parking window.
    //
    if (g_hwndParking) {
        DestroyWindow(g_hwndParking);
        g_hwndParking = NULL;
        UnregisterClass("CtlFrameWork_Parking", g_hInstance);
    }

    // clean up after reflection, if appropriate.
    //
    if (g_fRegisteredReflect) {
        UnregisterClass(g_szReflectClassName, g_hInstance);
        g_fRegisteredReflect = FALSE;
    }
}

//=--------------------------------------------------------------------------=
// DllRegisterServer
//=--------------------------------------------------------------------------=
// registers the Automation server
//
// Output:
//    HRESULT
//
// Notes:
//
STDAPI DllRegisterServer
(
    void
)
{
    HRESULT hr;

    hr = RegisterAllObjects();
    RETURN_ON_FAILURE(hr);

    // call user registration function.
    //
    return (RegisterData())? S_OK : E_FAIL;
}



//=--------------------------------------------------------------------------=
// DllUnregisterServer
//=--------------------------------------------------------------------------=
// unregister's the Automation server
//
// Output:
//    HRESULT
//
// Notes:
//
STDAPI DllUnregisterServer
(
    void
)
{
    HRESULT hr;

    hr = UnregisterAllObjects();
    RETURN_ON_FAILURE(hr);

    // call user unregistration function
    //
    return (UnregisterData()) ? S_OK : E_FAIL;
}


//=--------------------------------------------------------------------------=
// DllCanUnloadNow
//=--------------------------------------------------------------------------=
// we are being asked whether or not it's okay to unload the DLL.  just check
// the lock counts on remaining objects ...
//
// Output:
//    HRESULT        - S_OK, can unload now, S_FALSE, can't.
//
// Notes:
//
STDAPI DllCanUnloadNow
(
    void
)
{

#ifdef VS_HELP

      if (g_pIVsHelpSystem)
      {
          g_pIVsHelpSystem->Release();
          g_pIVsHelpSystem = NULL;
      }

#endif

    // if there are any objects lying around, then we can't unload.  The
    // controlling CUnknownObject class that people should be inheriting from
    // takes care of this
    //
#ifdef MDAC_BUILD
    return (g_cLocks || !CanUnloadLibraryNow()) ? S_FALSE : S_OK;
#else
    return (g_cLocks) ? S_FALSE : S_OK;
#endif
}


//=--------------------------------------------------------------------------=
// DllGetClassObject
//=--------------------------------------------------------------------------=
// creates a ClassFactory object, and returns it.
//
// Parameters:
//    REFCLSID        - CLSID for the class object
//    REFIID          - interface we want class object to be.
//    void **         - pointer to where we should ptr to new object.
//
// Output:
//    HRESULT         - S_OK, CLASS_E_CLASSNOTAVAILABLE, E_OUTOFMEMORY,
//                      E_INVALIDARG, E_UNEXPECTED
//
// Notes:
//
STDAPI DllGetClassObject
(
    REFCLSID rclsid,
    REFIID   riid,
    void   **ppvObjOut
)
{
    HRESULT hr;
    void   *pv;
    int     iIndex;

    // arg checking
    //
    if (!ppvObjOut)
        return E_INVALIDARG;

    // first of all, make sure they're asking for something we work with.
    //
    iIndex = IndexOfOleObject(rclsid);
    if (iIndex == -1)
#ifdef MDAC_BUILD
        // NOTE: LibraryGetClassObject() hook for ATL/VS98 support, added by markash
	return LibraryGetClassObject(rclsid, riid, ppvObjOut);
#else         
        return CLASS_E_CLASSNOTAVAILABLE;
#endif

    // create the blank object.
    //
    pv = (void *)new CClassFactory(iIndex);
    if (!pv)
        return E_OUTOFMEMORY;

    // QI for whatever the user has asked for.
    //
    hr = ((IUnknown *)pv)->QueryInterface(riid, ppvObjOut);
    ((IUnknown *)pv)->Release();

    return hr;
}
//=--------------------------------------------------------------------------=
// IndexOfOleObject
//=--------------------------------------------------------------------------=
// returns the index in our global table of objects of the given CLSID.  if
// it's not a supported object, then we return -1
//
// Parameters:
//    REFCLSID     - [in] duh.
//
// Output:
//    int          - >= 0 is index into global table, -1 means not supported
//
// Notes:
//
int IndexOfOleObject
(
    REFCLSID rclsid
)
{
    int x = 0;

    // an object is creatable if it's CLSID is in the table of all allowable object
    // types.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (OBJECTISCREATABLE(x)) {
            if (rclsid == CLSIDOFOBJECT(x))
                return x;
        }
        x++;
    }

    return -1;
}

//=--------------------------------------------------------------------------=
// RegisterAllObjects
//=--------------------------------------------------------------------------=
// registers all the objects for the given automation server.
//
// Parameters:
//    none
//
// Output:
//    HERSULT        - S_OK, E_FAIL
//
// Notes:
//
HRESULT RegisterAllObjects
(
    void
)
{
    ITypeLib *pTypeLib = NULL;
    HRESULT hr;
    DWORD   dwPathLen;
    char    szTmp[MAX_PATH];
    char    szHelpPath[MAX_PATH];
    int     x = 0;
    BOOL    fHelpFile = FALSE;
    long    lMajor = -1, lMinor = -1;
    UINT    cbWinHelpPath = 0;
    OLECHAR *pwszHelpPath;
    BSTR bstrTypeLibName = NULL;
	WORD wFlags = 0;

#if DEBUG
	BOOL fCtlFlagFound = FALSE;
	BOOL fCtlTypeLib = FALSE;
	int iCatID;
	BOOL fCatIDFound = FALSE;
#endif

    // Load and register our type library.
    //
    if (g_fServerHasTypeLibrary) {
        TLIBATTR *ptlattr;
        dwPathLen = GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
        bstrTypeLibName = BSTRFROMANSI(szTmp);
        hr = LoadTypeLib(bstrTypeLibName, &pTypeLib);
        if (FAILED(hr)) goto CleanUp;
		
        pTypeLib->GetLibAttr(&ptlattr);
        lMajor = ptlattr->wMajorVerNum;
        lMinor = ptlattr->wMinorVerNum;

#if DEBUG
		fCtlTypeLib = ptlattr->wLibFlags & LIBFLAG_FCONTROL;
#endif		
        pTypeLib->ReleaseTLibAttr(ptlattr);

    }


    // loop through all of our creatable objects [those that have a clsid in
    // our global table] and register them.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (!OBJECTISCREATABLE(x)) {
            x++;
            continue;
        }
	
        // Check to see if there is a help file for the object
        // If so, look for it in the Windows\Help directory.  If a help file is 
        // found for any object in the Windows\Help directory, then we'll register it with 
        // the typelib.  Once we find the first help file we stop looking.
        //
        if (!fHelpFile) {
            if (cbWinHelpPath == 0)  {
                cbWinHelpPath = GetHelpFilePath(szHelpPath, MAX_PATH);
                lstrcat(szHelpPath, "\\");
                cbWinHelpPath++;
            }
		
            ASSERT(cbWinHelpPath > 0, "Help path is zero length");
            ASSERT(cbWinHelpPath + ((HELPFILEOFOBJECT(x)) ? lstrlen(HELPFILEOFOBJECT(x)) : 0) < MAX_PATH, "Help file path exceeds maxiumu path");
		
            // Make sure we have a non-NULL pointer before calling lstrlen
            // and check that the helpfile exists and isn't a directory
            //		
            if (HELPFILEOFOBJECT(x) && lstrlen(HELPFILEOFOBJECT(x)) > 0) {
                lstrcpyn(szHelpPath + cbWinHelpPath, HELPFILEOFOBJECT(x), lstrlen(HELPFILEOFOBJECT(x)) + 1);
                fHelpFile = ((GetFileAttributes(szHelpPath) & FILE_ATTRIBUTE_DIRECTORY) == 0);
            }

            // Once we've determined the help file exists, terminate after the filename
            // since all we care to register is the path.  Not the path and filename.  We also
            // don't want the terminating '\', so subtract 1 from cbWinHelpPath.
            //
            if (fHelpFile)
                szHelpPath[cbWinHelpPath - 1] = '\0';
            else
                szHelpPath[cbWinHelpPath] = '\0';
        }

        // depending on the object type, register different pieces of information
        //
        switch (g_ObjectInfo[x].usType) {

          // for both simple co-creatable objects and proeprty pages, do the same
          // thing
          //
          case OI_UNKNOWN:
          case OI_PROPERTYPAGE:

	#if DEBUG
			// For debug builds, verify that the cached object data matches the typeinfo attributes for that object
			//
			hr =  GetTypeFlagsForGuid(pTypeLib, CLSIDOFOBJECT(x), &wFlags);
			if (SUCCEEDED(hr))
			{
				if (NULL != CREATEFNOFOBJECT(x))
				{
					ASSERT(wFlags & TYPEFLAG_FCANCREATE, "Create flag not found on creatable object");
				}
				else
				{
					ASSERT(!(wFlags & TYPEFLAG_FCANCREATE), "Create flag found on non-creatable object");
				}
			}
	#endif

            RegisterUnknownObject(NAMEOFOBJECT(x), LABELOFOBJECT(x), CLSIDOFOBJECT(x), ISAPARTMENTMODELTHREADED(x));
            break;

          case OI_AUTOMATION:
	
	#if DEBUG
			// For debug builds, verify that the cached object data matches the typeinfo attributes for that object
			//
			hr =  GetTypeFlagsForGuid(pTypeLib, CLSIDOFOBJECT(x), &wFlags);
			if (SUCCEEDED(hr))
			{
				if (NULL != CREATEFNOFOBJECT(x))
				{
					ASSERT(wFlags & TYPEFLAG_FCANCREATE, "Create flag not found on creatable object");
				}
				else
				{
					ASSERT(!(wFlags & TYPEFLAG_FCANCREATE), "Create flag found on non-creatable object");
				}
			}
	#endif
            RegisterAutomationObject(g_szLibName, NAMEOFOBJECT(x), LABELOFOBJECT(x), VERSIONOFOBJECT(x),
                                     lMajor, lMinor, *g_pLibid, CLSIDOFOBJECT(x), ISAPARTMENTMODELTHREADED(x));
            break;

          case OI_CONTROL:
			
			{	
				BOOL fControl = TRUE;

				//  Go to the TypeInfo for the object and see if it has the control bit set
				//  We should only add the Control and ToolboxBitmap32 registry key for objects 
				//  that have the Control bit set in their typelib.
				//
				//  Note: If the TypeLib can't be found or there is an error attempting to
				//		  retrieve the control flag, we default to setting the Control bit.
				//        Since we're attempting to register the object as a control our
				//        default assumption will be that it is a control.
				//
				hr =  GetTypeFlagsForGuid(pTypeLib, CLSIDOFOBJECT(x), &wFlags);
				if (SUCCEEDED(hr))
				{
					fControl = wFlags & TYPEFLAG_FCONTROL;
			
			#if DEBUG
					fCtlFlagFound |= fControl;

					// For debug builds, verify that the cached object data matches the typeinfo attributes for that object
					//
					if (NULL != CREATEFNOFOBJECT(x))
					{
						ASSERT(wFlags & TYPEFLAG_FCANCREATE, "Create flag not found on creatable object");
					}
					else
					{
						ASSERT(!(wFlags & TYPEFLAG_FCANCREATE), "Create flag found on non-creatable object");
					}
			#endif

				}

				RegisterControlObject(g_szLibName, NAMEOFOBJECT(x), LABELOFOBJECT(x), 
									  VERSIONOFOBJECT(x), VERSIONMINOROFOBJECT(x),
									  lMajor, lMinor,
									  *g_pLibid, CLSIDOFOBJECT(x), OLEMISCFLAGSOFCONTROL(x),
									  BITMAPIDOFCONTROL(x), ISAPARTMENTMODELTHREADED(x),
									  fControl);
			}
            break;

        }
        x++;
    }

	// Make sure the if a TypeLib control attribute was found, a coclass control attribute is also found;
	// or neither is found.  You can't have one without the other.
	// 
	ASSERT((fCtlTypeLib && fCtlFlagFound) || 
		   (!fCtlTypeLib && !fCtlFlagFound), "TypeLib and coclass control attributes not set consistently");


    if (g_fServerHasTypeLibrary)
    {
		ASSERT(pTypeLib, "TypeLib pointer is NULL");
		ASSERT(SysStringLen(bstrTypeLibName) > 0, "TypeLib name is invalid");

        if (fHelpFile)
		pwszHelpPath = OLESTRFROMANSI(szHelpPath);

	// Note: we have to pass in an empty string instead of NULL if fHelpFile==FALSE, because
	//   otherwise OLEAUT leaves the old value of the HELPDIR key there (stephwe 9/97)
        hr = RegisterTypeLib(pTypeLib, bstrTypeLibName, fHelpFile ? pwszHelpPath : L"");

        if (fHelpFile)
		CoTaskMemFree(pwszHelpPath);

        pTypeLib->Release();
        if (FAILED(hr)) goto CleanUp;
    }

#if DEBUG		

	// Make sure there is consistency between the Control flags set in the typelib
	// versus the CATID_Control attribute.
	//
	for (iCatID=0; iCatID < g_ctCATIDImplemented; iCatID++)
	{
		if (IsEqualGUID((REFGUID) *g_rgCATIDImplemented[iCatID], (REFGUID) CATID_Control))
		{
			fCatIDFound = TRUE;					   
			break;
		}
	}
	
	ASSERT((fCatIDFound && fCtlFlagFound) || 
		   (!fCatIDFound && !fCtlFlagFound), "Typelib control attribute not in sync with CATID_Control setting");

#endif

    hr = S_OK;

CleanUp:
    SysFreeString(bstrTypeLibName);

    return hr;
}

//=--------------------------------------------------------------------------=
// UnregisterAllObjects
//=--------------------------------------------------------------------------=
// un-registers all the objects for the given automation server.
//
// Parameters:
//    none
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//	WARNING! You must link with the new version of OLEAUT shipping with
//	         Visual Basic version 5.0 in order for this function to 
//	         work correctly.
//
HRESULT UnregisterAllObjects
(
    void
)
{
    HRESULT hr;
    int x = 0;
    
    char szTmp[MAX_PATH];
    TLIBATTR *ptlibattr = NULL;
    ITypeLib *pTypeLib = NULL;

    // loop through all of our creatable objects [those that have a clsid in
    // our global table] and register them.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (!OBJECTISCREATABLE(x)) {
            x++;
            continue;
        }

        switch (g_ObjectInfo[x].usType) {

          case OI_UNKNOWN:
          case OI_PROPERTYPAGE:
            UnregisterUnknownObject(CLSIDOFOBJECT(x), NULL);
            break;

          case OI_CONTROL:
            UnregisterControlObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                    CLSIDOFOBJECT(x));
	    break;
    
          case OI_AUTOMATION:
            UnregisterAutomationObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                       CLSIDOFOBJECT(x));
            break;

        }
        x++;
    }

    // if we've got one, unregister our type library 
    if (g_pLibid)
    {
	GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
	MAKE_WIDEPTR_FROMANSI(pwsz, szTmp);

	hr = LoadTypeLibEx(pwsz, REGKIND_NONE, &pTypeLib);
	if (FAILED(hr)) goto CleanUp;

	hr = pTypeLib->GetLibAttr(&ptlibattr);		
	if (FAILED(hr)) goto CleanUp;
	
	// Call OLEAUT to have it unregister our type library.  It will handle
	// the case where there is a 16-bit version of the control's typelib
	// registered and will only blow away the 32-bit related keys in this case.
	//
	UnRegisterTypeLib(*g_pLibid, ptlibattr->wMajorVerNum, ptlibattr->wMinorVerNum, ptlibattr->lcid, ptlibattr->syskind);

    }


CleanUp:
    if (ptlibattr)
	pTypeLib->ReleaseTLibAttr(ptlibattr);
    
    RELEASE_OBJECT(pTypeLib);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\pch.h ===
//
// Definition of precompiled header
//
#include "IPserver.h"
#include "Globals.h"
#include "util.h"
#include "macros.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\stdenum.cpp ===
//=--------------------------------------------------------------------------=
// StandardEnum.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of a generic enumerator object.
//
#include "pch.h"
#include "StdEnum.H"

SZTHISFILE

//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//            none
//
// Notes: This default constructor only exists so that derived classes can be created
//        Internal debug checks have been added to confirm that internal
//        state is correctly set before use (calls to Next, Skip, etc)
//        
//
#pragma warning(disable:4355)  // using 'this' in constructor
CStandardEnum::CStandardEnum()
: CUnknownObject(NULL, (IEnumGeneric *)this),
  m_iid(IID_IUnknown),
  m_cElements(0),
  m_cbElementSize(0),
  m_iCurrent(0),
  m_rgElements(NULL),
  m_pfnCopyElement(NULL)
{
    m_pEnumClonedFrom = NULL;
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    REFCLSID        - [in] type of enumerator that we are
//    int             - [in] number of elements in the enumeration
//    int             - [in] size of each element
//    void *          - [in] pointer to element data
//    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
//                    - [in] copying function
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CStandardEnum::CStandardEnum
(
    REFCLSID rclsid,
    int      cElements,
    int      cbElementSize,
    void    *rgElements,
    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
)
: CUnknownObject(NULL, (IEnumGeneric *)this),
  m_iid(rclsid),
  m_cElements(cElements),
  m_cbElementSize(cbElementSize),
  m_iCurrent(0),
  m_rgElements(rgElements),
  m_pfnCopyElement(pfnCopyElement)
{
    m_pEnumClonedFrom = NULL;
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// "it is not death, but dying, which is terrible."
//    - Henry Fielding (1707-54)
//
// Notes:
//
CStandardEnum::~CStandardEnum ()
{
    // if we're a cloned object, then just release our parent object and
    // we're done. otherwise, free up the allocated memory we were given
    //
    if (m_pEnumClonedFrom)
        m_pEnumClonedFrom->Release();
    else {
        if (m_rgElements) CtlHeapFree(g_hHeap, 0, m_rgElements);
    }
}

//=--------------------------------------------------------------------------=
// CStandardEnum::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support our internal iid, and that's all
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CStandardEnum::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    	
    if (DO_GUIDS_MATCH(riid, m_iid) || DO_GUIDS_MATCH(riid, IID_IUnknown)) 
    {
        ExternalAddRef();
        *ppvObjOut = (IEnumGeneric *)this;
        return S_OK;
    }

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Next
//=--------------------------------------------------------------------------=
// returns the next dude in our iteration
//
// Parameters:
//    unsigned long     - [in]  count of elements requested
//    void    *         - [out] array of slots to put values in.
//    unsigned long *   - [out] actual number fetched
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Next
(
    unsigned long  cElm,
    void          *rgDest,
    unsigned long *pcElmOut
)
{
	ASSERT(m_pfnCopyElement, "NULL m_pfnCopyElement is invalid CStandardEnum state!");

    unsigned long cElementsFetched = 0;
    void         *pElementDest = rgDest;
    const void   *pElementSrc = (const BYTE *)m_rgElements + (m_cbElementSize * m_iCurrent);

    while (cElementsFetched < cElm) {

        // if we hit EOF, break out
        //
        if (m_iCurrent >= m_cElements)
            break;

        // copy the element out for them
        //
        m_pfnCopyElement(pElementDest, pElementSrc, m_cbElementSize);

        // increase the counters
        //
        pElementDest = (LPBYTE)pElementDest + m_cbElementSize;
        pElementSrc  = (const BYTE *)pElementSrc + m_cbElementSize;
        m_iCurrent++;
        cElementsFetched++;
    }

    if (pcElmOut)
        *pcElmOut = cElementsFetched;

    return (cElementsFetched < cElm)? S_FALSE : S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Skip
//=--------------------------------------------------------------------------=
// skips the requested number of rows.
//
// Parameters:
//    unsigned long     - [in] number to skip
//
// Output:
//    HRESULT           - S_OK, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Skip
(
    unsigned long cSkip
)
{
	ASSERT(m_pfnCopyElement, "NULL m_pfnCopyElement is invalid CStandardEnum state!");

    // handle running off the end
    //
    if (m_iCurrent + (int)cSkip > m_cElements) {
        m_iCurrent = m_cElements;
        return S_FALSE;
    }

    m_iCurrent += cSkip;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Reset
//=--------------------------------------------------------------------------=
// reset the counter.
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//
STDMETHODIMP CStandardEnum::Reset
(
    void
)
{
    m_iCurrent = 0;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CStandardEnum::Clone
//=--------------------------------------------------------------------------=
// clones the object and gives the new one the same position
//
// Parameters:
//    IEnumVARIANT **    - [out] where to put the new object.
//
// Output;
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStandardEnum::Clone
(
    IEnumGeneric **ppEnumClone
)
{
	ASSERT(m_pfnCopyElement, "NULL m_pfnCopyElement is invalid CStandardEnum state!");

    CStandardEnum *pNewEnum;

    *ppEnumClone = NULL;

    pNewEnum = New CStandardEnum(m_iid, m_cElements, m_cbElementSize, m_rgElements, m_pfnCopyElement);
    RETURN_ON_NULLALLOC(pNewEnum);

    // hold on to who we were cloned from so m_rgElements stays alive, and we don't
    // have to copy it.
    //
    pNewEnum->m_pEnumClonedFrom = this;
    pNewEnum->m_iCurrent = m_iCurrent;

    // AddRef() ourselves on their behalf.
    //
    AddRef();
    *ppEnumClone = (IEnumGeneric *)pNewEnum;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\unknown.cpp ===
//=--------------------------------------------------------------------------=
// Unknown.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation for various things in the unknown object that supports
// aggregation.
//
#include "pch.h"
#include "Unknown.H"
#include <stddef.h>

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::m_pMainUnknown
//=--------------------------------------------------------------------------=
// this method is used when we're sitting in the private unknown object,
// and we need to get at the pointer for the main unknown.  basically, it's
// a little better to do this pointer arithmetic than have to store a pointer
// to the parent, etc.
//
inline CUnknownObject *CUnknownObject::CPrivateUnknownObject::m_pMainUnknown
(
    void
)
{
    return (CUnknownObject *)((LPBYTE)this - offsetof(CUnknownObject, m_UnkPrivate));
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::QueryInterface
//=--------------------------------------------------------------------------=
// this is the non-delegating internal QI routine.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CUnknownObject::CPrivateUnknownObject::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    CHECK_POINTER(ppvObjOut);

    // if they're asking for IUnknown, then we have to pass them ourselves.
    // otherwise defer to the inheriting object's InternalQueryInterface
    //
    if (DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        m_cRef++;
        *ppvObjOut = (IUnknown *)this;
        return S_OK;
    } else
        return m_pMainUnknown()->InternalQueryInterface(riid, ppvObjOut);

    // dead code    
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CUnknownObject::CPrivateUnknownObject::AddRef
(
    void
)
{
    return ++m_cRef;
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CUnknownObject::CPrivateUnknownObject::Release
(
    void
)
{
    // are we just about to go away?
    //
    if (1 == m_cRef) {

        // if we are, then we want to let the user know about it, so they can
        // free things up before their vtables go away.  the extra ref here
        // makes sure that if they addref/release something, they don't cause
        // the current code to get tripped again
        //
        m_cRef++;
        m_pMainUnknown()->BeforeDestroyObject();
        ASSERT(m_cRef == 2, "ctl has Ref Count problem!!");

        m_cRef  = 0; // so people can be sure of this in the destructor
        delete m_pMainUnknown();
        return 0;
    }

    return --m_cRef;
}


//=--------------------------------------------------------------------------=
// CUnknownObject::InternalQueryInterface
//=--------------------------------------------------------------------------=
// objects that are aggregated use this to support additional interfaces.
// they should call this method on their parent so that any of it's interfaces
// are queried.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CUnknownObject::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    *ppvObjOut = NULL;

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// CUnknownObject::BeforeDestroyObject
//=--------------------------------------------------------------------------=
// called just as we are about to trash an object
//
// Notes:
//
void CUnknownObject::BeforeDestroyObject
(
    void
)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\proppage.cpp ===
//=--------------------------------------------------------------------------=
// PropertyPages.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of CPropertyPage object.
//
#include "pch.h"
#include "PropPage.H"

#if defined(VS_HELP) || defined(HTML_HELP)

    #ifdef MS_BUILD
        #include "HtmlHelp.h"
    #else
        #include "HtmlHelp.hxx"
    #endif

    #ifdef VS_HELP
        #include "VSHelp.h"        // Visual Studio html help support
    #endif

#endif

// for ASSERT and FAIL
//
SZTHISFILE



// this variable is used to pass the pointer to the object to the hwnd.
//
static CPropertyPage *s_pLastPageCreated;

//=--------------------------------------------------------------------------=
// CPropertyPage::CPropertyPage
//=--------------------------------------------------------------------------=
// constructor.
//
// Parameters:
//    IUnknown *          - [in] controlling unknown
//    int                 - [in] object type.
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CPropertyPage::CPropertyPage
(
    IUnknown         *pUnkOuter,
    int               iObjectType
)
: CUnknownObject(pUnkOuter, this), m_ObjectType(iObjectType)
{
    // initialize various dudes.
    //
    m_pPropertyPageSite = NULL;
    m_hwnd = NULL;
    m_cObjects = 0;

    m_fDirty = FALSE;
    m_fActivated = FALSE;
    m_fDeactivating = FALSE;
    m_ppUnkObjects = NULL;
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CPropertyPage::~CPropertyPage
//=--------------------------------------------------------------------------=
// destructor.
//
// Notes:
//
CPropertyPage::~CPropertyPage()
{
    // clean up our window.
    //
    if (m_hwnd) {
        SetWindowLong(m_hwnd, GWL_USERDATA, 0xffffffff);
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }

    // release all the objects we're holding on to.
    //
    ReleaseAllObjects();

    // release the site
    //
    RELEASE_OBJECT(m_pPropertyPageSite);
}

//=--------------------------------------------------------------------------=
// CPropertyPage::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support IPP and IPP2.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CPropertyPage::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    IUnknown *pUnk;

    *ppvObjOut = NULL;

    if (DO_GUIDS_MATCH(IID_IPropertyPage, riid)) {
        pUnk = (IUnknown *)this;
    } else if (DO_GUIDS_MATCH(IID_IPropertyPage2, riid)) {
        pUnk = (IUnknown *)this;
    } else {
        return CUnknownObject::InternalQueryInterface(riid, ppvObjOut);
    }

    pUnk->AddRef();
    *ppvObjOut = (void *)pUnk;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::SetPageSite    [IPropertyPage]
//=--------------------------------------------------------------------------=
// the initialization function for a property page through which the page
// receives an IPropertyPageSite pointer.
//
// Parameters:
//    IPropertyPageSite *        - [in] new site.
//
// Output:
//    HRESULT
//
// Notes;
//
STDMETHODIMP CPropertyPage::SetPageSite
(
    IPropertyPageSite *pPropertyPageSite
)
{
    RELEASE_OBJECT(m_pPropertyPageSite);
    m_pPropertyPageSite = pPropertyPageSite;
    ADDREF_OBJECT(pPropertyPageSite);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Activate    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to create it's display window as a child of hwndparent
// and to position it according to prc.
//
// Parameters:
//    HWND                - [in]  parent window
//    LPCRECT             - [in]  where to position ourselves
//    BOOL                - [in]  whether we're modal or not.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Activate
(
    HWND    hwndParent,
    LPCRECT prcBounds,
    BOOL    fModal
)
{
    HRESULT hr;

    // first make sure the dialog window is loaded and created.
    //
    hr = EnsureLoaded();
    RETURN_ON_FAILURE(hr);

    // fire off a PPM_NEWOBJECTS now
    //    
	hr = NewObjects();		// Note: m_fDirty is cleared after this call
    RETURN_ON_FAILURE(hr);

    // set our parent window if we haven't done so yet.
    //
    if (!m_fActivated) {
        SetParent(m_hwnd, hwndParent);
        m_fActivated = TRUE;
    }

    // now move ourselves to where we're told to be and show ourselves
    //
    Move(prcBounds);
    ShowWindow(m_hwnd, SW_SHOW);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Deactivate    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to destroy the window created in activate
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Deactivate
(
    void
)
{
    HRESULT hr = S_OK;

    m_fDeactivating = TRUE;

    SendMessage(m_hwnd, PPM_FREEOBJECTS, 0, (LPARAM)&hr);
    RETURN_ON_FAILURE(hr);

    // blow away your window.
    //
    if (m_hwnd)
    {
        DestroyWindow(m_hwnd);
	    m_hwnd = NULL;
    }

    m_fActivated = FALSE;
    m_fDeactivating = FALSE;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::GetPageInfo    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to fill a PROPPAGEINFO structure
//
// Parameters:
//    PROPPAGEINFO *    - [out] where to put info.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::GetPageInfo
(
    PROPPAGEINFO *pPropPageInfo
)
{
    RECT rect;

    CHECK_POINTER(pPropPageInfo);

    EnsureLoaded();

    // clear it out first.
    //
    memset(pPropPageInfo, 0, sizeof(PROPPAGEINFO));

    pPropPageInfo->pszTitle = OLESTRFROMRESID(TITLEIDOFPROPPAGE(m_ObjectType));
    pPropPageInfo->pszDocString = OLESTRFROMRESID(DOCSTRINGIDOFPROPPAGE(m_ObjectType));
    pPropPageInfo->pszHelpFile = OLESTRFROMANSI(HELPFILEOFPROPPAGE(m_ObjectType));
    pPropPageInfo->dwHelpContext = HELPCONTEXTOFPROPPAGE(m_ObjectType);

    if (!(pPropPageInfo->pszTitle && pPropPageInfo->pszDocString && pPropPageInfo->pszHelpFile))
        goto CleanUp;

    // if we've got a window yet, go and set up the size information they want.
    //
    if (m_hwnd) {
        GetWindowRect(m_hwnd, &rect);

        pPropPageInfo->size.cx = rect.right - rect.left;
        pPropPageInfo->size.cy = rect.bottom - rect.top;
    }

    return S_OK;

  CleanUp:
    if (pPropPageInfo->pszDocString) {
      CoTaskMemFree(pPropPageInfo->pszDocString);
      pPropPageInfo->pszDocString = NULL;
    }
    if (pPropPageInfo->pszHelpFile) {
      CoTaskMemFree(pPropPageInfo->pszHelpFile);
      pPropPageInfo->pszHelpFile = NULL;
    }
    if (pPropPageInfo->pszTitle) {
      CoTaskMemFree(pPropPageInfo->pszTitle);
      pPropPageInfo->pszTitle = NULL;
    }

    return E_OUTOFMEMORY;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::SetObjects    [IPropertyPage]
//=--------------------------------------------------------------------------=
// provides the page with the objects being affected by the changes.
//
// Parameters:
//    ULONG            - [in] count of objects.
//    IUnknown **      - [in] objects.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::SetObjects
(
    ULONG      cObjects,
    IUnknown **ppUnkObjects
)
{
    HRESULT hr;
    ULONG   x;

    //Vegas 33683 - joejo
    // make sure the old control is updated
    // if page is dirty!
    if (m_fDirty)
        hr = Apply();

    // make sure we've been loaded, and free out any other objects that might
    // have been hanging around
    //
    ReleaseAllObjects();

    if (!cObjects)
        return S_OK;

    // now go and set up the new ones.
    //
    m_ppUnkObjects = (IUnknown **)CtlHeapAlloc(g_hHeap, 0, cObjects * sizeof(IUnknown *));
    RETURN_ON_NULLALLOC(m_ppUnkObjects);

    // loop through and copy over all the objects.
    //
    for (x = 0; x < cObjects; x++) {
        m_ppUnkObjects[x] = ppUnkObjects[x];
        ADDREF_OBJECT(m_ppUnkObjects[x]);
    }

    // go and tell the page that there are new objects [but only if it's been
    // activated]
    //
    hr = S_OK;
    m_cObjects = cObjects;
    if (m_fActivated)
        hr = NewObjects();    // Note: m_fDirty is cleared after this call
    
    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Show    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to show or hide its window
//
// Parameters:
//    UINT             - [in] whether to show or hide
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Show
(
    UINT nCmdShow
)
{
    if (m_hwnd)
        ShowWindow(m_hwnd, nCmdShow);
    else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Move    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to relocate and resize itself to a position other than what
// was specified through Activate
//
// Parameters:
//    LPCRECT        - [in] new position and size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Move
(
    LPCRECT prcBounds
)
{
    // do what they sez
    //
    if (m_hwnd)
        SetWindowPos(m_hwnd, NULL, prcBounds->left, prcBounds->top,
                     prcBounds->right - prcBounds->left,
                     prcBounds->bottom - prcBounds->top,
                     SWP_NOZORDER);
    else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::IsPageDirty    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page whether it has changed its state
//
// Output
//    S_OK            - yep
//    S_FALSE         - nope
//
// Notes:
//
STDMETHODIMP CPropertyPage::IsPageDirty
(
    void
)
{
    return m_fDirty ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Apply    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to send its changes to all the objects passed through
// SetObjects()
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Apply
(
    void
)
{
    HRESULT hr = S_OK;

    if (m_hwnd) {
        SendMessage(m_hwnd, PPM_APPLY, 0, (LPARAM)&hr);
        RETURN_ON_FAILURE(hr);

        if (m_fDirty) {
            m_fDirty = FALSE;

            if (m_pPropertyPageSite && !m_fDeactivating)
                m_pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }
    } else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Help    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page that the help button was clicked.
//
// Parameters:
//    LPCOLESTR        - [in] help directory
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Help
(
    LPCOLESTR pszHelpDir        // Note: With VS_HELP set this parameter is ignored
)
{
    char *pszExt;
    char buf[MAX_PATH];
    BOOL f = FALSE;

#ifdef VS_HELP
    BOOL bHelpStarted;
    HRESULT hr;
#endif

    ASSERT(m_hwnd, "CPropertyPage::Help called with no hwnd!");

    pszExt = FileExtension(HELPFILEOFPROPPAGE(m_ObjectType));
    if (pszExt)
    {

    #ifdef VS_HELP
    #else
    #endif

    #if defined(VS_HELP) || defined(HTML_HELP)
    
        if (lstrcmpi(pszExt, "CHM") == 0)
        {

        #ifdef VS_HELP

            lstrcpy(buf, HELPFILEOFPROPPAGE(m_ObjectType));

            // First try to show help through VisualStudio
            //
            hr = VisualStudioShowHelpTopic(buf, HELPCONTEXTOFPROPPAGE(m_ObjectType), &bHelpStarted);
            f = SUCCEEDED(hr);

            // Check to see if Visual Studio help could be successfully started.  If not,
            // assume it doesn't exist
            //
            if (!bHelpStarted)
        
        #endif

            {        
                MAKE_ANSIPTR_FROMWIDE(psz, pszHelpDir);
                lstrcpy(buf, psz);
                lstrcat(buf, "\\");
                lstrcat(buf, HELPFILEOFPROPPAGE(m_ObjectType));

                // Show the help topic manually by calling HtmlHelp directly
                //
                f = (BOOL) HtmlHelp(m_hwnd, buf, HH_HELP_CONTEXT, 
                            HELPCONTEXTOFPROPPAGE(m_ObjectType));            
            }

        #ifdef VS_HELP

            else
            {
                ASSERT(SUCCEEDED(hr), "Failed to show help topic from Visual Studio");
            }

        #endif

        }

        else if (lstrcmpi(pszExt, "HLP") == 0)
    
    #endif

        {
            // WinHelp

            // get the helpfile name
            //
            MAKE_ANSIPTR_FROMWIDE(psz, pszHelpDir);
            lstrcpy(buf, psz);
            lstrcat(buf, "\\");
            lstrcat(buf, HELPFILEOFPROPPAGE(m_ObjectType));

            lstrcat(buf, ">LangRef");				// Use LangRef window style
            f = WinHelp(m_hwnd, buf, HELP_CONTEXT,
                        HELPCONTEXTOFPROPPAGE(m_ObjectType));
        }        

    #if defined(VS_HELP) || defined(HTML_HELP)

        else
        {
            FAIL("Unrecognized help file type");
        }

    #endif

    }


    return f ? S_OK : E_FAIL;
}

static BOOL IsLastTabItem(HWND hdlg, HWND hctl, UINT nCmd)
{
    if ((SendMessage(hdlg, WM_GETDLGCODE, 0, 0L) &
     (DLGC_WANTALLKEYS | DLGC_WANTMESSAGE | DLGC_WANTTAB)) == 0)
    {
        // Get top level child for controls with children, like combo.
        //	        
        HWND hwnd;
        for (/**/; hctl != hdlg; hctl = GetParent(hctl))
            hwnd = hctl;

        // Walk the zorder list until we reached the end
        // or until we get to a valid tab item
        //
        do
        {
	        if ((hwnd = GetWindow(hwnd, nCmd)) == NULL)
		        return TRUE;
        }
        while ((GetWindowLong(hwnd, GWL_STYLE) & (WS_DISABLED|WS_TABSTOP|WS_VISIBLE)) != (WS_TABSTOP|WS_VISIBLE));
	}
    return FALSE;
}


//=--------------------------------------------------------------------------=
// CPropertyPage::TranslateAccelerator    [IPropertyPage]
//=--------------------------------------------------------------------------=
// informs the page of keyboard events, allowing it to implement it's own
// keyboard interface.
//
// Parameters:
//    LPMSG            - [in] message that triggered this
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::TranslateAccelerator
(
    LPMSG pmsg
)
{
    ASSERT(m_hwnd, "How can we get a TranslateAccelerator call if we're not visible?");
    CHECK_POINTER(pmsg);

    BOOL fHandled = FALSE;
    HWND hctl;

    // Special consideration for the Return and Escape keys.
    //
    if ((pmsg->message == WM_KEYDOWN) &&
        ((pmsg->wParam == VK_RETURN) || (pmsg->wParam == VK_ESCAPE))) {

        // Always let the frame handle the Escape key, but if we have the
        // Return key, then we need to ask the focus control if it wants it.
        // Usually, controls that want the Return key will return DLGC_WANTALLKEYS
        // when they process WM_GETDLGCODE.  This is the case when an
        // Edit or RichEdit control has the ES_MULTILINE style
        //
        if (VK_RETURN == pmsg->wParam && m_hwnd != pmsg->hwnd
         && (SendMessage(pmsg->hwnd, WM_GETDLGCODE, 0, 0L) & DLGC_WANTALLKEYS)) {

            // Pass the Return key on as a WM_CHAR, because
            // this is what TranslateMessage will do for a
            // WM_KEYDOWN
            //
            // If a control does not process this message, then
            // it should return non-zero, in which case we can
            // pass it on to the Frame
            //
            fHandled = !SendMessage(pmsg->hwnd, WM_CHAR, pmsg->wParam, pmsg->lParam);
        }

        // If the message was not handled, then let the 
        // Frame handle this message, but we need to change
        // the window handle to that of the propage.
        // This needs to be done because edit controls
        // with ES_WANTRETURN will return DLGC_WANTALLKEYS,
        // which will cause the Frame not to handle the Escape key
        // 
        return fHandled ? S_OK : (pmsg->hwnd = m_hwnd, S_FALSE);
    }

    if (pmsg->message == WM_KEYDOWN && pmsg->wParam == VK_TAB && GetKeyState(VK_CONTROL) >= 0) {
        // If we already have the focus.  Let's determine whether we should
        // pass focus up to the frame.
        //
        if (IsChild(m_hwnd, pmsg->hwnd)) {
            // Fix for default button border
            //
            DWORD dwDefID = SendMessage(m_hwnd, DM_GETDEFID, 0, 0);
            if (HIWORD(dwDefID) == DC_HASDEFID) {
                hctl = GetDlgItem(m_hwnd, LOWORD(dwDefID));
                if (NULL != hctl && IsWindowEnabled(hctl))
                    SendMessage(m_hwnd, WM_NEXTDLGCTL, (WPARAM)hctl, 1L);
            }
            // If the focus control is the last the the tab order
            // then we will pass the message to the frame
            //
            if (IsLastTabItem(m_hwnd, pmsg->hwnd, GetKeyState(VK_SHIFT) < 0 ?
             GW_HWNDPREV : GW_HWNDNEXT)) {
	            // Pass focus to the frame by letting the page site handle
                // this message.
                if (NULL != m_pPropertyPageSite)
                    fHandled = m_pPropertyPageSite->TranslateAccelerator(pmsg) == S_OK;
            }

        } else {

            // We don't already have the focus.  The frame is passing the
            // focus to us.
            //
            hctl = GetNextDlgTabItem(m_hwnd, NULL, GetKeyState(VK_SHIFT) < 0);
            if (NULL != hctl)
                fHandled = (BOOL)SendMessage(m_hwnd, WM_NEXTDLGCTL, (WPARAM)hctl, 1L);
        }            
    }

    // just pass this message on to the dialog proc and see if they want it.
    //
    // just pass this message on to the dialog proc and see if they want it.
    //
    if (FALSE == fHandled) {
        // In order for accelerators to work properly, we need to
        // temporarily replace the message window handle to that
        // of the first child in the property page in response
        // to a WM_SYSKEYDOWN.  This will allow the user to use an
        // accelerator key to go from a tab to a control on the 
        // active page.
        //
        hctl = pmsg->hwnd;
        if (WM_SYSKEYDOWN == pmsg->message && !IsChild(m_hwnd, pmsg->hwnd))
            pmsg->hwnd = GetWindow(m_hwnd, GW_CHILD);

        fHandled = IsDialogMessage(m_hwnd, pmsg);
        pmsg->hwnd = hctl;
    }

    return fHandled ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::EditProperty    [IPropertyPage2]
//=--------------------------------------------------------------------------=
// instructs the page to set the focus to the property matching the dispid.
//
// Parameters:
//    DISPID            - [in] dispid of property to set focus to.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::EditProperty
(
    DISPID dispid
)
{
    HRESULT hr = E_NOTIMPL;

    // send the message on to the control, and see what they want to do with it.
    //
    SendMessage(m_hwnd, PPM_EDITPROPERTY, (WPARAM)dispid, (LPARAM)&hr);

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::EnsureLoaded
//=--------------------------------------------------------------------------=
// makes sure the dialog is actually loaded
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CPropertyPage::EnsureLoaded
(
    void
)
{
    HRESULT hr = S_OK;
    HRSRC hrsrc;
    HGLOBAL hDlg;
    LPCDLGTEMPLATE pDlg;
    HWND hwndDlg;

    // duh
    //
    if (m_hwnd)
        return S_OK;

    // create the dialog window
    //
    hrsrc = FindResource(GetResourceHandle(), TEMPLATENAMEOFPROPPAGE(m_ObjectType), RT_DIALOG);
    ASSERT(hrsrc, "Failed to find dialog template");
    if (!hrsrc) 
	return HRESULT_FROM_WIN32(GetLastError());
        
    hDlg = LoadResource(GetResourceHandle(), hrsrc);
    ASSERT(hDlg, "Failed to load dialog resource");
    if (!hDlg)
	return HRESULT_FROM_WIN32(GetLastError()); 

    pDlg = (LPCDLGTEMPLATE) LockResource(hDlg);
    ASSERT(pDlg, "Failed to lock dialog resource");
    if (!pDlg)
	return HRESULT_FROM_WIN32(GetLastError()); 
    
    // set up the global variable so that when we're in the dialog proc, we can
    // stuff this in the hwnd
    //
    // crit sect this whole creation process for apartment threading support.
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    s_pLastPageCreated = this;

    // Why not call CreateDialog instead?  The answer is that the property page
    // dialog resource may contain Windows custom controls where the window proc for the
    // Windows control resides in your control DLL (e.g., .OCX file), not the 
    // satellite DLL.  If CreateDialog calls CreateWindow to create your Windows custom control 
    // with a different instance than where the window class for the control is 
    // registered, it will fail.
    //
    hwndDlg = CreateDialogIndirect(g_hInstance, pDlg, GetParkingWindow(),
                          (DLGPROC)CPropertyPage::PropPageDlgProc);

    ASSERT(hwndDlg, "Couldn't load Dialog Resource!!!");
    ASSERT(hwndDlg == m_hwnd, "Returned hwnd doesn't match cached hwnd");

    // clean up variables and leave the critical section
    //
    s_pLastPageCreated = NULL;
    LEAVECRITICALSECTION1(&g_CriticalSection);

    if (!m_hwnd)     
        return HRESULT_FROM_WIN32(GetLastError());    

#if 0
    // go and notify the window that it should pick up any objects that are
    // available
    //
    SendMessage(m_hwnd, PPM_NEWOBJECTS, 0, (LPARAM)&hr);
#endif  // 0

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::ReleaseAllObjects
//=--------------------------------------------------------------------------=
// releases all the objects that we're working with
//
// Notes:
//
void CPropertyPage::ReleaseAllObjects
(
    void
)
{
    HRESULT hr;
    UINT x;

    // some people will want to stash pointers in the PPM_INITOBJECTS case, so
    // we want to tell them to release them now.
    //
    if (m_fActivated && m_hwnd)
        SendMessage(m_hwnd, PPM_FREEOBJECTS, 0, (LPARAM)&hr);

    if (!m_cObjects) return;
    // loop through and blow them all away.
    //
    for (x = 0; x < m_cObjects; x++)
        QUICK_RELEASE(m_ppUnkObjects[x]);

    CtlHeapFree(g_hHeap, 0, m_ppUnkObjects);
    m_ppUnkObjects = NULL;
    m_cObjects = 0;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::PropPageDlgProc
//=--------------------------------------------------------------------------=
// static global helper dialog proc that gets called before we pass the message
// on to anybody ..
//
// Parameters:
//    - see win32sdk docs on DialogProc
//
// Notes:
//
BOOL CALLBACK CPropertyPage::PropPageDlgProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    CPropertyPage *pPropertyPage;

    // get the window long, and see if it's been set to the object this hwnd
    // is operating against.  if not, go and set it now.
    //
    pPropertyPage = (CPropertyPage *)GetWindowLong(hwnd, GWL_USERDATA);
    if ((ULONG)pPropertyPage == 0xffffffff)
        return FALSE;
    if (!pPropertyPage) {
        SetWindowLong(hwnd, GWL_USERDATA, (LONG)s_pLastPageCreated);
        pPropertyPage = s_pLastPageCreated;
        pPropertyPage->m_hwnd = hwnd;
    }

    ASSERT(pPropertyPage, "Uh oh.  Got a window, but no CpropertyPage for it!");

    // just call the user dialog proc and see if they want to do anything.
    //
    return pPropertyPage->DialogProc(hwnd, msg, wParam, lParam);
}


//=--------------------------------------------------------------------------=
// CPropertyPage::FirstControl
//=--------------------------------------------------------------------------=
// returns the first controlish object that we are showing ourselves for.
// returns a cookie that must be passed in for Next ...
//
// Parameters:
//    DWORD *    - [out] cookie to be used for Next
//
// Output:
//    IUnknown *
//
// Notes:
//
IUnknown *CPropertyPage::FirstControl
(
    DWORD *pdwCookie
)
{
    // just use the implementation of NEXT.
    //
    *pdwCookie = 0;
    return NextControl(pdwCookie);
}

//=--------------------------------------------------------------------------=
// CPropertyPage::NextControl
//=--------------------------------------------------------------------------=
// returns the next control in the chain of people to work with given a cookie
//
// Parameters:
//    DWORD *            - [in/out] cookie to get next from, and new cookie.
//
// Output:
//    IUnknown *
//
// Notes:
//
IUnknown *CPropertyPage::NextControl
(
    DWORD *pdwCookie
)
{
    UINT      i;

    // go looking through all the objects that we've got, and find the
    // first non-null one.
    //
    for (i = *pdwCookie; i < m_cObjects; i++) {
        if (!m_ppUnkObjects[i]) continue;

        *pdwCookie = i + 1;                // + 1 so we start at next item next time
        return m_ppUnkObjects[i];
    }

    // couldn't find it .
    //
    *pdwCookie = 0xffffffff;
    return NULL;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::NewObjects    [helper]
//=--------------------------------------------------------------------------=
// Sends PPM_NEWOBJECTS message to the property page dialog, so that
// it can initialize its dialog fields.
//
// Notes:
//
HRESULT CPropertyPage::NewObjects()
{
	HRESULT hr = S_OK;
	SendMessage(m_hwnd, PPM_NEWOBJECTS, 0, (LPARAM) &hr);

	// Clear the dirty bit and make sure the Apply button gets disabled.
	//
	if (m_fDirty)
	{
		m_fDirty = FALSE;
        
        ASSERT(m_fDeactivating == FALSE, "We're being deactivated?");
		if (m_pPropertyPageSite)
                m_pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);        
	}

	return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::MakeDirty    [helper, callable]
//=--------------------------------------------------------------------------=
// marks a page as dirty.
//
// Notes:
//
void CPropertyPage::MakeDirty
(
    void
)
{
    m_fDirty = TRUE;
    
    // Need to make sure we have a page site and we're not being deactivated
    // IE 4.0 will crash if we attempt to call OnStatusChange while we're being
    // deactivated
    //
    if (m_pPropertyPageSite && !m_fDeactivating)
        m_pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY|PROPPAGESTATUS_VALIDATE);
}


// from Globals.C
//
extern HINSTANCE g_hInstResources;


//=--------------------------------------------------------------------------=
// CPropertyPage::GetResourceHandle    [helper, callable]
//=--------------------------------------------------------------------------=
// returns current resource handle, based on pagesites ambient LCID.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE CPropertyPage::GetResourceHandle
(
    void
)
{
    if (!g_fSatelliteLocalization)
        return g_hInstance;

    // if we've already got it, then there's not all that much to do.
    // don't need to crit sect this one right here since even if they do fall
    // into the ::GetResourceHandle call, it'll properly deal with things.
    //
    if (g_hInstResources)
        return g_hInstResources;

    // we'll get the ambient localeid from the host, and pass that on to the
    // automation object.
    //
    // enter a critical section for g_lcidLocale and g_fHavelocale
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (!g_fHaveLocale) {
        if (m_pPropertyPageSite) {
            m_pPropertyPageSite->GetLocaleID(&g_lcidLocale);
            g_fHaveLocale = TRUE;
        }
    }
    LEAVECRITICALSECTION1(&g_CriticalSection);

    return ::GetResourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\adbind.h ===
//=--------------------------------------------------------------------------=
//
// adbind.h	Microsoft Active Data Binding interfaces
//
//              Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
//=--------------------------------------------------------------------------=
#ifndef _ADBIND_H_
#define _ADBIND_H_

#include "oledb.h"

DEFINE_GUID(IID_IDataFormat, 0xaf08b280, 0x90f2, 0x11d0,0x94, 0x84, 0x00, 0xa0, 0xc9, 0x11, 0x10, 0xed);

//=--------------------------------------------------------------------------=
// IDataFormat interface
//=--------------------------------------------------------------------------=
#undef  INTERFACE
#define INTERFACE IID_IDataFormat

// The following are used with IDataFormat::GetBinding
#define DATAFORMAT_FGETDATA	0x0   // Return a SetData binding
#define DATAFORMAT_FSETDATA	0x1   // Return a GetData binding

DECLARE_INTERFACE_(IDataFormat, IUnknown)
{
  STDMETHOD(GetBinding)(VARTYPE vtPropHint, DWORD rgfDataFormat, IUnknown* prowset, DBCOLUMNINFO* pcolinfo, DBBINDING* pbinding, ULONG* pcbSize, DWORD* pdwCookie) PURE;
  STDMETHOD(GetData)(DWORD dwCookie, void* pvFrom, VARIANT* pvarTo, DBSTATUS* pdbstatus, IDispatch* pdispObject) PURE;
  STDMETHOD(SetData)(DWORD dwCookie, VARIANT* pvarFrom, void* pvTo, IDispatch* pdispObject) PURE;
  STDMETHOD(ReleaseData)(DWORD dwCookie, void* pv) PURE;
  STDMETHOD(ReleaseBinding)(DWORD dwCookie) PURE;
  STDMETHOD(GetRawData)(DWORD dwCookie, void *pvFrom, VARIANT *pvarTo, DBSTATUS *pdbstatus) PURE;
  STDMETHOD(SetRawData)(DWORD dwCookie, VARIANT *pvarFrom, void *pvTo) PURE;
  STDMETHOD(Clone)(IDataFormat **ppDataFormat) PURE;
  STDMETHOD(Convert)(DWORD dwCookie, const VARIANT *pvarFrom, VARIANT *pvarTo) PURE;
  STDMETHOD(SetLcid)(LCID lcid) PURE;
  STDMETHOD(Default)(BOOL *fDefault) PURE;
  STDMETHOD(GetLcid)(LCID *lcid) PURE;
};

#endif // _ADBIND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\util.cpp ===
//=--------------------------------------------------------------------------=
// Util.C
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains routines that we will find useful.
//
#include "pch.h"

#include <comcat.h>

// for ASSERT and FAIL
//
SZTHISFILE

BOOL g_bDllVerChecked = FALSE;

// VERSION.DLL functions
//
HINSTANCE g_hinstVersion = NULL;
PVERQUERYVALUE g_pVerQueryValue = NULL;
PGETFILEVERSIONINFO g_pGetFileVersionInfo = NULL;
PGETFILEVERSIONINFOSIZE g_pGetFileVersionInfoSize = NULL;

// temporary until we get an updated ComCat.H
//
EXTERN_C const CATID CATID_SimpleFrameControl = {0xD40C2700,0xFFA1,0x11cf,{0x82,0x34,0x00,0xaa,0x00,0xC1,0xAB,0x85}};

// These are externals for registering the control CATID's
extern const CATID *g_rgCATIDImplemented[];
extern const CATID *g_rgCATIDRequired[];
extern const int g_ctCATIDImplemented;
extern const int g_ctCATIDRequired;

#define CATID_ARRAY_SIZE 10

//=---------------------------------------------------------------------------=
// this table is used for copying data around, and persisting properties.
// basically, it contains the size of a given data type
//
const BYTE g_rgcbDataTypeSize[] = {
    0,                      // VT_EMPTY= 0,
    0,                      // VT_NULL= 1,
    sizeof(short),          // VT_I2= 2,
    sizeof(long),           // VT_I4 = 3,
    sizeof(float),          // VT_R4  = 4,
    sizeof(double),         // VT_R8= 5,
    sizeof(CURRENCY),       // VT_CY= 6,
    sizeof(DATE),           // VT_DATE = 7,
    sizeof(BSTR),           // VT_BSTR = 8,
    sizeof(IDispatch *),    // VT_DISPATCH    = 9,
    sizeof(SCODE),          // VT_ERROR    = 10,
    sizeof(VARIANT_BOOL),   // VT_BOOL    = 11,
    sizeof(VARIANT),        // VT_VARIANT= 12,
    sizeof(IUnknown *),     // VT_UNKNOWN= 13,
};

#ifndef MDAC_BUILD

    //=---------------------------------------------------------------------------=
    // overloaded new
    //=---------------------------------------------------------------------------=
    //
    // Please use New instead of new by inheriting from the class CtlNewDelete 
    // in Macros.H
    //
    inline void * _cdecl operator new
    (
        size_t    size
    )
    {
      if (!g_hHeap)
		    {
		    g_hHeap = GetProcessHeap();
		    return g_hHeap ? CtlHeapAlloc(g_hHeap, 0, size) : NULL;
		    }

      return CtlHeapAlloc(g_hHeap, 0, size);
    }

    //=---------------------------------------------------------------------------=
    // overloaded delete
    //=---------------------------------------------------------------------------=
    // retail case just uses win32 Local* heap mgmt functions
    //
    // Parameters:
    //    void *        - [in] free me!
    //
    // Notes:
    //
    void _cdecl operator delete ( void *ptr)
    {
        if (ptr)
          CtlHeapFree(g_hHeap, 0, ptr);
    }

#endif

//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
        break;
      default:
        FAIL("Bogus String Type.");
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromResId
//=--------------------------------------------------------------------------=
// given a resource ID, load it, and allocate a wide string for it.
//
// Parameters:
//    WORD            - [in] resource id.
//    BYTE            - [in] type of string desired.
//
// Output:
//    LPWSTR          - needs to be cast to desired string type.
//
// Notes:
//
LPWSTR MakeWideStrFromResourceId
(
    WORD    wId,
    BYTE    bType
)
{
    int i;

    char szTmp[512];

    // load the string from the resources.
    //
    i = LoadString(GetResourceHandle(), wId, szTmp, 512);
    if (!i) return NULL;

    return MakeWideStrFromAnsi(szTmp, bType);
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromWide
//=--------------------------------------------------------------------------=
// given a wide string, make a new wide string with it of the given type.
//
// Parameters:
//    LPWSTR            - [in]  current wide str.
//    BYTE              - [in]  desired type of string.
//
// Output:
//    LPWSTR
//
// Notes:
//
LPWSTR MakeWideStrFromWide
(
    LPWSTR pwsz,
    BYTE   bType
)
{
    LPWSTR pwszTmp;
    int i;

    if (!pwsz) return NULL;

    // just copy the string, depending on what type they want.
    //
    switch (bType) {
      case STR_OLESTR:
        i = lstrlenW(pwsz);
        pwszTmp = (LPWSTR)CoTaskMemAlloc((i * sizeof(WCHAR)) + sizeof(WCHAR));
        if (!pwszTmp) return NULL;
        memcpy(pwszTmp, pwsz, (sizeof(WCHAR) * i) + sizeof(WCHAR));
        break;

      case STR_BSTR:
        pwszTmp = (LPWSTR)SysAllocString(pwsz);
        break;
    }

    return pwszTmp;
}

//=--------------------------------------------------------------------------=
// StringFromGuidA
//=--------------------------------------------------------------------------=
// returns an ANSI string from a CLSID or GUID
//
// Parameters:
//    REFIID               - [in]  clsid to make string out of.
//    LPSTR                - [in]  buffer in which to place resultant GUID.
//
// Output:
//    int                  - number of chars written out.
//
// Notes:
//
int StringFromGuidA
(
    REFIID   riid,
    LPSTR    pszBuf
)
{
    return wsprintf((char *)pszBuf, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", riid.Data1, 
            riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], 
            riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);

}

//=--------------------------------------------------------------------------=
// RegisterUnknownObject
//=--------------------------------------------------------------------------=
// registers a simple CoCreatable object.  nothing terribly serious.
// we add the following information to the registry:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
//
// Parameters:
//    LPCSTR       - [in] Object Name
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't register it all
//
// Notes:
//
BOOL RegisterUnknownObject
(
    LPCSTR   pszObjectName,
    LPCSTR   pszLabelName,
    REFCLSID riidObject,
    BOOL     fAptThreadSafe
)
{
    HKEY  hk = NULL, hkSub = NULL;
    char  szGuidStr[GUID_STR_LEN];
    DWORD dwPathLen, dwDummy;
    char  szScratch[MAX_PATH];
    long  l;

    // HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32  @ThreadingModel = Apartment
    //

    // If someone has added Implemented Categories for our control, then
    // don't blow away the entire CLSID section as we will blow away
    // these keys.  Ideally we should clean up all other keys, but 
    // implemented categories, but this would be expensive.
    //
    if (!ExistImplementedCategories(riidObject))
	// clean out any garbage
	//
	UnregisterUnknownObject(riidObject, NULL);

    if (!StringFromGuidA(riidObject, szGuidStr)) 
	goto CleanUp;
    wsprintf(szScratch, "CLSID\\%s", szGuidStr);
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    if (!pszLabelName)
	wsprintf(szScratch, "%s Object", pszObjectName);	        
    else 
        lstrcpy(szScratch, pszLabelName);

    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);

    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "InprocServer32", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    dwPathLen = GetModuleFileName(g_hInstance, szScratch, sizeof(szScratch));
    if (!dwPathLen) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, dwPathLen + 1);
    CLEANUP_ON_ERROR(l);

    if (fAptThreadSafe)
    {
	l = RegSetValueEx(hkSub, "ThreadingModel", 0, REG_SZ, (BYTE *)"Apartment", sizeof("Apartment"));
	CLEANUP_ON_ERROR(l);
    }
    else
    {
        // Blow away any existing key that would say we're Apartment model threaded
        //
	RegDeleteValue(hkSub, "ThreadingModel");    
    }

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    return TRUE;

    // we are not very happy!
    //
  CleanUp:
    if (hk) RegCloseKey(hk);
    if (hkSub) RegCloseKey(hkSub);
    return FALSE;

}

//=--------------------------------------------------------------------------=
// RegisterAutomationObject
//=--------------------------------------------------------------------------=
// given a little bit of information about an automation object, go and put it
// in the registry.
// we add the following information in addition to that set up in
// RegisterUnknownObject:
//
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> = <ObjectName> Object
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CLSID = <CLSID>
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CurVer = <ObjectName>.Object.<VersionNumber>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\Version = <VERSION>
//
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> = <ObjectName> Object
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber>\CLSID = <CLSID>
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\TypeLib = <LibidOfTypeLibrary>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\ProgID = <LibraryName>.<ObjectName>.<VersionNumber>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\VersionIndependentProgID = <LibraryName>.<ObjectName>
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Object Version Number
//    long         - [in] typelib major ver
//    long         - [in] typelib minor ver
//    REFCLSID     - [in] LIBID of type library
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//
BOOL RegisterAutomationObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    LPCSTR   pszLabelName,
    long     lVersion,
    long     lTLMajor,
    long     lTLMinor,
    REFCLSID riidLibrary,
    REFCLSID riidObject,
    BOOL     fAptThreadSafe
)
{
    ICatRegister *pCatRegister;
    HRESULT hr;
    HKEY  hk = NULL, hkSub = NULL;
    char  szGuidStr[GUID_STR_LEN];
    char  szScratch[MAX_PATH];
    long  l;
    DWORD dwDummy;

    // This is a warning assert.  If you've tripped this, then your current component 
    // is within VERSION_DELTA versions of exceeding MAX_VERSION.  Consider bumping up MAX_VERSION 
    // or change the delta to a smaller number.  Reasonable settings for these
    // depend on how often you do a major version change of your component.
    //
    ASSERT(MAX_VERSION > VERSION_DELTA, "The MAX_VERSION setting is not in line with what we expect it to be.");
    ASSERT(lVersion <= MAX_VERSION - VERSION_DELTA, "Version number of component is approaching or exceeds limit of checked range.  Consider increasing MAX_VERSION value.");

    // first register the simple Unknown stuff.
    //
    if (!RegisterUnknownObject(pszObjectName, pszLabelName, riidObject, fAptThreadSafe)) return FALSE;

    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CLSID = <CLSID>
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CurVer = <ObjectName>.Object.<VersionNumber>
    //
    lstrcpy(szScratch, pszLibName);
    lstrcat(szScratch, ".");
    lstrcat(szScratch, pszObjectName);

    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0L, "",
                       REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    if (!pszLabelName)
	wsprintf(szScratch, "%s Object", pszObjectName);
    else
        lstrcpy(szScratch, pszLabelName);

    l = RegSetValueEx(hk, NULL, 0L, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch)+1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "CLSID", 0L, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    if (!StringFromGuidA(riidObject, szGuidStr))
        goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0L, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "CurVer", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    ASSERT(pszObjectName, "Object name is NULL");
    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber>\CLSID = <CLSID>
    //
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    if (!pszLabelName)
	wsprintf(szScratch, "%s Object", pszObjectName);
    else
	lstrcpy(szScratch, pszLabelName);

    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "CLSID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\ProgID = <LibraryName>.<ObjectName>.<VersionNumber>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\VersionIndependentProgID = <LibraryName>.<ObjectName>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\TypeLib = <LibidOfTypeLibrary>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\Version = "<TLMajor>.<TLMinor>"
    //
    if (!StringFromGuidA(riidObject, szGuidStr)) goto CleanUp;
    wsprintf(szScratch, "CLSID\\%s", szGuidStr);

    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ|KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "VersionIndependentProgID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);

    l = RegCreateKeyEx(hk, "ProgID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "TypeLib", 0, "", REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkSub, &dwDummy);

    if (!StringFromGuidA(riidLibrary, szGuidStr)) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    // now set up the version information
    //
    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "Version", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%ld.%ld", lTLMajor, lTLMinor);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);

    // now, finally, register ourselves with component categories
    //
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,
                          CLSCTX_INPROC_SERVER, IID_ICatRegister,
                          (void **)&pCatRegister);
    if (SUCCEEDED(hr)) {
        pCatRegister->RegisterClassImplCategories(riidObject, 1,
                                                  (GUID *)&CATID_Programmable);
        pCatRegister->Release();
    }

    RegCloseKey(hkSub);
    RegCloseKey(hk);
    return TRUE;

  CleanUp:
    if (hk) RegCloseKey(hkSub);
    if (hk) RegCloseKey(hk);
    return FALSE;
}

//=--------------------------------------------------------------------------=
// RegisterControlObject.
//=--------------------------------------------------------------------------=
// in addition to writing out automation object information, this function
// writes out some values specific to a control.
//
// What we add here:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\Control
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\MiscStatus\1 = <MISCSTATUSBITS>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\ToolboxBitmap32 = <PATH TO BMP>
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Object Major Version Number
//    long         - [in] Object Minor Vesrion Number
//    long         - [in] TypeLib Major Version Number
//    long         - [in] Typelib minor version number
//    REFCLSID     - [in] LIBID of type library
//    REFCLSID     - [in] CLSID of the object
//    DWORD        - [in] misc status flags for ctl
//    WORD         - [in] toolbox id for control
//	  BOOL	       - [in] Apartment thread safe flag
//	  BOOL		   - [in] Control bit:Flag to tell whether to add the Control key or not.
//
// Output:
//    BOOL
//
// Notes:
//    - not the most terribly efficient routine.
//
BOOL RegisterControlObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    LPCSTR   pszLabelName,
    long     lMajorVersion,
    long     lMinorVersion,
    long     lTLMajor,
    long     lTLMinor,
    REFCLSID riidLibrary,
    REFCLSID riidObject,
    DWORD    dwMiscStatus,
    WORD     wToolboxBitmapId,
    BOOL     fAptThreadSafe,
	BOOL	 fControl
)
{
    ICatRegister *pCatRegister;
    HRESULT hr;
    HKEY    hk, hkSub = NULL, hkSub2 = NULL;
    char    szTmp[MAX_PATH];
    char    szGuidStr[GUID_STR_LEN];
    DWORD   dwDummy;
    CATID   rgCatid[CATID_ARRAY_SIZE];
    LONG    l;

    // first register all the automation information for this sucker.
    //
    if (!RegisterAutomationObject(pszLibName, pszObjectName, pszLabelName, lMajorVersion, lTLMajor, lTLMinor, riidLibrary, riidObject, fAptThreadSafe)) return FALSE;

    // then go and register the control specific stuff.
    //
    StringFromGuidA(riidObject, szGuidStr);
    wsprintf(szTmp, "CLSID\\%s", szGuidStr);
    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, szTmp, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // create the control flag.
    //
	if (fControl)
	{
		l = RegCreateKeyEx(hk, "Control", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
		CLEANUP_ON_ERROR(l);
		RegCloseKey(hkSub);
		hkSub = NULL;
	}

    // now set up the MiscStatus Bits...
    //       
    l = RegCreateKeyEx(hk, "MiscStatus", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    szTmp[0] = '0';
    szTmp[1] = '\0';
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, 2);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hkSub, "1", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub2, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szTmp, "%d", dwMiscStatus);
    l = RegSetValueEx(hkSub2, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
    RegCloseKey(hkSub2);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    hkSub = NULL; 

	// Don't need Toolbox bitmap for designers and other non-controls
	//
	if (fControl)
	{
		// now set up the toolbox bitmap
		//
		GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
		wsprintf(szGuidStr, ", %d", wToolboxBitmapId);
		lstrcat(szTmp, szGuidStr);

		l = RegCreateKeyEx(hk, "ToolboxBitmap32", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
		CLEANUP_ON_ERROR(l);

		l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
		CLEANUP_ON_ERROR(l);
	}

    // now, finally, register ourselves with component categories
    //
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,
                          CLSCTX_INPROC_SERVER, IID_ICatRegister,
                          (void **)&pCatRegister);
    if (SUCCEEDED(hr)) {
      int iCounter;

      ASSERT(g_ctCATIDImplemented <= CATID_ARRAY_SIZE  &&  
             g_ctCATIDRequired <= CATID_ARRAY_SIZE,
             "Array for CATID's is too small.  Need to adjust.");

      // Register all the implemented CATID's of the control.
      if(g_ctCATIDImplemented > 0)
      {
        for(iCounter = 0;  iCounter < g_ctCATIDImplemented  && 
                           iCounter < CATID_ARRAY_SIZE;  iCounter++)
          memcpy(&(rgCatid[iCounter]), g_rgCATIDImplemented[iCounter], sizeof(CATID));

        pCatRegister->RegisterClassImplCategories(riidObject, 
                                                  g_ctCATIDImplemented, 
                                                  (GUID *)rgCatid);
      } //if

      // Register all the Required CATID's of the control.
      if(g_ctCATIDRequired > 0)
      {
        for(iCounter = 0;  iCounter < g_ctCATIDRequired  &&
                           iCounter < CATID_ARRAY_SIZE;  iCounter++)
          memcpy(&(rgCatid[iCounter]), g_rgCATIDRequired[iCounter], sizeof(CATID));

        pCatRegister->RegisterClassReqCategories(riidObject, 
                                                 g_ctCATIDRequired,
                                                 (GUID *)rgCatid);
      } //if

        pCatRegister->Release();
    }

  CleanUp:
    if (hk)
        RegCloseKey(hk);
    if (hkSub)
        RegCloseKey(hkSub);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// UnregisterUnknownObject
//=--------------------------------------------------------------------------=
// cleans up all the stuff that RegisterUnknownObject puts in the
// registry.
//
// Parameters:
//    REFCLSID     - [in] CLSID of the object
//    BOOL	   - [out] Returns TRUE if all keys were deleted for the 
//			   given CLSID.  Returns FALSE if only the
//			   InprocServer32 key or no keys were deleted.
//			   The caller can pass NULL if they don't care
//			   about what set of keys were removed.
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//	WARNING! This routine assumes that all framework built components
//		 and their predessors are in-process server 32-bit DLLs.
//               If other server types exist for control's CLSID
//		 the CLSID entry will be blown away for these server types.
//
//		 If the framework and the control are built as 16-bit components
//	         and you unregister the control, the information will be left
//	         in the registry.  You're on your own to make this work for 16-bit.
//
//		 This routine *only* preserves the CLSID section if
//		 a 16-bit InprocServer key is found.
//
BOOL UnregisterUnknownObject
(
    REFCLSID riidObject,
    BOOL *pfAllRemoved
)
{
    char szScratch[MAX_PATH];
    HKEY hk;
    BOOL f;
    long l;

    // Start on the assumption that we are going to blow away the entire section
    // for the given CLSID.  If this turns out to be a false assumption we'll
    // reset this to FALSE.
    //
    if (pfAllRemoved)
        *pfAllRemoved = TRUE;

    // delete everybody of the form
    //   HKEY_CLASSES_ROOT\CLSID\<CLSID> [\] *
    //
    if (!StringFromGuidA(riidObject, szScratch))
        return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "CLSID", 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // See if a 16-bit in-proc server is register for this object
    // If so, then we don't want to disturb any of the keys except
    // the 32-bit in-proc server key
    //
    if (ExistInprocServer(hk, szScratch))
    {
	// Move one more level down to the InprocServer32 key and only delete it
	// We need to preserve the other keys for the InprocServer.
	//
	lstrcat(szScratch, "\\InprocServer32");
	if (pfAllRemoved)
		*pfAllRemoved = FALSE;
    }

    f = DeleteKeyAndSubKeys(hk, szScratch);

    RegCloseKey(hk);

    return f;				   
}

//=--------------------------------------------------------------------------=
// UnregisterAutomationObject
//=--------------------------------------------------------------------------=
// unregisters an automation object, including all of it's unknown object
// information.
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't get it all unregistered.
//
// Notes:
//
BOOL UnregisterAutomationObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidObject
)
{
    char szScratch[MAX_PATH];
    HKEY hk;
    BOOL f, fAllRemoved, fFailure;    
    long l, lVersionFound;    
    DWORD dwDummy;
    BOOL bSuccess;

    // first thing -- unregister Unknown information
    //
    f = UnregisterUnknownObject(riidObject, &fAllRemoved);
    if (!f) return FALSE;

    if (fAllRemoved)
    {
          
	// delete everybody of the form
	//   HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> [\] *
        //
	// Note: It's important we unregister the version dependent progid first
        //       otherwise, if another version of the component was unregistered
        //       it will have blown away the version independent progid, we'd
        //       fail and never blow away the version dependent progid
	wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
	f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch);	
        if (!f) return FALSE;
        

        // Before we blow away the version independent ProgId, make sure there are 
        // no version dependent ProgIds out there
        //
        if (!QueryOtherVersionProgIds(pszLibName, pszObjectName, lVersion, &lVersionFound, &fFailure))
        {
            ASSERT(!fFailure, "QueryOtherVersionProgIds failed");

            // If a failure occurred such that we don't know if there was another version,
            // error on the side of leaving the version dependent ProgId in the registry.
            //
            if (!fFailure)
            {
	        // delete everybody of the form:
	        //   HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> [\] *
	        //
                wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName);        
	        f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch);
	        if (!f) return FALSE;
            }
        }
        else
        {
            // This is here to fix a bug in the previous version of the framework
            // In the previous version we'd blindly blow away the progid for the
            // component without looking for other versions.  To help
            // resolve this, we'll restore the progid if we found other 
            // version dependent progids.
            //       
            ASSERT(lVersionFound > 0, "Version number found is 0");
            bSuccess = CopyVersionDependentProgIdToIndependentProgId(pszLibName, pszObjectName, lVersionFound);
            ASSERT(bSuccess, "Failed to copy version dependent ProgId to version independent ProgId");
            
            // The previous version of the framework didn't write out the CurVer sub-key so
            // we need to take care of that here.
            //
            wsprintf(szScratch, "%s.%s\\CurVer", pszLibName, pszObjectName);                                    
            l = RegOpenKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, KEY_ALL_ACCESS, &hk);
            if (ERROR_SUCCESS != l)
            {
                l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                                                        KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
                
                ASSERT(ERROR_SUCCESS == l, "Failed to create reg key");
                if (ERROR_SUCCESS == l)
                {
                    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersionFound);
                    
                    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);                    
                    ASSERT(ERROR_SUCCESS == l, "Failed to set key value");

                    l = RegCloseKey(hk);
                    ASSERT(ERROR_SUCCESS == l, "Failed to close key");
                }
                    
            }
            else
            {
                l = RegCloseKey(hk);
            }
                                           
        }       

    }

    return TRUE;
}

//=--------------------------------------------------------------------------=
// UnregisterTypeLibrary
//=--------------------------------------------------------------------------=
// blows away the type library keys for a given libid.
//
// Parameters:
//    REFCLSID        - [in] libid to blow away.
//
// Output:
//    BOOL            - TRUE OK, FALSE bad.
//
// Notes:
//    - WARNING: this function just blows away the entire type library section,
//      including all localized versions of the type library.  mildly anti-
//      social, but not killer.
//
BOOL UnregisterTypeLibrary
(
    REFCLSID riidLibrary
)
{
    HKEY hk;
    char szScratch[GUID_STR_LEN];
    long l;
    BOOL f;

    // convert the libid into a string.
    //
    if (!StringFromGuidA(riidLibrary, szScratch))
	return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "TypeLib", 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    f = DeleteKeyAndSubKeys(hk, szScratch);
    RegCloseKey(hk);
    return f;
}


//=--------------------------------------------------------------------------=
// DeleteKeyAndSubKeys
//=--------------------------------------------------------------------------=
// deletes a key and all of its subkeys.
//
// Parameters:
//    HKEY                - [in] delete the descendant specified
//    LPCSTR              - [in] i'm the descendant specified
//
// Output:
//    BOOL                - TRUE OK, FALSE baaaad.
//
// Notes:
//    - I don't feel too bad about implementing this recursively, since the
//      depth isn't likely to get all the great.
//    - Despite the win32 docs claiming it does, RegDeleteKey doesn't seem to
//      work with sub-keys under windows 95.
//
BOOL DeleteKeyAndSubKeys
(
    HKEY    hkIn,
    LPCSTR  pszSubKey
)
{
    HKEY  hk;
    char  szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    BOOL  f;

    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // loop through all subkeys, blowing them away.
    //
    f = TRUE;
    while (f) {
        dwTmpSize = MAX_PATH;
        // We're deleting keys, so always enumerate the 0th
        l = RegEnumKeyEx(hk, 0, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (l != ERROR_SUCCESS) break;
        f = DeleteKeyAndSubKeys(hk, szTmp);
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    RegCloseKey(hk);
    l = RegDeleteKey(hkIn, pszSubKey);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// QueryOtherVersionProgIds [RegisterTypeLib helper]
//=--------------------------------------------------------------------------=
// Searches for other version dependent ProgIds for a component
//
// Parameters:
//    pszLibName          - [in] lib name portion of ProgId <libname.coclass>
//    pszObjectName       - [in] coclass portion of ProgId  <libname.coclass>
//    lVersion            - [in] Major version number of our component
//    plFoundVersion      - [out] The largest version number found not equal to our own.  
//                                The version number will be less than or equal to MAX_VERSION
//    pfFailure           - [out] Flag indicating that a failure occurred preventing
//                                us from knowing if there are any other ProgIds
// Output:
//    BOOL                - TRUE:  One or more other version dependent progids exist
//                          FALSE: No other version dependent progids exist
//
// Notes:
//    - If a version dependent ProgId exceeds MAX_VERSION we won't find it.
//    - ASSUMPTION: Major versions are checked for starting at MAX_VERSION and working
//                  down to 1.  An assert will occur if your component
//                  approaches MAX_VERSION allowing you to bump up MAX_VERSION.
//                  The assumption is that major version changes on components 
//                  built with the framework are rare.  It should take many
//                  dev cycles and many years to approach this limit.
//                  Once you get near the limit the assert fires and you
//                  can modify the value to anticipate future versions.
//                  This will allow components built today to successfully
//                  find ProgIds for other components built in the future.                  
//                  However, at some point a component built today won't
//                  be able to find other controls that exceed today's 
//                  MAX_VERSION value.  If this is a concern, re-write
//                  this routine to use RegEnumKey and look for any
//                  version dependent ProgId independent of it's version number.
//                  We chose not to implement it this way, since there may be
//                  several hundred calls to RegEnumKey to find the ProgId
//                  you're looking for.  It's cheaper to make at most MAX_VERSION
//                  calls.
//
BOOL QueryOtherVersionProgIds
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    long     *plFoundVersion,
    BOOL     *pfFailure
    
)
{
    BOOL fFound;
    char szTmp[MAX_PATH];
    long lVer;
    long l;
    HKEY hk, hkVersion;    

    CHECK_POINTER(pszLibName);
    CHECK_POINTER(pszObjectName);

    // This is a warning assert.  If you've tripped this, then your current component 
    // is within VERSION_DELTA versions of exceeding MAX_VERSION.  Consider bumping up MAX_VERSION 
    // or change the delta to a smaller number.  Reasonable settings for these
    // depend on how often you do a major version change of your component.
    //
    ASSERT(MAX_VERSION > VERSION_DELTA, "The MAX_VERSION setting is not in line with what we expect it to be.");
    ASSERT(lVersion <= MAX_VERSION - VERSION_DELTA, "Version number of component is approaching or exceeds limit of checked range.  Consider increasing MAX_VERSION value.");

    // Initialize out params
    //
    if (plFoundVersion)
        *plFoundVersion = 0;

    if (pfFailure)
        *pfFailure = TRUE;

    fFound = FALSE;
    
    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "", 0, KEY_ALL_ACCESS, &hk);
    ASSERT(l == ERROR_SUCCESS, "Failed to open HKEY_CLASSES_ROOT");
    if (l != ERROR_SUCCESS) return FALSE;   // Note: If this fails we don't know whether a version dependent ProgId exists or not.

    // We need to walk backwards down from MAX_VERSION so that we end up with the largest version number
    // not equaling our own
    // PERF: It's cheaper to look for a realistic set of versions than it is to enumerate all registry keys
    //       looking for a partial match on the ProgId to figure out what versions are available.
    //
    for (lVer = MAX_VERSION; lVer > 0; lVer--)
    {
        // We know about our version number, skip it.
        //
        if (lVersion == lVer)
            continue;

        // Create version dependent ProgId
        //
        wsprintf(szTmp, "%s.%s.%ld", pszLibName, pszObjectName, lVer);

        l = RegOpenKeyEx(hk, szTmp, 0, KEY_ALL_ACCESS, &hkVersion);

        if (ERROR_SUCCESS == l)        
        {
            // We found another version dependent ProgId other than our own - bail out
            // 
            fFound = TRUE;

            if (plFoundVersion)
                *plFoundVersion = lVer;

            l = RegCloseKey(hkVersion);
            ASSERT(l == ERROR_SUCCESS, "Failed to close version dependent key");
            goto CleanUp;        
        }
    }    

CleanUp:

    // If we made it this far, then we know for certain whether there were other
    // version dependent progids or not.  Reflect back to the caller there
    // was no general failure that led to us not know whether there were
    // any version dependent ProgIds
    //
    if (pfFailure)
        *pfFailure = FALSE;
    
    l = RegCloseKey(hk);
    ASSERT(l == ERROR_SUCCESS, "Failed closing HKEY_CLASSES_ROOT key");

    return fFound;
}

//=--------------------------------------------------------------------------=
// CopyVersionDependentProgIdToIndependentProgId [RegisterTypeLib helper]
//=--------------------------------------------------------------------------=
// Copies the contents of the version dependent ProgId to a version 
// independent ProgId
//
// Parameters:
//    pszLibName          - [in] lib name portion of ProgId <libname.coclass>
//    pszObjectName       - [in] coclass portion of ProgId  <libname.coclass>
//    lVersion            - [in] Major version number of our component
//
// Output:
//    BOOL                - TRUE:  ProgId was copied successfully
//                          FALSE: ProgId was not copied successfully
//
// Notes:
//
BOOL CopyVersionDependentProgIdToIndependentProgId
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion    
)
{    
    CHECK_POINTER(pszLibName);
    CHECK_POINTER(pszObjectName);
    
    HKEY hkVerDependent, hkVerIndependent;    
    char szTmp[MAX_PATH];
    long l, lTmp;
    BOOL bSuccess;
    DWORD dwDummy;
    
    // Get a handle to the version dependent ProgId
    //
    wsprintf(szTmp, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);  

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, szTmp, 0, KEY_ALL_ACCESS, &hkVerDependent);
    ASSERT(ERROR_SUCCESS == l, "Failed to open the version dependent ProgId");
    if (ERROR_SUCCESS != l)
        return FALSE;

    // Blow away the version independent ProgId
    //
    wsprintf(szTmp, "%s.%s", pszLibName, pszObjectName);
    DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szTmp);

    // Create the initial key for the version independent ProgId
    //
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szTmp, 0, "", REG_OPTION_NON_VOLATILE,
                                                    KEY_READ | KEY_WRITE, NULL, &hkVerIndependent, &dwDummy);
    if (ERROR_SUCCESS != l)
        goto CleanUp;

    // Copy the contents of the version dependent ProgId to the version independent ProgId
    //
    bSuccess = CopyRegistrySection(hkVerDependent, hkVerIndependent);
    l = (bSuccess) ? ERROR_SUCCESS : !ERROR_SUCCESS;

CleanUp:    
    lTmp = RegCloseKey(hkVerDependent);
    ASSERT(ERROR_SUCCESS == lTmp, "Failed to close registry key");

    lTmp = RegCloseKey(hkVerIndependent);
    ASSERT(ERROR_SUCCESS == lTmp, "Failed to close registry key");
    
    return (ERROR_SUCCESS == l) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// CopyRegistrySection
//=--------------------------------------------------------------------------=
// Recursively copies a section of the registry to another section of the
// registry
//
// Parameters:
//      hkSource        - [in]  The source key to copy from
//      hkDest          - [in]  The dest key to copy to
//
// Output:
//    BOOL                - TRUE:  Registry section was copied successfully
//                          FALSE: Registry section was not copied successfully
//
// Notes:
//      - In order for this to work, only the top-level destination key should exist.
//        We assume that there are no sub-keys under the destination key.
//
BOOL CopyRegistrySection(HKEY hkSource, HKEY hkDest)
{
    char szTmp[MAX_PATH];
    long l, lTmp;
    DWORD dwKey, dwDummy, cbData;
    HKEY hkSrcSub, hkDestSub;
    BOOL bSuccess;
    FILETIME ft;
    DWORD dwType;

    // Copy the value of the source key to the destination key
    //
    cbData = sizeof(szTmp);
    l = RegQueryValueEx(hkSource, NULL,  NULL, &dwType, (BYTE *) szTmp, &cbData);

    if (ERROR_SUCCESS != l)
        return FALSE;

    l = RegSetValueEx(hkDest, NULL, NULL, dwType, (const BYTE *) szTmp, cbData);
    if (ERROR_SUCCESS != l)
        return FALSE;

    dwKey = 0;

    // Enumerate through all of the sub-keys underneath the source key
    //
    while (ERROR_SUCCESS == RegEnumKeyEx(hkSource, dwKey, szTmp, &cbData, NULL, NULL, NULL, &ft))
    {
        ASSERT(cbData > 0, "RegEnumKeyEx returned 0 length string");
        
        // Open the registry source sub-key
        //
        l = RegOpenKeyEx(hkSource, szTmp, 0, KEY_ALL_ACCESS, &hkSrcSub);
        
        ASSERT(ERROR_SUCCESS == l, "Failed to open reg key");
        if (ERROR_SUCCESS != l)
            break;

        // Create the registry dest sub-key
        //
        l = RegCreateKeyEx(hkDest, szTmp, 0, "", REG_OPTION_NON_VOLATILE,
                                                    KEY_READ | KEY_WRITE, NULL, &hkDestSub, &dwDummy);
        
        ASSERT(ERROR_SUCCESS == l, "Failed to create reg key");
        if (ERROR_SUCCESS != l)
        {
            lTmp = RegCloseKey(hkSrcSub);
            ASSERT(ERROR_SUCCESS == lTmp, "Failed to close reg key");
            break;
        }

        // Recursively call ourselves copying all sub-entries from the source key to the dest key
        //
        bSuccess = CopyRegistrySection(hkSrcSub, hkDestSub);
        ASSERT(bSuccess, "Recursive call to CopyRegistrySection failed");

        // Cleanup
        //
        lTmp = RegCloseKey(hkSrcSub);
        ASSERT(ERROR_SUCCESS == l, "Failed to close reg key");

        lTmp = RegCloseKey(hkDestSub);
        ASSERT(ERROR_SUCCESS == l, "Failed to close reg key");

        dwKey++;
    }

    return (ERROR_SUCCESS == l ? TRUE : FALSE);
}

//=--------------------------------------------------------------------------=
// GetHelpFilePath [RegisterTypeLib helper]
//=--------------------------------------------------------------------------=
// Returns the path to the Windows\Help directory
//
// Parameters:
//	char * - [in/out] Pointer to buffer that will contain
//		           the HELP path we will return to the caller
//	UINT   - [in] Number of bytes in the buffer
//
// Output:
//	UINT	- Returns the number of bytes actually copied to the buffer
// 
UINT GetHelpFilePath(char *pszPath, UINT cbPath)
{
	UINT cb;
	char szHelp[] = "\\HELP";
	
	ASSERT(pszPath, "Path pointer is NULL");

	// No need to continue if specified buffer size is zero or less
	//
	if (cbPath == 0)
		return 0;

	cb = GetWindowsDirectory(pszPath, cbPath);
	ASSERT(cb > 0, "Windows path is zero length");
	
	// Concatenate "\HELP" onto the Windows directory
	//
	cb += lstrlen(szHelp);
	if (cb < cbPath)
		lstrcat(pszPath, szHelp);
	else
		FAIL("Unable to add HELP path to Windows, buffer too small");

	return cb;		
}

//=--------------------------------------------------------------------------=
// ExistInprocServer [RegisterUnknownObject Helper]
//=--------------------------------------------------------------------------=
// Checks for the Implemented Categories key under a given key
//
// Parameters:
//	riid - [in] CLSID of object to be examined
//
// Output:
//	BOOL	- Returns TRUE if Implemented Categories exists
//		  Returns FALSE if Implemented Categories doesn't exist
//
BOOL ExistImplementedCategories(REFCLSID riid)
{	
	char szGuidStr[MAX_PATH];
	char szScratch[MAX_PATH];
	long l;
	DWORD dwDummy;
	HKEY hkCLSID, hkImplementedCategories;

	if (!StringFromGuidA(riid, szGuidStr)) 
		return FALSE;
	wsprintf(szScratch, "CLSID\\%s", szGuidStr);

	l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ, NULL, &hkCLSID, &dwDummy);
	if (l != ERROR_SUCCESS) return FALSE;	
	
	l = RegOpenKeyEx(hkCLSID, "Implemented Categories", 0, KEY_ALL_ACCESS, &hkImplementedCategories);
	RegCloseKey(hkCLSID);

	if (l != ERROR_SUCCESS) return FALSE;	
	RegCloseKey(hkImplementedCategories);

	// If we made it this far, then the 'Implemented Categories' key must have been found
	//	
	return TRUE;
}

//=--------------------------------------------------------------------------=
// ExistInprocServer [UnregisterUnknownObject Helper]
//=--------------------------------------------------------------------------=
// Checks for other servers such as (16-bit) InProcServer under the
// CLSID section for a given CLSID guid.
//
// Parameters:
//	HKEY	- [in]	HKEY top-level key where to look for the given
//			CLSID
//	char *  - [in]  CLSID of server that we want to see if there
//			is an (16-bit) InProcServer registered.
//
// Output:
//	BOOL	- Returns TRUE if a 16-bit in-proc server is registered
//		  Returns FALSE if no 16-bit in-proc server is registered
//
BOOL ExistInprocServer(HKEY hkCLSID, char *pszCLSID)
{	
	HKEY hkInProcServer;
	LONG l;
	char szInprocServer[MAX_PATH];

	wsprintf(szInprocServer, "%s\\InprocServer", pszCLSID);
	
	// Attempt to open the 16-bit 'InProcServer' key
	//
	l = RegOpenKeyEx(hkCLSID, szInprocServer, 0, KEY_ALL_ACCESS, &hkInProcServer);
	if (l != ERROR_SUCCESS) return FALSE;	
	RegCloseKey(hkInProcServer);

	// If we made it this far, then the 'InProcServer' key must have been found
	//	
	return TRUE;
}

//=--------------------------------------------------------------------------=
// FileExtension
//=--------------------------------------------------------------------------=
// Given a filename returns the file extension without the preceeded period.
//
char *FileExtension(const char *pszFilename)
{
    char *pPeriod;

    ASSERT(pszFilename, "Passed in filename is NULL");

    // Start at the end of the string and work backwards looking for a period
    //
    pPeriod = (char *) pszFilename + lstrlen(pszFilename) - 1;
    while (pPeriod >= pszFilename)
    {
        if (*pPeriod == '.')
            return ++pPeriod;

        pPeriod--;
    }

    // No extension name was found
    //
    return NULL;
}

//=--------------------------------------------------------------------------=
// Conversion Routines
//=--------------------------------------------------------------------------=
// the following stuff is stuff used for the various conversion routines.
//
#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)>>1)) / (ppli) )
#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH )

static  int     s_iXppli;            // Pixels per logical inch along width
static  int     s_iYppli;            // Pixels per logical inch along height
static  BYTE    s_fGotScreenMetrics; // Are above valid?

//=--------------------------------------------------------------------------=
// GetScreenMetrics
//=--------------------------------------------------------------------------=
// private function we call to set up various metrics the conversion routines
// will use.
//
// Notes:
//
static void GetScreenMetrics
(
    void
)
{
    HDC hDCScreen;

    // we have to critical section this in case two threads are converting
    // things at the same time
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    if (s_fGotScreenMetrics)
        goto Done;

    // we want the metrics for the screen
    //
    hDCScreen = GetDC(NULL);

    ASSERT(hDCScreen, "couldn't get a DC for the screen.");
    s_iXppli = GetDeviceCaps(hDCScreen, LOGPIXELSX);
    s_iYppli = GetDeviceCaps(hDCScreen, LOGPIXELSY);

    ReleaseDC(NULL, hDCScreen);
    s_fGotScreenMetrics = TRUE;

    // we're done with our critical seciton.  clean it up
    //
  Done:
    LEAVECRITICALSECTION1(&g_CriticalSection);
}

//=--------------------------------------------------------------------------=
// HiMetricToPixel
//=--------------------------------------------------------------------------=
// converts from himetric to Pixels.
//
// Parameters:
//    const SIZEL *        - [in]  dudes in himetric
//    SIZEL *              - [out] size in pixels.
//
// Notes:
//
void HiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix)
{
    GetScreenMetrics();

    // We got logical HIMETRIC along the display, convert them to pixel units
    //
    lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, s_iXppli);
    lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, s_iYppli);
}

//=--------------------------------------------------------------------------=
// PixelToHiMetric
//=--------------------------------------------------------------------------=
// converts from pixels to himetric.
//
// Parameters:
//    const SIZEL *        - [in]  size in pixels
//    SIZEL *              - [out] size in himetric
//
// Notes:
//
void PixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
    GetScreenMetrics();

    // We got pixel units, convert them to logical HIMETRIC along the display
    //
    lpSizeInHiMetric->cx = MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, s_iXppli);
    lpSizeInHiMetric->cy = MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, s_iYppli);
}

//=--------------------------------------------------------------------------=
// _MakePath
//=--------------------------------------------------------------------------=
// little helper routine for RegisterLocalizedTypeLibs and GetResourceHandle.
// not terrilby efficient or smart, but it's registration code, so we don't
// really care.
//
// Notes:
//
void _MakePath
(
    LPSTR pszFull,
    const char * pszName,
    LPSTR pszOut
)
{
    LPSTR psz;
    LPSTR pszLast;

    lstrcpy(pszOut, pszFull);
    psz = pszLast = pszOut;
    while (*psz) {
        if (*psz == '\\')
            pszLast = AnsiNext(psz);
        psz = AnsiNext(psz);
    }

    // got the last \ character, so just go and replace the name.
    //
    lstrcpy(pszLast, pszName);
}

// from Globals.C
//
extern HINSTANCE    g_hInstResources;

//=--------------------------------------------------------------------------=
// GetResourceHandle
//=--------------------------------------------------------------------------=
// returns the resource handle.  we use the host's ambient Locale ID to
// determine, from a table in the DLL, which satellite DLL to load for
// localized resources.  If a satellite .DLL is not supported or not found
// the instance handle of the object is returned.
//
// Input:
//		lcid = 0 - [in, optional] Locale id that caller wants resource handle for
//				                  This overrides the default lcid.  If no lcid
//								  is provided or its 0, then the default lcid is used.
//
// Output:
//    HINSTANCE
//
// Notes:
//  The localized .DLL must be at the same location as the client object or control.
//  If the .DLL is not in the same location it will not be found and the resource
//  handle of the client object or control will be returned.
//
//  If a localized .DLL containing the full language abbreviation is not found,
//  the language abbreviation is truncated to two characters and the satellite
//  DLL with that name is attempted.  For example, the name MyCtlJPN.DLL and
//  MyCtlJP.DLL are both valid.
//
// If an lcid is passed in then we will attempt to find a satellite DLL matching 
// the desired lcid.  If the lcid is not 0, doesn't match the default lcid and a 
// library is found and loaded for it, we don't cache the library's instance handle.  
// Its up to the caller to call FreeLibrary on the returned handle.  The caller should
// compare the returned handle against g_hInstResources and g_hInstance.  If its not 
// equal to either of these handles then call FreeLibrary on it.  If it is equal to 
// either of these handles then the call must *not* call FreeLibrary on it.
//
HINSTANCE _stdcall GetResourceHandle
(
    LCID lcid /* = 0 */
)
{
    int i;
    char szExtension[5], szModuleName[MAX_PATH];
    char szDllName[MAX_PATH], szFinalName[MAX_PATH];
    char szBaseName[MAX_PATH];
    HINSTANCE hInstResources;
    int iCompare;

#if DEBUG
    int iReCompare;
    char szEnvironValue[MAX_PATH];
    char szMessage[5 * MAX_PATH];		// The message includes 4 file references plus message text
    DWORD dwLength;
    DWORD dwSuccess = 0;
#endif

    // crit sect this so that we don't screw anything up.
    //
    ENTERCRITICALSECTION1(&g_CriticalSection);
    
    // If we fall out, we need to make sure we're returning the cached resource handle
    //
    hInstResources = g_hInstResources;

    // don't do anything if we don't have to
    // If the resource handle has already been cached and the passed in lcid matches the 
    // cached lcid or its the default, we just use the saved instance.
    //
    if ((hInstResources && (lcid == 0 || lcid == g_lcidLocale)) || !g_fSatelliteLocalization)
        goto CleanUp;
    
    if (lcid == 0)
	// Passed in LCID is zero so we want the instance for the default lcid.
	lcid = g_lcidLocale;

    // we're going to call GetLocaleInfo to get the abbreviated name for the
    // LCID we've got.
    //
    i = GetLocaleInfo(lcid, LOCALE_SABBREVLANGNAME, szExtension, sizeof(szExtension));
    if (!i) goto CleanUp;

    // we've got the language extension.  go and load the DLL name from the
    // resources and then tack on the extension.
    // please note that all inproc sers -must- have the string resource 1001
    // defined to the base name of the server if they wish to support satellite
    // localization.
    //
    i = LoadString(g_hInstance, 1001, szBaseName, sizeof(szBaseName));
    ASSERT(i, "This server doesn't have IDS_SERVERBASENAME defined in their resources!");
    if (!i) goto CleanUp;

#ifdef MDAC_BUILD    
    if (g_fSatelliteLangExtension)
#endif
    {
        // got the basename and the extention. go and combine them, and then add
        // on the .DLL for them.
        //
        wsprintf(szDllName, "%s%s.DLL", szBaseName, szExtension);

        // try to load in the DLL
        //
    #if DEBUG
        dwLength = 
    #endif
            GetModuleFileName(g_hInstance, szModuleName, MAX_PATH);

	ASSERT(dwLength > 0, "GetModuleFileName failed");

        _MakePath(szModuleName, szDllName, szFinalName);

        hInstResources = LoadLibrary(szFinalName);

    #if DEBUG

	// This will help diagnose problems where a machine may contain two satellite .DLLs
	// one using the long extension name and the other the short extension name.
	// We'll at least get a warning under DEBUG that we've got two plausible satellite
	// DLLs hanging around, but we're only going to use one of them:  the one with the long name.
	//
	if (hInstResources && lstrlen(szExtension) > 2)
	{
	    HINSTANCE hinstTemp;
	    char szExtTemp[MAX_PATH];

	    // Truncate the language extension to the first two characters
	    lstrcpy(szExtTemp, szExtension);	// Don't want to whack the extension as this will cause
					        // the next if statement to always fail if we truncate it here.
					        // Make a copy and use it.

	    szExtTemp[2] = '\0';
	    wsprintf(szDllName, "%s%s.DLL", szBaseName, szExtTemp);		
	    _MakePath(szModuleName, szDllName, szFinalName);

	    // Try loading the localized .DLL using the truncated lang abbreviation
	    hinstTemp = LoadLibrary(szFinalName);
	    ASSERT(hinstTemp == NULL, "Satellite DLLs with both long and short language abbreviations found.  Using long abbreviation.");
	}

    #endif	 // DEBUG

        if (!hInstResources && lstrlen(szExtension) > 2)
        {
	    // Truncate the language extension to the first two characters
	    szExtension[2] = '\0';	
	    wsprintf(szDllName, "%s%s.DLL", szBaseName, szExtension);		
	       _MakePath(szModuleName, szDllName, szFinalName);

	    // Try loading the localized .DLL using the truncated lang abbreviation
	    hInstResources = LoadLibrary(szFinalName);
        }

        // if we couldn't find it with the entire LCID, try it with just the primary
        // langid
        //
        if (!hInstResources) 
        {
            LPSTR psz;
            LCID lcid;
            lcid = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(g_lcidLocale)), SUBLANG_DEFAULT), SORT_DEFAULT);
            i = GetLocaleInfo(lcid, LOCALE_SABBREVLANGNAME, szExtension, sizeof(szExtension));
            if (!i) goto CleanUp;

            // reconstruct the DLL name.  the -7 is the length of XXX.DLL. mildly
            // hacky, but it should be fine.  there are no DBCS lang identifiers.
            // finally, retry the load
            //
            psz = szFinalName + lstrlen(szFinalName);
            memcpy((LPBYTE)psz - 7, szExtension, 3);
            hInstResources = LoadLibrary(szFinalName);
        }

        //try under the <base path>\LCID\<sxBaseName.dll>
        if (!hInstResources)
        {

          wsprintf(szDllName, "%u\\%s.dll", lcid, szBaseName);		
          _MakePath(szModuleName, szDllName, szFinalName);
          hInstResources = LoadLibrary(szFinalName);         
        }
    }

#ifdef MDAC_BUILD

    else
    {        
        char *psz;

        GetModuleFileName(g_hInstance, szModuleName, MAX_PATH);
        psz = strrchr(szModuleName, '\\');
        *psz = NULL;

        // szModuleName should now contain the path for the DLL
        // now concatenate the resource location
        strcat(szModuleName, "\\resources\\");
        wsprintf(szDllName, "%s%d", szModuleName, lcid);
        strcat(szDllName, "\\");
        strcat(szDllName, szBaseName);
        strcat(szDllName, ".DLL");

        // try to load in the DLL
        //
        hInstResources = LoadLibrary(szDllName);    
    }

#endif

  CleanUp:

    // if we couldn't load the DLL for some reason, then just return the
    // current resource handle, which is good enough.
    //
    if (!hInstResources) 
	hInstResources = g_hInstance;

    if (!g_hInstResources && (lcid == 0 || lcid == g_lcidLocale))
	// We only cache the instance handle for the default LCID.
	// For all other passed in lcid values we will LoadLibrary on the satellite DLL each time.
	// Its recommended that the calling app cache the returned instance handle for the given
	// lcid passed in.
	//
	g_hInstResources = hInstResources;

    ASSERT(hInstResources, "Resource handle is NULL");

    // =-------------------------------------------------------------------
    // Satellite .DLL version check
    // =-------------------------------------------------------------------
    // The satellite .DLL version must exactly match the version of the
    // 
    if ((!g_bDllVerChecked) || 
	    (lcid != g_lcidLocale && lcid != 0))
    {	
	    // If we're using a satellite .DLL 
	    // (hInstResources != g_hInstance), do a version check.
	    // 
	    // If the passed in lcid is different than what we've cached and we're
	    // using a satellite .DLL, do the version check.
	    //

	    // Make sure we have a satellite .DLL
	    //
	    if (hInstResources != g_hInstance) 								
	    {
	    #if DEBUG
		    dwLength = 
	    #endif
			    GetModuleFileName(hInstResources, szFinalName, MAX_PATH);

		    ASSERT(dwLength > 0, "GetModuleFileName failed");

		    iCompare = CompareDllVersion(szFinalName, TRUE);
		    
	    #if DEBUG

		    if (VERSION_LESS_THAN == iCompare)
		    {
			    wsprintf(szMessage, "Major version compare: VERSION resource info in %s is less than VERSION info in %s. Non-localized resources will be used.  In order to see localized resources, you need to obtain a version of %s that matches %s.", szFinalName, szModuleName, szFinalName, szModuleName);
			    DisplayAssert(szMessage, "", _szThisFile, __LINE__);
		    }
		    else if (VERSION_GREATER_THAN == iCompare)
		    {
			    wsprintf(szMessage, "Major version compare: VERSION resource info in %s is greater than VERSION info in %s. Non-localized resources will be used.  In order to see localized resources, you need to obtain a version of %s that matches %s.", szFinalName, szModuleName, szFinalName, szModuleName);
			    DisplayAssert(szMessage, "", _szThisFile, __LINE__);
		    }
		    else if (VERSION_EQUAL == iCompare)
		    {

			    // Vegas #29024: Only enable full version assert if environment variable is set.
			    //
			    dwSuccess = GetEnvironmentVariable("INTL_VERSION_COMPARE", szEnvironValue,  MAX_PATH);

			    if (dwSuccess > 0)
			    {
				    // Re-do the comparison using a full-version compare
				    //
				    // Note: Don't use iCompare here otherwise DEBUG builds will default to non-localized resources
				    //		 when major version comparison succeeds, but full version compare fails.  				
				    //
				    iReCompare = CompareDllVersion(szFinalName, FALSE);

				    if (VERSION_LESS_THAN == iReCompare)
				    {
					    wsprintf(szMessage, "Warning: Full version compare: VERSION resource info in %s is less than VERSION info in %s. Localized resources will continue to be used, but may not be in sync.", szFinalName, szModuleName);
					    DisplayAssert(szMessage, "", _szThisFile, __LINE__);
				    }
				    else if (VERSION_GREATER_THAN == iReCompare)
				    {
					    wsprintf(szMessage, "Warning: Full version compare: VERSION resource info in %s is greater than VERSION info in %s. Localized resources will continue to be used, but may not be in sync.", szFinalName, szModuleName);
					    DisplayAssert(szMessage, "", _szThisFile, __LINE__);
				    }
			    }

		    }

	    #endif

		    // If CompareDllVersion ever returns NOT_EQUAL it means it didn't get far enough
		    // to figure out if the version was less than or greater than.  It must have failed.
		    //
		    // Note: In this case, we go ahead and use the satellite .DLL anyway.  It may be that
		    //	     the satellite .DLL doesn't contain VERSION info.
		    //
		    ASSERT(VERSION_NOT_EQUAL != iCompare, "Failure attempting to compare satellite .DLL version");
		    if (VERSION_LESS_THAN == iCompare || VERSION_GREATER_THAN == iCompare)
		    {
			    // If the check fails, return the instance of ourself, not the
			    // satellite .DLL.  Resources will be displayed in English.
			    //
			    hInstResources = g_hInstance;

			    if (lcid == 0 || lcid == g_lcidLocale)
			    {
				    g_hInstResources = g_hInstance;				
			    }
		    }

	    }

	    if (lcid == 0 || lcid == g_lcidLocale)
		    g_bDllVerChecked = TRUE;
    }

    LEAVECRITICALSECTION1(&g_CriticalSection);

    return hInstResources;
}

//=--------------------------------------------------------------------------=
// CompareDllVersion
//=--------------------------------------------------------------------------=
// Given a pointer to an external filename, compare the version info in the
// file with the version info in our own binary (.DLL or .OCX).
//
// Parameters:
//
// Returns: S_OK if type flags are successfully found, otherwise an error code
//
VERSIONRESULT _stdcall CompareDllVersion(const char * pszFilename, BOOL bCompareMajorVerOnly)
{	
	// Default to not equal.  The only time we're not equal is if something failed.
	//
	VERSIONRESULT vrResult = VERSION_NOT_EQUAL;
	
	BOOL bResult;	
	VS_FIXEDFILEINFO ffiMe, ffiDll;
	char szModuleName[MAX_PATH];
	WORD wMajorVerMe;
	WORD wMajorVerDll;

	DWORD dwLength;

	// Get VERSION info for our own .DLL/.OCX (aka Me)
	//
	ASSERT(g_hInstance, "hInstance is NULL");
	dwLength = GetModuleFileName(g_hInstance, szModuleName, MAX_PATH);
	ASSERT(dwLength > 0, "GetModuleFilename failed");

	if (0 == dwLength)
		goto CleanUp;

	// Make sure we're not comparing the same file
	//
	ASSERT(0 != lstrcmpi(szModuleName, pszFilename), "The same file is being compared");

	bResult = GetVerInfo(szModuleName, &ffiMe);
	ASSERT(bResult, "GetVerInfo failed");	
	if (!bResult)
		goto CleanUp;

	ASSERT(0xFEEF04BD == ffiMe.dwSignature, "Bad VS_FIXEDFILEINFO signature for Me");

	// Get version info for the passed in .DLL name
	//
	bResult = GetVerInfo(pszFilename, &ffiDll);
	ASSERT(bResult, "GetVerInfo failed");	
	if (!bResult)
		goto CleanUp;

	ASSERT(0xFEEF04BD == ffiDll.dwSignature, "Bad VS_FIXEDFILEINFO signature for Me");
	
	if (bCompareMajorVerOnly)
	{
		// Major version compare
		//
		wMajorVerMe = HIWORD(ffiMe.dwFileVersionMS);
		wMajorVerDll = HIWORD(ffiDll.dwFileVersionMS);

		if (wMajorVerMe == wMajorVerDll)
			return VERSION_EQUAL;
		else if (wMajorVerMe > wMajorVerDll)
			return VERSION_LESS_THAN;
		else
			return VERSION_GREATER_THAN;

	}
	else	
	{	
		// Full version compare
		//
		// Compare the version with our build version set by constants in DWINVERS.H
		//
		if (ffiMe.dwFileVersionMS == ffiDll.dwFileVersionMS &&
			ffiMe.dwFileVersionLS == ffiDll.dwFileVersionLS)
		{
			vrResult = VERSION_EQUAL;
		}
		else if (ffiMe.dwFileVersionMS == ffiDll.dwFileVersionMS)
		{
			if (ffiMe.dwFileVersionLS > ffiDll.dwFileVersionLS)
					vrResult = VERSION_LESS_THAN;
			else
					vrResult = VERSION_GREATER_THAN;
		}
		else if (ffiMe.dwFileVersionMS < ffiDll.dwFileVersionMS)
		{
			vrResult = VERSION_LESS_THAN;
		}
		else
		{
			vrResult = VERSION_GREATER_THAN;
		}

	}

CleanUp:
	return vrResult;

}

//=--------------------------------------------------------------------------=
// GetVerInfo
//=--------------------------------------------------------------------------=
// Returns the VERSION resource fixed file info struct for a given file.
//
// Parameters:
//		pszFilename	- [in]		Filename to return version info for
//		pffi		- [out]		Version info
//
BOOL _stdcall GetVerInfo(const char * pszFilename, VS_FIXEDFILEINFO *pffi)
{	
	DWORD dwHandle = 0;
	DWORD dwVersionSize = 0;
	UINT uiLength = 0;
	VS_FIXEDFILEINFO * pffiTemp;

#if DEBUG
	DWORD dwGetLastError;
#endif

	BYTE *pVersionInfo = NULL;
	BOOL bResult = FALSE;

	memset(pffi, 0, sizeof(VS_FIXEDFILEINFO));
	
	dwVersionSize = CallGetFileVersionInfoSize((char *) pszFilename, &dwHandle);

#if DEBUG
	dwGetLastError = GetLastError();
#endif

	ASSERT(dwVersionSize > 0, "GetFileVersionInfoSize failed");

	if (0 == dwVersionSize)
		goto CleanUp;

	pVersionInfo = (BYTE *) HeapAlloc(g_hHeap, 0, dwVersionSize);
	ASSERT(pVersionInfo, "pVersionInfo is NULL");
	if (NULL == pVersionInfo)
		goto CleanUp;

	bResult = CallGetFileVersionInfo((char *) pszFilename, dwHandle, dwVersionSize, pVersionInfo);
	ASSERT(bResult, "GetFileVersionInfo failed");
	if (!bResult)
		goto CleanUp;

	bResult = CallVerQueryValue(pVersionInfo, "\\", (void **) &pffiTemp, &uiLength);
	ASSERT(bResult, "VerQueryValue failed");
	
	if (!bResult)
		goto CleanUp;

	ASSERT(sizeof(VS_FIXEDFILEINFO) == uiLength, "Returned length is invalid");
	memcpy(pffi, pffiTemp, uiLength);

CleanUp:

	if (pVersionInfo)
		HeapFree(g_hHeap, 0, pVersionInfo);

	return bResult;
}

//=--------------------------------------------------------------------------=
// CallGetFileVersionInfoSize [VERSION.DLL API wrapper]
//=--------------------------------------------------------------------------=
// This does a dynamic call to the GetFileVersionInfoSize API function.  If
// VERSION.DLL isn't loaded, then this function loads it.
//
BOOL CallGetFileVersionInfoSize
(
	LPTSTR lptstrFilename, 
	LPDWORD lpdwHandle
)
{
	EnterCriticalSection(&g_CriticalSection);

	// One-time setup of VERSION.DLL and function pointer
	//
	if (!g_pGetFileVersionInfoSize)
	{
		if (!g_hinstVersion)
		{
			g_hinstVersion = LoadLibrary(DLL_VERSION);
			ASSERT(g_hinstVersion, "Failed to load VERSION.DLL");
			if (!g_hinstVersion)
				return FALSE;
		}
			
		g_pGetFileVersionInfoSize = (PGETFILEVERSIONINFOSIZE) GetProcAddress(g_hinstVersion, FUNC_GETFILEVERSIONINFOSIZE);
		ASSERT(g_pGetFileVersionInfoSize, "Failed to get proc address for GetFileVersionInfoSize");
		if (!g_pGetFileVersionInfoSize)
			return FALSE;
	}
		
	LeaveCriticalSection(&g_CriticalSection);

	// Call GetFileVersionInfoSize
	//
	return g_pGetFileVersionInfoSize(lptstrFilename, lpdwHandle);	
}


//=--------------------------------------------------------------------------=
// CallGetFileVersionInfo [VERSION.DLL API wrapper]
//=--------------------------------------------------------------------------=
// This does a dynamic call to the GetFileVersionInfo API function.  If
// VERSION.DLL isn't loaded, then this function loads it.
//
BOOL CallGetFileVersionInfo
(
	LPTSTR lpststrFilename, 
	DWORD dwHandle, 
	DWORD dwLen, 
	LPVOID lpData	
)
{
	EnterCriticalSection(&g_CriticalSection);

	// One-time setup of VERSION.DLL and function pointer
	//
	if (!g_pGetFileVersionInfo)
	{
		if (!g_hinstVersion)
		{
			g_hinstVersion = LoadLibrary(DLL_VERSION);
			ASSERT(g_hinstVersion, "Failed to load VERSION.DLL");
			if (!g_hinstVersion)
				return FALSE;
		}
			
		g_pGetFileVersionInfo = (PGETFILEVERSIONINFO) GetProcAddress(g_hinstVersion, FUNC_GETFILEVERSIONINFO);
		ASSERT(g_pGetFileVersionInfo, "Failed to get proc address for GetFileVersionInfo");
		if (!g_pGetFileVersionInfo)
			return FALSE;
	}
		
	LeaveCriticalSection(&g_CriticalSection);

	// Call GetFileVersionInfo
	//
	return g_pGetFileVersionInfo(lpststrFilename, dwHandle, dwLen, lpData);	
}


//=--------------------------------------------------------------------------=
// CallVerQueryValue [VERSION.DLL API wrapper]
//=--------------------------------------------------------------------------=
// This does a dynamic call to the VerQueryValue API function.  If
// VERSION.DLL isn't loaded, then this function loads it.
//
BOOL CallVerQueryValue
(
	const LPVOID pBlock,
	LPTSTR lpSubBlock,
	LPVOID *lplpBuffer,
	PUINT puLen
)
{
	EnterCriticalSection(&g_CriticalSection);

	// One-time setup of VERSION.DLL and function pointer
	//
	if (!g_pVerQueryValue)
	{
		if (!g_hinstVersion)
		{
			g_hinstVersion = LoadLibrary(DLL_VERSION);
			ASSERT(g_hinstVersion, "Failed to load VERSION.DLL");
			if (!g_hinstVersion)
				return FALSE;
		}
			
		g_pVerQueryValue = (PVERQUERYVALUE) GetProcAddress(g_hinstVersion, FUNC_VERQUERYVALUE);
		ASSERT(g_pVerQueryValue, "Failed to get proc address for VerQueryValue");
		if (!g_pVerQueryValue)
			return FALSE;
	}
		
	LeaveCriticalSection(&g_CriticalSection);

	// Call VerQueryValue
	//
	return g_pVerQueryValue(pBlock, lpSubBlock, lplpBuffer, puLen);
}

//=--------------------------------------------------------------------------=
// GetTypeInfoFlagsForGuid
//=--------------------------------------------------------------------------=
// Given a pointer to a TypeLib and a TypeInfo guid, returns the TYPEFLAGS
// associated with the TypeInfo
//
// Parameters:
//		pTypeLib -		[in]  Pointer of TypeLib to find typeinfo type flags
//		guidTypeInfo - 	[in]  Guid of TypeInfo we're looking for
//		pwFlags -       [out] TYPEFLAGS associated with the typeinfo
//
// Returns: S_OK if type flags are successfully found, otherwise an error code
//
HRESULT GetTypeFlagsForGuid(ITypeLib *pTypeLib, REFGUID guidTypeInfo, WORD *pwFlags)
{
	ITypeInfo *pTypeInfo;
	TYPEATTR *pTypeAttr;
	HRESULT hr;

	if (!pTypeLib || !pwFlags)
		return E_POINTER;

	*pwFlags = 0;

	// Search for the given guid in the TypeLib
	//
	hr = pTypeLib->GetTypeInfoOfGuid(guidTypeInfo, &pTypeInfo);		

	if (SUCCEEDED(hr))
	{
		// Get the type attributes for the found TypeInfo
		//
		hr = pTypeInfo->GetTypeAttr(&pTypeAttr);
		ASSERT(SUCCEEDED(hr), "Failed to get ctl TypeInfo TypeAttr");

		if (SUCCEEDED(hr))
		{
			// Return TYPEFLAGS
			//
			*pwFlags = pTypeAttr->wTypeFlags;
			pTypeInfo->ReleaseTypeAttr(pTypeAttr);
		}

		pTypeInfo->Release();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\strcoll.cpp ===
//=--------------------------------------------------------------------------=
// StringsColl.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation for our simple strings collections.
//
#include "pch.h"

#include "SimpleEnumVar.H"
#include "StringsColl.H"


// for asserts
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// CStringsCollection::CStringsCollection
//=--------------------------------------------------------------------------=
// constructor. sets up the safearray pointer.
//
// Parameters:
//    SAFEARRAY        - [in] the collection we're working with.
//
// Notes:
//
CStringCollection::CStringCollection
(
    SAFEARRAY *psa
)
: m_psa(psa)
{
    ASSERT(m_psa, "Bogus Safearray pointer!");
}

//=--------------------------------------------------------------------------=
// CStringCollection::~CStringCollection
//=--------------------------------------------------------------------------=
//
// Notes:
//
CStringCollection::~CStringCollection()
{
}

//=--------------------------------------------------------------------------=
// CStringCollection::get_Count
//=--------------------------------------------------------------------------=
// returns the count of the things in the collection
//
// Parameters:
//    long *         - [out] the count
//
// Output:
//    HRESULT        - S_OK, one of the SAFEARRAY Scodes.
//
// Notes:
//    - we're assuming the safearray's lower bound is zero!
//
STDMETHODIMP CStringCollection::get_Count
(
    long *plCount
)
{
    HRESULT hr;

    ASSERT(m_psa, "Who created a collection without a SAFEARRAY?");

    CHECK_POINTER(plCount);

    // get the bounds.
    //
    hr = SafeArrayGetUBound(m_psa, 1, plCount);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // add one since we're zero-offset
    //
    (*plCount)++;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringCollection::get_Item
//=--------------------------------------------------------------------------=
// returns a string given an INDEX
//
// Parameters:
//    long          - [in]  the index to get it from
//    BSTR *        - [out] the item
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStringCollection::get_Item
(
    long  lIndex,
    BSTR *pbstrItem
)
{
    HRESULT hr;

    CHECK_POINTER(pbstrItem);

    // get the element from the safearray
    //
    hr = SafeArrayGetElement(m_psa, &lIndex, pbstrItem);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // otherwise, we've got it, so we can return
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringCollection::get__NewEnum
//=--------------------------------------------------------------------------=
// returns a new IEnumVARIANT object with the collection in it.
//
// Parameters:
//    IUnknown     **    - [out] new enumvariant object.
//
// Output:
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStringCollection::get__NewEnum
(
    IUnknown **ppUnkNewEnum
)
{
    HRESULT hr;
    long    l;

    CHECK_POINTER(ppUnkNewEnum);

    // get the count of things in the SAFEARRAY
    //
    hr = get_Count(&l);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // create the object.
    //
    *ppUnkNewEnum = (IUnknown *) new CSimpleEnumVariant(m_psa, l);
    if (!*ppUnkNewEnum)
        CLEARERRORINFORET(E_OUTOFMEMORY);

    // refcount is already 1, so we can leave.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// CStringDynaCollection::CStringDynaCollection
//=--------------------------------------------------------------------------=
// constructor for this object.  doesn't do very much.
//
// Parameters:
//    same as for CStringCollection
//
// Notes:
//
CStringDynaCollection::CStringDynaCollection
(
    SAFEARRAY *psa
)
: CStringCollection(psa)
{
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::~CStringDynaCollection
//=--------------------------------------------------------------------------=
// destructor.
//
// Notes:
//
CStringDynaCollection::~CStringDynaCollection()
{
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::put_Item
//=--------------------------------------------------------------------------=
// sets the value of an item in the array.
//
// Parameters:
//    long         - [in] index at which to put it
//    BSTR         - [in] new value.
//
// Output:
//    HRESULT      - S_OK, safearray Scode.
//
// Notes:
//    - NULLs are converted to ""
//
STDMETHODIMP CStringDynaCollection::put_Item
(
    long lIndex,
    BSTR bstr
)
{
    HRESULT hr;
    long l;
    BSTR bstr2 = NULL;

    // get the count and verify our index
    //
    hr = get_Count(&l);
    RETURN_ON_FAILURE(hr);
    if (lIndex < 0 || lIndex >= l)
        CLEARERRORINFORET(E_INVALIDARG);
    
    // put out the string, convert NULLs to ""
    //
    if (!bstr) {
        bstr2 = SysAllocString(L"");
        RETURN_ON_NULLALLOC(bstr2);
    }

    hr = SafeArrayPutElement(m_psa, &lIndex, (bstr) ? bstr : bstr2);
    if (bstr2) SysFreeString(bstr2);
    CLEARERRORINFORET_ON_FAILURE(hr);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::Add
//=--------------------------------------------------------------------------=
// adds a new string to the end of the collection.
//
// Parameters:
//    BSTR         - [in] the new string to add
//
// Notes:
//
STDMETHODIMP CStringDynaCollection::Add
(
    BSTR bstr
)
{
    SAFEARRAYBOUND sab;
    BSTR    bstr2 = NULL;
    HRESULT hr;
    long    l;

    // get the current size of the array.
    //
    hr = get_Count(&l);
    RETURN_ON_FAILURE(hr);

    // add one new elemnt
    //
    sab.cElements = l + 1;
    sab.lLbound = 0;

    // redim the array.
    //
    hr = SafeArrayRedim(m_psa, &sab);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // put the out string, converting NULLs to ""
    //
    if (!bstr) {
        bstr2 = SysAllocString(L"");
        RETURN_ON_NULLALLOC(bstr2);
    }

    hr = SafeArrayPutElement(m_psa, &l, (bstr) ? bstr : bstr2);
    if (bstr2) SysFreeString(bstr2);
    CLEARERRORINFORET_ON_FAILURE(hr);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::Remove
//=--------------------------------------------------------------------------=
// removes an element from the collection, and shuffles all the rest down to
// fill up the space.
//
// Parameters:
//    long         - [in] index of dude to remove.
//
// Output:
//    HRESULT      - S_OK, safearray Scodes.
//
// Notes:
//
STDMETHODIMP CStringDynaCollection::Remove
(
    long lIndex
)
{
    SAFEARRAYBOUND sab;
    HRESULT hr;
    BSTR    bstr;
    long    lCount;
    long    x, y;

    // first get the count of things in our array.
    //
    hr = get_Count(&lCount);
    RETURN_ON_FAILURE(hr);

    // check the index
    //
    if (lIndex < 0 || lIndex >= lCount)
        CLEARERRORINFORET(E_INVALIDARG);

    // let's go through, shuffling everything down one.
    //
    for (x = lIndex, y = x + 1; x < lCount - 1; x++, y++) {
        // get the next element.
        //
        hr = SafeArrayGetElement(m_psa, &y, &bstr);
        CLEARERRORINFORET_ON_FAILURE(hr);

        // set it at the current location
        //
        hr = SafeArrayPutElement(m_psa, &x, bstr);
        CLEARERRORINFORET_ON_FAILURE(hr);
    }

    // we're at the last element.  let's go and kill it.
    //
    sab.cElements = lCount - 1;
    sab.lLbound = 0;

    // CONSIDER: 9.95 -- there is a bug in oleaut32.dll which causes the
    //         below to fail if cElements = 0.
    //
    hr = SafeArrayRedim(m_psa, &sab);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // we're done.  go bye-bye.
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\framewrk\vshelp.cpp ===
//=--------------------------------------------------------------------------=
// HtmlHlp.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains routines that we will find useful.
//
#include "pch.h"
#include "VsHelp.h"

SZTHISFILE

#ifdef VS_HELP

IVsHelpSystem *g_pIVsHelpSystem = NULL;

//=--------------------------------------------------------------------------=
// QueryStartupVisualStudioHelp [HtmlHelp helper]
//=--------------------------------------------------------------------------=
// Starts up Visual Studio help system 
//
HRESULT QueryStartupVisualStudioHelp(IVsHelpSystem **ppIVsHelpSystem)
{    
 
    CHECK_POINTER(ppIVsHelpSystem);
    
    HRESULT hr = S_OK;    
    IVsHelpInit *pIVSHelpInit = NULL;

    ENTERCRITICALSECTION1(&g_CriticalSection);

    // Check to see if we're already started.  If so, no need to continue
    //
    if (g_pIVsHelpSystem)
    {
        goto CleanUp;
    }    

    // Create an instance of the VsHelpServices package, if not already created
    //
    hr = ::CoCreateInstance(CLSID_VsHelpServices,
                            NULL, 
                            CLSCTX_INPROC_SERVER,
                            IID_IVsHelpSystem,
                            (void**) &g_pIVsHelpSystem) ; 

    if (FAILED(hr))
    {
        goto CleanUp;
    }

    ASSERT(g_pIVsHelpSystem, "g_pIVsHelpSystem is NULL even though hr was successful");
    if (!g_pIVsHelpSystem)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    //--- Initialize the help system.

    // Get the init interface pointer.
    //
    hr = g_pIVsHelpSystem->QueryInterface(IID_IVsHelpInit, (void**)&pIVSHelpInit);
    ASSERT(SUCCEEDED(hr), "QI to IVSHelpInit failed -- continuing anyway");
  
    if (SUCCEEDED(hr))
    {
        hr = pIVSHelpInit->LoadUIResources(g_lcidLocale);
        ASSERT(SUCCEEDED(hr), "LoadUIResources() failed (this will happen if you haven't run MSDN setup) -- continuing anyway");
    }

    hr = S_OK;

CleanUp:

    LEAVECRITICALSECTION1(&g_CriticalSection);

    QUICK_RELEASE(pIVSHelpInit);

    if (SUCCEEDED(hr))
    {
        g_pIVsHelpSystem->AddRef();
        *ppIVsHelpSystem = g_pIVsHelpSystem;
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// VisualStudioShowHelpTopic [HtmlHelp helper]
//=--------------------------------------------------------------------------=
// Displays the help topic in Visual Studio's help window
//
HRESULT VisualStudioShowHelpTopic(const char *pszHelpFile, DWORD dwContextId, BOOL *pbHelpStarted)
{
    HRESULT hr;
    IVsHelpSystem* pIVsHelpSystem = NULL;
    BSTR bstrHelpFile;

    // Hand back help started to signify that we were able to start the help 
    // system.  This is useful since the controls have no clue as to what 
    // environment they are running under Visual Studio might not be around 
    // in which case the control will call HtmlHelp directly.
    //
    if (pbHelpStarted)
        *pbHelpStarted = FALSE;

    hr = QueryStartupVisualStudioHelp(&pIVsHelpSystem);
    if (FAILED(hr))    
        return hr;

    ASSERT(pIVsHelpSystem, "QI succeeded but return value is NULL");

    hr = pIVsHelpSystem->ActivateHelpSystem(0);
    ASSERT(SUCCEEDED(hr), "Failed to activate the help system");
    if (FAILED(hr))
        goto CleanUp;
    
    // With the help system successfully activated, signify to the caller 
    // that the Visual Studio help mechanism should work
    //
    if (pbHelpStarted)
        *pbHelpStarted = TRUE;
    
    bstrHelpFile = BSTRFROMANSI(pszHelpFile);
    ASSERT(bstrHelpFile, "Out of memory allocating BSTR");

    hr = pIVsHelpSystem->DisplayTopicFromIdentifier(bstrHelpFile, dwContextId, VHS_Localize);
    SysFreeString(bstrHelpFile);

    ASSERT(SUCCEEDED(hr), "Failed to display help topic");
    if (FAILED(hr))
        goto CleanUp;

CleanUp:
    QUICK_RELEASE(pIVsHelpSystem);

    return hr;   
}

#endif // VS_HELP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\asp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.15 */
/* at Wed Mar 12 14:39:56 1997
 */
/* Compiler settings for asp.idl:
    Os, W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __asp_h__
#define __asp_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ASPTypeLibrary_LIBRARY_DEFINED__
#define __ASPTypeLibrary_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ASPTypeLibrary
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_ASPTypeLibrary;

#ifndef __IStringList_INTERFACE_DEFINED__
#define __IStringList_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStringList
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][helpstring][uuid] */ 



EXTERN_C const IID IID_IStringList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IStringList : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT i,
            /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStringListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStringList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStringList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStringList __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStringList __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStringList __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Item )( 
            IStringList __RPC_FAR * This,
            /* [in] */ VARIANT i,
            /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Count )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get__NewEnum )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IStringListVtbl;

    interface IStringList
    {
        CONST_VTBL struct IStringListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStringList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStringList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStringList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStringList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStringList_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IStringList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IStringList_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IStringList_get_Item(This,i,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,i,pVariantReturn)

#define IStringList_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IStringList_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT __stdcall IStringList_get_Item_Proxy( 
    IStringList __RPC_FAR * This,
    /* [in] */ VARIANT i,
    /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IStringList_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IStringList_get_Count_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IStringList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][propget][id] */ HRESULT __stdcall IStringList_get__NewEnum_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IStringList_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStringList_INTERFACE_DEFINED__ */


#ifndef __IRequestDictionary_INTERFACE_DEFINED__
#define __IRequestDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequestDictionary
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][helpstring][uuid] */ 



EXTERN_C const IID IID_IRequestDictionary;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRequestDictionary : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Var,
            /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequestDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequestDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequestDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Item )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ VARIANT Var,
            /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [restricted][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get__NewEnum )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IRequestDictionaryVtbl;

    interface IRequestDictionary
    {
        CONST_VTBL struct IRequestDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequestDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequestDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequestDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequestDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequestDictionary_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IRequestDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IRequestDictionary_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IRequestDictionary_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IRequestDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT __stdcall IRequestDictionary_get_Item_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in] */ VARIANT Var,
    /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IRequestDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][propget][id] */ HRESULT __stdcall IRequestDictionary_get__NewEnum_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IRequestDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequestDictionary_INTERFACE_DEFINED__ */


#ifndef __IRequest_INTERFACE_DEFINED__
#define __IRequest_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequest
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][uuid] */ 



EXTERN_C const IID IID_IRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRequest : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_QueryString( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Form( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT __stdcall get_Body( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_ServerVariables( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_ClientCertificate( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequest __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequest __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Item )( 
            IRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_QueryString )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Form )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [hidden][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Body )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_ServerVariables )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_ClientCertificate )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Cookies )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        END_INTERFACE
    } IRequestVtbl;

    interface IRequest
    {
        CONST_VTBL struct IRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequest_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IRequest_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IRequest_get_Item(This,bstrVar,ppObjReturn)	\
    (This)->lpVtbl -> get_Item(This,bstrVar,ppObjReturn)

#define IRequest_get_QueryString(This,ppDictReturn)	\
    (This)->lpVtbl -> get_QueryString(This,ppDictReturn)

#define IRequest_get_Form(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Form(This,ppDictReturn)

#define IRequest_get_Body(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Body(This,ppDictReturn)

#define IRequest_get_ServerVariables(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ServerVariables(This,ppDictReturn)

#define IRequest_get_ClientCertificate(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ClientCertificate(This,ppDictReturn)

#define IRequest_get_Cookies(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Cookies(This,ppDictReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT __stdcall IRequest_get_Item_Proxy( 
    IRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrVar,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);


void __RPC_STUB IRequest_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IRequest_get_QueryString_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_QueryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IRequest_get_Form_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Form_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget][id] */ HRESULT __stdcall IRequest_get_Body_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IRequest_get_ServerVariables_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ServerVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IRequest_get_ClientCertificate_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ClientCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IRequest_get_Cookies_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequest_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Request;

class Request;
#endif

#ifndef __IReadCookie_INTERFACE_DEFINED__
#define __IReadCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReadCookie
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][helpstring][uuid] */ 



EXTERN_C const IID IID_IReadCookie;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IReadCookie : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Var,
            /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_HasKeys( 
            /* [retval][out] */ boolean __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReadCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReadCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReadCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReadCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Item )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ VARIANT Var,
            /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_HasKeys )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pfHasKeys);
        
        /* [restricted][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get__NewEnum )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IReadCookieVtbl;

    interface IReadCookie
    {
        CONST_VTBL struct IReadCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReadCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReadCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReadCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReadCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReadCookie_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IReadCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IReadCookie_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IReadCookie_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IReadCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IReadCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT __stdcall IReadCookie_get_Item_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in] */ VARIANT Var,
    /* [optional][retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IReadCookie_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IReadCookie_get_HasKeys_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pfHasKeys);


void __RPC_STUB IReadCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][propget][id] */ HRESULT __stdcall IReadCookie_get__NewEnum_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IReadCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReadCookie_INTERFACE_DEFINED__ */


#ifndef __IWriteCookie_INTERFACE_DEFINED__
#define __IWriteCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWriteCookie
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][helpstring][uuid] */ 



EXTERN_C const IID IID_IWriteCookie;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IWriteCookie : public IDispatch
    {
    public:
        virtual /* [propput][id] */ HRESULT __stdcall put_Item( 
            /* [in] */ VARIANT key,
            /* [in] */ BSTR rhs) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Expires( 
            /* [in] */ DATE rhs) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Domain( 
            /* [in] */ BSTR rhs) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Path( 
            /* [in] */ BSTR rhs) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Secure( 
            /* [in] */ boolean rhs) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_HasKeys( 
            /* [retval][out] */ boolean __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWriteCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWriteCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWriteCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWriteCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Item )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ VARIANT key,
            /* [in] */ BSTR rhs);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Expires )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DATE rhs);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Domain )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR rhs);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Path )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR rhs);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Secure )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ boolean rhs);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_HasKeys )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pfHasKeys);
        
        /* [restricted][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get__NewEnum )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IWriteCookieVtbl;

    interface IWriteCookie
    {
        CONST_VTBL struct IWriteCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWriteCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWriteCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWriteCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWriteCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWriteCookie_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IWriteCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IWriteCookie_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IWriteCookie_put_Item(This,key,rhs)	\
    (This)->lpVtbl -> put_Item(This,key,rhs)

#define IWriteCookie_put_Expires(This,rhs)	\
    (This)->lpVtbl -> put_Expires(This,rhs)

#define IWriteCookie_put_Domain(This,rhs)	\
    (This)->lpVtbl -> put_Domain(This,rhs)

#define IWriteCookie_put_Path(This,rhs)	\
    (This)->lpVtbl -> put_Path(This,rhs)

#define IWriteCookie_put_Secure(This,rhs)	\
    (This)->lpVtbl -> put_Secure(This,rhs)

#define IWriteCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IWriteCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propput][id] */ HRESULT __stdcall IWriteCookie_put_Item_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ VARIANT key,
    /* [in] */ BSTR rhs);


void __RPC_STUB IWriteCookie_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IWriteCookie_put_Expires_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ DATE rhs);


void __RPC_STUB IWriteCookie_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IWriteCookie_put_Domain_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR rhs);


void __RPC_STUB IWriteCookie_put_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IWriteCookie_put_Path_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR rhs);


void __RPC_STUB IWriteCookie_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IWriteCookie_put_Secure_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ boolean rhs);


void __RPC_STUB IWriteCookie_put_Secure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IWriteCookie_get_HasKeys_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pfHasKeys);


void __RPC_STUB IWriteCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][propget][id] */ HRESULT __stdcall IWriteCookie_get__NewEnum_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IWriteCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWriteCookie_INTERFACE_DEFINED__ */


#ifndef __IResponse_INTERFACE_DEFINED__
#define __IResponse_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResponse
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][uuid] */ 



EXTERN_C const IID IID_IResponse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IResponse : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Buffer( 
            /* [retval][out] */ boolean __RPC_FAR *fIsBuffering) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Buffer( 
            /* [in] */ boolean fIsBuffering) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_ContentType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_ContentType( 
            /* [in] */ BSTR pbstrContentTypeRet) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Expires( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Expires( 
            /* [in] */ VARIANT varExpiresMinutesRet) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_ExpiresAbsolute( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_ExpiresAbsolute( 
            /* [in] */ VARIANT varExpiresRet) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Status( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Status( 
            /* [in] */ BSTR pbstrStatusRet) = 0;
        
        virtual /* [hidden][id] */ HRESULT __stdcall Add( 
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall AddHeader( 
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall AppendToLog( 
            /* [in] */ BSTR bstrLogEntry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall BinaryWrite( 
            /* [in] */ SAFEARRAY __RPC_FAR * rgbBuffer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall Clear( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall End( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall Flush( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall Redirect( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall Write( 
            /* [in] */ VARIANT varText) = 0;
        
        virtual /* [hidden][id] */ HRESULT __stdcall WriteBlock( 
            /* [in] */ short iBlockNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResponse __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResponse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IResponse __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IResponse __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *fIsBuffering);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [in] */ boolean fIsBuffering);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR pbstrContentTypeRet);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Expires )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Expires )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varExpiresMinutesRet);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varExpiresRet);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Cookies )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Status )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Status )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR pbstrStatusRet);
        
        /* [hidden][id] */ HRESULT ( __stdcall __RPC_FAR *Add )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *AddHeader )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *AppendToLog )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrLogEntry);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *BinaryWrite )( 
            IResponse __RPC_FAR * This,
            /* [in] */ SAFEARRAY __RPC_FAR * rgbBuffer);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *Clear )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *End )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *Flush )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *Redirect )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *Write )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varText);
        
        /* [hidden][id] */ HRESULT ( __stdcall __RPC_FAR *WriteBlock )( 
            IResponse __RPC_FAR * This,
            /* [in] */ short iBlockNumber);
        
        END_INTERFACE
    } IResponseVtbl;

    interface IResponse
    {
        CONST_VTBL struct IResponseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResponse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResponse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResponse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResponse_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IResponse_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IResponse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IResponse_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IResponse_get_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> get_Buffer(This,fIsBuffering)

#define IResponse_put_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> put_Buffer(This,fIsBuffering)

#define IResponse_get_ContentType(This,pbstrContentTypeRet)	\
    (This)->lpVtbl -> get_ContentType(This,pbstrContentTypeRet)

#define IResponse_put_ContentType(This,pbstrContentTypeRet)	\
    (This)->lpVtbl -> put_ContentType(This,pbstrContentTypeRet)

#define IResponse_get_Expires(This,pvarExpiresMinutesRet)	\
    (This)->lpVtbl -> get_Expires(This,pvarExpiresMinutesRet)

#define IResponse_put_Expires(This,varExpiresMinutesRet)	\
    (This)->lpVtbl -> put_Expires(This,varExpiresMinutesRet)

#define IResponse_get_ExpiresAbsolute(This,pvarExpiresRet)	\
    (This)->lpVtbl -> get_ExpiresAbsolute(This,pvarExpiresRet)

#define IResponse_put_ExpiresAbsolute(This,varExpiresRet)	\
    (This)->lpVtbl -> put_ExpiresAbsolute(This,varExpiresRet)

#define IResponse_get_Cookies(This,ppCookies)	\
    (This)->lpVtbl -> get_Cookies(This,ppCookies)

#define IResponse_get_Status(This,pbstrStatusRet)	\
    (This)->lpVtbl -> get_Status(This,pbstrStatusRet)

#define IResponse_put_Status(This,pbstrStatusRet)	\
    (This)->lpVtbl -> put_Status(This,pbstrStatusRet)

#define IResponse_Add(This,bstrHeaderValue,bstrHeaderName)	\
    (This)->lpVtbl -> Add(This,bstrHeaderValue,bstrHeaderName)

#define IResponse_AddHeader(This,bstrHeaderName,bstrHeaderValue)	\
    (This)->lpVtbl -> AddHeader(This,bstrHeaderName,bstrHeaderValue)

#define IResponse_AppendToLog(This,bstrLogEntry)	\
    (This)->lpVtbl -> AppendToLog(This,bstrLogEntry)

#define IResponse_BinaryWrite(This,rgbBuffer)	\
    (This)->lpVtbl -> BinaryWrite(This,rgbBuffer)

#define IResponse_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IResponse_End(This)	\
    (This)->lpVtbl -> End(This)

#define IResponse_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#define IResponse_Redirect(This,bstrURL)	\
    (This)->lpVtbl -> Redirect(This,bstrURL)

#define IResponse_Write(This,varText)	\
    (This)->lpVtbl -> Write(This,varText)

#define IResponse_WriteBlock(This,iBlockNumber)	\
    (This)->lpVtbl -> WriteBlock(This,iBlockNumber)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT __stdcall IResponse_get_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *fIsBuffering);


void __RPC_STUB IResponse_get_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IResponse_put_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ boolean fIsBuffering);


void __RPC_STUB IResponse_put_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IResponse_get_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);


void __RPC_STUB IResponse_get_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IResponse_put_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR pbstrContentTypeRet);


void __RPC_STUB IResponse_put_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IResponse_get_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);


void __RPC_STUB IResponse_get_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IResponse_put_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varExpiresMinutesRet);


void __RPC_STUB IResponse_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IResponse_get_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);


void __RPC_STUB IResponse_get_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IResponse_put_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varExpiresRet);


void __RPC_STUB IResponse_put_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IResponse_get_Cookies_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);


void __RPC_STUB IResponse_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IResponse_get_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);


void __RPC_STUB IResponse_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IResponse_put_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR pbstrStatusRet);


void __RPC_STUB IResponse_put_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT __stdcall IResponse_Add_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue,
    /* [in] */ BSTR bstrHeaderName);


void __RPC_STUB IResponse_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_AddHeader_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderName,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_AddHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_AppendToLog_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrLogEntry);


void __RPC_STUB IResponse_AppendToLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_BinaryWrite_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ SAFEARRAY __RPC_FAR * rgbBuffer);


void __RPC_STUB IResponse_BinaryWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_Clear_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_End_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_Flush_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_Redirect_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrURL);


void __RPC_STUB IResponse_Redirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IResponse_Write_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varText);


void __RPC_STUB IResponse_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT __stdcall IResponse_WriteBlock_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ short iBlockNumber);


void __RPC_STUB IResponse_WriteBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResponse_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Response;

class Response;
#endif

#ifndef __ISessionObject_INTERFACE_DEFINED__
#define __ISessionObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISessionObject
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][uuid] */ 



EXTERN_C const IID IID_ISessionObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ISessionObject : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_SessionID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet) = 0;
        
        virtual /* [propget][id] */ HRESULT __stdcall get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT __stdcall put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar) = 0;
        
        virtual /* [propputref][id] */ HRESULT __stdcall putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Timeout( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_Timeout( 
            /* [in] */ long plvar) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall Abandon( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISessionObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISessionObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISessionObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISessionObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_SessionID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);
        
        /* [propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar);
        
        /* [propputref][id] */ HRESULT ( __stdcall __RPC_FAR *putref_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long plvar);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *Abandon )( 
            ISessionObject __RPC_FAR * This);
        
        END_INTERFACE
    } ISessionObjectVtbl;

    interface ISessionObject
    {
        CONST_VTBL struct ISessionObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISessionObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISessionObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISessionObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISessionObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISessionObject_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define ISessionObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define ISessionObject_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define ISessionObject_get_SessionID(This,pbstrRet)	\
    (This)->lpVtbl -> get_SessionID(This,pbstrRet)

#define ISessionObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define ISessionObject_put_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,pvar)

#define ISessionObject_putref_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,pvar)

#define ISessionObject_get_Timeout(This,plvar)	\
    (This)->lpVtbl -> get_Timeout(This,plvar)

#define ISessionObject_put_Timeout(This,plvar)	\
    (This)->lpVtbl -> put_Timeout(This,plvar)

#define ISessionObject_Abandon(This)	\
    (This)->lpVtbl -> Abandon(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT __stdcall ISessionObject_get_SessionID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);


void __RPC_STUB ISessionObject_get_SessionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT __stdcall ISessionObject_get_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB ISessionObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT __stdcall ISessionObject_put_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT pvar);


void __RPC_STUB ISessionObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT __stdcall ISessionObject_putref_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT pvar);


void __RPC_STUB ISessionObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall ISessionObject_get_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall ISessionObject_put_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long plvar);


void __RPC_STUB ISessionObject_put_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall ISessionObject_Abandon_Proxy( 
    ISessionObject __RPC_FAR * This);


void __RPC_STUB ISessionObject_Abandon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISessionObject_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Session;

class Session;
#endif

#ifndef __IApplicationObject_INTERFACE_DEFINED__
#define __IApplicationObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IApplicationObject
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][uuid] */ 



EXTERN_C const IID IID_IApplicationObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IApplicationObject : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT __stdcall get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT __stdcall put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar) = 0;
        
        virtual /* [propputref][id] */ HRESULT __stdcall putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall Lock( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall UnLock( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IApplicationObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IApplicationObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IApplicationObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar);
        
        /* [propputref][id] */ HRESULT ( __stdcall __RPC_FAR *putref_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT pvar);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *Lock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *UnLock )( 
            IApplicationObject __RPC_FAR * This);
        
        END_INTERFACE
    } IApplicationObjectVtbl;

    interface IApplicationObject
    {
        CONST_VTBL struct IApplicationObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApplicationObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApplicationObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IApplicationObject_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IApplicationObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IApplicationObject_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IApplicationObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define IApplicationObject_put_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,pvar)

#define IApplicationObject_putref_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,pvar)

#define IApplicationObject_Lock(This)	\
    (This)->lpVtbl -> Lock(This)

#define IApplicationObject_UnLock(This)	\
    (This)->lpVtbl -> UnLock(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT __stdcall IApplicationObject_get_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IApplicationObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT __stdcall IApplicationObject_put_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT pvar);


void __RPC_STUB IApplicationObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT __stdcall IApplicationObject_putref_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT pvar);


void __RPC_STUB IApplicationObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IApplicationObject_Lock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IApplicationObject_UnLock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_UnLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApplicationObject_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Application;

class Application;
#endif

#ifndef __IServer_INTERFACE_DEFINED__
#define __IServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IServer
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][uuid] */ 



EXTERN_C const IID IID_IServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IServer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_ScriptTimeout( 
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT __stdcall put_ScriptTimeout( 
            /* [in] */ long plTimeoutSeconds) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall CreateObject( 
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall HTMLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall MapPath( 
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall URLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IServer __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IServer __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);
        
        /* [helpstring][propput][id] */ HRESULT ( __stdcall __RPC_FAR *put_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [in] */ long plTimeoutSeconds);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *CreateObject )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *HTMLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *MapPath )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *URLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        END_INTERFACE
    } IServerVtbl;

    interface IServer
    {
        CONST_VTBL struct IServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IServer_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IServer_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IServer_get_ScriptTimeout(This,plTimeoutSeconds)	\
    (This)->lpVtbl -> get_ScriptTimeout(This,plTimeoutSeconds)

#define IServer_put_ScriptTimeout(This,plTimeoutSeconds)	\
    (This)->lpVtbl -> put_ScriptTimeout(This,plTimeoutSeconds)

#define IServer_CreateObject(This,bstrProgID,ppDispObject)	\
    (This)->lpVtbl -> CreateObject(This,bstrProgID,ppDispObject)

#define IServer_HTMLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> HTMLEncode(This,bstrIn,pbstrEncoded)

#define IServer_MapPath(This,bstrLogicalPath,pbstrPhysicalPath)	\
    (This)->lpVtbl -> MapPath(This,bstrLogicalPath,pbstrPhysicalPath)

#define IServer_URLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLEncode(This,bstrIn,pbstrEncoded)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT __stdcall IServer_get_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);


void __RPC_STUB IServer_get_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT __stdcall IServer_put_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ long plTimeoutSeconds);


void __RPC_STUB IServer_put_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IServer_CreateObject_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);


void __RPC_STUB IServer_CreateObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IServer_HTMLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_HTMLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IServer_MapPath_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrLogicalPath,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);


void __RPC_STUB IServer_MapPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IServer_URLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServer_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Server;

class Server;
#endif

#ifndef __IScriptingContext_INTERFACE_DEFINED__
#define __IScriptingContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScriptingContext
 * at Wed Mar 12 14:39:56 1997
 * using MIDL 3.00.15
 ****************************************/
/* [auto_handle][oleautomation][dual][hidden][helpstring][uuid] */ 



EXTERN_C const IID IID_IScriptingContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IScriptingContext : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Request( 
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Response( 
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Server( 
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Session( 
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT __stdcall get_Application( 
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptingContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptingContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptingContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IScriptingContext __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Request )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Response )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Server )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Session )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);
        
        /* [helpstring][propget][id] */ HRESULT ( __stdcall __RPC_FAR *get_Application )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);
        
        END_INTERFACE
    } IScriptingContextVtbl;

    interface IScriptingContext
    {
        CONST_VTBL struct IScriptingContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptingContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptingContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptingContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptingContext_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IScriptingContext_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IScriptingContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IScriptingContext_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)


#define IScriptingContext_get_Request(This,ppRequest)	\
    (This)->lpVtbl -> get_Request(This,ppRequest)

#define IScriptingContext_get_Response(This,ppResponse)	\
    (This)->lpVtbl -> get_Response(This,ppResponse)

#define IScriptingContext_get_Server(This,ppServer)	\
    (This)->lpVtbl -> get_Server(This,ppServer)

#define IScriptingContext_get_Session(This,ppSession)	\
    (This)->lpVtbl -> get_Session(This,ppSession)

#define IScriptingContext_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT __stdcall IScriptingContext_get_Request_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);


void __RPC_STUB IScriptingContext_get_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IScriptingContext_get_Response_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);


void __RPC_STUB IScriptingContext_get_Response_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IScriptingContext_get_Server_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);


void __RPC_STUB IScriptingContext_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IScriptingContext_get_Session_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);


void __RPC_STUB IScriptingContext_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT __stdcall IScriptingContext_get_Application_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IScriptingContext_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptingContext_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ScriptingContext;

class ScriptingContext;
#endif
#endif /* __ASPTypeLibrary_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\cdf.h ===
#ifndef _DEFINED_CDF_H_
#define _DEFINED_CDF_H_

#define MAX_NODE_NAME      32
#define MAX_NODE_CLASS     64

// pack definition structures on a DWORD boundary to match VB Type definition aligment

#pragma pack(4)

typedef enum tagCONV_NODE_TYPE
{
   NODE_TYPE_PAGE,
   NODE_TYPE_CONVERSATION
} CONV_NODE_TYPE;

typedef struct tagCONV_HEADER
{
   DWORD dwVersion;
   DWORD cNodes;
   DWORD dwFirstNodeID;
   DWORD dwReserved1;
   DWORD dwReserved2;
} CONV_HEADER;

typedef struct tagCONV_NODE
{
   DWORD				   dwNodeID; // Not saved in file. NodeID = offset into file. Set on return from API
   char  				szName[MAX_NODE_NAME];
   char    				szClass[MAX_NODE_CLASS];   // TODO: Can we limit names and classes as such?
   DWORD				   dwReserved1;
   DWORD				   dwReserved2;
   DWORD				   dwReserved3;
   DWORD				   dwLinkCount;
// DWORD    			dwLink1;
// DWORD			      dwLink2;
// ...
// DWORD    			dwLinkN;
// etc.
} CONV_NODE;

//
// CDF File Format
//
// Header
//
//	Name Len
//	Name
//	Class Len
//	Class
//	Link Count
//	Link1
//	Link2
//	...
//	LinkN

#pragma pack()

// resource type name used for CDFs

#define CDF_RESOURCE_TYPE "__ICDF__"

// current version of CDF

#define CDF_VERSION 0

// File layout:
//
// header
// constructor node (no links)
// destructor node (no links)
// termination node (no links)
// OnError node
// first link of OnError node
// second link of OnError node
// ...
// nth link of OnError node
// first conversation node
// first link of first node
// second link of first node
// ...
// nth link of first node
// second conversation node
// first link of second node
// etc.
//
// File is always read and written sequentially

///////////////////////////////////////////////////////////////////
//////////////////////////// CDF API //////////////////////////////
///////////////////////////////////////////////////////////////////

// Functions for reading a CDF

extern "C" HRESULT WINAPI CDF_Open(LPTSTR pszFileName, HANDLE *phCDF);
extern "C" HRESULT WINAPI CDF_OpenFromResource(HANDLE hModule, LPCSTR pszResourceName, HANDLE *phCDF);

extern "C" HRESULT WINAPI CDF_GetVersion(HANDLE hCDF, DWORD *pdwVersion);
extern "C" HRESULT WINAPI CDF_GetNodeCount(HANDLE hCDF, DWORD *pdwNodeCount);

extern "C" HRESULT WINAPI CDF_GetFirstNode(HANDLE hCDF, CONV_NODE *pConvNode);
extern "C" HRESULT WINAPI CDF_GetNode(HANDLE hCDF, DWORD dwNodeID, CONV_NODE *pConvNode);
extern "C" HRESULT WINAPI CDF_GetLink(HANDLE hCDF, DWORD dwNodeID, DWORD dwIndex, CONV_NODE *pDestConvNode);

// Functions for writing a CDF

extern "C" HRESULT WINAPI CDF_Create(LPCTSTR pszFileName, HANDLE *phCDF);
extern "C" HRESULT WINAPI CDF_AddNode(HANDLE hCDF, LPSTR pszName, LPSTR pszClass);
extern "C" HRESULT WINAPI CDF_AddLink(HANDLE hCDF, LPSTR pszDestNode);

// Always close the CDF when finished reading or writing

extern "C" HRESULT WINAPI CDF_Close(HANDLE hCDF);

#endif	// _DEFINED_CDF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\autoobj.h ===
//=--------------------------------------------------------------------------=
// AutomationObject.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// all of our objects will inherit from this class to share as much of the same
// code as possible.  this super-class contains the unknown and dispatch
// implementations for them.
//
#ifndef _AUTOMATIONOBJECT_H_

#include "Unknown.H"            // for aggregating unknown
#include <olectl.h>             // for connection point stuff

//=--------------------------------------------------------------------------=
// the constants in this header file uniquely identify your automation objects.
// make sure that for each object you have in the g_ObjectInfo table, you have
// a constant in this header file.
//
#include "LocalSrv.H"

//=--------------------------------------------------------------------------=
// Misc constants
//=--------------------------------------------------------------------------=

// maximum number of arguments that can be sent to FireEvent()
//
#define MAX_ARGS    32

// for the types of sinks that the COleControl class has.  you shouldn't ever
// need to use these
//
#define SINK_TYPE_EVENT      0
#define SINK_TYPE_PROPNOTIFY 1


//=--------------------------------------------------------------------------=
// Structures
//=--------------------------------------------------------------------------=

// describes an event
//
typedef struct tagEVENTINFO {

    DISPID    dispid;                    // dispid of the event
    int       cParameters;               // number of arguments to the event
    VARTYPE  *rgTypes;                   // type of each argument

} EVENTINFO;


// This is a helper structure that you can use to help verify that the
// Data1_ #define's match up with the interfaces they represent.
// In your code declare an array as follows:
//
//		#ifdef DEBUG
//
//			GUIDDATA1_COMPARE g_gdMyControl [] = {
//						{ Data1_MyControlInterface, &IID_IMyControlInterface.Data1 },
//						{ Data1_MySubObject, &IID_IMySubObject.Data1 },
//						{0, 0},												// Mark the end of the array
//						}; 
//		#endif
//
// In your InternalQueryInterface function, make a call to the framework
// helper function  DebugVerifyData1Guids as follows:
//
//		#ifdef DEBUG
//			DebugVerifyData1Guids(g_gdMyControl);
//		#endif
//
#ifdef DEBUG
	 
 struct GUIDDATA1_COMPARE
 {
	DWORD dwData1a;
	DWORD *pdwData1b;
 };

 void DebugVerifyData1Guids(GUIDDATA1_COMPARE *pGuidData1_Compare);

#endif

//=--------------------------------------------------------------------------=
// AUTOMATIONOBJECTINFO
//=--------------------------------------------------------------------------=
// for each automation object type you wish to expose to the programmer/user
// that is not a control, you must fill out one of these structures.  if the
// object isn't CoCreatable, then the first four fields should be empty.
// otherwise, they should be filled in with the appropriate information.
// use the macro DEFINE_AUTOMATIONOBJECT to both declare and define your object.
// make sure you have an entry in the global table of objects, g_ObjectInfo
// in the main .Cpp file for your InProc server.
//
typedef struct {

    UNKNOWNOBJECTINFO unknowninfo;               // fill in with 0's if we're not CoCreatable
    long         lVersion;                       // Version number of Object.  ONLY USE IF YOU'RE CoCreatable!
    long         lVersionMinor;                  // minor version number
    const IID   *riid;                           // object's type
    const IID   *riidEvents;                     // if it has events
    LPCSTR       pszHelpFile;                    // the helpfile for this automation object.
    ITypeInfo   *pTypeInfo;                      // typeinfo for this object
    UINT         cTypeInfo;                      // number of refs to the type info

} AUTOMATIONOBJECTINFO;

// macros to manipulate the AUTOMATIONOBJECTINFO in the global table table.
//
#define VERSIONOFOBJECT(index)         ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->lVersion
#define VERSIONMINOROFOBJECT(index)    ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->lVersionMinor
#define INTERFACEOFOBJECT(index)       (*(((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->riid))
#define EVENTIIDOFOBJECT(index)        (*(((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->riidEvents))
#define PPTYPEINFOOFOBJECT(index)      &((((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo))
#define PTYPEINFOOFOBJECT(index)       ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo
#define CTYPEINFOOFOBJECT(index)       ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->cTypeInfo
#define HELPFILEOFOBJECT(index)        ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszHelpFile

#define ISVALIDEVENTIID(index)	       (((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->riidEvents != NULL)

#ifndef INITOBJECTS

#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \
extern AUTOMATIONOBJECTINFO name##Object \

#define DEFINE_AUTOMATIONOBJECTWEVENTS(name, clsid, objname, fn, ver, riid, piide, pszh) \
extern AUTOMATIONOBJECTINFO name##Object \

#define DEFINE_AUTOMATIONOBJECT2(name, clsid, objname, lblname, fn, ver, vermin, riid, pszh, fthreadsafe) \
extern AUTOMATIONOBJECTINFO name##Object \

#define DEFINE_AUTOMATIONOBJECTWEVENTS2(name, clsid, objname, lblname, fn, ver, vermin, riid, piide, pszh, fthreadsafe) \
extern AUTOMATIONOBJECTINFO name##Object \

#define DEFINE_AUTOMATIONOBJECT3(name, clsid, objname, lblname, precreatefn, fn, ver, vermin, riid, pszh, fthreadsafe) \
extern AUTOMATIONOBJECTINFO name##Object \

#define DEFINE_AUTOMATIONOBJECTWEVENTS3(name, clsid, objname, lblname, precreatefn, fn, ver, vermin, riid, piide, pszh, fthreadsafe) \
extern AUTOMATIONOBJECTINFO name##Object \

#else
#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, NULL, TRUE, fn, NULL }, ver, 0, riid, NULL,  pszh, NULL, 0} \

#define DEFINE_AUTOMATIONOBJECTWEVENTS(name, clsid, objname, fn, ver, riid, piide, pszh) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, NULL, TRUE, fn, NULL }, ver, 0, riid, piide, pszh, NULL, 0} \

#define DEFINE_AUTOMATIONOBJECT2(name, clsid, objname, lblname, fn, ver, vermin, riid, pszh, fthreadsafe) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, lblname, fthreadsafe, fn, NULL }, ver, vermin, riid, NULL,  pszh, NULL, 0} \

#define DEFINE_AUTOMATIONOBJECTWEVENTS2(name, clsid, objname, lblname, fn, ver, vermin, riid, piide, pszh, fthreadsafe) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, lblname, fthreadsafe, fn, NULL }, ver, vermin, riid, piide, pszh, NULL, 0} \

#define DEFINE_AUTOMATIONOBJECT3(name, clsid, objname, lblname, precreatefn, fn, ver, vermin, riid, pszh, fthreadsafe) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, lblname, fthreadsafe, fn, precreatefn }, ver, vermin, riid, NULL,  pszh, NULL, 0} \

#define DEFINE_AUTOMATIONOBJECTWEVENTS3(name, clsid, objname, lblname, precreatefn, fn, ver, vermin, riid, piide, pszh, fthreadsafe) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, lblname, fthreadsafe, fn, precreatefn }, ver, vermin, riid, piide, pszh, NULL, 0} \

#endif // INITOBJECTS

//=--------------------------------------------------------------------------=
// Standard Dispatch and SupportErrorInfo
//=--------------------------------------------------------------------------=
// all objects should declare these in their class definitions so that they
// get standard implementations of IDispatch and ISupportErrorInfo.
//
#define DECLARE_STANDARD_DISPATCH() \
    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) { \
        return CAutomationObject::GetTypeInfoCount(pctinfo); \
    } \
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **ppTypeInfoOut) { \
        return CAutomationObject::GetTypeInfo(itinfo, lcid, ppTypeInfoOut); \
    } \
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cnames, LCID lcid, DISPID *rgdispid) { \
        return CAutomationObject::GetIDsOfNames(riid, rgszNames, cnames, lcid, rgdispid); \
    } \
    STDMETHOD(Invoke)(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr) { \
        return CAutomationObject::Invoke(dispid, riid, lcid, wFlags, pdispparams, pVarResult, pexcepinfo, puArgErr); \
    } \


#define DECLARE_STANDARD_SUPPORTERRORINFO() \
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid) { \
        return CAutomationObject::InterfaceSupportsErrorInfo(riid); \
    } \


//=--------------------------------------------------------------------------=
// CAutomationObject
//=--------------------------------------------------------------------------=
// global class that all automation objects can inherit from to give them a
// bunch of implementation for free, namely IDispatch and ISupportsErrorInfo
//
//
class CAutomationObject : public CUnknownObject  {

  public:
    // aggreation query interface support
    //
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IDispatch methods
    //
    STDMETHOD(GetTypeInfoCount)(UINT *);
    STDMETHOD(GetTypeInfo)(UINT, LCID, ITypeInfo **);
    STDMETHOD(GetIDsOfNames)(REFIID, OLECHAR **, UINT, LCID, DISPID *);
    STDMETHOD(Invoke)(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

    //  ISupportErrorInfo methods
    //
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID);

    CAutomationObject(IUnknown *, int , void *);
    virtual ~CAutomationObject();

    // callable functions -- things that most people will find useful.
    //
    virtual HINSTANCE GetResourceHandle(void);
    virtual HRESULT Exception(HRESULT hr, WORD idException, DWORD dwHelpContextID);
    virtual HRESULT Exception(HRESULT hr, LPWSTR wszException, DWORD dwHelpContextID);

  protected:
    // member variables that derived objects might need to get at information in the
    // global object table
    //
    int   m_ObjectType;

#ifdef MDAC_BUILD
    const CLSID	*m_pTypeLibId;
#endif

  private:
    // member variables we don't share.
    //
    BYTE  m_fLoadedTypeInfo;
};


//=--------------------------------------------------------------------------=
// CAutomationObjectWEvents
//=--------------------------------------------------------------------------=
// a slightly modified version of CAutomationObject that supports event
// firing
//
class CAutomationObjectWEvents : public CAutomationObject,
                                 public IConnectionPointContainer {

  public:
    // aggreation query interface support
    //
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // we have to declare this since IConnectionPointContainer inherits
    // from IUnknown
    //
    DECLARE_STANDARD_UNKNOWN();

    // IConnectionPointContainer methods
    //
    STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS FAR* ppEnum);
    STDMETHOD(FindConnectionPoint)(REFIID iid, LPCONNECTIONPOINT FAR* ppCP);

    // how everybody will fire an event
    //
    void __cdecl FireEvent(EVENTINFO * pEventInfo, ...);

    // whether it's necessary to fire the event
    BOOL FFireEvent() { return m_cpEvents.m_rgSinks != NULL; }

    CAutomationObjectWEvents(IUnknown *, int , void *);
    virtual ~CAutomationObjectWEvents();

  protected:
    // nested class that will handle all of the connection point stuff
    //
    class CConnectionPoint : public IConnectionPoint {
      public:
        IUnknown **m_rgSinks;

        // IUnknown methods
        //
        STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) ;
        STDMETHOD_(ULONG,AddRef)(THIS) ;
        STDMETHOD_(ULONG,Release)(THIS) ;

        // IConnectionPoint methods
        //
        STDMETHOD(GetConnectionInterface)(IID FAR* pIID);
        STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer FAR* FAR* ppCPC);
        STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie);
        STDMETHOD(Unadvise)(DWORD dwCookie);
        STDMETHOD(EnumConnections)(LPENUMCONNECTIONS FAR* ppEnum);

        void    DoInvoke(DISPID dispid, DISPPARAMS * pdispparam);
        void    DoOnChanged(DISPID dispid);
        BOOL    DoOnRequestEdit(DISPID dispid);
        HRESULT AddSink(void *, DWORD *);

        CAutomationObjectWEvents *m_pObject();
        CConnectionPoint(BYTE b){
            m_bType = b;
            m_rgSinks = NULL;
            m_cSinks = 0;
        }
        ~CConnectionPoint();

      private:
        BYTE   m_bType;
        short  m_cSinks;

    } m_cpEvents, m_cpPropNotify;

    // so they can get at some of our protected things, like AddRef, QI, etc.
    //
    friend CConnectionPoint;
};


#define _AUTOMATIONOBJECT_H_
#endif // _AUTOMATIONOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\csf.h ===
#ifndef _GLOBAL_WEBCLASS_CONSTANTS_
#define _GLOBAL_WEBCLASS_CONSTANTS_

#define WEBITEM_URL_PARAM_NAME                   "WCI"
#define WEBITEM_URL_PARAM_NAME_LEN               sizeof(WEBITEM_URL_PARAM_NAME)

#define WEBITEM_URL_PARAM_NAME_WIDE              L"WCI"
#define WEBITEM_URL_PARAM_NAME_WIDE_LEN          sizeof(WEBITEM_URL_PARAM_NAME_WIDE)

#define WEBITEM_INTERNAL_URL_PARAM_NAME          "WCIID"
#define WEBITEM_INTERNAL_URL_PARAM_NAME_LEN      sizeof(WEBITEM_INTERNAL_URL_PARAM_NAME)

#define WEBITEM_INTERNAL_URL_PARAM_NAME_WIDE     L"WCIID"
#define WEBITEM_INTERNAL_URL_PARAM_NAME_WIDE_LEN sizeof(WEBITEM_INTERNAL_URL_PARAM_NAME_WIDE)

#define EVENT_URL_PARAM_NAME                     "WCE"
#define EVENT_URL_PARAM_NAME_LEN                 sizeof(EVENT_URL_PARAM_NAME)

#define EVENT_URL_PARAM_NAME_WIDE                L"WCE"
#define EVENT_URL_PARAM_NAME_WIDE_LEN            sizeof(EVENT_URL_PARAM_NAME_WIDE)

#define EVENT_INTERNAL_URL_PARAM_NAME            "WCEID"
#define EVENT_INTERNAL_URL_PARAM_NAME_LEN        sizeof(EVENT_INTERNAL_URL_PARAM_NAME)

#define EVENT_INTERNAL_URL_PARAM_NAME_WIDE       L"WCEID"
#define EVENT_INTERNAL_URL_PARAM_NAME_WIDE_LEN   sizeof(EVENT_INTERNAL_URL_PARAM_NAME_WIDE)


#define PAGECLASS_URL_PARAM_NAME_WIDE	L"CPC"
#define PAGECLASS_URL_PARAM_NAME		"CPC"

#define CONVCLASS_URL_PARAM_NAME_WIDE	L"CCC"
#define CONVCLASS_URL_PARAM_NAME		"CCC"

#define INTERNAL_PAGENAME_URL_PARAM_NAME_WIDE	L"WCIID"
#define INTERNAL_PAGENAME_URL_PARAM_NAME		"WCIID"

#define EXTERNAL_PAGENAME_URL_PARAM_NAME_WIDE	L"WCI"
#define EXTERNAL_PAGENAME_URL_PARAM_NAME		"WCI"

#define CONVNAME_URL_PARAM_NAME_WIDE	L"CCN"
#define CONVNAME_URL_PARAM_NAME			"CCN"

#define SEQNO_URL_PARAM_NAME			"CSN"
#define SEQNO_URL_PARAM_NAME_WIDE		L"CSN"

#define NOTRANS_URL_PARAM_NAME			"WCNOTRANS"
#define NOTRANS_URL_PARAM_NAME_WIDE		L"WCNOTRANS"

#define STACKID_URL_PARAM_NAME_WIDE		L"SID"

#define NODEID_URL_PARAM_NAME_WIDE		L"ICNODEID"

#define MAX_EVENT_LEN	256

#define	EMBEDDED_GET_SENTINEL_WIDE			L"ICGET"

#define	HYPERLINK_SENTINEL_WIDE				L"WCE"
#define	INTERNAL_HYPERLINK_SENTINEL_WIDE	L"WCEID"
#define	EXTERNAL_HYPERLINK_SENTINEL_WIDE	L"WCE"

#define	SUBMIT_SENTINEL_WIDE				L"ICSUBMIT_"

#define  CUSTOM_EVENT_SENTINEL_WIDE    L"ICEVENT"

#define	MAX_ERROR_DESCRIPTION				256

#define MAX_CLASS_SIZE						64
#define MAX_NAME_SIZE						64

#define REGDB_CONVERSATIONS_PATH			TEXT("SOFTWARE\\Microsoft\\Visual Basic\\6.0\\WebClass")
#define REGDB_TRACE_MASK_VALUE			    TEXT("TraceMask")
#define REGDB_DEF_TEMPLATES_DIR_VALUE       "DefaultTemplateDirectory"
#define REGDB_DEF_TEMPLATES_DIR_VALUE_WIDE  L"DefaultTemplateDirectory"

#define MAX_SEQNO_LEN                       16

#define URL_MUNGING_TOKEN                   "^@^"
#define URL_MUNGING_TOKEN_WIDE              L"^@^"

#define URL_MAX_LEN  256							// Max chars in URL

// DEFINE_GUID(CATID_WebClass, );

// {74E7D75E-3826-11d1-9C70-00C04FB987DF}
const GUID CATID_WebClass =
{ 0xcbc5d810, 0x1856, 0x11d1, { 0xb8, 0x1, 0x0, 0xa0, 0xd1, 0x0, 0x37, 0xe4  } };

#define WC_DEBUG_START_PARAM	"WCDEBUG"
#define WC_DEBUG_START_PARAM_WIDE	L"WCDEBUG"

#define ASP_EXT		    ".ASP"
#define ASP_EXT_LEN		sizeof(ASP_EXT)

#define ASP_EXT_WIDE        L".ASP"
#define ASP_EXT_WIDE_LEN    sizeof(ASP_EXT_WIDE_LEN)

// Note first char must reamin a uniuqe char
//
#define URL_DATA_PARAM_NAME	        "WCU"
#define URL_DATA_PARAM_NAME_WIDE	L"WCU"
#define URL_DATA_PARAM_NAME_LEN 	sizeof("WCU") - 1

#define MAX_WEBITEMS                512
#define HIAVG_WEBITEMS              64

#endif // _GLOBAL_WEBCLASS_CONSTANTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\ctrlobj.h ===
//=--------------------------------------------------------------------------=
// ControlObject.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for the COleControl object
//
#ifndef _CONTROLOBJECT_H_

// we need the automation object and ctlole.h
//
#include "AutoObj.H"
#include "Macros.H"

// For VC++ 4.2 include files and above, all OCX96.H declarations are in OCIDL.H
// For VB 5.0 build tools, we must include OCX96.H to get this declares.
//
#ifndef __ocidl_h__
#include "ocx96.h"
#endif

// These are the original QA structures.  We preserve the declarations here
// because if the structure size changes (i.e., gets larger) in OCIDL.H
// then controls will begin to fail QuickActivate when hosted on older 
// containers.
//
typedef struct  tagQACONTAINER_OLD
    {
    ULONG cbSize;
    IOleClientSite __RPC_FAR *pClientSite;
    IAdviseSinkEx __RPC_FAR *pAdviseSink;
    IPropertyNotifySink __RPC_FAR *pPropertyNotifySink;
    IUnknown __RPC_FAR *pUnkEventSink;
    DWORD dwAmbientFlags;
    OLE_COLOR colorFore;
    OLE_COLOR colorBack;
    IFont __RPC_FAR *pFont;
    IOleUndoManager __RPC_FAR *pUndoMgr;
    DWORD dwAppearance;
    LONG lcid;
    HPALETTE hpal;
    struct IBindHost __RPC_FAR *pBindHost;
    }	QACONTAINER_OLD;

typedef struct  tagQACONTROL_OLD
    {
    ULONG cbSize;
    DWORD dwMiscStatus;
    DWORD dwViewStatus;
    DWORD dwEventCookie;
    DWORD dwPropNotifyCookie;
    DWORD dwPointerActivationPolicy;
    }	QACONTROL_OLD;


// forward declaration
//
class COleControl;

//=--------------------------------------------------------------------------=
// Misc Helper Functions
//=--------------------------------------------------------------------------=
//
// given an Unknown pointer, get the COleControl * for it.  used typically
// in property page code.
//
COleControl *ControlFromUnknown(IUnknown *);


//=--------------------------------------------------------------------------=
// Misc Constants
//=--------------------------------------------------------------------------=
// superclass window support.  you can pass this in to DoSuperClassPaint
//
#define DRAW_SENDERASEBACKGROUND        1

//=--------------------------------------------------------------------------=
// Various Hosts don't handle OLEIVERB_PROPERTIES correctly, so we can't use
// that as our Properties verb number.  Instead, we're going to define
// CTLIVERB_PROPERTIES as 1, and return that one in IOleObject::EnumVerbs,
// but we'll still handle OLEIVERB_PROPERTIES correctly in DoVerb.
//
#define CTLIVERB_PROPERTIES     1


//=--------------------------------------------------------------------------=
// this structure is like the OLEVERB structure, except that it has a resource ID
// instead of a string for the verb's name.  better support for localization.
//
typedef struct tagVERBINFO {

    LONG    lVerb;                // verb id
    ULONG   idVerbName;           // resource ID of verb name
    DWORD   fuFlags;              // verb flags
    DWORD   grfAttribs;           // Specifies some combination of the verb attributes in the OLEVERBATTRIB enumeration.

} VERBINFO;

//=--------------------------------------------------------------------------=
// CONTROLOBJECTINFO
//=--------------------------------------------------------------------------=
// for each control you wish to expose to the programmer/user, you need to
// declare and define one of the following structures.  the first part should
// follow the rules of the AUTOMATIONOBJECTINFO structure.  it's pretty hard,
// however, to imagine a scenario where the control isn't CoCreatable ...
// once this structre is declared/defined, an entry should be put in the
// global g_ObjectInfo table.
//
typedef struct {

    AUTOMATIONOBJECTINFO AutomationInfo;           // automation and creation information
    DWORD           dwOleMiscFlags;                // control flags
    DWORD           dwActivationPolicy;            // IPointerInactive support
    VARIANT_BOOL    fOpaque;                       // is your control 100% opaque?
    VARIANT_BOOL    fWindowless;                   // do we do windowless if we can?
    WORD            wToolboxId;                    // resource ID of Toolbox Bitmap
    LPCSTR          szWndClass;                    // name of window control class
    VARIANT_BOOL    fWindowClassRegistered;        // has the window class been registered yet?
    WORD            cPropPages;                    // number of property pages
    const GUID    **rgPropPageGuids;               // array of the property page GUIDs
    WORD            cCustomVerbs;                  // number of custom verbs
    const VERBINFO *rgCustomVerbs;                 // description of custom verbs
    WNDPROC         pfnSubClass;                   // for subclassed controls.    
} CONTROLOBJECTINFO;


#ifndef INITOBJECTS

#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo,  w, szwc, cpp, rgppg, ccv, rgcv) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_CONTROLOBJECT2(name, clsid, progid, lblname, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_WINDOWLESSCONTROLOBJECT2(name, clsid, progid, lblname, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, fo,  w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_CONTROLOBJECT3(name, clsid, progid, lblname, precreatefn, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_WINDOWLESSCONTROLOBJECT3(name, clsid, progid, lblname, precreatefn, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, fo,  w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
extern CONTROLOBJECTINFO name##Control \

#else
#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, NULL, TRUE, fn, NULL}, ver, 0, riid, piide, pszh, NULL, 0}, dwcf, dwap, TRUE, FALSE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL} \

#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo, w, szwc, cpp, rgppg, ccv, rgcv) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, NULL, TRUE, fn, NULL}, ver, 0, riid, piide, pszh, NULL, 0}, dwcf, dwap, fo, TRUE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL} \

#define DEFINE_CONTROLOBJECT2(name, clsid, progid, lblname, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, lblname, fthreadsafe, fn, NULL}, ver, vermin, riid, piide, pszh, NULL, 0}, dwcf, dwap, TRUE, FALSE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL} \

#define DEFINE_WINDOWLESSCONTROLOBJECT2(name, clsid, progid, lblname, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, fo, w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, lblname, fthreadsafe, fn, NULL}, ver, vermin, riid, piide, pszh, NULL, 0}, dwcf, dwap, fo, TRUE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL} \

#define DEFINE_CONTROLOBJECT3(name, clsid, progid, lblname, precreatefn, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, lblname, fthreadsafe, fn, precreatefn}, ver, vermin, riid, piide, pszh, NULL, 0}, dwcf, dwap, TRUE, FALSE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL} \

#define DEFINE_WINDOWLESSCONTROLOBJECT3(name, clsid, progid, lblname, precreatefn, fn, ver, vermin, riid, pszh, piide, dwcf, dwap, fo, w, szwc, cpp, rgppg, ccv, rgcv, fthreadsafe) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, lblname, fthreadsafe, fn, precreatefn}, ver, vermin, riid, piide, pszh, NULL, 0}, dwcf, dwap, fo, TRUE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL} \

#endif // !INITOBJECTS

#define OLEMISCFLAGSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->dwOleMiscFlags
#define FCONTROLISWINDOWLESS(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fWindowless
#define FCONTROLISOPAQUE(index)          ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fOpaque
#define ACTIVATIONPOLICYOFCONTROL(index) ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->dwActivationPolicy
#define WNDCLASSNAMEOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->szWndClass
#define CPROPPAGESOFCONTROL(index)       ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->cPropPages
#define PPROPPAGESOFCONTROL(index)       ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->rgPropPageGuids
#define CCUSTOMVERBSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->cCustomVerbs
#define CUSTOMVERBSOFCONTROL(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->rgCustomVerbs
#define BITMAPIDOFCONTROL(index)         ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->wToolboxId
#define CTLWNDCLASSREGISTERED(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fWindowClassRegistered
#define SUBCLASSWNDPROCOFCONTROL(index)  ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->pfnSubClass

//=--------------------------------------------------------------------------=
// IControlPrv
//=--------------------------------------------------------------------------=
// Interface which allows you to access the COleControl class pointer to
// a control
//
interface IControlPrv : IUnknown
{
	STDMETHOD(GetControl)(COleControl **ppCOleControl) PURE;
};

//=--------------------------------------------------------------------------=
// COleControl
//=--------------------------------------------------------------------------=
// the mother of all C++ objects
//
class COleControl : public CAutomationObjectWEvents, 
                    public IOleObject, public IOleControl,
                    public IOleInPlaceObjectWindowless, public IOleInPlaceActiveObject,
                    public IViewObjectEx, public IPersistPropertyBag,
                    public IPersistStreamInit, public IPersistStorage,
                    public ISpecifyPropertyPages, public IProvideClassInfo,
                    public IPointerInactive, public IQuickActivate,
					public IControlPrv
{
  public:
    // IUnknown methods -- there are required since we inherit from variuos
    // people who themselves inherit from IUnknown.  just delegate to controlling
    // unknown
    //
    DECLARE_STANDARD_UNKNOWN();

    //=--------------------------------------------------------------------------=
    // IPersist methods.  used by IPersistStream and IPersistStorage
    //
    STDMETHOD(GetClassID)(THIS_ LPCLSID lpClassID);

    // IPersistStreamInit methods
    //
    STDMETHOD(IsDirty)(THIS);
    STDMETHOD(Load)(LPSTREAM pStm);
    STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* pcbSize);
    STDMETHOD(InitNew)();

    // IPersistStorage
    //
    STDMETHOD(InitNew)(IStorage  *pStg);
    STDMETHOD(Load)(IStorage  *pStg);
    STDMETHOD(Save)(IStorage  *pStgSave, BOOL fSameAsLoad);
    STDMETHOD(SaveCompleted)(IStorage  *pStgNew);
    STDMETHOD(HandsOffStorage)(void);

    // IPersistPropertyBag
    //
    STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                    BOOL fSaveAllProperties);

    // IOleControl methods
    //
    STDMETHOD(GetControlInfo)(LPCONTROLINFO pCI);
    STDMETHOD(OnMnemonic)(LPMSG pMsg);
    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);
    STDMETHOD(FreezeEvents)(BOOL bFreeze);

    // IOleObject methods
    //
    STDMETHOD(SetClientSite)(IOleClientSite  *pClientSite);
    STDMETHOD(GetClientSite)(IOleClientSite  * *ppClientSite);
    STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    STDMETHOD(Close)(DWORD dwSaveOption);
    STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker  *pmk);
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker  * *ppmk);
    STDMETHOD(InitFromData)(IDataObject  *pDataObject, BOOL fCreation, DWORD dwReserved);
    STDMETHOD(GetClipboardData)(DWORD dwReserved, IDataObject  * *ppDataObject);
    STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite  *pActiveSite, LONG lindex,
                                     HWND hwndParent, LPCRECT lprcPosRect);
    STDMETHOD(EnumVerbs)(IEnumOLEVERB  * *ppEnumOleVerb);
    STDMETHOD(Update)(void);
    STDMETHOD(IsUpToDate)(void);
    STDMETHOD(GetUserClassID)(CLSID  *pClsid);
    STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR  *pszUserType);
    STDMETHOD(SetExtent)(DWORD dwDrawAspect,SIZEL  *psizel);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL  *psizel);
    STDMETHOD(Advise)(IAdviseSink  *pAdvSink, DWORD  *pdwConnection);
    STDMETHOD(Unadvise)(DWORD dwConnection);
    STDMETHOD(EnumAdvise)(IEnumSTATDATA  * *ppenumAdvise);
    STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD  *pdwStatus);
    STDMETHOD(SetColorScheme)(LOGPALETTE  *pLogpal);

    // IOleWindow.  required for IOleInPlaceObject and IOleInPlaceActiveObject
    //
    STDMETHOD(GetWindow)(HWND *phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

    // IOleInPlaceObject/IOleInPlaceObjectWindowless
    //
    STDMETHOD(InPlaceDeactivate)(void);
    STDMETHOD(UIDeactivate)(void);
    STDMETHOD(SetObjectRects)(LPCRECT lprcPosRect,LPCRECT lprcClipRect) ;
    STDMETHOD(ReactivateAndUndo)(void);
    STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    STDMETHOD(GetDropTarget)(IDropTarget **ppDropTarget);

    // IOleInPlaceActiveObject
    //
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg);
    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate);
    STDMETHOD(OnDocWindowActivate)(BOOL fActivate);
    STDMETHOD(ResizeBorder)(LPCRECT prcBorder,
                            IOleInPlaceUIWindow  *pUIWindow,
                            BOOL fFrameWindow);
    STDMETHOD(EnableModeless)(BOOL fEnable);

    // IViewObject2/IViewObjectEx
    //
    STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void  *pvAspect,
                    DVTARGETDEVICE  *ptd, HDC hdcTargetDev, HDC hdcDraw,
                    LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                    BOOL ( __stdcall  *pfnContinue )(DWORD dwContinue),
                    DWORD dwContinue);
    STDMETHOD(GetColorSet)(DWORD dwDrawAspect,LONG lindex, void  *pvAspect,
                           DVTARGETDEVICE  *ptd, HDC hicTargetDev,
                           LOGPALETTE  * *ppColorSet);
    STDMETHOD(Freeze)(DWORD dwDrawAspect, LONG lindex,
                      void  *pvAspect,DWORD  *pdwFreeze);
    STDMETHOD(Unfreeze)(DWORD dwFreeze);
    STDMETHOD(SetAdvise)(DWORD aspects, DWORD advf, IAdviseSink  *pAdvSink);
    STDMETHOD(GetAdvise)(DWORD *pAspects, DWORD  *pAdvf, IAdviseSink  * *ppAdvSink);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, LONG lindex, DVTARGETDEVICE __RPC_FAR *ptd, LPSIZEL lpsizel);
    STDMETHOD(GetRect)(DWORD dwAspect, LPRECTL pRect);
    STDMETHOD(GetViewStatus)(DWORD *pdwStatus);
    STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG lCloseHint, DWORD *pHitResult);
    STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG lCloseHint, DWORD *pHitResult);
    STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG lindex, DVTARGETDEVICE *ptd, HDC hicTargetDev, DVEXTENTINFO *pExtentInfo, LPSIZEL psizel);

    // ISpecifyPropertyPages
    //
    STDMETHOD(GetPages)(CAUUID * pPages);

    // IProvideClassInfo methods
    //
    STDMETHOD(GetClassInfo)(LPTYPEINFO * ppTI);

    // IPointerInactive methods
    //
    STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy);
    STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg);
    STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways);

    // IQuickActivate methods
    //
    STDMETHOD(QuickActivate)(QACONTAINER *pqacontainer, QACONTROL *pqacontrol);
    STDMETHOD(SetContentExtent)(LPSIZEL);
    STDMETHOD(GetContentExtent)(LPSIZEL);

	// IControlPrv methods
	STDMETHOD(GetControl)(COleControl **pOleControl);

    // constructor and destructor
    //
    COleControl(IUnknown *pUnkOuter, int iPrimaryDispatch, void *pMainInterface);
    virtual ~COleControl();

    //=--------------------------------------------------------------------------=
    // callable by anybody
    //
    static LRESULT CALLBACK ControlWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    static LRESULT CALLBACK ReflectWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    static LRESULT CALLBACK ParkingWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

    // You can use this in any parent window to support message reflection 
    //
    static BOOL ReflectOcmMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *pLResult);

    static COleControl * ControlFromHwnd(HWND hwnd) {
        return (COleControl *) GetWindowLong(hwnd, GWL_USERDATA);
    }

    HINSTANCE    GetResourceHandle(void);

    //=--------------------------------------------------------------------------=
    // ole controls that want to support both windowed and windowless operations
    // should use these wrappers instead of the appropriate win32 api routine.
    // controls that don't care and just want to be windowed all the time can
    // just go ahead and use the api routines.
    //
    BOOL    SetFocus(BOOL fGrab);                       // SetFocus API
    BOOL    OcxGetFocus(void);                          // GetFocus() == m_hwnd
    BOOL    OcxGetWindowRect(LPRECT);                   // gets your current window rect
    LRESULT OcxDefWindowProc(UINT, WPARAM, LPARAM);     // DefWindowProc
    HDC     OcxGetDC(void);                             // GetDC(m_hwnd);
    void    OcxReleaseDC(HDC hdc);                      // ReleaseDC(m_hwnd, hdc);
    BOOL    OcxSetCapture(BOOL fGrab);                  // SetCapture(fGrab ? m_hwnd : NULL);
    BOOL    OcxGetCapture(void);                        // GetCapture() == m_hwnd
    BOOL    OcxInvalidateRect(LPCRECT, BOOL);           // InvalidateRect(m_hwnd, prc, f);
    BOOL    OcxScrollRect(LPCRECT, LPCRECT, int, int);  // ScrollWindowEx(...);

	// little routine for people to tell if they are windowless or not
    //
    inline BOOL  Windowless(void) {
        return !m_fInPlaceActive || m_pInPlaceSiteWndless;
    }

    // some people don't care if they're windowed or not -- they just need
    // a site pointer.  this makes it a little easier.
    //
    inline IOleInPlaceSite    *GetInPlaceSite(void) {
        return (IOleInPlaceSite *)(m_pInPlaceSiteWndless ? m_pInPlaceSiteWndless : m_pInPlaceSite);
	}

  protected:

    //=--------------------------------------------------------------------------=
    // member variables that derived controls can get at.
    //
    // derived controls Should NOT modify the following.
    //
    IOleClientSite     *m_pClientSite;             // client site
    IOleControlSite    *m_pControlSite;            // IOleControlSite ptr on client site
    IOleInPlaceSite    *m_pInPlaceSite;            // IOleInPlaceSite for managing activation
    IOleInPlaceFrame   *m_pInPlaceFrame;           // IOleInPlaceFrame ptr on client site
    IOleInPlaceUIWindow *m_pInPlaceUIWindow;       // for negotiating border space with client
    ISimpleFrameSite   *m_pSimpleFrameSite;        // simple frame site
    IDispatch          *m_pDispAmbient;            // ambient dispatch pointer
    SIZEL               m_Size;                    // the size of this control    
    RECT                m_rcLocation;              // where we at
    HWND                m_hwnd;                    // our window
    HWND                m_hwndParent;              // our parent window

    // You may need this if you override ::Save
    IOleAdviseHolder *m_pOleAdviseHolder;          // IOleObject::Advise holder object

    // Windowless OLE controls support
    //
    IOleInPlaceSiteWindowless *m_pInPlaceSiteWndless; // IOleInPlaceSiteWindowless pointer

    // flags indicating internal state.  do not modify.
    //
    unsigned m_fDirty:1;                           // does the control need to be resaved?
    unsigned m_fInPlaceActive:1;                   // are we in place active or not?
    unsigned m_fInPlaceVisible:1;                  // we are in place visible or not?
    unsigned m_fUIActive:1;                        // are we UI active or not.
    unsigned m_fCreatingWindow:1;                  // indicates if we're in CreateWindowEx or not
    unsigned m_fSaveSucceeded:1;                   // did an IStorage save work correctly?

    //=--------------------------------------------------------------------------=
    // methods that derived controls can override, but may need to be called
    // from their versions.
    //
    virtual void      ViewChanged(void);
    virtual HRESULT   InternalQueryInterface(REFIID riid, void **ppvObjOut);
    virtual void      BeforeDestroyObject(void);

    //=--------------------------------------------------------------------------=
    // member functions that provide for derived controls, or that we use, but
    // derived controls might still find useful.
    //
    HRESULT      DoSuperClassPaint(HDC, LPCRECTL);
    HRESULT      RecreateControlWindow(void);
    BOOL         DesignMode(void);
    BOOL         GetAmbientProperty(DISPID, VARTYPE, void *);
    BOOL         GetAmbientFont(IFont **ppFontOut);
    void         ModalDialog(BOOL fShow);
    void         InvalidateControl(LPCRECT prc);    
    BOOL         SetControlSize(SIZEL *pSizel);

    HWND         CreateInPlaceWindow(int x, int y, BOOL fNoRedraw);
    HRESULT      InPlaceActivate(LONG lVerb);
    void         SetInPlaceVisible(BOOL);
    void         SetInPlaceParent(HWND);

    // IPropertyNotifySink stuff.
    //
    inline void  PropertyChanged(DISPID dispid) {
        m_cpPropNotify.DoOnChanged(dispid);
    }
    inline BOOL  RequestPropertyEdit(DISPID dispid) {
        return m_cpPropNotify.DoOnRequestEdit(dispid);
    }

    // subclassed windows controls support ...
    //
    inline HWND  GetOuterWindow(void) {
        return (m_hwndReflect) ? m_hwndReflect : m_hwnd;
    }

  private:
    //=--------------------------------------------------------------------------=
    // the following are methods that ALL control writers must override and implement
    //
    STDMETHOD(LoadBinaryState)(IStream *pStream) PURE;
    STDMETHOD(SaveBinaryState)(IStream *pStream) PURE;
    STDMETHOD(LoadTextState)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog) PURE;
    STDMETHOD(SaveTextState)(IPropertyBag *pPropertyBag, BOOL fWriteDefault) PURE;
    STDMETHOD(OnDraw)(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize) PURE;
    virtual LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam) PURE;
    virtual BOOL    RegisterClassData(void) PURE;

    //=--------------------------------------------------------------------------=
    // OVERRIDABLES -- methods controls can implement for customized functionality
    //
    virtual void    AmbientPropertyChanged(DISPID dispid);
    virtual BOOL    BeforeCreateWindow(DWORD *, DWORD *, LPSTR);
    virtual void    BeforeDestroyWindow(void);
    virtual HRESULT DoCustomVerb(LONG lVerb);
    virtual BOOL    OnSetExtent(SIZEL *pSizeL);
    virtual BOOL    OnSpecialKey(LPMSG);
    virtual BOOL    OnGetPalette(HDC, LOGPALETTE **);
    virtual HRESULT OnQuickActivate(QACONTAINER *, DWORD *);
    virtual BOOL    InitializeNewState();
    virtual BOOL    AfterCreateWindow(void);
    virtual BOOL    OnGetRect(DWORD dvAspect, LPRECTL prcRect);
    virtual HRESULT OnSetClientSite(void);

    //=--------------------------------------------------------------------------=
    // methods that various people internally will share.  not needed, however, by
    // any inherting classes.
    //
    HRESULT         m_SaveToStream(IStream *pStream);
    HRESULT         LoadStandardState(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);
    HRESULT         LoadStandardState(IStream *pStream);
    HRESULT         SaveStandardState(IPropertyBag *pPropertyBag);
    HRESULT         SaveStandardState(IStream *pStream);

    //=--------------------------------------------------------------------------=
    // member variables we don't want anybody to get their hands on, including
    // inheriting classes
    //
    HWND              m_hwndReflect;               // for subclassed windows
    IAdviseSink      *m_pViewAdviseSink;           // IViewAdvise sink for IViewObject2
    unsigned          m_fHostReflects:1;           // does the host reflect messages?
    unsigned          m_fCheckedReflecting:1;      // have we checked above yet?

    // internal flags.  various other flags are visible to the end control class.
    //
    unsigned m_fModeFlagValid:1;                   // we stash the mode as much as possible
    unsigned m_fViewAdvisePrimeFirst: 1;           // for IViewobject2::setadvise
    unsigned m_fViewAdviseOnlyOnce: 1;             // for iviewobject2::setadvise
    unsigned m_fUsingWindowRgn:1;                  // for SetObjectRects and clipping
    unsigned m_fRunMode:1;                         // are we in run mode or not?
    unsigned m_fChangingExtents:1;		   // Prevent recursive SetExtent calls

};

#define _CONTROLOBJECT_H_
#endif // _CONTROLOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\datapath.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0101 */
/* at Wed May 22 16:53:08 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __datapath_h__
#define __datapath_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IBindHost_FWD_DEFINED__
#define __IBindHost_FWD_DEFINED__
typedef interface IBindHost IBindHost;
#endif 	/* __IBindHost_FWD_DEFINED__ */


#ifndef __IObjectWithSite_FWD_DEFINED__
#define __IObjectWithSite_FWD_DEFINED__
typedef interface IObjectWithSite IObjectWithSite;
#endif 	/* __IObjectWithSite_FWD_DEFINED__ */


#ifndef __IDataPathBrowser_FWD_DEFINED__
#define __IDataPathBrowser_FWD_DEFINED__
typedef interface IDataPathBrowser IDataPathBrowser;
#endif 	/* __IDataPathBrowser_FWD_DEFINED__ */


#ifndef __IProvideClassInfo3_FWD_DEFINED__
#define __IProvideClassInfo3_FWD_DEFINED__
typedef interface IProvideClassInfo3 IProvideClassInfo3;
#endif 	/* __IProvideClassInfo3_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "oaidl.h"
#include "olectl.h"
#include "urlmon.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: datapath.h

#pragma comment(lib,"uuid3.lib")
//
//--------------------------------------------------------------------------
			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

#include "idispids.h"
typedef BSTR OLE_DATAPATH;
#define SID_SDataPathBrowser IID_IDataPathBrowser
#define SID_IBindHost IID_IBindHost
#define SID_SBindHost IID_IBindHost

////////////////////////////////////////////////////////////////////////////
//  State values for the DISPID_READYSTATE property
			/* size is 4 */

enum __MIDL___MIDL__intf_0000_0001
    {	READYSTATE_UNINITIALIZED	= 1,
	READYSTATE_LOADING	= 0,
	READYSTATE_LOADED	= 2,
	READYSTATE_INTERACTIVE	= 3,
	READYSTATE_COMPLETE	= 4
    };

////////////////////////////////////////////////////////////////////////////
//  DataPath GUIDs (link to uuid3.lib)
EXTERN_C const GUID OLE_DATAPATH_BMP;
EXTERN_C const GUID OLE_DATAPATH_DIB;
EXTERN_C const GUID OLE_DATAPATH_WMF;
EXTERN_C const GUID OLE_DATAPATH_ENHMF;
EXTERN_C const GUID OLE_DATAPATH_GIF;
EXTERN_C const GUID OLE_DATAPATH_JPEG;
EXTERN_C const GUID OLE_DATAPATH_TIFF;
EXTERN_C const GUID OLE_DATAPATH_XBM;
EXTERN_C const GUID OLE_DATAPATH_PCX;
EXTERN_C const GUID OLE_DATAPATH_PICT;
EXTERN_C const GUID OLE_DATAPATH_CGM;
EXTERN_C const GUID OLE_DATAPATH_EPS;
EXTERN_C const GUID OLE_DATAPATH_COMMONIMAGE;
EXTERN_C const GUID OLE_DATAPATH_ALLIMAGE;
EXTERN_C const GUID OLE_DATAPATH_AVI;
EXTERN_C const GUID OLE_DATAPATH_MPEG;
EXTERN_C const GUID OLE_DATAPATH_QUICKTIME;
EXTERN_C const GUID OLE_DATAPATH_BASICAUDIO;
EXTERN_C const GUID OLE_DATAPATH_MIDI;
EXTERN_C const GUID OLE_DATAPATH_WAV;
EXTERN_C const GUID OLE_DATAPATH_RIFF;
EXTERN_C const GUID OLE_DATAPATH_SOUND;
EXTERN_C const GUID OLE_DATAPATH_VIDEO;
EXTERN_C const GUID OLE_DATAPATH_ALLMM;
EXTERN_C const GUID OLE_DATAPATH_ANSITEXT;
EXTERN_C const GUID OLE_DATAPATH_UNICODE;
EXTERN_C const GUID OLE_DATAPATH_RTF;
EXTERN_C const GUID OLE_DATAPATH_HTML;
EXTERN_C const GUID OLE_DATAPATH_POSTSCRIPT;
EXTERN_C const GUID OLE_DATAPATH_ALLTEXT;
EXTERN_C const GUID OLE_DATAPATH_DIF;
EXTERN_C const GUID OLE_DATAPATH_SYLK;
EXTERN_C const GUID OLE_DATAPATH_BIFF;
EXTERN_C const GUID OLE_DATAPATH_PALETTE;
EXTERN_C const GUID OLE_DATAPATH_PENDATA;
////////////////////////////////////////////////////////////////////////////

EXTERN_C const GUID FLAGID_Internet;
EXTERN_C const GUID GUID_PathProperty;
EXTERN_C const GUID GUID_HasPathProperties;

////////////////////////////////////////////////////////////////////////////
//  ARRAYID GUIDs (link to uuid3.lib)
EXTERN_C const GUID ARRAYID_PathProperties;

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPBINDHOST_DEFINED
#define _LPBINDHOST_DEFINED
EXTERN_C const GUID SID_BindHost;


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IBindHost_INTERFACE_DEFINED__
#define __IBindHost_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBindHost
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IBindHost __RPC_FAR *LPBINDHOST;


EXTERN_C const IID IID_IBindHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IBindHost : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateMoniker( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT __stdcall MonikerBindToStorage( 
            /* [in] */ IMoniker __RPC_FAR *pMk,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj) = 0;
        
        virtual HRESULT __stdcall MonikerBindToObject( 
            /* [in] */ IMoniker __RPC_FAR *pMk,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindHostVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IBindHost __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IBindHost __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IBindHost __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *CreateMoniker )( 
            IBindHost __RPC_FAR * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( __stdcall __RPC_FAR *MonikerBindToStorage )( 
            IBindHost __RPC_FAR * This,
            /* [in] */ IMoniker __RPC_FAR *pMk,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);
        
        HRESULT ( __stdcall __RPC_FAR *MonikerBindToObject )( 
            IBindHost __RPC_FAR * This,
            /* [in] */ IMoniker __RPC_FAR *pMk,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);
        
    } IBindHostVtbl;

    interface IBindHost
    {
        CONST_VTBL struct IBindHostVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBindHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBindHost_CreateMoniker(This,szName,pBC,ppmk,dwReserved)	\
    (This)->lpVtbl -> CreateMoniker(This,szName,pBC,ppmk,dwReserved)

#define IBindHost_MonikerBindToStorage(This,pMk,pBC,pBSC,riid,ppvObj)	\
    (This)->lpVtbl -> MonikerBindToStorage(This,pMk,pBC,pBSC,riid,ppvObj)

#define IBindHost_MonikerBindToObject(This,pMk,pBC,pBSC,riid,ppvObj)	\
    (This)->lpVtbl -> MonikerBindToObject(This,pMk,pBC,pBSC,riid,ppvObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IBindHost_CreateMoniker_Proxy( 
    IBindHost __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ IBindCtx __RPC_FAR *pBC,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IBindHost_CreateMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindHost_MonikerBindToStorage_Proxy( 
    IBindHost __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pMk,
    /* [in] */ IBindCtx __RPC_FAR *pBC,
    /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);


void __RPC_STUB IBindHost_MonikerBindToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindHost_MonikerBindToObject_Proxy( 
    IBindHost __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pMk,
    /* [in] */ IBindCtx __RPC_FAR *pBC,
    /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);


void __RPC_STUB IBindHost_MonikerBindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindHost_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0100
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPOBJECTWITHSITE_DEFINED
#define _LPOBJECTWITHSITE_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0100_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0100_v0_0_s_ifspec;

#ifndef __IObjectWithSite_INTERFACE_DEFINED__
#define __IObjectWithSite_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectWithSite
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][object][uuid] */ 


			/* size is 4 */
typedef /* [unique] */ IObjectWithSite __RPC_FAR *LPOBJECTWITHSITE;


EXTERN_C const IID IID_IObjectWithSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IObjectWithSite : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetSite( 
            /* [in] */ IUnknown __RPC_FAR *pUnkSite) = 0;
        
        virtual HRESULT __stdcall GetSite( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvSite) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithSiteVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IObjectWithSite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IObjectWithSite __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IObjectWithSite __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SetSite )( 
            IObjectWithSite __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkSite);
        
        HRESULT ( __stdcall __RPC_FAR *GetSite )( 
            IObjectWithSite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvSite);
        
    } IObjectWithSiteVtbl;

    interface IObjectWithSite
    {
        CONST_VTBL struct IObjectWithSiteVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectWithSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectWithSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectWithSite_SetSite(This,pUnkSite)	\
    (This)->lpVtbl -> SetSite(This,pUnkSite)

#define IObjectWithSite_GetSite(This,riid,ppvSite)	\
    (This)->lpVtbl -> GetSite(This,riid,ppvSite)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IObjectWithSite_SetSite_Proxy( 
    IObjectWithSite __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkSite);


void __RPC_STUB IObjectWithSite_SetSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IObjectWithSite_GetSite_Proxy( 
    IObjectWithSite __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvSite);


void __RPC_STUB IObjectWithSite_GetSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectWithSite_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0101
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPDATAPATHBROWSER_DEFINED
#define _LPDATAPATHBROWSER_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0101_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0101_v0_0_s_ifspec;

#ifndef __IDataPathBrowser_INTERFACE_DEFINED__
#define __IDataPathBrowser_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDataPathBrowser
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][object][local][uuid] */ 



EXTERN_C const IID IID_IDataPathBrowser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDataPathBrowser : public IUnknown
    {
    public:
        virtual HRESULT __stdcall BrowseType( 
            /* [in] */ REFGUID rguidPathType,
            /* [in] */ LPOLESTR pszDefaultPath,
            /* [in] */ ULONG cchPath,
            /* [size_is][out] */ LPOLESTR pszPath,
            /* [in] */ HWND hWnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataPathBrowserVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IDataPathBrowser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IDataPathBrowser __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IDataPathBrowser __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *BrowseType )( 
            IDataPathBrowser __RPC_FAR * This,
            /* [in] */ REFGUID rguidPathType,
            /* [in] */ LPOLESTR pszDefaultPath,
            /* [in] */ ULONG cchPath,
            /* [size_is][out] */ LPOLESTR pszPath,
            /* [in] */ HWND hWnd);
        
    } IDataPathBrowserVtbl;

    interface IDataPathBrowser
    {
        CONST_VTBL struct IDataPathBrowserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataPathBrowser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataPathBrowser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataPathBrowser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataPathBrowser_BrowseType(This,rguidPathType,pszDefaultPath,cchPath,pszPath,hWnd)	\
    (This)->lpVtbl -> BrowseType(This,rguidPathType,pszDefaultPath,cchPath,pszPath,hWnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IDataPathBrowser_BrowseType_Proxy( 
    IDataPathBrowser __RPC_FAR * This,
    /* [in] */ REFGUID rguidPathType,
    /* [in] */ LPOLESTR pszDefaultPath,
    /* [in] */ ULONG cchPath,
    /* [size_is][out] */ LPOLESTR pszPath,
    /* [in] */ HWND hWnd);


void __RPC_STUB IDataPathBrowser_BrowseType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataPathBrowser_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0102
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPPROVIDECLASSINFO3_DEFINED
#define _LPPROVIDECLASSINFO3_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0102_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0102_v0_0_s_ifspec;

#ifndef __IProvideClassInfo3_INTERFACE_DEFINED__
#define __IProvideClassInfo3_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideClassInfo3
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IProvideClassInfo3 __RPC_FAR *LPPROVIDECLASSINFO3;

			/* size is 4 */

enum __MIDL_IProvideClassInfo3_0001
    {	INTERNETFLAG_USESDATAPATHS	= 0x1
    };

EXTERN_C const IID IID_IProvideClassInfo3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideClassInfo3 : public IProvideClassInfo2
    {
    public:
        virtual HRESULT __stdcall GetGUIDDwordArrays( 
            /* [in] */ REFGUID rguidArray,
            /* [out][in] */ CAUUID __RPC_FAR *pcaUUID,
            /* [out][in] */ CADWORD __RPC_FAR *pcadw) = 0;
        
        virtual HRESULT __stdcall GetClassInfoLocale( 
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppITypeInfo,
            /* [in] */ LCID lcid) = 0;
        
        virtual HRESULT __stdcall GetFlags( 
            /* [in] */ REFGUID guidGroup,
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideClassInfo3Vtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IProvideClassInfo3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IProvideClassInfo3 __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IProvideClassInfo3 __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassInfo )( 
            IProvideClassInfo3 __RPC_FAR * This,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTI);
        
        HRESULT ( __stdcall __RPC_FAR *GetGUID )( 
            IProvideClassInfo3 __RPC_FAR * This,
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
        HRESULT ( __stdcall __RPC_FAR *GetGUIDDwordArrays )( 
            IProvideClassInfo3 __RPC_FAR * This,
            /* [in] */ REFGUID rguidArray,
            /* [out][in] */ CAUUID __RPC_FAR *pcaUUID,
            /* [out][in] */ CADWORD __RPC_FAR *pcadw);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassInfoLocale )( 
            IProvideClassInfo3 __RPC_FAR * This,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppITypeInfo,
            /* [in] */ LCID lcid);
        
        HRESULT ( __stdcall __RPC_FAR *GetFlags )( 
            IProvideClassInfo3 __RPC_FAR * This,
            /* [in] */ REFGUID guidGroup,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
    } IProvideClassInfo3Vtbl;

    interface IProvideClassInfo3
    {
        CONST_VTBL struct IProvideClassInfo3Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideClassInfo3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideClassInfo3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideClassInfo3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideClassInfo3_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)


#define IProvideClassInfo3_GetGUID(This,dwGuidKind,pGUID)	\
    (This)->lpVtbl -> GetGUID(This,dwGuidKind,pGUID)


#define IProvideClassInfo3_GetGUIDDwordArrays(This,rguidArray,pcaUUID,pcadw)	\
    (This)->lpVtbl -> GetGUIDDwordArrays(This,rguidArray,pcaUUID,pcadw)

#define IProvideClassInfo3_GetClassInfoLocale(This,ppITypeInfo,lcid)	\
    (This)->lpVtbl -> GetClassInfoLocale(This,ppITypeInfo,lcid)

#define IProvideClassInfo3_GetFlags(This,guidGroup,pdwFlags)	\
    (This)->lpVtbl -> GetFlags(This,guidGroup,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IProvideClassInfo3_GetGUIDDwordArrays_Proxy( 
    IProvideClassInfo3 __RPC_FAR * This,
    /* [in] */ REFGUID rguidArray,
    /* [out][in] */ CAUUID __RPC_FAR *pcaUUID,
    /* [out][in] */ CADWORD __RPC_FAR *pcadw);


void __RPC_STUB IProvideClassInfo3_GetGUIDDwordArrays_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IProvideClassInfo3_GetClassInfoLocale_Proxy( 
    IProvideClassInfo3 __RPC_FAR * This,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppITypeInfo,
    /* [in] */ LCID lcid);


void __RPC_STUB IProvideClassInfo3_GetClassInfoLocale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IProvideClassInfo3_GetFlags_Proxy( 
    IProvideClassInfo3 __RPC_FAR * This,
    /* [in] */ REFGUID guidGroup,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IProvideClassInfo3_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideClassInfo3_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0103
 * at Wed May 22 16:53:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL__intf_0103_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0103_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\btree.h ===
#ifndef BTREE_H
#define BTREE_H

//------------------
//  BTreePage
//  	A BTree page
//------------------

struct PageHeader
{
    long Order;    // maximum # of page  links in page
    long MaxKeys;  // maximum # of keys  in page
    long MinKeys;  // minimum # of keys  in page
    long NoOfKeys; // actual  # of keys  in page
    long KeySize;  // maximum # of bytes in a key
};

template <class K, class D>
struct BTreeNode
{
    K  m_Key;
    const D * m_pData;
    ULONG m_ulHash;
    BTreeNode<K, D> * m_pNext;

    BTreeNode();
    BTreeNode(const K& Key, const D* data);
    ~BTreeNode();

    void operator = (const BTreeNode& node);
};

template <class K, class D>
BTreeNode<K,D>::BTreeNode() :
m_pData(NULL),
m_pNext(NULL),
m_ulHash(0)
{
}

template <class K, class D>
BTreeNode<K,D>::BTreeNode(const K& Key, const D* pdata) :
m_pData(pdata),
m_pNext(NULL)
{
    m_Key = Key;
    m_ulHash = Hash(Key);
}

template <class K, class D>
BTreeNode<K,D>::~BTreeNode()
{
    m_pNext = NULL;
}

template <class K, class D>
void BTreeNode<K,D>::operator=(const BTreeNode& node)
{
    m_Key = node.m_Key;
    m_pData = node.m_pData;
    m_ulHash = node.m_ulHash;
    m_pNext = node.m_pNext;
}

template <class K, class D>
struct BTreePage
{
    PageHeader m_hdr;    // header information
    BTreeNode<K,D> * m_pNodes;
    BTreePage<K,D>** m_ppLinks;

    BTreePage<K,D>*  m_pParent;
    BTreePage(long ord);
    BTreePage(const BTreePage & p);
    ~BTreePage();
    void operator = (const BTreePage & page);
    void DeleteAllNodes();
    void CopyNodes(BTreeNode<K,D>* pDestNodes, BTreeNode<K,D>* pSrcNodes, long cnt);
};

template <class K, class D> 
BTreePage<K,D>::BTreePage(long ord)
{

    m_hdr.Order     = ord;
    m_hdr.MaxKeys   = ord - 1;
    m_hdr.MinKeys   = ord / 2;
    m_hdr.NoOfKeys  = 0;
    m_hdr.KeySize   = sizeof(K);

    if (m_hdr.Order == 0)
    {
        m_pNodes = NULL;
        m_ppLinks = NULL;
        return;
    }

    // allocate key array
    m_pNodes = new BTreeNode<K,D> [m_hdr.MaxKeys];

    ASSERT(m_pNodes, "Couldn't allocate nodes array!");

    memset(m_pNodes,0,m_hdr.MaxKeys * sizeof(BTreeNode<K,D>));

    m_ppLinks = new BTreePage<K,D>*[m_hdr.MaxKeys + 1];

    ASSERT(m_ppLinks, "Couldn't allocate limks array!");

    memset(m_ppLinks,0,((m_hdr.MaxKeys + 1)* sizeof(BTreePage<K,D>*)));

    m_pParent = NULL;
}
	
template <class K, class D>
BTreePage<K, D>::BTreePage(const BTreePage<K,D> & pg)
{
    m_hdr = pg.m_hdr;

    // allocate key array
    m_pNodes = new BTreeNode<K,D>[m_hdr.MaxKeys];

    ASSERT(m_pNodes, "Couldn't allocate nodes array!");

    CopyNodes(m_pNodes, pg.m_pNodes, m_hdr.Order);

    for (int i = 0; i < m_hdr.MaxKeys + 1; i++)
        m_ppLinks[i] = pg.m_ppLinks[i];

    m_pParent = pg.m_pParent;
}
	
template <class K, class D>
BTreePage<K, D>::~BTreePage()
{
    // delete old buffers
    DeleteAllNodes();
    
    delete [] m_ppLinks;
}
	
template <class K, class D>
void BTreePage<K,D>::operator = (const BTreePage<K,D> & pg)
{

    // allocate key array
    if (m_pNodes!= NULL)
        DeleteAllNodes();

    m_pNodes = new BTreeNode<K,D> [pg.m_hdr.MaxKeys];

    ASSERT(m_pNodes, "Couldn't allocate nodes array!");

    if (m_ppLinks)
        delete [] m_ppLinks;

    m_ppLinks = new BTreePage<K,D>*[pg.m_hdr.MaxKeys + 1];

    ASSERT(m_ppLinks, "Couldn't allocate links array!");

    m_hdr = pg.m_hdr;

    CopyNodes(m_pNodes, pg.m_pNodes, m_hdr.Order);


    for (int i = 0; i < m_hdr.MaxKeys + 1; i++)
        m_ppLinks[i] = pg.m_ppLinks[i];

    m_pParent = pg.m_pParent;
}

template <class K, class D>
void BTreePage<K,D>::DeleteAllNodes()
{
    for (int i = 0; i < m_hdr.NoOfKeys; i++)
    {
        BTreeNode<K,D>* pIndex = m_pNodes[i].m_pNext;

        while(pIndex)
        {
            BTreeNode<K,D>* pDel = pIndex;
            pIndex = pIndex->m_pNext;
            delete pDel;
        }

    }

    delete [] m_pNodes;
    m_pNodes = NULL;
}

template <class K, class D>
void BTreePage<K,D>::CopyNodes(BTreeNode<K,D>* pDestNodes, BTreeNode<K,D>* pSrcNodes, long cnt)
{
    for (int i = 0; i < cnt; i++)
    {
        pDestNodes[i] = pSrcNodes[i];
        BTreeNode<K,D>* pSrcIndex = pSrcNodes[i].m_pNext;
        BTreeNode<K,D>* pDestIndex = pDestNodes;

        while(pSrcIndex)
        {
            pDestIndex->m_pNext = new BTreeNode<K,D>(*pSrcIndex);
            pSrcIndex = pSrcIndex->m_pNext;
            pDestIndex = pDestIndex->m_pNext;
        }
    }
}

//-----------------------------------------------
//  BTree
//      A DataFile that uses a BTree for indexing
//      NOTE: No copy semantics will exist for a btree
//-----------------------------------------------

template <class K, class D>
	class BTree
{
public:
    BTree(long ord); // new
    BTree(long ord, int (*compare)(const K& key1, const K& key2));

    ~BTree();

    void Insert(const K & key, const D* data);
    const D* Get(const K & key);
    void Delete(const K & key);
    void InOrder(void (* func)(const K & key, const D* pdata, int depth, int index));
    void Clear();

private:
    // data members
    BTreePage<K,D>*    m_pRoot;   // root page (always in memory)

    void (* TravFunc)(const K & key, const D* pdata, int depth, int index);
    int (*CompFunc) (const K& key1, const K& key2);

    // search for a node
    BOOL Search(BTreePage<K,D>* ppg, const ULONG& thash, const K& searchkey, BTreePage<K,D>** ppkeypage, long & pos);

    // insert node into leaf
    void InsertKey(const K & inskey, const D* pdata);

    // promote a key into a parent node
    void PromoteInternal(BTreePage<K, D>* ppg, BTreeNode<K,D> & node, BTreePage<K, D>* pgrtrpage);

    // promote a key by creating a new root
    void PromoteRoot(BTreeNode<K,D> & node, BTreePage<K, D>* plesspage, BTreePage<K, D>* pgrtrpage);

    // adjust tree if leaf has shrunk in size
    void AdjustTree(BTreePage<K, D>* pleafpg);

    // redistribute keys among siblings and parent
    void Redistribute(long keypos, BTreePage<K, D>* plesspage, BTreePage<K, D>* pparpage, BTreePage<K, D>* pgrtrpage);

    // concatenate sibling pages
    void Concatenate(long keypos, BTreePage<K, D>* plesspage, BTreePage<K, D>* pparpage, BTreePage<K, D>* pgrtrpage);

    // recursive traversal function used by InOrder
    void RecurseTraverse(const BTreePage<K, D>* ppg, int depth);

    // recursively delete a page and all it's sub pages;
    void DeletePage(BTreePage<K,D>* ppg);
};
	
template <class K, class D>
BTree<K,D>::BTree(long ord)
{
    CompFunc  = NULL;
    m_pRoot = new BTreePage<K,D>(ord);
}
	
template <class K, class D>
BTree<K,D>::BTree(long ord, int (*comp)(const K& key1, const K& key2))
{
    CompFunc  = comp;
    m_pRoot = new BTreePage<K,D>(ord);
}
	
template <class K, class D>
BTree<K,D>::~BTree()
{
    DeletePage(m_pRoot);
}
	
template <class K, class D>
void BTree<K,D>::Insert(const K & key, const D* pdb)
{
    // store the key in a page
    InsertKey(key,pdb);
}
    
template <class K, class D>
const D* BTree<K,D>::Get(const K & key)
{

    BTreePage<K,D>* pgetpage = NULL;
    long  getpos;

    if (Search(m_pRoot, Hash(key), key, &pgetpage, getpos))
    {
        BOOL found = FALSE;

        BTreeNode<K,D>* pnode = &pgetpage->m_pNodes[getpos];

	if (CompFunc)
	{
          while(pnode && !found)
          {
              if (CompFunc(key, pnode->m_Key) == 0)
              {
                  found = TRUE;
                  return pnode->m_pData;
              }

              pnode = pnode->m_pNext;
	  }
	}
	else
	{
          while(pnode && !found)
          {
              if (key == pnode->m_Key)
              {
                  found = TRUE;
                  return pnode->m_pData;
              }

              pnode = pnode->m_pNext;
	  }
        }

    }
    else
    {
        return NULL;
    }

    return NULL;
}

template <class K, class D>
void BTree<K,D>::Delete(const K & delkey)
{

    BTreePage<K,D>* pdelpage = NULL;
    long delpos;

    if (!Search(m_pRoot, Hash(delkey), delkey, &pdelpage, delpos))
    {
        return;
    }

    if (!pdelpage->m_ppLinks[0]) // is this a leaf page?
    {
        //Delete all linked nodes.
        BOOL bFound = FALSE;
        BOOL bDelNode = FALSE;
        BTreeNode<K,D>* pDelNode = (pdelpage->m_pNodes + delpos);
        BTreeNode<K,D>* pIndex = pDelNode;

        while(pDelNode && !bFound)
        {
            if ((CompFunc  && (CompFunc(delkey, pDelNode->m_Key) == 0)) ||
		(!CompFunc && (delkey == pDelNode->m_Key)))
            {
                //If the node we need to delete is the head node in the list AND it's the only node
                //then we need to skip to the routine below to delete it from the tree.
                // + delpos
                if (pDelNode == (pdelpage->m_pNodes + delpos))
                {
                    if (!pDelNode->m_pNext)
                    {
                        bDelNode = TRUE;
                    }
                    else
                    {
                        pDelNode = pDelNode->m_pNext;
                        *pIndex = *pDelNode;
                        delete pDelNode;
                        pDelNode = NULL;
                    }
                }
                else
                {
                    pIndex->m_pNext = pDelNode->m_pNext;
                    delete pDelNode;
                    pDelNode = NULL;
                }

                bFound = TRUE;
            }
            else
            {
                pIndex = pDelNode;
                pDelNode = pDelNode->m_pNext;
            }

        }

        if (bDelNode)
        {
            --pdelpage->m_hdr.NoOfKeys;

            // remove key from leaf
	    for (long n = delpos; n < pdelpage->m_hdr.NoOfKeys; ++n)
            {
                pdelpage->m_pNodes[n] = pdelpage->m_pNodes[n + 1];
            }

            memset((void*)&pdelpage->m_pNodes[pdelpage->m_hdr.NoOfKeys], 0, sizeof(BTreeNode<K,D>));


            // adjust tree
	    if (pdelpage->m_hdr.NoOfKeys < pdelpage->m_hdr.MinKeys)
                AdjustTree(pdelpage);
        }
    }
    else // delpage is internal
    {
        // replace deleted key with immediate successor
        BTreePage<K,D>* psucpage = NULL;

        // find successor
        psucpage = pdelpage->m_ppLinks[delpos + 1];

        while (psucpage->m_ppLinks[0])
            psucpage = psucpage->m_ppLinks[0];

        
        //Delete all linked nodes.
        BOOL bFound = FALSE;
        BOOL bDelNode = FALSE;
        BTreeNode<K,D>* pDelNode = (pdelpage->m_pNodes + delpos);
        BTreeNode<K,D>* pIndex = pDelNode;

        while(pDelNode && !bFound)
        {
            if ((CompFunc  && (CompFunc(delkey, pDelNode->m_Key) == 0)) ||
		(!CompFunc && (delkey == pDelNode->m_Key)))
            {
                //If the node we need to delete is the head node in the list AND it's the only node
                //then we need to skip to the routine below to delete it from the tree.
                if (pDelNode == (pdelpage->m_pNodes + delpos))
                {
                    if (!pDelNode->m_pNext)
                    {
                        bDelNode = TRUE;
                    }
                    else
                    {
                        pDelNode = pDelNode->m_pNext;
                        pdelpage->m_pNodes[delpos].operator=(*pDelNode);
                        delete pDelNode;
                    }
                }
                else
                {
                    pIndex->m_pNext = pDelNode->m_pNext;
                    delete pDelNode;
                    pDelNode = NULL;
                }

                bFound = TRUE;
            }
            else
            {
                pIndex = pDelNode;
                pDelNode = pDelNode->m_pNext;
            }
        }

        if (bDelNode)
        {
            // first key is the "swappee"
            pdelpage->m_pNodes[delpos] = psucpage->m_pNodes[0];

            // deleted swapped key from sucpage
            --psucpage->m_hdr.NoOfKeys;

            for (long n = 0; n < psucpage->m_hdr.NoOfKeys; ++n)
    	    {
                psucpage->m_pNodes[n] = psucpage->m_pNodes[n + 1];
                psucpage->m_ppLinks[n + 1] = psucpage->m_ppLinks[n + 2];
            }

            memset((void*)&psucpage->m_pNodes[psucpage->m_hdr.NoOfKeys], 0, sizeof(BTreeNode<K,D>));

            psucpage->m_ppLinks[psucpage->m_hdr.NoOfKeys + 1] = NULL;


	        // adjust tree for leaf node
            if (psucpage->m_hdr.NoOfKeys < psucpage->m_hdr.MinKeys)
                AdjustTree(psucpage);
        }
    }
}
    
template <class K, class D>
void BTree<K,D>::InOrder(void (* func)(const K & key, const D* pdata, int depth, int index))
{
    // save the address of the function to call
    TravFunc = func;

    // recurse the tree
    RecurseTraverse(m_pRoot, 0);

}

template <class K, class D>
void BTree<K,D>::Clear()
{
    DeletePage(m_pRoot);
}
    
template <class K, class D>
BOOL BTree<K,D>::Search(BTreePage<K,D>* ppg, const ULONG& thash, const K& searchkey, BTreePage<K,D>** ppkeypage, long & pos)
{
    BOOL result;
    pos = 0;

    for (;;)
    {
        if (pos == ppg->m_hdr.NoOfKeys)
            goto getpage;

        if (ppg->m_pNodes[pos].m_ulHash == thash)
        {
            *ppkeypage = (BTreePage<K,D>*)ppg;
            result = TRUE;
            break;
        }
        else
        {
            if (ppg->m_pNodes[pos].m_ulHash < thash)
               ++pos;
            else
            {
                // I know this is a label -- so shoot me!
getpage:

                // if we're in a leaf page, key wasn't found
                if (!ppg->m_ppLinks[pos])
                {
                    *ppkeypage = (BTreePage<K,D>*)ppg;
                    result  = FALSE;
                }
                else
                {
      	            result = Search(ppg->m_ppLinks[pos],thash, searchkey,ppkeypage,pos);
                }

                break;
            }
        }
    }

    return result;
}

template <class K, class D>
void BTree<K,D>::InsertKey(const K & inskey, const D* pdata)
{
    BTreePage<K,D>* pinspage = NULL;
    long inspos;
    BTreeNode<K,D> newnode(inskey, pdata);

    BOOL bFound = Search(m_pRoot,Hash(inskey), inskey,&pinspage,inspos);

    if (bFound)
    {
        BOOL found = FALSE;

        BTreeNode<K,D>* pnode = &(pinspage->m_pNodes[inspos]);
        BTreeNode<K,D>* pparent = NULL;

	if (CompFunc != NULL)
	{
	    while(pnode && !found)
	    {
                if (CompFunc(inskey, pnode->m_Key) == 0)
		{
		    found = TRUE;
		}
        
		pparent = pnode;
		pnode = pnode->m_pNext;
	    }
	}
	else
	{
	    while(pnode && !found)
	    {
                if (inskey == pnode->m_Key)
		{
		    found = TRUE;
		}
        
		pparent = pnode;
		pnode = pnode->m_pNext;
	    }
        }

        if (found)
        {
            return;
        }
    
        pparent->m_pNext = new BTreeNode<K,D>(inskey, pdata);

    }
    else
    {
        if (pinspage->m_hdr.NoOfKeys == pinspage->m_hdr.MaxKeys)
        {
            // temporary arrays
            BTreeNode<K,D>* ptempkeys = new BTreeNode<K,D>[pinspage->m_hdr.MaxKeys + 1];

            // copy entries from inspage to temporaries
            long nt = 0; // index into temporaries
            long ni = 0; // index into inspage

            ptempkeys[inspos] = newnode;

            while (ni < pinspage->m_hdr.MaxKeys)
            {
                if (ni == inspos)
                ++nt;

                ptempkeys[nt] = pinspage->m_pNodes[ni];

                ++ni;
                ++nt;
            }

            // generate a new leaf node
            BTreePage<K,D>* psibpage = new BTreePage<K,D>(pinspage->m_hdr.Order);
            psibpage->m_pParent = pinspage->m_pParent;

            // clear # of keys in pages
            pinspage->m_hdr.NoOfKeys = 0;
            psibpage->m_hdr.NoOfKeys = 0;

            // copy appropriate keys from temp to pages
            for (ni = 0; ni < pinspage->m_hdr.MinKeys; ++ni)
            {
                pinspage->m_pNodes[ni] = ptempkeys[ni];

                ++pinspage->m_hdr.NoOfKeys;
            }

            for (ni = pinspage->m_hdr.MinKeys + 1; ni <= pinspage->m_hdr.MaxKeys; ++ni)
            {
                psibpage->m_pNodes[ni - 1 - pinspage->m_hdr.MinKeys] = ptempkeys[ni];
                ++(psibpage->m_hdr.NoOfKeys);
            }

            // Fill any remaining entries in inspage with null.
            // Note that sibpage is initialized to null values
            // by the constructor.

            for (ni = pinspage->m_hdr.MinKeys; ni < pinspage->m_hdr.MaxKeys; ++ni)
            {
                memset((void*)&pinspage->m_pNodes[ni],0,sizeof(BTreeNode<K,D>));
            }

            // promote key and pointer
            if (!pinspage->m_pParent)
            {
                // we need to create a new root
                PromoteRoot(ptempkeys[pinspage->m_hdr.MinKeys], pinspage, psibpage);
            }
            else
            {
                BTreePage<K,D>* pparpage;

                pparpage = pinspage->m_pParent;

                // promote into parent
                PromoteInternal(pparpage, ptempkeys[pinspage->m_hdr.MinKeys], psibpage);
            }

            delete [] ptempkeys;
        }
        else // simply insert new key and data ptr
        {
            for (long n = pinspage->m_hdr.NoOfKeys; n > inspos; --n)
            {
                pinspage->m_pNodes[n] = pinspage->m_pNodes[n - 1];
            }

            pinspage->m_pNodes[inspos] = newnode;

            ++pinspage->m_hdr.NoOfKeys;
        }
    }

}

template <class K, class D>
void BTree<K,D>::PromoteInternal(BTreePage<K,D>* pinspage, BTreeNode<K,D> & node, BTreePage<K,D>* pgrtrpage)
{
    if (pinspage->m_hdr.NoOfKeys == pinspage->m_hdr.MaxKeys)
    {
        // temporary arrays
        BTreeNode<K,D> * ptempkeys = new BTreeNode<K,D>[pinspage->m_hdr.MaxKeys + 1];
        BTreePage<K,D>** ptemplnks = new BTreePage<K,D>*[pinspage->m_hdr.Order   + 1];

        // copy entries from inspage to temporaries
        long nt = 0; // index into temporaries
        long ni = 0; // index into inspage

        ptemplnks[0] = pinspage->m_ppLinks[0];

        long inspos = 0;

        // find insertion position
        while ((inspos < pinspage->m_hdr.MaxKeys) 
        &&  (pinspage->m_pNodes[inspos].m_ulHash < node.m_ulHash))
        ++inspos;

        // store new info
        ptempkeys[inspos]     = node;
        ptemplnks[inspos + 1] = pgrtrpage;

        // copy existing keys
        while (ni < pinspage->m_hdr.MaxKeys)
        {
            if (ni == inspos)
                ++nt;

            ptempkeys[nt]     = pinspage->m_pNodes[ni];
            ptemplnks[nt + 1] = pinspage->m_ppLinks[ni + 1];

            ++ni;
            ++nt;
        }

        // generate a new leaf node
        BTreePage<K,D>* psibpage = new BTreePage<K,D>(pinspage->m_hdr.Order);

        psibpage->m_pParent = pinspage->m_pParent;

        // clear # of keys in pages
        pinspage->m_hdr.NoOfKeys = 0;
        psibpage->m_hdr.NoOfKeys = 0;

        pinspage->m_ppLinks[0] = ptemplnks[0];

        // copy appropriate keys from temp to pages
        for (ni = 0; ni < pinspage->m_hdr.MinKeys; ++ni)
        {
            pinspage->m_pNodes[ni]     = ptempkeys[ni];
            pinspage->m_ppLinks[ni + 1] = ptemplnks[ni + 1];

            ++pinspage->m_hdr.NoOfKeys;
        }

        psibpage->m_ppLinks[0] = ptemplnks[pinspage->m_hdr.MinKeys + 1];

        for (ni = pinspage->m_hdr.MinKeys + 1; ni <= pinspage->m_hdr.MaxKeys; ++ni)
        {
            psibpage->m_pNodes[ni - 1 - pinspage->m_hdr.MinKeys] = ptempkeys[ni];
            psibpage->m_ppLinks[ni - pinspage->m_hdr.MinKeys]     = ptemplnks[ni + 1];

            ++psibpage->m_hdr.NoOfKeys;
        }

        // Fill any remaining entries in inspage with null.
        // Note that sibpage is initialized to null values
        // by the constructor.

        for (ni = pinspage->m_hdr.MinKeys; ni < pinspage->m_hdr.MaxKeys; ++ni)
        {
            memset((void*)&pinspage->m_pNodes[ni],0, sizeof(BTreeNode<K,D>));
            pinspage->m_ppLinks[ni + 1] = NULL;
        }

        // update child parent links
        BTreePage<K,D>* pchild;

        for (ni = 0; ni <= psibpage->m_hdr.NoOfKeys; ++ni)
        {
            pchild = psibpage->m_ppLinks[ni];

            pchild->m_pParent= psibpage;

        }

        // promote key and pointer
        if (!pinspage->m_pParent)
        {
            // we need to create a new root
            PromoteRoot(ptempkeys[pinspage->m_hdr.MinKeys], pinspage, psibpage);
        }
        else
        {
            BTreePage<K, D>* pparpage;

            pparpage = pinspage->m_pParent;

            // promote into parent
            PromoteInternal(pparpage, ptempkeys[pinspage->m_hdr.MinKeys], psibpage);
        }

        delete [] ptempkeys;
        delete [] ptemplnks;
    }
    else // simply insert new key and data ptr
    {
        long inspos = 0;

        // find insertion position
        while ((inspos < pinspage->m_hdr.NoOfKeys) 
        && (pinspage->m_pNodes[inspos].m_ulHash < node.m_ulHash))
        ++inspos;

        // shift any keys right
        for (long n = pinspage->m_hdr.NoOfKeys; n > inspos; --n)
        {
            pinspage->m_pNodes[n]     = pinspage->m_pNodes[n - 1];
            pinspage->m_ppLinks[n + 1] = pinspage->m_ppLinks[n];
        }

        // store new info
        pinspage->m_pNodes[inspos]     = node;
        pinspage->m_ppLinks[inspos + 1] = pgrtrpage;

        ++pinspage->m_hdr.NoOfKeys;

    }
}

template <class K, class D>
void BTree<K,D>::PromoteRoot(BTreeNode<K,D> & node, BTreePage<K,D> * plesspage, BTreePage<K,D> * pgrtrpage)
{
    // create new root page
    BTreePage<K,D>* pnewroot = new BTreePage<K,D>(m_pRoot->m_hdr.Order);

    // insert key into new root
    pnewroot->m_pNodes[0] = node;

    pnewroot->m_ppLinks[0] = plesspage;
    pnewroot->m_ppLinks[1] = pgrtrpage;

    pnewroot->m_hdr.NoOfKeys = 1;

    m_pRoot = pnewroot;

    plesspage->m_pParent = m_pRoot;
    pgrtrpage->m_pParent = m_pRoot;

}

template <class K, class D>
void BTree<K,D>::AdjustTree(BTreePage<K,D>* ppg)
{
    if (!ppg->m_pParent)
        return;

    BTreePage<K,D>* pparpage = ppg->m_pParent;
    BTreePage<K,D>* psibless = NULL;
    BTreePage<K,D>* psibgrtr = NULL;

    // find pointer to pg in parent
    for (long n = 0; pparpage->m_ppLinks[n] != ppg; ++n)
    ;

    // read sibling pages
    if (n < pparpage->m_hdr.NoOfKeys)
        psibgrtr = pparpage->m_ppLinks[n + 1];

    if (n > 0)
        psibless = pparpage->m_ppLinks[n - 1];

    if (!psibgrtr && !psibless)
        return;

    // decide to redistribute or concatenate
    if (!psibgrtr || (psibgrtr && psibless && (psibless->m_hdr.NoOfKeys > psibgrtr->m_hdr.NoOfKeys)))
    {
        --n;

        if (psibless->m_hdr.NoOfKeys > psibless->m_hdr.MinKeys)
            Redistribute(n,psibless,pparpage,ppg);
        else
            Concatenate(n,psibless,pparpage,ppg);
    }
    else if (psibgrtr)
    {
        if (psibgrtr->m_hdr.NoOfKeys > psibgrtr->m_hdr.MinKeys)
            Redistribute(n,ppg,pparpage,psibgrtr);
        else
            Concatenate(n,ppg,pparpage,psibgrtr);
    }

}
    
template <class K, class D>
void BTree<K,D>::Redistribute(long keypos, BTreePage<K,D>* plesspage, BTreePage<K,D>* pparpage, BTreePage<K,D>* pgrtrpage)
{
    // note: this function is ONLY called for leaf nodes!
    long n;

    if (!plesspage->m_ppLinks[0]) // working with leaves
    {
        if (plesspage->m_hdr.NoOfKeys > pgrtrpage->m_hdr.NoOfKeys)
        {
            // slide a key from lesser to greater
            // move keys in greater to the left by one
            for (n = pgrtrpage->m_hdr.NoOfKeys; n > 0; --n)
            {
                pgrtrpage->m_pNodes[n] = pgrtrpage->m_pNodes[n - 1];
            }

            // store parent separator key in greater page
            pgrtrpage->m_pNodes[0] = pparpage->m_pNodes[keypos];

            // increment greater page's key count
            ++pgrtrpage->m_hdr.NoOfKeys;

            // decrement lessor page's key count
            --plesspage->m_hdr.NoOfKeys;

            // move last key in less page to parent as separator
            pparpage->m_pNodes[keypos] = plesspage->m_pNodes[plesspage->m_hdr.NoOfKeys];

            // clear last key in less page
            memset((void*)&plesspage->m_pNodes[plesspage->m_hdr.NoOfKeys], 0, sizeof(BTreeNode<K,D>));
        }
        else
        {
            // slide a key from greater to lessor
            // add parent key to lessor page
            plesspage->m_pNodes[plesspage->m_hdr.NoOfKeys] = pparpage->m_pNodes[keypos];

            // increment lessor page's key count
            ++plesspage->m_hdr.NoOfKeys;

            // insert in parent the lowest key in greater page
            pparpage->m_pNodes[keypos] = pgrtrpage->m_pNodes[0];

            // decrement # of keys in greater page
            --pgrtrpage->m_hdr.NoOfKeys;

            // move keys in greater page to left
            for (n = 0; n < pgrtrpage->m_hdr.NoOfKeys; ++n)
            {
                pgrtrpage->m_pNodes[n] = pgrtrpage->m_pNodes[n + 1];
            }

            // make last key blank
            memset((void*)&pgrtrpage->m_pNodes[n], 0, sizeof(BTreeNode<K,D>));
        }
    }
    else
    {
        if (plesspage->m_hdr.NoOfKeys > pgrtrpage->m_hdr.NoOfKeys)
        {
            // slide a key from lesser to greater
            // move keys in greater to the left by one
            for (n = pgrtrpage->m_hdr.NoOfKeys; n > 0; --n)
            {
                pgrtrpage->m_pNodes[n] = pgrtrpage->m_pNodes[n - 1];
                pgrtrpage->m_ppLinks[n + 1] = pgrtrpage->m_ppLinks[n];
            }

            pgrtrpage->m_ppLinks[1] = pgrtrpage->m_ppLinks[0];

            // store parent separator key in greater page
            pgrtrpage->m_pNodes[0] = pparpage->m_pNodes[keypos];
            pgrtrpage->m_ppLinks[0] = plesspage->m_ppLinks[plesspage->m_hdr.NoOfKeys];

            // update child link
            BTreePage<K,D>* pchild;

            pchild = pgrtrpage->m_ppLinks[0];

            pchild->m_pParent= pgrtrpage;

            // increment greater page's key count
            ++pgrtrpage->m_hdr.NoOfKeys;

            // decrement lessor page's key count
            --plesspage->m_hdr.NoOfKeys;

            // move last key in less page to parent as separator
            pparpage->m_pNodes[keypos] = plesspage->m_pNodes[plesspage->m_hdr.NoOfKeys];

            // clear last key in less page
            memset((void*)&plesspage->m_pNodes[plesspage->m_hdr.NoOfKeys], 0, sizeof(BTreeNode<K,D>));
            plesspage->m_ppLinks[plesspage->m_hdr.NoOfKeys + 1] = NULL;
        }
        else
        {
            // slide a key from greater to lessor
            // add parent key to lessor page
            plesspage->m_pNodes[plesspage->m_hdr.NoOfKeys] = pparpage->m_pNodes[keypos];
            plesspage->m_ppLinks[plesspage->m_hdr.NoOfKeys + 1] = pgrtrpage->m_ppLinks[0];

            // update child link
            BTreePage<K,D>* pchild;

            pchild = pgrtrpage->m_ppLinks[0];

            pchild->m_pParent = plesspage;

            // increment lessor page's key count
            ++plesspage->m_hdr.NoOfKeys;

            // insert in parent the lowest key in greater page
            pparpage->m_pNodes[keypos] = pgrtrpage->m_pNodes[0];

            // decrement # of keys in greater page
            --pgrtrpage->m_hdr.NoOfKeys;

            // move keys in greater page to left
            for (n = 0; n < pgrtrpage->m_hdr.NoOfKeys; ++n)
            {
                pgrtrpage->m_pNodes[n] = pgrtrpage->m_pNodes[n + 1];
                pgrtrpage->m_ppLinks[n] = pgrtrpage->m_ppLinks[n + 1];
            }

            pgrtrpage->m_ppLinks[n] = pgrtrpage->m_ppLinks[n + 1];

            // make last key blank
            memset((void*)&pgrtrpage->m_pNodes[n], 0, sizeof(BTreeNode<K,D>));
            pgrtrpage->m_ppLinks[n + 1] = NULL;
        }
    }

    if (!pparpage->m_pParent)
        m_pRoot = pparpage;
}
	
template <class K, class D>
void BTree<K,D>::Concatenate(long keypos, BTreePage<K,D>* plesspage, BTreePage<K,D>* pparpage, BTreePage<K,D>* pgrtrpage)
{
    long n, ng;

    // move separator key from parent into lesspage
    plesspage->m_pNodes[plesspage->m_hdr.NoOfKeys] = pparpage->m_pNodes[keypos];
    plesspage->m_ppLinks[plesspage->m_hdr.NoOfKeys + 1] = pgrtrpage->m_ppLinks[0];

    ++plesspage->m_hdr.NoOfKeys;

    // delete separator from parent
    --pparpage->m_hdr.NoOfKeys;

    for (n = keypos; n < pparpage->m_hdr.NoOfKeys; ++n)
    {
        pparpage->m_pNodes[n] = pparpage->m_pNodes[n + 1];
        pparpage->m_ppLinks[n + 1] = pparpage->m_ppLinks[n + 2];
    }

    // clear unused key in parent
    memset((void*)&pparpage->m_pNodes[n], 0, sizeof(BTreeNode<K,D>));
    pparpage->m_ppLinks[n + 1] = NULL;

    // copy keys from grtrpage to lesspage
    ng = 0;
    n  = plesspage->m_hdr.NoOfKeys;

    while (ng < pgrtrpage->m_hdr.NoOfKeys)
    {
        ++plesspage->m_hdr.NoOfKeys;

        plesspage->m_pNodes[n] = pgrtrpage->m_pNodes[ng];
        memset((void*)&pgrtrpage->m_pNodes[ng], 0, sizeof(BTreeNode<K,D>));
        plesspage->m_ppLinks[n + 1] = pgrtrpage->m_ppLinks[ng + 1];
        pgrtrpage->m_ppLinks[ng + 1] = NULL;

        ++ng;
        ++n; 
    }

    delete pgrtrpage;

    // is this a leaf page?
    if (plesspage->m_ppLinks[0])
    {
        // adjust child pointers to point to less page
        BTreePage<K,D>* pchild;

        for (n = 0; n <= plesspage->m_hdr.NoOfKeys; ++n)
        {
            pchild = plesspage->m_ppLinks[n];

            pchild->m_pParent = plesspage;
        }
    }

    // write less page and parent
    if (pparpage->m_hdr.NoOfKeys == 0)
    {
        AdjustTree(pparpage);

        plesspage->m_pParent = pparpage->m_pParent;

        if (!plesspage->m_pParent)
            m_pRoot = plesspage;
        else
        {
            for (int n = 0; n <= pparpage->m_pParent->m_hdr.NoOfKeys; n++)
            {
                if (pparpage == pparpage->m_pParent->m_ppLinks[n])
                {
                    pparpage->m_pParent->m_ppLinks[n] = plesspage;
                    break;
                }
            }
            
        }

        delete pparpage;

    }
    else
    {
        // reset root page, if necessary
        if (!pparpage->m_pParent)
            m_pRoot = pparpage;

        // if parent is too small, adjust tree!
        if (pparpage->m_hdr.NoOfKeys < pparpage->m_hdr.MinKeys)
            AdjustTree(pparpage);
    }
}   

template <class K, class D>
void BTree<K,D>::RecurseTraverse(const BTreePage<K,D>* ppg, int depth)
{
    long n;
    BTreePage<K,D>* p = NULL;
    
    depth++;
    // sequence through keys in page, recursively processing links
    for (n = 0; n < ppg->m_hdr.NoOfKeys; ++n)
    {
        // follow each link before processing page
        if (ppg->m_ppLinks[n])
        {
            p = ppg->m_ppLinks[n];
            RecurseTraverse(p, depth);
            
        }

        int index = 0;

        BTreeNode<K,D>* p = &ppg->m_pNodes[n];

        while(p)
        {
            TravFunc(p->m_Key, p->m_pData, depth, index);
            index++;
            p = p->m_pNext;
        }

    }

    // handle greatest subtree link
    if ((ppg->m_ppLinks != NULL) && ppg->m_ppLinks[n])
    {
        p = ppg->m_ppLinks[n];
        RecurseTraverse(p, depth);
    }

}

template <class K, class D>
void BTree<K,D>::DeletePage(BTreePage<K,D>* ppg)
{
    long n;
    BTreePage<K,D>* p = NULL;

    if (!ppg)

        return;

    // sequence through keys in page, recursively processing links
    for (n = 0; n < ppg->m_hdr.NoOfKeys; ++n)
    {
        // follow each link before processing page
        if (ppg->m_ppLinks[n])
        {
            p = ppg->m_ppLinks[n];
            DeletePage(p);
            ppg->m_ppLinks[n] = NULL;
        }

    }

    // handle greatest subtree link
    if ((ppg->m_ppLinks != NULL) && ppg->m_ppLinks[n])
    {
        p = ppg->m_ppLinks[n];
        DeletePage(p);
        ppg->m_ppLinks[n] = NULL;
    }

    delete ppg;

}
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\idispids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: idispids.h
//
//--------------------------------------------------------------------------

#define DISPID_READYSTATE               (-525)
#define DISPID_READYSTATECHANGE         (-609)
#define DISPID_AMBIENT_TRANSFERPRIORITY (-728)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\debug.h ===
//=--------------------------------------------------------------------------=
// Debug.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the various macros and the like which are only useful in DEBUG
// builds
//
#ifndef _DEBUG_H_

//=---------------------------------------------------------------------------=
// all the things required to handle our ASSERT mechanism
//=---------------------------------------------------------------------------=
//
#if DEBUG

// Function Prototypes
//
VOID DisplayAssert(LPSTR pszMsg, LPSTR pszAssert, LPSTR pszFile, UINT line);
VOID SetCtlSwitches (LPSTR lpFileName);


// Macros
//
// *** Include this macro at the top of any source file using *ASSERT*() macros ***
//
#if !defined(SZTHISFILE)
#define SZTHISFILE	static char _szThisFile[] = __FILE__;
#endif //!defined(SZTHISFILE)


// our versions of the ASSERT and FAIL macros.
//
#if !defined(ASSERT)
#define ASSERT(fTest, szMsg)                                \
    if (!(fTest))  {                                        \
        static char szMsgCode[] = szMsg;                    \
        static char szAssert[] = #fTest;                    \
        DisplayAssert(szMsgCode, szAssert, _szThisFile, __LINE__); \
    }
#endif //!defined(ASSERT)

#if !defined(FAIL)
#define FAIL(szMsg)                                         \
        { static char szMsgCode[] = szMsg;                    \
        DisplayAssert(szMsgCode, "FAIL", _szThisFile, __LINE__); }
#endif //!defined(FAIL)



// macro that checks a pointer for validity on input
//
#define CHECK_POINTER(val) if (!(val) || IsBadReadPtr((void *)(val), sizeof(void *))) { FAIL("Pointer is NULL"); }

//////
// CCritSec
// ~~~~~~~~
//   This is a class to help track down whether a critical section has been left
//   using a LeaveCriticalSection or not.
//
class CCritSec
{
public:
    CCritSec(CRITICAL_SECTION *CritSec);
    ~CCritSec();

    // methods
    void Left(void);

private:
    // variables
    BOOL  m_fLeft;
    CRITICAL_SECTION *m_pCriticalSection;
}; // CCritSec

#define ENTERCRITICALSECTION1(CriticalSection) CCritSec DebugCriticalSection1(CriticalSection)
#define LEAVECRITICALSECTION1(CriticalSection) DebugCriticalSection1.Left()
#define ENTERCRITICALSECTION2(CriticalSection) CCritSec DebugCriticalSection2(CriticalSection)
#define LEAVECRITICALSECTION2(CriticalSection) DebugCriticalSection2.Left()
#define ENTERCRITICALSECTION3(CriticalSection) CCritSec DebugCriticalSection3(CriticalSection)
#define LEAVECRITICALSECTION3(CriticalSection) DebugCriticalSection3.Left()

#else  // DEBUG

#if !defined(SZTHISFILE)
#define SZTHISFILE
#endif //!defined(SZTHISFILE)

#if !defined(ASSERT)
#define ASSERT(fTest, err)
#endif //!defined(ASSERT)

#if !defined(FAIL)
#define FAIL(err)
#endif //!defined(FAIL)

#define CHECK_POINTER(val)

#define ENTERCRITICALSECTION1(CriticalSection) EnterCriticalSection(CriticalSection)
#define LEAVECRITICALSECTION1(CriticalSection) LeaveCriticalSection(CriticalSection)
#define ENTERCRITICALSECTION2(CriticalSection) EnterCriticalSection(CriticalSection)
#define LEAVECRITICALSECTION2(CriticalSection) LeaveCriticalSection(CriticalSection)
#define ENTERCRITICALSECTION3(CriticalSection) EnterCriticalSection(CriticalSection)
#define LEAVECRITICALSECTION3(CriticalSection) LeaveCriticalSection(CriticalSection)

// Force compile errors when OutputDebugString used in Retail builds
#ifndef USE_OUTPUTDEBUGSTRING_IN_RETAIL
#undef OutputDebugString
#define OutputDebugString(s)
#endif

#endif	// DEBUG

#define _DEBUG_H_
#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\globals.h ===
//=--------------------------------------------------------------------------=
// Globals.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains externs and stuff for Global variables, etc ..
//
#ifndef _GLOBALS_H_

// the library that we are
//
extern const CLSID *g_pLibid;

//=--------------------------------------------------------------------------=
// support for licensing
//
extern BOOL   g_fMachineHasLicense;
extern BOOL   g_fCheckedForLicense;

extern const BOOL g_fUseRuntimeLicInCompositeCtl;

//=--------------------------------------------------------------------------=
// does our server have a type library?
//
extern BOOL   g_fServerHasTypeLibrary;

//=--------------------------------------------------------------------------=
// our instance handle, and various pieces of information interesting to
// localization
//
extern HINSTANCE    g_hInstance;

extern const VARIANT_BOOL g_fSatelliteLocalization;

#ifdef MDAC_BUILD
    extern VARIANT_BOOL g_fSatelliteLangExtension;
#endif

extern VARIANT_BOOL       g_fHaveLocale;
extern LCID               g_lcidLocale;

//=--------------------------------------------------------------------------=
// apartment threading support.
//
extern CRITICAL_SECTION g_CriticalSection;

//=--------------------------------------------------------------------------=
// critical section for our heap memory leak detection
//
extern CRITICAL_SECTION g_csHeap;
extern BOOL g_fInitCrit;
extern BOOL g_flagConstructorAlloc;

//=--------------------------------------------------------------------------=
// our global memory allocator and global memory pool
//
extern HANDLE   g_hHeap;

//=--------------------------------------------------------------------------=
// global parking window for parenting various things.
//
extern HWND     g_hwndParking;

//=--------------------------------------------------------------------------=
// system information
//
extern BOOL g_fSysWin95;                    // we're under Win95 system, not just NT SUR
extern BOOL g_fSysWinNT;                    // we're under some form of Windows NT
extern BOOL g_fSysWin95Shell;               // we're under Win95 or Windows NT SUR { > 3/51)
extern BOOL g_fDBCSEnabled;					// system is DBCS enabled

//Vegas 21279 - joejo
//=--------------------------------------------------------------------------=
// OleAut Library Handle
//
#ifdef MDAC_BUILD
extern HINSTANCE g_hOleAutHandle;
#else
extern HANDLE 	 g_hOleAutHandle;
#endif
//Vegas 21279 - joejo

//=-------------------------------------------------------------------------------
//  Control Debug Switch implementation
//=-------------------------------------------------------------------------------
//---------------------------------------------------------------------------
// The following macros allow you declare global BOOL variables that are only
// included in the debug build (they map to FALSE in the retail build).  
// These boolean switches are automatically persisted (in %WINDIR%\ctlswtch.ini) 
// and a console app (ctlswtch.exe) is used to turn on/off the switches.
// All switches must be initialized.  This can be done in the InitializeLibrary()
// routine of each control.  All switches are initialized to FALSE using the
// INIT_SWITCH macro, and to TRUE using the INIT_SWITCH_TRUE macro.
//
//                     
// To declare a switch (global scope), define and intialize the switch e.g.
//
//
//  DEFINE_SWITCH(fContainer);
//
// AND,
//
//  INIT_SWITCH(fContainer);
//
//
// To test whether a switch is currently set (TRUE), use FSWITCH, e.g.
//
//  if (FSWITCH(fContainer))
//    *ppv = (IOleContainer*)this;
//
//
// To reference a switch declared in another file, use EXTERN_SWITCH, e.g.
//
//  EXTERN_SWITCH(fContainer);
//
// AND
//
//  INIT_SWITCH(fContainer);
//---------------------------------------------------------------------------
#if DEBUG

// private implementation; use SWITCH macros below to declare and use
class CtlSwitch {
public:
  void InitSwitch(char * pszName);

  BOOL m_fSet;			    // TRUE if switch is enabled
  char * m_pszName;		    // name of the switch
  CtlSwitch* m_pctlswNext;          // next switch in global list
  static CtlSwitch* g_pctlswFirst;  // head of global list
};

#define DEFINE_SWITCH(NAME)	    CtlSwitch g_Switch_ ## NAME;
#define INIT_SWITCH(NAME)	    g_Switch_ ## NAME . InitSwitch(#NAME);
#define EXTERN_SWITCH(NAME)	    extern CtlSwitch g_Switch_ ## NAME;
#define INIT_SWITCH_TRUE(NAME)      g_Switch_ ## NAME . InitSwitch(#NAME);  g_Switch_ ## NAME . m_fSet = TRUE;
#define FSWITCH(NAME)		    (g_Switch_ ## NAME . m_fSet)


#else //DEBUG

#define DEFINE_SWITCH(NAME) 
#define INIT_SWITCH(NAME)
#define EXTERN_SWITCH(NAME) 
#define INIT_SWITCH_TRUE(NAME)
#define FSWITCH(NAME)		    FALSE

#endif //DEBUG


#define _GLOBALS_H_
#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\depfile.inc ===
; Dependency file for setup wizards.

// This include file is included at the beginning of every .dep template
// file (.tpl).  Remember that the customers will see anything that is
// not commented out using C++ or C-style comments.
//
// Include version information from dwinvers.h
#include "dwinvers.h"
//
// Define a version string
#define MAKEVERSION(aa,bb,cc,dd) aa.bb.cc.dd
//
// Default version string
#define VERSION MAKEVERSION(vusMajorVer,vusMinorVer,vusVersNumf2,vusVersNuml2)



// declare language ID's
//
//
// Note: for most of these, we use the primary language ID,
//  : and NOT the full language ID (the exceptions being
//  : CHT/CHS).
//
#define ID_ENGLISH 0009
#define ID_GERMAN 0007
#define ID_FRENCH 000C
#define ID_ITALIAN 0010
#define ID_SPANISH 000A
#define ID_JAPANESE 0011
#define ID_KOREAN 0012
#define ID_CHT 0404
#define ID_CHS 0804



// locale abbreviations
//
//
// The following are the standard localized DLL names:
//
// English:               EN
// German:                DE
// French:                FR
// Italian:               IT
// Spanish:               ES
// Japanese:              JP
// Korean:                KO
// Chinese Traditional:   CHT
// Chinese Simplified:    CHS


// ***************************************************************************
// Standard Internet keys
// ***************************************************************************
#define INTERNET_VB5(a) \
	CABFileName=a ## .cab					      {NEWL} \
	CABDefaultURL=http:{DOUBLESLASH}activex.microsoft.com/controls/vb5  {NEWL} \
	CABINFFile=a ## .inf

#define INTERNET(a) \
	CABFileName=a ## .cab					      {NEWL} \
	CABDefaultURL=http:{DOUBLESLASH}activex.microsoft.com/controls/vb6  {NEWL} \
	CABINFFile=a ## .inf


// ***************************************************************************
// Defines a single language DLL section.  Use this only
// if your component has only a single satellite DLL.
// ***************************************************************************
#define SATELLITE_1(basename, baselocname, langabbrev, langid, langfullname) \
; ** langfullname (langabbrev) ***				      {NEWL} \
; (langid = langfullname)					      {NEWL} \
;								      {NEWL} \
[basename <langid>]						      {NEWL} \
Uses1=baselocname ## langabbrev ## .dll				      {NEWL} \
Uses2=								      {NEWL} \
								      {NEWL} \
[baselocname ## langabbrev ## .dll <langid>]			      {NEWL} \
Uses1=								      {NEWL} \
INTERNET(baselocname ## langabbrev)				      {NEWL}


// ***************************************************************************
// Defines all language satellite DLL sections.  Use this only
// if your component has only a single satellite DLL.
// ***************************************************************************
#define SATELLITE_DLLS(component, baselocname) \
SATELLITE_1(component, baselocname, DE, ID_GERMAN, German)	      {NEWL} \
SATELLITE_1(component, baselocname, FR, ID_FRENCH, French)	      {NEWL} \
SATELLITE_1(component, baselocname, IT, ID_ITALIAN, Italian)	      {NEWL} \
SATELLITE_1(component, baselocname, ES, ID_SPANISH, Spanish)	      {NEWL} \
SATELLITE_1(component, baselocname, JP, ID_JAPANESE, Japanese)	      {NEWL} \
SATELLITE_1(component, baselocname, KO, ID_KOREAN, Korean)	      {NEWL} \
SATELLITE_1(component, baselocname, CHT, ID_CHT, Chinese Traditional) {NEWL} \
SATELLITE_1(component, baselocname, CHS, ID_CHS, Chinese Simplified)  {NEWL}


// ***************************************************************************
// Standard section for ComCat.dll
// ***************************************************************************
#define STD_COMCAT_SECTION \
/* BUG #5-28738,stephwe,11/96: Include ComCat.dll as a dependence     {NEWL} \
   of all our shipped ctls */					      {NEWL} \
								      {NEWL} \
/* Note that we are *not* including this file in any of the cab files {NEWL} \
   because IE3.0 can't download it if in use, which it will be */     {NEWL} \
								      {NEWL} \
/* NOTE: This section is repeated in vb6dep.ini.  Please keep them in {NEWL} \
   sync. */							      {NEWL} \
								      {NEWL} \
[ComCat.dll]							      {NEWL} \
Dest=$(WinSysPathSysFile)					      {NEWL} \
Register=$(DLLSelfRegister)					      {NEWL} \
Uses1=								      {NEWL}


// ***************************************************************************
// The entire contents of a standard dependency file for a component
// without any dependencies other than a localized DLL using the standard
// language abbreviations, self-registerable, and going into windows\system
// ***************************************************************************

#define STD_DEP_FILE_ONLY_SATELLITE_DEPENDENCE(component, basename, baselocname) \
; Dependencies for component					      {NEWL} \
								      {NEWL} \
								      {NEWL} \
; Default Dependencies ---------------------------------------------- {NEWL} \
								      {NEWL} \
								      {NEWL} \
[component]							      {NEWL} \
Dest=$(WinSysPath)						      {NEWL} \
Register=$(DLLSelfRegister)					      {NEWL} \
Version=VERSION							      {NEWL} \
Uses1=ComCat.dll/*BUG #5-28738,stephwe,11/96 */			      {NEWL} \
Uses2=								      {NEWL} \
INTERNET(basename)						      {NEWL} \
								      {NEWL} \
STD_COMCAT_SECTION	  					      {NEWL} \
								      {NEWL} \
; Localized Dependencies -------------------------------------------- {NEWL} \
								      {NEWL} \
								      {NEWL} \
SATELLITE_DLLS(component, baselocname)



// ***************************************************************************


// VERSION INFORMATION!
// This is the version for the .dep file *itself*.  It goes at the top of every .dep file
[Version]
Version=VERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\localsrv.h ===
//=--------------------------------------------------------------------------=
// LocalServer.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// global routines that are specific to the inproc server itself, such as
// registration, object creation, object specification, etc...
//
#ifndef _LOCALSERVER_H_

void      InitializeLibrary(void);
void      UninitializeLibrary(void);

#ifdef MDAC_BUILD
    BOOL	  CanUnloadLibraryNow(void);
    HRESULT	  LibraryGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObjOut);
#endif

BOOL      RegisterData(void);
BOOL      UnregisterData(void);
BOOL      CheckForLicense();
BOOL      CheckLicenseKey(LPWSTR wszCheckme);
BSTR      GetLicenseKey(void);

// global variables that various people use to get information about the control.
//
extern const char g_szLibName [];
extern const CLSID *g_pLibid;

//=--------------------------------------------------------------------------=
// Global object information table
//=--------------------------------------------------------------------------=
// for each object in your application, you have an entry in this table.  they
// do not necessarily have to be CoCreatable, but if they are used, then they
// should reside here.  use the macros to fill in this table.
//
typedef struct tagOBJECTINFO {

    unsigned short usType;
    void          *pInfo;

} OBJECTINFO;

extern OBJECTINFO g_ObjectInfo[];

//=--------------------------------------------------------------------------=
// these things are used to set up our objects in our global object table
//
#define OI_UNKNOWN       0
#define OI_AUTOMATION    1
#define OI_CONTROL       2
#define OI_PROPERTYPAGE  3
#define OI_BOGUS         0xffff

#define OBJECTISCREATABLE(index)  (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->rclsid != NULL)
#define ISEMPTYOBJECT(index)      (g_ObjectInfo[index].usType == OI_BOGUS)

// these are the macros you should use to fill in the table.  Note that the name
// must be exactly the same as that used in the global structure you created
// for this object.
//
#define UNKNOWNOBJECT(name)    { OI_UNKNOWN,      (void *)&(name##Object) }
#define AUTOMATIONOBJECT(name) { OI_AUTOMATION,   (void *)&(name##Object) }
#define CONTROLOBJECT(name)    { OI_CONTROL,      (void *)&(name##Control) }
#define PROPERTYPAGE(name)     { OI_PROPERTYPAGE, (void *)&(name##Page) }
#define EMPTYOBJECT            { OI_BOGUS, NULL }

#define _LOCALSERVER_H_
#endif // _LOCALSERVER_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\kxalpha.h ===
/*++

  Copyright (c) 1992, 1993 Digital Equipment Corporation


  Module:
           kxalpha.h

  Abstract:
           Contains alpha architecture constants and assembly macros.

  Author:
          Joe Notarangelo  31-March-1992   (based on Dave Cutler's kxmips.h)


  Revision History

  16-July-1992       John DeRosa

  Removed fwcalpal.h hook.


  8-July-1992        John DeRosa

  Added fwcalpal.h hooks, defined HALT call_pal.


--*/

//
// Define Sfw Interrupt Levels and masks
//

#define APC_INTERRUPT 0x1
#define DISPATCH_INTERRUPT 0x2

//
// Define standard integer registers.
//
// N.B. `at' is `AT' so it doesn't conflict with the `.set at' pseudo-op.
//

#define v0 $0                   // return value register
#define t0 $1                   // caller saved (temporary) registers
#define t1 $2                   //
#define t2 $3                   //
#define t3 $4                   //
#define t4 $5                   //
#define t5 $6                   //
#define t6 $7                   //
#define t7 $8                   //
#define s0 $9                   // callee saved (nonvolatile) registers
#define s1 $10                  //
#define s2 $11                  //
#define s3 $12                  //
#define s4 $13                  //
#define s5 $14                  //
#define fp $15                  // frame pointer register, or s6
#define a0 $16                  // argument registers
#define a1 $17                  //
#define a2 $18                  //
#define a3 $19                  //
#define a4 $20                  //
#define a5 $21                  //
#define t8 $22                  // caller saved (temporary) registers
#define t9 $23                  //
#define t10 $24                 //
#define t11 $25                 //
#define ra $26                  // return address register
#define t12 $27                 // caller saved (temporary) registers
#define AT $28                  // assembler temporary register
#define gp $29                  // global pointer register
#define sp $30                  // stack pointer register
#define zero $31                // zero register

#ifndef PALCODE

//
// Define standard floating point registers.
//

#define f0 $f0                  // return value register
#define f1 $f1                  // return value register
#define f2 $f2                  // callee saved (nonvolatile) registers
#define f3 $f3                  //
#define f4 $f4                  //
#define f5 $f5                  //
#define f6 $f6                  //
#define f7 $f7                  //
#define f8 $f8                  //
#define f9 $f9                  //
#define f10 $f10                // caller saved (temporary) registers
#define f11 $f11                //
#define f12 $f12                //
#define f13 $f13                //
#define f14 $f14                //
#define f15 $f15                //
#define f16 $f16                // argument registers
#define f17 $f17                //
#define f18 $f18                //
#define f19 $f19                //
#define f20 $f20                //
#define f21 $f21                //
#define f22 $f22                // caller saved (temporary) registers
#define f23 $f23                //
#define f24 $f24                //
#define f25 $f25                //
#define f26 $f26                //
#define f27 $f27                //
#define f28 $f28                //
#define f29 $f29                //
#define f30 $f30                //
#define f31 $f31                // floating zero register
#define fzero $f31              // floating zero register (alias)

#endif //!PALCODE


//
// Define procedure entry macros
//

#define ALTERNATE_ENTRY(Name)           \
        .globl  Name;                   \
Name:;

#define LEAF_ENTRY(Name)                \
        .text;                          \
        .align  4;                      \
        .globl  Name;                   \
        .ent    Name, 0;                \
Name:;                                  \
        .frame  sp, 0, ra;              \
        .prologue 0;

#define NESTED_ENTRY(Name, fsize, retrg) \
        .text;                          \
        .align  4;                      \
        .globl  Name;                   \
        .ent    Name, 0;                \
Name:;                                  \
        .frame  sp, fsize, retrg;

//
// Define global definition macros.
//

#define END_REGION(Name)                \
        .globl  Name;                   \
Name:;

#define START_REGION(Name)              \
        .globl  Name;                   \
Name:;

//
// Define exception handling macros.
//

#define EXCEPTION_HANDLER(Handler)      \
        .edata 1, Handler;


#define PROLOGUE_END  .prologue 1;

//
// Define save and restore floating state macros.
//

#define SAVE_NONVOLATILE_FLOAT_STATE    \
        bsr     ra, KiSaveNonVolatileFloatState

//
// Define interfaces to pcr and palcode
//
//    The interfaces defined in the following macros will be PALcode
//    calls for some implemenations, but may be in-line code in others
//    (eg. uniprocessor vs multiprocessor).  At the current time all of
//    the interfaces are PALcode calls.
//

//
// Define interfaces for cache coherency
//

//++
//
// IMB
//
// Macro Description:
//
//     Issue the architecture-defined Instruction Memory Barrier.  This
//     instruction will make the processor instruction stream coherent with
//     the system memory.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     None.
//
//--

#define IMB          call_pal imb

//
// Define PALcode Environment Transition Interfaces
//

//++
//
// REBOOT
//
// Macro Description:
//
//     Reboot the processor to return to firmware.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Does not return.
//
// Registers Used:
//
//     None.
//
//--

#define REBOOT         call_pal reboot

//++
//
// RESTART
//
// Macro Description:
//
//     Restart the processor with the processor state found in a
//     restart block.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies a pointer to an ARC restart block with an Alpha AXP
//          saved state area.
//
// Return Value:
//
//     If successful the call does not return.  Otherwise, any return
//     is considered a failure.
//
// Registers Used:
//
//     None.
//
//--

#define RESTART      call_pal restart

//++
//
// SWPPAL
//
// Macro Description:
//
//     Swap the execution environment to a new PALcode image.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the physical address of the base of the new PALcode
//          image.
//
//     a1 - a5 - Supply arguments to the new PALcode environment.
//
// Return Value:
//
//     Does not return.
//
// Registers Used:
//
//     None.
//
//--

#define SWPPAL       call_pal swppal

//
// Define IRQL and interrupt interfaces
//

//++
//
// DISABLE_INTERRUPTS
//
// Macro Description:
//
//     Disable all interrupts for the current processor and return the
//     previous PSR.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     None.
//
//--

#define DISABLE_INTERRUPTS        call_pal di

//++
//
// ENABLE_INTERRUPTS
//
// Macro Description:
//
//     Enable interrupts according to the current PSR for the current
//     processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     None.
//
//--

#define ENABLE_INTERRUPTS         call_pal ei

//++
//
// SWAP_IRQL
//
// Macro Description:
//
//     Swap the IRQL level for the current processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the new IRQL level.
//
// Return Value:
//
//     v0 = previous IRQL level.
//
// Registers Used:
//
//     AT, a1 - a3.
//
//--

#define SWAP_IRQL    call_pal swpirql

//++
//
// GET_CURRENT_IRQL
//
// Macro Description:
//
//     Return the current processor Interrupt Request Level (IRQL).
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = current IRQL.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_CURRENT_IRQL  call_pal rdirql


//
// Define interfaces for software interrupts
//

//++
//
// DEASSERT_SOFTWARE_INTERRUPT
//
// Macro Description:
//
//     Deassert the software interrupts indicated in a0 for the current
//     processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the mask for the software interrupt to be de-asserted.
//          a0<1> - Deassert DISPATCH software interrupt.
//          a0<0> - Deassert APC software interrupt.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a1 - a3.
//
//--

#define DEASSERT_SOFTWARE_INTERRUPT    call_pal csir

//++
//
// REQUEST_SOFTWARE_INTERRUPT
//
// Macro Description:
//
//     Request software interrupts on the current processor according to
//     the mask supplied in a0.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the mask of software interrupts to be requested.
//          a0<1> - Request DISPATCH software interrupt.
//          a0<0> - Request APC software interrupt.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a1 - a3.
//
//--

#define REQUEST_SOFTWARE_INTERRUPT     call_pal ssir

//
// Define interfaces to Processor Status Register
//

//++
//
// GET_CURRENT_PROCESSOR_STATUS_REGISTER
//
// Macro Description:
//
//     Return the current Processor Status Register (PSR) for the current
//     processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = current PSR.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_CURRENT_PROCESSOR_STATUS_REGISTER   call_pal rdpsr


//
// Define current thread interface
//

//++
//
// GET_THREAD_ENVIRONMENT_BLOCK
//
// Macro Description:
//
//     Return the base address of the current Thread Environment Block (TEB),
//     for the currently executing thread on the current processor.
//
// Mode;
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = TEB base address.
//
// Registers Used:
//
//     None.
//
//--

#define GET_THREAD_ENVIRONMENT_BLOCK  call_pal rdteb

//++
//
// GET_CURRENT_THREAD
//
// Macro Description:
//
//     Return the thread object address for the currently executing thread
//     on the current processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = PCR base address.
//
// Registers Used:
//
//     AT.
//
//--

#ifdef NT_UP

//
// If uni-processor, retrieve current thread address from the global
// variable KiCurrentThread.
//

#define GET_CURRENT_THREAD              \
        lda     v0, KiCurrentThread;    \
        ldl     v0, 0(v0)

#else

//
// If multi-processor, retrive per-processor current thread via a call pal.
//

#define GET_CURRENT_THREAD    call_pal rdthread

#endif //NT_UP

//
// Define per-processor data area routine interfaces
//

//++
//
// GET_PROCESSOR_CONTROL_REGION_BASE
//
// Macro Description:
//
//     Return the base address of the Process Control Region (PCR)
//     for the current processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = PCR base address.
//
// Registers Used:
//
//     AT.
//
//--

#ifdef NT_UP

//
// Uni-processor, address of PCR is in global variable.
//

#define GET_PROCESSOR_CONTROL_REGION_BASE \
        lda     v0, KiPcrBaseAddress;     \
        ldl     v0, 0(v0)

#else

//
// Multi-processor, get per-processor value via call pal.
//

#define GET_PROCESSOR_CONTROL_REGION_BASE    call_pal rdpcr

#endif //NT_UP

//++
//
// GET_PROCESSOR_CONTROL_BLOCK_BASE
//
// Macro Description:
//
//     Return the Processor Control Block base address.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = PRCB base address.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_PROCESSOR_CONTROL_BLOCK_BASE   \
        GET_PROCESSOR_CONTROL_REGION_BASE; \
        ldl     v0, PcPrcb(v0)


//
// Define kernel stack interfaces
//

//++
//
// GET_INITIAL_KERNEL_STACK
//
// Macro Description:
//
//     Return the initial kernel stack address for the current thread.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = initial kernel stack address.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_INITIAL_KERNEL_STACK  call_pal rdksp

//++
//
// SET_INITIAL_KERNEL_STACK
//
// Macro Description:
//
//     Set the initial kernel stack address for the current thread.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the new initial kernel stack address.
//
// Return Value:
//
//     v0 - Previous initial kernel stack address.
//
// Registers Used:
//
//     AT.
//
//--

#define SET_INITIAL_KERNEL_STACK  call_pal swpksp

//
// Define initialization routine interfaces
//

//++
//
// INITIALIZE_PAL
//
// Macro Description:
//
//     Supply values to initialize the PALcode.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies initial PageDirectoryBase (32-bit superpage address).
//     a1 - Supplies PRCB Base Address (32-bit superpage address).
//     a2 - Supplies address of initial kernel thread object.
//     a3 - Supplies address of TEB for initial kernel thread object.
//     gp - Supplies kernel image global pointer.
//     sp - Supplies initial thread kernel stack pointer.
//
// Return Value:
//
//     v0 = PAL base address in 32-bit super-page format (KSEG0).
//
// Registers Used:
//
//     AT, a3.
//
//--

#define INITIALIZE_PAL  call_pal initpal

//++
//
// WRITE_KERNEL_ENTRY_POINT
//
// Macro Description:
//
//     Register the kernel entry point to receive control for a
//     class of exceptions.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the address of the kernel entry point.
//     a1 - Supplies the class of exception dispatched to this entry point.
//          0 = bug check conditions
//          1 = memory management faults
//          2 = interrupts
//          3 = system service calls
//          4 = general exception traps
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a2-a3.
//
//--

#define WRITE_KERNEL_ENTRY_POINT  call_pal wrentry

//
// Define entry point values for the wrentry callpal function
//

#define entryBugCheck   0
#define entryMM         1
#define entryInterrupt  2
#define entrySyscall    3
#define entryGeneral    4

//++
//
// CACHE_PCR_VALUES
//
// Macro Description:
//
//     Notify the PALcode that the PCR has been initialized by the
//     kernel and the HAL and that the PALcode may now read values
//     from the PCR and cache them inside the processor.
//
//     N.B. - the PCR pointer must have already been established in
//          initpal
//
//     N.B. - This interface is a processor-specific implementation
//          and cannot be assumed to be present on all processors.
//          Currently implemented for the following processors:
//
//              DECchip 21064
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a0 - a3.
//
//--

#define CACHE_PCR_VALUES  call_pal initpcr

//
// Define transition interfaces
//

//++
//
// RETURN_FROM_TRAP_OR_INTERRUPT
//
// Macro Description:
//
//     Return to execution thread after processing a trap or
//     interrupt.  Traps can be general exceptions (breakpoint,
//     arithmetic traps, etc.) or memory management faults.
//     This macro is also used to startup a thread of execution
//     for the first time.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the previous processor status register.
//     a1 - Supplies new software interrupt requests.
//          a1<1> - Request a DISPATCH Interrupt.
//          a1<0> - Request an APC Interrupt.
//
// Return Value:
//
//     Does not return.
//
// Registers Used:
//
//     None.
//
//--

#define RETURN_FROM_TRAP_OR_INTERRUPT      call_pal rfe

//++
//
// RETURN_FROM_SYSTEM_CALL
//
// Macro Description:
//
//     Return from a system service call.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the previous processor status register.
//     a1 - Supplies new software interrupt requests.
//          a1<1> - Request a DISPATCH Interrupt.
//          a1<0> - Request an APC Interrupt.
//
// Return Value:
//
//     Does not return.
//
// Registers Used:
//
//     All volatile registers.
//
//--

#define RETURN_FROM_SYSTEM_CALL   call_pal retsys

//++
//
// SYSCALL
//
// Macro Description:
//
//     Call a system service.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     v0 - Supplies the system service number.
//     [other arguments as per calling standard]
//
// Return Value:
//
//     Will not return directly, returns via retsys, no return value.
//
// Registers Used:
//
//     All volatile registers.
//
//--

#define SYSCALL  call_pal callsys

//
// Define breakpoint interfaces
//

//++
//
// BREAK
//
// Macro Description:
//
//     Issue a user breakpoint which may be handled by a user-mode
//     debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     None.
//
//--

#define BREAK    call_pal bpt

//++
//
// BREAK_DEBUG_STOP
//
// Macro Description:
//
//     Issue a stop breakpoint to the kernel debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--

#define BREAK_DEBUG_STOP \
    ldil    v0, DEBUG_STOP_BREAKPOINT; \
    call_pal callkd

//++
//++
//
// BREAK_BREAKIN
//
// Macro Description:
//
//     Issue a breakin breakpoint to the kernel debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--

#define BREAK_BREAKIN \
    ldil    v0, BREAKIN_BREAKPOINT; \
    call_pal callkd

//++
//
// BREAK_DEBUG_LOAD_SYMBOLS
//
// Macro Description:
//
//     Issue a load symbols breakpoint to the kernel debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--

#define BREAK_DEBUG_LOAD_SYMBOLS \
    ldil    v0, DEBUG_LOAD_SYMBOLS_BREAKPOINT; \
    call_pal callkd

//++
//
// BREAK_DEBUG_UNLOAD_SYMBOLS
//
// Macro Description:
//
//     Issue a unload symbols breakpoint to the kernel debugger.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Will not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--

#define BREAK_DEBUG_UNLOAD_SYMBOLS \
    ldil    v0, DEBUG_UNLOAD_SYMBOLS_BREAKPOINT; \
    call_pal callkd

//++
//
// BREAK_DEBUG_PRINT
//
// Macro Description:
//
//     Cause a debug print breakpoint which will be interpreted by
//     the kernel debugger and will print a string to the kernel debugger
//     port.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     a0 - Supplies the address of ASCII string to print.
//     a1 - Supplies the length of the string to print.
//
// Return Value:
//
//     Does not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--


#define BREAK_DEBUG_PRINT \
    ldil    v0, DEBUG_PRINT_BREAKPOINT; \
    call_pal callkd

//++
//
// BREAK_DEBUG_PROMPT
//
// Macro Description:
//
//     Cause a debug print breakpoint which will be interpreted by
//     the kernel debugger and will receive a string from the kernel debugger
//     port after prompting for input.
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     a0 - Supplies the address of ASCII string to print.
//     a1 - Supplies the length of the string to print.
//     a2 - Supplies the address of the buffer to receive the input string.
//     a3 - Supplies the maximum length of the input string.
//
// Return Value:
//
//     Does not return directly, returns via rti, no return value.
//
// Registers Used:
//
//     AT, v0.
//
//--


#define BREAK_DEBUG_PROMPT \
    ldil    v0, DEBUG_PROMPT_BREAKPOINT; \
    call_pal callkd

//
// Define tb manipulation interfaces
//

//++
//
// TB_INVALIDATE_ALL
//
// Macro Description:
//
//     Invalidate all cached virtual address translations for the current
//     processor that are not fixed.
//     Some translations may be fixed in hardware and/or software and
//     these are not invalidated (eg. super-pages).
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a0 - a3.
//
//--


#define TB_INVALIDATE_ALL   call_pal tbia

//++
//
// TB_INVALIDATE_SINGLE
//
// Macro Description:
//
//     Invalidate any cached virtual address translations for a single
//     virtual address.
//
//     Note - it is legal for an implementation to invalidate more
//     translations that the single one specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Virtual Address of the translation to invalidate.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a1 - a3.
//
//--

#define TB_INVALIDATE_SINGLE   call_pal tbis

//++
//
// TB_INVALIDATE_MULTIPLE
//
// Macro Description:
//
//     Invalidate any cached virtual address translations for the specified
//     set of virtual addresses.
//
//     Note - it is legal for an implementation to invalidate more
//     translations than those specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies a pointer to the list of Virtual Addresses of the
//          translations to invalidate.
//     a1 - Supplies the count of Virtual Addresses in the list
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a2.
//
//--

#define TB_INVALIDATE_MULTIPLE   call_pal tbim

//++
//
// TB_INVALIDATE_SINGLE_ASN
//
// Macro Description:
//
//     Invalidate any cached virtual address translations for a single
//     virtual address for the specified address space number.
//
//     Note - it is legal for an implementation to invalidate more
//     translations that the single one specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Virtual Address of the translation to invalidate.
//
//     a1 - Supplies the Address Space Number of the translation to be
//          invalidated.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a1 - a3.
//
//--

#define TB_INVALIDATE_SINGLE_ASN   call_pal tbisasn

//++
//
// TB_INVALIDATE_MULTIPLE_ASN
//
// Macro Description:
//
//     Invalidate any cached virtual address translations for the specified
//     set of virtual addresses for the specified address space number.
//
//     Note - it is legal for an implementation to invalidate more
//     translations than those specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies a pointer to the list of Virtual Addresses of the
//          translations to invalidate.
//
//     a1 - Supplies the count of Virtual Addresses in the list
//
//     a2 - Supplies the Address Space Number of the translation to be
//          invalidated.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a3.
//
//--

#define TB_INVALIDATE_MULTIPLE_ASN   call_pal tbimasn

//++
//
// DATA_TB_INVALIDATE_SINGLE
//
// Macro Description:
//
//     Invalidate data stream translations for a single virtual address.
//
//     Note - it is legal for an implementation to invalidate more
//     translations that the single one specified.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Virtual Address of the translation to invalidate.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     a1 - a3.
//
//--

#define DATA_TB_INVALIDATE_SINGLE  call_pal dtbis

//
// Define context switch interfaces
//

//++
//
// SWAP_THREAD_CONTEXT
//
// Macro Description:
//
//
//     Change to a new thread context.  This will mean a new kernel stack,
//     new current thread address and a new thread environment block.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Virtual Address of new initial kernel stack.
//     a1 - Supplies the address of new thread object.
//     a2 - Supplies the address of new thread environment block.
//     a3 - Supplies the PFN of the new page directory if the process
//          is to be swapped, -1 otherwise.
//     a4 - Supplies the ASN of the new processor if the process is to
//          be swapped, undefined otherwise.
//     a5 - Supplies the ASN wrap indicator if the process is to be swapped,
//          undefined otherwise.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT.
//
//--

#define SWAP_THREAD_CONTEXT   call_pal  swpctx

//++
//
// SWAP_PROCESS_CONTEXT
//
// Macro Description:
//
//     Change from one process address space to another.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 - Supplies the Pfn of Page Directory for new address space.
//     a1 - Supplies the Address Space Number for new address space.
//     a2 - Supplies the ASN wrap indicator (0 = no wrap, non-zero = wrap).
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, a3.
//
//--

#define SWAP_PROCESS_CONTEXT  call_pal  swpprocess

//
// Define access to DPC Active flag
//

//++
//
// GET_DPC_ACTIVE_FLAG
//
// Macro Description:
//
//     Return the DPC Active Flag for the current processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 = DPC Active Flag
//
// Registers Used:
//
//     AT.
//
//--

#ifdef NT_UP

//
// The DPC Active flag can be safely acquired from the PCR (there is only one).
//

#define GET_DPC_ACTIVE_FLAG \
        GET_PROCESSOR_CONTROL_REGION_BASE; \
        ldl     v0, PcDpcRoutineActive(v0)

#else

//
// Ensure that the DPC flag fetch is atomic.
//

#define GET_DPC_ACTIVE_FLAG \
        DISABLE_INTERRUPTS;                 \
        GET_PROCESSOR_CONTROL_REGION_BASE;  \
        ldl     v0, PcDpcRoutineActive(v0); \
        ENABLE_INTERRUPTS;

#endif //NT_UP

//++
//
// SET_DPC_ACTIVE_FLAG
//
// Macro Description:
//
//     Set the DPC Active Flag for the current processor.
//
// Mode:
//
//     Kernel only.
//
// Arguments:
//
//     a0 = Supplies the DPC Active Flag Value to set.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT.
//
//--

#define SET_DPC_ACTIVE_FLAG                     \
        .set    noat;                           \
        GET_PROCESSOR_CONTROL_REGION_BASE;      \
        stl     a0, PcDpcRoutineActive(v0);     \
        .set    at


//
// Define interfaces for generate trap
//

//++
//
// GENERATE_TRAP
//
// Macro Description:
//
//     Generate a trap.  Code has discovered an exception condition
//     and wants to raise a trap to indicate the condition.  Anticipated
//     for use by compilers for divide by zero, etc..
//
// Mode:
//
//     Kernel and User.
//
// Arguments:
//
//     a0 = Supplies the trap number which identifies the exception.
//
// Return Value:
//
//     Does not return, generates a trap to kernel mode, no return value.
//
// Registers Used:
//
//     None.
//
//--

#define GENERATE_TRAP call_pal gentrap

//
// Define performance and debug interfaces.
//

//++
//
// GET_INTERNAL_COUNTERS
//
// Macro Description:
//
//     Read the internal processor event counters.  The counter formats
//     and the events counted are processor implementation-dependent.
//
//     N.B. - the counters will only be implemented for checked builds.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     a0 - Supplies the superpage 32 address of the buffer to receive
//          the counter data.  The address must be quadword aligned.
//
//     a1 - Supplies the length of the buffer allocated for the counters.
//
// Return Value:
//
//     v0 - 0 is returned if the interface is not implemented.
//          If v0 <= a1 then v0 is the length of the data returned.
//          If v0 > a1 then v0 is the length of the processor implementation
//          counter record.
//
// Registers Used:
//
//     AT, a2 - a3.
//
//--

#define GET_INTERNAL_COUNTERS  call_pal rdcounters

//++
//
// GET_INTERNAL_PROCESSOR_STATE
//
// Macro Description:
//
//     Read the internal processor state.  The data values returned and
//     their format are processor implementation-dependent.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     a0 - Supplies the superpage 32 address of the buffer to receive
//          the processor state data.  The address must be quadword aligned.
//
//     a1 - Supplies the length of the buffer allocated for the state.
//
// Return Value:
//
//     v0 - If v0 <= a1 then v0 is the length of the data returned.
//          If v0 > a1 then v0 is the length of the processor implementation
//          state record.
//
// Registers Used:
//
//     AT, a2 - a3.
//
//--

#define GET_INTERNAL_PROCESSOR_STATE  call_pal rdstate

//++
//
// WRITE_PERFORMANCE_COUNTERS
//
// Macro Description:
//
//     Write the state of the internal processor performance counters.
//     The number of performance counters, the events they count, and their
//     usage is processor implementation-depedent.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     a0 - Supplies the number of the performance counter.
//
//     a1 - Supplies a flag that indicates if the performance counter is
//          to be enabled or disabled (0 = disabled, non-zero = enabled).
//
//     a2 - a5 - Supply processor implementation-dependent parameters.
//
// Return Value:
//
//     v0 - 0 is returned if the operation is unsuccessful or the performance
//          counter does not exist.  Otherwise, a non-zero value is returned.
//
// Registers Used:
//
//     AT, a2 - a5.
//
//--

#define WRITE_PERFORMANCE_COUNTERS  call_pal wrperfmon


//
// Define interfaces for controlling the state of machine checks.
//

//++
//
// DRAIN_ABORTS
//
// Macro Description:
//
//     Stall processor execution until all previous instructions have
//     executed to the point that any exceptions they may raise have been
//     signalled.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     None.
//
//--

#define DRAIN_ABORTS  call_pal draina


//++
//
// GET_MACHINE_CHECK_ERROR_SUMMARY
//
// Macro Description:
//
//     Read the processor machine check error summary register.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     v0 - The value of the MCES register.
//
// Registers Used:
//
//     AT.
//
//--

#define GET_MACHINE_CHECK_ERROR_SUMMARY  call_pal rdmces


//++
//
// WRITE_MACHINE_CHECK_ERROR_SUMMARY
//
// Macro Description:
//
//     Write new values to the machine check error summary register.
//
// Mode:
//
//     Kernel.
//
// Arguments:
//
//     a0 - Supplies the values to write to the MCES register.
//
// Return Value:
//
//     v0 - Previous value of the MCES register.
//
// Registers Used:
//
//     AT, a1 - a3.
//
//--

#define WRITE_MACHINE_CHECK_ERROR_SUMMARY  call_pal wrmces


//++
//
// LoadByte(
//     Register Value,
//     Offset(Register) Base
//     )
//
// Macro Description:
//
//     Loades the byte at the base address defined by the
//     offset + register expression Base into the register Value
//
// Arguments:
//
//     Value - Supplies the string name of the destination register
//
//     Base - Supplies the base address (as an offset(register) string) of
//            the source of the byte.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT
//
//--

#define LoadByte( Value, Base )        \
        .set    noat;                  \
        lda     AT, Base;              \
        ldq_u   Value, Base;           \
        extbl   Value, AT, Value;      \
        .set    at;


//++
//
// StoreByte(
//     Register Value,
//     Offset(Register) Base
//     )
//
// Macro Description:
//
//     Store the low byte of the register Value at the base address
//     defined by the offset + register expression Base.
//
//     N.B. - This macro preserves longword granularity of accesses.
//
// Arguments:
//
//     Value - Supplies the string name of the register containing the store
//             data.
//
//     Base - Supplies the base address (as an offset(register) string) of
//            the destination of the store.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, t12.
//
//--

#define StoreByte( Value, Base )        \
        .set    noat;                   \
        lda     AT, Base;               \
        ldq_u   t12, (AT);              \
        mskbl   t12, AT, t12;           \
        insbl   Value, AT, AT;          \
        bis     t12, AT, t12;           \
        lda     AT, Base;               \
        bic     AT, 3, AT;              \
        extll   t12, AT, t12;           \
        stl     t12, 0(AT);             \
        .set    at;


//++
//
// ZeroByte(
//     Offset(Register) Base
//     )
//
// Macro Description:
//
//     Zeroes the byte at the address defined by the offset + register
//     expression Base.
//
//     N.B. - This macro preserves longword granularity of accesses.
//
// Arguments:
//
//     Base - Supplies the base address (as an offset(register) string) of
//            the destination of the store.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, t12.
//
//--

#define ZeroByte( Base )        \
        .set    noat;                   \
        lda     AT, Base;               \
        ldq_u   t12, (AT);              \
        mskbl   t12, AT, t12;           \
        bic     AT, 3, AT;              \
        extll   t12, AT, t12;           \
        stl     t12, (AT);              \
        .set    at;

//++
//
// StoreByteAligned(
//     Register Value,
//     Offset(Register) Base
//     )
//
// Macro Description:
//
//     Store the low byte of the register Value at the base address
//     defined by the offset + register expression Base.  This macro
//     is functionally equivalent to StoreByte, but it assumes that
//     Base is dword aligned and optimizes the generated code
//     based on the alignment of Offset.
//
//     N.B. - This macro preserves longword granularity of accesses.
//
// Arguments:
//
//     Value - Supplies the string name of the register containing the store
//             data.
//
//     Base - Supplies the base address (as an offset(register) string) of
//            the destination of the store.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, t12.
//
//--

#define StoreByteAligned( Value, Offset, Base )         \
    .set    noat;                                       \
    ldl     AT, Offset(Base);                           \
    mskbl   AT, 0, t12;                                 \
    bis     t12, Value, AT;                             \
    stl     AT, Offset(Base);                           \
    .set    at;


//++
//
// ClearByteAligned(
//     Offset,
//     Base
//     )
//
// Macro Description:
//
//     Clears the byte at the location defined by the offset + register
//     expression Base.  It assumes that Base is dword aligned and optimizes
//     the generated code based on the alignment of Offset.
//
//     N.B. - This macro preserves longword granularity of accesses.
//
// Arguments:
//
//     Offset - Supplies the offset of the destination of the store.
//
//     Base - Supplies the base address of the destination of the store.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, t12.
//
//--

#define ZeroByteAligned( Offset, Base )          \
    .set    noat;                                       \
    ldl     AT, Offset(Base);                           \
    mskbl   AT, 0, t12;                                 \
    stl     t12, Offset(Base);                          \
    .set    at;



//++
//
// StoreWord(
//     Register Value,
//     Offset(Register) Base
//     )
//
// Macro Description:
//
//     Store the word of the register Value at the word aligned base address
//     defined by the offset + register expression Base.
//
//     N.B. - This macro preserves longword granularity of accesses.
//
//     N.B. - The destination must be word-aligned.
//
// Arguments:
//
//     Value - Supplies the string name of the register containing the store
//             data.
//
//     Base - Supplies the base address (as an offset(register) string) of
//            the destination of the store.
//
// Return Value:
//
//     None.
//
// Registers Used:
//
//     AT, t12.
//
//--

#define StoreWord( Value, Base )        \
        .set    noat;                   \
        lda     AT, Base;               \
        ldq_u   t12, (AT);              \
        mskwl   t12, AT, t12;           \
        inswl   Value, AT, AT;          \
        bis     t12, AT, t12;           \
        lda     AT, Base;               \
        bic     AT, 3, AT;              \
        extll   t12, AT, t12;           \
        stl     t12, 0(AT);             \
        .set    at;

//
// Define subtitle macro
//

#define SBTTL(x)

//
// Define mnemonic for writing callpal in assembly language that will
// fit in the opcode field.
//

#define callpal call_pal

//
// Define exception data section and align.
//
// Nearly all source files that include this header file need the following
// few pseudo-ops and so, by default, they are placed once here rather than
// repeated in every source file.  If these pseudo-ops are not needed, then
// define HEADER_FILE prior to including this file.
//
// Also the PALCODE environment uses this include file but cannot use
// these definitions.
//

#if  !defined(HEADER_FILE) && !defined(PALCODE)

        .edata 0
        .align 2
        .text

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\ksalpha.h ===
#include "kxalpha.h"

//
// Process State Enumerated Type Values
//

#define ProcessInMemory 0x0
#define ProcessOutOfMemory 0x1
#define ProcessInTransition 0x2

//
// Thread State Enumerated Type Values
//

#define Initialized 0x0
#define Ready 0x1
#define Running 0x2
#define Standby 0x3
#define Terminated 0x4
#define Waiting 0x5

//
// Wait Reason Enumerated Type Values
//

#define WrEventPair 0xe

//
// Apc State Structure Offset Definitions
//

#define AsApcListHead 0x0
#define AsProcess 0x10
#define AsKernelApcInProgress 0x14
#define AsKernelApcPending 0x15
#define AsUserApcPending 0x16

//
// Critical Section Structure Offset Definitions
//

#define CsLockCount 0x4
#define CsRecursionCount 0x8
#define CsOwningThread 0xc

//
// Dispatcher Context Structure Offset Definitions
//

#define DcControlPc 0x0
#define DcFunctionEntry 0x4
#define DcEstablisherFrame 0x8
#define DcContextRecord 0xc

//
// Exception Record Offset, Flag, and Enumerated Type Definitions
//

#define EXCEPTION_NONCONTINUABLE 0x1
#define EXCEPTION_UNWINDING 0x2
#define EXCEPTION_EXIT_UNWIND 0x4
#define EXCEPTION_STACK_INVALID 0x8
#define EXCEPTION_NESTED_CALL 0x10
#define EXCEPTION_TARGET_UNWIND 0x20
#define EXCEPTION_COLLIDED_UNWIND 0x40
#define EXCEPTION_UNWIND 0x66

#define ExceptionContinueExecution 0x0
#define ExceptionContinueSearch 0x1
#define ExceptionNestedException 0x2
#define ExceptionCollidedUnwind 0x3

#define ErExceptionCode 0x0
#define ErExceptionFlags 0x4
#define ErExceptionRecord 0x8
#define ErExceptionAddress 0xc
#define ErNumberParameters 0x10
#define ErExceptionInformation 0x14
#define ExceptionRecordLength 0x50

//
// Fast Mutex Structure Offset Definitions
//

#define FmCount 0x0
#define FmOwner 0x4
#define FmContention 0x8
#define FmEvent 0xc
#define FmOldIrql 0x1c

//
// Large Integer Structure Offset Definitions
//

#define LiLowPart 0x0
#define LiHighPart 0x4

//
// List Entry Structure Offset Definitions
//

#define LsFlink 0x0
#define LsBlink 0x4

//
// String Structure Offset Definitions
//

#define StrLength 0x0
#define StrMaximumLength 0x2
#define StrBuffer 0x4

//
// Processor Control Registers Structure Offset Definitions
//

#define PCR_MINOR_VERSION 0x1
#define PCR_MAJOR_VERSION 0x1
#define PcMinorVersion 0x0
#define PcMajorVersion 0x4
#define PcPalBaseAddress 0x8
#define PcPalMajorVersion 0x10
#define PcPalMinorVersion 0x14
#define PcPalSequenceVersion 0x18
#define PcPalMajorSpecification 0x1c
#define PcPalMinorSpecification 0x20
#define PcFirmwareRestartAddress 0x28
#define PcRestartBlock 0x30
#define PcPalReserved 0x38
#define PcPanicStack 0xc38
#define PcProcessorType 0xc3c
#define PcProcessorRevision 0xc40
#define PcPhysicalAddressBits 0xc44
#define PcMaximumAddressSpaceNumber 0xc48
#define PcPageSize 0xc4c
#define PcFirstLevelDcacheSize 0xc50
#define PcFirstLevelDcacheFillSize 0xc54
#define PcFirstLevelIcacheSize 0xc58
#define PcFirstLevelIcacheFillSize 0xc5c
#define PcFirmwareRevisionId 0xc60
#define PcSystemType 0xc64
#define PcSystemVariant 0xc6c
#define PcSystemRevision 0xc70
#define PcSystemSerialNumber 0xc74
#define PcCycleClockPeriod 0xc84
#define PcSecondLevelCacheSize 0xc88
#define PcSecondLevelCacheFillSize 0xc8c
#define PcThirdLevelCacheSize 0xc90
#define PcThirdLevelCacheFillSize 0xc94
#define PcFourthLevelCacheSize 0xc98
#define PcFourthLevelCacheFillSize 0xc9c
#define PcPrcb 0xca0
#define PcNumber 0xca4
#define PcSetMember 0xca8
#define PcHalReserved 0xcb0
#define PcIrqlTable 0xeb0
#define PcIrqlMask 0xed0
#define PcInterruptRoutine 0x10e0
#define PcReservedVectors 0x14e0
#define PcMachineCheckError 0x14f0
#define PcDpcStack 0x14f4
#define PcNotMember 0x14e4
#define PcCurrentPid 0x14fc
#define PcSystemServiceDispatchStart 0x1504
#define PcSystemServiceDispatchEnd 0x1508
#define PcIdleThread 0x150c
#define ProcessorControlRegisterLength 0x1510
#define SharedUserData 0xff000000
#define UsTickCountLow 0x0
#define UsTickCountMultiplier 0x4
#define UsInterruptTime 0x8
#define UsSystemTime 0x10

//
// Processor Block Structure Offset Definitions
//

#define PRCB_MINOR_VERSION 0x1
#define PRCB_MAJOR_VERSION 0x2
#define PbMinorVersion 0x0
#define PbMajorVersion 0x2
#define PbCurrentThread 0x4
#define PbNextThread 0x8
#define PbIdleThread 0xc
#define PbNumber 0x10
#define PbBuildType 0x12
#define PbSetMember 0x14
#define PbRestartBlock 0x18
#define PbInterruptCount 0x1c
#define PbDpcTime 0x20
#define PbInterruptTime 0x24
#define PbKernelTime 0x28
#define PbUserTime 0x2c
#define PbQuantumEndDpc 0x30
#define PbIpiFrozen 0x5c
#define PbIpiCounts 0x310
#define PbProcessorState 0x60
#define PbAlignmentFixupCount 0x334
#define PbContextSwitches 0x338
#define PbDcacheFlushCount 0x33c
#define PbExceptionDispatchcount 0x340
#define PbFirstLevelTbFills 0x344
#define PbFloatingEmulationCount 0x348
#define PbIcacheFlushCount 0x34c
#define PbSecondLevelTbFills 0x350
#define PbSystemCalls 0x354
#define PbCurrentPacket 0x380
#define PbTargetSet 0x38c
#define PbWorkerRoutine 0x390
#define PbRequestSummary 0x3c0
#define PbSignalDone 0x3c4
#define PbDpcListHead 0x468
#define PbDpcLock 0x470
#define PbDpcCount 0x474
#define PbLastDpcCount 0x290
#define PbQuantumEnd 0x478
#define PbStartCount 0x460
#define PbSoftwareInterrupts 0x298
#define PbInterruptActive 0x29c
#define PbDpcRoutineActive 0x47c
#define PbDpcQueueDepth 0x480
#define PbDpcRequestRate 0x45c
#define PbDpcBypassCount 0x294
#define PbApcBypassCount 0x2a0
#define PbDispatchInterruptCount 0x2a4
#define PbDpcInterruptRequested 0x400
#define PbMaximumDpcQueueDepth 0x450
#define PbMinimumDpcRate 0x454
#define PbAdjustDpcThreshold 0x458
#define ProcessorBlockLength 0x490

//
// Immediate Interprocessor Command Definitions
//

#define IPI_APC 0x1
#define IPI_DPC 0x2
#define IPI_FREEZE 0x4
#define IPI_PACKET_READY 0x8

//
// Interprocessor Interrupt Count Structure Offset Definitions
//

#define IcFreeze 0x0
#define IcPacket 0x4
#define IcDPC 0x8
#define IcAPC 0xc
#define IcFlushSingleTb 0x10
#define IcFlushEntireTb 0x18
#define IcChangeColor 0x20
#define IcSweepDcache 0x24
#define IcSweepIcache 0x28
#define IcSweepIcacheRange 0x2c
#define IcFlushIoBuffers 0x30

//
// Thread Environment Block Structure Offset Definitions
//

#define TeStackBase 0x4
#define TeStackLimit 0x8
#define TeEnvironmentPointer 0x1c
#define TeClientId 0x20
#define TeActiveRpcHandle 0x28
#define TeThreadLocalStoragePointer 0x2c
#define TePeb 0x30
#define TeSoftFpcr 0xc8
#define TeCsrQlpcStack 0x44
#define TeGdiClientPID 0x6f4
#define TeGdiClientTID 0x6f8
#define TeGdiThreadLocalInfo 0x6fc
#define TeglDispatchTable 0x714
#define TeglSectionInfo 0xbe0
#define TeglSection 0xbe4
#define TeglTable 0xbe8
#define TeglCurrentRC 0xbec
#define TeglContext 0xbf0
#define PebKernelCallbackTable 0x2c

//
// Time Structure Offset Definitions
//

#define TmLowTime 0x0
#define TmHighTime 0x4

//
// APC object Structure Offset Definitions
//

#define ApType 0x0
#define ApSize 0x2
#define ApThread 0x8
#define ApApcListEntry 0xc
#define ApKernelRoutine 0x14
#define ApRundownRoutine 0x18
#define ApNormalRoutine 0x1c
#define ApNormalContext 0x20
#define ApSystemArgument1 0x24
#define ApSystemArgument2 0x28
#define ApApcStateIndex 0x2c
#define ApApcMode 0x2d
#define ApInserted 0x2e

//
// DPC object Structure Offset Definitions
//

#define DpType 0x0
#define DpDpcListEntry 0x4
#define DpDeferredRoutine 0xc
#define DpDeferredContext 0x10
#define DpSystemArgument1 0x14
#define DpSystemArgument2 0x18
#define DpLock 0x1c

//
// Device object Structure Offset Definitions
//

#define DvType 0x0
#define DvSize 0x2
#define DvDeviceListHead 0x4
#define DvSpinLock 0xc
#define DvBusy 0x10

//
// Device queue entry Structure Offset Definitions
//

#define DeDeviceListEntry 0x0
#define DeSortKey 0x8
#define DeInserted 0xc

//
// Event Structure Offset Definitions
//

#define EvType 0x0
#define EvSize 0x2
#define EvSignalState 0x4
#define EvWaitListHead 0x8

//
// Event Pair Structure Offset Definitions
//

#define EpType 0x0
#define EpSize 0x2
#define EpEventLow 0x4
#define EpEventHigh 0x14

//
// Interrupt Object Structure Offset Definitions
//

#define InType 0x0
#define InSize 0x2
#define InInterruptListEntry 0x4
#define InServiceRoutine 0xc
#define InServiceContext 0x10
#define InSpinLock 0x14
#define InActualLock 0x18
#define InDispatchAddress 0x1c
#define InVector 0x20
#define InIrql 0x24
#define InSynchronizeIrql 0x25
#define InMode 0x2c
#define InNumber 0x28
#define InFloatingSave 0x26
#define InConnected 0x27
#define InDispatchCode 0x34
#define InLevelSensitive 0x0
#define InLatched 0x1

//
// Process Object Structure Offset Definitions
//

#define PrProfileListHead 0x10
#define PrReadyListHead 0x2c
#define PrSwapListEntry 0x34
#define PrThreadListHead 0x3c
#define PrKernelTime 0x24
#define PrUserTime 0x28
#define PrDirectoryTableBase 0x18
#define PrActiveProcessors 0x20
#define PrAffinity 0x48
#define PrStackCount 0x4c
#define PrAutoAlignment 0x50
#define PrBasePriority 0x4e
#define PrState 0x51
#define PrThreadQuantum 0x4f
#define ProcessObjectLength 0x60

//
// Queue Object Structure Offset Definitions
//

#define QuEntryListHead 0x10
#define QuThreadListHead 0x10
#define QuCurrentCount 0x18
#define QuMaximumCount 0x1c

//
// Profile Object Structure Offset Definitions
//

#define PfType 0x0
#define PfSize 0x2
#define PfProfileListEntry 0x4
#define PfProcess 0xc
#define PfRangeBase 0x10
#define PfRangeLimit 0x14
#define PfBucketShift 0x18
#define PfBuffer 0x1c
#define PfStarted 0x2a
#define PfSource 0x28
#define PfAffinity 0x24

//
// Thread Object Structure Offset Definitions
//

#define EeKernelEventPair 0x0
#define EtEventPair 0x224
#define EtPerformanceCountLow 0x204
#define EtPerformanceCountHigh 0x23c
#define EtEthreadLength 0x240
#define ThMutantListHead 0x10
#define ThInitialStack 0x18
#define ThStackLimit 0x1c
#define ThKernelStack 0x20
#define ThTeb 0x24
#define ThDebugActive 0x28
#define ThState 0x29
#define ThAlerted 0x2a
#define ThApcState 0x30
#define ThContextSwitches 0x48
#define ThWaitStatus 0x4c
#define ThWaitIrql 0x50
#define ThWaitMode 0x51
#define ThWaitNext 0x52
#define ThWaitReason 0x53
#define ThWaitBlockList 0x54
#define ThWaitListEntry 0x58
#define ThWaitTime 0x60
#define ThBasePriority 0x64
#define ThDecrementCount 0x65
#define ThPriorityDecrement 0x66
#define ThQuantum 0x67
#define ThWaitBlock 0x68
#define ThQueue 0xe0
#define ThTimer 0xe8
#define ThQueueListEntry 0x110
#define ThAffinity 0x118
#define ThPreempted 0x11c
#define ThProcessReadyQueue 0x11d
#define ThKernelStackResident 0x11e
#define ThNextProcessor 0x11f
#define ThCallbackStack 0x120
#define ThWin32Thread 0x124
#define ThTrapFrame 0x128
#define ThApcStatePointer 0x12c
#define ThKernelApcDisable 0x134
#define ThLargeStack 0x135
#define ThPriority 0x2f
#define ThPreviousMode 0x137
#define ThKernelTime 0x138
#define ThUserTime 0x13c
#define ThSavedApcState 0x140
#define ThAlertable 0x158
#define ThApcStateIndex 0x159
#define ThApcQueueable 0x15a
#define ThAutoAlignment 0x15b
#define ThStackBase 0x15c
#define ThSuspendApc 0x160
#define ThSuspendSemaphore 0x190
#define ThThreadListEntry 0x1a4
#define ThFreezeCount 0x1ac
#define ThSuspendCount 0x1ad
#define ThreadObjectLength 0x1b0
#define EVENT_WAIT_BLOCK_OFFSET 0xb0

//
// Timer object Structure Offset Definitions
//

#define TiDueTime 0x10
#define TiTimerListEntry 0x18
#define TiDpc 0x20
#define TiInserted 0x24
#define TIMER_TABLE_SIZE 0x80

//
// Wait Block Structure Offset Definitions
//

#define WbWaitListEntry 0x0
#define WbThread 0x8
#define WbObject 0xc
#define WbNextWaitBlock 0x10
#define WbWaitKey 0x14
#define WbWaitType 0x16

//
// Context Frame Offset and Flag Definitions
//

#define CONTEXT_FULL 0x20007
#define CONTEXT_CONTROL 0x20001
#define CONTEXT_FLOATING_POINT 0x20002
#define CONTEXT_INTEGER 0x20004

#define CxFltF0 0x0
#define CxFltF1 0x8
#define CxFltF2 0x10
#define CxFltF3 0x18
#define CxFltF4 0x20
#define CxFltF5 0x28
#define CxFltF6 0x30
#define CxFltF7 0x38
#define CxFltF8 0x40
#define CxFltF9 0x48
#define CxFltF10 0x50
#define CxFltF11 0x58
#define CxFltF12 0x60
#define CxFltF13 0x68
#define CxFltF14 0x70
#define CxFltF15 0x78
#define CxFltF16 0x80
#define CxFltF17 0x88
#define CxFltF18 0x90
#define CxFltF19 0x98
#define CxFltF20 0xa0
#define CxFltF21 0xa8
#define CxFltF22 0xb0
#define CxFltF23 0xb8
#define CxFltF24 0xc0
#define CxFltF25 0xc8
#define CxFltF26 0xd0
#define CxFltF27 0xd8
#define CxFltF28 0xe0
#define CxFltF29 0xe8
#define CxFltF30 0xf0
#define CxFltF31 0xf8
#define CxIntV0 0x100
#define CxIntT0 0x108
#define CxIntT1 0x110
#define CxIntT2 0x118
#define CxIntT3 0x120
#define CxIntT4 0x128
#define CxIntT5 0x130
#define CxIntT6 0x138
#define CxIntT7 0x140
#define CxIntS0 0x148
#define CxIntS1 0x150
#define CxIntS2 0x158
#define CxIntS3 0x160
#define CxIntS4 0x168
#define CxIntS5 0x170
#define CxIntFp 0x178
#define CxIntA0 0x180
#define CxIntA1 0x188
#define CxIntA2 0x190
#define CxIntA3 0x198
#define CxIntA4 0x1a0
#define CxIntA5 0x1a8
#define CxIntT8 0x1b0
#define CxIntT9 0x1b8
#define CxIntT10 0x1c0
#define CxIntT11 0x1c8
#define CxIntRa 0x1d0
#define CxIntT12 0x1d8
#define CxIntAt 0x1e0
#define CxIntGp 0x1e8
#define CxIntSp 0x1f0
#define CxIntZero 0x1f8
#define CxFpcr 0x200
#define CxSoftFpcr 0x208
#define CxFir 0x210
#define CxPsr 0x218
#define CxContextFlags 0x21c
#define ContextFrameLength 0x230

//
// Exception Frame Offset Definitions and Length
//

#define ExFltF2 0x8
#define ExFltF3 0x10
#define ExFltF4 0x18
#define ExFltF5 0x20
#define ExFltF6 0x28
#define ExFltF7 0x30
#define ExFltF8 0x38
#define ExFltF9 0x40
#define ExIntS0 0x48
#define ExIntS1 0x50
#define ExIntS2 0x58
#define ExIntS3 0x60
#define ExIntS4 0x68
#define ExIntS5 0x70
#define ExIntFp 0x78
#define ExPsr 0x88
#define ExSwapReturn 0x80
#define ExIntRa 0x0
#define ExceptionFrameLength 0xa0

//
// Jump Offset Definitions and Length
//

#define JbFp 0x0
#define JbPc 0x4
#define JbSeb 0x8
#define JbType 0xc
#define JbFltF2 0x10
#define JbFltF3 0x18
#define JbFltF4 0x20
#define JbFltF5 0x28
#define JbFltF6 0x30
#define JbFltF7 0x38
#define JbFltF8 0x40
#define JbFltF9 0x48
#define JbIntS0 0x50
#define JbIntS1 0x58
#define JbIntS2 0x60
#define JbIntS3 0x68
#define JbIntS4 0x70
#define JbIntS5 0x78
#define JbIntS6 0x80
#define JbIntSp 0x88
#define JbFir 0x90

//
// Trap Frame Offset Definitions and Length
//

#define TrFltF0 0x128
#define TrFltF1 0x138
#define TrFltF10 0x140
#define TrFltF11 0x148
#define TrFltF12 0x150
#define TrFltF13 0x158
#define TrFltF14 0x160
#define TrFltF15 0x168
#define TrFltF16 0x170
#define TrFltF17 0x178
#define TrFltF18 0x180
#define TrFltF19 0x188
#define TrFltF20 0x190
#define TrFltF21 0x198
#define TrFltF22 0x1a0
#define TrFltF23 0x1a8
#define TrFltF24 0x1b0
#define TrFltF25 0x1b8
#define TrFltF26 0x1c0
#define TrFltF27 0x1c8
#define TrFltF28 0x1d0
#define TrFltF29 0x1d8
#define TrFltF30 0x1e0
#define TrIntV0 0xa0
#define TrIntT0 0xa8
#define TrIntT1 0xb0
#define TrIntT2 0xb8
#define TrIntT3 0xc0
#define TrIntT4 0xc8
#define TrIntT5 0xd0
#define TrIntT6 0xd8
#define TrIntT7 0xe0
#define TrIntFp 0x18
#define TrIntA0 0x20
#define TrIntA1 0x28
#define TrIntA2 0x30
#define TrIntA3 0x38
#define TrIntA4 0x118
#define TrIntA5 0x120
#define TrIntT8 0xe8
#define TrIntT9 0xf0
#define TrIntT10 0xf8
#define TrIntT11 0x100
#define TrIntT12 0x108
#define TrIntAt 0x110
#define TrIntGp 0x48
#define TrIntSp 0x0
#define TrFpcr 0x130
#define TrPsr 0x10
#define TrPreviousKsp 0x14
#define TrFir 0x8
#define TrExceptionRecord 0x50
#define TrOldIrql 0x1e8
#define TrPreviousMode 0x1ec
#define TrIntRa 0x40
#define TrTrapFrame 0x1f0
#define TrapFrameLength 0x200

//
// Loader Parameter Block Offset Definitions
//

#define LpbLoadOrderListHead 0x0
#define LpbMemoryDescriptorListHead 0x8
#define LpbKernelStack 0x18
#define LpbPrcb 0x1c
#define LpbProcess 0x20
#define LpbThread 0x24
#define LpbRegistryLength 0x28
#define LpbRegistryBase 0x2c
#define LpbDpcStack 0x60
#define LpbFirstLevelDcacheSize 0x64
#define LpbFirstLevelDcacheFillSize 0x68
#define LpbFirstLevelIcacheSize 0x6c
#define LpbFirstLevelIcacheFillSize 0x70
#define LpbGpBase 0x74
#define LpbPanicStack 0x78
#define LpbPcrPage 0x7c
#define LpbPdrPage 0x80
#define LpbSecondLevelDcacheSize 0x84
#define LpbSecondLevelDcacheFillSize 0x88
#define LpbSecondLevelIcacheSize 0x8c
#define LpbSecondLevelIcacheFillSize 0x90
#define LpbPhysicalAddressBits 0x94
#define LpbMaximumAddressSpaceNumber 0x98
#define LpbSystemSerialNumber 0x9c
#define LpbSystemType 0xac
#define LpbSystemVariant 0xb4
#define LpbSystemRevision 0xb8
#define LpbProcessorType 0xbc
#define LpbProcessorRevision 0xc0
#define LpbCycleClockPeriod 0xc4
#define LpbPageSize 0xc8
#define LpbRestartBlock 0xcc
#define LpbFirmwareRestartAddress 0xd0
#define LpbFirmwareRevisionId 0xd8
#define LpbPalBaseAddress 0xdc

//
// Client/Server data structure definitions.
//

#define CidUniqueProcess 0x0
#define CidUniqueThread 0x4
#define CsrlClientThread 0x0
#define CsrlMessageStack 0xc

//
//  System Service Descriptor Table structure definitions.
//

#define NUMBER_SERVICE_TABLES 0x2
#define SERVICE_NUMBER_MASK 0xfff
#define SERVICE_TABLE_SHIFT 0x8
#define SERVICE_TABLE_MASK 0x10
#define SdBase 0x0
#define SdCount 0x4
#define SdLimit 0x8
#define SdNumber 0xc

//
// Restart Block Structure Definitions
//

#define RbSignature 0x0
#define RbLength 0x4
#define RbVersion 0x8
#define RbRevision 0xa
#define RbNextRestartBlock 0xc
#define RbRestartAddress 0x10
#define RbBootMasterId 0x14
#define RbProcessorId 0x18
#define RbBootStatus 0x1c
#define RbCheckSum 0x20
#define RbSaveAreaLength 0x24
#define RbSaveArea 0x28
#define RbHaltReason 0x28
#define RbLogoutFrame 0x2c
#define RbPalBase 0x30
#define RbIntV0 0x38
#define RbIntT0 0x40
#define RbIntT1 0x48
#define RbIntT2 0x50
#define RbIntT3 0x58
#define RbIntT4 0x60
#define RbIntT5 0x68
#define RbIntT6 0x70
#define RbIntT7 0x78
#define RbIntS0 0x80
#define RbIntS1 0x88
#define RbIntS2 0x90
#define RbIntS3 0x98
#define RbIntS4 0xa0
#define RbIntS5 0xa8
#define RbIntFp 0xb0
#define RbIntA0 0xb8
#define RbIntA1 0xc0
#define RbIntA2 0xc8
#define RbIntA3 0xd0
#define RbIntA4 0xd8
#define RbIntA5 0xe0
#define RbIntT8 0xe8
#define RbIntT9 0xf0
#define RbIntT10 0xf8
#define RbIntT11 0x100
#define RbIntRa 0x108
#define RbIntT12 0x110
#define RbIntAT 0x118
#define RbIntGp 0x120
#define RbIntSp 0x128
#define RbIntZero 0x130
#define RbFpcr 0x138
#define RbFltF0 0x140
#define RbFltF1 0x148
#define RbFltF2 0x150
#define RbFltF3 0x158
#define RbFltF4 0x160
#define RbFltF5 0x168
#define RbFltF6 0x170
#define RbFltF7 0x178
#define RbFltF8 0x180
#define RbFltF9 0x188
#define RbFltF10 0x190
#define RbFltF11 0x198
#define RbFltF12 0x1a0
#define RbFltF13 0x1a8
#define RbFltF14 0x1b0
#define RbFltF15 0x1b8
#define RbFltF16 0x1c0
#define RbFltF17 0x1c8
#define RbFltF18 0x1d0
#define RbFltF19 0x1d8
#define RbFltF20 0x1e0
#define RbFltF21 0x1e8
#define RbFltF22 0x1f0
#define RbFltF23 0x1f8
#define RbFltF24 0x200
#define RbFltF25 0x208
#define RbFltF26 0x210
#define RbFltF27 0x218
#define RbFltF28 0x220
#define RbFltF29 0x228
#define RbFltF30 0x230
#define RbFltF31 0x238
#define RbAsn 0x240
#define RbGeneralEntry 0x244
#define RbIksp 0x248
#define RbInterruptEntry 0x24c
#define RbKgp 0x250
#define RbMces 0x254
#define RbMemMgmtEntry 0x258
#define RbPanicEntry 0x25c
#define RbPcr 0x260
#define RbPdr 0x264
#define RbPsr 0x268
#define RbReiRestartAddress 0x26c
#define RbSirr 0x270
#define RbSyscallEntry 0x274
#define RbTeb 0x278
#define RbThread 0x27c
#define RbPerProcessorState 0x280

//
// Address Space Layout Definitions
//

#define KSEG0_BASE 0x80000000
#define KSEG2_BASE 0xc0000000
#define SYSTEM_BASE 0xc0800000
#define PDE_BASE 0xc0180000
#define PTE_BASE 0xc0000000

//
// Page Table and Directory Entry Definitions
//

#define PAGE_SIZE 0x2000
#define PAGE_SHIFT 0xd
#define PDI_SHIFT 0x18
#define PTI_SHIFT 0xd

//
// Interrupt Priority Request Level Definitions
//

#define APC_LEVEL 0x1
#define DISPATCH_LEVEL 0x2
#define IPI_LEVEL 0x6
#define POWER_LEVEL 0x7
#define HIGH_LEVEL 0x7

//
// Bug Check Code Definitions
//

#define DATA_BUS_ERROR 0x2e
#define INSTRUCTION_BUS_ERROR 0x2f
#define INTERRUPT_EXCEPTION_NOT_HANDLED 0x3d
#define INTERRUPT_UNWIND_ATTEMPTED 0x3c
#define INVALID_DATA_ACCESS_TRAP 0x4
#define IRQL_NOT_LESS_OR_EQUAL 0xa
#define NO_USER_MODE_CONTEXT 0xe
#define PANIC_STACK_SWITCH 0x2b
#define SYSTEM_EXIT_OWNED_MUTEX 0x39
#define SYSTEM_SERVICE_EXCEPTION 0x3b
#define SYSTEM_UNWIND_PREVIOUS_USER 0x3a
#define TRAP_CAUSE_UNKNOWN 0x12

//
// Breakpoint Definitions
//

#define USER_BREAKPOINT 0x0
#define KERNEL_BREAKPOINT 0x1
#define BREAKIN_BREAKPOINT 0x19
#define DEBUG_PRINT_BREAKPOINT 0x14
#define DEBUG_PROMPT_BREAKPOINT 0x15
#define DEBUG_STOP_BREAKPOINT 0x16
#define DEBUG_LOAD_SYMBOLS_BREAKPOINT 0x17
#define DEBUG_UNLOAD_SYMBOLS_BREAKPOINT 0x18

//
// Trap Code Definitions
//

#define GENTRAP_INTEGER_OVERFLOW 0xffffffff
#define GENTRAP_INTEGER_DIVIDE_BY_ZERO 0xfffffffe
#define GENTRAP_FLOATING_OVERFLOW 0xfffffffd
#define GENTRAP_FLOATING_DIVIDE_BY_ZERO 0xfffffffc
#define GENTRAP_FLOATING_UNDERFLOW 0xfffffffb
#define GENTRAP_FLOATING_INVALID_OPERAND 0xfffffffa
#define GENTRAP_FLOATING_INEXACT_RESULT 0xfffffff9

//
// Status Code Definitions
//

#define STATUS_SUCCESS 0x0
#define STATUS_ALPHA_MACHINE_CHECK 0xdfff002e
#define STATUS_ACCESS_VIOLATION 0xc0000005
#define STATUS_GUARD_PAGE_VIOLATION 0x80000001
#define STATUS_STACK_OVERFLOW 0xc00000fd
#define STATUS_IN_PAGE_ERROR 0xc0000006
#define STATUS_DATATYPE_MISALIGNMENT 0x80000002
#define STATUS_INVALID_OWNER 0xc000005a
#define STATUS_INVALID_SYSTEM_SERVICE 0xc000001c
#define STATUS_ILLEGAL_INSTRUCTION 0xc000001d
#define STATUS_KERNEL_APC 0x100
#define STATUS_BREAKPOINT 0x80000003
#define STATUS_SINGLE_STEP 0x80000004
#define STATUS_INTEGER_OVERFLOW 0xc0000095
#define STATUS_INVALID_LOCK_SEQUENCE 0xc000001e
#define STATUS_INSTRUCTION_MISALIGNMENT 0xc00000aa
#define STATUS_FLOAT_STACK_CHECK 0xc0000092
#define STATUS_NO_EVENT_PAIR 0xc000014e
#define STATUS_INTEGER_DIVIDE_BY_ZERO 0xc0000094
#define STATUS_INVALID_PARAMETER_1 0xc00000ef
#define STATUS_UNWIND 0xc0000027
#define STATUS_ALPHA_FLOATING_NOT_IMPLEMENTED 0xc000014a
#define STATUS_ALPHA_ARITHMETIC_EXCEPTION 0xc0000092
#define STATUS_ALPHA_GENTRAP 0xc00000aa
#define STATUS_ALPHA_BAD_VIRTUAL_ADDRESS 0xc0000005
#define STATUS_NO_CALLBACK_ACTIVE 0xc0000258
#define STATUS_BAD_COMPRESSION_BUFFER 0xc0000242

//
// Miscellaneous Definitions
//

#define Executive 0x0
#define KernelMode 0x0
#define FALSE 0x0
#define TRUE 0x1
#define BASE_PRIORITY_THRESHOLD 0x8
#define EVENT_PAIR_INCREMENT 0x1
#define LOW_REALTIME_PRIORITY 0x10
#define MM_USER_PROBE_ADDRESS 0x7fff0000
#define KERNEL_STACK_SIZE 0x4000
#define KERNEL_LARGE_STACK_COMMIT 0x4000
#define SET_LOW_WAIT_HIGH 0xfffffffe
#define SET_HIGH_WAIT_LOW 0xffffffff
#define THREAD_QUANTUM 0x2
#define PROCESSOR_ALPHA_21064 0x5248
#define PROCESSOR_ALPHA_21164 0x52ac
#define PROCESSOR_ALPHA_21066 0x524a
#define PROCESSOR_ALPHA_21068 0x524c
#define PTE_VALID_MASK 0x1
#define PTE_VALID 0x0
#define PTE_OWNER_MASK 0x2
#define PTE_OWNER 0x1
#define PTE_DIRTY_MASK 0x4
#define PTE_DIRTY 0x2
#define PTE_GLOBAL_MASK 0x10
#define PTE_GLOBAL 0x4
#define PTE_WRITE_MASK 0x80
#define PTE_WRITE 0x7
#define PTE_COPYONWRITE_MASK 0x100
#define PTE_COPYONWRITE 0x8
#define PTE_PFN_MASK 0xfffffe00
#define PTE_PFN 0x9
#define PSR_MODE_MASK 0x1
#define PSR_USER_MODE 0x1
#define PSR_MODE 0x0
#define PSR_IE_MASK 0x2
#define PSR_IE 0x1
#define PSR_IRQL_MASK 0x1c
#define PSR_IRQL 0x2
#define IE_SFW_MASK 0x3
#define IE_SFW 0x0
#define IE_HDW_MASK 0xfc
#define IE_HDW 0x2
#define MCHK_CORRECTABLE_MASK 0x1
#define MCHK_CORRECTABLE 0x0
#define MCHK_RETRYABLE_MASK 0x2
#define MCHK_RETRYABLE 0x1
#define MCES_MCK_MASK 0x1
#define MCES_MCK 0x0
#define MCES_SCE_MASK 0x2
#define MCES_SCE 0x1
#define MCES_PCE_MASK 0x4
#define MCES_PCE 0x2
#define MCES_DPC_MASK 0x8
#define MCES_DPC 0x3
#define MCES_DSC_MASK 0x10
#define MCES_DSC 0x4
#define MCES_DMCK_MASK 0x20
#define MCES_DMCK 0x5
#define EXCSUM_SWC_MASK 0x1
#define EXCSUM_SWC 0x0
#define EXCSUM_INV_MASK 0x2
#define EXCSUM_INV 0x1
#define EXCSUM_DZE_MASK 0x4
#define EXCSUM_DZE 0x2
#define EXCSUM_OVF_MASK 0x8
#define EXCSUM_OVF 0x3
#define EXCSUM_UNF_MASK 0x10
#define EXCSUM_UNF 0x4
#define EXCSUM_INE_MASK 0x20
#define EXCSUM_INE 0x5
#define EXCSUM_IOV_MASK 0x40
#define EXCSUM_IOV 0x6

//
// Call PAL mnemonics
//

// begin callpal

#define bpt 0x80
#define callsys 0x83
#define imb 0x86
#define gentrap 0xaa
#define rdteb 0xab
#define kbpt 0xac
#define callkd 0xad
#define halt 0x0
#define restart 0x1
#define draina 0x2
#define reboot 0x3
#define initpal 0x4
#define wrentry 0x5
#define swpirql 0x6
#define rdirql 0x7
#define di 0x8
#define ei 0x9
#define swppal 0xa
#define ssir 0xc
#define csir 0xd
#define rfe 0xe
#define retsys 0xf
#define swpctx 0x10
#define swpprocess 0x11
#define rdmces 0x12
#define wrmces 0x13
#define tbia 0x14
#define tbis 0x15
#define tbisasn 0x17
#define dtbis 0x16
#define rdksp 0x18
#define swpksp 0x19
#define rdpsr 0x1a
#define rdpcr 0x1c
#define rdthread 0x1e
#define tbim 0x20
#define tbimasn 0x21
#define rdcounters 0x30
#define rdstate 0x31
#define wrperfmon 0x32
#define initpcr 0x38

// end callpal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\ipserver.h ===
//=--------------------------------------------------------------------------=
// InProcServer.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// global header file that contains all the windows stuff, etc ...  should
// be pre-compiled to speed things up a little bit.
//
#ifndef _INPROCSERVER_H_

#define INC_OLE2
#include <windows.h>
#include <stddef.h>                    // for offsetof()
#include <olectl.h>

#ifdef VC4_BUILD
    typedef BOOL bool;
    #define false FALSE
    #define true  TRUE
#endif

// things that -everybody- wants [read: is going to get]
//
#include "Debug.H"

//=--------------------------------------------------------------------------=
// we don't want to use the CRTs, and would like some memory tracking in the
// debug case, so we'll override these guys
//=--------------------------------------------------------------------------=
//
void * _cdecl operator new(size_t size);
void  _cdecl operator delete(void *ptr);


//=--------------------------------------------------------------------------=
// Useful macros
//=--------------------------------------------------------------------------=
//
// handy error macros, randing from cleaning up, to returning to clearing
// rich error information as well.
//
#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp
#define CLEARERRORINFORET(hr) { SetErrorInfo(0, NULL); return hr; }
#define CLEARERRORINFORET_ON_FAILURE(hr) if (FAILED(hr)) { SetErrorInfo(0, NULL); return hr; }

#define CLEANUP_ON_ERROR(l)    if (l != ERROR_SUCCESS) goto CleanUp

// conversions
//
#define BOOL_TO_VARIANTBOOL(f) (f) ? VARIANT_TRUE : VARIANT_FALSE

// Reference counting help.
//
#define RELEASE_OBJECT(ptr)    if (ptr) { IUnknown *__pUnk = (ptr); (ptr) = NULL; __pUnk->Release(); }
#define QUICK_RELEASE(ptr)     if (ptr) ((IUnknown *)ptr)->Release();
#define ADDREF_OBJECT(ptr)     if (ptr) (ptr)->AddRef()



//=--------------------------------------------------------------------------=
// QueryInterface Optimizations
//=--------------------------------------------------------------------------=
// for optimizing QI's
//
#define DO_GUIDS_MATCH(riid1, riid2) ((riid1.Data1 == riid2.Data1) && (riid1 == riid2))

// Data1_*
//
// the first dword of GUIDs for most of the interesting interfaces.  these are
// used by speed critical versions of QueryInterface
//
#define Data1_IActiveDesigner              0x51AAE3E0
#define Data1_IAdviseSink                  0x0000010f
#define Data1_IAdviseSink2                 0x00000125
#define Data1_IAdviseSinkEx                0x3af24290
#define Data1_IBindCtx                     0x0000000e
#define Data1_ICDataDoc                    0xF413E4C0
#define Data1_IClassFactory                0x00000001
#define Data1_IClassFactory2               0xb196b28f
#define Data1_IConnectionPoint             0xb196b286
#define Data1_IConnectionPointContainer    0xb196b284
#define Data1_IControl_95                  0x9a4bbfb5
#define Data1_IControl                     0xa7fddba0
#define Data1_ICreateErrorInfo             0x22f03340
#define Data1_ICreateTypeInfo              0x00020405
#define Data1_ICreateTypeLib               0x00020406
#define Data1_IDataAdviseHolder            0x00000110
#define Data1_IDataFrame                   0x97F254E0
#define Data1_IDataFrameExpert             0x73687490
#define Data1_IDataObject                  0x0000010e
#define Data1_IDispatch                    0x00020400
#define Data1_IDropSource                  0x00000121
#define Data1_IDropTarget                  0x00000122
#define Data1_IEnumCallback                0x00000108
#define Data1_IEnumConnectionPoints        0xb196b285
#define Data1_IEnumConnections             0xb196b287
#define Data1_IEnumFORMATETC               0x00000103
#define Data1_IEnumGeneric                 0x00000106
#define Data1_IEnumHolder                  0x00000107
#define Data1_IEnumMoniker                 0x00000102
#define Data1_IEnumOLEVERB                 0x00000104
#define Data1_IEnumSTATDATA                0x00000105
#define Data1_IEnumSTATSTG                 0x0000000d
#define Data1_IEnumString                  0x00000101
#define Data1_IEnumOleUndoActions          0xb3e7c340
#define Data1_IEnumUnknown                 0x00000100
#define Data1_IEnumVARIANT                 0x00020404
#define Data1_IErrorInfo                   0x1cf2b120
#define Data1_IExternalConnection          0x00000019
#define Data1_IFont                        0xbef6e002
#define Data1_IFontDisp                    0xbef6e003
#define Data1_IFormExpert                  0x5aac7f70
#define Data1_IGangConnectWithDefault      0x6d5140c0
#define Data1_IInternalMoniker             0x00000011
#define Data1_ILockBytes                   0x0000000a
#define Data1_IMalloc                      0x00000002
#define Data1_IMarshal                     0x00000003
#define Data1_IMessageFilter               0x00000016
#define Data1_IMoniker                     0x0000000f
#define Data1_IMsoCommandTarget            0xb722bccb
#define Data1_IMsoDocument                 0xb722bcc5
#define Data1_IOleInPlaceComponent         0x5efc7970
#define Data1_IMsoView                     0xb722bcc6
#define Data1_IOleAdviseHolder             0x00000111
#define Data1_IOleCache                    0x0000011e
#define Data1_IOleCache2                   0x00000128
#define Data1_IOleCacheControl             0x00000129
#define Data1_IOleClientSite               0x00000118
#define Data1_IOleCompoundUndoAction       0xa1faf330
#define Data1_IOleContainer                0x0000011b
#define Data1_IOleControl                  0xb196b288
#define Data1_IOleControlSite              0xb196b289
#define Data1_IOleInPlaceActiveObject      0x00000117
#define Data1_IOleInPlaceFrame             0x00000116
#define Data1_IOleInPlaceObject            0x00000113
#define Data1_IOleInPlaceObjectWindowless  0x1c2056cc
#define Data1_IOleInPlaceSite              0x00000119
#define Data1_IOleInPlaceSiteEx            0x9c2cad80
#define Data1_IOleInPlaceSiteWindowless    0x922eada0
#define Data1_IOleInPlaceUIWindow          0x00000115
#define Data1_IOleItemContainer            0x0000011c
#define Data1_IOleLink                     0x0000011d
#define Data1_IOleManager                  0x0000011f
#define Data1_IOleObject                   0x00000112
#define Data1_IOlePresObj                  0x00000120
#define Data1_IOlePropertyFrame            0xb83bb801
#define Data1_IOleStandardTool             0xd97877c4
#define Data1_IOleUndoAction               0x894ad3b0
#define Data1_IOleUndoActionManager        0xd001f200
#define Data1_IOleWindow                   0x00000114
#define Data1_IPSFactory                   0x00000009
#define Data1_IPSFactoryBuffer             0xd5f569d0
#define Data1_IParseDisplayName            0x0000011a
#define Data1_IPerPropertyBrowsing         0x376bd3aa
#define Data1_IPersist                     0x0000010c
#define Data1_IPersistFile                 0x0000010b
#define Data1_IPersistPropertyBag          0x37D84F60
#define Data1_IPersistStorage              0x0000010a
#define Data1_IPersistStream               0x00000109
#define Data1_IPersistStreamInit           0x7fd52380
#define Data1_IPicture                     0x7bf80980
#define Data1_IPictureDisp                 0x7bf80981
#define Data1_IPointerInactive             0x55980ba0
#define Data1_IPropertyNotifySink          0x9bfbbc02
#define Data1_IPropertyPage                0xb196b28d
#define Data1_IPropertyPage2               0x01e44665
#define Data1_IPropertyPage3               0xb83bb803
#define Data1_IPropertyPageInPlace         0xb83bb802
#define Data1_IPropertyPageSite            0xb196b28c
#define Data1_IPropertyPageSite2           0xb83bb804
#define Data1_IProvideClassInfo            0xb196b283
#define Data1_IProvideDynamicClassInfo     0x468cfb80
#define Data1_IQuickActivate               0xcf51ed10
#define Data1_IRequireClasses              0x6d5140d0
#define Data1_IRootStorage                 0x00000012
#define Data1_IRunnableObject              0x00000126
#define Data1_IRunningObjectTable          0x00000010
#define Data1_ISelectionContainer          0x6d5140c6
#define Data1_IServiceProvider             0x6d5140c1
#define Data1_ISimpleFrameSite             0x742b0e01
#define Data1_ISpecifyPropertyPages        0xb196b28b
#define Data1_IStdMarshalInfo              0x00000018
#define Data1_IStorage                     0x0000000b
#define Data1_IStream                      0x0000000c
#define Data1_ISupportErrorInfo            0xdf0b3d60
#define Data1_ITypeComp                    0x00020403
#define Data1_ITypeInfo                    0x00020401
#define Data1_ITypeLib                     0x00020402
#define Data1_IUnknown                     0x00000000
#define Data1_IViewObject                  0x0000010d
#define Data1_IViewObject2                 0x00000127
#define Data1_IViewObjectEx                0x3af24292
#define Data1_IWeakRef                     0x0000001a
#define Data1_ICategorizeProperties        0x4d07fc10
#define Data1_IObjectSafety                0xcb5bdc81

#define QI_INHERITS(pObj, itf)              \
    case Data1_##itf:                       \
      if(DO_GUIDS_MATCH(riid, IID_##itf))   \
      {                                     \
        itf *pITF = pObj;                   \
        *ppvObjOut = (void *)(itf *)pObj;   \
      }                                     \
      break;

#define SAFE_CAST(varDest, varSrc, type) \
    { type var = varSrc; varDest = (type)varSrc; }



#define _INPROCSERVER_H_
#endif // _INPROCSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\macros.h ===
//=--------------------------------------------------------------------------=
// Macros.h
//=--------------------------------------------------------------------------=
// Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
// Handy macros like the ones we use in the VB code base.
//=--------------------------------------------------------------------------=
#ifndef _MACROS_H_

#include <globals.h>

//---------------------------------------------------------------------------
//  Debugging Heap Memory Leaks:
//		Macros and definitions		
//---------------------------------------------------------------------------
#ifdef DEBUG
typedef char * LPSZ;
#define NUM_INST_TABLE_ENTRIES 1024
#define Deb_FILELINEPROTO   , LPSTR lpszFile, UINT line
#define Deb_FILELINECALL    , __FILE__, __LINE__
#define Deb_FILELINEPASS    , lpszFile, line
#else  // DEBUG
#define Deb_FILELINEPROTO
#define Deb_FILELINECALL
#define Deb_FILELINEPASS
#endif  // DEBUG


// Function prototypes for the actual implementations of the debug heap wrapper functions.
#ifdef DEBUG
LPVOID CtlHeapAllocImpl(HANDLE g_hHeap, DWORD dwFlags, DWORD dwBytes Deb_FILELINEPROTO);
LPVOID CtlHeapReAllocImpl(HANDLE g_hHeap, DWORD dwFlags, LPVOID lpvMem, DWORD dwBytes Deb_FILELINEPROTO);
BOOL   CtlHeapFreeImpl(HANDLE g_hHeap, DWORD dwFlags, LPVOID lpvMem);
extern VOID CheckForLeaks(VOID);
inline UINT HashInst(VOID * pv) { return ((UINT) ((ULONG)pv >> 4)) % NUM_INST_TABLE_ENTRIES; } //  Hashing function
#endif // DEBUG


#define OleAlloc(dwBytes)									CoTaskMemAlloc(dwBytes)
#define OleReAlloc(lpvMem, dwBytes)			  CoTaskMemReAlloc(lpvMem, dwBytes)
#define OleFree(lpvMem)										CoTaskMemFree(lpvMem)
#define New																new (g_hHeap Deb_FILELINECALL)

//--------------------------------------------------------------------------------------------------
//	Macros for our memory leak detection

#ifdef DEBUG
// Use these functions to allocate memory from the global heap.
#define CtlHeapAlloc(g_hHeap, dwFlags, dwBytes)						CtlHeapAllocImpl(g_hHeap, dwFlags, dwBytes Deb_FILELINECALL)
#define CtlHeapReAlloc(g_hHeap, dwFlags, lpvMem, dwBytes)	CtlHeapReAllocImpl(g_hHeap, dwFlags, lpvMem, dwBytes Deb_FILELINECALL)
#define CtlHeapFree(g_hHeap, dwFlags, lpvMem)							CtlHeapFreeImpl(g_hHeap, dwFlags, lpvMem)
#define CtlAlloc(dwBytes)																	CtlHeapAllocImpl(g_hHeap, 0, dwBytes Deb_FILELINECALL)
#define CtlAllocZero(dwBytes)															CtlHeapAllocImpl(g_hHeap, HEAP_ZERO_MEMORY, dwBytes Deb_FILELINECALL)
#define CtlReAlloc(lpvMem, dwBytes)																	CtlHeapReAllocImpl(g_hHeap, 0, lpvMem, dwBytes Deb_FILELINECALL)
#define CtlReAllocZero(lpvMem, dwBytes)																	CtlHeapReAllocImpl(g_hHeap, HEAP_ZERO_MEMORY, lpvMem, dwBytes Deb_FILELINECALL)
#define CtlFree(lpvMem)																		CtlHeapFreeImpl(g_hHeap, 0, lpvMem)
#define NewCtlHeapAlloc(g_hHeap, dwFlags, dwBytes)				CtlHeapAllocImpl(g_hHeap, dwFlags, dwBytes Deb_FILELINEPASS)

#else
// In retail on Win32 we map directly to the Win32 Heap API
#define CtlHeapAlloc(g_hHeap, dwFlags, dwBytes)						HeapAlloc(g_hHeap, dwFlags, dwBytes)
#define CtlHeapReAlloc(g_hHeap, dwFlags, lpvMem, dwBytes) HeapReAlloc(g_hHeap, dwFlags, lpvMem, dwBytes)
#define CtlHeapFree(g_hHeap, dwFlags, lpvMem)							HeapFree(g_hHeap, dwFlags, lpvMem)
#define CtlAlloc(dwBytes)																	HeapAlloc(g_hHeap, 0, dwBytes)
#define CtlAllocZero(dwBytes)															HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, dwBytes)
#define CtlReAlloc(lpvMem, dwBytes)																	HeapReAlloc(g_hHeap, 0, lpvMem, dwBytes)
#define CtlReAllocZero(lpvMem, dwBytes)																	HeapReAlloc(g_hHeap, HEAP_ZERO_MEMORY, lpvMem, dwBytes)
#define CtlFree(lpvMem)																		HeapFree(g_hHeap, 0, lpvMem)
#define NewCtlHeapAlloc(g_hHeap, dwFlags, dwBytes)				HeapAlloc(g_hHeap, dwFlags, dwBytes)
#endif // DEBUG

//	Macros for header files
//  SZTHISFILE cannot be defined in header files.  These macros avoid its re-definition
#ifdef DEBUG
#define CtlHeapAlloc_Header_Util(g_hHeap, dwFlags, dwBytes)	CtlHeapAllocImpl(g_hHeap, dwFlags, dwBytes, __FILE__, __LINE__);
#else
#define CtlHeapAlloc_Header_Util(g_hHeap, dwFlags, dwBytes)	HeapAlloc (g_hHeap, dwFlags, dwBytes);
#endif // DEBUG


//=---------------------------------------------------------------------------=
// class CtlNewDelete
//
// This class MUST be inherited by any class in the CTLS Tree that wants
// to use "new" or "delete" to allocate/free.
//
// This class has no data members or virtual functions, so it does not
// change the size of any instances of classes which inherit from it.
//=---------------------------------------------------------------------------=
class CtlNewDelete
{
public:
inline void * _cdecl operator new (size_t size, HANDLE g_hHeap Deb_FILELINEPROTO);
inline void _cdecl operator delete (LPVOID pv, HANDLE g_hHeap Deb_FILELINEPROTO);
inline void _cdecl operator delete (LPVOID pv);
};


//=---------------------------------------------------------------------------=
// CtlNewDelete::operator new
//=---------------------------------------------------------------------------=
// Parameters:
//    size_t         - [in] what size do we alloc
//		g_hHeap				 - [in] our global heap
//		lpszFile			 - [in] what file are we allocating from
//		line					 - [in] what line # do we allocate from
//
// Output:
//    VOID *         - new memory.
//
// Notes:
//
// We don't need to worry about ENTERCRITICALSECTION1 here.
// New is either called by the c run-time or after
// g_hHeap has been initialized in DllMain PROCESS_ATTACH.
// In either case this call is synchronized.
// If we try putting ENTERCRITICALSECTION1 here, we will
// blow up if the c run-time is attempting to initialize
// our static objects such as objects w/ global constructors.
inline void * _cdecl CtlNewDelete::operator new (size_t size, HANDLE g_hHeap Deb_FILELINEPROTO)
{
    if (!g_hHeap)
    {
        g_hHeap = GetProcessHeap();
        return g_hHeap ? NewCtlHeapAlloc(g_hHeap, 0, size) : NULL;
    }

    return NewCtlHeapAlloc(g_hHeap, 0, size);
}

//=---------------------------------------------------------------------------=
// CtlNewDelete::operator delete
//=---------------------------------------------------------------------------=
// retail case just uses win32 Local* heap mgmt functions
//
// Parameters:
//    void *        - [in] free me!
//
// Notes:
//
inline void _cdecl CtlNewDelete::operator delete ( void *ptr, HANDLE g_hHeap Deb_FILELINEPROTO)
{
    if (ptr)
      CtlHeapFree(g_hHeap, 0, ptr);
}
inline void _cdecl CtlNewDelete::operator delete ( void *ptr)
{
    if (ptr)
      CtlHeapFree(g_hHeap, 0, ptr);
}

//---------------------------------------------------------------------------
// Convert C's BOOL to Basic's BOOL
//---------------------------------------------------------------------------
#define BASICBOOLOF(f)    ((f) ? -1 : 0 )
#define FMAKEBOOL(f)      (!!(f))

//---------------------------------------------------------------------------
// Code macros
//---------------------------------------------------------------------------
#define SWAP(type, a, b)  { type _z_=(a);  (a)=(b);  (b)=_z_; }

#if 0
#define loop  while(1)    // "loop" keyword for infinite loops
#endif // 0

// "scope" keyword for { } that are used just to introduce a new name scope.
// It's disconcerting to see { } without some keyword in front of the {...
#define scope


#define ADDREF(PUNK) \
  {if (PUNK) (PUNK)->AddRef();}

#ifndef RELEASE
#define RELEASE(PUNK) \
  {if (PUNK) {LPUNKNOWN punkXXX = (PUNK); (PUNK) = NULL; punkXXX->Release();}}
#endif //RELEASE

// In some multiple inheritance cases you need to dis-ambiguate which IUnknown implementation to use
#define RELEASETYPE(PUNK,TYPE) \
  {if (PUNK) {LPUNKNOWN punkXXX = (TYPE *)(PUNK); (PUNK) = NULL; punkXXX->Release();}}

#define FREESTRING(bstrVal) \
  {if((bstrVal) != NULL) {SysFreeString((bstrVal)); (bstrVal) = NULL; }}

//---------------------------------------------------------------------
// Debug macros
//---------------------------------------------------------------------
#if DEBUG
void _DebugPrintf(char* pszFormat, ...);
void _DebugPrintIf(BOOL fPrint, char* pszFormat, ...);

#define DebugPrintf _DebugPrintf
#define DebugPrintIf _DebugPrintIf

#else // DEBUG || DEBUG_OUTPUT_ON

inline void _DebugNop(...) {}

#define DebugPrintf     1 ? (void)0 : _DebugNop
#define DebugPrintIf    1 ? (void)0 : _DebugNop
#define DebugMessageBox 1 ? (void)0 : _DebugNop

#endif // DEBUG

//---------------------------------------------------------------------
// Error handling macros
//---------------------------------------------------------------------

#ifdef DEBUG
extern HRESULT HrDebugTraceReturn(HRESULT hr, char *szFile, int iLine);
#define RRETURN(hr) return HrDebugTraceReturn(hr, _szThisFile, __LINE__)
#else
#define RRETURN(hr) return (hr)
#endif  //DEBUG


// FAILEDHR : Same as FAILED(hr), but prints a debug message if the test failed.
#if DEBUG
#define FAILEDHR(HR) _FAILEDHR(HR, _szThisFile, __LINE__)
inline BOOL _FAILEDHR(HRESULT hr, char* pszFile, int iLine)
  {
  if (FAILED(hr))
    HrDebugTraceReturn(hr, pszFile, iLine);
  return FAILED(hr);
  }
#else
#define FAILEDHR(HR) FAILED(HR)
#endif

// SUCCEEDEDHR : Same as SUCCEEDED(hr), but prints a debug message if the test failed.
#define SUCCEEDEDHR(HR) (!FAILEDHR(HR))

// Print a debug message if FAILED(hr).
#if DEBUG
#define CHECKHR(HR) _CHECKHR(HR, _szThisFile, __LINE__)
inline void _CHECKHR(HRESULT hr, char* pszFile, int iLine)
  {
  if (FAILED(hr))
    HrDebugTraceReturn(hr, pszFile, iLine);
  }
#else
#define CHECKHR(HR) HR
#endif

#define IfErrGoto(EXPR, LABEL) \
    { err = (EXPR); if (err) goto LABEL; }

#define IfErrRet(EXPR) \
    { err = (EXPR); if (err) return err; };

#define IfErrGo(EXPR) IfErrGoto(EXPR, Error)


#define IfFailGoto(EXPR, LABEL) \
    { hr = (EXPR); if(FAILEDHR(hr)) goto LABEL; }

#ifndef IfFailRet
#define IfFailRet(EXPR) \
    { hr = (EXPR); if(FAILED(hr)) RRETURN(hr); }
#endif // IfFailRet

#define IfFailGo(EXPR) IfFailGoto(EXPR, Error)


#define IfFalseGoto(EXPR, HR, LABEL) \
    { if(!(EXPR)) { hr = (HR); goto LABEL; } }


#define IfFalseRet(EXPR, HR) \
    { if(!(EXPR)) RRETURN(HR); }

#define IfFalseGo(EXPR, HR) IfFalseGoto(EXPR, HR, Error)


#if DEBUG
#define CHECKRESULT(x) ASSERT((x)==NOERROR,"");
#else  // DEBUG
#define CHECKRESULT(x) (x)
#endif  // DEBUG


//---------------------------------------------------------------------------
// STATICF is for static functions.  In retail we disable this in order to
// do better function reordering via the linker.
//---------------------------------------------------------------------------
#if !defined(STATICF)
#ifdef DEBUG
#define STATICF static
#else  // DEBUG
#define STATICF
#endif  // DEBUG
#endif


#define _MACROS_H_
#endif // _MACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\makeauto.inc ===
#=------------------------------------------------------------------------=
# MakeAuto.Inc
#=------------------------------------------------------------------------=
# Copyright  1995  Microsoft Corporation.  All Rights Reserved.
#
# THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
# ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
# PARTICULAR PURPOSE.
#=--------------------------------------------------------------------------=
#
# builds an automation server.  Assumes existence of $(SERVERNAME) and $(OBJS)
#

#
# targets
#
!if "$(FRAMEWRKDIR)" == ""
FRAMEWRKDIR=..\..
!endif

VERSIONHDR=$(FRAMEWRKDIR)\dwinvers.h

!if "$(_SERVERFILENAME)"==""
_SERVERFILENAME=$(SERVERNAME).DLL
!endif

!if "$(INTLBLD)"!=""
!if "$(_LOCALEBASENAME)"==""
!message _LOCALEBASENAME not set
!endif
!endif

# Special for msrdo20 build - allows output of ODL.H (or some other alternate)
!if "$(ALTERNATEODLHFILE)"==""
_ALTERNATEODLHFILE=-h $(SERVERNAME)Interfaces.H
!else
_ALTERNATEODLHFILE=$(ALTERNATEODLHFILE)
!endif

# Tools
#
!include "Tools.Inc"
SRCDIR=..
FXDIR=$(FRAMEWRKDIR)\FrameWrk
INTLPATH=.\.

# Relative path to the INTL, satellite DLL build, directory
#

!if "$(TOOLS)"==""
TOOLS=TOOLS
!endif

!if "$(C32)"==""
C32=C32
!endif

IDHEADER=..\..\tools\idheader.bat

# build specific flags
#
!if "$(ASDEBUG)"!=""
#
# debug
#
# Special for msrdo20 build - this is a non-mfc server NOT built in the framework
#
!if "$(NONFRAMEWRKMAKE)"==""
LIBS=$(FXDIR)\Debug\CtlFwD32.Lib $(DEVBIN)\htmlhelp\v6\debug\lib\htmlhelp.lib
!endif
CFLAGS=-Zil -DDEBUG -Od -FI$(FRAMEWRKDIR)\include\vc41warn.h
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAieee
!endif
LFLAGS=-debugtype:cv -debug:notmapped,full -pdb:none

RCFLAGS=-dDEBUG
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\debug\CtlFwD32.Lib  ..\..\vblic\debug\vblic.lib

!else if "$(ASICECAP)"!=""
#
# ICECap
#
# Special for msrdo20 build - this is a non-mfc server NOT built in the framework
!if "$(NONFRAMEWRKMAKE)"==""
LIBS=$(FXDIR)\IceCap\CtlFwI32.Lib ICap.Lib msvcrt.lib $(DEVBIN)\htmlhelp\v6\retail\lib\htmlhelp.lib
!endif
#
CFLAGS=-Gh -Zil -Owxsb1 -DICECAP -FI$(FRAMEWRKDIR)\include\vc41warn.h
LFLAGS=-debug:mapped
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\icecap\CtlFwI32.Lib ..\..\vblic\icecap\vblic.lib


!else
#
# Release
#
# Special for msrdo20 build - this is a non-mfc server NOT built in the framework
!if "$(NONFRAMEWRKMAKE)"==""
LIBS=$(FXDIR)\Release\CtlFwR32.Lib $(DEVBIN)\htmlhelp\v6\retail\lib\htmlhelp.lib
!endif
#
CFLAGS=-Zil -Owxsb1 -FI$(FRAMEWRKDIR)\include\vc41warn.h
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAieee -QAl
!endif
LFLAGS=
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\release\CtlFwR32.Lib ..\..\vblic\release\vblic.lib

LFLAGS=$(LFLAGS) -debugtype:fixup,cv -debug:notmapped,full
!endif

#
# The CTLS_BROWSE environment variable turns on/off the compilation of a
# browse file when the object is compiled.  Set CTLS_BROWSE to something
# if you wish a browse file generated.
!if "$(CTLS_BROWSE)"!=""
CFLAGS=$(CFLAGS) /FR
BSCMAKE=bscmake.exe
!endif

#
# default flags
#
INCPATH=-I. -I$(SRCDIR) -I$(FRAMEWRKDIR)\Include $(_INCPATH) -I$(VB55CTLS)
RCFLAGS=-r -dRC_INVOKED $(RCFLAGS) $(_RCFLAGS) $(INCPATH)
LIBS= $(LIBS) $(_LIBS) kernel32.lib user32.lib ole32.lib uuid.lib advapi32.lib oldnames.lib uuid2.lib oleaut32.nt4 comdlg32.lib gdi32.lib
!ifdef RISC_BLD
LFLAGS=$(LFLAGS) $(_LFLAGS) -nologo -out:$(_SERVERFILENAME) -DLL -subsystem:windows,4.00 -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE) -def:$(SRCDIR)\$(SERVERNAME).def
!if "$(_NOODLFILE)"==""
CFLAGS=-nologo -c $(INCPATH) -Gd -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS) -Tp
!else
CFLAGS=-nologo -c $(INCPATH) -Gd -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS)
!endif
!else
LFLAGS=$(LFLAGS) $(_LFLAGS) -nologo -out:$(_SERVERFILENAME) -DLL -subsystem:windows,4.00 -nodefaultlib -machine:i386 -def:$(SRCDIR)\$(SERVERNAME).def
!if "$(_NOODLFILE)"==""
CFLAGS=-nologo -c $(INCPATH) -QIfdiv- -Gd -Gs -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS) -Tp
!else
CFLAGS=-nologo -c $(INCPATH) -QIfdiv- -Gd -Gs -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS)
!endif
!endif

_SERVERDEP=$(_SERVERDEP)

!if "$(PCHFILE)"!=""
OBJS=$(OBJS) pch.obj
PCHFLAGS=-Yu$(PCHFILE)
!endif

all: \
!if "$(INTLBLD)"!=""
	$(INTLPATH)\$(_LOCALEBASENAME)xxx.Dll
!elseif "$(DEPFILEBLD)"!=""
	$(_SERVERBASENAME).DEP
!else
	$(MORETARGETS) $(_SERVERFILENAME) $(POSTTARGETS)
!endif

!if "$(_NOODLFILE)"==""
$(_SERVERFILENAME): $(VERSIONHDR) $(SERVERNAME).TLB $(OBJS) \
                   $(_SERVERDEP) $(SRCDIR)\Makefile
    $(LINK) $(OBJS) $(LIBS) $(LFLAGS)
!else
$(_SERVERFILENAME): $(VERSIONHDR) $(OBJS) \
                   $(_SERVERDEP) $(SRCDIR)\Makefile
    $(LINK) $(OBJS) $(LIBS) $(LFLAGS)

!endif

!if "$(CTLS_BROWSE)"!=""
	$(BSCMAKE) /o $(SERVERNAME).bsc *.sbr
!endif

# Precompiled header build rules
#
!if "$(PCHFILE)"!=""
pch.cpp:
    echo #include "$(PCHFILE)" > pch.cpp

pch.pch pch.obj: $(SRCDIR)\$(PCHFILE) pch.cpp
	$(CC) -Yc$(PCHFILE) $(CFLAGS) pch.cpp
!endif

# Standard build rules.
# If a .CPP, .C or .ODL file can't
# be found in the other dependencies then it defaults to one of the following build rules
#
{$(SRCDIR)}.cpp.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<

{$(SRCDIR)}.c.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<

{$(SRCDIR)}.odl.tlb:
	$(MKTYPLIB) $(_MKTYPLIBFLAGS) -nologo -cpp_opt "/C /E /D__MKTYPLIB__ -nologo $(_MTLPREPROCFLAGS)" $(_ALTERNATEODLHFILE) -o Errors.LOG $<

{$(SRCDIR)}.idl.tlb:
	$(MIDL) /newtlb /h -o Errors.LOG $<

# TODO: you should come up with some mechanism to generate this file
#       on your own.
#
#-----------------------------------------------------------------------
# Build dwinvers.h
#-----------------------------------------------------------------------
$(FRAMEWRKDIR)\dwinvers.h : $(FRAMEWRKDIR)\dwinvers.txt
  echo Building dwinvers.h
  $(MAKEVERS) > $(FRAMEWRKDIR)\dwinvers.h < $(FRAMEWRKDIR)\dwinvers.txt
  $(THUNDER55)\$(TOOLS)\bin\getver $(THUNDER55)\$(C32)\dll\vba6\vba6.dll VBA >> $(FRAMEWRKDIR)\dwinvers.h
  copy $(FRAMEWRKDIR)\dwinvers.h $(FRAMEWRKDIR)\framewrk

!if "$(_NOODLFILE)"==""
$(SERVERNAME).TLB : $(SRCDIR)\$(SERVERNAME).ODL $(TLBTARGETS)
    echo Generating $(SERVERNAME).TLB and $(_ALTERNATEODLHFILE)
    $(MKTYPLIB) $(_MKTYPLIBFLAGS) $(INCPATH) -nologo -cpp_opt "/C /E /D__MKTYPLIB__ -nologo $(_MTLPREPROCFLAGS)" $(_ALTERNATEODLHFILE) -o Errors.LOG -tlb $(SERVERNAME).TLB $(SRCDIR)\$(SERVERNAME).ODL


$(SERVERNAME).Rbj : $(SERVERNAME).TLB $(SRCDIR)\$(SERVERNAME).RC
    echo Compiling $(SERVERNAME).RC
    $(RC) $(RCFLAGS) -fo $(SERVERNAME).Res $(SRCDIR)\$(SERVERNAME).Rc
!endif

!if "$(SERVERNAME)"=="RDOCURS"
$(SERVERNAME).Rbj : $(SRCDIR)\$(SERVERNAME).RC
    echo Compiling $(SERVERNAME).RC
    $(RC) $(RCFLAGS) -fo $(SERVERNAME).Res $(SRCDIR)\$(SERVERNAME).Rc
!endif

!ifdef RISC_BLD
    cvtres -machine:$(PROCESSOR_ARCHITECTURE) -nologo -out:$(SERVERNAME).Rbj $(SERVERNAME).Res
!else
    cvtres -machine:ix86 -nologo -out:$(SERVERNAME).Rbj $(SERVERNAME).Res
!endif

# Localized DLL build
#

Clean:
	del *.obj
	del *.dll
	del *.pdb
	del *.vcp

!if "$(_NOODLFILE)"==""

!if "$(PCHFILE)"==""
Dep: $(MORETARGETS) $(SERVERNAME).TLB
    echo Generating Dependencies for $(SERVERNAME)
    $(INCLUDES) $(INCLPREOPT) $(INCPATH) -d $(SRCDIR)\*.c* $(SRCDIR)\*.odl > dep.mak
!else
Dep: $(MORETARGETS) $(SERVERNAME).TLB pch.pch
    echo Generating Dependencies for $(SERVERNAME)
    $(INCLUDES) $(INCPATH) -d -r$(PCHFILE)=pch.pch $(SRCDIR)\*.c* $(SRCDIR)\*.odl > dep.mak
!endif

!else

!if "$(PCHFILE)"==""
Dep: $(MORETARGETS)
    echo Generating Dependencies for $(SERVERNAME)
    $(INCLUDES) $(INCLPREOPT) $(INCPATH) -d $(SRCDIR)\*.c*  > dep.mak
!else
Dep: $(MORETARGETS) pch.pch
    echo Generating Dependencies for $(SERVERNAME)
    $(INCLUDES) $(INCPATH) -d -r$(PCHFILE)=pch.pch $(SRCDIR)\*.c*  > dep.mak
!endif

!endif
#=----------------------------=
# Include Dependency Makefile
#
!IF EXIST(dep.mak)
!include dep.mak
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\makectl.inc ===
#=------------------------------------------------------------------------=
# MakeCtl.Inc
#=------------------------------------------------------------------------=
# Copyright  1995  Microsoft Corporation.  All Rights Reserved.
#
# THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
# ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
# PARTICULAR PURPOSE.
#=--------------------------------------------------------------------------=
#
# builds a control.  Assumes existence of $(CONTROLNAME), and $(OBJS)
#

.SUFFIXES: .s

#
# Determine the build type.
# You can use this constant to make relative path references to
# other binaries that you need to link to.  For example, 
# ..\..\MyLib\$(BUILDTYPE)\MyLib.Lib
#
!if "$(ASDEBUG)" != ""
BUILDTYPE=DEBUG
BUILDLIB=LIBDBG
!elseif "$(ASICECAP)" != ""
BUILDTYPE=ICECAP
BUILDLIB=LIBICE
!else
BUILDTYPE=RELEASE
BUILDLIB=LIBREL
!endif

#
# targets
#
VERSIONHDR=dwinvers.h

#
# support for naming your OCX something other than CONTROLNAME
#
!if "$(_SERVERFILENAME)"==""
_SERVERFILENAME=$(CONTROLNAME).Ocx
!endif

!if "$(_DEFBASENAME)"==""
_DEFBASENAME=$(CONTROLNAME)
!endif

# Tools
#
!include "Tools.Inc"
SRCDIR=..
FXDIR=..\..\FrameWrk

!if "$(VC4_BUILD)" != ""
_CFLAGS=$(_CFLAGS) -DVC4_BUILD=1
!endif

# build specific flags
#
!if "$(ASDEBUG)"!=""
#
# debug
#
LIBS=$(FXDIR)\Debug\CtlFwD32.Lib 
!if "$(VC4_BUILD)" == ""
LIBS=$(LIBS) $(DEVBIN)\htmlhelp\v6\debug\lib\htmlhelp.lib
!endif
CFLAGS=-Zil -DDEBUG -Od -FI..\..\include\vc41warn.h
!   if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAieee
!   endif
!if "$(PDBYES)"==""
LFLAGS=-debugtype:cv -debug:notmapped,full -pdb:none
!else
LFLAGS=-debugtype:cv -debug:notmapped,full
!endif
RCFLAGS=-dDEBUG
MLFLAGS=-Zi
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
MLFLAGS=$(MLFLAGS) -Gy
!endif

!else if "$(ASICECAP)"!=""
#
# ICECap
#
LIBS=$(FXDIR)\IceCap\CtlFwI32.Lib ICap.Lib msvcrt.lib 
!if "$(VC4_BUILD)" == ""
LIBS=$(LIBS) $(DEVBIN)\htmlhelp\v6\retail\lib\htmlhelp.lib
!endif
#
CFLAGS=-Gh -Zil -Oxsb1 -DICECAP -FI..\..\include\vc41warn.h
LFLAGS=-debug:mapped
MLFLAGS=-Zi
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\icecap\CtlFwI32.Lib ..\..\vblic\icecap\vblic.lib
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
MLFLAGS=$(MLFLAGS) -Gy
!endif
!else
#
# Release
#          
LIBS=$(FXDIR)\Release\CtlFwR32.Lib
!if "$(VC4_BUILD)" == ""
LIBS=$(LIBS) $(DEVBIN)\htmlhelp\v6\retail\lib\htmlhelp.lib
!endif

!if "$(SPENABLED)"==""
#
CFLAGS=-Zil -Oxsb1 -GF -FI..\..\include\vc41warn.h
!   if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAl -QAieee
!   endif
!else
#
CFLAGS=-Zil -Oxsb1 -FI..\..\include\vc41warn.h
!   if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAl -QAieee
!   endif
!endif

#LNK4078: multiple ".text" sections found with different attributes (40000040)
LFLAGS=/optidata /merge:.rdata=.text /ignore:4078 -OPT:REF -OPT:ICF,4 
MLFLAGS=-Zi 
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
MLFLAGS=$(MLFLAGS) -Gy
!endif
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\release\CtlFwR32.Lib ..\..\vblic\release\vblic.lib
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAl -QAieee
MLFLAGS=$(MLFLAGS) -Gy
!endif

LFLAGS=$(LFLAGS) -debugtype:fixup,cv -debug:notmapped,full
!endif

#
# This is to turn on or off the browse info file
# If CTLS_BROWSE environment variable is set then turn on the
# browse file stuff.
!if "$(CTLS_BROWSE)"!=""
CFLAGS=$(CFLAGS) /FR
BSCMAKE=bscmake.exe
!endif

#
# default flags
#
INCPATH=-I. -I$(SRCDIR) -I..\..\include $(_INCPATH) -I$(DEVBINC)\htmlhelp\v6\idl\include

!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
MLFLAGS=$(INCPATH) -nologo $(MLFLAGS)
!elseif "$(PROCESSOR_ARCHITECTURE)"=="MIPS"
MLFLAGS=-c $(INCPATH) -nologo $(MLFLAGS)
!elseif "$(PROCESSOR_ARCHITECTURE)"=="PPC"
MLFLAGS=$(INCPATH) -nologo $(MLFLAGS)
!else
MLFLAGS=-c -coff $(INCPATH) -nologo $(MLFLAGS)
!endif

RCFLAGS=-r -dRC_INVOKED $(RCFLAGS) $(_RCFLAGS) $(INCPATH)

!if "$(ASDEBUG)" != ""
MKTYPLIBFLAGS=$(MKTYPLIBFLAGS) -DDEBUG
MTLPREPROCFLAGS=$(MTLPREPROCFLAGS) -DDEBUG
!elseif "$(ASICECAP)" != ""
MKTYPLIBFLAGS=$(MKTYPLIBFLAGS) -DICECAP
MTLPREPROCFLAGS=$(MTLPREPROCFLAGS) -DICECAP
!endif

!ifdef RISC_BLD
LIBS=$(LIBS) $(_LIBS) kernel32.lib user32.lib ole32.lib advapi32.lib oldnames.lib oleaut32.nt4 comdlg32.lib gdi32.lib 
LFLAGS=$(LFLAGS) $(_LFLAGS) -nologo -out:$(_SERVERFILENAME) -DLL -subsystem:windows,4.00 -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE) -def:$(SRCDIR)\$(_DEFBASENAME).def
CFLAGS=-nologo -c $(INCPATH) -Gd -Gy -W3 -WX -Oi -DRISC_BLD $(CFLAGS) $(_CFLAGS) -Tp
MKTYPLIBFLAGS=$(_MKTYPLIBFLAGS) $(MKTYPLIBFLAGS) /DRISC_BLD
MTLPREPROCFLAGS=$(_MTLPREPROCFLAGS) $(MTLPREPROCFLAGS) /DRISC_BLD
!else
LIBS= $(LIBS) $(_LIBS) kernel32.lib user32.lib ole32.lib advapi32.lib oldnames.lib oleaut32.nt4 comdlg32.lib gdi32.lib
LFLAGS=$(LFLAGS) $(_LFLAGS) -nologo -out:$(_SERVERFILENAME) -DLL -subsystem:windows,4.00 -nodefaultlib -machine:i386 -def:$(SRCDIR)\$(_DEFBASENAME).def
CFLAGS=-nologo -c $(INCPATH) -QIfdiv- -Gd -Gs -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS) -Tp
MKTYPLIBFLAGS=$(_MKTYPLIBFLAGS) $(MKTYPLIBFLAGS)
MTLPREPROCFLAGS=$(_MTLPREPROCFLAGS) $(MTLPREPROCFLAGS)
!endif

# Clients can choose to link with their own versions of UUID.LIB
#
!if "$(_NOUUID)" == ""
LIBS=$(LIBS) uuid.lib uuid2.lib
!endif

!if "$(PCHFILE)"!=""
!if "$(PCHBASEFILE)" != ""
OBJS=$(OBJS) $(PCHBASEFILE).obj
PCHFLAGS=-Yu$(PCHFILE)
!else
OBJS=$(OBJS) pch.obj
PCHFLAGS=-Yu$(PCHFILE)
!endif
!endif

# set up our default targets
#
!if "$(ALLTARGETS)"==""
ALLTARGETS=$(_SERVERFILENAME)
!endif

!if "$(TLBTARGETS)"==""
TLBTARGETS=$(SRCDIR)\$(CONTROLNAME).ODL
!endif

#=------------------------------------------------------------------------=
# the good stuff -- the real targets
#
all: $(MORETARGETS) $(ALLTARGETS)

$(_SERVERFILENAME): $(VERSIONHDR) $(CONTROLNAME).TLB $(OBJS) \
		    $(_SERVERDEP) $(SRCDIR)\Makefile
    $(LINK) $(OBJS) $(LIBS) $(LFLAGS)
!if "$(CTLS_BROWSE)"!=""
	$(BSCMAKE) /o $(CONTROLNAME).bsc /S (windows.h eb.h vb.h ole2.h) *.sbr
!endif

# Precompiled header build rules
#
!if "$(PCHFILE)"!=""
!if "$(PCHBASEFILE)" != ""
# pre-compiled header targets. 
$(PCHBASEFILE).cpp:
    echo #include "$(PCHFILE)" > $(PCHBASEFILE).cpp

$(PCHBASEFILE).pch $(PCHBASEFILE).obj: $(SRCDIR)\$(PCHFILE) $(PCHBASEFILE).cpp
	$(CC) -Yc$(PCHFILE) $(CFLAGS) $(PCHBASEFILE).cpp

!else
# pre-compiled header targets. 
pch.cpp:
    echo #include "$(PCHFILE)" > pch.cpp

pch.pch pch.obj: $(SRCDIR)\$(PCHFILE) pch.cpp
	$(CC) -Yc$(PCHFILE) $(CFLAGS) pch.cpp
!endif
!endif

# Standard build rules.
# If a .CPP, .C or .ODL file can't
# be found in the other dependencies then it defaults to one of the following build rules
#
{$(SRCDIR)}.cpp.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<

{$(SRCDIR)}.c.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<

{$(SRCDIR)}.s.Obj:
!ifdef RISC_BLD
!  if "$(PROCESSOR_ARCHITECTURE)"=="PPC"
    $(CC) /P /Tc $<
    $(ML) $*.i
     del $*.i
!  else
    $(ML) $(MLFLAGS) $< /Fo$@
!  endif
!else
{$(SRCDIR)}.asm.Obj:
    $(ML) $(MLFLAGS) $<
!endif

# TODO: you should come up with some mechanism to generate this file
#       on your own.
#
$(VERSIONHDR) : ..\..\FrameWrk\dwinvers.h
    echo Generating Version Information Header File (dwinvers.h)
    copy ..\..\FrameWrk\dwinvers.h >nul

$(CONTROLNAME).TLB : $(TLBTARGETS)
    echo Generating $(CONTROLNAME).TLB and $(CONTROLNAME)Interfaces.H
    $(CC) /E /D__MKTYPLIB__ -nologo $(MTLPREPROCFLAGS) $(INCPATH) /Tc $(SRCDIR)\$(CONTROLNAME).ODL > preproc.odl
    $(MKTYPLIB) $(MKTYPLIBFLAGS) -nocpp -nologo  -h $(CONTROLNAME)Interfaces.H -o Errors.LOG -tlb $(CONTROLNAME).TLB preproc.odl
				  
$(CONTROLNAME).Rbj : $(CONTROLNAME).TLB $(SRCDIR)\$(CONTROLNAME).RC
    echo Compiling $(CONTROLNAME).RC
    $(RC) $(RCFLAGS) -fo $(CONTROLNAME).Res $(SRCDIR)\$(CONTROLNAME).Rc
!ifdef RISC_BLD
    cvtres -machine:$(PROCESSOR_ARCHITECTURE) -nologo -out:$(CONTROLNAME).Rbj $(CONTROLNAME).Res
!else
    cvtres -machine:ix86 -nologo -out:$(CONTROLNAME).Rbj $(CONTROLNAME).Res
!endif

Clean:
	del *.obj
	del *.dll
	del *.pdb
	del *.vcp

!if "$(PCHFILE)"==""
Dep: $(MORETARGETS) $(CONTROLNAME).TLB
    echo Generating Dependencies for $(CONTROLNAME)
    $(INCLUDES) $(INCPATH) -d $(SRCDIR)\*.c* $(SRCDIR)\*.rc $(SRCDIR)\*.odl > dep.mak
!else
!if "$(PCHBASEFILE)" != ""
Dep: $(MORETARGETS) $(CONTROLNAME).TLB $(PCHBASEFILE).pch
    echo Generating Dependencies for $(CONTROLNAME)
    $(INCLUDES) $(INCPATH) -d -r$(PCHFILE)=$(PCHBASEFILE).pch $(SRCDIR)\*.c* $(SRCDIR)\*.rc $(SRCDIR)\*.odl > dep.mak

!else
Dep: $(MORETARGETS) $(CONTROLNAME).TLB pch.pch
    echo Generating Dependencies for $(CONTROLNAME)
    $(INCLUDES) $(INCPATH) -d -r$(PCHFILE)=pch.pch $(SRCDIR)\*.c* $(SRCDIR)\*.rc $(SRCDIR)\*.odl > dep.mak
!endif
!endif

#=----------------------------=
# Include Dependency Makefile 
#
!IF EXIST(dep.mak)
!include dep.mak
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\makecbc.inc ===
#=------------------------------------------------------------------------=
# MakeCBC.Inc
#=------------------------------------------------------------------------=
# Copyright  1995  Microsoft Corporation.  All Rights Reserved.
#
# THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
# ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
# PARTICULAR PURPOSE.
#=--------------------------------------------------------------------------=
#
# builds a custom base class.  Assumes existence of $(DESIGNERNAME), and $(OBJS)
#

.SUFFIXES: .s


#
# targets
#
VERSIONHDR=dwinvers.h


#
# support for naming your DLL something other than DESIGNERNAME
#
!if "$(_SERVERFILENAME)"==""
_SERVERFILENAME=$(DESIGNERNAME).DLL
!endif
!if "$(RUNMODEDLL)"=="YES"
!if "$(_RUNMODESERVERNAME)"==""
_RUNMODESERVERNAME=$(RUNMODE).DLL
!endif
!endif

# Tools
#
!include "Tools.Inc"
SRCDIR=..
FXDIR=..\..\FrameWrk
INTLPATH=.\.

# build specific flags
#
!if "$(ASDEBUG)"!=""
#
# debug
#
LIBS=$(FXDIR)\Debug\CtlFwD32.Lib $(DEVBIN)\htmlhelp\v6\debug\lib\htmlhelp.lib
CFLAGS=-Zil -DDEBUG -Od -FI..\..\include\vc41warn.h
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS = $(CFLAGS) /QAieee
!endif
_MTLPREPROCFLAGS = $(_MTLPREPROCFLAGS) /DDEBUG
LINKFLAGS=-debugtype:cv -debug:notmapped,full
RCFLAGS=-dDEBUG
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\debug\CtlFwD32.Lib  ..\..\vblic\debug\vblic.lib

!else if "$(ASICECAP)"!=""
#
# ICECap
#
LIBS=$(FXDIR)\IceCap\CtlFwI32.Lib ICap.Lib msvcrt.lib $(DEVBIN)\htmlhelp\v6\retail\lib\htmlhelp.lib
CFLAGS=-Gh -Zil -Owxsb1 -DICECAP -FI..\..\include\vc41warn.h
LINKFLAGS=-debug:mapped
_MTLPREPROCFLAGS = $(_MTLPREPROCFLAGS) /DICECAP
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\icecap\CtlFwI32.Lib ..\..\vblic\icecap\vblic.lib

!else
#
# Release
#
LIBS=$(FXDIR)\Release\CtlFwR32.Lib $(DEVBIN)\htmlhelp\v6\retail\lib\htmlhelp.lib
#
CFLAGS=-Zil -Owxsb1 -FI..\..\include\vc41warn.h
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS = $(CFLAGS) /QAl /QAieee
!endif
LINKFLAGS=-debugtype:fixup,cv -debug:notmapped,full
_SERVERDEP=$(_SERVERDEP) ..\..\framewrk\release\CtlFwR32.Lib ..\..\vblic\release\vblic.lib

!endif

# 
# The CTLS_BROWSE environment variable turns on/off the compilation of a
# browse file when the object is compiled.  Set CTLS_BROWSE to something
# if you wish a browse file generated.
!if "$(CTLS_BROWSE)"!=""
CFLAGS=$(CFLAGS) /FR
BSCMAKE=bscmake.exe
!endif

#
# default flags
#
INCPATH=-I. -I$(SRCDIR) -I..\..\Include $(_INCPATH)
MLFLAGS=-c -coff $(INCPATH) -nologo
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
MLFLAGS=$(MLFLAGS) -Gy
!endif
RCFLAGS=-r $(RCFLAGS) $(_RCFLAGS) $(INCPATH)

!ifdef RISC_BLD
LIBS= $(LIBS) $(_LIBS) kernel32.lib user32.lib ole32.lib uuid.lib advapi32.lib oldnames.lib uuid2.lib oleaut32.nt4 comdlg32.lib gdi32.lib 
LFLAGS=$(LINKFLAGS) $(_LFLAGS) -nologo -DLL -subsystem:windows,4.00 -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE)
CFLAGS=-nologo -c $(INCPATH) -Gd -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS) -Tp
!else
LIBS= $(LIBS) $(_LIBS) kernel32.lib user32.lib ole32.lib uuid.lib advapi32.lib oldnames.lib uuid2.lib oleaut32.nt4 comdlg32.lib gdi32.lib
LFLAGS=$(LINKFLAGS) $(_LFLAGS) -nologo -DLL -subsystem:windows,4.00 -nodefaultlib -machine:i386
CFLAGS=-nologo -c $(INCPATH) -QIfdiv- -Gd -Gs -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS) -Tp
!endif

!if "$(ASDEBUG)"!=""
DSGNLFLAGS=-out:$(_SERVERFILENAME) $(LFLAGS) -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(DESIGNERNAME)_d -def:$(SRCDIR)\$(DESIGNERNAME).def
!else
DSGNLFLAGS=-out:$(_SERVERFILENAME) $(LFLAGS) -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(DESIGNERNAME)_r -def:$(SRCDIR)\$(DESIGNERNAME).def
!endif
DSGNLIBS=$(LIBS) $(_DSGNLIBS)

!if "$(ASDEBUG)"!=""
RUNLFLAGS=-out:$(_RUNMODESERVERNAME) $(LFLAGS) -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(DESIGNERNAME)_rt_d -def:$(SRCDIR)\$(RUNMODE).DEF
!else
RUNLFLAGS=-out:$(_RUNMODESERVERNAME) $(LFLAGS) -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(DESIGNERNAME)_rt_r -def:$(SRCDIR)\$(RUNMODE).DEF
!endif
RUNLIBS=$(LIBS) $(_RUNLIBS)


!IF "$(ALLTARGETS)"==""
ALLTARGETS= \
!if "$(INTLBLD)"==""
!if "$(RUNMODEDLL)"=="YES"
     $(_RUNMODESERVERNAME) \
!endif
     $(_SERVERFILENAME) \
!if "$(ASDEBUG)"=="" && "$(ASICECAP)"==""
	  Lego
!endif
!else
    $(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL
!endif
!endif

!if "$(TLBTARGETS)"==""
TLBTARGETS=$(SRCDIR)\$(DESIGNERNAME).TLB
!endif

!if "$(TLBRUNTARGETS)"==""
TLBRUNTARGETS=$(SRCDIR)\$(RUNMODE).ODL
!endif

!if "$(PCHFILE)"!=""
OBJS=$(OBJS) pch.obj
PCHFLAGS=-Yu$(PCHFILE)
!endif


#=--------------------------------------------------------------------------=
# build the designer, and, if appropriate, the run-mode DLL
#
all: $(ALLTARGETS)

$(_SERVERFILENAME): $(VERSIONHDR) $(DESIGNERNAME).TLB $(OBJS) \
                    $(_SERVERDEP) $(SRCDIR)\Makefile
    $(LINK) $(OBJS) $(DSGNLIBS) $(DSGNLFLAGS)
!if "$(CTLS_BROWSE)"!=""
    $(BSCMAKE) /o $(_SERVERFILENAME).bsc *.sbr
!endif

!if "$(RUNMODEDLL)"=="YES"
$(_RUNMODESERVERNAME): $(VERSIONHDR) \
!if "$(RUNMODETLB)"=="YES"
		$(RUNMODE).TLB \
!endif
		$(RUNOBJS)
    $(LINK) $(RUNOBJS) $(RUNLFLAGS) $(RUNLIBS)
!endif

!if "$(PCHFILE)"!=""
# pre-compiled header targets. 
pch.cpp:
  echo #include "$(PCHFILE)" > pch.cpp

pch.pch pch.obj: $(SRCDIR)\$(PCHFILE) pch.cpp
  $(CC) -Yc$(PCHFILE) $(CFLAGS) pch.cpp
!endif

{$(SRCDIR)}.cpp.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<

{$(SRCDIR)}.c.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<

{$(SRCDIR)}.asm.Obj:
    $(ML) $(MLFLAGS) $<

# TODO: you should come up with some mechanism to generate this file
#       on your own.
#
$(VERSIONHDR) : ..\..\FrameWrk\dwinvers.h
    echo Generating Version Information Header File (dwinvers.h)
    copy ..\..\FrameWrk\dwinvers.h >nul

$(DESIGNERNAME).TLB : $(TLBTARGETS)
    echo Generating $(DESIGNERNAME).TLB and $(DESIGNERNAME)Interfaces.H
    $(CC) $(INCPATH) -nologo /C /E /D__MKTYPLIB__ $(_MTLPREPROCFLAGS) /Tc $(SRCDIR)\$(DESIGNERNAME).ODL > preproc.odl
    $(MKTYPLIB) $(_MKTYPLIBFLAGS) -nologo -nocpp -h $(DESIGNERNAME)Interfaces.H -o Errors.LOG -tlb $(DESIGNERNAME).TLB preproc.odl

$(RUNMODE).TLB : $(TLBRUNTARGETS)
    echo Generating $(RUNMODE).TLB and $(RUNMODE)Interfaces.H
    $(CC) $(INCPATH) -nologo /C /E /D__MKTYPLIB__ $(_MTLPREPROCFLAGS) /Tc $(SRCDIR)\$(RUNMODE).ODL > preproc.odl
    $(MKTYPLIB) $(_MKTYPLIBFLAGS) -nologo -nocpp -h $(RUNMODE)Interfaces.H -o Errors.LOG -tlb $(RUNMODE).TLB preproc.odl

$(DESIGNERNAME).Rbj : $(DESIGNERNAME).TLB $(SRCDIR)\$(DESIGNERNAME).RC
    echo Compiling $(DESIGNERNAME).RC
    $(RC) $(RCFLAGS) -fo $(DESIGNERNAME).Res $(SRCDIR)\$(DESIGNERNAME).Rc
!ifdef RISC_BLD
    cvtres -machine:$(PROCESSOR_ARCHITECTURE) -nologo -out:$(DESIGNERNAME).Rbj $(DESIGNERNAME).Res
!else
    cvtres -machine:ix86 -nologo -out:$(DESIGNERNAME).Rbj $(DESIGNERNAME).Res
!endif

$(RUNMODE).Rbj : \
!if "$(RUNMODETLB)"=="YES"
		$(RUNMODE).TLB \
!endif
		$(SRCDIR)\$(RUNMODE).RC
    echo Compiling $(RUNMODE).RC
    $(RC) $(RCFLAGS) -fo $(RUNMODE).Res $(SRCDIR)\$(RUNMODE).Rc
!ifdef RISC_BLD
    cvtres -machine:$(PROCESSOR_ARCHITECTURE) -nologo -out:$(RUNMODE).Rbj $(RUNMODE).Res
!else
    cvtres -machine:ix86 -nologo -out:$(RUNMODE).Rbj $(RUNMODE).Res
!endif


!if "$(_SERVERBASENAME)"==""
!message _SERVERBASENAME not set
!endif
!if "$(_SERVEREXTENSION)"==""
!message _SERVEREXTENSION not set
!endif

!if "$(RUNMODEDLL)"=="YES"
!if "$(_RUNMODEBASENAME)"==""
!message _RUNMODEBASENAME not set
!endif

!if "$(_RUNMODEEXTENSION)"==""
!message _RUNMODEEXTENSION not set
!endif
!endif

!if "$(INTLBLD)"!=""
!if "$(_LOCALEBASENAME)"==""
!message _LOCALEBASENAME not set
!endif
!endif

Lego:
!if "$(CTLS_LEGO)"=="YES"
  nmake -f $(THUNDER55)\common\instr.mak FILE_BASE=$(_SERVERBASENAME) FILE_EXTENSION=$(_SERVEREXTENSION) CMD_SCRIPT= BOOT_SYM=
!if "$(_RUNMODEBASENAME)" != ""
  nmake -f $(THUNDER55)\common\instr.mak FILE_BASE=$(_RUNMODEBASENAME) FILE_EXTENSION=$(_RUNMODEEXTENSION) CMD_SCRIPT= BOOT_SYM=
!endif
!endif

Clean:
	del *.obj
	del *.dll
	del *.pdb
	del *.vcp

Dep: GenerateDeps \
!if "$(RUNMODETLB)"=="YES"
     $(RUNMODE).TLB \
!endif     
!if "$(PCHFILE)"!=""
    pch.pch \
!endif
     $(DESIGNERNAME).TLB


GenerateDeps: $(INTLPATH)\HelpStrs.RC $(DESIGNERNAME).TLB dwinvers.h
    echo Generating Dependancies for $(DESIGNERNAME)
!if "$(PCHFILE)"==""
    $(INCLUDES) $(INCPATH) -d $(SRCDIR)\*.c* $(SRCDIR)\*.odl > dep.mak
!else
    $(INCLUDES) $(INCPATH) -d -r$(PCHFILE)=pch.pch $(SRCDIR)\*.c* $(SRCDIR)\*.odl > dep.mak
!endif


#=----------------------------=
# Include Dependency Makefile 
#
!IF EXIST(dep.mak)
!include dep.mak
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\makelib.inc ===
#=------------------------------------------------------------------------=
# MakeLib.Inc
#=------------------------------------------------------------------------=
# Copyright  1995  Microsoft Corporation.  All Rights Reserved.
#
# THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
# ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
# PARTICULAR PURPOSE.
#=--------------------------------------------------------------------------=
#
# builds a library.  Assumes existence of $(TARGET) and $(OBJS)
# (TARGET is the base name of the library, i.e. datad)
#

#
# targets
#
!if "$(FRAMEWRKDIR)" == ""
!   if "$(MDAC_BUILD)" != ""
FRAMEWRKDIR=..\..\..
!   else
FRAMEWRKDIR=..\..
!   endif
!endif

# Tools
#
!include "Tools.Inc"
!if "$(MDAC_BUILD)" != ""
SRCDIR=\foxde\framewrk
!else
SRCDIR=..
!endif
TARGETLIB=$(TARGET).lib

!if "$(VC4_BUILD)" != ""
_CFLAGS=$(_CFLAGS) -DVC4_BUILD=1
!endif

# build specific flags
#
!if "$(ASDEBUG)"!=""
#
# debug
#
!if "$(MDAC_BUILD)" != ""
CFLAGS=-Zil -DDEBUG -D_DEBUG -DSTRICT -Od -DMDAC_BUILD -FI$(FRAMEWRKDIR)\include\vc41warn.h
!else
CFLAGS=-Zil -DDEBUG -Od -FI$(FRAMEWRKDIR)\include\vc41warn.h
!endif
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAieee
!endif
RCFLAGS=-dDEBUG

!else if "$(ASICECAP)"!=""
#
# ICECap
#
!if "$(MDAC_BUILD)" != ""
CFLAGS=-Gh -Zil -Owxsb1 -DICECAP -DNDEBUG -DSTRICT -DMDAC_BUILD -FI$(FRAMEWRKDIR)\include\vc41warn.h
!else
CFLAGS=-Gh -Zil -Owxsb1 -DICECAP -FI$(FRAMEWRKDIR)\include\vc41warn.h
!endif

!else
#
# Release
#
!if "$(MDAC_BUILD)" != ""
CFLAGS=-Zil -Owxsb1 -DNDEBUG -DSTRICT -DMDAC_BUILD -FI$(FRAMEWRKDIR)\include\vc41warn.h
!else
CFLAGS=-Zil -Owxsb1 -FI$(FRAMEWRKDIR)\include\vc41warn.h
!endif

!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
CFLAGS=$(CFLAGS) -QAl -QAieee
!endif 

!endif

# 
# The CTLSBROWSE or CTLS_BROWSE environment variable turns on/off the compilation of a
# browse file when the object is compiled.  Set CTLSBROWSE or CTLS_BROWSE to something
# if you wish a browse file generated.
!if "$(CTLSBROWSE)" != ""
CTLS_BROWSE=1
!endif

!if "$(CTLS_BROWSE)"!=""
CFLAGS=$(CFLAGS) /FR
BSCMAKE=bscmake.exe
!endif

#
# If we have precompiled headers, add the pch file to
# the list of objects and to the compiler flags
#
!if "$(PCHFILE)"!=""
OBJS=$(OBJS) pch.obj
PCHFLAGS=-Yu$(PCHFILE)
!endif

#
# default flags
#   CONSIDER: Will every library always want CV info?
#
INCPATH=-I. -I$(SRCDIR) -I$(FRAMEWRKDIR)\Include $(_INCPATH)
!ifdef RISC_BLD
LIBFLAGS=$(LIBFLAGS) $(_LIBFLAGS) -debugtype:cv -nologo -out:$(TARGETLIB) -subsystem:windows,4.00 -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE)
CFLAGS=-nologo -c $(INCPATH) -Gd -Gs -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS) -Tp
!else
LIBFLAGS=$(LIBFLAGS) $(_LIBFLAGS) -debugtype:cv -nologo -out:$(TARGETLIB) -subsystem:windows,4.00 -nodefaultlib -machine:ix86
CFLAGS=-nologo -c $(INCPATH) -QIfdiv- -Gd -Gs -Gy -W3 -WX -Oi $(CFLAGS) $(_CFLAGS) -Tp
!endif

!if "$(PCHFILE)" == ""
all: $(MORETARGETS) $(TARGETLIB)
!else
all: pch.pch $(MORETARGETS) $(TARGETLIB)
!endif

$(TARGETLIB): $(OBJS) $(SRCDIR)\Makefile
    $(LIBRARIAN) $(OBJS) $(LIBFLAGS)
!if "$(DATABROWSE)"!=""
    $(BSCMAKE) /o $(TARGET).bsc /S (windows.h ole2.h) *.sbr
!endif

# Precompiled header build rules
#
!if "$(PCHFILE)"!=""
# pre-compiled header targets. 
pch.cpp:
    echo #include "$(PCHFILE)" > pch.cpp

pch.pch pch.obj: $(SRCDIR)\$(PCHFILE) pch.cpp
	$(CC) -Yc$(PCHFILE) $(CFLAGS) pch.cpp
!endif


# Standard build rules.  
# If a .CPP, .C or .ODL file can't
# be found in the other dependencies then it defaults to one of the following build rules
#
{$(SRCDIR)}.cpp.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<

{$(SRCDIR)}.c.obj:
    $(CC) $(PCHFLAGS) $(CFLAGS) $<


Clean:
	del *.obj
	del *.dll
	del *.pdb
	del *.vcp


!if "$(PCHFILE)"==""
Dep: $(MORETARGETS)
    echo Generating Dependencies for $(SERVERNAME)
    $(INCLUDES) $(INCPATH) -d $(SRCDIR)\*.c* > dep.mak
!else
Dep: pch.pch $(MORETARGETS) 
    echo Generating Dependencies for $(SERVERNAME)
    $(INCLUDES) $(INCPATH) -d -r$(PCHFILE)=pch.pch $(SRCDIR)\*.c* > dep.mak
!endif

#=----------------------------=
# Include Dependency Makefile 
#
!IF EXIST(dep.mak)
!include dep.mak
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\proppage.h ===
//=--------------------------------------------------------------------------=
// PropertyPages.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for CPropertyPage.
//
#ifndef _PROPERTYPAGES_H_

// things we really need
//
#include "Unknown.H"
#include <olectl.h>
#include "LocalSrv.H"

//=--------------------------------------------------------------------------=
// messages that we'll send to property pages to instruct them to accomplish
// tasks.
//
#define PPM_NEWOBJECTS    (WM_USER + 100)
#define PPM_APPLY         (WM_USER + 101)
#define PPM_EDITPROPERTY  (WM_USER + 102)
#define PPM_FREEOBJECTS   (WM_USER + 103)

//=--------------------------------------------------------------------------=
// structure that control writers will use to define property pages.
//
typedef struct tagPROPERTYPAGEINFO {

    UNKNOWNOBJECTINFO unknowninfo;
    WORD    wDlgResourceId;
    WORD    wTitleId;
    WORD    wDocStringId;
    LPCSTR  szHelpFile;
    DWORD   dwHelpContextId;

} PROPERTYPAGEINFO;

#ifndef INITOBJECTS

#define DEFINE_PROPERTYPAGEOBJECT(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci) \
    extern PROPERTYPAGEINFO name##Page \

#define DEFINE_PROPERTYPAGEOBJECT2(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci, fthreadsafe) \
    extern PROPERTYPAGEINFO name##Page \

#else // INITOBJECTS

#define DEFINE_PROPERTYPAGEOBJECT(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci) \
    PROPERTYPAGEINFO name##Page = { {pclsid, pszon, NULL, TRUE, pfn }, wr, wt, wd, pszhf, dwhci } \

#define DEFINE_PROPERTYPAGEOBJECT2(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci, fthreadsafe) \
    PROPERTYPAGEINFO name##Page = { {pclsid, pszon, NULL, fthreadsafe, pfn }, wr, wt, wd, pszhf, dwhci } \

#endif // INITOBJECTS


#define TEMPLATENAMEOFPROPPAGE(index)    MAKEINTRESOURCE(((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wDlgResourceId)
#define TITLEIDOFPROPPAGE(index)         (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wTitleId)
#define DOCSTRINGIDOFPROPPAGE(index)     (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wDocStringId)
#define HELPCONTEXTOFPROPPAGE(index)     (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->dwHelpContextId)
#define HELPFILEOFPROPPAGE(index)        (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->szHelpFile)

//=--------------------------------------------------------------------------=
//
class CPropertyPage : public CUnknownObject,
											public IPropertyPage2 {

  public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IPropertyPage methods
    //
    STDMETHOD(SetPageSite)(LPPROPERTYPAGESITE pPageSite);
    STDMETHOD(Activate)(HWND hwndParent, LPCRECT lprc, BOOL bModal);
    STDMETHOD(Deactivate)(void);
    STDMETHOD(GetPageInfo)(LPPROPPAGEINFO pPageInfo);
    STDMETHOD(SetObjects)(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHOD(Show)(UINT nCmdShow);
    STDMETHOD(Move)(LPCRECT prect);
    STDMETHOD(IsPageDirty)(void);
    STDMETHOD(Apply)(void);
    STDMETHOD(Help)(LPCOLESTR lpszHelpDir);
    STDMETHOD(TranslateAccelerator)(LPMSG lpMsg);

    // IPropertyPage2 methods
    //
    STDMETHOD(EditProperty)(THIS_ DISPID dispid);

    // constructor destructor
    //
    CPropertyPage(IUnknown *pUnkOuter, int iObjectType);
    virtual ~CPropertyPage();

    HINSTANCE GetResourceHandle(void);            // returns current resource handle.

  protected:
    IPropertyPageSite *m_pPropertyPageSite;       // pointer to our ppage site.
    void     MakeDirty();                         // makes the property page dirty.
    HWND     m_hwnd;                              // our hwnd.

    // the following two methods allow a property page implementer to get at all the
    // objects that we need to set here.
    //
    IUnknown *FirstControl(DWORD *dwCookie);
    IUnknown *NextControl(DWORD *dwCookie);

    virtual HRESULT InternalQueryInterface(REFIID, void **);

    int      m_ObjectType;                        // what type of object we are

  private:
    IUnknown **m_ppUnkObjects;                    // objects that we're working with.

    unsigned m_fActivated:1;
    unsigned m_fDirty:1;
    unsigned m_fDeactivating:1;                   // Set when the page is deactivating.  This helps prevent
                                                  // unnecessary calls to IPropertyPageSite::OnStatusChange

    UINT     m_cObjects;                          // how many objects we're holding on to

    void     ReleaseAllObjects(void);           // clears out all objects we've got.
    HRESULT  EnsureLoaded(void);                // forces the load of the page.
    HRESULT  NewObjects(void);			// Notifies page to initialize its fields with prop vals

    // default dialog proc for a page.
    //
    static BOOL CALLBACK PropPageDlgProc(HWND, UINT, WPARAM, LPARAM);

    // all page implementers MUST implement the following function.
    //
    virtual BOOL DialogProc(HWND, UINT, WPARAM, LPARAM) PURE;
};

#define _PROPERTYPAGES_H_
#endif // _PROPERTYPAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\rtol.h ===
//=--------------------------------------------------------------------------=
// RToL.H
//=--------------------------------------------------------------------------=
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// This is here to support compilation with VC5.  VC5 header files lost
// a couple of things for Right To Left so they are right here.

//#if _MSC_VER == 1100

#ifndef _RTOL_H_
#define _RTOL_H_

#define DISPID_RIGHTTOLEFT           (-611)
#define DISPID_AMBIENT_RIGHTTOLEFT   (-732)

#endif // _RTOL_H_ 

//#endif // _MSC_VER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\olebind.h ===
/*****************************************************************************\
*                                                                             *
* olebind.h     Data binding interfaces for OLE                               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1994, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _OLEBIND_H_ )
#define _OLEBIND_H_

#if !defined( INITGUID )
// trevors: To build with vc5, we should not include olectlid.h anymore.  We
// should include olectl.h.  We check to see if we are compiling with vc5 or
// not and include the correct header file. 
#if _MSC_VER == 1100
#include <olectl.h>
#else
#include <olectlid.h>
#endif // _MSC_VER
#endif

DEFINE_GUID(IID_IBoundObject,
	0x9BFBBC00,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IBoundObjectSite,
	0x9BFBBC01,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);

typedef interface IBoundObject FAR* LPBOUNDOBJECT;
typedef interface ICursor FAR* LPCURSOR;

typedef interface IBoundObjectSite FAR* LPBOUNDOBJECTSITE;
typedef interface ICursor FAR* FAR* LPLPCURSOR;


//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObject interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObject

DECLARE_INTERFACE_(IBoundObject, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObject methods
    //
    STDMETHOD(OnSourceChanged)(THIS_ DISPID dispid, BOOL fBound, BOOL FAR* lpfOwnXferOut) PURE;
    STDMETHOD(IsDirty)(THIS_ DISPID dispid) PURE;
};
//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObjectSite interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObjectSite

DECLARE_INTERFACE_(IBoundObjectSite, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObjectSite methods
    //
    STDMETHOD(GetCursor)(THIS_ DISPID dispid, LPLPCURSOR ppCursor, LPVOID FAR* ppcidOut) PURE;
};


#endif // !defined( _OLEBIND_H_ )

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\objsafe.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0101 */
/* at Fri May 24 09:44:29 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __objsafe_h__
#define __objsafe_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IObjectSafety_FWD_DEFINED__
#define __IObjectSafety_FWD_DEFINED__
typedef interface IObjectSafety IObjectSafety;
#endif 	/* __IObjectSafety_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri May 24 09:44:29 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  (C) Copyright 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: ObjSafe.h
//
//--------------------------------------------------------------------------
#ifndef _LPSAFEOBJECT_DEFINED
#define _LPSAFEOBJECT_DEFINED

// Option bit definitions for IObjectSafety:
#define	INTERFACESAFE_FOR_UNTRUSTED_CALLER	0x00000001	// Caller of interface may be untrusted
#define	INTERFACESAFE_FOR_UNTRUSTED_DATA	0x00000002	// Data passed into interface may be untrusted

// {CB5BDC81-93C1-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IObjectSafety, 0xcb5bdc81, 0x93c1, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
//EXTERN_C GUID CATID_SafeForScripting;
//EXTERN_C GUID CATID_SafeForInitializing;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IObjectSafety_INTERFACE_DEFINED__
#define __IObjectSafety_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectSafety
 * at Fri May 24 09:44:29 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IObjectSafety;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IObjectSafety : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetInterfaceSafetyOptions( 
            /* [in] */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
            /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions) = 0;
        
        virtual HRESULT __stdcall SetInterfaceSafetyOptions( 
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwOptionSetMask,
            /* [in] */ DWORD dwEnabledOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectSafetyVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IObjectSafety __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IObjectSafety __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IObjectSafety __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetInterfaceSafetyOptions )( 
            IObjectSafety __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
            /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions);
        
        HRESULT ( __stdcall __RPC_FAR *SetInterfaceSafetyOptions )( 
            IObjectSafety __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwOptionSetMask,
            /* [in] */ DWORD dwEnabledOptions);
        
    } IObjectSafetyVtbl;

    interface IObjectSafety
    {
        CONST_VTBL struct IObjectSafetyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectSafety_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectSafety_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectSafety_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectSafety_GetInterfaceSafetyOptions(This,riid,pdwSupportedOptions,pdwEnabledOptions)	\
    (This)->lpVtbl -> GetInterfaceSafetyOptions(This,riid,pdwSupportedOptions,pdwEnabledOptions)

#define IObjectSafety_SetInterfaceSafetyOptions(This,riid,dwOptionSetMask,dwEnabledOptions)	\
    (This)->lpVtbl -> SetInterfaceSafetyOptions(This,riid,dwOptionSetMask,dwEnabledOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IObjectSafety_GetInterfaceSafetyOptions_Proxy( 
    IObjectSafety __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
    /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions);


void __RPC_STUB IObjectSafety_GetInterfaceSafetyOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IObjectSafety_SetInterfaceSafetyOptions_Proxy( 
    IObjectSafety __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [in] */ DWORD dwOptionSetMask,
    /* [in] */ DWORD dwEnabledOptions);


void __RPC_STUB IObjectSafety_SetInterfaceSafetyOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectSafety_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0006
 * at Fri May 24 09:44:29 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


			/* size is 4 */
typedef /* [unique] */ IObjectSafety __RPC_FAR *LPOBJECTSAFETY;

#endif


extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\ocx96.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Wed Mar 27 07:31:34 1996
 */
//@@MIDL_FILE_HEADING(  )
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ocx96_h__
#define __ocx96_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

typedef interface IAdviseSinkEx IAdviseSinkEx;


typedef interface IOleInPlaceObjectWindowless IOleInPlaceObjectWindowless;


typedef interface IOleInPlaceSiteEx IOleInPlaceSiteEx;


typedef interface IOleInPlaceSiteWindowless IOleInPlaceSiteWindowless;


typedef interface IViewObjectEx IViewObjectEx;


typedef interface IOleUndoUnit IOleUndoUnit;


typedef interface IOleParentUndoUnit IOleParentUndoUnit;


typedef interface IEnumOleUndoUnits IEnumOleUndoUnits;


typedef interface IOleUndoManager IOleUndoManager;


typedef interface IQuickActivate IQuickActivate;


typedef interface IPointerInactive IPointerInactive;


/* header files for imported files */

#ifndef _MAC 
#include "oaidl.h"
#endif
#include "olectl.h"

#ifndef _MAC 
#include "datapath.h"
#else
#define IBindHost IUnknown
#endif


/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#define OLEMISC_IGNOREACTIVATEWHENVISIBLE 0x00080000
#define OLEMISC_SUPPORTSMULTILEVELUNDO    0x00200000




/****************************************
 * Generated header for interface: IAdviseSinkEx
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object][local] */ 


			/* size is 4 */
typedef IAdviseSinkEx *LPADVISESINKEX;


EXTERN_C const IID IID_IAdviseSinkEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAdviseSinkEx : public IAdviseSink
    {
    public:
        virtual void __stdcall OnViewStatusChange( 
            /* [in] */ DWORD dwViewStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAdviseSinkExVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IAdviseSinkEx * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IAdviseSinkEx * This);
        
        ULONG ( __stdcall *Release )( 
            IAdviseSinkEx * This);
        
        /* [local] */ void ( __stdcall *OnDataChange )( 
            IAdviseSinkEx * This,
            /* [unique][in] */ FORMATETC *pFormatetc,
            /* [unique][in] */ STGMEDIUM *pStgmed);
        
        /* [local] */ void ( __stdcall *OnViewChange )( 
            IAdviseSinkEx * This,
            /* [in] */ DWORD dwAspect,
            /* [in] */ LONG lindex);
        
        /* [local] */ void ( __stdcall *OnRename )( 
            IAdviseSinkEx * This,
            /* [in] */ IMoniker *pmk);
        
        /* [local] */ void ( __stdcall *OnSave )( 
            IAdviseSinkEx * This);
        
        /* [local] */ void ( __stdcall *OnClose )( 
            IAdviseSinkEx * This);
        
        void ( __stdcall *OnViewStatusChange )( 
            IAdviseSinkEx * This,
            /* [in] */ DWORD dwViewStatus);
        
    } IAdviseSinkExVtbl;

    interface IAdviseSinkEx
    {
        CONST_VTBL struct IAdviseSinkExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAdviseSinkEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAdviseSinkEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAdviseSinkEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAdviseSinkEx_OnDataChange(This,pFormatetc,pStgmed)	\
    (This)->lpVtbl -> OnDataChange(This,pFormatetc,pStgmed)

#define IAdviseSinkEx_OnViewChange(This,dwAspect,lindex)	\
    (This)->lpVtbl -> OnViewChange(This,dwAspect,lindex)

#define IAdviseSinkEx_OnRename(This,pmk)	\
    (This)->lpVtbl -> OnRename(This,pmk)

#define IAdviseSinkEx_OnSave(This)	\
    (This)->lpVtbl -> OnSave(This)

#define IAdviseSinkEx_OnClose(This)	\
    (This)->lpVtbl -> OnClose(This)


#define IAdviseSinkEx_OnViewStatusChange(This,dwViewStatus)	\
    (This)->lpVtbl -> OnViewStatusChange(This,dwViewStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void __stdcall IAdviseSinkEx_OnViewStatusChange_Proxy( 
    IAdviseSinkEx * This,
    /* [in] */ DWORD dwViewStatus);






/****************************************
 * Generated header for interface: __MIDL__intf_0087
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IAdviseSinkEx * LPADVISESINKEX;




/****************************************
 * Generated header for interface: IOleInPlaceObjectWindowless
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object][local] */ 


			/* size is 4 */
typedef IOleInPlaceObjectWindowless *LPOLEINPLACEOBJECTWINDOWLESS;


EXTERN_C const IID IID_IOleInPlaceObjectWindowless;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleInPlaceObjectWindowless : public IOleInPlaceObject
    {
    public:
        virtual HRESULT __stdcall OnWindowMessage( 
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lparam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT __stdcall GetDropTarget( 
            /* [out] */ IDropTarget **ppDropTarget) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleInPlaceObjectWindowlessVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IOleInPlaceObjectWindowless * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IOleInPlaceObjectWindowless * This);
        
        ULONG ( __stdcall *Release )( 
            IOleInPlaceObjectWindowless * This);
        
        /* [input_sync] */ HRESULT ( __stdcall *GetWindow )( 
            IOleInPlaceObjectWindowless * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( __stdcall *ContextSensitiveHelp )( 
            IOleInPlaceObjectWindowless * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( __stdcall *InPlaceDeactivate )( 
            IOleInPlaceObjectWindowless * This);
        
        HRESULT ( __stdcall *UIDeactivate )( 
            IOleInPlaceObjectWindowless * This);
        
        /* [input_sync] */ HRESULT ( __stdcall *SetObjectRects )( 
            IOleInPlaceObjectWindowless * This,
            /* [in] */ LPCRECT lprcPosRect,
            /* [in] */ LPCRECT lprcClipRect);
        
        HRESULT ( __stdcall *ReactivateAndUndo )( 
            IOleInPlaceObjectWindowless * This);
        
        HRESULT ( __stdcall *OnWindowMessage )( 
            IOleInPlaceObjectWindowless * This,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lparam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( __stdcall *GetDropTarget )( 
            IOleInPlaceObjectWindowless * This,
            /* [out] */ IDropTarget **ppDropTarget);
        
    } IOleInPlaceObjectWindowlessVtbl;

    interface IOleInPlaceObjectWindowless
    {
        CONST_VTBL struct IOleInPlaceObjectWindowlessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleInPlaceObjectWindowless_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleInPlaceObjectWindowless_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleInPlaceObjectWindowless_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleInPlaceObjectWindowless_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IOleInPlaceObjectWindowless_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IOleInPlaceObjectWindowless_InPlaceDeactivate(This)	\
    (This)->lpVtbl -> InPlaceDeactivate(This)

#define IOleInPlaceObjectWindowless_UIDeactivate(This)	\
    (This)->lpVtbl -> UIDeactivate(This)

#define IOleInPlaceObjectWindowless_SetObjectRects(This,lprcPosRect,lprcClipRect)	\
    (This)->lpVtbl -> SetObjectRects(This,lprcPosRect,lprcClipRect)

#define IOleInPlaceObjectWindowless_ReactivateAndUndo(This)	\
    (This)->lpVtbl -> ReactivateAndUndo(This)


#define IOleInPlaceObjectWindowless_OnWindowMessage(This,msg,wParam,lparam,plResult)	\
    (This)->lpVtbl -> OnWindowMessage(This,msg,wParam,lparam,plResult)

#define IOleInPlaceObjectWindowless_GetDropTarget(This,ppDropTarget)	\
    (This)->lpVtbl -> GetDropTarget(This,ppDropTarget)

#endif /* COBJMACROS */


#endif 	/* C style interface */










/****************************************
 * Generated header for interface: __MIDL__intf_0088
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IOleInPlaceObjectWindowless * LPOLEINPLACEOBJECTWINDOWLESS;




/****************************************
 * Generated header for interface: IOleInPlaceSiteEx
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object][local] */ 


			/* size is 2 */
typedef 
enum _ACTIVATEFLAGS
    {	ACTIVATE_WINDOWLESS	= 1
    }	ACTIVATEFLAGS;


EXTERN_C const IID IID_IOleInPlaceSiteEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleInPlaceSiteEx : public IOleInPlaceSite
    {
    public:
        virtual HRESULT __stdcall OnInPlaceActivateEx( 
            /* [out] */ BOOL *pfNoRedraw,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT __stdcall OnInPlaceDeactivateEx( 
            /* [in] */ BOOL fNoRedraw) = 0;
        
        virtual HRESULT __stdcall RequestUIActivate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleInPlaceSiteExVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IOleInPlaceSiteEx * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IOleInPlaceSiteEx * This);
        
        ULONG ( __stdcall *Release )( 
            IOleInPlaceSiteEx * This);
        
        /* [input_sync] */ HRESULT ( __stdcall *GetWindow )( 
            IOleInPlaceSiteEx * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( __stdcall *ContextSensitiveHelp )( 
            IOleInPlaceSiteEx * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( __stdcall *CanInPlaceActivate )( 
            IOleInPlaceSiteEx * This);
        
        HRESULT ( __stdcall *OnInPlaceActivate )( 
            IOleInPlaceSiteEx * This);
        
        HRESULT ( __stdcall *OnUIActivate )( 
            IOleInPlaceSiteEx * This);
        
        HRESULT ( __stdcall *GetWindowContext )( 
            IOleInPlaceSiteEx * This,
            /* [out] */ IOleInPlaceFrame **ppFrame,
            /* [out] */ IOleInPlaceUIWindow **ppDoc,
            /* [out] */ LPRECT lprcPosRect,
            /* [out] */ LPRECT lprcClipRect,
            /* [out][in] */ LPOLEINPLACEFRAMEINFO lpFrameInfo);
        
        HRESULT ( __stdcall *Scroll )( 
            IOleInPlaceSiteEx * This,
            /* [in] */ SIZE scrollExtant);
        
        HRESULT ( __stdcall *OnUIDeactivate )( 
            IOleInPlaceSiteEx * This,
            /* [in] */ BOOL fUndoable);
        
        HRESULT ( __stdcall *OnInPlaceDeactivate )( 
            IOleInPlaceSiteEx * This);
        
        HRESULT ( __stdcall *DiscardUndoState )( 
            IOleInPlaceSiteEx * This);
        
        HRESULT ( __stdcall *DeactivateAndUndo )( 
            IOleInPlaceSiteEx * This);
        
        HRESULT ( __stdcall *OnPosRectChange )( 
            IOleInPlaceSiteEx * This,
            /* [in] */ LPCRECT lprcPosRect);
        
        HRESULT ( __stdcall *OnInPlaceActivateEx )( 
            IOleInPlaceSiteEx * This,
            /* [out] */ BOOL *pfNoRedraw,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( __stdcall *OnInPlaceDeactivateEx )( 
            IOleInPlaceSiteEx * This,
            /* [in] */ BOOL fNoRedraw);
        
        HRESULT ( __stdcall *RequestUIActivate )( 
            IOleInPlaceSiteEx * This);
        
    } IOleInPlaceSiteExVtbl;

    interface IOleInPlaceSiteEx
    {
        CONST_VTBL struct IOleInPlaceSiteExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleInPlaceSiteEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleInPlaceSiteEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleInPlaceSiteEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleInPlaceSiteEx_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IOleInPlaceSiteEx_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IOleInPlaceSiteEx_CanInPlaceActivate(This)	\
    (This)->lpVtbl -> CanInPlaceActivate(This)

#define IOleInPlaceSiteEx_OnInPlaceActivate(This)	\
    (This)->lpVtbl -> OnInPlaceActivate(This)

#define IOleInPlaceSiteEx_OnUIActivate(This)	\
    (This)->lpVtbl -> OnUIActivate(This)

#define IOleInPlaceSiteEx_GetWindowContext(This,ppFrame,ppDoc,lprcPosRect,lprcClipRect,lpFrameInfo)	\
    (This)->lpVtbl -> GetWindowContext(This,ppFrame,ppDoc,lprcPosRect,lprcClipRect,lpFrameInfo)

#define IOleInPlaceSiteEx_Scroll(This,scrollExtant)	\
    (This)->lpVtbl -> Scroll(This,scrollExtant)

#define IOleInPlaceSiteEx_OnUIDeactivate(This,fUndoable)	\
    (This)->lpVtbl -> OnUIDeactivate(This,fUndoable)

#define IOleInPlaceSiteEx_OnInPlaceDeactivate(This)	\
    (This)->lpVtbl -> OnInPlaceDeactivate(This)

#define IOleInPlaceSiteEx_DiscardUndoState(This)	\
    (This)->lpVtbl -> DiscardUndoState(This)

#define IOleInPlaceSiteEx_DeactivateAndUndo(This)	\
    (This)->lpVtbl -> DeactivateAndUndo(This)

#define IOleInPlaceSiteEx_OnPosRectChange(This,lprcPosRect)	\
    (This)->lpVtbl -> OnPosRectChange(This,lprcPosRect)


#define IOleInPlaceSiteEx_OnInPlaceActivateEx(This,pfNoRedraw,dwFlags)	\
    (This)->lpVtbl -> OnInPlaceActivateEx(This,pfNoRedraw,dwFlags)

#define IOleInPlaceSiteEx_OnInPlaceDeactivateEx(This,fNoRedraw)	\
    (This)->lpVtbl -> OnInPlaceDeactivateEx(This,fNoRedraw)

#define IOleInPlaceSiteEx_RequestUIActivate(This)	\
    (This)->lpVtbl -> RequestUIActivate(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */












/****************************************
 * Generated header for interface: __MIDL__intf_0089
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IOleInPlaceSiteEx * LPOLEINPLACESITEEX;




/****************************************
 * Generated header for interface: IOleInPlaceSiteWindowless
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object][local] */ 


			/* size is 4 */
typedef IOleInPlaceSiteWindowless *LPOLEINPLACESITEWINDOWLESS;

#define OLEDC_NODRAW 1
#define OLEDC_PAINTBKGND 2
#define OLEDC_OFFSCREEN 4

EXTERN_C const IID IID_IOleInPlaceSiteWindowless;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleInPlaceSiteWindowless : public IOleInPlaceSiteEx
    {
    public:
        virtual HRESULT __stdcall CanWindowlessActivate( void) = 0;
        
        virtual HRESULT __stdcall GetCapture( void) = 0;
        
        virtual HRESULT __stdcall SetCapture( 
            /* [in] */ BOOL fCapture) = 0;
        
        virtual HRESULT __stdcall GetFocus( void) = 0;
        
        virtual HRESULT __stdcall SetFocus( 
            /* [in] */ BOOL fFocus) = 0;
        
        virtual HRESULT __stdcall GetDC( 
            /* [in] */ LPCRECT prc,
            /* [in] */ DWORD grfFlags,
            /* [out] */ HDC *phDC) = 0;
        
        virtual HRESULT __stdcall ReleaseDC( 
            /* [in] */ HDC hDC) = 0;
        
        virtual HRESULT __stdcall InvalidateRect( 
            /* [in] */ LPCRECT prc,
            /* [in] */ BOOL fErase) = 0;
        
        virtual HRESULT __stdcall InvalidateRgn( 
            /* [in] */ HRGN hrgn,
            /* [in] */ BOOL fErase) = 0;
        
        virtual HRESULT __stdcall ScrollRect( 
            /* [in] */ int dx,
            /* [in] */ int dy,
            /* [in] */ LPCRECT prcScroll,
            /* [in] */ LPCRECT prcClip) = 0;
        
        virtual HRESULT __stdcall AdjustRect( 
            /* [out][in] */ LPRECT prc) = 0;
        
        virtual HRESULT __stdcall OnDefWindowMessage( 
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleInPlaceSiteWindowlessVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IOleInPlaceSiteWindowless * This);
        
        ULONG ( __stdcall *Release )( 
            IOleInPlaceSiteWindowless * This);
        
        /* [input_sync] */ HRESULT ( __stdcall *GetWindow )( 
            IOleInPlaceSiteWindowless * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( __stdcall *ContextSensitiveHelp )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( __stdcall *CanInPlaceActivate )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *OnInPlaceActivate )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *OnUIActivate )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *GetWindowContext )( 
            IOleInPlaceSiteWindowless * This,
            /* [out] */ IOleInPlaceFrame **ppFrame,
            /* [out] */ IOleInPlaceUIWindow **ppDoc,
            /* [out] */ LPRECT lprcPosRect,
            /* [out] */ LPRECT lprcClipRect,
            /* [out][in] */ LPOLEINPLACEFRAMEINFO lpFrameInfo);
        
        HRESULT ( __stdcall *Scroll )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ SIZE scrollExtant);
        
        HRESULT ( __stdcall *OnUIDeactivate )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ BOOL fUndoable);
        
        HRESULT ( __stdcall *OnInPlaceDeactivate )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *DiscardUndoState )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *DeactivateAndUndo )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *OnPosRectChange )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ LPCRECT lprcPosRect);
        
        HRESULT ( __stdcall *OnInPlaceActivateEx )( 
            IOleInPlaceSiteWindowless * This,
            /* [out] */ BOOL *pfNoRedraw,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( __stdcall *OnInPlaceDeactivateEx )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ BOOL fNoRedraw);
        
        HRESULT ( __stdcall *RequestUIActivate )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *CanWindowlessActivate )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *GetCapture )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *SetCapture )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ BOOL fCapture);
        
        HRESULT ( __stdcall *GetFocus )( 
            IOleInPlaceSiteWindowless * This);
        
        HRESULT ( __stdcall *SetFocus )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ BOOL fFocus);
        
        HRESULT ( __stdcall *GetDC )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ LPCRECT prc,
            /* [in] */ DWORD grfFlags,
            /* [out] */ HDC *phDC);
        
        HRESULT ( __stdcall *ReleaseDC )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ HDC hDC);
        
        HRESULT ( __stdcall *InvalidateRect )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ LPCRECT prc,
            /* [in] */ BOOL fErase);
        
        HRESULT ( __stdcall *InvalidateRgn )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ HRGN hrgn,
            /* [in] */ BOOL fErase);
        
        HRESULT ( __stdcall *ScrollRect )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ int dx,
            /* [in] */ int dy,
            /* [in] */ LPCRECT prcScroll,
            /* [in] */ LPCRECT prcClip);
        
        HRESULT ( __stdcall *AdjustRect )( 
            IOleInPlaceSiteWindowless * This,
            /* [out][in] */ LPRECT prc);
        
        HRESULT ( __stdcall *OnDefWindowMessage )( 
            IOleInPlaceSiteWindowless * This,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
    } IOleInPlaceSiteWindowlessVtbl;

    interface IOleInPlaceSiteWindowless
    {
        CONST_VTBL struct IOleInPlaceSiteWindowlessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleInPlaceSiteWindowless_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleInPlaceSiteWindowless_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleInPlaceSiteWindowless_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleInPlaceSiteWindowless_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IOleInPlaceSiteWindowless_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IOleInPlaceSiteWindowless_CanInPlaceActivate(This)	\
    (This)->lpVtbl -> CanInPlaceActivate(This)

#define IOleInPlaceSiteWindowless_OnInPlaceActivate(This)	\
    (This)->lpVtbl -> OnInPlaceActivate(This)

#define IOleInPlaceSiteWindowless_OnUIActivate(This)	\
    (This)->lpVtbl -> OnUIActivate(This)

#define IOleInPlaceSiteWindowless_GetWindowContext(This,ppFrame,ppDoc,lprcPosRect,lprcClipRect,lpFrameInfo)	\
    (This)->lpVtbl -> GetWindowContext(This,ppFrame,ppDoc,lprcPosRect,lprcClipRect,lpFrameInfo)

#define IOleInPlaceSiteWindowless_Scroll(This,scrollExtant)	\
    (This)->lpVtbl -> Scroll(This,scrollExtant)

#define IOleInPlaceSiteWindowless_OnUIDeactivate(This,fUndoable)	\
    (This)->lpVtbl -> OnUIDeactivate(This,fUndoable)

#define IOleInPlaceSiteWindowless_OnInPlaceDeactivate(This)	\
    (This)->lpVtbl -> OnInPlaceDeactivate(This)

#define IOleInPlaceSiteWindowless_DiscardUndoState(This)	\
    (This)->lpVtbl -> DiscardUndoState(This)

#define IOleInPlaceSiteWindowless_DeactivateAndUndo(This)	\
    (This)->lpVtbl -> DeactivateAndUndo(This)

#define IOleInPlaceSiteWindowless_OnPosRectChange(This,lprcPosRect)	\
    (This)->lpVtbl -> OnPosRectChange(This,lprcPosRect)


#define IOleInPlaceSiteWindowless_OnInPlaceActivateEx(This,pfNoRedraw,dwFlags)	\
    (This)->lpVtbl -> OnInPlaceActivateEx(This,pfNoRedraw,dwFlags)

#define IOleInPlaceSiteWindowless_OnInPlaceDeactivateEx(This,fNoRedraw)	\
    (This)->lpVtbl -> OnInPlaceDeactivateEx(This,fNoRedraw)

#define IOleInPlaceSiteWindowless_RequestUIActivate(This)	\
    (This)->lpVtbl -> RequestUIActivate(This)


#define IOleInPlaceSiteWindowless_CanWindowlessActivate(This)	\
    (This)->lpVtbl -> CanWindowlessActivate(This)

#define IOleInPlaceSiteWindowless_GetCapture(This)	\
    (This)->lpVtbl -> GetCapture(This)

#define IOleInPlaceSiteWindowless_SetCapture(This,fCapture)	\
    (This)->lpVtbl -> SetCapture(This,fCapture)

#define IOleInPlaceSiteWindowless_GetFocus(This)	\
    (This)->lpVtbl -> GetFocus(This)

#define IOleInPlaceSiteWindowless_SetFocus(This,fFocus)	\
    (This)->lpVtbl -> SetFocus(This,fFocus)

#define IOleInPlaceSiteWindowless_GetDC(This,prc,grfFlags,phDC)	\
    (This)->lpVtbl -> GetDC(This,prc,grfFlags,phDC)

#define IOleInPlaceSiteWindowless_ReleaseDC(This,hDC)	\
    (This)->lpVtbl -> ReleaseDC(This,hDC)

#define IOleInPlaceSiteWindowless_InvalidateRect(This,prc,fErase)	\
    (This)->lpVtbl -> InvalidateRect(This,prc,fErase)

#define IOleInPlaceSiteWindowless_InvalidateRgn(This,hrgn,fErase)	\
    (This)->lpVtbl -> InvalidateRgn(This,hrgn,fErase)

#define IOleInPlaceSiteWindowless_ScrollRect(This,dx,dy,prcScroll,prcClip)	\
    (This)->lpVtbl -> ScrollRect(This,dx,dy,prcScroll,prcClip)

#define IOleInPlaceSiteWindowless_AdjustRect(This,prc)	\
    (This)->lpVtbl -> AdjustRect(This,prc)

#define IOleInPlaceSiteWindowless_OnDefWindowMessage(This,msg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> OnDefWindowMessage(This,msg,wParam,lParam,plResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */






























/****************************************
 * Generated header for interface: __MIDL__intf_0090
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IOleInPlaceSiteWindowless * LPOLEINPLACESITEWINDOWLESS;




/****************************************
 * Generated header for interface: IViewObjectEx
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object][local] */ 


			/* size is 4 */
typedef IViewObjectEx *LPVIEWOBJECTEX;

			/* size is 2 */
typedef 
enum _VIEWSTATUS
    {	VIEWSTATUS_OPAQUE	= 1,
	VIEWSTATUS_SOLIDBKGND	= 2,
	VIEWSTATUS_DVASPECTOPAQUE	= 4,
	VIEWSTATUS_DVASPECTTRANSPARENT	= 8
    }	VIEWSTATUS;

			/* size is 2 */
typedef 
enum _HITRESULT
    {	HITRESULT_OUTSIDE	= 0,
	HITRESULT_TRANSPARENT	= 1,
	HITRESULT_CLOSE	= 2,
	HITRESULT_HIT	= 3
    }	HITRESULT;

			/* size is 2 */
typedef 
enum _DVASPECT2
    {	DVASPECT_OPAQUE	= 16,
	DVASPECT_TRANSPARENT	= 32
    }	DVASPECT2;

			/* size is 16 */
typedef struct  tagExtentInfo
    {
    UINT cb;
    DWORD dwExtentMode;
    SIZEL sizelProposed;
    }	DVEXTENTINFO;

			/* size is 2 */
typedef 
enum tagExtentMode
    {	DVEXTENT_CONTENT	= 0,
	DVEXTENT_INTEGRAL	= DVEXTENT_CONTENT + 1
    }	DVEXTENTMODE;

			/* size is 2 */
typedef 
enum tagAspectInfoFlag
    {	DVASPECTINFOFLAG_CANOPTIMIZE	= 1
    }	DVASPECTINFOFLAG;

			/* size is 8 */
typedef struct  tagAspectInfo
    {
    UINT cb;
    DWORD dwFlags;
    }	DVASPECTINFO;


EXTERN_C const IID IID_IViewObjectEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IViewObjectEx : public IViewObject2
    {
    public:
        virtual HRESULT __stdcall GetRect( 
            /* [in] */ DWORD dwAspect,
            /* [out] */ LPRECTL pRect) = 0;
        
        virtual HRESULT __stdcall GetViewStatus( 
            /* [out] */ DWORD *pdwStatus) = 0;
        
        virtual HRESULT __stdcall QueryHitPoint( 
            /* [in] */ DWORD dwAspect,
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ POINT ptlLoc,
            /* [in] */ LONG lCloseHint,
            /* [out] */ DWORD *pHitResult) = 0;
        
        virtual HRESULT __stdcall QueryHitRect( 
            /* [in] */ DWORD dwAspect,
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ LPCRECT prcLoc,
            /* [in] */ LONG lCloseHint,
            /* [out] */ DWORD *pHitResult) = 0;
        
        virtual HRESULT __stdcall GetNaturalExtent( 
            /* [in] */ DWORD dwAspect,
            /* [in] */ LONG lindex,
            /* [in] */ DVTARGETDEVICE *ptd,
            /* [in] */ HDC hicTargetDev,
            /* [in] */ DVEXTENTINFO *pExtentInfo,
            /* [out] */ LPSIZEL psizel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IViewObjectExVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IViewObjectEx * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IViewObjectEx * This);
        
        ULONG ( __stdcall *Release )( 
            IViewObjectEx * This);
        
        HRESULT ( __stdcall *Draw )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [unique][in] */ DVTARGETDEVICE *ptd,
            /* [in] */ HDC hdcTargetDev,
            /* [in] */ HDC hdcDraw,
            /* [in] */ LPCRECTL lprcBounds,
            /* [in] */ LPCRECTL lprcWBounds,
            /* [in] */ BOOL ( __stdcall __stdcall *pfnContinue )( 
                DWORD dwContinue),
            /* [in] */ DWORD dwContinue);
        
        HRESULT ( __stdcall *GetColorSet )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [in] */ DVTARGETDEVICE *ptd,
            /* [in] */ HDC hicTargetDev,
            /* [out] */ LOGPALETTE **ppColorSet);
        
        HRESULT ( __stdcall *Freeze )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [out] */ DWORD *pdwFreeze);
        
        HRESULT ( __stdcall *Unfreeze )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwFreeze);
        
        HRESULT ( __stdcall *SetAdvise )( 
            IViewObjectEx * This,
            /* [in] */ DWORD aspects,
            /* [in] */ DWORD advf,
            /* [unique][in] */ IAdviseSink *pAdvSink);
        
        HRESULT ( __stdcall *GetAdvise )( 
            IViewObjectEx * This,
            /* [out] */ DWORD *pAspects,
            /* [out] */ DWORD *pAdvf,
            /* [out] */ IAdviseSink **ppAdvSink);
        
        HRESULT ( __stdcall *GetExtent )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [in] */ DVTARGETDEVICE *ptd,
            /* [out] */ LPSIZEL lpsizel);
        
        HRESULT ( __stdcall *GetRect )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwAspect,
            /* [out] */ LPRECTL pRect);
        
        HRESULT ( __stdcall *GetViewStatus )( 
            IViewObjectEx * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( __stdcall *QueryHitPoint )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwAspect,
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ POINT ptlLoc,
            /* [in] */ LONG lCloseHint,
            /* [out] */ DWORD *pHitResult);
        
        HRESULT ( __stdcall *QueryHitRect )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwAspect,
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ LPCRECT prcLoc,
            /* [in] */ LONG lCloseHint,
            /* [out] */ DWORD *pHitResult);
        
        HRESULT ( __stdcall *GetNaturalExtent )( 
            IViewObjectEx * This,
            /* [in] */ DWORD dwAspect,
            /* [in] */ LONG lindex,
            /* [in] */ DVTARGETDEVICE *ptd,
            /* [in] */ HDC hicTargetDev,
            /* [in] */ DVEXTENTINFO *pExtentInfo,
            /* [out] */ LPSIZEL psizel);
        
    } IViewObjectExVtbl;

    interface IViewObjectEx
    {
        CONST_VTBL struct IViewObjectExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IViewObjectEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IViewObjectEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IViewObjectEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IViewObjectEx_Draw(This,dwDrawAspect,lindex,pvAspect,ptd,hdcTargetDev,hdcDraw,lprcBounds,lprcWBounds,pfnContinue,dwContinue)	\
    (This)->lpVtbl -> Draw(This,dwDrawAspect,lindex,pvAspect,ptd,hdcTargetDev,hdcDraw,lprcBounds,lprcWBounds,pfnContinue,dwContinue)

#define IViewObjectEx_GetColorSet(This,dwDrawAspect,lindex,pvAspect,ptd,hicTargetDev,ppColorSet)	\
    (This)->lpVtbl -> GetColorSet(This,dwDrawAspect,lindex,pvAspect,ptd,hicTargetDev,ppColorSet)

#define IViewObjectEx_Freeze(This,dwDrawAspect,lindex,pvAspect,pdwFreeze)	\
    (This)->lpVtbl -> Freeze(This,dwDrawAspect,lindex,pvAspect,pdwFreeze)

#define IViewObjectEx_Unfreeze(This,dwFreeze)	\
    (This)->lpVtbl -> Unfreeze(This,dwFreeze)

#define IViewObjectEx_SetAdvise(This,aspects,advf,pAdvSink)	\
    (This)->lpVtbl -> SetAdvise(This,aspects,advf,pAdvSink)

#define IViewObjectEx_GetAdvise(This,pAspects,pAdvf,ppAdvSink)	\
    (This)->lpVtbl -> GetAdvise(This,pAspects,pAdvf,ppAdvSink)


#define IViewObjectEx_GetExtent(This,dwDrawAspect,lindex,ptd,lpsizel)	\
    (This)->lpVtbl -> GetExtent(This,dwDrawAspect,lindex,ptd,lpsizel)


#define IViewObjectEx_GetRect(This,dwAspect,pRect)	\
    (This)->lpVtbl -> GetRect(This,dwAspect,pRect)

#define IViewObjectEx_GetViewStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetViewStatus(This,pdwStatus)

#define IViewObjectEx_QueryHitPoint(This,dwAspect,pRectBounds,ptlLoc,lCloseHint,pHitResult)	\
    (This)->lpVtbl -> QueryHitPoint(This,dwAspect,pRectBounds,ptlLoc,lCloseHint,pHitResult)

#define IViewObjectEx_QueryHitRect(This,dwAspect,pRectBounds,prcLoc,lCloseHint,pHitResult)	\
    (This)->lpVtbl -> QueryHitRect(This,dwAspect,pRectBounds,prcLoc,lCloseHint,pHitResult)

#define IViewObjectEx_GetNaturalExtent(This,dwAspect,lindex,ptd,hicTargetDev,pExtentInfo,psizel)	\
    (This)->lpVtbl -> GetNaturalExtent(This,dwAspect,lindex,ptd,hicTargetDev,pExtentInfo,psizel)

#endif /* COBJMACROS */


#endif 	/* C style interface */
















/****************************************
 * Generated header for interface: __MIDL__intf_0091
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IViewObjectEx * LPVIEWOBJECTEX;
			/* size is 0 */

#define UAS_NORMAL         0
#define UAS_BLOCKED        1
#define UAS_NOPARENTENABLE 2
#define UAS_MASK           0x03




/****************************************
 * Generated header for interface: IOleUndoUnit
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object] */ 



EXTERN_C const IID IID_IOleUndoUnit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleUndoUnit : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Do( 
            /* [in] */ IOleUndoManager *pUndoManager) = 0;
        
        virtual HRESULT __stdcall GetDescription( 
            /* [out] */ BSTR *pbstr) = 0;
        
        virtual HRESULT __stdcall GetUnitType( 
            /* [out] */ CLSID *pclsid,
            /* [out] */ LONG *plID) = 0;
        
        virtual HRESULT __stdcall OnNextAdd( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleUndoUnitVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IOleUndoUnit * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IOleUndoUnit * This);
        
        ULONG ( __stdcall *Release )( 
            IOleUndoUnit * This);
        
        HRESULT ( __stdcall *Do )( 
            IOleUndoUnit * This,
            /* [in] */ IOleUndoManager *pUndoManager);
        
        HRESULT ( __stdcall *GetDescription )( 
            IOleUndoUnit * This,
            /* [out] */ BSTR *pbstr);
        
        HRESULT ( __stdcall *GetUnitType )( 
            IOleUndoUnit * This,
            /* [out] */ CLSID *pclsid,
            /* [out] */ LONG *plID);
        
        HRESULT ( __stdcall *OnNextAdd )( 
            IOleUndoUnit * This);
        
    } IOleUndoUnitVtbl;

    interface IOleUndoUnit
    {
        CONST_VTBL struct IOleUndoUnitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleUndoUnit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleUndoUnit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleUndoUnit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleUndoUnit_Do(This,pUndoManager)	\
    (This)->lpVtbl -> Do(This,pUndoManager)

#define IOleUndoUnit_GetDescription(This,pbstr)	\
    (This)->lpVtbl -> GetDescription(This,pbstr)

#define IOleUndoUnit_GetUnitType(This,pclsid,plID)	\
    (This)->lpVtbl -> GetUnitType(This,pclsid,plID)

#define IOleUndoUnit_OnNextAdd(This)	\
    (This)->lpVtbl -> OnNextAdd(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */














/****************************************
 * Generated header for interface: __MIDL__intf_0092
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IOleUndoUnit * LPOLEUNDOUNIT;




/****************************************
 * Generated header for interface: IOleParentUndoUnit
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object] */ 



EXTERN_C const IID IID_IOleParentUndoUnit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleParentUndoUnit : public IOleUndoUnit
    {
    public:
        virtual HRESULT __stdcall Open( 
            /* [in] */ IOleParentUndoUnit *pPUU) = 0;
        
        virtual HRESULT __stdcall Close( 
            /* [in] */ IOleParentUndoUnit *pPUU,
            /* [in] */ BOOL fCommit) = 0;
        
        virtual HRESULT __stdcall Add( 
            /* [in] */ IOleUndoUnit *pUU) = 0;
        
        virtual HRESULT __stdcall FindUnit( 
            /* [in] */ IOleUndoUnit *pUU) = 0;
        
        virtual HRESULT __stdcall GetParentState( 
            /* [out] */ DWORD *pdwState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleParentUndoUnitVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IOleParentUndoUnit * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IOleParentUndoUnit * This);
        
        ULONG ( __stdcall *Release )( 
            IOleParentUndoUnit * This);
        
        HRESULT ( __stdcall *Do )( 
            IOleParentUndoUnit * This,
            /* [in] */ IOleUndoManager *pUndoManager);
        
        HRESULT ( __stdcall *GetDescription )( 
            IOleParentUndoUnit * This,
            /* [out] */ BSTR *pbstr);
        
        HRESULT ( __stdcall *GetUnitType )( 
            IOleParentUndoUnit * This,
            /* [out] */ CLSID *pclsid,
            /* [out] */ LONG *plID);
        
        HRESULT ( __stdcall *OnNextAdd )( 
            IOleParentUndoUnit * This);
        
        HRESULT ( __stdcall *Open )( 
            IOleParentUndoUnit * This,
            /* [in] */ IOleParentUndoUnit *pPUU);
        
        HRESULT ( __stdcall *Close )( 
            IOleParentUndoUnit * This,
            /* [in] */ IOleParentUndoUnit *pPUU,
            /* [in] */ BOOL fCommit);
        
        HRESULT ( __stdcall *Add )( 
            IOleParentUndoUnit * This,
            /* [in] */ IOleUndoUnit *pUU);
        
        HRESULT ( __stdcall *FindUnit )( 
            IOleParentUndoUnit * This,
            /* [in] */ IOleUndoUnit *pUU);
        
        HRESULT ( __stdcall *GetParentState )( 
            IOleParentUndoUnit * This,
            /* [out] */ DWORD *pdwState);
        
    } IOleParentUndoUnitVtbl;

    interface IOleParentUndoUnit
    {
        CONST_VTBL struct IOleParentUndoUnitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleParentUndoUnit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleParentUndoUnit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleParentUndoUnit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleParentUndoUnit_Do(This,pUndoManager)	\
    (This)->lpVtbl -> Do(This,pUndoManager)

#define IOleParentUndoUnit_GetDescription(This,pbstr)	\
    (This)->lpVtbl -> GetDescription(This,pbstr)

#define IOleParentUndoUnit_GetUnitType(This,pclsid,plID)	\
    (This)->lpVtbl -> GetUnitType(This,pclsid,plID)

#define IOleParentUndoUnit_OnNextAdd(This)	\
    (This)->lpVtbl -> OnNextAdd(This)


#define IOleParentUndoUnit_Open(This,pPUU)	\
    (This)->lpVtbl -> Open(This,pPUU)

#define IOleParentUndoUnit_Close(This,pPUU,fCommit)	\
    (This)->lpVtbl -> Close(This,pPUU,fCommit)

#define IOleParentUndoUnit_Add(This,pUU)	\
    (This)->lpVtbl -> Add(This,pUU)

#define IOleParentUndoUnit_FindUnit(This,pUU)	\
    (This)->lpVtbl -> FindUnit(This,pUU)

#define IOleParentUndoUnit_GetParentState(This,pdwState)	\
    (This)->lpVtbl -> GetParentState(This,pdwState)

#endif /* COBJMACROS */


#endif 	/* C style interface */
















/****************************************
 * Generated header for interface: __MIDL__intf_0093
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IOleParentUndoUnit * LPOLEPARENTUNDOUNIT;




/****************************************
 * Generated header for interface: IEnumOleUndoUnits
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object] */ 



EXTERN_C const IID IID_IEnumOleUndoUnits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumOleUndoUnits : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out][length_is][size_is][out] */ IOleUndoUnit **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumOleUndoUnits **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumOleUndoUnitsVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IEnumOleUndoUnits * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IEnumOleUndoUnits * This);
        
        ULONG ( __stdcall *Release )( 
            IEnumOleUndoUnits * This);
        
        HRESULT ( __stdcall *Next )( 
            IEnumOleUndoUnits * This,
            /* [in] */ ULONG celt,
            /* [out][length_is][size_is][out] */ IOleUndoUnit **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( __stdcall *Skip )( 
            IEnumOleUndoUnits * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall *Reset )( 
            IEnumOleUndoUnits * This);
        
        HRESULT ( __stdcall *Clone )( 
            IEnumOleUndoUnits * This,
            /* [out] */ IEnumOleUndoUnits **ppenum);
        
    } IEnumOleUndoUnitsVtbl;

    interface IEnumOleUndoUnits
    {
        CONST_VTBL struct IEnumOleUndoUnitsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumOleUndoUnits_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumOleUndoUnits_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumOleUndoUnits_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumOleUndoUnits_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumOleUndoUnits_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumOleUndoUnits_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumOleUndoUnits_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */














/****************************************
 * Generated header for interface: __MIDL__intf_0094
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IEnumOleUndoUnits * LPENUMOLEUNDOUNITS;
#define SID_SOleUndoManager IID_IOleUndoManager




/****************************************
 * Generated header for interface: IOleUndoManager
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object] */ 



EXTERN_C const IID IID_IOleUndoManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleUndoManager : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Open( 
            /* [in] */ IOleParentUndoUnit *pPUU) = 0;
        
        virtual HRESULT __stdcall Close( 
            /* [in] */ IOleParentUndoUnit *pPUU,
            /* [in] */ BOOL fCommit) = 0;
        
        virtual HRESULT __stdcall Add( 
            /* [in] */ IOleUndoUnit *pUU) = 0;
        
        virtual HRESULT __stdcall GetOpenParentState( 
            /* [out] */ DWORD *pdwState) = 0;
        
        virtual HRESULT __stdcall DiscardFrom( 
            /* [in] */ IOleUndoUnit *pUU) = 0;
        
        virtual HRESULT __stdcall UndoTo( 
            /* [in] */ IOleUndoUnit *pUU) = 0;
        
        virtual HRESULT __stdcall RedoTo( 
            /* [in] */ IOleUndoUnit *pUU) = 0;
        
        virtual HRESULT __stdcall EnumUndoable( 
            /* [out] */ IEnumOleUndoUnits **ppEnum) = 0;
        
        virtual HRESULT __stdcall EnumRedoable( 
            /* [out] */ IEnumOleUndoUnits **ppEnum) = 0;
        
        virtual HRESULT __stdcall GetLastUndoDescription( 
            /* [out] */ BSTR *pbstr) = 0;
        
        virtual HRESULT __stdcall GetLastRedoDescription( 
            /* [out] */ BSTR *pbstr) = 0;
        
        virtual HRESULT __stdcall Enable( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleUndoManagerVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IOleUndoManager * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IOleUndoManager * This);
        
        ULONG ( __stdcall *Release )( 
            IOleUndoManager * This);
        
        HRESULT ( __stdcall *Open )( 
            IOleUndoManager * This,
            /* [in] */ IOleParentUndoUnit *pPUU);
        
        HRESULT ( __stdcall *Close )( 
            IOleUndoManager * This,
            /* [in] */ IOleParentUndoUnit *pPUU,
            /* [in] */ BOOL fCommit);
        
        HRESULT ( __stdcall *Add )( 
            IOleUndoManager * This,
            /* [in] */ IOleUndoUnit *pUU);
        
        HRESULT ( __stdcall *GetOpenParentState )( 
            IOleUndoManager * This,
            /* [out] */ DWORD *pdwState);
        
        HRESULT ( __stdcall *DiscardFrom )( 
            IOleUndoManager * This,
            /* [in] */ IOleUndoUnit *pUU);
        
        HRESULT ( __stdcall *UndoTo )( 
            IOleUndoManager * This,
            /* [in] */ IOleUndoUnit *pUU);
        
        HRESULT ( __stdcall *RedoTo )( 
            IOleUndoManager * This,
            /* [in] */ IOleUndoUnit *pUU);
        
        HRESULT ( __stdcall *EnumUndoable )( 
            IOleUndoManager * This,
            /* [out] */ IEnumOleUndoUnits **ppEnum);
        
        HRESULT ( __stdcall *EnumRedoable )( 
            IOleUndoManager * This,
            /* [out] */ IEnumOleUndoUnits **ppEnum);
        
        HRESULT ( __stdcall *GetLastUndoDescription )( 
            IOleUndoManager * This,
            /* [out] */ BSTR *pbstr);
        
        HRESULT ( __stdcall *GetLastRedoDescription )( 
            IOleUndoManager * This,
            /* [out] */ BSTR *pbstr);
        
        HRESULT ( __stdcall *Enable )( 
            IOleUndoManager * This,
            /* [in] */ BOOL fEnable);
        
    } IOleUndoManagerVtbl;

    interface IOleUndoManager
    {
        CONST_VTBL struct IOleUndoManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleUndoManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleUndoManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleUndoManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleUndoManager_Open(This,pPUU)	\
    (This)->lpVtbl -> Open(This,pPUU)

#define IOleUndoManager_Close(This,pPUU,fCommit)	\
    (This)->lpVtbl -> Close(This,pPUU,fCommit)

#define IOleUndoManager_Add(This,pUU)	\
    (This)->lpVtbl -> Add(This,pUU)

#define IOleUndoManager_GetOpenParentState(This,pdwState)	\
    (This)->lpVtbl -> GetOpenParentState(This,pdwState)

#define IOleUndoManager_DiscardFrom(This,pUU)	\
    (This)->lpVtbl -> DiscardFrom(This,pUU)

#define IOleUndoManager_UndoTo(This,pUU)	\
    (This)->lpVtbl -> UndoTo(This,pUU)

#define IOleUndoManager_RedoTo(This,pUU)	\
    (This)->lpVtbl -> RedoTo(This,pUU)

#define IOleUndoManager_EnumUndoable(This,ppEnum)	\
    (This)->lpVtbl -> EnumUndoable(This,ppEnum)

#define IOleUndoManager_EnumRedoable(This,ppEnum)	\
    (This)->lpVtbl -> EnumRedoable(This,ppEnum)

#define IOleUndoManager_GetLastUndoDescription(This,pbstr)	\
    (This)->lpVtbl -> GetLastUndoDescription(This,pbstr)

#define IOleUndoManager_GetLastRedoDescription(This,pbstr)	\
    (This)->lpVtbl -> GetLastRedoDescription(This,pbstr)

#define IOleUndoManager_Enable(This,fEnable)	\
    (This)->lpVtbl -> Enable(This,fEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */






























/****************************************
 * Generated header for interface: __MIDL__intf_0095
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IOleUndoManager * LPOLEUNDOMANAGER;
#define QACONTAINER_SHOWHATCHING      0x0001
#define QACONTAINER_SHOWGRABHANDLES   0x0002
#define QACONTAINER_USERMODE          0x0004
#define QACONTAINER_DISPLAYASDEFAULT  0x0008
#define QACONTAINER_UIDEAD            0x0010
#define QACONTAINER_AUTOCLIP          0x0020
#define QACONTAINER_MESSAGEREFLECT    0x0040
#define QACONTAINER_SUPPORTSMNEMONICS 0x0080
			/* size is 56 */
typedef struct  _QACONTAINER
    {
    ULONG cbSize;
    IOleClientSite *pClientSite;
    IAdviseSinkEx *pAdviseSink;
    IPropertyNotifySink *pPropertyNotifySink;
    IUnknown *pUnkEventSink;
    DWORD dwAmbientFlags;
    OLE_COLOR colorFore;
    OLE_COLOR colorBack;
    IFont *pFont;
    IOleUndoManager *pUndoMgr;
    DWORD dwAppearance;
    LONG lcid;
    HPALETTE hpal;
    IBindHost *pBindHost;
    }	QACONTAINER;

			/* size is 24 */
typedef struct  _QACONTROL
    {
    ULONG cbSize;
    DWORD dwMiscStatus;
    DWORD dwViewStatus;
    DWORD dwEventCookie;
    DWORD dwPropNotifyCookie;
    DWORD dwPointerActivationPolicy;
    }	QACONTROL;





/****************************************
 * Generated header for interface: IQuickActivate
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object][local] */ 



EXTERN_C const IID IID_IQuickActivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IQuickActivate : public IUnknown
    {
    public:
        virtual HRESULT __stdcall QuickActivate( 
            /* [in] */ QACONTAINER *pqacontainer,
            /* [out] */ QACONTROL *pqacontrol) = 0;
        
        virtual HRESULT __stdcall SetContentExtent( 
            LPSIZEL lpsizel) = 0;
        
        virtual HRESULT __stdcall GetContentExtent( 
            LPSIZEL lpsizel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQuickActivateVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IQuickActivate * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IQuickActivate * This);
        
        ULONG ( __stdcall *Release )( 
            IQuickActivate * This);
        
        HRESULT ( __stdcall *QuickActivate )( 
            IQuickActivate * This,
            /* [in] */ QACONTAINER *pqacontainer,
            /* [out] */ QACONTROL *pqacontrol);
        
        HRESULT ( __stdcall *SetContentExtent )( 
            IQuickActivate * This,
            LPSIZEL lpsizel);
        
        HRESULT ( __stdcall *GetContentExtent )( 
            IQuickActivate * This,
            LPSIZEL lpsizel);
        
    } IQuickActivateVtbl;

    interface IQuickActivate
    {
        CONST_VTBL struct IQuickActivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQuickActivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IQuickActivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IQuickActivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IQuickActivate_QuickActivate(This,pqacontainer,pqacontrol)	\
    (This)->lpVtbl -> QuickActivate(This,pqacontainer,pqacontrol)

#define IQuickActivate_SetContentExtent(This,lpsizel)	\
    (This)->lpVtbl -> SetContentExtent(This,lpsizel)

#define IQuickActivate_GetContentExtent(This,lpsizel)	\
    (This)->lpVtbl -> GetContentExtent(This,lpsizel)

#endif /* COBJMACROS */


#endif 	/* C style interface */












/****************************************
 * Generated header for interface: __MIDL__intf_0096
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IQuickActivate * LPQUICKACTIVATE;
			/* size is 2 */
typedef 
enum _POINTERINACTIVE
    {	POINTERINACTIVE_ACTIVATEONENTRY	= 1,
	POINTERINACTIVE_DEACTIVATEONLEAVE	= 2,
	POINTERINACTIVE_ACTIVATEONDRAG	= 4
    }	POINTERINACTIVE;





/****************************************
 * Generated header for interface: IPointerInactive
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][unique][object][local] */ 



EXTERN_C const IID IID_IPointerInactive;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPointerInactive : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetActivationPolicy( 
            /* [out] */ DWORD *pdwPolicy) = 0;
        
        virtual HRESULT __stdcall OnInactiveMouseMove( 
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ DWORD grfKeyState) = 0;
        
        virtual HRESULT __stdcall OnInactiveSetCursor( 
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ DWORD dwMouseMsg,
            /* [in] */ BOOL fSetAlways) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPointerInactiveVtbl
    {
        
        HRESULT ( __stdcall *QueryInterface )( 
            IPointerInactive * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        ULONG ( __stdcall *AddRef )( 
            IPointerInactive * This);
        
        ULONG ( __stdcall *Release )( 
            IPointerInactive * This);
        
        HRESULT ( __stdcall *GetActivationPolicy )( 
            IPointerInactive * This,
            /* [out] */ DWORD *pdwPolicy);
        
        HRESULT ( __stdcall *OnInactiveMouseMove )( 
            IPointerInactive * This,
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ DWORD grfKeyState);
        
        HRESULT ( __stdcall *OnInactiveSetCursor )( 
            IPointerInactive * This,
            /* [in] */ LPCRECT pRectBounds,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ DWORD dwMouseMsg,
            /* [in] */ BOOL fSetAlways);
        
    } IPointerInactiveVtbl;

    interface IPointerInactive
    {
        CONST_VTBL struct IPointerInactiveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPointerInactive_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPointerInactive_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPointerInactive_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPointerInactive_GetActivationPolicy(This,pdwPolicy)	\
    (This)->lpVtbl -> GetActivationPolicy(This,pdwPolicy)

#define IPointerInactive_OnInactiveMouseMove(This,pRectBounds,x,y,grfKeyState)	\
    (This)->lpVtbl -> OnInactiveMouseMove(This,pRectBounds,x,y,grfKeyState)

#define IPointerInactive_OnInactiveSetCursor(This,pRectBounds,x,y,dwMouseMsg,fSetAlways)	\
    (This)->lpVtbl -> OnInactiveSetCursor(This,pRectBounds,x,y,dwMouseMsg,fSetAlways)

#endif /* COBJMACROS */


#endif 	/* C style interface */












/****************************************
 * Generated header for interface: __MIDL__intf_0097
 * at Wed Mar 27 07:31:34 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


typedef IPointerInactive * LPPOINTERINACTIVE;



/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\strcoll.h ===
//=--------------------------------------------------------------------------=
// StringsColl.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the definitions for the various string collections we'll use
//
#ifndef _STRINGSCOLL_H_

#include "CommDlgInterfaces.H"



//=--------------------------------------------------------------------------=
// the CStringsCollection class basically works with a safearray to expose the
// collection, and uses the safearray functions to maniplate it.
//=--------------------------------------------------------------------------=
// NOTES: 9.95 - this collection assumes that the safearray lbound is
//        zero!
//=--------------------------------------------------------------------------=
//
class CStringCollection {

  public:
    // a couple of methods that are common
    //
    STDMETHOD(get_Count)(THIS_ long FAR* pcStrings);
    STDMETHOD(get_Item)(THIS_ long lIndex, BSTR FAR* pbstrItem);
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppUnkNewEnum);

    CStringCollection(SAFEARRAY *);
    virtual ~CStringCollection();

  protected:
    // what the collection will work with.
    //
    SAFEARRAY *m_psa;
};

class CStringDynaCollection : public CStringCollection {

  public:
    // in addition to the CStringCollection methods, we'll have
    //
    STDMETHOD(put_Item)(THIS_ long lIndex, BSTR bstrItem);
    STDMETHOD(Add)(THIS_ BSTR bstrNew);
    STDMETHOD(Remove)(THIS_ long lIndex);

    CStringDynaCollection(SAFEARRAY *);
    virtual ~CStringDynaCollection();

};


#define _STRINGSCOLL_H_
#endif // _STRINGSCOLL_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\tools.inc ===
#=------------------------------------------------------------------------=
# Tools.Inc
#=------------------------------------------------------------------------=
# Copyright  1995  Microsoft Corporation.  All Rights Reserved.
#
# THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
# ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
# PARTICULAR PURPOSE.
#=--------------------------------------------------------------------------=
#
# sets up the various tools required to build a control.
#


CC=cl
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
ML=asaxp
!elseif "$(PROCESSOR_ARCHITECTURE)"=="MIPS"
ML=cl
!elseif "$(PROCESSOR_ARCHITECTURE)"=="PPC"
ML=pas
!else
ML=ml
!endif
RC=rc
LINK=link
LIBRARIAN=lib
MKTYPLIB=mktyplib
INCLUDES=includes
MKDEP=mkdep
MAKEVERS=$(THUNDER55)\$(TOOLS)\BIN\makevers /MajorVer 6 /MinorVer 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\stdenum.h ===
//=--------------------------------------------------------------------------=
// StandardEnum.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// object definition for a generic enumerator object.
//
#ifndef _STANDARDENUM_H_

#include "Unknown.H"
#include "Macros.H"

// to support a generic Enumerator object, we'll just define this
// interface.  it can be safely cast to any other enumerator, since all
// they differ in is their pointer type in Next().
//
class IEnumGeneric: public IUnknown {

  public:
    virtual HRESULT __stdcall Next(ULONG celt, LPVOID rgelt, ULONG *pceltFetched) = 0;
    virtual HRESULT __stdcall Skip(ULONG celt) = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(IEnumGeneric **ppenum) = 0;
};

//=--------------------------------------------------------------------------=
// StandardEnum
//=--------------------------------------------------------------------------=
// a generic enumerator object.  given a pointer to generic data, some
// information about the elements, and a function to copy the elements,
// we can implement a generic enumerator.
//
// NOTE: this class assumes that rgElements is HeapAlloc'd, and will free it
//       in it's destructor [although it IS valid for this to be NULL if there
//       are no elements to enumerate over.]
//
class CStandardEnum: public CUnknownObject, 
										 public IEnumGeneric {

public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IEnumVariant methods
    //
    STDMETHOD(Next)(unsigned long celt, void * rgvar, unsigned long * pceltFetched); 
    STDMETHOD(Skip)(unsigned long celt); 
    STDMETHOD(Reset)(); 
    STDMETHOD(Clone)(IEnumGeneric **ppEnumOut); 

	CStandardEnum();
    CStandardEnum(REFIID riid, int cElement, int cbElement, void *rgElements,
                 void (WINAPI * pfnCopyElement)(void *, const void *, DWORD));
    ~CStandardEnum();

private:
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

protected:
    IID m_iid;                        // type of enumerator that we are
    int m_cElements;                  // Total number of elements
    int m_cbElementSize;              // Size of each element
    int m_iCurrent;                   // Current position: 0 = front, m_cElt = end
    VOID * m_rgElements;              // Array of elements  
    CStandardEnum *m_pEnumClonedFrom; // If we were cloned, from whom?
    void  (WINAPI * m_pfnCopyElement)(void *, const void *, DWORD);
};



#define _STANDARDENUM_H_
#endif // _STANDARDENUM_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\vb5auto.inc ===
#=------------------------------------------------------------------------=
# vb5ctls.inc
#=------------------------------------------------------------------------=
# builds a control for the vb5 product.  adds a few pieces of functionality
# to the generic makectl.inc


#=------------------------------------------------------------------------=
# NOTE:
#
# variable definitions before the !include line, and new targets, etc,
# afterwards.
#
#=------------------------------------------------------------------------=

#=------------------------------------------------------------------------=
# variable definitions
#
!if "$(_SERVERFILENAME)"==""
_SERVERFILENAME=$(SERVERNAME).Dll
!endif

# Relative path to the INTL, satellite DLL build, directory
#
INTLPATH=.\.
VBLICPATH=..\..\VBLIC

IDHEADER=..\..\tools\idheader.bat
DEPFILE=..\..\tools\depfile.bat

!if "$(DEPFILEBLD)"!=""
ALLTARGETS=$(_SERVERBASENAME).DEP
!else
MORETARGETS=\
!	if "$(_NOID)" == ""
		Helpstrs.H \
!	endif
	$(MORETARGETS)
!if "$(ASDEBUG)"=="" && "$(ASICECAP)"==""
POSTTARGETS=Lego
!else
POSTTARGETS=
!endif
!endif

TLBTARGETS=\
!if "$(_NOID)" == ""
	HelpStrs.H \
!endif
!if "$(_NOODLFILE)"==""
	..\$(SERVERNAME).ODL
!endif

# licensing support
#
!if "$(ASDEBUG)"!=""
_LIBS=$(_LIBS) $(VBLICPATH)\debug\vblic.lib 
!elseif "$(ASICECAP)"!=""
_LIBS=$(_LIBS) $(VBLICPATH)\icecap\vblic.lib 
!else
_LIBS=$(_LIBS) $(VBLICPATH)\release\vblic.lib 
!endif

#=------------------------------------------------------------------------=
# extra compiler flags, etc.
#
!if "$(ASDEBUG)"!=""
#
# debug
#
_LFLAGS=$(_LFLAGS) -map:$(SERVERNAME).map
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
_CFLAGS = $(_CFLAGS) /QAieee
!endif

!else if "$(ASICECAP)"!=""
#
# icecap
#
_LFLAGS=$(_LFLAGS) -map:$(SERVERNAME).map

!else
#
# release
#
_LFLAGS=$(_LFLAGS) -debugtype:fixup,cv -debug:notmapped,full -debugtype:coff -map:$(SERVERNAME).map

!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
_CFLAGS = $(_CFLAGS) /QAl /QAieee
!endif
!endif

!if "$(_NOBASE)"==""
!if "$(ASDEBUG)"!=""
_LFLAGS=$(_LFLAGS) -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(SERVERNAME)_d
!else
_LFLAGS=$(_LFLAGS) -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(SERVERNAME)_r
!endif
!endif

#=------------------------------------------------------------------------=
# put all variable definitions before this, and new targets afterwards
#
!include "..\..\Include\MakeAuto.Inc"


#=------------------------------------------------------------------------=
# new targets
#

VBDep:\
!if "$(_NOID)" == ""
	HelpStrs.H \
!endif
	dep

# helpstr/id support
#
!if "$(_NOID)" == ""
HelpStrs.H : ..\$(SERVERNAME).ID
    echo Generating HelpIDs.H, HelpStrs.H and HelpStrs.RC
    $(IDHEADER) ..\$(SERVERNAME).id helpids.h helpstrs.h helpstrs.rc > nul
!endif

!if "$(SERVERNAME)"==""
!message _SERVERBASENAME not set
!endif
!if "$(_SERVEREXTENSION)"==""
!message _SERVEREXTENSION not set
!endif
!if "$(_LOCALEBASENAME)"==""
!message _LOCALEBASENAME not set
!endif

# Localized DLL build
#
!if "$(_NOID)" == ""
$(INTLPATH)\HelpStrs.RC : ..\$(SERVERNAME).ID
		echo Generating HelpStrs.RC
		$(IDHEADER) ..\$(SERVERNAME).id $(INTLPATH)\helpids.h $(INTLPATH)\helpstrs.h $(INTLPATH)\helpstrs.rc > nul
!endif

$(INTLPATH)\intl.res : $(INTLPATH)\intl.rc
	echo Compiling satellite DLL resources ...
# Special for msrdo20 build - this is a non-mfc server NOT built in the framework
!if "$(NONFRAMEWRKMAKE)"==""
	rc -dINTLBUILD $(INCPATH) -I$(FRAMEWRKDIR)\framewrk\. $(_RCFLAGS) -fo $(INTLPATH)\intl.res $(INTLPATH)\intl.rc
!else
	rc -dINTLBUILD $(INCPATH) $(_RCFLAGS) -fo $(INTLPATH)\intl.res $(INTLPATH)\intl.rc
!endif

$(INTLPATH)\intl.rbj : $(INTLPATH)\intl.res
!ifdef RISC_BLD
	cvtres -machine:$(PROCESSOR_ARCHITECTURE) -nologo -out:$(INTLPATH)\intl.rbj $(INTLPATH)\intl.res
!else
	cvtres -machine:ix86 -nologo -out:$(INTLPATH)\intl.rbj $(INTLPATH)\intl.res
!endif

!if "$(INTLBLD)"!=""
#
# Check for the .ID file.  Not all objects require an .ID file.
#
!	if exist(..\$(SERVERNAME).ID)
$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL : $(FRAMEWRKDIR)\dwinvers.h \
!if "$(_NOID)"==""
			$(INTLPATH)\helpstrs.rc \
!endif  
 $(INTLPATH)\intl.rbj
	echo Linking satellite DLL ...
	link -nologo -out:$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL -DLL -subsystem:windows,4.00 -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(SERVERNAME)_intl -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE) -noentry $(INTLPATH)\intl.rbj
!	else
$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL : $(INTLPATH)\intl.rbj
	echo Linking satellite DLL ...
	link -nologo -out:$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL -DLL -subsystem:windows,4.00 -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(SERVERNAME)_intl -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE) -noentry $(INTLPATH)\intl.rbj
!	endif

!endif

Lego:
!if "$(CTLS_LEGO)"=="YES"
  nmake -f $(THUNDER55)\common\instr.mak FILE_BASE=$(_SERVERBASENAME) FILE_EXTENSION=$(_SERVEREXTENSION) CMD_SCRIPT= BOOT_SYM=
!endif

# Dependency File Build
#
$(_SERVERBASENAME).DEP : $(_SERVERBASENAME).TPL $(VB55CTLS)\dwinvers.txt $(VB55CTLS)\dwinvers.h
	echo Generating Setup Wizard dependency file
	$(DEPFILE) $(_SERVERBASENAME).tpl $(_SERVERBASENAME).dep
	del $(_SERVERBASENAME).dep.suc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\vb5cbc.inc ===
#=------------------------------------------------------------------------=
# VB55CTLS.inc
#=------------------------------------------------------------------------=
# builds a control for the vb5 product.  adds a few pieces of functionality
# to the generic MakeCBC.inc


#=------------------------------------------------------------------------=
# NOTE:
#
# variable definitions before the !include line, and new targets, etc,
# afterwards.
#
#=------------------------------------------------------------------------=


#=------------------------------------------------------------------------=
# variable definitions
#
!if "$(_SERVERFILENAME)"==""
_SERVERFILENAME=$(DESIGNERNAME).Dll
!endif

!ifndef _BASEKEYNAME
_BASEKEYNAME=$(_LOCALEBASENAME)
!endif

# Relative path to the INTL, satellite DLL build, directory
#
INTLPATH=.\.
VBLICPATH=..\..\VBLIC

!if "$(TOOLS)"==""
TOOLS=TOOLS
!endif

!if "$(C32)"==""
C32=C32
!endif

IDHEADER=..\..\tools\idheader.bat
DEPFILE=..\..\tools\depfile.bat

!if "$(INTLBLD)"!=""
ALLTARGETS=$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL \
!elseif "$(DEPFILEBLD)"!=""
!if "$(RUNMODEDLL)"=="YES"
DEPFILEBASENAME=$(_RUNMODEBASENAME)
!else
DEPFILEBASENAME=$(_SERVERBASENAME)
!endif
ALLTARGETS=$(DEPFILEBASENAME).DEP
!else
ALLTARGETS=$(SPECIALTARGETS) $(VB55CTLS)\dwinvers.h Helpstrs.H  \
!if "$(RUNMODEDLL)"=="YES"
    $(_RUNMODESERVERNAME) \
!endif
    $(_SERVERFILENAME)  \
!if "$(ASDEBUG)"=="" && "$(ASICECAP)"==""
	   Lego
!endif
!endif

TLBTARGETS=HelpStrs.H ..\$(DESIGNERNAME).ODL
TLBRUNTARGETS=HelpStrs.H ..\$(RUNMODE).ODL

# licensing support
#
!if "$(ASDEBUG)"!=""
_LIBS=$(_LIBS) $(VBLICPATH)\debug\vblic.lib 
!elseif "$(ASICECAP)"!=""
_LIBS=$(_LIBS) $(VBLICPATH)\icecap\vblic.lib 
!else
_LIBS=$(_LIBS) $(VBLICPATH)\release\vblic.lib 
!endif

#=------------------------------------------------------------------------=
# extra compiler flags, etc.
#
!if "$(ASDEBUG)"!=""
#
# debug
#
_LFLAGS=$(_LFLAGS) -map:$(_SERVERBASENAME).map
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
_CFLAGS = $(_CFLAGS) /QAieee
!endif

!else if "$(ASICECAP)"!=""
#
# icecap
#
_LFLAGS=$(_LFLAGS) -map:$(_SERVERBASENAME).map

!else
#
# release
#
_LFLAGS=$(_LFLAGS) -debugtype:fixup,cv -debug:notmapped,full -debugtype:coff -map:$(_SERVERBASENAME).map
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
_CFLAGS = $(_CFLAGS) /QAl /QAieee
!endif
!endif

#=------------------------------------------------------------------------=
# put all variable definitions before this, and new targets afterwards
#
!include "..\..\Include\MakeCBC.Inc"


#=------------------------------------------------------------------------=
# new targets
#
VBDep: HelpStrs.H dep

#-----------------------------------------------------------------------
# Build dwinvers.h
#-----------------------------------------------------------------------
$(VB55CTLS)\dwinvers.h : $(VB55CTLS)\dwinvers.txt
  echo Building dwinvers.h
  $(MAKEVERS) > $(VB55CTLS)\dwinvers.h < $(VB55CTLS)\dwinvers.txt
  $(THUNDER55)\$(TOOLS)\bin\getver $(THUNDER55)\$(C32)\dll\vba6\vba6.dll VBA >> $(VB55CTLS)\dwinvers.h
  copy $(VB55CTLS)\dwinvers.h $(VB55CTLS)\framewrk

# helpstr/id support
#
HelpStrs.H : ..\$(DESIGNERNAME).ID
    echo Generating HelpIDs.H, HelpStrs.H and HelpStrs.RC
    $(IDHEADER) ..\$(DESIGNERNAME).id helpids.h helpstrs.h helpstrs.rc > nul

!if "$(_SERVERBASENAME)"==""
!message _SERVERBASENAME not set
!endif
!if "$(_SERVEREXTENSION)"==""
!message _SERVEREXTENSION not set
!endif
!if "$(_LOCALEBASENAME)"==""
!message _LOCALEBASENAME not set
!endif

# Localized DLL build
#
$(INTLPATH)\HelpStrs.RC : ..\$(DESIGNERNAME).ID
		echo Generating HelpStrs.RC
		$(IDHEADER) ..\$(DESIGNERNAME).id $(INTLPATH)\helpids.h $(INTLPATH)\helpstrs.h $(INTLPATH)\helpstrs.rc > nul

$(INTLPATH)\intl.res : $(INTLPATH)\intl.rc
	echo Compiling satellite DLL resources ...
	rc -dINTLBUILD -i..\. -i\. -i..\..\framewrk\. -i..\..\include\. $(_RCFLAGS) -fo $(INTLPATH)\intl.res $(INTLPATH)\intl.rc

$(INTLPATH)\intl.rbj : $(INTLPATH)\intl.res
!ifdef RISC_BLD 
	cvtres -machine:$(PROCESSOR_ARCHITECTURE) -nologo -out:$(INTLPATH)\intl.rbj $(INTLPATH)\intl.res
!else
	cvtres -machine:ix86 -nologo -out:$(INTLPATH)\intl.rbj $(INTLPATH)\intl.res
!endif

$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL : $(INTLPATH)\helpstrs.rc $(INTLPATH)\intl.rbj 
	echo Linking satellite DLL ...
	link -nologo -out:$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL -DLL -subsystem:windows,4.00 -base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(_BASEKEYNAME)_intl -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE) -noentry $(INTLPATH)\intl.rbj

Lego:
!if "$(CTLS_LEGO)"=="YES"
  nmake -f $(THUNDER55)\common\instr.mak FILE_BASE=$(_SERVERBASENAME) FILE_EXTENSION=$(_SERVEREXTENSION) CMD_SCRIPT= BOOT_SYM=
!endif

# Dependency File Build
#
$(DEPFILEBASENAME).DEP : $(DEPFILEBASENAME).TPL $(VB55CTLS)\dwinvers.txt $(VB55CTLS)\dwinvers.h
	echo Generating Setup Wizard dependency file
	$(DEPFILE) $(DEPFILEBASENAME).tpl $(DEPFILEBASENAME).dep
	del $(DEPFILEBASENAME).dep.suc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\vbdsc.h ===
/*****************************************************************************\
*                                                                             *
* vbdsc.h       DSC interfaces for OLE                                        *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1994, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _VBDSC_H_ )
#define _VBDSC_H_

// JeffG: Copied this section from olebind.h to get rid of compiler warnings
#if !defined( INITGUID )
// trevors: To build with vc5, we should not include olectlid.h anymore.  We
// should include olectl.h.  We check to see if we are compiling with vc5 or
// not and include the correct header file. 
#if _MSC_VER == 1100
#include <olectl.h>
#else
#include <olectlid.h>
#endif // _MSC_VER
#endif

DEFINE_GUID(IID_IVBDSC, 
        0x1ab42240, 0x8c70, 0x11ce, 0x94, 0x21, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

typedef interface IVBDSC FAR *LPVBDSC;


typedef enum _tagDSCERROR
  {
  DSCERR_BADDATAFIELD = 0
  }
DSCERROR;


//////////////////////////////////////////////////////////////////////////////
//
//  IVBDSC interface
//
//////////////////////////////////////////////////////////////////////////////

#undef INTERFACE
#define INTERFACE IVBDSC

DECLARE_INTERFACE_(IVBDSC, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IVBDSC methods
    //
    STDMETHOD(CancelUnload)(THIS_ BOOL FAR *pfCancel) PURE;
    STDMETHOD(Error)(THIS_ DWORD dwErr, BOOL FAR *pfShowError) PURE;
    STDMETHOD(CreateCursor)(THIS_ ICursor FAR * FAR *ppCursor) PURE;
};

#endif // !defined( _VBDSC_H_ )

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\util.h ===
//=--------------------------------------------------------------------------=
// Util.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains utilities that we will find useful.
//
#ifndef _UTIL_H_

#include "Globals.H"
#include "Macros.h"

//=--------------------------------------------------------------------------=
// Structs, Enums, Etc.
//=--------------------------------------------------------------------------=
typedef enum 
{
	VERSION_LESS_THAN=-1,
	VERSION_EQUAL=0,
	VERSION_GREATER_THAN=1,
	VERSION_NOT_EQUAL=2
} VERSIONRESULT;

//=--------------------------------------------------------------------------=
// Misc Helper Stuff
//=--------------------------------------------------------------------------=
//

HWND      GetParkingWindow(void);

HINSTANCE _stdcall GetResourceHandle(LCID lcid = 0);	// Optional LCID param
											            // If not used or zero, we use
											            // g_lcidLocale.

//=--------------------------------------------------------------------------=
// VERSION.DLL function pointers
//=--------------------------------------------------------------------------=
//
#define DLL_VERSION "VERSION.DLL"

#define FUNC_VERQUERYVALUE "VerQueryValueA"
#define FUNC_GETFILEVERSIONINFO "GetFileVersionInfoA"
#define FUNC_GETFILEVERSIONINFOSIZE "GetFileVersionInfoSizeA"

typedef DWORD (_stdcall * PGETFILEVERSIONINFOSIZE)(LPTSTR lptstrFilename, LPDWORD lpdwHandle);
typedef BOOL (_stdcall * PGETFILEVERSIONINFO)(LPTSTR lpststrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
typedef BOOL (_stdcall * PVERQUERYVALUE)(const LPVOID pBlock, LPTSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);

BOOL CallGetFileVersionInfoSize(LPTSTR lptstrFilename, LPDWORD lpdwHandle);
BOOL CallGetFileVersionInfo(LPTSTR lpststrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
BOOL CallVerQueryValue(const LPVOID pBlock, LPTSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);

BOOL _stdcall InitVersionFuncs();
VERSIONRESULT _stdcall  CompareDllVersion(const char * pszFilename, BOOL bCompareMajorVerOnly);
BOOL _stdcall GetVerInfo(const char * pszFilename, VS_FIXEDFILEINFO *pffi);

// an array of common OLE automation data types and their sizes [in bytes]
//
extern const BYTE g_rgcbDataTypeSize [];


//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=
// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL
//

// CAUTION: Be careful setting MAX_VERSION too high.  Changing this value
//          has serious performance implications.  This means that for
//          every control registered we may call RegOpenKeyEx MAX_VERSION-1 times
//          to find out if there is a version dependent ProgId.  Since major
//          version upgrades of components should be a infrequent occurance
//          this should be a reasonable limit for most components.
// PERF:    I ran ICECAP for the value below and this lead to RegOpenKeyEx to
//          count for 2.2% of unregistration time.  I tried 255 and RegOpenKeyEx
//          jumps to 44% of unregistration time.  This value has no impact on registration time.
//
#define MAX_VERSION     32      // The max number of version dependent ProgIds to look for
#define VERSION_DELTA   10      // Subtract this value from MAX_VERSION to obtain the threshold
                                // at which we'll throw an assert warning you that the version
                                // of your component is nearing or exceeding the versions 
                                // (MAX_VERSION) we support
#define GUID_STR_LEN    40

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : CtlHeapAlloc(g_hHeap, 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
        if (m_pBuf)
            *((unsigned short *)m_pBuf) = 0;
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) CtlHeapFree(g_hHeap, 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};


//=--------------------------------------------------------------------------=
// string helpers.
//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

// * 2 for DBCS handling in below length computation
//
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#define BSTRFROMRESID(x)   (BSTR)MakeWideStrFromResourceId(x, STR_BSTR)
#define OLESTRFROMRESID(x) (LPOLESTR)MakeWideStrFromResourceId(x, STR_OLESTR)
#define COPYOLESTR(x)      (LPOLESTR)MakeWideStrFromWide(x, STR_OLESTR)
#define COPYBSTR(x)        (BSTR)MakeWideStrFromWide(x, STR_BSTR) // Embedded NULLs not supported

inline BSTR DuplicateBSTR(BSTR bstr) { 
    return SysAllocStringLen(bstr, SysStringLen(bstr)); }

LPWSTR MakeWideStrFromAnsi(LPSTR, BYTE bType);
LPWSTR MakeWideStrFromResourceId(WORD, BYTE bType);
LPWSTR MakeWideStrFromWide(LPWSTR, BYTE bType);


// takes a GUID, and a pointer to a buffer, and places the string form of the
// GUID in said buffer.
//
int StringFromGuidA(REFIID, LPSTR);


//=--------------------------------------------------------------------------=
// registry helpers.
//
// takes some information about an Automation Object, and places all the
// relevant information about it in the registry.
//
BOOL RegSetMultipleValues(HKEY hkey, ...);
BOOL RegisterUnknownObject(LPCSTR pszObjectName, LPCSTR pszLabelName, REFCLSID riidObject, BOOL fAptThreadSafe);
BOOL RegisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, LPCSTR pszLabelName, long lObjVer, long lMajorVersion, long lMinorVersion, REFCLSID riidLibrary, REFCLSID riidObject, BOOL fAptThreadSafe);
BOOL RegisterControlObject(LPCSTR pszLibName, LPCSTR pszObjectName, LPCSTR pszLabelName, long lObjMajVer, long lObjMinVer, long lMajorVersion, long lMinorVersion, REFCLSID riidLibrary, REFCLSID riidObject, DWORD dwMiscStatus, WORD wToolboxBitmapId, BOOL fAptThreadSafe, BOOL fControl);
BOOL UnregisterUnknownObject(REFCLSID riidObject, BOOL *pfAllRemoved);
BOOL UnregisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidObject);
#define UnregisterControlObject UnregisterAutomationObject

BOOL UnregisterTypeLibrary(REFCLSID riidLibrary);

// Register/UnregisterUnknownObject helpers to help prevent us from blowing away specific keys
//
BOOL ExistInprocServer(HKEY hkCLSID, char *pszCLSID);
BOOL ExistImplementedCategories(REFCLSID riid);

// Finds out if there are other version dependent ProgIds for our component around
//
BOOL QueryOtherVersionProgIds(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, long *plFoundVersion, BOOL *pfFailure);

// Copies the contents of a version dependent ProgId to a version independent ProgId
//
BOOL CopyVersionDependentProgIdToIndependentProgId(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion);

// Copies a source key (including all sub-keys) to a destination key
//
BOOL CopyRegistrySection(HKEY hkSource, HKEY hkDest);

// deletes a key in the registr and all of it's subkeys
//
BOOL DeleteKeyAndSubKeys(HKEY hk, LPCSTR pszSubKey);

// Path of Windows\Help directory.
//
UINT GetHelpFilePath(char *pszPath, UINT cbPath);

// Helper function for registration
//
void _MakePath(LPSTR pszFull, const char * pszName, LPSTR pszOut);

// TypeLib helper functions
//
HRESULT GetTypeFlagsForGuid(ITypeLib *pTypeLib, REFGUID guidTypeInfo, WORD *pwFlags);

//=--------------------------------------------------------------------------=
// string helpers.
//
char * FileExtension(const char *pszFilename);

//=--------------------------------------------------------------------------=
// conversion helpers.
//
void        HiMetricToPixel(const SIZEL *pSizeInHiMetric, SIZEL *pSizeinPixels);
void        PixelToHiMetric(const SIZEL *pSizeInPixels, SIZEL *pSizeInHiMetric);


//=--------------------------------------------------------------------------=
// This is a version macro so that versioning can be done in text and binary
// streams.
//
#define VERSION(x,y) MAKELONG(y,x)

#define _UTIL_H_
#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\vb5ctls.inc ===
#=------------------------------------------------------------------------=
# VB55CTLS.inc
#=------------------------------------------------------------------------=
# builds a control for the vb5 product.  adds a few pieces of functionality
# to the generic makectl.inc


#=------------------------------------------------------------------------=
# NOTE:
#
# variable definitions before the !include line, and new targets, etc,
# afterwards.
#
#=------------------------------------------------------------------------=


#=------------------------------------------------------------------------=
# variable definitions
#
!if "$(_SERVERFILENAME)"==""
_SERVERFILENAME=$(CONTROLNAME).Ocx
!endif

# Relative path to the INTL, satellite DLL build, directory
#
INTLPATH=.\.
VBLICPATH=..\..\VBLIC

!if "$(TOOLS)"==""
TOOLS=TOOLS
!endif

!if "$(C32)"==""
C32=C32
!endif

IDHEADER=..\..\tools\idheader.bat
DEPFILE=..\..\tools\depfile.bat

#
# base address file
BASEFILE=$(DEVBINC)\vstudio\v6\dllbase.txt

!if "$(INTLBLD)"!=""
ALLTARGETS=dwinvers.h $(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL \
!elseif "$(DEPFILEBLD)"!=""
ALLTARGETS=$(_SERVERBASENAME).DEP
!else
ALLTARGETS=$(VB55CTLS)\dwinvers.h \
!if "$(_NOID)" == ""
	Helpstrs.H \
!endif
	$(_SERVERFILENAME)  \
!if "$(ASDEBUG)"=="" && "$(ASICECAP)"==""
	   Lego
!endif
!endif

TLBTARGETS= \
!if "$(_NOID)" == ""
	HelpStrs.H \
!endif
	..\$(CONTROLNAME).ODL

# licensing support
#
!if "$(ASDEBUG)"!=""
_LIBS=$(_LIBS) $(VBLICPATH)\debug\vblic.lib 
!elseif "$(ASICECAP)"!=""
_LIBS=$(_LIBS) $(VBLICPATH)\icecap\vblic.lib 
!else
_LIBS=$(_LIBS) $(VBLICPATH)\release\vblic.lib 
!endif

#=------------------------------------------------------------------------=
# extra compiler flags, etc.
#
!if "$(ASDEBUG)"!=""
#
# debug
#
_LFLAGS=$(_LFLAGS) -map:$(_SERVERBASENAME).map
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
_CFLAGS = $(_CFLAGS) /QAieee
!endif

!else if "$(ASICECAP)"!=""
#
# icecap
#
_LFLAGS=$(_LFLAGS) -map:$(_SERVERBASENAME).map

!else
#
# release
#
_LFLAGS=$(_LFLAGS) -debugtype:fixup,cv -debug:notmapped,full -debugtype:coff -map:$(_SERVERBASENAME).map
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
_CFLAGS = $(_CFLAGS) /QAl /QAieee
!endif
!endif

!if "$(_NOBASE)"==""
!if "$(_BASEADDRNAME)"==""
#default base address name is the name of the control
!if "$(ASDEBUG)"!=""
_LFLAGS=$(_LFLAGS) -base:@$(BASEFILE),$(CONTROLNAME)_d
!else
_LFLAGS=$(_LFLAGS) -base:@$(BASEFILE),$(CONTROLNAME)_r
!endif
!else
#using custom base address name
!if "$(ASDEBUG)"!=""
_LFLAGS=$(_LFLAGS) -base:@$(BASEFILE),$(_BASEADDRNAME)_d
!else
_LFLAGS=$(_LFLAGS) -base:@$(BASEFILE),$(_BASEADDRNAME)_r
!endif
!endif
!endif

#
# The CTLS_BROWSE environment variable turns on/off the compilation of a
# browse file.  Set CTLS_BROWSE to something and one will be generated.
!if "$(CTLS_BROWSE)"!=""
CFLAGS=$(CFLAGS) /FR
BSCMAKE=bscmake.exe
!endif

#=------------------------------------------------------------------------=
# put all variable definitions before this, and new targets afterwards
#
!include "..\..\Include\MakeCtl.Inc"


#=------------------------------------------------------------------------=
# new targets
#
VBDep: HelpStrs.H dep

#-----------------------------------------------------------------------
# Build dwinvers.h
#-----------------------------------------------------------------------
$(VB55CTLS)\dwinvers.h : $(VB55CTLS)\dwinvers.txt
  echo Building dwinvers.h
  $(MAKEVERS) > $(VB55CTLS)\dwinvers.h < $(VB55CTLS)\dwinvers.txt
  $(THUNDER55)\$(TOOLS)\bin\getver $(THUNDER55)\$(C32)\dll\vba6\vba6.dll VBA >> $(VB55CTLS)\dwinvers.h
  copy $(VB55CTLS)\dwinvers.h $(VB55CTLS)\framewrk

# helpstr/id support
#
!if "$(_NOID)" == ""
HelpStrs.H : ..\$(CONTROLNAME).ID
    echo Generating HelpIDs.H, HelpStrs.H and HelpStrs.RC
    $(IDHEADER) ..\$(CONTROLNAME).id helpids.h helpstrs.h helpstrs.rc > nul
!endif

!if "$(_SERVERBASENAME)"==""
!message _SERVERBASENAME not set
!endif
!if "$(_SERVEREXTENSION)"==""
!message _SERVEREXTENSION not set
!endif


!if "$(INTLBLD)"!=""
# Localized DLL build
#
!if "$(_LOCALEBASENAME)"==""
!message _LOCALEBASENAME not set
!endif

!if "$(_NOBASE)" == ""
!if "$(_INTLBASEADDRNAME)"==""
#default base address name to the name of the control
_LFLAGS_INTL=-base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(CONTROLNAME)_intl
!else
#using custom base address name
_LFLAGS_INTL=-base:@$(DEVBINC)\vstudio\v6\dllbase.txt,$(_INTLBASEADDRNAME)_intl
!endif
!endif

!if "$(_NOID)" == ""
$(INTLPATH)\HelpStrs.RC : ..\$(CONTROLNAME).ID
		echo Generating HelpStrs.RC
		$(IDHEADER) ..\$(CONTROLNAME).id $(INTLPATH)\helpids.h $(INTLPATH)\helpstrs.h $(INTLPATH)\helpstrs.rc > nul
!endif

$(INTLPATH)\intl.res : $(INTLPATH)\intl.rc
	echo Compiling satellite DLL resources ...
	rc -dINTLBUILD $(INCPATH) $(_RCFLAGS) -fo $(INTLPATH)\intl.res $(INTLPATH)\intl.rc

$(INTLPATH)\intl.rbj : $(INTLPATH)\intl.res
!ifdef RISC_BLD 
	cvtres -machine:$(PROCESSOR_ARCHITECTURE) -nologo -out:$(INTLPATH)\intl.rbj $(INTLPATH)\intl.res
!else
	cvtres -machine:ix86 -nologo -out:$(INTLPATH)\intl.rbj $(INTLPATH)\intl.res
!endif


$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL : \
!if	"$(_NOID)" == ""
	$(INTLPATH)\helpstrs.rc \
!endif
	$(INTLPATH)\intl.rbj 
	echo Linking satellite DLL ...
	link -nologo $(_LFLAGS_INTL) -out:$(INTLPATH)\$(_LOCALEBASENAME)xxx.DLL -DLL -subsystem:windows,4.00 -nodefaultlib -machine:$(PROCESSOR_ARCHITECTURE) -noentry $(INTLPATH)\intl.rbj

!endif	//INTLBLD

Lego:
!if "$(CTLS_LEGO)"=="YES" && "$(_SERVERBASENAME)"!="Crystl32"
  nmake -f $(THUNDER55)\common\instr.mak FILE_BASE=$(_SERVERBASENAME) FILE_EXTENSION=$(_SERVEREXTENSION) CMD_SCRIPT= BOOT_SYM=
!endif

# Dependency File Build
#
$(_SERVERBASENAME).DEP : $(_SERVERBASENAME).TPL $(VB55CTLS)\dwinvers.txt $(VB55CTLS)\dwinvers.h
	echo Generating Setup Wizard dependency file
	$(DEPFILE) $(_SERVERBASENAME).tpl $(_SERVERBASENAME).dep
	del $(_SERVERBASENAME).dep.suc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\unknown.h ===
//=--------------------------------------------------------------------------=
// Unknown.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// a class definition for an IUnknown super-class that will support
// aggregation.
//
#ifndef _UNKNOWN_H_

#include "Macros.H"

//=--------------------------------------------------------------------------=
// UNKNOWNOBJECTINFO
//
// if you want a simple co-creatable object, with no other guarantees about
// it, then you need to put the following entry in the global table of objects.
// other object types that are more complex, such as automation objects, and
// controls, will also use this information...
//
typedef struct {

    const CLSID *rclsid;                    // CLSID of your object.      ONLY USE IF YOU'RE CoCreatable!
    LPCSTR       pszObjectName;             // Name of your object.       ONLY USE IF YOU'RE CoCreatable!
    LPCSTR	 pszLabelName;		    // Registry display name      ONLY USE IF YOU'RE CoCreatable!
					    // for your object
    BOOL	 fApptThreadSafe;
    IUnknown    *(*pfnCreate)(IUnknown *);  // pointer to creation fn.    ONLY USE IF YOU'RE CoCreatable!
    HRESULT      (*pfnPreCreate)(void);     // pointer to pre-create fn.

} UNKNOWNOBJECTINFO;

#define NAMEOFOBJECT(index)       (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszObjectName)
#define LABELOFOBJECT(index)	  (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszLabelName)


#define CLSIDOFOBJECT(index)      (*(((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->rclsid))
#define CREATEFNOFOBJECT(index)   (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pfnCreate)
#define ISAPARTMENTMODELTHREADED(index)  (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fApptThreadSafe)

#define PRECREATEFNOFOBJECT(index) (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pfnPreCreate)

#ifndef INITOBJECTS

#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \
extern UNKNOWNOBJECTINFO name##Object \

#define DEFINE_UNKNOWNOBJECT2(name, clsid, objname, lblname, fn, fthreadsafe) \
extern UNKNOWNOBJECTINFO name##Object \

#define DEFINE_UNKNOWNOBJECT3(name, clsid, objname, lblname, precreatefn, fn, fthreadsafe) \
extern UNKNOWNOBJECTINFO name##Object \

#else
#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \
    UNKNOWNOBJECTINFO name##Object = { clsid, objname, NULL, TRUE, fn, NULL } \

#define DEFINE_UNKNOWNOBJECT2(name, clsid, objname, lblname, fn, fthreadsafe) \
    UNKNOWNOBJECTINFO name##Object = { clsid, objname, lblname, fthreadsafe, fn, NULL } \

#define DEFINE_UNKNOWNOBJECT3(name, clsid, objname, lblname, precreatefn, fn, fthreadsafe) \
    UNKNOWNOBJECTINFO name##Object = { clsid, objname, lblname, fthreadsafe, fn, precreatefn } \

#endif // INITOBJECTS


//=--------------------------------------------------------------------------=
// DECLARE_STANDARD_UNKNOWN
//
// All objects that are going to inherit from CUnknown for their IUnknown
// implementation should put this in their class declaration instead of the
// three IUnknown methods.
//
#define DECLARE_STANDARD_UNKNOWN() \
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut) { \
        return ExternalQueryInterface(riid, ppvObjOut); \
    } \
    STDMETHOD_(ULONG, AddRef)(void) { \
        return ExternalAddRef(); \
    } \
    STDMETHOD_(ULONG, Release)(void) { \
        return ExternalRelease(); \
    } \

// global variable where we store the current lock count on our DLL.  This resides
// in InProcServer.Cpp
//
extern LONG g_cLocks;



//=--------------------------------------------------------------------------=
// this class doesn't inherit from IUnknown since people inheriting from it
// are going to do so, and just delegate their IUnknown calls to the External*
// member functions on this object.  the internal private unknown object does
// need to inherit from IUnknown, since it will be used directly as an IUnknown
// object.
//
class CUnknownObject : public CtlNewDelete {

  public:
    CUnknownObject(IUnknown *pUnkOuter, void *pvInterface)
        : m_pvInterface(pvInterface),
          m_pUnkOuter((pUnkOuter) ? pUnkOuter : &m_UnkPrivate)
        {  InterlockedIncrement(&g_cLocks); }

    virtual ~CUnknownObject() { InterlockedDecrement(&g_cLocks); }

    // these are all protected so that classes that inherit from this can
    // at get at them.
    //
  protected:
    // IUnknown methods.  these just delegate to the controlling
    // unknown.
    //
    HRESULT ExternalQueryInterface(REFIID riid, void **ppvObjOut) {
        return m_pUnkOuter->QueryInterface(riid, ppvObjOut);
    }
    virtual ULONG ExternalAddRef(void) {
        return m_pUnkOuter->AddRef();
    }
    virtual ULONG ExternalRelease(void) {
        return m_pUnkOuter->Release();
    }

    // people should use this during creation to return their private
    // unknown
    //
    inline IUnknown *PrivateUnknown (void) {
        return &m_UnkPrivate;
    }

    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);
    virtual void    BeforeDestroyObject(void);

    IUnknown *m_pUnkOuter;            // outer controlling Unknown
    void     *m_pvInterface;          // the real interface we're working with.

  private:
    // the inner, private unknown implementation is for the aggregator
    // to control the lifetime of this object, and for those cases where
    // this object isn't aggregated.
    //
    class CPrivateUnknownObject : public IUnknown {
      public:
        STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // constructor is remarkably trivial
        //
        CPrivateUnknownObject() : m_cRef(1) {}

      private:
        CUnknownObject *m_pMainUnknown();
        ULONG m_cRef;
    } m_UnkPrivate;

    // so they can reference themselves in CUnknownObject from pMainUnknown()
    //
    friend class CPrivateUnknownObject;

    // by overriding this, people inheriting from this unknown can implement
    // additional interfaces.  declared as private here so they have to use their
    // own version.
    //
};




#define _UNKNOWN_H_
#endif // _UNKNOWN_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\vc5warn.h ===
//=--------------------------------------------------------------------------=
// VC5Warn.h
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// disables several VC5 warnings that trip framewrk definitions
//

// warning C4291: no matching operator delete found; memory will not be
// freed if initialization throws an exception. This happens on Alpha builds
// because class CtlNewDelete in macros.h does not define a matching delete
// operator.

#if defined(ALPHA)
#pragma warning(disable:4291)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\vbochost.h ===
//---------------------------------------------------------------------------
// VBOCHOST.H
//---------------------------------------------------------------------------
// Copyright (c) 1991-1995, Microsoft Corp.  All Rights Reserved.
//---------------------------------------------------------------------------
// Include file for the OLE Custom Controls Visual Basic
// programming interface.
//---------------------------------------------------------------------------

#if !defined (_VBOCHOST_H_)
#define _VBOCHOST_H_
        
DEFINE_GUID(IID_IVBGetControl, 0x40A050A0L, 0x3C31, 0x101B, 0xA8, 0x2E, 0x08, 0x00, 0x2B, 0x2B, 0x23, 0x37);
DEFINE_GUID(IID_IGetOleObject, 0x8A701DA0L, 0x4FEB, 0x101B, 0xA8, 0x2E, 0x08, 0x00, 0x2B, 0x2B, 0x23, 0x37);

//---------------------------------------------------------------------------
// IVBGetControl
//---------------------------------------------------------------------------

// Constants for dwWhich parameter:
#define GC_WCH_SIBLING	    0x00000001L
#define GC_WCH_CONTAINER    0x00000002L   // no FONLYNEXT/PREV
#define GC_WCH_CONTAINED    0x00000003L   // no FONLYNEXT/PREV
#define GC_WCH_ALL	    0x00000004L
#define GC_WCH_FREVERSEDIR  0x08000000L   // OR'd with others
#define GC_WCH_FONLYNEXT    0x10000000L   // OR'd with others
#define GC_WCH_FONLYPREV    0x20000000L   // OR'd with others
#define GC_WCH_FSELECTED    0x40000000L   // OR'd with others

DECLARE_INTERFACE_(IVBGetControl, IUnknown)
    {
    // *** IUnknown methods ****
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IVBGetControl methods ****
    STDMETHOD(EnumControls)(THIS_ DWORD dwOleContF, DWORD dwWhich, 
                            LPENUMUNKNOWN FAR *ppenumUnk) PURE;
    };

//---------------------------------------------------------------------------
// IGetOleObject
//---------------------------------------------------------------------------
DECLARE_INTERFACE_(IGetOleObject, IUnknown)
    {
    // *** IUnknown methods ****
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IGetOleObject methods ****
    STDMETHOD(GetOleObject)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    };

#endif  // !defined (_VBOCHOST_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\vshelp.h ===
//=--------------------------------------------------------------------------=
// HtmlHlp.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// Contains HtmlHelp helper functions
//
#ifndef _HTMLHELP_H_
#define _HTMLHELP_H_

#ifdef VS_HELP

    #include "HelpInit.H"
    #include "HelpSys.H"
    #include "HelpSvcs.h"
    
    //=--------------------------------------------------------------------------=
    // HtmlHelp helpers
    //
    HRESULT VisualStudioShowHelpTopic(const char *pszHelpFile, DWORD dwContextId, BOOL *pbHelpStarted);
    HRESULT QueryStartupVisualStudioHelp(IVsHelpSystem **ppIVsHelpSystem);

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\vc41warn.h ===
//=--------------------------------------------------------------------------=
// VC41Warn.h
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// disables several new VC4.1 warnings that trip standard headers
//

// VC4.1 warning about bool
#pragma warning(disable:4237)

// VC4.1 warning - anachronism used
#pragma warning(disable:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\wbclsser.h ===
//=--------------------------------------------------------------------------=
// wbclsser.h
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// API for WebClass Designer Serialization
//
// adolfoc 7/29/97
//			Renamed WCS_NODE_TYPE_URL to WCS_NODE_TYPE_PAGE,
//			added WCS_NODE_TYPE_URL with value 3,
//			changed URL tag to Page
// 
#ifndef _WBCLSSER_H_

#include "csfdebug.h"
#include "convman_tlb.h"

// Designer State Flags
#define RUNSTATE_COMPILED          0x00000000
#define RUNSTATE_F5                0x00000001

#define DISPID_OBJECT_PROPERTY_START 	0x00000500

// Serialization Versions
// 0.0      Beta1
// 0.1      PreBeta2   -   WebItems must be sorted on load
// 0.2      PreBeta2   -   Added Optimize member var to WebItems
// 0.3      PreBeta2   -   WebEvents are now sorted on load too
// 0.4      PreBeta2   - 
// 0.5      PreBeta2   -   Tagattributes added anonymous tag number
// 0.6		<skipped>
// 0.7      PreRC1	   -   Added URLInName to design time state
// 0.8      PreRC1	   -   Fixed bug in WebItem and event sorting algorithm. Now we need
//						   to fixup old projects with bug whose WebItems and events are not
//						   serialized in alphabetical order.

// structure of WebClass on disk
const DWORD dwExpectedVerMajor = 0;
const DWORD dwExpectedVerMinor = 8; 

class CRunWebItemState;
class CRunEventState;

class CStateBase
{
public:
	CStateBase() {}
	~CStateBase() {}

public:
	//////////////////////////////////////////////////////////////////////
	//
	// inline ReadStrings(IStream *pStream, ULONG acbStrings[],
	//                    BSTR *apbstrStrings[], int cStrings)
	//                    
	//
	//
	//////////////////////////////////////////////////////////////////////

	inline ReadStrings(IStream *pStream, ULONG acbStrings[],
					   BSTR *apbstrStrings[], int cStrings)
	{
		HRESULT hr = S_OK;
		ULONG cbRead = 0;
        char *pszReadBuf = NULL;
        ULONG cbLongest = 0;
        int i = 0;

        while (i < cStrings)
        {
            if (acbStrings[i] > cbLongest)
            {
                cbLongest = acbStrings[i];
            }
            i++;
        }
        if (0 != cbLongest)
        {
            pszReadBuf = new char[cbLongest + sizeof(WCHAR)];
            CSF_CHECK(NULL != pszReadBuf, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);
        }
        i = 0;
		while (i < cStrings)
		{
            if (0 == acbStrings[i])
            {
                *(apbstrStrings[i]) = NULL;
            }
            else
            {
                hr = pStream->Read(pszReadBuf, acbStrings[i], &cbRead);
                CSF_CHECK(hr == S_OK, hr, CSF_TRACE_EXTERNAL_ERRORS);
                CSF_CHECK(cbRead == acbStrings[i], STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);
                *((WCHAR *)&pszReadBuf[acbStrings[i]]) = L'\0';

                *(apbstrStrings[i]) = ::SysAllocString((WCHAR *)pszReadBuf);
                CSF_CHECK(*(apbstrStrings[i]) != NULL, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);
            }
			i++;
		}

	CLEANUP:
        if (NULL != pszReadBuf)
        {
            delete [] pszReadBuf;
        }
		return hr;
	}

	//////////////////////////////////////////////////////////////////////
	//
	// inline WriteStrings(IStream *pStream, ULONG acbStrings[],
	//                     BSTR *apbstrStrings[], int cStrings)
	//
	//
	//////////////////////////////////////////////////////////////////////


	inline WriteStrings(IStream *pStream, ULONG acbStrings[],
						BSTR abstrStrings[], int cStrings)
	{
		HRESULT hr = S_OK;
		ULONG cbWritten = 0;
		int i = 0;

		while (i < cStrings)
		{
            if (NULL != abstrStrings[i])
            {
                hr = pStream->Write(abstrStrings[i], acbStrings[i], &cbWritten);
                CSF_CHECK(hr == S_OK, hr, CSF_TRACE_EXTERNAL_ERRORS);
                CSF_CHECK(cbWritten == acbStrings[i], STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);
            }
			i++;
		}

	CLEANUP:
		return hr;
	}

};

class CRunWebClassState : public CStateBase
{
public:
	CRunWebClassState()
	{
		m_dwVerMajor = dwExpectedVerMajor;
		m_dwVerMinor = dwExpectedVerMinor;
		m_bstrName = NULL;		// Kill
		m_bstrProgID = NULL;	// Runtime only
		m_StateManagementType = wcNoState;
		m_bstrASPName = NULL;	
		m_bstrAppendedParams = NULL;	
		m_bstrStartupItem = NULL;	
		m_DIID_WebClass = GUID_NULL;
		m_DIID_WebClassEvents = GUID_NULL;
		m_dwTICookie = 0;	
		m_dwFlags = 0;
		m_rgWebItemsState = 0;
		m_dwWebItemCount = 0;
	}

	~CRunWebClassState()
	{
		if(m_bstrName != NULL)
			::SysFreeString(m_bstrName);

		if(m_bstrProgID != NULL)
			::SysFreeString(m_bstrProgID);

		if(m_bstrASPName != NULL)
			::SysFreeString(m_bstrASPName);

        if(m_bstrAppendedParams != NULL)
            ::SysFreeString(m_bstrAppendedParams);

        if(m_bstrStartupItem != NULL)
            ::SysFreeString(m_bstrStartupItem);
	}

public:
	DWORD				m_dwVerMajor;            // major version number
	DWORD				m_dwVerMinor;            // minor version number
	BSTR				m_bstrName;             // WebClass name
	BSTR				m_bstrProgID;           // WebClass progid
	StateManagement		m_StateManagementType;  // state management type
	BSTR				m_bstrASPName;          // name of ASP file
	IID					m_DIID_WebClass;        // IID of WebClass' main IDispatch
	IID					m_DIID_WebClassEvents;  // IID of WebClass' events IDispatch
	DWORD				m_dwTICookie;           // typeinfo cookie
    BSTR                m_bstrAppendedParams;   // URL state
    BSTR                m_bstrStartupItem;      // f5 statup Item
	DWORD				m_dwFlags;
	CRunWebItemState*	m_rgWebItemsState;
	DWORD				m_dwWebItemCount;		// runtime node types

public:
	HRESULT Load(LPSTREAM pStm)
	{
		HRESULT hr = S_OK;
		ULONG cbRead = 0;
		ULONG acbStrings[5];
		BSTR *apbstrStrings[5];

		// read structure from stream

		hr = pStm->Read(this, sizeof(CRunWebClassState), &cbRead);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(CRunWebClassState) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

		// TODO: need error codes for version incompatibility, handle backlevel formats etc.

//		CSF_CHECK(dwExpectedVerMajor == m_dwVerMajor, STG_E_OLDFORMAT, CSF_TRACE_EXTERNAL_ERRORS);
//		CSF_CHECK(dwExpectedVerMinor == m_dwVerMinor, STG_E_OLDFORMAT, CSF_TRACE_EXTERNAL_ERRORS);

		// read string lengths from stream

		hr = pStm->Read(acbStrings, sizeof(acbStrings), &cbRead);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(acbStrings) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

		// set up array of string pointer addresses

		apbstrStrings[0] = &(m_bstrName);
		apbstrStrings[1] = &(m_bstrProgID);
		apbstrStrings[2] = &(m_bstrASPName);
		apbstrStrings[3] = &(m_bstrAppendedParams);
		apbstrStrings[4] = &(m_bstrStartupItem);

		// read strings from stream

		hr = ReadStrings(pStm, acbStrings, apbstrStrings,
					   (sizeof(acbStrings) / sizeof(acbStrings[0])) );

	CLEANUP:
		return hr;
	}

	HRESULT Save(LPSTREAM pStm)
	{
		HRESULT hr = S_OK;
		ULONG cbWritten = 0;
		ULONG acbStrings[5];
        ::ZeroMemory(acbStrings, sizeof(acbStrings));
		BSTR abstrStrings[5];

		// write WebClass structure to stream

		hr = pStm->Write(this, sizeof(CRunWebClassState), &cbWritten);
		CSF_CHECK(hr == S_OK, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(cbWritten == sizeof(CRunWebClassState), STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

		// get lengths of strings and write them to stream

        if (NULL != m_bstrName)
        {
            acbStrings[0] = ::SysStringByteLen(m_bstrName);
        }
        if (NULL != m_bstrProgID)
        {
            acbStrings[1] = ::SysStringByteLen(m_bstrProgID);
        }
        if (NULL != m_bstrASPName)
        {
            acbStrings[2] = ::SysStringByteLen(m_bstrASPName);
        }
        if (NULL != m_bstrAppendedParams)
        {
            acbStrings[3] = ::SysStringByteLen(m_bstrAppendedParams);
        }
        if (NULL != m_bstrStartupItem)
        {
            acbStrings[4] = ::SysStringByteLen(m_bstrStartupItem);
        }

		hr = pStm->Write(acbStrings, sizeof(acbStrings), &cbWritten);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(cbWritten == sizeof(acbStrings), STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

		// set up array of pointers to strings to be written to stream

		abstrStrings[0] = m_bstrName;
		abstrStrings[1] = m_bstrProgID;
		abstrStrings[2] = m_bstrASPName;
		abstrStrings[3] = m_bstrAppendedParams;
		abstrStrings[4] = m_bstrStartupItem;

		// write strings to stream

		hr = WriteStrings(pStm, acbStrings, abstrStrings,
						(sizeof(acbStrings) / sizeof(acbStrings[0])) );

	CLEANUP:
		return hr;
	}
};

typedef struct tagWCS_NODEHEADER
{
	BYTE bType;                   // node type: nested WebClass, URL, events
} WCS_NODEHEADER;

// WCS_DTNODE_TYPE_URL_BOUND_TAG is a special case because WCS_DTNODE.dispid
// contains the dispid of the referenced URL and WCS_DTNODE.bstrName contains
// the name of the referenced URL.

// structure of node on disk at runtime

class CRunWebItemState : protected CStateBase
{
public:
	CRunWebItemState()
	{
		m_dwVerMajor = dwExpectedVerMajor;
		m_dwVerMinor = dwExpectedVerMinor;
		m_dispid = -1;
		m_bstrName = NULL;
		m_bstrTemplate = NULL;
		m_bstrToken = NULL;
		m_IID_Events = GUID_NULL;
		m_fParseReplacements = FALSE;
		m_bstrAppendedParams = NULL;
    	m_fUsesRelativePath = FALSE;
		m_dwTokenInfo = 0;
		m_dwReserved2 = 0;
		m_dwReserved3 = 0;
		m_rgEvents = 0;
		m_dwEventCount = 0;
	}

	~CRunWebItemState()
	{
		if(m_bstrName != NULL)
			::SysFreeString(m_bstrName);

		if(m_bstrTemplate != NULL)
			::SysFreeString(m_bstrTemplate);

		if(m_bstrToken != NULL)
			::SysFreeString(m_bstrToken);

		if(m_bstrAppendedParams != NULL)
			::SysFreeString(m_bstrAppendedParams);
	}

public:
	HRESULT Load(LPSTREAM pStm)
	{
		HRESULT hr = S_OK;
		ULONG cbRead = 0;
		ULONG acbStrings[4];
		BSTR *apbstrStrings[4];
		int cStrings = 4;

		// read structure from stream

		hr = pStm->Read(this, sizeof(CRunWebItemState), &cbRead);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(CRunWebItemState) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

	//	m_pvData = NULL; // don't take junk pointer value from stream

		// set up array of string pointer addresses according to node type

		apbstrStrings[0] = &m_bstrName;
		apbstrStrings[1] = &m_bstrTemplate;
		apbstrStrings[2] = &m_bstrToken;
		apbstrStrings[3] = &m_bstrAppendedParams;

		// read string lengths from stream

		hr = pStm->Read(acbStrings, sizeof(acbStrings), &cbRead);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(acbStrings) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

		// read strings from stream

		hr = ReadStrings(pStm, acbStrings, apbstrStrings, cStrings);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_INTERNAL_ERRORS);

	CLEANUP:
		return hr;
	}

	HRESULT Save
	(
		LPSTREAM pStm
	)
	{
		HRESULT hr = S_OK;
		ULONG cbWritten = 0;
		ULONG acbStrings[4];
        ::ZeroMemory(acbStrings, sizeof(acbStrings));
		BSTR abstrStrings[4];
		int cStrings = 4;

		// write node structure to stream

		hr = pStm->Write(this, sizeof(CRunWebItemState), &cbWritten);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(CRunWebItemState) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

		// set up array of strings to be written to stream and
		// determine how many there will be

		abstrStrings[0] = m_bstrName;
        if (NULL != m_bstrName)
        {
            acbStrings[0] = ::SysStringByteLen(m_bstrName);
        }

		abstrStrings[1] = m_bstrTemplate;
        if (NULL != m_bstrTemplate)
        {
            acbStrings[1] = ::SysStringByteLen(m_bstrTemplate);
        }
		abstrStrings[2] = m_bstrToken;
        if (NULL != m_bstrToken)
        {
            acbStrings[2] = ::SysStringByteLen(m_bstrToken);
        }
		abstrStrings[3] = m_bstrAppendedParams;
        if (NULL != m_bstrAppendedParams)
        {
            acbStrings[3] = ::SysStringByteLen(m_bstrAppendedParams);
        }

		// write string lengths to stream

		hr = pStm->Write(acbStrings, sizeof(acbStrings), &cbWritten);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(acbStrings) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

		// write strings to stream

		hr = WriteStrings(pStm, acbStrings, abstrStrings, cStrings);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_INTERNAL_ERRORS);

	CLEANUP:
		return hr;
	}

public:
    DWORD m_dwVerMajor;
	DWORD m_dwVerMinor;
	// common properties
	DISPID m_dispid;                // dispid of node
	BSTR m_bstrName;                // name of node

	// url properties
	BSTR m_bstrTemplate;            // url's HTML template name
	BSTR m_bstrToken;               // url's token for replacement events
	IID m_IID_Events;               // IID of url's dynamic events interface
	BOOL m_fParseReplacements;      // TRUE=parse replacement recursively
	BSTR m_bstrAppendedParams;		// Appended params
    BOOL m_fUsesRelativePath;        // Specifies whether the runtime should load
                                    // templates relative to the ASP's actual path

	DWORD m_dwTokenInfo;
	DWORD m_dwReserved2;
	DWORD m_dwReserved3;
	CRunEventState* m_rgEvents;
	DWORD m_dwEventCount;
};

// design time node types

#define WCS_NODE_TYPE_RESOURCE            (BYTE)10
//#define WCS_DTNODE_TYPE_UNBOUND_TAG     (BYTE)12
//#define WCS_DTNODE_TYPE_NESTED_WEBCLASS (BYTE)15  

//#define WCS_DTNODE_TYPE_CUSTOM_EVENT    (BYTE)11
//#define WCS_DTNODE_TYPE_URL_BOUND_TAG   (BYTE)13
//#define WCS_DTNODE_TYPE_EVENT_BOUND_TAG (BYTE)14

class CRunEventState : public CStateBase
{
public:
	enum EventTypes
	{
		typeCustomEvent,
		typeURLBoundTag,
		typeEventBoundTag,
		typeUnboundTag,
	};

	CRunEventState()
	{
		m_dwVerMajor = 0;
		m_dwVerMinor = 0;
		m_type = wcCustom;
		m_dispid = -1;
		m_bstrName = NULL;
		m_bstrOriginalHref = NULL;
	}

	~CRunEventState()
	{
		if(m_bstrName != NULL)
			::SysFreeString(m_bstrName);

		if(m_bstrOriginalHref != NULL)
			::SysFreeString(m_bstrOriginalHref);
	}

public:
	inline BOOL IsDTEvent()
	{
		return ( (m_type == EventTypes::typeCustomEvent)  ||
			   (m_type == EventTypes::typeUnboundTag)   ||
			   (m_type == EventTypes::typeURLBoundTag) ||
			   (m_type == EventTypes::typeEventBoundTag)
			 );
	}
	
	HRESULT Load(LPSTREAM pStm)
	{
		HRESULT hr = S_OK;
		ULONG cbRead = 0;
		ULONG acbStrings[2];
		BSTR *apbstrStrings[2];
		int cStrings = 2;

		// TODO: Mopve this into state funcs..
		hr = pStm->Read(this, sizeof(CRunEventState), &cbRead);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);

		// read design time string lengths from stream

		hr = pStm->Read(acbStrings, sizeof(acbStrings), &cbRead);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(acbStrings) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

		// now check if there are any strings to read
		// if yes then set up array of string pointer addresses

		apbstrStrings[0] = &m_bstrName;
		apbstrStrings[1] = &m_bstrOriginalHref;

		hr = ReadStrings(pStm, acbStrings, apbstrStrings, 2);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_INTERNAL_ERRORS);

	CLEANUP:
		return hr;
	}

	HRESULT Save(LPSTREAM pStm)
	{
		HRESULT hr = S_OK;
		ULONG cbWritten = 0;
		ULONG acbStrings[2];
        ::ZeroMemory(acbStrings, sizeof(acbStrings));
		BSTR abstrStrings[2];
		int cStrings = 2;

		// set version numbers in node

		hr = pStm->Write(this, sizeof(CRunEventState), &cbWritten);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(CRunEventState) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

		// set up array of strings to be written to stream and
		// determine how many there will be

        if (NULL != m_bstrName)
        {
            acbStrings[0] = ::SysStringByteLen(m_bstrName);
        }
        if (NULL != m_bstrOriginalHref)
        {
            acbStrings[1] = ::SysStringByteLen(m_bstrOriginalHref);
        }

		abstrStrings[0] = m_bstrName;
		abstrStrings[1] = m_bstrOriginalHref;

		// write string lengths to stream

		hr = pStm->Write(acbStrings, sizeof(acbStrings), &cbWritten);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
		CSF_CHECK(sizeof(acbStrings) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

		// write strings to stream

		hr = WriteStrings(pStm, acbStrings, abstrStrings, cStrings);
		CSF_CHECK(S_OK == hr, hr, CSF_TRACE_INTERNAL_ERRORS);

	CLEANUP:
		return hr;
	}

	inline DISPID GetDISPIDDirect() { return m_dispid; }
	inline BSTR GetNameDirect() {return m_bstrName; }

public:
	DWORD m_dwVerMajor;
	DWORD m_dwVerMinor;
	WebClassEventTypes  m_type;               // node type: nested WebClass, URL, events
	DISPID		m_dispid;             // dispid of node
	BSTR		m_bstrName;           // name of node
	BSTR		m_bstrOriginalHref;
};


class CRunWebClassStateHeader
{
public:
	CRunWebClassStateHeader()
	{
		m_pWebClassState = NULL;
		m_cbWebClassState = 0;
		m_dwWebItemCount = 0;
	}

	~CRunWebClassStateHeader(){}

public:
	CRunWebClassState*	m_pWebClassState;
	DWORD				m_cbWebClassState;
	DWORD				m_dwWebItemCount;
};

//////////////////////////////////////////////////////////////////////
//
// File Format:
//
// WCS_WEBCLASS structure
// length of WCS_WEBCLASS.bstrName
// length of WCS_WEBCLASS.bstrCatastropheURL
// length of WCS_WEBCLASS.bstrVirtualDirectory
// WCS_WEBCLASS.bstrName
// WCS_WEBCLASS.bstrCatastropheURL
// WCS_WEBCLASS.bstrVirtualDirectory
//
// WCS_WEBCLASS.cNodes instances of
// +-------------------------------
// | WCS_NODE structure
// | length of WCS_NODE.bstrName
// | lengths of other node specific strings
// | WCS_NODE.bstrName
// | other node specific strings
// +-------------------------------
//
//////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////
//
// inline void WCS_FreeWebClass(WCS_WEBCLASS *pClass)
//
// Frees all embedded BSTRs and invokes delete on structure
// 
//////////////////////////////////////////////////////////////////////
/*
inline void WCS_FreeWebClass(WCS_WEBCLASS *pClass)
{
  if (pClass->bstrName != NULL)
  {
    ::SysFreeString(pClass->bstrName);
  }
  if (pClass->bstrProgID != NULL)
  {
    ::SysFreeString(pClass->bstrProgID);
  }
  if (pClass->bstrCatastropheURL != NULL)
  {
    ::SysFreeString(pClass->bstrCatastropheURL);
  }
  if (pClass->bstrVirtualDirectory != NULL)
  {
    ::SysFreeString(pClass->bstrVirtualDirectory);
  }
  if (pClass->bstrFirstURL != NULL)
  {
    ::SysFreeString(pClass->bstrFirstURL);
  }
  if (pClass->bstrASPName != NULL)
  {
    ::SysFreeString(pClass->bstrASPName);
  }
  delete pClass;
}
*/
//////////////////////////////////////////////////////////////////////
//
// inline void WCS_FreeNode(WCS_NODE *pNode)
//
// Frees all embedded BSTRs and invokes delete on structure
//
//////////////////////////////////////////////////////////////////////
/*
inline void WCS_FreeNode(WCS_NODE *pNode)
{
  if (pNode->bstrName != NULL)
  {
    ::SysFreeString(pNode->bstrName);
  }
  if (WCS_NODE_TYPE_NESTED_WEBCLASS == pNode->bType)
  {
    if (pNode->bstrProgID != NULL)
    {
      ::SysFreeString(pNode->bstrProgID);
    }
  }
  else if ( (WCS_NODE_TYPE_PAGE == pNode->bType) ||
            (WCS_DTNODE_TYPE_PAGE == pNode->bType) )
  {
    if (pNode->bstrTemplate != NULL)
    {
      ::SysFreeString(pNode->Page.bstrTemplate);
    }
    if (pNode->Page.bstrToken != NULL)
    {
      ::SysFreeString(pNode->Page.bstrToken);
    }
    if (pNode->Page.bstrAppendedParams != NULL)
    {
      ::SysFreeString(pNode->Page.bstrAppendedParams);
    }
  }
  delete pNode;
}

//////////////////////////////////////////////////////////////////////
//
// inline void WCS_FreeDTNode(WCS_NODE *pNode)
//
// Frees all embedded BSTRs and invokes delete on structure
//
//////////////////////////////////////////////////////////////////////

inline void WCS_FreeDTNode(WCS_DTNODE *pNode)
{
  if ( (WCS_DTNODE_TYPE_URL_BOUND_TAG == pNode->bType) ||
       (WCS_DTNODE_TYPE_EVENT_BOUND_TAG == pNode->bType) )
  {
    if (NULL != pNode->DTEvent.bstrOriginalHref)
    {
      ::SysFreeString(pNode->DTEvent.bstrOriginalHref);
    }
  }
  else if (WCS_DTNODE_TYPE_PAGE == pNode->bType)
  {
    if (NULL != pNode->DTPage.bstrHTMLTemplateSrcName)
    {
      ::SysFreeString(pNode->DTPage.bstrHTMLTemplateSrcName);
    }
  }
  WCS_FreeNode(pNode);
}



//////////////////////////////////////////////////////////////////////
//
// inline HRESULT WCS_ReadWebClass(IStream *pStream,
//                                 WCS_WEBCLASS **ppClass)
//
//
//////////////////////////////////////////////////////////////////////


inline HRESULT WCS_ReadWebClass(IStream *pStream, WCS_WEBCLASS **ppClass)
{
  HRESULT hr = S_OK;
  ULONG cbRead = 0;
  ULONG acbStrings[6];
  BSTR *apbstrStrings[6];

  // allocate structure
  
  *ppClass = new WCS_WEBCLASS;
  CSF_CHECK(*ppClass != NULL, E_OUTOFMEMORY, CSF_TRACE_INTERNAL_ERRORS);

  // read structure from stream

  hr = pStream->Read(*ppClass, sizeof(**ppClass), &cbRead);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(**ppClass) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

  (*ppClass)->pvData = NULL; // don't take junk pointer value from stream

  // TODO: need error codes for version incompatibility, handle backlevel formats etc.

  CSF_CHECK(WCS_WEBCLASS_VER_MAJOR == (*ppClass)->wVerMajor, STG_E_OLDFORMAT, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(WCS_WEBCLASS_VER_MAJOR == (*ppClass)->wVerMinor, STG_E_OLDFORMAT, CSF_TRACE_EXTERNAL_ERRORS);

  // read string lengths from stream

  hr = pStream->Read(acbStrings, sizeof(acbStrings), &cbRead);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(acbStrings) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

  // set up array of string pointer addresses

  apbstrStrings[0] = &((*ppClass)->bstrName);
  apbstrStrings[1] = &((*ppClass)->bstrProgID);
  apbstrStrings[2] = &((*ppClass)->bstrCatastropheURL);
  apbstrStrings[3] = &((*ppClass)->bstrVirtualDirectory);
  apbstrStrings[4] = &((*ppClass)->bstrFirstURL);
  apbstrStrings[5] = &((*ppClass)->bstrASPName);

  // read strings from stream

  hr = ReadStrings(pStream, acbStrings, apbstrStrings,
                   (sizeof(acbStrings) / sizeof(acbStrings[0])) );
  
CLEANUP:
  if (FAILED(hr) && (*ppClass != NULL))
  {
    WCS_FreeWebClass(*ppClass);
    *ppClass = NULL;
  }
  return hr;
}


//=--------------------------------------------------------------------------=
//
// inline HRESULT WCS_ReadNodeFromStream(IStream *pStream, WCS_NODE *pNode)
//
// Reads a WCS_NODE structure from a stream. Caller passes in node.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCS_ReadNodeFromStream(IStream *pStream, WCS_NODE *pNode)
{
  HRESULT hr = S_OK;
  ULONG cbRead = 0;
  ULONG acbStrings[4];
  BSTR *apbstrStrings[4];
  int cStrings = 0;

  // read structure from stream

  hr = pStream->Read(pNode, sizeof(*pNode), &cbRead);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(*pNode) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

  // TODO: need error codes for version incompatibility, handle backlevel formats etc.

  CSF_CHECK(WCS_NODE_VER_MAJOR == pNode->wVerMajor, STG_E_OLDFORMAT, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(WCS_NODE_VER_MINOR == pNode->wVerMinor, STG_E_OLDFORMAT, CSF_TRACE_EXTERNAL_ERRORS);

  // set up array of string pointer addresses according to node type

  apbstrStrings[0] = &(pNode->bstrName);

  if ( (WCS_NODE_TYPE_NESTED_WEBCLASS == pNode->bType) ||
       (WCS_DTNODE_TYPE_NESTED_WEBCLASS == pNode->bType) )
  {
    apbstrStrings[1] = &(pNode->bstrProgID);
    cStrings = 2;
  }
  else if ( (WCS_NODE_TYPE_PAGE == pNode->bType) ||
            (WCS_DTNODE_TYPE_PAGE == pNode->bType) )
  {
    apbstrStrings[1] = &(pNode->bstrTemplate);
    apbstrStrings[2] = &(pNode->bstrToken);
    apbstrStrings[3] = &(pNode->bstrAppendedParams);
    cStrings = 4;
  }
  else if ( (WCS_NODE_TYPE_EVENT == bType) ||
            IsDTEvent(bType) )
  {
    cStrings = 1;
  }
  else
  {
    CSF_CHECK(FALSE, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);
  }

  // read string lengths from stream

  hr = pStream->Read(acbStrings, sizeof(acbStrings), &cbRead);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(acbStrings) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

  // read strings from stream

  hr = ReadStrings(pStream, acbStrings, apbstrStrings, cStrings);

CLEANUP:
  return hr;
}

//////////////////////////////////////////////////////////////////////
//
// inline HRESULT WCS_ReadNode(IStream *pStream, WCS_NODE **ppNode)
//
// Allocates a WCS_NODE structure and reads its contents from the
// stream.
//
//////////////////////////////////////////////////////////////////////

inline HRESULT WCS_ReadNode(IStream *pStream, WCS_NODE **ppNode)
{
  HRESULT hr = S_OK;

  // allocate structure

  *ppNode = new WCS_NODE;
  CSF_CHECK(*ppNode != NULL, E_OUTOFMEMORY, CSF_TRACE_INTERNAL_ERRORS);

  // read node in from stream

  hr = WCS_ReadNodeFromStream(pStream, *ppNode);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_INTERNAL_ERRORS);

CLEANUP:
  if (FAILED(hr) && (*ppNode != NULL))
  {
    WCS_FreeNode(*ppNode);
    *ppNode = NULL;
  }
  return hr;
}



//=--------------------------------------------------------------------------=
//
// inline HRESULT WCS_ReadDTNode(IStream *pStream, WCS_DTNODE **ppNode)
//
// Allocates a WCS_DTNODE and reads its contents from the stream.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCS_ReadDTNode(IStream *pStream, WCS_DTNODE **ppNode)
{
  HRESULT hr = S_OK;
  ULONG cbRead = 0;
  ULONG acbStrings[1];
  BSTR *apbstrStrings[1];
  int cStrings = 0;

  // allocate structure

  *ppNode = new WCS_DTNODE;
  CSF_CHECK(*ppNode != NULL, E_OUTOFMEMORY, CSF_TRACE_INTERNAL_ERRORS);

  // read base class WCS_NODE first

  hr = WCS_ReadNodeFromStream(pStream, *ppNode);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_INTERNAL_ERRORS);

  // read design time fields

  if (WCS_DTNODE_TYPE_PAGE == (*ppNode)->bType)
  {
    hr = pStream->Read(&(*ppNode)->DTPage, sizeof((*ppNode)->DTPage), &cbRead);
    CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
    CSF_CHECK(sizeof((*ppNode)->DTPage) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);
  }
  else if (WCS_DTNODE_TYPE_NESTED_WEBCLASS != (*ppNode)->bType)
  {
    hr = pStream->Read(&(*ppNode)->DTEvent, sizeof((*ppNode)->DTEvent), &cbRead);
    CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
    CSF_CHECK(sizeof((*ppNode)->DTEvent) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);
  }

  // read design time string lengths from stream

  hr = pStream->Read(acbStrings, sizeof(acbStrings), &cbRead);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(acbStrings) == cbRead, STG_E_DOCFILECORRUPT, CSF_TRACE_EXTERNAL_ERRORS);

  // now check if there are any strings to read
  // if yes then set up array of string pointer addresses

  if (0 == acbStrings[0])
  {
    // There are no strings to read so store NULL pointers
    if (WCS_DTNODE_TYPE_PAGE == (*ppNode)->bType)
    {
      (*ppNode)->DTPage.bstrHTMLTemplateSrcName = NULL;
    }
    else if (WCS_DTNODE_TYPE_NESTED_WEBCLASS != (*ppNode)->bType)
    {
      (*ppNode)->DTEvent.bstrOriginalHref = NULL;
    }
    goto CLEANUP;
  }
  else // There are strings so read them from the stream
  {
    if (WCS_DTNODE_TYPE_PAGE == (*ppNode)->bType)
    {
      apbstrStrings[0] = &((*ppNode)->DTPage.bstrHTMLTemplateSrcName);
    }
    else if (WCS_DTNODE_TYPE_NESTED_WEBCLASS != (*ppNode)->bType)
    {
      apbstrStrings[0] = &((*ppNode)->DTEvent.bstrOriginalHref);
    }
    cStrings++;
  }

  // read strings from stream

  if (cStrings > 0)
  {
    hr = ReadStrings(pStream, acbStrings, apbstrStrings, cStrings);
  }

CLEANUP:
  if (FAILED(hr) && (*ppNode != NULL))
  {
    WCS_FreeDTNode(*ppNode);
    *ppNode = NULL;
  }
  return hr;
}

//////////////////////////////////////////////////////////////////////
//
// inline HRESULT WCS_WriteWebClass(IStream *pStream, WCS_WEBCLASS *pClass)
//
//
//////////////////////////////////////////////////////////////////////

inline HRESULT WCS_WriteWebClass(IStream *pStream, WCS_WEBCLASS *pClass)
{
  HRESULT hr = S_OK;
  ULONG cbWritten = 0;
  ULONG acbStrings[6];
  BSTR abstrStrings[6];

  // set version numbers

  pClass->wVerMajor = WCS_WEBCLASS_VER_MAJOR;
  pClass->wVerMinor = WCS_WEBCLASS_VER_MAJOR;

  // write WebClass structure to stream

  hr = pStream->Write(pClass, sizeof(*pClass), &cbWritten);
  CSF_CHECK(hr == S_OK, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(cbWritten == sizeof(*pClass), STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

  // get lengths of strings and write them to stream

  acbStrings[0] = SysStringByteLen(pClass->bstrName);
  acbStrings[1] = SysStringByteLen(pClass->bstrProgID);
  acbStrings[2] = SysStringByteLen(pClass->bstrCatastropheURL);
  acbStrings[3] = SysStringByteLen(pClass->bstrVirtualDirectory);
  acbStrings[4] = SysStringByteLen(pClass->bstrFirstURL);
  acbStrings[5] = SysStringByteLen(pClass->bstrASPName);

  hr = pStream->Write(acbStrings, sizeof(acbStrings), &cbWritten);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(cbWritten == sizeof(acbStrings), STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

  // set up array of pointers to strings to be written to stream
  
  abstrStrings[0] = pClass->bstrName;
  abstrStrings[1] = pClass->bstrProgID;
  abstrStrings[2] = pClass->bstrCatastropheURL;
  abstrStrings[3] = pClass->bstrVirtualDirectory;
  abstrStrings[4] = pClass->bstrFirstURL;
  abstrStrings[5] = pClass->bstrASPName;

  // write strings to stream

  hr = WriteStrings(pStream, acbStrings, abstrStrings,
                    (sizeof(acbStrings) / sizeof(acbStrings[0])) );

CLEANUP:
  return hr;
}


//////////////////////////////////////////////////////////////////////
//
// inline HRESULT WCS_WriteNode(IStream *pStream, WCS_NODE *pNode)
//
//
//////////////////////////////////////////////////////////////////////

inline HRESULT WCS_WriteNode(IStream *pStream, WCS_NODE *pNode)
{
  HRESULT hr = S_OK;
  ULONG cbWritten = 0;
  ULONG acbStrings[4];
  BSTR abstrStrings[4];
  int cStrings = 0;

  // set version numbers in node

  pNode->wVerMajor = WCS_NODE_VER_MAJOR;
  pNode->wVerMinor = WCS_NODE_VER_MINOR;

  // write node structure to stream

  hr = pStream->Write(pNode, sizeof(*pNode), &cbWritten);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(*pNode) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

  // set up array of strings to be written to stream and
  // determine how many there will be

  abstrStrings[0] = pNode->bstrName;
  acbStrings[0] = ::SysStringByteLen(pNode->bstrName);

  if ( (WCS_NODE_TYPE_NESTED_WEBCLASS == pNode->bType) ||
       (WCS_DTNODE_TYPE_NESTED_WEBCLASS == pNode->bType) )
  {
    abstrStrings[1] = pNode->Nested.bstrProgID;
    acbStrings[1] = ::SysStringByteLen(pNode->Nested.bstrProgID);
    cStrings = 2;
  }
  else if ( (WCS_NODE_TYPE_PAGE == pNode->bType) ||
            (WCS_DTNODE_TYPE_PAGE == pNode->bType) )
  {
    abstrStrings[1] = pNode->Page.bstrTemplate;
    acbStrings[1] = ::SysStringByteLen(pNode->Page.bstrTemplate);
    abstrStrings[2] = pNode->Page.bstrToken;
    acbStrings[2] = ::SysStringByteLen(pNode->Page.bstrToken);
    abstrStrings[3] = pNode->Page.bstrAppendedParams;
    acbStrings[3] = ::SysStringByteLen(pNode->Page.bstrAppendedParams);
    cStrings = 4;
  }
  else if ( (WCS_NODE_TYPE_EVENT == pNode->bType) ||
            WCS_IsDTEvent(pNode->bType) )
  {
    cStrings = 1;
  }
  else
  {
    CSF_CHECK(FALSE, E_INVALIDARG, CSF_TRACE_INTERNAL_ERRORS);
  }

  // write string lengths to stream

  hr = pStream->Write(acbStrings, sizeof(acbStrings), &cbWritten);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(acbStrings) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

  // write strings to stream

  hr = WriteStrings(pStream, acbStrings, abstrStrings, cStrings);

CLEANUP:
  return hr;
}

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCS_WriteDTNode(IStream *pStream, WCS_DTNODE *pNode)
//
// Write design time node. Write the base class runtime node and then
// then extra stuff in the design time node.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCS_WriteDTNode(IStream *pStream, WCS_DTNODE *pNode)
{
  HRESULT hr = S_OK;
  ULONG cbWritten = 0;
  ULONG acbStrings[1] = { 0 };
  BSTR abstrStrings[1];
  int cStrings = 0;

  // write run time node first

  hr = WCS_WriteNode(pStream, pNode);
  CSF_CHECK(hr == S_OK, hr, CSF_TRACE_INTERNAL_ERRORS);

  // write design time fields

  if (WCS_DTNODE_TYPE_PAGE == pNode->bType)
  {
    hr = pStream->Write(&pNode->DTPage, sizeof(pNode->DTPage), &cbWritten);
    CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
    CSF_CHECK(sizeof(pNode->DTPage) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

    if (NULL != pNode->DTPage.bstrHTMLTemplateSrcName)
    {
      abstrStrings[0] = pNode->DTPage.bstrHTMLTemplateSrcName;
      acbStrings[0] = ::SysStringByteLen(pNode->DTPage.bstrHTMLTemplateSrcName);
      cStrings++;
    }
  }
  else if (WCS_DTNODE_TYPE_NESTED_WEBCLASS != pNode->bType)
  {
    hr = pStream->Write(&pNode->DTEvent, sizeof(pNode->DTEvent), &cbWritten);
    CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
    CSF_CHECK(sizeof(pNode->DTEvent) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

    if (NULL != pNode->DTEvent.bstrOriginalHref)
    {
      abstrStrings[0] = pNode->DTEvent.bstrOriginalHref;
      acbStrings[0] = ::SysStringByteLen(pNode->DTEvent.bstrOriginalHref);
      cStrings++;
    }
  }

  hr = pStream->Write(acbStrings, sizeof(acbStrings), &cbWritten);
  CSF_CHECK(S_OK == hr, hr, CSF_TRACE_EXTERNAL_ERRORS);
  CSF_CHECK(sizeof(acbStrings) == cbWritten, STG_E_WRITEFAULT, CSF_TRACE_EXTERNAL_ERRORS);

  if (cStrings > 0)
  {
    hr = WriteStrings(pStream, acbStrings, abstrStrings, cStrings);
    CSF_CHECK(S_OK == hr, hr, CSF_TRACE_INTERNAL_ERRORS);
  }

CLEANUP:
  return hr;
}
*/


#define _WBCLSSER_H_
#endif // _WBCLSSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\wcutil.h ===
//=--------------------------------------------------------------------------=
// WCUtil.H
//=--------------------------------------------------------------------------=
// Copyright (c) 1987-1998, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Utitlity Routines for the WebClass Designer
//

#ifndef _WCUTIL_H_

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_ANSIFromWideStr(WCHAR * pwszWideStr, char **ppszAnsi)
//
// Converts null terminated WCHAR string to null terminated ANSI string. 
// Allocates ANSI string using new operator. If successful, caller must free
// ANSI string with delete operator.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_ANSIFromWideStr(WCHAR *pwszWideStr, char **ppszAnsi)
{
    CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_ANSIFromWideStr"));

    HRESULT hr = S_OK;
    *ppszAnsi = NULL;
    int cchWideStr = (int)::wcslen(pwszWideStr);
    int cchConverted = 0;

    // get required buffer length

    int cchAnsi = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                        0,                    // performance and mapping flags 
                                        pwszWideStr,          // address of wide-character string 
                                        cchWideStr,           // number of characters in string 
                                        NULL,                 // address of buffer for new string 
                                        0,                    // size of buffer 
                                        NULL,                 // address of default for unmappable characters 
                                        NULL                  // address of flag set when default char. used 
                                       );
    CSF_CHECK(0 != cchAnsi, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // allocate a buffer for the ANSI string

    *ppszAnsi = new char [cchAnsi + 1];
    CSF_CHECK(NULL != *ppszAnsi, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

    // now convert the string and copy it to the buffer

    cchConverted = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                         0,                    // performance and mapping flags 
                                         pwszWideStr,          // address of wide-character string 
                                         cchWideStr,           // number of characters in string 
                                         *ppszAnsi,            // address of buffer for new string 
                                         cchAnsi,              // size of buffer 
                                         NULL,                 // address of default for unmappable characters 
                                         NULL                  // address of flag set when default char. used 
                                        );
    CSF_CHECK(cchConverted == cchAnsi, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // add terminating null byte

    *( (*ppszAnsi) + cchAnsi ) = '\0';

CLEANUP:
    if (FAILED(hr))
    {
        if (NULL != *ppszAnsi)
        {
            delete [] *ppszAnsi;
            *ppszAnsi = NULL;
        }
    }

    CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_ANSIFromWideStr hr = %08.8X"), hr);

    return hr;
}

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_ANSIFromWideStr(WCHAR * pwszWideStr, char **ppszAnsi)
//
// Converts null terminated WCHAR string to null terminated ANSI string. 
// Allocates ANSI string using new operator. If successful, caller must free
// ANSI string with delete operator.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_ANSIFromWideStrLen(WCHAR *pwszWideStr, int cchWideStr, char **ppszAnsi)
{
    CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_ANSIFromWideStr"));

    HRESULT hr = S_OK;
    *ppszAnsi = NULL;
    int cchConverted = 0;

    // get required buffer length

    int cchAnsi = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                        0,                    // performance and mapping flags 
                                        pwszWideStr,          // address of wide-character string 
                                        cchWideStr,           // number of characters in string 
                                        NULL,                 // address of buffer for new string 
                                        0,                    // size of buffer 
                                        NULL,                 // address of default for unmappable characters 
                                        NULL                  // address of flag set when default char. used 
                                       );
    CSF_CHECK(0 != cchAnsi, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // allocate a buffer for the ANSI string

    *ppszAnsi = new char [cchAnsi + 1];
    CSF_CHECK(NULL != *ppszAnsi, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

    // now convert the string and copy it to the buffer

    cchConverted = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                         0,                    // performance and mapping flags 
                                         pwszWideStr,          // address of wide-character string 
                                         cchWideStr,           // number of characters in string 
                                         *ppszAnsi,            // address of buffer for new string 
                                         cchAnsi,              // size of buffer 
                                         NULL,                 // address of default for unmappable characters 
                                         NULL                  // address of flag set when default char. used 
                                        );
    CSF_CHECK(cchConverted == cchAnsi, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // add terminating null byte

    *( (*ppszAnsi) + cchAnsi ) = '\0';

CLEANUP:
    if (FAILED(hr))
    {
        if (NULL != *ppszAnsi)
        {
            delete [] *ppszAnsi;
            *ppszAnsi = NULL;
        }
    }

    CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_ANSIFromWideStr hr = %08.8X"), hr);

    return hr;
}

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_WideStrFromANSI(char *pszAnsi, WCHAR **ppwszWideStr))
//
// Converts null terminated ANSI string to a null terminated WCHAR string. 
// Allocates WCHAR string buffer using the new operator. If successful, caller
// must free WCHAR string using the delete operator.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_WideStrFromANSI(char *pszAnsi, WCHAR **ppwszWideStr)
{
    CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_WideStrFromANSI"));

    HRESULT hr = S_OK;
    *ppwszWideStr = NULL;
    int cchANSI = ::strlen(pszAnsi);
    int cchConverted = 0;

    // get required buffer length

    int cchWideStr = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                           0,                    // performance and mapping flags 
                                           pszAnsi,              // address of multibyte string 
                                           cchANSI,              // number of characters in string 
                                           NULL,                 // address of buffer for new string 
                                           0                     // size of buffer 
                                          );
    CSF_CHECK(0 != cchWideStr, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // allocate a buffer for the WCHAR *

    *ppwszWideStr = new WCHAR[cchWideStr + 1];
    CSF_CHECK(NULL != *ppwszWideStr, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

    // now convert the string and copy it to the buffer

    cchConverted = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                         0,                    // performance and mapping flags 
                                         pszAnsi,              // address of multibyte string 
                                         cchANSI,              // number of characters in string 
                                         *ppwszWideStr,               // address of buffer for new string 
                                         cchWideStr               // size of buffer 
                                        );
    CSF_CHECK(cchConverted == cchWideStr, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // add terminating null character

    *( (*ppwszWideStr) + cchWideStr ) = L'\0';

CLEANUP:
    if (FAILED(hr))
    {
        if (NULL != *ppwszWideStr)
        {
            delete [] *ppwszWideStr;
            *ppwszWideStr = NULL;
        }
    }

    CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_WideStrFromANSI hr = %08.8X"), hr);

    return hr;
}

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_WideStrFromANSIExtra(char *pszAnsi, WCHAR **ppwszWideStr))
//
// Converts null terminated ANSI string to a null terminated WCHAR string. 
// Allocates WCHAR string buffer using the new operator. If successful, caller
// must free WCHAR string using the delete operator. 
//
// User can also specify the number of extra bytes to add the returned buffer. The
// actual size of the buffer is returned as well.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_WideStrFromANSIExtra
(
	HANDLE hHeap,
	char *pszAnsi, 
	int cchANSI,
	WCHAR **ppwszWideStr, 
	DWORD cbExtra,
	DWORD* pcbBufferSize,
	DWORD* pcchConverted
)
{
    CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_WideStrFromANSI"));

    HRESULT hr = S_OK;
    *ppwszWideStr = NULL;
    int cchConverted = 0;
	DWORD cbBufferSize = 0;

    // get required buffer length

    int cchWideStr = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                           0,                    // performance and mapping flags 
                                           pszAnsi,              // address of multibyte string 
                                           cchANSI,              // number of characters in string 
                                           NULL,                 // address of buffer for new string 
                                           0                     // size of buffer 
                                          );
    CSF_CHECK(0 != cchWideStr, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

	cbBufferSize = (cchWideStr + 1 + cbExtra) * sizeof(WCHAR);

    // allocate a buffer for the WCHAR *

    *ppwszWideStr = (LPWSTR) HeapAlloc(hHeap, NULL, cbBufferSize);
    CSF_CHECK(NULL != *ppwszWideStr, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

    // now convert the string and copy it to the buffer

    cchConverted = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                         0,                    // performance and mapping flags 
                                         pszAnsi,              // address of multibyte string 
                                         cchANSI,              // number of characters in string 
                                         *ppwszWideStr,               // address of buffer for new string 
                                         cchWideStr               // size of buffer 
                                        );
    CSF_CHECK(cchConverted == cchWideStr, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // add terminating null character

    *( (*ppwszWideStr) + cchWideStr ) = L'\0';
	
	*pcbBufferSize = cbBufferSize;
	*pcchConverted = cchConverted;

CLEANUP:
    if (FAILED(hr))
    {
        if (NULL != *ppwszWideStr)
        {
            delete [] *ppwszWideStr;
            *ppwszWideStr = NULL;
        }
    }

    CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_WideStrFromANSI hr = %08.8X"), hr);

    return hr;
}

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_WideStrFromANSILen(char *pszAnsi, int nLen, WCHAR **ppwszWideStr))
//
// Converts length specifed ANSI string to a null terminated WCHAR string. 
// Allocates WCHAR string buffer using the new operator. If successful, caller
// must free WCHAR string using the delete operator.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_WideStrFromANSILen(char *pszAnsi, int nLen, WCHAR **ppwszWideStr)
{
    CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_WideStrFromANSI"));

    HRESULT hr = S_OK;
    *ppwszWideStr = NULL;
    int cchConverted = 0;

	if(nLen == 0)
	{
		*ppwszWideStr = NULL;
		return S_OK;
	}

    // get required buffer length

    int cchWideStr = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                           0,                    // performance and mapping flags 
                                           pszAnsi,              // address of multibyte string 
                                           nLen,              // number of characters in string 
                                           NULL,                 // address of buffer for new string 
                                           0                     // size of buffer 
                                          );
    CSF_CHECK(0 != cchWideStr, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // allocate a buffer for the WCHAR *

    *ppwszWideStr = new WCHAR[cchWideStr + 1];
    CSF_CHECK(NULL != *ppwszWideStr, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

    // now convert the string and copy it to the buffer

    cchConverted = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                         0,                    // performance and mapping flags 
                                         pszAnsi,              // address of multibyte string 
                                         nLen,              // number of characters in string 
                                         *ppwszWideStr,               // address of buffer for new string 
                                         cchWideStr               // size of buffer 
                                        );
    CSF_CHECK(cchConverted == cchWideStr, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // add terminating null character

    *( (*ppwszWideStr) + cchWideStr ) = L'\0';

CLEANUP:
    if (FAILED(hr))
    {
        if (NULL != *ppwszWideStr)
        {
            delete [] *ppwszWideStr;
            *ppwszWideStr = NULL;
        }
    }

    CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_WideStrFromANSI hr = %08.8X"), hr);

    return hr;
}

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_ANSIFromBSTR(BSTR bstr, char **ppszAnsi)
//
// Converts BSTR to null terminated ANSI string. Allocates ANSI string using
// new operator. If successful, caller must free ANSI string with delete
// operator.
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_ANSIFromBSTR(BSTR bstr, char **ppszAnsi)
{
  CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_ANSIFromBSTR"));

  HRESULT hr = S_OK;
  *ppszAnsi = NULL;
  int cchBstr = (int)::SysStringLen(bstr);
  int cchConverted = 0;

  // get required buffer length

  int cchAnsi = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                      0,                    // performance and mapping flags 
                                      bstr,                 // address of wide-character string 
                                      cchBstr,              // number of characters in string 
                                      NULL,                 // address of buffer for new string 
                                      0,                    // size of buffer 
                                      NULL,                 // address of default for unmappable characters 
                                      NULL                  // address of flag set when default char. used 
                                     );
  CSF_CHECK(0 != cchAnsi, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

  // allocate a buffer for the ANSI string

  *ppszAnsi = new char [cchAnsi + 1];
  CSF_CHECK(NULL != *ppszAnsi, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

  // now convert the string and copy it to the buffer
  
  cchConverted = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                       0,                    // performance and mapping flags 
                                       bstr,                 // address of wide-character string 
                                       cchBstr,              // number of characters in string 
                                       *ppszAnsi,            // address of buffer for new string 
                                       cchAnsi,              // size of buffer 
                                       NULL,                 // address of default for unmappable characters 
                                       NULL                  // address of flag set when default char. used 
                                      );
  CSF_CHECK(cchConverted == cchAnsi, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

  // add terminating null byte

  *( (*ppszAnsi) + cchAnsi ) = '\0';

CLEANUP:
  if (FAILED(hr))
  {
    if (NULL != *ppszAnsi)
    {
      delete [] *ppszAnsi;
      *ppszAnsi = NULL;
    }
  }

  CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_ANSIFromBSTR hr = %08.8X"), hr);

  return hr;
}



//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_BSTRFromANSI(char *pszAnsi, BSTR *pbstr))
//
// Converts null terminated ANSI string to a null terminated BSTR. Allocates
// BSTR. If successful, caller must free BSTR using ::SysFreeString().
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_BSTRFromANSI(char *pszAnsi, BSTR *pbstr)
{
  CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_BSTRFromANSI"));

  HRESULT hr = S_OK;
  WCHAR   *pwszWideStr = NULL;

  // convert to a wide string first

  hr = WCU_WideStrFromANSI(pszAnsi, &pwszWideStr);
  CSF_CHECK(SUCCEEDED(hr), hr, CSF_TRACE_INTERNAL_ERRORS);

  // allocate a BSTR and copy it

  *pbstr = ::SysAllocStringLen(pwszWideStr, ::wcslen(pwszWideStr));
  CSF_CHECK(NULL != *pbstr, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

CLEANUP:
  if (NULL != pwszWideStr)
  {
      delete [] pwszWideStr;
  }
  if (FAILED(hr))
  {
    if (NULL != *pbstr)
    {
      ::SysFreeString(*pbstr);
      *pbstr = NULL;
    }
  }

  CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_BSTRFromANSI hr = %08.8X"), hr);

  return hr;
}

//=--------------------------------------------------------------------------=
//
// inline HRESULT WCU_BSTRFromANSILen(char *pszAnsi, int nLen, BSTR *pbstr))
//
// Converts len specified ANSI string to a null terminated BSTR. Allocates
// BSTR. If successful, caller must free BSTR using ::SysFreeString().
//
//=--------------------------------------------------------------------------=

inline HRESULT WCU_BSTRFromANSILen(char *pszAnsi, int nLen, BSTR *pbstr)
{
  CSF_TRACE(CSF_TRACE_ENTER_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Entered WCU_BSTRFromANSI"));

  HRESULT hr = S_OK;
  WCHAR   *pwszWideStr = NULL;

  if(nLen == 0)
  {
	*pbstr = SysAllocString(L"\0");
	CSF_CHECK(*pbstr != NULL, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

	return S_OK;
  }

  // convert to a wide string first

  hr = WCU_WideStrFromANSILen(pszAnsi, nLen, &pwszWideStr);
  CSF_CHECK(SUCCEEDED(hr), hr, CSF_TRACE_INTERNAL_ERRORS);

  // allocate a BSTR and copy it

  *pbstr = ::SysAllocStringLen(pwszWideStr, nLen);
  CSF_CHECK(NULL != *pbstr, E_OUTOFMEMORY, CSF_TRACE_EXTERNAL_ERRORS);

CLEANUP:
  if (NULL != pwszWideStr)
  {
      delete [] pwszWideStr;
  }
  if (FAILED(hr))
  {
    if (NULL != *pbstr)
    {
      ::SysFreeString(*pbstr);
      *pbstr = NULL;
    }
  }

  CSF_TRACE(CSF_TRACE_LEAVE_INTERNAL_FUNC)(CSF_TRACE_CONTEXT, TEXT("Leaving WCU_BSTRFromANSI hr = %08.8X"), hr);

  return hr;
}

inline HRESULT GetIISVersion
(
	DWORD* pdwMajor, 
	DWORD* pdwMinor
)
{
	HRESULT hr = S_OK;
	TCHAR *pszRegIISParamsKey = { TEXT("SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters") };
	TCHAR *pszRegASPParamsKey = { TEXT("SYSTEM\\CurrentControlSet\\Services\\W3SVC\\ASP") };
	HKEY hKey = NULL;
	long lRet = 0;
	DWORD dwType = 0;
	DWORD cbSize = sizeof(DWORD);

	lRet = ::RegOpenKey(HKEY_LOCAL_MACHINE,
  					    pszRegIISParamsKey,
					    &hKey);
	CSF_CHECK(lRet == ERROR_SUCCESS, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);
		
	// Now, we can get the size of the value...
	lRet = ::RegQueryValueEx(hKey, "MajorVersion", NULL, &dwType, (BYTE*) pdwMajor, &cbSize);
	CSF_CHECK(lRet == ERROR_SUCCESS, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

	// Now, we can get the size of the value...
	lRet = ::RegQueryValueEx(hKey, "MinorVersion", NULL, &dwType, (BYTE*) pdwMinor, &cbSize);
	CSF_CHECK(lRet == ERROR_SUCCESS, E_UNEXPECTED, CSF_TRACE_EXTERNAL_ERRORS);

    // Uggghh! IIS 3.0 never update the registry verison, so we need to check for 
    // ASP if 1 or 2 was specified...
    if(*pdwMajor < 3)
    {
		::RegCloseKey(hKey);

	    lRet = ::RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
  					            pszRegASPParamsKey,
                                0,
                                KEY_QUERY_VALUE,
					            &hKey);
	    
        if(lRet == ERROR_SUCCESS)
        {
            // We found the ASP key so this must be version 3.0...
            *pdwMajor = 3;
            *pdwMinor = 0;
        }
        
    }

CLEANUP:
	if(hKey != NULL)
		::RegCloseKey(hKey);

	return hr;
}

// TODO: Do we want this this way?
// Maybe just substract 2? No We ain't dynamic casue
// of the tlb anyhow.
inline DWORD IISVersionToASPVersion(DWORD dwIIS)
{
    DWORD dwASP = 0;
    
    if(dwIIS == 3)
    {
        dwASP = 1;
    }
    else if(dwIIS == 4)
    {
        dwASP = 2;
    }

    return dwASP;
}

// Listed from most to least
static WCHAR g_wszMostUniqueCharset[] = {L"~`\\_/{}|[]^!@#$%*():;"};

//----------------------------------------------------------------------------------------
// PickMostUniqueChar
//----------------------------------------------------------------------------------------
// Selects the most unique char in the specified string. We use this to pick the most unique
// char in the user supplied tag prefix. This optimizes searching for those tags
//----------------------------------------------------------------------------------------

inline HRESULT PickMostUniqueChar
(
    LPWSTR pwszPrefix,		// [in] String to find unique char in
    WORD* pwIndex			// [out] Index of the most unique char
)
{
	LPWSTR pwszRet = NULL;

	ASSERT(wcslen(pwszPrefix) < 0xFFFF);

	// See if the string contains any of our unique chars
	//
	pwszRet = wcspbrk(pwszPrefix, g_wszMostUniqueCharset);

	if(pwszRet != NULL)
	{
	    *pwIndex = (WORD)(pwszRet - pwszPrefix);
	}
	else
	{
		// If not, just use first char in the string
		//
	    *pwIndex = 0;
	}

    return S_OK;
}

/***
*wchar_t *wcsistr(string1, string2) - search for string2 in string1
*       (wide strings)
*
*Purpose:
*       finds the first occurrence of string2 in string1 (wide strings)
*
*Entry:
*       wchar_t *string1 - string to search in
*       wchar_t *string2 - string to search for
*
*Exit:
*       returns a pointer to the first occurrence of string2 in
*       string1, or NULL if string2 does not occur in string1
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/



//=--------------------------------------------------------------------------=
//
// wchar_t *WCU_wcsistr(string1, string2)
//
// Purpose:
//       Finds the first occurrence of string2 in string1 (wide strings.
//       Not case sensitive.
//       This is a direct copy of C runtime source code from VC5. The only
//       addition is the use of the Win32 API CharUpperBuffW() to do a locale
//       sensitive conversion of characters to upper case before comparing
//       them.
//
// Entry:
//       wchar_t *string1 - string to search in
//       wchar_t *string2 - string to search for
//
// Exit:
//       returns a pointer to the first occurrence of string2 in
//       string1, or NULL if string2 does not occur in string1
//
//=--------------------------------------------------------------------------=

inline wchar_t * __cdecl WCU_wcsistr
(
    const wchar_t * wcs1,
    const wchar_t * wcs2
)
{
    wchar_t *cp = (wchar_t *) wcs1;
    wchar_t *s1, *s2;
    wchar_t c1, c2;
    

    while (*cp)
    {
        s1 = cp;
        s2 = (wchar_t *) wcs2;

        // while there are characters left in both strings

        while ( *s1 && *s2 )
        {
            // if the characters are not equal

            if (*s1 - *s2)
            {
                // convert them to uppercase

                c1 = *s1;
                c2 = *s2;
                if ( (CharUpperBuffW(&c1, (DWORD)1) != (DWORD)1) ||
                     (CharUpperBuffW(&c2, (DWORD)1) != (DWORD)1) )
                {
                    break;
                }

                // if the upper case characters are not equal then the string
                // is not there

                if (c1 - c2)
                    break;
            }
            s1++, s2++;
        }

        if (!*s2)
            return(cp);

        cp++;
    }

    return(NULL);
}



#define _WCUTIL_H_
#endif // _WCUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mmcproxy\multisel.cpp ===
//=--------------------------------------------------------------------------=
// multisel.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMultiSelDataObject class implementation
//
// This class simulates a multi-select data object craeted by MMC. It is
// used by the stub when it receives a remote call with multiple data objects.
//=--------------------------------------------------------------------------=

#include "mmc.h"

static HRESULT ANSIFromWideStr(WCHAR *pwszWideStr, char **ppszAnsi);
extern "C" HRESULT GetClipboardFormat(WCHAR      *pwszFormatName,
                                      CLIPFORMAT *pcfFormat);


class CMultiSelDataObject : public IDataObject
{
    public:
        CMultiSelDataObject();
        ~CMultiSelDataObject();

        HRESULT SetDataObjects(IDataObject **ppiDataObjects, long cDataObjects);
        
    private:

    // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

    // IDataObject
        STDMETHOD(GetData)(FORMATETC *pFormatEtcIn, STGMEDIUM *pmedium);
        STDMETHOD(GetDataHere)(FORMATETC *pFormatEtc, STGMEDIUM *pmedium);
        STDMETHOD(QueryGetData)(FORMATETC *pFormatEtc);
        STDMETHOD(GetCanonicalFormatEtc)(FORMATETC *pFormatEtcIn,
                                         FORMATETC *pFormatEtcOut);
        STDMETHOD(SetData)(FORMATETC *pFormatEtc,
                           STGMEDIUM *pmedium,
                           BOOL fRelease);
        STDMETHOD(EnumFormatEtc)(DWORD            dwDirection,
                                 IEnumFORMATETC **ppenumFormatEtc);
        STDMETHOD(DAdvise)(FORMATETC   *pFormatEtc,
                           DWORD        advf,
                           IAdviseSink *pAdvSink,
                           DWORD       *pdwConnection);
        STDMETHOD(DUnadvise)(DWORD dwConnection);
        STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise);

        void InitMemberVariables();
        void ReleaseDataObjects();

        SMMCDataObjects *m_pDataObjects;
        CLIPFORMAT       m_cfMultiSelectSnapIns;
        CLIPFORMAT       m_cfMultiSelectDataObject;
        ULONG            m_cRefs;
};


CMultiSelDataObject::CMultiSelDataObject()
{
    InitMemberVariables();
    m_cRefs = 1L;
}

CMultiSelDataObject::~CMultiSelDataObject()
{
    ReleaseDataObjects();
    InitMemberVariables();
}


void CMultiSelDataObject::ReleaseDataObjects()
{
    DWORD i = 0;

    if (NULL != m_pDataObjects)
    {
        while (i < m_pDataObjects->count)
        {
            if (NULL != m_pDataObjects->lpDataObject[i])
            {
                m_pDataObjects->lpDataObject[i]->Release();
            }
            i++;
        }
        (void)::GlobalFree((HGLOBAL)m_pDataObjects);
        m_pDataObjects = NULL;
    }
}

void CMultiSelDataObject::InitMemberVariables()
{
    m_pDataObjects = NULL;
    m_cfMultiSelectSnapIns = 0;
    m_cfMultiSelectDataObject = 0;
    m_cRefs = 0;
}


HRESULT CMultiSelDataObject::SetDataObjects
(
    IDataObject **ppiDataObjects,
    long          cDataObjects
)
{
    HRESULT hr = S_OK;
    long    i = 0;

    ReleaseDataObjects();

    hr = ::GetClipboardFormat(CCF_MULTI_SELECT_SNAPINS,
                              &m_cfMultiSelectSnapIns);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = ::GetClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT,
                              &m_cfMultiSelectDataObject);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    m_pDataObjects = (SMMCDataObjects *)::GlobalAlloc(GPTR,
        sizeof(SMMCDataObjects) + ((cDataObjects - 1) * sizeof(IDataObject *)));

    if (NULL == m_pDataObjects)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    m_pDataObjects->count = cDataObjects;

    for (i = 0; i < cDataObjects; i++)
    {
        ppiDataObjects[i]->AddRef();
        m_pDataObjects->lpDataObject[i] = ppiDataObjects[i];
    }

Cleanup:
    return hr;
}


//=--------------------------------------------------------------------------=
//
//                          IUnknown Methods
//
//=--------------------------------------------------------------------------=

STDMETHODIMP CMultiSelDataObject::QueryInterface(REFIID riid, void **ppvObjOut)
{
    HRESULT hr = S_OK;

    if (IID_IUnknown == riid)
    {
        AddRef();
        *ppvObjOut = (IUnknown *)this;
    }
    else if (IID_IDataObject == riid)
    {
        AddRef();
        *ppvObjOut = (IDataObject *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}


STDMETHODIMP_(ULONG) CMultiSelDataObject::AddRef(void)
{
    m_cRefs++;
    return m_cRefs;
}


STDMETHODIMP_(ULONG) CMultiSelDataObject::Release(void)
{
    ULONG cRefs = --m_cRefs;

    if (0 == cRefs)
    {
        delete this;
    }
    return cRefs;
}

//=--------------------------------------------------------------------------=
//
//                             IDataObject Methods
//
//=--------------------------------------------------------------------------=

STDMETHODIMP CMultiSelDataObject::GetData
(
    FORMATETC *pFmtEtc,
    STGMEDIUM *pStgMed
)
{
    SMMCDataObjects *pMMCDataObjects = NULL;
    DWORD           *pdw = NULL;
    DWORD            i = 0;
    HRESULT          hr = S_OK;

    if (TYMED_HGLOBAL != pFmtEtc->tymed)
    {
        hr = DV_E_TYMED;
        goto Cleanup;
    }

    if (m_cfMultiSelectSnapIns == pFmtEtc->cfFormat)
    {
        if (NULL == m_pDataObjects)
        {
            hr = DV_E_FORMATETC;
            goto Cleanup;
        }
        pStgMed->hGlobal = ::GlobalAlloc(GPTR,
                         sizeof(SMMCDataObjects) +
                         ((m_pDataObjects->count - 1) * sizeof(IDataObject *)));

        if (NULL == pStgMed->hGlobal)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        pStgMed->tymed = TYMED_HGLOBAL;
        pMMCDataObjects = (SMMCDataObjects *)pStgMed->hGlobal;
        pMMCDataObjects->count = m_pDataObjects->count;

        for (i = 0; i < pMMCDataObjects->count; i++)
        {
            // Note: According to the rules of COM the returned IDataObject
            // pointers should be AddRef()ed. That is not done here in order
            // to emulate the way MMC does it.
            pMMCDataObjects->lpDataObject[i] = m_pDataObjects->lpDataObject[i];
        }
    }
    else if (m_cfMultiSelectDataObject == pFmtEtc->cfFormat)
    {
        pStgMed->hGlobal = ::GlobalAlloc(GPTR, sizeof(DWORD));
        if (NULL == pStgMed->hGlobal)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        pStgMed->tymed = TYMED_HGLOBAL;
        pdw = (DWORD *)pStgMed->hGlobal;
        *pdw = (DWORD)1;
    }
    else
    {
        hr = DV_E_FORMATETC;
        goto Cleanup;
    }
Cleanup:
    return hr;
}

STDMETHODIMP CMultiSelDataObject::GetDataHere
(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pmedium
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMultiSelDataObject::QueryGetData(FORMATETC *pFmtEtc)
{
    HRESULT hr = S_OK;
    if (TYMED_HGLOBAL != pFmtEtc->tymed)
    {
        hr = DV_E_TYMED;
    }
    else if ( (m_cfMultiSelectSnapIns != pFmtEtc->cfFormat) &&
              (m_cfMultiSelectDataObject != pFmtEtc->cfFormat) )
    {
        hr = DV_E_FORMATETC;
    }
    return hr;
}

STDMETHODIMP CMultiSelDataObject::GetCanonicalFormatEtc
(
    FORMATETC *pFormatEtcIn,
    FORMATETC *pFormatEtcOut
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMultiSelDataObject::SetData
(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pmedium,
    BOOL       fRelease
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMultiSelDataObject::EnumFormatEtc
(
    DWORD            dwDirection,
    IEnumFORMATETC **ppenumFormatEtc
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMultiSelDataObject::DAdvise
(
    FORMATETC   *pFormatEtc,
    DWORD        advf,
    IAdviseSink *pAdvSink,
    DWORD       *pdwConnection
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMultiSelDataObject::DUnadvise(DWORD dwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMultiSelDataObject::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
    return E_NOTIMPL;
}


extern "C" HRESULT CreateMultiSelDataObject
(
    IDataObject          **ppiDataObjects,
    long                   cDataObjects,
    IDataObject          **ppiMultiSelDataObject
)
{
    HRESULT              hr = S_OK;
    CMultiSelDataObject *pMultiSelDataObject = new CMultiSelDataObject;

    *ppiMultiSelDataObject = NULL;

    if (NULL == pMultiSelDataObject)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pMultiSelDataObject->SetDataObjects(ppiDataObjects, cDataObjects);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    *ppiMultiSelDataObject = pMultiSelDataObject;

Cleanup:
    if ( FAILED(hr) && (NULL != pMultiSelDataObject) )
    {
        delete pMultiSelDataObject;
    }
    return hr;
}


extern "C" HRESULT GetClipboardFormat
(
    WCHAR       *pwszFormatName,
    CLIPFORMAT  *pcfFormat
)
{
    HRESULT  hr = S_OK;
    BOOL     fAnsi = TRUE;
    char    *pszFormatName = NULL;

    OSVERSIONINFO VerInfo;
    ::ZeroMemory(&VerInfo, sizeof(VerInfo));

    // Determine whether we are on NT or Win9x so that we know whether to
    // register clipboard format strings as UNICODE or ANSI.

    VerInfo.dwOSVersionInfoSize = sizeof(VerInfo);
    if (!::GetVersionEx(&VerInfo))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Cleanup;
    }

    if (VER_PLATFORM_WIN32_NT == VerInfo.dwPlatformId)
    {
        fAnsi = FALSE;
    }

    if (fAnsi)
    {
        hr = ::ANSIFromWideStr(pwszFormatName, &pszFormatName);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        *pcfFormat = static_cast<CLIPFORMAT>(::RegisterClipboardFormatA(pszFormatName));
    }
    else
    {
        *pcfFormat = static_cast<CLIPFORMAT>(::RegisterClipboardFormatW(pwszFormatName));
    }

    if (0 == *pcfFormat)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }

Cleanup:
    if (NULL != pszFormatName)
    {
        (void)::GlobalFree(pszFormatName);
    }
    return hr;
}

static HRESULT ANSIFromWideStr(WCHAR *pwszWideStr, char **ppszAnsi)
{
    HRESULT hr = S_OK;
    int     cchWideStr = (int)::wcslen(pwszWideStr);
    int     cchConverted = 0;

    *ppszAnsi = NULL;

    // get required buffer length

    int cchAnsi = ::WideCharToMultiByte(CP_ACP,      // code page - ANSI code page
                                        0,           // performance and mapping flags 
                                        pwszWideStr, // address of wide-character string 
                                        cchWideStr,  // number of characters in string 
                                        NULL,        // address of buffer for new string 
                                        0,           // size of buffer 
                                        NULL,        // address of default for unmappable characters 
                                        NULL         // address of flag set when default char. used 
                                       );
    if (cchAnsi == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Cleanup;
    }

    // allocate a buffer for the ANSI string
    *ppszAnsi = static_cast<char *>(::GlobalAlloc(GPTR, cchAnsi + 1));
    if (*ppszAnsi == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // now convert the string and copy it to the buffer
    cchConverted = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                         0,                    // performance and mapping flags 
                                         pwszWideStr,          // address of wide-character string 
                                         cchWideStr,           // number of characters in string 
                                         *ppszAnsi,             // address of buffer for new string 
                                         cchAnsi,              // size of buffer 
                                         NULL,                 // address of default for unmappable characters 
                                         NULL                  // address of flag set when default char. used 
                                        );
    if (cchConverted != cchAnsi)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Cleanup;
    }

    // add terminating null byte

    *((*ppszAnsi) + cchAnsi) = '\0';

Cleanup:
    if (FAILED(hr))
    {
        if (NULL != *ppszAnsi)
        {
            (void)::GlobalFree(*ppszAnsi);
            *ppszAnsi = NULL;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mmcproxy\stub_mmc_i.c ===
#include <mmc_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mmcproxy\stub_mmc_p.c ===
#include <mmc_p.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\include\wininet.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    wininet.h

Abstract:

    Contains manifests, macros, types and prototypes for Microsoft Windows
    Internet Extensions

--*/

#if !defined(_WININET_)
#define _WININET_

/*
 * Set up Structure Packing to be 4 bytes
 * for all wininet structures
 */

#pragma pack(push, wininet, 4)

#if defined(__cplusplus)
extern "C" {
#endif

#if !defined(_WINX32_)
#define INTERNETAPI DECLSPEC_IMPORT
#else
#define INTERNETAPI
#endif

//
// internet types
//

typedef LPVOID HINTERNET;
typedef HINTERNET * LPHINTERNET;

typedef WORD INTERNET_PORT;
typedef INTERNET_PORT * LPINTERNET_PORT;

//
// Internet APIs
//

//
// manifests
//

#define INTERNET_INVALID_PORT_NUMBER    0           // use the protocol-specific default

#define INTERNET_DEFAULT_FTP_PORT       21          // default for FTP servers
#define INTERNET_DEFAULT_GOPHER_PORT    70          //    "     "  gopher "
#define INTERNET_DEFAULT_HTTP_PORT      80          //    "     "  HTTP   "
#define INTERNET_DEFAULT_HTTPS_PORT     443         //    "     "  HTTPS  "
#define INTERNET_DEFAULT_SOCKS_PORT     1080        // default for SOCKS firewall servers.

#define MAX_CACHE_ENTRY_INFO_SIZE       4096

//
// maximum field lengths (arbitrary)
//

#define INTERNET_MAX_HOST_NAME_LENGTH   256
#define INTERNET_MAX_USER_NAME_LENGTH   128
#define INTERNET_MAX_PASSWORD_LENGTH    128
#define INTERNET_MAX_PORT_NUMBER_LENGTH 5           // INTERNET_PORT is unsigned short
#define INTERNET_MAX_PORT_NUMBER_VALUE  65535       // maximum unsigned short value
#define INTERNET_MAX_PATH_LENGTH        2048
#define INTERNET_MAX_PROTOCOL_NAME      "gopher"    // longest protocol name
#define INTERNET_MAX_URL_LENGTH         ((sizeof(INTERNET_MAX_PROTOCOL_NAME) - 1) \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)

//
// values returned by InternetQueryOption() with INTERNET_OPTION_KEEP_CONNECTION:
//

#define INTERNET_KEEP_ALIVE_UNKNOWN     ((DWORD)-1)
#define INTERNET_KEEP_ALIVE_ENABLED     1
#define INTERNET_KEEP_ALIVE_DISABLED    0

//
// flags returned by InternetQueryOption() with INTERNET_OPTION_REQUEST_FLAGS
//

#define INTERNET_REQFLAG_FROM_CACHE     0x00000001
#define INTERNET_REQFLAG_ASYNC          0x00000002

//
// flags common to open functions (not InternetOpen()):
//

#define INTERNET_FLAG_RELOAD            0x80000000  // retrieve the original item

//
// flags for InternetOpenUrl():
//

#define INTERNET_FLAG_RAW_DATA          0x40000000  // receive the item as raw data
#define INTERNET_FLAG_EXISTING_CONNECT  0x20000000  // do not create new connection object

//
// flags for InternetOpen():
//

#define INTERNET_FLAG_ASYNC             0x10000000  // this request is asynchronous (where supported)

//
// protocol-specific flags:
//

#define INTERNET_FLAG_PASSIVE           0x08000000  // used for FTP connections

//
// additional cache flags
//

#define INTERNET_FLAG_NO_CACHE_WRITE    0x04000000  // don't write this item to the cache
#define INTERNET_FLAG_DONT_CACHE        INTERNET_FLAG_NO_CACHE_WRITE

#define INTERNET_FLAG_MAKE_PERSISTENT   0x02000000  // make this item persistent in cache

#define INTERNET_FLAG_OFFLINE           0x01000000  // use offline semantics

//
// additional flags
//

#define INTERNET_FLAG_SECURE            0x00800000  // use PCT/SSL if applicable (HTTP)

#define INTERNET_FLAG_KEEP_CONNECTION   0x00400000  // use keep-alive semantics

#define INTERNET_FLAG_NO_AUTO_REDIRECT  0x00200000  // don't handle redirections automatically

#define INTERNET_FLAG_READ_PREFETCH     0x00100000  // do background read prefetch

#define INTERNET_FLAG_NO_COOKIES        0x00080000  // no automatic cookie handling

#define INTERNET_FLAG_NO_AUTH           0x00040000  // no automatic authentication handling

//
// Security Ignore Flags, Allow HttpOpenRequest to overide
//  Secure Channel (SSL/PCT) failures of the following types.
//

#define INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP   0x00008000 // ex: https:// to http://

#define INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS  0x00004000 // ex: http:// to https://

#define INTERNET_FLAG_IGNORE_CERT_DATE_INVALID  0x00002000 // expired X509 Cert.

#define INTERNET_FLAG_IGNORE_CERT_CN_INVALID    0x00001000 // bad common name in X509 Cert.

//more caching flags
#define INTERNET_FLAG_MUST_CACHE_REQUEST        0x00000010 // fails if unable to cache request
#define INTERNET_FLAG_RESYNCHRONIZE             0x00000800 // asking wininet to update an item if it is newer
#define INTERNET_FLAG_HYPERLINK                 0x00000400 // asking wininet to
                                                           //do hyperlinking semantic which works right for scripts
#define INTERNET_FLAG_NO_UI                     0x00000200

//
// flags for FTP
//

#define INTERNET_FLAG_TRANSFER_ASCII    FTP_TRANSFER_TYPE_ASCII
#define INTERNET_FLAG_TRANSFER_BINARY   FTP_TRANSFER_TYPE_BINARY

//
// flags field masks
//

#define SECURITY_INTERNET_MASK  (INTERNET_FLAG_IGNORE_CERT_CN_INVALID    |  \
                                 INTERNET_FLAG_IGNORE_CERT_DATE_INVALID  |  \
                                 INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS  |  \
                                 INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP   )

#define SECURITY_SET_MASK       SECURITY_INTERNET_MASK

#define INTERNET_FLAGS_MASK     (INTERNET_FLAG_RELOAD               \
                                | INTERNET_FLAG_RAW_DATA            \
                                | INTERNET_FLAG_EXISTING_CONNECT    \
                                | INTERNET_FLAG_ASYNC               \
                                | INTERNET_FLAG_PASSIVE             \
                                | INTERNET_FLAG_NO_CACHE_WRITE      \
                                | INTERNET_FLAG_MAKE_PERSISTENT     \
                                | INTERNET_FLAG_OFFLINE             \
                                | INTERNET_FLAG_SECURE              \
                                | INTERNET_FLAG_KEEP_CONNECTION     \
                                | INTERNET_FLAG_NO_AUTO_REDIRECT    \
                                | INTERNET_FLAG_READ_PREFETCH       \
                                | INTERNET_FLAG_NO_COOKIES          \
                                | INTERNET_FLAG_NO_AUTH             \
                                | SECURITY_INTERNET_MASK            \
                                | INTERNET_FLAG_TRANSFER_ASCII      \
                                | INTERNET_FLAG_TRANSFER_BINARY     \
                                | INTERNET_FLAG_RESYNCHRONIZE       \
                                | INTERNET_FLAG_MUST_CACHE_REQUEST  \
                                | INTERNET_FLAG_HYPERLINK           \
                                | INTERNET_FLAG_NO_UI               \
                                )

#define INTERNET_OPTIONS_MASK   (~INTERNET_FLAGS_MASK)

//
// INTERNET_NO_CALLBACK - if this value is presented as the dwContext parameter
// then no call-backs will be made for that API
//

#define INTERNET_NO_CALLBACK            0

//
// structures/types
//

//
// INTERNET_SCHEME - enumerated URL scheme type
//

typedef enum {
    INTERNET_SCHEME_PARTIAL = -2,
    INTERNET_SCHEME_UNKNOWN = -1,
    INTERNET_SCHEME_DEFAULT = 0,
    INTERNET_SCHEME_FTP,
    INTERNET_SCHEME_GOPHER,
    INTERNET_SCHEME_HTTP,
    INTERNET_SCHEME_HTTPS,
    INTERNET_SCHEME_FILE,
    INTERNET_SCHEME_NEWS,
    INTERNET_SCHEME_MAILTO,
    INTERNET_SCHEME_SOCKS,
    INTERNET_SCHEME_FIRST = INTERNET_SCHEME_FTP,
    INTERNET_SCHEME_LAST = INTERNET_SCHEME_SOCKS
} INTERNET_SCHEME, * LPINTERNET_SCHEME;

//
// INTERNET_ASYNC_RESULT - this structure is returned to the application via
// the callback with INTERNET_STATUS_REQUEST_COMPLETE. It is not sufficient to
// just return the result of the async operation. If the API failed then the
// app cannot call GetLastError() because the thread context will be incorrect.
// Both the value returned by the async API and any resultant error code are
// made available. The app need not check dwError if dwResult indicates that
// the API succeeded (in this case dwError will be ERROR_SUCCESS)
//

typedef struct {

    //
    // dwResult - the HINTERNET, DWORD or BOOL return code from an async API
    //

    DWORD dwResult;

    //
    // dwError - the error code if the API failed
    //

    DWORD dwError;
} INTERNET_ASYNC_RESULT, * LPINTERNET_ASYNC_RESULT;

//
// INTERNET_PREFETCH_STATUS -
//

typedef struct {

    //
    // dwStatus - status of download. See INTERNET_PREFETCH_ flags
    //

    DWORD dwStatus;

    //
    // dwSize - size of file downloaded so far
    //

    DWORD dwSize;
} INTERNET_PREFETCH_STATUS, * LPINTERNET_PREFETCH_STATUS;

//
// INTERNET_PREFETCH_STATUS - dwStatus values
//

#define INTERNET_PREFETCH_PROGRESS  0
#define INTERNET_PREFETCH_COMPLETE  1
#define INTERNET_PREFETCH_ABORTED   2

//
// INTERNET_PROXY_INFO - structure supplied with INTERNET_OPTION_PROXY to get/
// set proxy information on a InternetOpen() handle
//

typedef struct {

    //
    // dwAccessType - INTERNET_OPEN_TYPE_DIRECT, INTERNET_OPEN_TYPE_PROXY, or
    // INTERNET_OPEN_TYPE_PRECONFIG (set only)
    //

    DWORD dwAccessType;

    //
    // lpszProxy - proxy server list
    //

    LPCTSTR lpszProxy;

    //
    // lpszProxyBypass - proxy bypass list
    //

    LPCTSTR lpszProxyBypass;
} INTERNET_PROXY_INFO, * LPINTERNET_PROXY_INFO;

//
// INTERNET_VERSION_INFO - version information returned via
// InternetQueryOption(..., INTERNET_OPTION_VERSION, ...)
//

typedef struct {
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
} INTERNET_VERSION_INFO, * LPINTERNET_VERSION_INFO;

//
// URL_COMPONENTS - the constituent parts of an URL. Used in InternetCrackUrl()
// and InternetCreateUrl()
//
// For InternetCrackUrl(), if a pointer field and its corresponding length field
// are both 0 then that component is not returned; If the pointer field is NULL
// but the length field is not zero, then both the pointer and length fields are
// returned; if both pointer and corresponding length fields are non-zero then
// the pointer field points to a buffer where the component is copied. The
// component may be un-escaped, depending on dwFlags
//
// For InternetCreateUrl(), the pointer fields should be NULL if the component
// is not required. If the corresponding length field is zero then the pointer
// field is the address of a zero-terminated string. If the length field is not
// zero then it is the string length of the corresponding pointer field
//

typedef struct {
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPSTR   lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    INTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPSTR   lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    INTERNET_PORT nPort;        // converted port number
    LPSTR   lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPSTR   lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPSTR   lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPSTR   lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
} URL_COMPONENTSA, * LPURL_COMPONENTSA;
typedef struct {
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPWSTR  lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    INTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPWSTR  lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    INTERNET_PORT nPort;        // converted port number
    LPWSTR  lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPWSTR  lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPWSTR  lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPWSTR  lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
} URL_COMPONENTSW, * LPURL_COMPONENTSW;
#ifdef UNICODE
typedef URL_COMPONENTSW URL_COMPONENTS;
typedef LPURL_COMPONENTSW LPURL_COMPONENTS;
#else
typedef URL_COMPONENTSA URL_COMPONENTS;
typedef LPURL_COMPONENTSA LPURL_COMPONENTS;
#endif // UNICODE

//
// INTERNET_CERTIFICATE_INFO lpBuffer - contains the certificate returned from
// the server
//

typedef struct {

    //
    // ftExpiry - date the certificate expires.
    //

    FILETIME ftExpiry;

    //
    // ftStart - date the certificate becomes valid.
    //

    FILETIME ftStart;

    //
    // lpszSubjectInfo - the name of organization, site, and server
    //   the cert. was issued for.
    //

    LPTSTR lpszSubjectInfo;

    //
    // lpszIssuerInfo - the name of organization, site, and server
    //   the cert was issues by.
    //

    LPTSTR lpszIssuerInfo;

    //
    // lpszProtocolName - the name of the protocol used to provide the secure
    //   connection.
    //

    LPTSTR lpszProtocolName;

    //
    // lpszSignatureAlgName - the name of the algorithm used for signing
    //  the certificate.
    //

    LPTSTR lpszSignatureAlgName;

    //
    // lpszEncryptionAlgName - the name of the algorithm used for
    //  doing encryption over the secure channel (SSL/PCT) connection.
    //

    LPTSTR lpszEncryptionAlgName;

    //
    // dwKeySize - size of the key.
    //

    DWORD dwKeySize;

} INTERNET_CERTIFICATE_INFO, * LPINTERNET_CERTIFICATE_INFO;

//
// prototypes
//

INTERNETAPI
BOOL
WINAPI
InternetTimeFromSystemTime(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format
    OUT LPSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    );

//
// constants for InternetTimeFromSystemTime
//

#define INTERNET_RFC1123_FORMAT     0
#define INTERNET_RFC1123_BUFSIZE   30

INTERNETAPI
BOOL
WINAPI
InternetTimeToSystemTime(
    IN  LPCSTR lpszTime,         // NULL terminated string
    OUT SYSTEMTIME *pst,         // output in GMT time
    IN  DWORD dwReserved
    );

INTERNETAPI
BOOL
WINAPI
InternetDebugGetLocalTime(
    OUT SYSTEMTIME * pstLocalTime,
    OUT DWORD      * pdwReserved
);

INTERNETAPI
BOOL
WINAPI
InternetCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSA lpUrlComponents
    );
INTERNETAPI
BOOL
WINAPI
InternetCrackUrlW(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSW lpUrlComponents
    );
#ifdef UNICODE
#define InternetCrackUrl  InternetCrackUrlW
#else
#define InternetCrackUrl  InternetCrackUrlA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetCreateUrlA(
    IN LPURL_COMPONENTSA lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPSTR lpszUrl,
    IN OUT LPDWORD lpdwUrlLength
    );
INTERNETAPI
BOOL
WINAPI
InternetCreateUrlW(
    IN LPURL_COMPONENTSW lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPWSTR lpszUrl,
    IN OUT LPDWORD lpdwUrlLength
    );
#ifdef UNICODE
#define InternetCreateUrl  InternetCreateUrlW
#else
#define InternetCreateUrl  InternetCreateUrlA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetCanonicalizeUrlA(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
INTERNETAPI
BOOL
WINAPI
InternetCanonicalizeUrlW(
    IN LPCWSTR lpszUrl,
    OUT LPWSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetCanonicalizeUrl  InternetCanonicalizeUrlW
#else
#define InternetCanonicalizeUrl  InternetCanonicalizeUrlA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetCombineUrlA(
    IN LPCSTR lpszBaseUrl,
    IN LPCSTR lpszRelativeUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
INTERNETAPI
BOOL
WINAPI
InternetCombineUrlW(
    IN LPCWSTR lpszBaseUrl,
    IN LPCWSTR lpszRelativeUrl,
    OUT LPWSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetCombineUrl  InternetCombineUrlW
#else
#define InternetCombineUrl  InternetCombineUrlA
#endif // !UNICODE

//
// flags for InternetCrackUrl() and InternetCreateUrl()
//

#define ICU_ESCAPE      0x80000000  // (un)escape URL characters
#define ICU_USERNAME    0x40000000  // use internal username & password

//
// flags for InternetCanonicalizeUrl() and InternetCombineUrl()
//

#define ICU_NO_ENCODE   0x20000000  // Don't convert unsafe characters to escape sequence
#define ICU_DECODE      0x10000000  // Convert %XX escape sequences to characters
#define ICU_NO_META     0x08000000  // Don't convert .. etc. meta path sequences
#define ICU_ENCODE_SPACES_ONLY 0x04000000  // Encode spaces only
#define ICU_BROWSER_MODE 0x02000000 // Special encode/decode rules for browser

INTERNETAPI
HINTERNET
WINAPI
InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );
INTERNETAPI
HINTERNET
WINAPI
InternetOpenW(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetOpen  InternetOpenW
#else
#define InternetOpen  InternetOpenA
#endif // !UNICODE

//
// access types for InternetOpen()
//

#define INTERNET_OPEN_TYPE_PRECONFIG    0   // use registry configuration
#define INTERNET_OPEN_TYPE_DIRECT       1   // direct to net
#define INTERNET_OPEN_TYPE_PROXY        3   // via named proxy

#define PRE_CONFIG_INTERNET_ACCESS  INTERNET_OPEN_TYPE_PRECONFIG
#define LOCAL_INTERNET_ACCESS       INTERNET_OPEN_TYPE_DIRECT
#define GATEWAY_INTERNET_ACCESS     2   // Internet via gateway
#define CERN_PROXY_INTERNET_ACCESS  INTERNET_OPEN_TYPE_PROXY

INTERNETAPI
BOOL
WINAPI
InternetCloseHandle(
    IN HINTERNET hInternet
    );

INTERNETAPI
HINTERNET
WINAPI
InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
InternetConnectW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszUserName OPTIONAL,
    IN LPCWSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define InternetConnect  InternetConnectW
#else
#define InternetConnect  InternetConnectA
#endif // !UNICODE

//
// service types for InternetConnect()
//

#define INTERNET_SERVICE_FTP    1
#define INTERNET_SERVICE_GOPHER 2
#define INTERNET_SERVICE_HTTP   3

INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define InternetOpenUrl  InternetOpenUrlW
#else
#define InternetOpenUrl  InternetOpenUrlA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

INTERNETAPI
DWORD
WINAPI
InternetSetFilePointer(
    IN HINTERNET hFile,
    IN LONG  lDistanceToMove,
    IN PVOID pReserved,
    IN DWORD dwMoveMethod,
    IN DWORD dwContext
    );

INTERNETAPI
BOOL
WINAPI
InternetWriteFile(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    );

INTERNETAPI
BOOL
WINAPI
InternetQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

INTERNETAPI
BOOL
WINAPI
InternetFindNextFileA(
    IN HINTERNET hFind,
    OUT LPVOID lpvFindData
    );
INTERNETAPI
BOOL
WINAPI
InternetFindNextFileW(
    IN HINTERNET hFind,
    OUT LPVOID lpvFindData
    );
#ifdef UNICODE
#define InternetFindNextFile  InternetFindNextFileW
#else
#define InternetFindNextFile  InternetFindNextFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
INTERNETAPI
BOOL
WINAPI
InternetQueryOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define InternetQueryOption  InternetQueryOptionW
#else
#define InternetQueryOption  InternetQueryOptionA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );
INTERNETAPI
BOOL
WINAPI
InternetSetOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );
#ifdef UNICODE
#define InternetSetOption  InternetSetOptionW
#else
#define InternetSetOption  InternetSetOptionA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetSetOptionExA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    );
INTERNETAPI
BOOL
WINAPI
InternetSetOptionExW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetSetOptionEx  InternetSetOptionExW
#else
#define InternetSetOptionEx  InternetSetOptionExA
#endif // !UNICODE

//
// flags for InternetSetOptionEx()
//

#define ISO_GLOBAL      0x00000001  // modify option globally
#define ISO_REGISTRY    0x00000002  // write option to registry (where applicable)

#define ISO_VALID_FLAGS (ISO_GLOBAL | ISO_REGISTRY)

//
// options manifests for Internet{Query|Set}Option
//

#define INTERNET_OPTION_CALLBACK                1
#define INTERNET_OPTION_CONNECT_TIMEOUT         2
#define INTERNET_OPTION_CONNECT_RETRIES         3
#define INTERNET_OPTION_CONNECT_BACKOFF         4
#define INTERNET_OPTION_SEND_TIMEOUT            5
#define INTERNET_OPTION_CONTROL_SEND_TIMEOUT    INTERNET_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_RECEIVE_TIMEOUT         6
#define INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT INTERNET_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_DATA_SEND_TIMEOUT       7
#define INTERNET_OPTION_DATA_RECEIVE_TIMEOUT    8
#define INTERNET_OPTION_HANDLE_TYPE             9
#define INTERNET_OPTION_CONTEXT_VALUE           10
#define INTERNET_OPTION_LISTEN_TIMEOUT          11
#define INTERNET_OPTION_READ_BUFFER_SIZE        12
#define INTERNET_OPTION_WRITE_BUFFER_SIZE       13

#define INTERNET_OPTION_ASYNC_ID                15
#define INTERNET_OPTION_ASYNC_PRIORITY          16

#define INTERNET_OPTION_PARENT_HANDLE           21
#define INTERNET_OPTION_KEEP_CONNECTION         22
#define INTERNET_OPTION_REQUEST_FLAGS           23
#define INTERNET_OPTION_EXTENDED_ERROR          24

#define INTERNET_OPTION_OFFLINE_MODE            26
#define INTERNET_OPTION_CACHE_STREAM_HANDLE     27
#define INTERNET_OPTION_USERNAME                28
#define INTERNET_OPTION_PASSWORD                29
#define INTERNET_OPTION_ASYNC                   30
#define INTERNET_OPTION_SECURITY_FLAGS          31
#define INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT    32
#define INTERNET_OPTION_DATAFILE_NAME           33
#define INTERNET_OPTION_URL                     34
#define INTERNET_OPTION_SECURITY_CERTIFICATE    35
#define INTERNET_OPTION_SECURITY_KEY_BITNESS    36
#define INTERNET_OPTION_REFRESH                 37
#define INTERNET_OPTION_PROXY                   38
#define INTERNET_OPTION_SETTINGS_CHANGED        39
#define INTERNET_OPTION_VERSION                 40
#define INTERNET_OPTION_USER_AGENT              41

#define INTERNET_FIRST_OPTION                   INTERNET_OPTION_CALLBACK
#define INTERNET_LAST_OPTION                    INTERNET_OPTION_USER_AGENT

//
// values for INTERNET_OPTION_PRIORITY
//

#define INTERNET_PRIORITY_FOREGROUND            1000

//
// handle types
//

#define INTERNET_HANDLE_TYPE_INTERNET           1
#define INTERNET_HANDLE_TYPE_CONNECT_FTP        2
#define INTERNET_HANDLE_TYPE_CONNECT_GOPHER     3
#define INTERNET_HANDLE_TYPE_CONNECT_HTTP       4
#define INTERNET_HANDLE_TYPE_FTP_FIND           5
#define INTERNET_HANDLE_TYPE_FTP_FIND_HTML      6
#define INTERNET_HANDLE_TYPE_FTP_FILE           7
#define INTERNET_HANDLE_TYPE_FTP_FILE_HTML      8
#define INTERNET_HANDLE_TYPE_GOPHER_FIND        9
#define INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML   10
#define INTERNET_HANDLE_TYPE_GOPHER_FILE        11
#define INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML   12
#define INTERNET_HANDLE_TYPE_HTTP_REQUEST       13

//
// values for INTERNET_OPTION_SECURITY_FLAGS
//

#define SECURITY_FLAG_SECURE                    0x00000001 // can query only
#define SECURITY_FLAG_SSL                       0x00000002
#define SECURITY_FLAG_SSL3                      0x00000004
#define SECURITY_FLAG_PCT                       0x00000008
#define SECURITY_FLAG_PCT4                      0x00000010
#define SECURITY_FLAG_IETFSSL4                  0x00000020

#define SECURITY_FLAG_40BIT                     0x10000000
#define SECURITY_FLAG_128BIT                    0x20000000
#define SECURITY_FLAG_56BIT                     0x40000000
#define SECURITY_FLAG_UNKNOWNBIT                0x80000000
#define SECURITY_FLAG_NORMALBITNESS             SECURITY_FLAG_40BIT

#define SECURITY_FLAG_IGNORE_CERT_CN_INVALID    INTERNET_FLAG_IGNORE_CERT_CN_INVALID
#define SECURITY_FLAG_IGNORE_CERT_DATE_INVALID  INTERNET_FLAG_IGNORE_CERT_DATE_INVALID
#define SECURITY_FLAG_IGNORE_REDIRECT_TO_HTTPS  INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS
#define SECURITY_FLAG_IGNORE_REDIRECT_TO_HTTP   INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP

INTERNETAPI
BOOL
WINAPI
InternetGetLastResponseInfoA(
    OUT LPDWORD lpdwError,
    OUT LPSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
INTERNETAPI
BOOL
WINAPI
InternetGetLastResponseInfoW(
    OUT LPDWORD lpdwError,
    OUT LPWSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define InternetGetLastResponseInfo  InternetGetLastResponseInfoW
#else
#define InternetGetLastResponseInfo  InternetGetLastResponseInfoA
#endif // !UNICODE

//
// callback function for InternetSetStatusCallback
//

typedef
VOID
(CALLBACK * INTERNET_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN DWORD dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    );

typedef INTERNET_STATUS_CALLBACK * LPINTERNET_STATUS_CALLBACK;

INTERNETAPI
INTERNET_STATUS_CALLBACK
WINAPI
InternetSetStatusCallback(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    );

//
// status manifests for Internet status callback
//

#define INTERNET_STATUS_RESOLVING_NAME          10
#define INTERNET_STATUS_NAME_RESOLVED           11
#define INTERNET_STATUS_CONNECTING_TO_SERVER    20
#define INTERNET_STATUS_CONNECTED_TO_SERVER     21
#define INTERNET_STATUS_SENDING_REQUEST         30
#define INTERNET_STATUS_REQUEST_SENT            31
#define INTERNET_STATUS_RECEIVING_RESPONSE      40
#define INTERNET_STATUS_RESPONSE_RECEIVED       41
#define INTERNET_STATUS_CTL_RESPONSE_RECEIVED   42
#define INTERNET_STATUS_PREFETCH                43
#define INTERNET_STATUS_CLOSING_CONNECTION      50
#define INTERNET_STATUS_CONNECTION_CLOSED       51
#define INTERNET_STATUS_HANDLE_CREATED          60
#define INTERNET_STATUS_HANDLE_CLOSING          70
#define INTERNET_STATUS_REQUEST_COMPLETE        100
#define INTERNET_STATUS_REDIRECT                110

//
// if the following value is returned by InternetSetStatusCallback, then
// probably an invalid (non-code) address was supplied for the callback
//

#define INTERNET_INVALID_STATUS_CALLBACK        ((INTERNET_STATUS_CALLBACK)(-1L))

//
// FTP
//

//
// manifests
//

#define FTP_TRANSFER_TYPE_UNKNOWN   0x00000000
#define FTP_TRANSFER_TYPE_ASCII     0x00000001
#define FTP_TRANSFER_TYPE_BINARY    0x00000002

#define FTP_TRANSFER_TYPE_MASK      (FTP_TRANSFER_TYPE_ASCII | FTP_TRANSFER_TYPE_BINARY)

//
// prototypes
//

INTERNETAPI
HINTERNET
WINAPI
FtpFindFirstFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
FtpFindFirstFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpFindFirstFile  FtpFindFirstFileW
#else
#define FtpFindFirstFile  FtpFindFirstFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpGetFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszRemoteFile,
    IN LPCSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
FtpGetFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszRemoteFile,
    IN LPCWSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpGetFile  FtpGetFileW
#else
#define FtpGetFile  FtpGetFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpPutFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszLocalFile,
    IN LPCSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
FtpPutFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszLocalFile,
    IN LPCWSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpPutFile  FtpPutFileW
#else
#define FtpPutFile  FtpPutFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpDeleteFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszFileName
    );
INTERNETAPI
BOOL
WINAPI
FtpDeleteFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszFileName
    );
#ifdef UNICODE
#define FtpDeleteFile  FtpDeleteFileW
#else
#define FtpDeleteFile  FtpDeleteFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpRenameFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszExisting,
    IN LPCSTR lpszNew
    );
INTERNETAPI
BOOL
WINAPI
FtpRenameFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszExisting,
    IN LPCWSTR lpszNew
    );
#ifdef UNICODE
#define FtpRenameFile  FtpRenameFileW
#else
#define FtpRenameFile  FtpRenameFileA
#endif // !UNICODE

INTERNETAPI
HINTERNET
WINAPI
FtpOpenFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
FtpOpenFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpOpenFile  FtpOpenFileW
#else
#define FtpOpenFile  FtpOpenFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpCreateDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    );
INTERNETAPI
BOOL
WINAPI
FtpCreateDirectoryW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszDirectory
    );
#ifdef UNICODE
#define FtpCreateDirectory  FtpCreateDirectoryW
#else
#define FtpCreateDirectory  FtpCreateDirectoryA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpRemoveDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    );
INTERNETAPI
BOOL
WINAPI
FtpRemoveDirectoryW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszDirectory
    );
#ifdef UNICODE
#define FtpRemoveDirectory  FtpRemoveDirectoryW
#else
#define FtpRemoveDirectory  FtpRemoveDirectoryA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpSetCurrentDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    );
INTERNETAPI
BOOL
WINAPI
FtpSetCurrentDirectoryW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszDirectory
    );
#ifdef UNICODE
#define FtpSetCurrentDirectory  FtpSetCurrentDirectoryW
#else
#define FtpSetCurrentDirectory  FtpSetCurrentDirectoryA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpGetCurrentDirectoryA(
    IN HINTERNET hConnect,
    OUT LPSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    );
INTERNETAPI
BOOL
WINAPI
FtpGetCurrentDirectoryW(
    IN HINTERNET hConnect,
    OUT LPWSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    );
#ifdef UNICODE
#define FtpGetCurrentDirectory  FtpGetCurrentDirectoryW
#else
#define FtpGetCurrentDirectory  FtpGetCurrentDirectoryA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpCommandA(
    IN HINTERNET hConnect,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN LPCSTR lpszCommand,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
FtpCommandW(
    IN HINTERNET hConnect,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN LPCWSTR lpszCommand,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpCommand  FtpCommandW
#else
#define FtpCommand  FtpCommandA
#endif // !UNICODE

//
// Gopher
//

//
// manifests
//

//
// string field lengths (in characters, not bytes)
//

#define MAX_GOPHER_DISPLAY_TEXT     128
#define MAX_GOPHER_SELECTOR_TEXT    256
#define MAX_GOPHER_HOST_NAME        INTERNET_MAX_HOST_NAME_LENGTH
#define MAX_GOPHER_LOCATOR_LENGTH   (1                                  \
                                    + MAX_GOPHER_DISPLAY_TEXT           \
                                    + 1                                 \
                                    + MAX_GOPHER_SELECTOR_TEXT          \
                                    + 1                                 \
                                    + MAX_GOPHER_HOST_NAME              \
                                    + 1                                 \
                                    + INTERNET_MAX_PORT_NUMBER_LENGTH   \
                                    + 1                                 \
                                    + 1                                 \
                                    + 2                                 \
                                    )

//
// structures/types
//

//
// GOPHER_FIND_DATA - returns the results of a GopherFindFirstFile()/
// InternetFindNextFile() request
//

typedef struct {
    CHAR   DisplayString[MAX_GOPHER_DISPLAY_TEXT + 1];
    DWORD GopherType;   // GOPHER_TYPE_, if known
    DWORD SizeLow;
    DWORD SizeHigh;
    FILETIME LastModificationTime;
    CHAR   Locator[MAX_GOPHER_LOCATOR_LENGTH + 1];
} GOPHER_FIND_DATAA, * LPGOPHER_FIND_DATAA;
typedef struct {
    WCHAR  DisplayString[MAX_GOPHER_DISPLAY_TEXT + 1];
    DWORD GopherType;   // GOPHER_TYPE_, if known
    DWORD SizeLow;
    DWORD SizeHigh;
    FILETIME LastModificationTime;
    WCHAR  Locator[MAX_GOPHER_LOCATOR_LENGTH + 1];
} GOPHER_FIND_DATAW, * LPGOPHER_FIND_DATAW;
#ifdef UNICODE
typedef GOPHER_FIND_DATAW GOPHER_FIND_DATA;
typedef LPGOPHER_FIND_DATAW LPGOPHER_FIND_DATA;
#else
typedef GOPHER_FIND_DATAA GOPHER_FIND_DATA;
typedef LPGOPHER_FIND_DATAA LPGOPHER_FIND_DATA;
#endif // UNICODE

//
// manifests for GopherType
//

#define GOPHER_TYPE_TEXT_FILE       0x00000001
#define GOPHER_TYPE_DIRECTORY       0x00000002
#define GOPHER_TYPE_CSO             0x00000004
#define GOPHER_TYPE_ERROR           0x00000008
#define GOPHER_TYPE_MAC_BINHEX      0x00000010
#define GOPHER_TYPE_DOS_ARCHIVE     0x00000020
#define GOPHER_TYPE_UNIX_UUENCODED  0x00000040
#define GOPHER_TYPE_INDEX_SERVER    0x00000080
#define GOPHER_TYPE_TELNET          0x00000100
#define GOPHER_TYPE_BINARY          0x00000200
#define GOPHER_TYPE_REDUNDANT       0x00000400
#define GOPHER_TYPE_TN3270          0x00000800
#define GOPHER_TYPE_GIF             0x00001000
#define GOPHER_TYPE_IMAGE           0x00002000
#define GOPHER_TYPE_BITMAP          0x00004000
#define GOPHER_TYPE_MOVIE           0x00008000
#define GOPHER_TYPE_SOUND           0x00010000
#define GOPHER_TYPE_HTML            0x00020000
#define GOPHER_TYPE_PDF             0x00040000
#define GOPHER_TYPE_CALENDAR        0x00080000
#define GOPHER_TYPE_INLINE          0x00100000
#define GOPHER_TYPE_UNKNOWN         0x20000000
#define GOPHER_TYPE_ASK             0x40000000
#define GOPHER_TYPE_GOPHER_PLUS     0x80000000

//
// gopher type macros
//

#define IS_GOPHER_FILE(type)            (BOOL)(((type) & GOPHER_TYPE_FILE_MASK) ? TRUE : FALSE)
#define IS_GOPHER_DIRECTORY(type)       (BOOL)(((type) & GOPHER_TYPE_DIRECTORY) ? TRUE : FALSE)
#define IS_GOPHER_PHONE_SERVER(type)    (BOOL)(((type) & GOPHER_TYPE_CSO) ? TRUE : FALSE)
#define IS_GOPHER_ERROR(type)           (BOOL)(((type) & GOPHER_TYPE_ERROR) ? TRUE : FALSE)
#define IS_GOPHER_INDEX_SERVER(type)    (BOOL)(((type) & GOPHER_TYPE_INDEX_SERVER) ? TRUE : FALSE)
#define IS_GOPHER_TELNET_SESSION(type)  (BOOL)(((type) & GOPHER_TYPE_TELNET) ? TRUE : FALSE)
#define IS_GOPHER_BACKUP_SERVER(type)   (BOOL)(((type) & GOPHER_TYPE_REDUNDANT) ? TRUE : FALSE)
#define IS_GOPHER_TN3270_SESSION(type)  (BOOL)(((type) & GOPHER_TYPE_TN3270) ? TRUE : FALSE)
#define IS_GOPHER_ASK(type)             (BOOL)(((type) & GOPHER_TYPE_ASK) ? TRUE : FALSE)
#define IS_GOPHER_PLUS(type)            (BOOL)(((type) & GOPHER_TYPE_GOPHER_PLUS) ? TRUE : FALSE)

#define IS_GOPHER_TYPE_KNOWN(type)      (BOOL)(((type) & GOPHER_TYPE_UNKNOWN) ? FALSE : TRUE)

//
// GOPHER_TYPE_FILE_MASK - use this to determine if a locator identifies a
// (known) file type
//

#define GOPHER_TYPE_FILE_MASK       (GOPHER_TYPE_TEXT_FILE          \
                                    | GOPHER_TYPE_MAC_BINHEX        \
                                    | GOPHER_TYPE_DOS_ARCHIVE       \
                                    | GOPHER_TYPE_UNIX_UUENCODED    \
                                    | GOPHER_TYPE_BINARY            \
                                    | GOPHER_TYPE_GIF               \
                                    | GOPHER_TYPE_IMAGE             \
                                    | GOPHER_TYPE_BITMAP            \
                                    | GOPHER_TYPE_MOVIE             \
                                    | GOPHER_TYPE_SOUND             \
                                    | GOPHER_TYPE_HTML              \
                                    | GOPHER_TYPE_PDF               \
                                    | GOPHER_TYPE_CALENDAR          \
                                    | GOPHER_TYPE_INLINE            \
                                    )

//
// structured gopher attributes (as defined in gopher+ protocol document)
//

typedef struct {
    LPCTSTR Comment;
    LPCTSTR EmailAddress;
} GOPHER_ADMIN_ATTRIBUTE_TYPE, * LPGOPHER_ADMIN_ATTRIBUTE_TYPE;

typedef struct {
    FILETIME DateAndTime;
} GOPHER_MOD_DATE_ATTRIBUTE_TYPE, * LPGOPHER_MOD_DATE_ATTRIBUTE_TYPE;

typedef struct {
    DWORD Ttl;
} GOPHER_TTL_ATTRIBUTE_TYPE, * LPGOPHER_TTL_ATTRIBUTE_TYPE;

typedef struct {
    INT Score;
} GOPHER_SCORE_ATTRIBUTE_TYPE, * LPGOPHER_SCORE_ATTRIBUTE_TYPE;

typedef struct {
    INT LowerBound;
    INT UpperBound;
} GOPHER_SCORE_RANGE_ATTRIBUTE_TYPE, * LPGOPHER_SCORE_RANGE_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Site;
} GOPHER_SITE_ATTRIBUTE_TYPE, * LPGOPHER_SITE_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Organization;
} GOPHER_ORGANIZATION_ATTRIBUTE_TYPE, * LPGOPHER_ORGANIZATION_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Location;
} GOPHER_LOCATION_ATTRIBUTE_TYPE, * LPGOPHER_LOCATION_ATTRIBUTE_TYPE;

typedef struct {
    INT DegreesNorth;
    INT MinutesNorth;
    INT SecondsNorth;
    INT DegreesEast;
    INT MinutesEast;
    INT SecondsEast;
} GOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE, * LPGOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE;

typedef struct {
    INT Zone;
} GOPHER_TIMEZONE_ATTRIBUTE_TYPE, * LPGOPHER_TIMEZONE_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Provider;
} GOPHER_PROVIDER_ATTRIBUTE_TYPE, * LPGOPHER_PROVIDER_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Version;
} GOPHER_VERSION_ATTRIBUTE_TYPE, * LPGOPHER_VERSION_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR ShortAbstract;
    LPCTSTR AbstractFile;
} GOPHER_ABSTRACT_ATTRIBUTE_TYPE, * LPGOPHER_ABSTRACT_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR ContentType;
    LPCTSTR Language;
    DWORD Size;
} GOPHER_VIEW_ATTRIBUTE_TYPE, * LPGOPHER_VIEW_ATTRIBUTE_TYPE;

typedef struct {
    BOOL TreeWalk;
} GOPHER_VERONICA_ATTRIBUTE_TYPE, * LPGOPHER_VERONICA_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR QuestionType;
    LPCTSTR QuestionText;
} GOPHER_ASK_ATTRIBUTE_TYPE, * LPGOPHER_ASK_ATTRIBUTE_TYPE;

//
// GOPHER_UNKNOWN_ATTRIBUTE_TYPE - this is returned if we retrieve an attribute
// that is not specified in the current gopher/gopher+ documentation. It is up
// to the application to parse the information
//

typedef struct {
    LPCTSTR Text;
} GOPHER_UNKNOWN_ATTRIBUTE_TYPE, * LPGOPHER_UNKNOWN_ATTRIBUTE_TYPE;

//
// GOPHER_ATTRIBUTE_TYPE - returned in the user's buffer when an enumerated
// GopherGetAttribute call is made
//

typedef struct {
    DWORD CategoryId;   // e.g. GOPHER_CATEGORY_ID_ADMIN
    DWORD AttributeId;  // e.g. GOPHER_ATTRIBUTE_ID_ADMIN
    union {
        GOPHER_ADMIN_ATTRIBUTE_TYPE Admin;
        GOPHER_MOD_DATE_ATTRIBUTE_TYPE ModDate;
        GOPHER_TTL_ATTRIBUTE_TYPE Ttl;
        GOPHER_SCORE_ATTRIBUTE_TYPE Score;
        GOPHER_SCORE_RANGE_ATTRIBUTE_TYPE ScoreRange;
        GOPHER_SITE_ATTRIBUTE_TYPE Site;
        GOPHER_ORGANIZATION_ATTRIBUTE_TYPE Organization;
        GOPHER_LOCATION_ATTRIBUTE_TYPE Location;
        GOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE GeographicalLocation;
        GOPHER_TIMEZONE_ATTRIBUTE_TYPE TimeZone;
        GOPHER_PROVIDER_ATTRIBUTE_TYPE Provider;
        GOPHER_VERSION_ATTRIBUTE_TYPE Version;
        GOPHER_ABSTRACT_ATTRIBUTE_TYPE Abstract;
        GOPHER_VIEW_ATTRIBUTE_TYPE View;
        GOPHER_VERONICA_ATTRIBUTE_TYPE Veronica;
        GOPHER_ASK_ATTRIBUTE_TYPE Ask;
        GOPHER_UNKNOWN_ATTRIBUTE_TYPE Unknown;
    } AttributeType;
} GOPHER_ATTRIBUTE_TYPE, * LPGOPHER_ATTRIBUTE_TYPE;

#define MAX_GOPHER_CATEGORY_NAME    128     // arbitrary
#define MAX_GOPHER_ATTRIBUTE_NAME   128     //     "
#define MIN_GOPHER_ATTRIBUTE_LENGTH 256     //     "

//
// known gopher attribute categories. See below for ordinals
//

#define GOPHER_INFO_CATEGORY        TEXT("+INFO")
#define GOPHER_ADMIN_CATEGORY       TEXT("+ADMIN")
#define GOPHER_VIEWS_CATEGORY       TEXT("+VIEWS")
#define GOPHER_ABSTRACT_CATEGORY    TEXT("+ABSTRACT")
#define GOPHER_VERONICA_CATEGORY    TEXT("+VERONICA")

//
// known gopher attributes. These are the attribute names as defined in the
// gopher+ protocol document
//

#define GOPHER_ADMIN_ATTRIBUTE      TEXT("Admin")
#define GOPHER_MOD_DATE_ATTRIBUTE   TEXT("Mod-Date")
#define GOPHER_TTL_ATTRIBUTE        TEXT("TTL")
#define GOPHER_SCORE_ATTRIBUTE      TEXT("Score")
#define GOPHER_RANGE_ATTRIBUTE      TEXT("Score-range")
#define GOPHER_SITE_ATTRIBUTE       TEXT("Site")
#define GOPHER_ORG_ATTRIBUTE        TEXT("Org")
#define GOPHER_LOCATION_ATTRIBUTE   TEXT("Loc")
#define GOPHER_GEOG_ATTRIBUTE       TEXT("Geog")
#define GOPHER_TIMEZONE_ATTRIBUTE   TEXT("TZ")
#define GOPHER_PROVIDER_ATTRIBUTE   TEXT("Provider")
#define GOPHER_VERSION_ATTRIBUTE    TEXT("Version")
#define GOPHER_ABSTRACT_ATTRIBUTE   TEXT("Abstract")
#define GOPHER_VIEW_ATTRIBUTE       TEXT("View")
#define GOPHER_TREEWALK_ATTRIBUTE   TEXT("treewalk")

//
// identifiers for attribute strings
//

#define GOPHER_ATTRIBUTE_ID_BASE        0xabcccc00

#define GOPHER_CATEGORY_ID_ALL          (GOPHER_ATTRIBUTE_ID_BASE + 1)

#define GOPHER_CATEGORY_ID_INFO         (GOPHER_ATTRIBUTE_ID_BASE + 2)
#define GOPHER_CATEGORY_ID_ADMIN        (GOPHER_ATTRIBUTE_ID_BASE + 3)
#define GOPHER_CATEGORY_ID_VIEWS        (GOPHER_ATTRIBUTE_ID_BASE + 4)
#define GOPHER_CATEGORY_ID_ABSTRACT     (GOPHER_ATTRIBUTE_ID_BASE + 5)
#define GOPHER_CATEGORY_ID_VERONICA     (GOPHER_ATTRIBUTE_ID_BASE + 6)
#define GOPHER_CATEGORY_ID_ASK          (GOPHER_ATTRIBUTE_ID_BASE + 7)

#define GOPHER_CATEGORY_ID_UNKNOWN      (GOPHER_ATTRIBUTE_ID_BASE + 8)

#define GOPHER_ATTRIBUTE_ID_ALL         (GOPHER_ATTRIBUTE_ID_BASE + 9)

#define GOPHER_ATTRIBUTE_ID_ADMIN       (GOPHER_ATTRIBUTE_ID_BASE + 10)
#define GOPHER_ATTRIBUTE_ID_MOD_DATE    (GOPHER_ATTRIBUTE_ID_BASE + 11)
#define GOPHER_ATTRIBUTE_ID_TTL         (GOPHER_ATTRIBUTE_ID_BASE + 12)
#define GOPHER_ATTRIBUTE_ID_SCORE       (GOPHER_ATTRIBUTE_ID_BASE + 13)
#define GOPHER_ATTRIBUTE_ID_RANGE       (GOPHER_ATTRIBUTE_ID_BASE + 14)
#define GOPHER_ATTRIBUTE_ID_SITE        (GOPHER_ATTRIBUTE_ID_BASE + 15)
#define GOPHER_ATTRIBUTE_ID_ORG         (GOPHER_ATTRIBUTE_ID_BASE + 16)
#define GOPHER_ATTRIBUTE_ID_LOCATION    (GOPHER_ATTRIBUTE_ID_BASE + 17)
#define GOPHER_ATTRIBUTE_ID_GEOG        (GOPHER_ATTRIBUTE_ID_BASE + 18)
#define GOPHER_ATTRIBUTE_ID_TIMEZONE    (GOPHER_ATTRIBUTE_ID_BASE + 19)
#define GOPHER_ATTRIBUTE_ID_PROVIDER    (GOPHER_ATTRIBUTE_ID_BASE + 20)
#define GOPHER_ATTRIBUTE_ID_VERSION     (GOPHER_ATTRIBUTE_ID_BASE + 21)
#define GOPHER_ATTRIBUTE_ID_ABSTRACT    (GOPHER_ATTRIBUTE_ID_BASE + 22)
#define GOPHER_ATTRIBUTE_ID_VIEW        (GOPHER_ATTRIBUTE_ID_BASE + 23)
#define GOPHER_ATTRIBUTE_ID_TREEWALK    (GOPHER_ATTRIBUTE_ID_BASE + 24)

#define GOPHER_ATTRIBUTE_ID_UNKNOWN     (GOPHER_ATTRIBUTE_ID_BASE + 25)

//
// prototypes
//

INTERNETAPI
BOOL
WINAPI
GopherCreateLocatorA(
    IN LPCSTR lpszHost,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszDisplayString OPTIONAL,
    IN LPCSTR lpszSelectorString OPTIONAL,
    IN DWORD dwGopherType,
    OUT LPSTR lpszLocator OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
INTERNETAPI
BOOL
WINAPI
GopherCreateLocatorW(
    IN LPCWSTR lpszHost,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszDisplayString OPTIONAL,
    IN LPCWSTR lpszSelectorString OPTIONAL,
    IN DWORD dwGopherType,
    OUT LPWSTR lpszLocator OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define GopherCreateLocator  GopherCreateLocatorW
#else
#define GopherCreateLocator  GopherCreateLocatorA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
GopherGetLocatorTypeA(
    IN LPCSTR lpszLocator,
    OUT LPDWORD lpdwGopherType
    );
INTERNETAPI
BOOL
WINAPI
GopherGetLocatorTypeW(
    IN LPCWSTR lpszLocator,
    OUT LPDWORD lpdwGopherType
    );
#ifdef UNICODE
#define GopherGetLocatorType  GopherGetLocatorTypeW
#else
#define GopherGetLocatorType  GopherGetLocatorTypeA
#endif // !UNICODE

INTERNETAPI
HINTERNET
WINAPI
GopherFindFirstFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszLocator OPTIONAL,
    IN LPCSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATAA lpFindData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
GopherFindFirstFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszLocator OPTIONAL,
    IN LPCWSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATAW lpFindData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define GopherFindFirstFile  GopherFindFirstFileW
#else
#define GopherFindFirstFile  GopherFindFirstFileA
#endif // !UNICODE

INTERNETAPI
HINTERNET
WINAPI
GopherOpenFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszView OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
GopherOpenFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszLocator,
    IN LPCWSTR lpszView OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define GopherOpenFile  GopherOpenFileW
#else
#define GopherOpenFile  GopherOpenFileA
#endif // !UNICODE

typedef
BOOL
(CALLBACK * GOPHER_ATTRIBUTE_ENUMERATOR)(
    LPGOPHER_ATTRIBUTE_TYPE lpAttributeInfo,
    DWORD dwError
    );

INTERNETAPI
BOOL
WINAPI
GopherGetAttributeA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszAttributeName OPTIONAL,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwCharactersReturned,
    IN GOPHER_ATTRIBUTE_ENUMERATOR lpfnEnumerator OPTIONAL,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
GopherGetAttributeW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszLocator,
    IN LPCWSTR lpszAttributeName OPTIONAL,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwCharactersReturned,
    IN GOPHER_ATTRIBUTE_ENUMERATOR lpfnEnumerator OPTIONAL,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define GopherGetAttribute  GopherGetAttributeW
#else
#define GopherGetAttribute  GopherGetAttributeA
#endif // !UNICODE

//
// HTTP
//

//
// manifests
//

//
// the default major/minor HTTP version numbers
//

#define HTTP_MAJOR_VERSION      1
#define HTTP_MINOR_VERSION      0

#define HTTP_VERSION            TEXT("HTTP/1.0")

//
// HttpQueryInfo info levels. Generally, there is one info level
// for each potential RFC822/HTTP/MIME header that an HTTP server
// may send as part of a request response.
//
// The HTTP_QUERY_RAW_HEADERS info level is provided for clients
// that choose to perform their own header parsing.
//

#define HTTP_QUERY_MIME_VERSION                 0
#define HTTP_QUERY_CONTENT_TYPE                 1
#define HTTP_QUERY_CONTENT_TRANSFER_ENCODING    2
#define HTTP_QUERY_CONTENT_ID                   3
#define HTTP_QUERY_CONTENT_DESCRIPTION          4
#define HTTP_QUERY_CONTENT_LENGTH               5
#define HTTP_QUERY_CONTENT_LANGUAGE             6
#define HTTP_QUERY_ALLOW                        7
#define HTTP_QUERY_PUBLIC                       8
#define HTTP_QUERY_DATE                         9
#define HTTP_QUERY_EXPIRES                      10
#define HTTP_QUERY_LAST_MODIFIED                11
#define HTTP_QUERY_MESSAGE_ID                   12
#define HTTP_QUERY_URI                          13
#define HTTP_QUERY_DERIVED_FROM                 14
#define HTTP_QUERY_COST                         15
#define HTTP_QUERY_LINK                         16
#define HTTP_QUERY_PRAGMA                       17
#define HTTP_QUERY_VERSION                      18  // special: part of status line
#define HTTP_QUERY_STATUS_CODE                  19  // special: part of status line
#define HTTP_QUERY_STATUS_TEXT                  20  // special: part of status line
#define HTTP_QUERY_RAW_HEADERS                  21  // special: all headers as ASCIIZ
#define HTTP_QUERY_RAW_HEADERS_CRLF             22  // special: all headers
#define HTTP_QUERY_CONNECTION                   23
#define HTTP_QUERY_ACCEPT                       24
#define HTTP_QUERY_ACCEPT_CHARSET               25
#define HTTP_QUERY_ACCEPT_ENCODING              26
#define HTTP_QUERY_ACCEPT_LANGUAGE              27
#define HTTP_QUERY_AUTHORIZATION                28
#define HTTP_QUERY_CONTENT_ENCODING             29
#define HTTP_QUERY_FORWARDED                    30
#define HTTP_QUERY_FROM                         31
#define HTTP_QUERY_IF_MODIFIED_SINCE            32
#define HTTP_QUERY_LOCATION                     33
#define HTTP_QUERY_ORIG_URI                     34
#define HTTP_QUERY_REFERER                      35
#define HTTP_QUERY_RETRY_AFTER                  36
#define HTTP_QUERY_SERVER                       37
#define HTTP_QUERY_TITLE                        38
#define HTTP_QUERY_USER_AGENT                   39
#define HTTP_QUERY_WWW_AUTHENTICATE             40
#define HTTP_QUERY_PROXY_AUTHENTICATE           41
#define HTTP_QUERY_ACCEPT_RANGES                42
#define HTTP_QUERY_SET_COOKIE                   43
#define HTTP_QUERY_COOKIE                       44
#define HTTP_QUERY_REQUEST_METHOD               45  // special: GET/POST etc.

#define HTTP_QUERY_MAX                          45

//
// HTTP_QUERY_CUSTOM - if this special value is supplied as the dwInfoLevel
// parameter of HttpQueryInfo() then the lpBuffer parameter contains the name
// of the header we are to query
//

#define HTTP_QUERY_CUSTOM                       65535

//
// HTTP_QUERY_FLAG_REQUEST_HEADERS - if this bit is set in the dwInfoLevel
// parameter of HttpQueryInfo() then the request headers will be queried for the
// request information
//

#define HTTP_QUERY_FLAG_REQUEST_HEADERS         0x80000000

//
// HTTP_QUERY_FLAG_SYSTEMTIME - if this bit is set in the dwInfoLevel parameter
// of HttpQueryInfo() AND the header being queried contains date information,
// e.g. the "Expires:" header then lpBuffer will contain a SYSTEMTIME structure
// containing the date and time information converted from the header string
//

#define HTTP_QUERY_FLAG_SYSTEMTIME              0x40000000

//
// HTTP_QUERY_FLAG_NUMBER - if this bit is set in the dwInfoLevel parameter of
// HttpQueryInfo(), then the value of the header will be converted to a number
// before being returned to the caller, if applicable
//

#define HTTP_QUERY_FLAG_NUMBER                  0x20000000

//
// HTTP_QUERY_FLAG_COALESCE - combine the values from several headers of the
// same name into the output buffer
//

#define HTTP_QUERY_FLAG_COALESCE                0x10000000

#define HTTP_QUERY_MODIFIER_FLAGS_MASK          (HTTP_QUERY_FLAG_REQUEST_HEADERS    \
                                                | HTTP_QUERY_FLAG_SYSTEMTIME        \
                                                | HTTP_QUERY_FLAG_NUMBER            \
                                                | HTTP_QUERY_FLAG_COALESCE          \
                                                )

#define HTTP_QUERY_HEADER_MASK                  (~HTTP_QUERY_MODIFIER_FLAGS_MASK)

//
// HTTP Response Status Codes:
//

#define HTTP_STATUS_OK              200     // request completed
#define HTTP_STATUS_CREATED         201     // object created, reason = new URI
#define HTTP_STATUS_ACCEPTED        202     // async completion (TBS)
#define HTTP_STATUS_PARTIAL         203     // partial completion
#define HTTP_STATUS_NO_CONTENT      204     // no info to return

#define HTTP_STATUS_AMBIGUOUS       300     // server couldn't decide what to return
#define HTTP_STATUS_MOVED           301     // object permanently moved
#define HTTP_STATUS_REDIRECT        302     // object temporarily moved
#define HTTP_STATUS_REDIRECT_METHOD 303     // redirection w/ new access method
#define HTTP_STATUS_NOT_MODIFIED    304     // if-modified-since was not modified

#define HTTP_STATUS_BAD_REQUEST     400     // invalid syntax
#define HTTP_STATUS_DENIED          401     // access denied
#define HTTP_STATUS_PAYMENT_REQ     402     // payment required
#define HTTP_STATUS_FORBIDDEN       403     // request forbidden
#define HTTP_STATUS_NOT_FOUND       404     // object not found
#define HTTP_STATUS_BAD_METHOD      405     // method is not allowed
#define HTTP_STATUS_NONE_ACCEPTABLE 406     // no response acceptable to client found
#define HTTP_STATUS_PROXY_AUTH_REQ  407     // proxy authentication required
#define HTTP_STATUS_REQUEST_TIMEOUT 408     // server timed out waiting for request
#define HTTP_STATUS_CONFLICT        409     // user should resubmit with more info
#define HTTP_STATUS_GONE            410     // the resource is no longer available
#define HTTP_STATUS_AUTH_REFUSED    411     // couldn't authorize client

#define HTTP_STATUS_SERVER_ERROR    500     // internal server error
#define HTTP_STATUS_NOT_SUPPORTED   501     // required not supported
#define HTTP_STATUS_BAD_GATEWAY     502     // error response received from gateway
#define HTTP_STATUS_SERVICE_UNAVAIL 503     // temporarily overloaded
#define HTTP_STATUS_GATEWAY_TIMEOUT 504     // timed out waiting for gateway

//
// prototypes
//

INTERNETAPI
HINTERNET
WINAPI
HttpOpenRequestA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb,
    IN LPCSTR lpszObjectName,
    IN LPCSTR lpszVersion,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
HttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define HttpOpenRequest  HttpOpenRequestW
#else
#define HttpOpenRequest  HttpOpenRequestA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
HttpAddRequestHeadersA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );
INTERNETAPI
BOOL
WINAPI
HttpAddRequestHeadersW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );
#ifdef UNICODE
#define HttpAddRequestHeaders  HttpAddRequestHeadersW
#else
#define HttpAddRequestHeaders  HttpAddRequestHeadersA
#endif // !UNICODE

//
// values for dwModifiers parameter of HttpAddRequestHeaders()
//

#define HTTP_ADDREQ_INDEX_MASK      0x0000FFFF
#define HTTP_ADDREQ_FLAGS_MASK      0xFFFF0000

//
// HTTP_ADDREQ_FLAG_ADD_IF_NEW - the header will only be added if it doesn't
// already exist
//

#define HTTP_ADDREQ_FLAG_ADD_IF_NEW 0x10000000

//
// HTTP_ADDREQ_FLAG_ADD - if HTTP_ADDREQ_FLAG_REPLACE is set but the header is
// not found then if this flag is set, the header is added anyway, so long as
// there is a valid header-value
//

#define HTTP_ADDREQ_FLAG_ADD        0x20000000

//
// HTTP_ADDREQ_FLAG_COALESCE - coalesce headers with same name. e.g.
// "Accept: text/*" and "Accept: audio/*" with this flag results in a single
// header: "Accept: text/*, audio/*"
//

//
// HTTP_ADDREQ_FLAG_COALESCE - coalesce headers with same name. e.g.
// "Accept: text/*" and "Accept: audio/*" with this flag results in a single
// header: "Accept: text/*, audio/*"
//

#define HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA       0x40000000

#define HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON   0x01000000

#define HTTP_ADDREQ_FLAG_COALESCE                  HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA

//
// HTTP_ADDREQ_FLAG_REPLACE - replaces the specified header. Only one header can
// be supplied in the buffer. If the header to be replaced is not the first
// in a list of headers with the same name, then the relative index should be
// supplied in the low 8 bits of the dwModifiers parameter. If the header-value
// part is missing, then the header is removed
//

#define HTTP_ADDREQ_FLAG_REPLACE    0x80000000

INTERNETAPI
BOOL
WINAPI
HttpSendRequestA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );
INTERNETAPI
BOOL
WINAPI
HttpSendRequestW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );
#ifdef UNICODE
#define HttpSendRequest  HttpSendRequestW
#else
#define HttpSendRequest  HttpSendRequestA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
HttpQueryInfoA(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );
INTERNETAPI
BOOL
WINAPI
HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );
#ifdef UNICODE
#define HttpQueryInfo  HttpQueryInfoW
#else
#define HttpQueryInfo  HttpQueryInfoA
#endif // !UNICODE

//
// Cookie APIs
//

INTERNETAPI
BOOL
WINAPI
InternetSetCookieA(
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszCookieName,
    IN LPCSTR lpszCookieData
    );
INTERNETAPI
BOOL
WINAPI
InternetSetCookieW(
    IN LPCSTR lpszUrl,
    IN LPCWSTR lpszCookieName,
    IN LPCWSTR lpszCookieData
    );
#ifdef UNICODE
#define InternetSetCookie  InternetSetCookieW
#else
#define InternetSetCookie  InternetSetCookieA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetGetCookieA(
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszCookieName,
    OUT LPSTR lpCookieData,
    IN OUT LPDWORD lpdwSize
    );
INTERNETAPI
BOOL
WINAPI
InternetGetCookieW(
    IN LPCSTR lpszUrl,
    IN LPCWSTR lpszCookieName,
    OUT LPWSTR lpCookieData,
    IN OUT LPDWORD lpdwSize
    );
#ifdef UNICODE
#define InternetGetCookie  InternetGetCookieW
#else
#define InternetGetCookie  InternetGetCookieA
#endif // !UNICODE

//
// offline browsing
//

INTERNETAPI
DWORD
WINAPI
InternetAttemptConnect(
    DWORD dwReserved
    );

//
// Internet UI
//

//
// InternetErrorDlg - Provides UI for certain Errors.
//

#define FLAGS_ERROR_UI_FILTER_FOR_ERRORS        0x01
#define FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS     0x02
#define FLAGS_ERROR_UI_FLAGS_GENERATE_DATA      0x04
#define FLAGS_ERROR_UI_FLAGS_NO_UI              0x08

INTERNETAPI
DWORD
WINAPI
InternetErrorDlg(
     IN HWND hWnd,
     IN OUT HINTERNET hRequest,
     IN DWORD dwError,
     IN DWORD dwFlags,
     IN OUT LPVOID * lppvData
     );

INTERNETAPI
DWORD
WINAPI
InternetConfirmZoneCrossing(
     IN HWND hWnd,
     IN LPSTR szUrlPrev,
     IN LPSTR szUrlNew,
     IN BOOL bPost
     );

//#if !defined(_WINERROR_)

//
// Internet API error returns
//

#define INTERNET_ERROR_BASE                     12000

#define ERROR_INTERNET_OUT_OF_HANDLES           (INTERNET_ERROR_BASE + 1)
#define ERROR_INTERNET_TIMEOUT                  (INTERNET_ERROR_BASE + 2)
#define ERROR_INTERNET_EXTENDED_ERROR           (INTERNET_ERROR_BASE + 3)
#define ERROR_INTERNET_INTERNAL_ERROR           (INTERNET_ERROR_BASE + 4)
#define ERROR_INTERNET_INVALID_URL              (INTERNET_ERROR_BASE + 5)
#define ERROR_INTERNET_UNRECOGNIZED_SCHEME      (INTERNET_ERROR_BASE + 6)
#define ERROR_INTERNET_NAME_NOT_RESOLVED        (INTERNET_ERROR_BASE + 7)
#define ERROR_INTERNET_PROTOCOL_NOT_FOUND       (INTERNET_ERROR_BASE + 8)
#define ERROR_INTERNET_INVALID_OPTION           (INTERNET_ERROR_BASE + 9)
#define ERROR_INTERNET_BAD_OPTION_LENGTH        (INTERNET_ERROR_BASE + 10)
#define ERROR_INTERNET_OPTION_NOT_SETTABLE      (INTERNET_ERROR_BASE + 11)
#define ERROR_INTERNET_SHUTDOWN                 (INTERNET_ERROR_BASE + 12)
#define ERROR_INTERNET_INCORRECT_USER_NAME      (INTERNET_ERROR_BASE + 13)
#define ERROR_INTERNET_INCORRECT_PASSWORD       (INTERNET_ERROR_BASE + 14)
#define ERROR_INTERNET_LOGIN_FAILURE            (INTERNET_ERROR_BASE + 15)
#define ERROR_INTERNET_INVALID_OPERATION        (INTERNET_ERROR_BASE + 16)
#define ERROR_INTERNET_OPERATION_CANCELLED      (INTERNET_ERROR_BASE + 17)
#define ERROR_INTERNET_INCORRECT_HANDLE_TYPE    (INTERNET_ERROR_BASE + 18)
#define ERROR_INTERNET_INCORRECT_HANDLE_STATE   (INTERNET_ERROR_BASE + 19)
#define ERROR_INTERNET_NOT_PROXY_REQUEST        (INTERNET_ERROR_BASE + 20)
#define ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND (INTERNET_ERROR_BASE + 21)
#define ERROR_INTERNET_BAD_REGISTRY_PARAMETER   (INTERNET_ERROR_BASE + 22)
#define ERROR_INTERNET_NO_DIRECT_ACCESS         (INTERNET_ERROR_BASE + 23)
#define ERROR_INTERNET_NO_CONTEXT               (INTERNET_ERROR_BASE + 24)
#define ERROR_INTERNET_NO_CALLBACK              (INTERNET_ERROR_BASE + 25)
#define ERROR_INTERNET_REQUEST_PENDING          (INTERNET_ERROR_BASE + 26)
#define ERROR_INTERNET_INCORRECT_FORMAT         (INTERNET_ERROR_BASE + 27)
#define ERROR_INTERNET_ITEM_NOT_FOUND           (INTERNET_ERROR_BASE + 28)
#define ERROR_INTERNET_CANNOT_CONNECT           (INTERNET_ERROR_BASE + 29)
#define ERROR_INTERNET_CONNECTION_ABORTED       (INTERNET_ERROR_BASE + 30)
#define ERROR_INTERNET_CONNECTION_RESET         (INTERNET_ERROR_BASE + 31)
#define ERROR_INTERNET_FORCE_RETRY              (INTERNET_ERROR_BASE + 32)
#define ERROR_INTERNET_INVALID_PROXY_REQUEST    (INTERNET_ERROR_BASE + 33)
#define ERROR_INTERNET_NEED_UI                  (INTERNET_ERROR_BASE + 34)

#define ERROR_INTERNET_HANDLE_EXISTS            (INTERNET_ERROR_BASE + 36)
#define ERROR_INTERNET_SEC_CERT_DATE_INVALID    (INTERNET_ERROR_BASE + 37)
#define ERROR_INTERNET_SEC_CERT_CN_INVALID      (INTERNET_ERROR_BASE + 38)
#define ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR   (INTERNET_ERROR_BASE + 39)
#define ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR   (INTERNET_ERROR_BASE + 40)
#define ERROR_INTERNET_MIXED_SECURITY           (INTERNET_ERROR_BASE + 41)
#define ERROR_INTERNET_CHG_POST_IS_NON_SECURE   (INTERNET_ERROR_BASE + 42)
#define ERROR_INTERNET_POST_IS_NON_SECURE       (INTERNET_ERROR_BASE + 43)
#define ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED  (INTERNET_ERROR_BASE + 44)
#define ERROR_INTERNET_INVALID_CA               (INTERNET_ERROR_BASE + 45)
#define ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP    (INTERNET_ERROR_BASE + 46)
#define ERROR_INTERNET_ASYNC_THREAD_FAILED      (INTERNET_ERROR_BASE + 47)
#define ERROR_INTERNET_REDIRECT_SCHEME_CHANGE   (INTERNET_ERROR_BASE + 48)

//
// FTP API errors
//

#define ERROR_FTP_TRANSFER_IN_PROGRESS          (INTERNET_ERROR_BASE + 110)
#define ERROR_FTP_DROPPED                       (INTERNET_ERROR_BASE + 111)

//
// gopher API errors
//

#define ERROR_GOPHER_PROTOCOL_ERROR             (INTERNET_ERROR_BASE + 130)
#define ERROR_GOPHER_NOT_FILE                   (INTERNET_ERROR_BASE + 131)
#define ERROR_GOPHER_DATA_ERROR                 (INTERNET_ERROR_BASE + 132)
#define ERROR_GOPHER_END_OF_DATA                (INTERNET_ERROR_BASE + 133)
#define ERROR_GOPHER_INVALID_LOCATOR            (INTERNET_ERROR_BASE + 134)
#define ERROR_GOPHER_INCORRECT_LOCATOR_TYPE     (INTERNET_ERROR_BASE + 135)
#define ERROR_GOPHER_NOT_GOPHER_PLUS            (INTERNET_ERROR_BASE + 136)
#define ERROR_GOPHER_ATTRIBUTE_NOT_FOUND        (INTERNET_ERROR_BASE + 137)
#define ERROR_GOPHER_UNKNOWN_LOCATOR            (INTERNET_ERROR_BASE + 138)

//
// HTTP API errors
//

#define ERROR_HTTP_HEADER_NOT_FOUND             (INTERNET_ERROR_BASE + 150)
#define ERROR_HTTP_DOWNLEVEL_SERVER             (INTERNET_ERROR_BASE + 151)
#define ERROR_HTTP_INVALID_SERVER_RESPONSE      (INTERNET_ERROR_BASE + 152)
#define ERROR_HTTP_INVALID_HEADER               (INTERNET_ERROR_BASE + 153)
#define ERROR_HTTP_INVALID_QUERY_REQUEST        (INTERNET_ERROR_BASE + 154)
#define ERROR_HTTP_HEADER_ALREADY_EXISTS        (INTERNET_ERROR_BASE + 155)
#define ERROR_HTTP_REDIRECT_FAILED              (INTERNET_ERROR_BASE + 156)
#define ERROR_HTTP_NOT_REDIRECTED               (INTERNET_ERROR_BASE + 160) // BUGBUG

#define ERROR_INTERNET_SECURITY_CHANNEL_ERROR   (INTERNET_ERROR_BASE + 157) // BUGBUG
#define ERROR_INTERNET_UNABLE_TO_CACHE_FILE     (INTERNET_ERROR_BASE + 158) // BUGBUG
#define ERROR_INTERNET_TCPIP_NOT_INSTALLED      (INTERNET_ERROR_BASE + 159) // BUGBUG

#define INTERNET_ERROR_LAST                     ERROR_INTERNET_TCPIP_NOT_INSTALLED

//#endif // !defined(_WINERROR_)

//
// URLCACHE APIs
//

#if !defined(_WINX32_) && !defined(_URLCACHEAPI_)
#define URLCACHEAPI DECLSPEC_IMPORT
#else
#define URLCACHEAPI
#endif

//
// datatype definitions.
//

//
// cache entry type flags.
//

#define NORMAL_CACHE_ENTRY      0x00000001
#define STABLE_CACHE_ENTRY      0x00000002
#define STICKY_CACHE_ENTRY      0x00000004

#define SPARSE_CACHE_ENTRY      0x00010000
#define OCX_CACHE_ENTRY         0x00020000

#define COOKIE_CACHE_ENTRY      0x00100000
#define URLHISTORY_CACHE_ENTRY  0x00200000

//
// INTERNET_CACHE_ENTRY_INFO -
//

typedef struct _INTERNET_CACHE_ENTRY_INFOA {
    DWORD dwStructSize;         // version of cache system. 
    LPSTR lpszSourceUrlName;    // embedded pointer to the URL name string.
    LPSTR   lpszLocalFileName;  // embedded pointer to the local file name.
    DWORD CacheEntryType;       // cache type bit mask.
    DWORD dwUseCount;           // current users count of the cache entry.
    DWORD dwHitRate;            // num of times the cache entry was retrieved.
    DWORD dwSizeLow;            // low DWORD of the file size.
    DWORD dwSizeHigh;           // high DWORD of the file size.
    FILETIME LastModifiedTime;  // last modified time of the file in GMT format.
    FILETIME ExpireTime;        // expire time of the file in GMT format
    FILETIME LastAccessTime;    // last accessed time in GMT format
    FILETIME LastSyncTime;      // last time the URL was synchronized
                                // with the source
    LPBYTE lpHeaderInfo;        // embedded pointer to the header info.
    DWORD dwHeaderInfoSize;     // size of the above header.
    LPSTR   lpszFileExtension;  // File extension used to retrieve the urldata as a file.
    DWORD dwReserved;           // reserved for future use.
} INTERNET_CACHE_ENTRY_INFOA, * LPINTERNET_CACHE_ENTRY_INFOA;
typedef struct _INTERNET_CACHE_ENTRY_INFOW {
    DWORD dwStructSize;         // version of cache system. 
    LPSTR lpszSourceUrlName;    // embedded pointer to the URL name string.
    LPWSTR  lpszLocalFileName;  // embedded pointer to the local file name.
    DWORD CacheEntryType;       // cache type bit mask.
    DWORD dwUseCount;           // current users count of the cache entry.
    DWORD dwHitRate;            // num of times the cache entry was retrieved.
    DWORD dwSizeLow;            // low DWORD of the file size.
    DWORD dwSizeHigh;           // high DWORD of the file size.
    FILETIME LastModifiedTime;  // last modified time of the file in GMT format.
    FILETIME ExpireTime;        // expire time of the file in GMT format
    FILETIME LastAccessTime;    // last accessed time in GMT format
    FILETIME LastSyncTime;      // last time the URL was synchronized
                                // with the source
    LPBYTE lpHeaderInfo;        // embedded pointer to the header info.
    DWORD dwHeaderInfoSize;     // size of the above header.
    LPWSTR  lpszFileExtension;  // File extension used to retrieve the urldata as a file.
    DWORD dwReserved;           // reserved for future use.
} INTERNET_CACHE_ENTRY_INFOW, * LPINTERNET_CACHE_ENTRY_INFOW;
#ifdef UNICODE
typedef INTERNET_CACHE_ENTRY_INFOW INTERNET_CACHE_ENTRY_INFO;
typedef LPINTERNET_CACHE_ENTRY_INFOW LPINTERNET_CACHE_ENTRY_INFO;
#else
typedef INTERNET_CACHE_ENTRY_INFOA INTERNET_CACHE_ENTRY_INFO;
typedef LPINTERNET_CACHE_ENTRY_INFOA LPINTERNET_CACHE_ENTRY_INFO;
#endif // UNICODE

//
// Cache APIs
//

URLCACHEAPI
BOOL
WINAPI
CreateUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCSTR lpszFileExtension,
    OUT LPSTR lpszFileName,
    IN DWORD dwReserved
    );
URLCACHEAPI
BOOL
WINAPI
CreateUrlCacheEntryW(
    IN LPCSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCSTR lpszFileExtension,
    OUT LPWSTR lpszFileName,
    IN DWORD dwReserved
    );
#ifdef UNICODE
#define CreateUrlCacheEntry  CreateUrlCacheEntryW
#else
#define CreateUrlCacheEntry  CreateUrlCacheEntryA
#endif // !UNICODE

URLCACHEAPI
BOOL
WINAPI
CommitUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN LPCSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCSTR lpszFileExtension,
    IN DWORD dwReserved
    );
URLCACHEAPI
BOOL
WINAPI
CommitUrlCacheEntryW(
    IN LPCSTR lpszUrlName,
    IN LPCWSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCWSTR lpszFileExtension,
    IN DWORD dwReserved
    );
#ifdef UNICODE
#define CommitUrlCacheEntry  CommitUrlCacheEntryW
#else
#define CommitUrlCacheEntry  CommitUrlCacheEntryA
#endif // !UNICODE

URLCACHEAPI
BOOL
WINAPI
RetrieveUrlCacheEntryFileA(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    );
URLCACHEAPI
BOOL
WINAPI
RetrieveUrlCacheEntryFileW(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    );
#ifdef UNICODE
#define RetrieveUrlCacheEntryFile  RetrieveUrlCacheEntryFileW
#else
#define RetrieveUrlCacheEntryFile  RetrieveUrlCacheEntryFileA
#endif // !UNICODE

URLCACHEAPI
BOOL
WINAPI
UnlockUrlCacheEntryFile(
    IN LPCSTR lpszUrlName,
    IN DWORD dwReserved
    );

URLCACHEAPI
HANDLE
WINAPI
RetrieveUrlCacheEntryStreamA(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    );
URLCACHEAPI
HANDLE
WINAPI
RetrieveUrlCacheEntryStreamW(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    );
#ifdef UNICODE
#define RetrieveUrlCacheEntryStream  RetrieveUrlCacheEntryStreamW
#else
#define RetrieveUrlCacheEntryStream  RetrieveUrlCacheEntryStreamA
#endif // !UNICODE

URLCACHEAPI
BOOL
WINAPI
ReadUrlCacheEntryStream(
    IN HANDLE hUrlCacheStream,
    IN DWORD dwLocation,
    IN OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwLen,
    IN DWORD Reserved
    );

URLCACHEAPI
BOOL
WINAPI
UnlockUrlCacheEntryStream(
    IN HANDLE hUrlCacheStream,
    IN DWORD Reserved
    );

URLCACHEAPI
BOOL
WINAPI
GetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    );
URLCACHEAPI
BOOL
WINAPI
GetUrlCacheEntryInfoW(
    IN LPCSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    );
#ifdef UNICODE
#define GetUrlCacheEntryInfo  GetUrlCacheEntryInfoW
#else
#define GetUrlCacheEntryInfo  GetUrlCacheEntryInfoA
#endif // !UNICODE

#define CACHE_ENTRY_ATTRIBUTE_FC    0x00000004
#define CACHE_ENTRY_HITRATE_FC      0x00000010
#define CACHE_ENTRY_MODTIME_FC      0x00000040
#define CACHE_ENTRY_EXPTIME_FC      0x00000080
#define CACHE_ENTRY_ACCTIME_FC      0x00000100
#define CACHE_ENTRY_SYNCTIME_FC     0x00000200
#define CACHE_ENTRY_HEADERINFO_FC   0x00000400

URLCACHEAPI
BOOL
WINAPI
SetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN DWORD dwFieldControl
    );
URLCACHEAPI
BOOL
WINAPI
SetUrlCacheEntryInfoW(
    IN LPCSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN DWORD dwFieldControl
    );
#ifdef UNICODE
#define SetUrlCacheEntryInfo  SetUrlCacheEntryInfoW
#else
#define SetUrlCacheEntryInfo  SetUrlCacheEntryInfoA
#endif // !UNICODE

URLCACHEAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryA(
    IN LPCSTR lpszUrlSearchPattern,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpdwFirstCacheEntryInfoBufferSize
    );
URLCACHEAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryW(
    IN LPCSTR lpszUrlSearchPattern,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpdwFirstCacheEntryInfoBufferSize
    );
#ifdef UNICODE
#define FindFirstUrlCacheEntry  FindFirstUrlCacheEntryW
#else
#define FindFirstUrlCacheEntry  FindFirstUrlCacheEntryA
#endif // !UNICODE

URLCACHEAPI
BOOL
WINAPI
FindNextUrlCacheEntryA(
    IN HANDLE hEnumHandle,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpNextCacheEntryInfo,
    IN OUT LPDWORD lpdwNextCacheEntryInfoBufferSize
    );
URLCACHEAPI
BOOL
WINAPI
FindNextUrlCacheEntryW(
    IN HANDLE hEnumHandle,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpNextCacheEntryInfo,
    IN OUT LPDWORD lpdwNextCacheEntryInfoBufferSize
    );
#ifdef UNICODE
#define FindNextUrlCacheEntry  FindNextUrlCacheEntryW
#else
#define FindNextUrlCacheEntry  FindNextUrlCacheEntryA
#endif // !UNICODE

URLCACHEAPI
BOOL
WINAPI
FindCloseUrlCache(
    IN HANDLE hEnumHandle
    );

URLCACHEAPI
BOOL
WINAPI
DeleteUrlCacheEntry(
    IN LPCSTR lpszUrlName
    );

#if defined(__cplusplus)
}
#endif

/*
 * Return packing to whatever it was before we
 * entered this file
 */
#pragma pack(pop, wininet)

#endif // !defined(_WININET_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mmcproxy\stub_dlldata.c ===
#include <dlldata.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\autoexep.h ===
class CAutomationException
{
    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\ambients.cpp ===
//=--------------------------------------------------------------------------=
// ambients.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Class implementation for CAmbients.
//

#include "pch.h"
#include "common.h"
#include "ambients.h"

// for ASSERT and FAIL
//
SZTHISFILE


CAmbients::CAmbients()
{
    m_pDispAmbient = NULL;
}

CAmbients::~CAmbients()
{
    Detach();
}

void CAmbients::Attach(IDispatch *pDispAmbients)
{
    Detach();
    if (pDispAmbients != NULL)
    {
        pDispAmbients->AddRef();
    }
    m_pDispAmbient = pDispAmbients;
}

void CAmbients::Detach()
{
    RELEASE(m_pDispAmbient);
}

IDispatch *CAmbients::GetDispatch()
{
    return m_pDispAmbient;
}

HRESULT CAmbients::GetProjectDirectory(BSTR *pbstrProjDir)
{
    HRESULT hr = S_OK;
    hr = GetAmbientProperty(DISPID_AMBIENT_PROJECTDIRECTORY,
                            VT_BSTR,
                            pbstrProjDir);
    IfFailGo(hr);

Error:
    if (FAILED(hr))
    {
        *pbstrProjDir = NULL;
    }
    return hr;
}

HRESULT CAmbients::GetDesignerName(BSTR *pbstrName)
{
    HRESULT hr = S_OK;
    hr = GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME,
                            VT_BSTR,
                            pbstrName);
    IfFailGo(hr);

Error:
    if (FAILED(hr))
    {
        *pbstrName = NULL;
    }
    return hr;
}

HRESULT CAmbients::GetSaveMode(long *plSaveMode)
{
    HRESULT hr = S_OK;
    hr = GetAmbientProperty(DISPID_AMBIENT_SAVEMODE,
                            VT_I4,
                            plSaveMode);
    IfFailGo(hr);

Error:
    if (FAILED(hr))
    {
        *plSaveMode = DESIGNERSAVEMODE_NORMAL;
    }
    return hr;
}


HRESULT CAmbients::GetAmbientProperty
(
    DISPID   dispid,
    VARTYPE  vtRequested,
    void    *pvData
)
{
    DISPPARAMS dispparams;
    ::ZeroMemory(&dispparams, sizeof(dispparams));
    VARIANT varProperty;
    ::VariantInit(&varProperty);
    VARIANT varRequested;
    ::VariantInit(&varRequested);
    HRESULT hr = S_OK;

    IfFalseGo(NULL != m_pDispAmbient, E_UNEXPECTED);
    // Get the property

    hr = m_pDispAmbient->Invoke(dispid, IID_NULL, 0,
                                 DISPATCH_PROPERTYGET, &dispparams,
                                 &varProperty, NULL, NULL);
    IfFailGo(hr);

    // we've got the variant, so now go an coerce it to the type that the user
    // wants.  if the types are the same, then this will copy the stuff to
    // do appropriate ref counting ...
    //
    hr = ::VariantChangeType(&varRequested, &varProperty, 0, vtRequested);
    IfFailGo(hr);

    // copy the data to where the user wants it
    //

    switch (vtRequested)
    {
        case VT_UI1:
            *(BYTE *)pvData = varRequested.bVal;
            break;

        case VT_I2:
            *(short *)pvData = varRequested.iVal;
            break;

        case VT_I4:
            *(long *)pvData = varRequested.lVal;
            break;

        case VT_R4:
            *(FLOAT *)pvData = varRequested.fltVal;
            break;

        case VT_R8:
            *(DOUBLE *)pvData = varRequested.dblVal;
            break;

        case VT_DATE:
            ::memcpy((DATE *)pvData, &varRequested.date, sizeof(varRequested.date));
            break;

        case VT_CY:
            *(CY *)pvData = varRequested.cyVal;
            break;

        case VT_BSTR:
            *(BSTR *)pvData = varRequested.bstrVal;
            break;

        case VT_DISPATCH:
            *(LPDISPATCH *)pvData = varRequested.pdispVal;
            break;

        case VT_ERROR:
            *(SCODE *)pvData = varRequested.scode;
            break;

        case VT_BOOL:
            *(BOOL *)pvData = varRequested.boolVal;
            break;

        case VT_VARIANT:
            *(VARIANT *)pvData = varRequested;
            break;

        case VT_UNKNOWN:
            *(IUnknown **)pvData = varRequested.punkVal;
            break;

        default:
            hr = E_INVALIDARG;
            break;
    };

Error:
    if (FAILED(hr))
    {
        ::VariantClear(&varRequested);
    }
    ::VariantClear(&varProperty);
    return hr;
}

//---------------------------------------------------------------------------------------
// HRESULT CAmbients::GetProjectName
//---------------------------------------------------------------------------------------
//  Output
//      S_OK
//      E_OUTOFMEMORY
//
//  Notes
//      Returns the project name by parsing the ProgID
//      ambient
//
HRESULT CAmbients::GetProjectName
(
    BSTR *pbstrProjectName
)
{
    HRESULT hr = S_OK;
    BSTR bstrProgID = NULL;
    LPWSTR pwsz = NULL;
    BSTR bstrProjectName = NULL;
    BOOL fRet = FALSE;

    hr = GetAmbientProperty(DISPID_AMBIENT_PROGID, VT_BSTR, &bstrProgID);
    IfFailGo(hr);

    pwsz = ::wcschr(bstrProgID, L'.');   
    IfFalseGo(pwsz != NULL, E_UNEXPECTED);

    *pwsz = L'\0';

    bstrProjectName = ::SysAllocString(bstrProgID);
    IfFalseGo(NULL != bstrProjectName, E_OUTOFMEMORY);

    *pbstrProjectName = bstrProjectName;

Error:

    if (FAILED(hr))
    {
        *pbstrProjectName = NULL;
    }
    FREESTRING(bstrProgID);

    return hr;
}

HRESULT CAmbients::GetInteractive(BOOL *pfInteractive)
{
    HRESULT      hr = S_OK;
    BOOL fvarInteractive = VARIANT_FALSE;

    *pfInteractive = FALSE;

    // To ensure a good COleControl::m_pDispAmbient we need to fetch a
    // property as that is when the framework initializes it. There is no
    // particular reason for getting this property as opposed to some other.

    IfFailGo(GetAmbientProperty(DISPID_AMBIENT_INTERACTIVE,
                                VT_BOOL,
                                &fvarInteractive));

    if (VARIANT_TRUE == fvarInteractive)
    {
        *pfInteractive = TRUE;
    }

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mmcproxy\proxy.c ===
//=--------------------------------------------------------------------------=
// proxy.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// MMC Interfcace Proxy and Stub Functions
//
//=--------------------------------------------------------------------------=
// This file contains proxy and stub functions for MMC methods that are not
// remotable using a MIDL generated proxy and stub. Non-remotable methods have
// parameters that are ambiguous i.e. can be casted to different data types.
// For example, IComponentData::Notify() is passed an event and two additional
// LPARAM arguments that are interpreted according to the event. Sometimes an
// LPARAM contains a simple value such as a long or two BOOLs and sometimes it
// contains an IDataObject *. MIDL doesn't know the difference between
// MMCN_SELECT and MMCN_PRINT so we need to write some code to help out.
// 
// The version of MMC.IDL in the designer directory has added a [local]
// attribute to all non-remotable methods. In addition, an extra method has
// been added to the same interface that is a remotable version of the method.
// The remotable version has more parameters and represents the union of all
// possible interpretations of the ambiguous parameter. For example,
// IExtendControlbar::ControlbarNotify() is defined as:
// 
//    [helpstring("User actions"), local]
//    HRESULT ControlbarNotify([in] MMC_NOTIFY_TYPE event,
//                             [in] LPARAM arg, [in] LPARAM param);
// 
// This method can receive MMCN_SELECT, MMCN_BTN_CLICK, and MMCN_MENU_BTNCLICK.
// The union of all possible parameter types is used in the following method
// added to that interface:
// 
// 
//    HRESULT RemControlbarNotify([in] MMC_NOTIFY_TYPE event,
//                                [in] LPARAM lparam, 
//                                [in] IDataObject *piDataObject,
//                                [in] MENUBUTTONDATA *MenuButtonData);
// 
// Note, that normal, in-proc, non-remoted versions of IExtendControlbar do not
// have this extra method in their vtable because no one is going to call it.
// It is only used in the MILD generated proxy object.
// 
// In order to tell MIDL which method remotes ControlbarNotify() an attribute
// control file (ACF) is used. The entry in the ACF for IExtendControlbar is:
// 
// interface IExtendControlbar 
// {
//     [call_as (ControlbarNotify)]
//             RemControlbarNotify();
// 
// }
// 
// This says that RemControlbarNotify should be called when remoting
// ControlbarNotify(). MIDL generates the proxy/stub code as usual but it only
// generates the prototypes for ControlbarNotify proxy and stub. We have to
// write these routines. 
// 
// When a remote client has an IExtendControlbarNotify pointer it actually
// points into the proxy vtable. MIDL sets the ControlbarNotify entry pointing to
// our IExtendControlbar_ControlbarNotify_Proxy() function below. That function
// interprets the parameters and then calls the MIDL generated
// IExtendControlbar_RemControlbarNotify_Proxy() that packs up the parameters
// and sends them off to the server. If a parameters is not applicable, (e.g.
// MMCN_SELECT does not receive a pointer to a MENUBUTTONDATA stuct), then a
// pointer to an empty struct or zeroes are sent.
// 
// When the packet reaches the server side the MIDL generated
// IExtendControlbar_RemControlbarNotify_Stub() unpacks them and then calls our
// IExtendControlbar_ControlbarNotify_Stub() passing it the parameters and the
// IExtendControlbar pointer into the server. This function interprets the
// parameters and then calls ControlbarNotify in the server.
// 
//=--------------------------------------------------------------------------=

#include "mmc.h"

extern HRESULT GetClipboardFormat
(
    WCHAR      *pwszFormatName,
    CLIPFORMAT *pcfFormat
);

extern HRESULT CreateMultiSelDataObject
(
    IDataObject          **ppiDataObjects,
    long                   cDataObjects,
    IDataObject          **ppiMultiSelDataObject
);


static HRESULT MenuButtonClickProxy
( 
    IExtendControlbar __RPC_FAR *This,
    IDataObject                 *piDataObject,
    MENUBUTTONDATA              *pMenuButtonData
);

static HRESULT IsMultiSelect(IDataObject *piDataObject, BOOL *pfMultiSelect)
{
    HRESULT    hr = S_OK;
    DWORD     *pdwMultiSelect = NULL;
    BOOL       fGotData = FALSE;
    FORMATETC  FmtEtc;
    STGMEDIUM  StgMed;

    ZeroMemory(&FmtEtc, sizeof(FmtEtc));
    ZeroMemory(&StgMed, sizeof(StgMed));

    *pfMultiSelect = FALSE;

    if (NULL == piDataObject)
    {
        goto Cleanup;
    }

    if (IS_SPECIAL_DATAOBJECT(piDataObject))
    {
        goto Cleanup;
    }

    hr = GetClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT, &FmtEtc.cfFormat);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    FmtEtc.dwAspect  = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_HGLOBAL;
    StgMed.tymed = TYMED_HGLOBAL;

    hr = piDataObject->lpVtbl->GetData(piDataObject, &FmtEtc, &StgMed);
    if (SUCCEEDED(hr))
    {
        fGotData = TRUE;
    }
    else
    {
        hr = S_OK;
    }

    // Ignore any failures and assume that it is not multi-select. Snap-ins
    // should return DV_E_FORMATETC or DV_E_CLIPFORMAT but in practice that
    // is not the case. For example, the IIS snap-in returns E_NOTIMPL.
    // It would be impossible to cover the range of reasonable return codes so
    // we treat any error as format not supported.

    if (fGotData)
    {
        pdwMultiSelect = (DWORD *)GlobalLock(StgMed.hGlobal);

        if ((DWORD)1 == *pdwMultiSelect)
        {
            *pfMultiSelect = TRUE;
        }
    }

Cleanup:
    if (NULL != pdwMultiSelect)
    {
        (void)GlobalUnlock(StgMed.hGlobal);
    }

    if (fGotData)
    {
        ReleaseStgMedium(&StgMed);
    }
    return hr;
}




static HRESULT InterpretMultiSelect
(
    IDataObject     *piDataObject,
    long            *pcDataObjects,
    IDataObject   ***pppiDataObjects
)
{
    HRESULT          hr = S_OK;
    SMMCDataObjects *pMMCDataObjects = NULL;
    BOOL             fGotData = FALSE;
    size_t           cbObjectTypes = 0;
    long             i = 0;
    FORMATETC        FmtEtc;
    STGMEDIUM        StgMed;

    ZeroMemory(&FmtEtc, sizeof(FmtEtc));
    ZeroMemory(&StgMed, sizeof(StgMed));

    *pcDataObjects = 0;
    *pppiDataObjects = NULL;

    // Get the SMMCDataObjects structure from MMC

    hr = GetClipboardFormat(CCF_MULTI_SELECT_SNAPINS, &FmtEtc.cfFormat);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    FmtEtc.dwAspect  = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_HGLOBAL;
    StgMed.tymed = TYMED_HGLOBAL;

    hr = piDataObject->lpVtbl->GetData(piDataObject, &FmtEtc, &StgMed);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    fGotData = TRUE;

    pMMCDataObjects = (SMMCDataObjects *)GlobalLock(StgMed.hGlobal);
    if (NULL == pMMCDataObjects)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    // Allocate an array of IDataObject and copy the IDataObjects to it

    *pcDataObjects = pMMCDataObjects->count;
    *pppiDataObjects = (IDataObject **)GlobalAlloc(GPTR,
                               pMMCDataObjects->count * sizeof(IDataObject *));

    if (NULL == *pppiDataObjects)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    for (i = 0; i < *pcDataObjects; i++)
    {
        (*pppiDataObjects)[i] = pMMCDataObjects->lpDataObject[i];
    }

Cleanup:
    if (NULL != pMMCDataObjects)
    {
        (void)GlobalUnlock(StgMed.hGlobal);
    }

    if (fGotData)
    {
        ReleaseStgMedium(&StgMed);
    }

    return hr;
}


void CheckForSpecialDataObjects
(
    IDataObject **ppiDataObject,
    BOOL         *pfSpecialDataObject,
    long         *plSpecialDataObject
)
{
    long lSpecialDataObject = (long)(*ppiDataObject);

    if (IS_SPECIAL_DATAOBJECT(lSpecialDataObject))
    {
        *plSpecialDataObject = lSpecialDataObject;
        *ppiDataObject = NULL;
        *pfSpecialDataObject = TRUE;
    }
    else
    {
        *pfSpecialDataObject = FALSE;
    }
}

static HRESULT SetRemote(IUnknown *This)
{
    HRESULT     hr = S_OK;
    IMMCRemote *piMMCRemote = NULL;
    DWORD       cbFileName = 0;
    char        szModuleFileName[MAX_PATH] = "";

    // Call IMMCRemote methods: ObjectIsRemote and SetMMCExePath so that the
    // snap-in will know it is remote and so that it will have MMC.EXE's full
    // path in order to build taskpad display strings.

    hr = This->lpVtbl->QueryInterface(This, &IID_IMMCRemote,
                                      (void **)&piMMCRemote);
    if (FAILED(hr))
    {
        // If the object doesn't support IMMCRemote that is not an error.
        // The designer runtime will get this QI on both its main object and
        // its IComponent object but only the main object needs to support the
        // interface.
        hr = S_OK;
        goto Cleanup;
    }

    hr = piMMCRemote->lpVtbl->ObjectIsRemote(piMMCRemote);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    cbFileName = GetModuleFileName(NULL, // get executable that loaded us (MMC)
                                   szModuleFileName,
                                   sizeof(szModuleFileName));

    if (0 == cbFileName)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    hr = piMMCRemote->lpVtbl->SetMMCExePath(piMMCRemote, szModuleFileName);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = piMMCRemote->lpVtbl->SetMMCCommandLine(piMMCRemote, GetCommandLine());
    if (FAILED(hr))
    {
        goto Cleanup;
    }

Cleanup:
    if (NULL != piMMCRemote)
    {
        piMMCRemote->lpVtbl->Release(piMMCRemote);
    }

    return hr;
}




HRESULT STDMETHODCALLTYPE IExtendControlbar_SetControlbar_Proxy
( 
    IExtendControlbar __RPC_FAR *This,
    LPCONTROLBAR                 pControlbar
)
{
    HRESULT hr = S_OK;

    // Make sure the snap-in knows we are remoted. We do this here because
    // this is the first opportunity for the proxy to inform a toolbar
    // extension that it is remote.

    hr = SetRemote((IUnknown *)This);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = IExtendControlbar_RemSetControlbar_Proxy(This, pControlbar);

Cleanup:
    return hr;
}




HRESULT STDMETHODCALLTYPE IExtendControlbar_SetControlbar_Stub
( 
    IExtendControlbar __RPC_FAR  *This,
    LPCONTROLBAR                  pControlbar
)
{
    return This->lpVtbl->SetControlbar(This, pControlbar);
}


HRESULT STDMETHODCALLTYPE IExtendControlbar_ControlbarNotify_Proxy
( 
    IExtendControlbar __RPC_FAR *This,
    MMC_NOTIFY_TYPE              event,
    LPARAM                       arg,
    LPARAM                       param
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject  *piDataObject = NULL; // Not AddRef()ed
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // If this is not a menu button click then we can use the generated remoting
    // code with the arg and param unions

    if (MMCN_MENU_BTNCLICK == event)
    {
        hr = MenuButtonClickProxy(This,
                                  (IDataObject *)arg,
                                  (MENUBUTTONDATA *)param);
        goto Cleanup;
    }
    // Get any IDataObject associated with the event

    switch (event)
    {
        case MMCN_SELECT:
            piDataObject = (IDataObject *)param;
            break;

        case MMCN_BTN_CLICK:
            piDataObject = (IDataObject *)arg;
            break;

        default:
            piDataObject = NULL;
            break;
    }

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects,
                                  &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendControlbar_RemControlbarNotify_Proxy(This,
                                                     cDataObjects,
                                                     ppiDataObjects,
                                                     fSpecialDataObject,
                                                     lSpecialDataObject,
                                                     event, arg, param);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}




HRESULT STDMETHODCALLTYPE IExtendControlbar_ControlbarNotify_Stub
( 
    IExtendControlbar __RPC_FAR  *This,
    long                          cDataObjects,
    IDataObject                 **ppiDataObjects,
    BOOL                          fSpecialDataObject,
    long                          lSpecialDataObject,
    MMC_NOTIFY_TYPE               event,
    LPARAM                        arg,
    LPARAM                        param
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Put the IDataObject into the corresponding parameter for the event

    switch (event)
    {
        case MMCN_SELECT:
            param = (LPARAM)piDataObject;
            break;

        case MMCN_BTN_CLICK:
            arg = (LPARAM)piDataObject;
            break;

        default:
            break;
    }

    // Call into the snap-in with all parameters appearing as they would
    // when in-proc.

    hr = This->lpVtbl->ControlbarNotify(This, event, arg, param);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}


static HRESULT MenuButtonClickProxy
( 
    IExtendControlbar __RPC_FAR *This,
    IDataObject                 *piDataObject,
    MENUBUTTONDATA              *pMenuButtonData
)
{
    HRESULT                   hr = S_OK;
    POPUP_MENUDEF            *pPopupMenuDef = NULL;
    HMENU                     hMenu = NULL;
    UINT                      uiSelectedItemID = 0;
    IExtendControlbarRemote  *piECRemote = NULL;
    long                      i = 0;
    BOOL                      fIsMultiSelect = FALSE;
    long                      cDataObjects = 1L;
    IDataObject             **ppiDataObjects = NULL;


    // The generated remoting cannot easily handle what we need to do so we get
    // IExtendControlbarRemote on the snap-in. This interface has methods that
    // allow us to ask the snap-in for its popup menu items, display the menu
    // here on the MMC side, and then tell the snap-in which item was selected.

    hr = This->lpVtbl->QueryInterface(This, &IID_IExtendControlbarRemote,
                                      (void **)&piECRemote);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Tell the snap-in about the menu button click and get back its list of
    // popup menu items.

    hr = piECRemote->lpVtbl->MenuButtonClick(piECRemote,
                                             piDataObject,
                                             pMenuButtonData->idCommand,
                                             &pPopupMenuDef);     

    if ( FAILED(hr) || (NULL == pPopupMenuDef) )
    {
        goto Cleanup;
    }

    // Create an empty Win32 menu

    hMenu = CreatePopupMenu();
    if (NULL == hMenu)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    // Iterate through each of the items and add them to the menu

    for (i = 0; i < pPopupMenuDef->cMenuItems; i++)
    {
        if (!AppendMenu(hMenu,
                        pPopupMenuDef->MenuItems[i].uiFlags,
                        pPopupMenuDef->MenuItems[i].uiItemID,
                        pPopupMenuDef->MenuItems[i].pszItemText))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
    }

    // If the owner HWND is NULL then this is an extension and it does not have
    // access to IConsole2 on MMC to get the main frame HWND. In this case just
    // use the active window on this thread.

    if (NULL == pPopupMenuDef->hwndMenuOwner)
    {
        pPopupMenuDef->hwndMenuOwner = GetActiveWindow();
    }

    // Display the popup menu and wait for a selection.

    uiSelectedItemID = (UINT)TrackPopupMenu(
       hMenu,                        // menu to display
       TPM_LEFTALIGN |               // align left side of menu with x
       TPM_TOPALIGN  |               // align top of menu with y
       TPM_NONOTIFY  |               // don't send any messages during selection
       TPM_RETURNCMD |               // make the ret val the selected item
       TPM_LEFTBUTTON,               // allow selection with left button only
       pMenuButtonData->x,           // left side coordinate
       pMenuButtonData->y,           // top coordinate
       0,                            // reserved,
       pPopupMenuDef->hwndMenuOwner, // owner window, this comes from snap-in
                                     // as it can call IConsole2->GetMainWindow
       NULL);                        // not used

    // A zero return could indicate either an error or that the user hit
    // Escape or clicked off of the menu to cancel the operation. GetLastError()
    // determines whether there was an error. Either way we're done but set the
    // hr first.

    if (0 == uiSelectedItemID)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    // If i is non-zero then it contains the ID of the selected item.
    // Tell the snap-in what was selected and pass it the extra IUnknown it
    // included in its menu definition (this is snap-in defined and it allows
    // the snap-in to include some more identifying information to handle the
    // event).

    if (0 != uiSelectedItemID)
    {
        hr = piECRemote->lpVtbl->PopupMenuClick(
                                              piECRemote,
                                              piDataObject,
                                              uiSelectedItemID,
                                              pPopupMenuDef->punkSnapInDefined);
    }

Cleanup:

    if (NULL != piECRemote)
    {
        piECRemote->lpVtbl->Release(piECRemote);
    }
    if (NULL != hMenu)
    {
        (void)DestroyMenu(hMenu);
    }

    if (NULL != pPopupMenuDef)
    {
        for (i = 0; i < pPopupMenuDef->cMenuItems; i++)
        {
            if (NULL != pPopupMenuDef->MenuItems[i].pszItemText)
            {
                CoTaskMemFree(pPopupMenuDef->MenuItems[i].pszItemText);
            }
        }
        if (NULL != pPopupMenuDef->punkSnapInDefined)
        {
            pPopupMenuDef->punkSnapInDefined->lpVtbl->Release(pPopupMenuDef->punkSnapInDefined);
        }
        CoTaskMemFree(pPopupMenuDef);
    }

    return hr;
}



HRESULT STDMETHODCALLTYPE IExtendControlbarRemote_MenuButtonClick_Proxy
( 
    IExtendControlbarRemote __RPC_FAR  *This,
    IDataObject __RPC_FAR              *piDataObject,
    int                                 idCommand,
    POPUP_MENUDEF __RPC_FAR *__RPC_FAR *ppPopupMenuDef
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendControlbarRemote_RemMenuButtonClick_Proxy(This,
                                                          cDataObjects,
                                                          ppiDataObjects,
                                                          fSpecialDataObject,
                                                          lSpecialDataObject,
                                                          idCommand,
                                                          ppPopupMenuDef);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}




HRESULT STDMETHODCALLTYPE IExtendControlbarRemote_MenuButtonClick_Stub
( 
    IExtendControlbarRemote __RPC_FAR  *This,
    long                                cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR    ppiDataObjects[  ],
    BOOL                                fSpecialDataObject,
    long                                lSpecialDataObject,
    int                                 idCommand,
    POPUP_MENUDEF __RPC_FAR *__RPC_FAR *ppPopupMenuDef
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->MenuButtonClick(This, piDataObject,
                                       idCommand, ppPopupMenuDef);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendControlbarRemote_PopupMenuClick_Proxy
(
    IExtendControlbarRemote __RPC_FAR *This,
    IDataObject __RPC_FAR             *piDataObject,
    UINT                               uIDItem,
    IUnknown __RPC_FAR                *punkParam
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendControlbarRemote_RemPopupMenuClick_Proxy(This,
                                                         cDataObjects,
                                                         ppiDataObjects,
                                                         fSpecialDataObject,
                                                         lSpecialDataObject,
                                                         uIDItem,
                                                         punkParam);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendControlbarRemote_PopupMenuClick_Stub
(
    IExtendControlbarRemote __RPC_FAR *This,
    long                               cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR   ppiDataObjects[  ],
    BOOL                               fSpecialDataObject,
    long                               lSpecialDataObject,
    UINT                               uIDItem,
    IUnknown __RPC_FAR                *punkParam
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->PopupMenuClick(This, piDataObject, uIDItem, punkParam);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IComponentData_Initialize_Proxy
( 
    IComponentData  *This,
    LPUNKNOWN        pUnknown
)
{
    HRESULT hr = S_OK;

    // Tell the object it is remote and give the path to mmc.exe

    hr = SetRemote((IUnknown *)This);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Now pass on the Initiaize call normally. Using this order allows a snap-in
    // to know it is remote prior to its IComponentData::Initialize in case it
    // needs that information up front.

    hr = IComponentData_RemInitialize_Proxy(This, pUnknown);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

Cleanup:

    return hr;
}


HRESULT STDMETHODCALLTYPE IComponentData_Initialize_Stub
( 
    IComponentData *This,
    LPUNKNOWN       pUnknown
)
{
    return This->lpVtbl->Initialize(This, pUnknown);
}



HRESULT STDMETHODCALLTYPE IComponentData_CreateComponent_Proxy
( 
    IComponentData *This,
    LPCOMPONENT    *ppComponent
)
{
    HRESULT hr = S_OK;

    // Tell the object it is remote and give the path to mmc.exe

    hr = SetRemote((IUnknown *)This);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Now pass on the CreateComponent call normally. Using this order allows a
    // snap-in to know it is remote prior to its
    // IComponentData::CreateComponent in case it needs that information up
    // front.

    // We do this in IComponentData::Initialize and
    // IComponentData::CreateComponent. Most cases will use Initialize but in
    // MMC 1.1 a taskpad extension does not receive IComponentData::Initialize.
    // MMC only calls IComponentData::CreateComponent. As a taskpad extension
    // may need to resolve a res:// URL to use the mmc.exe path we need to do
    // it here as well.

    hr = IComponentData_RemCreateComponent_Proxy(This, ppComponent);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

Cleanup:

    return hr;
}


HRESULT STDMETHODCALLTYPE IComponentData_CreateComponent_Stub
( 
    IComponentData *This,
    LPCOMPONENT    *ppComponent
)
{
    return This->lpVtbl->CreateComponent(This, ppComponent);
}






HRESULT STDMETHODCALLTYPE IComponentData_Notify_Proxy
( 
    IComponentData __RPC_FAR *This,
    LPDATAOBJECT              piDataObject,
    MMC_NOTIFY_TYPE           event,
    LPARAM                    arg,
    LPARAM                    param
)
{
    BOOL fSpecialDataObject = FALSE;
    long lSpecialDataObject = 0;

    ICDNotifyParam ParamUnion;
    ZeroMemory(&ParamUnion, sizeof(ParamUnion));

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    ParamUnion.value = param;
    return IComponentData_RemNotify_Proxy(This, piDataObject,
                                          fSpecialDataObject,
                                          lSpecialDataObject,
                                          event, arg, &ParamUnion);
}


HRESULT STDMETHODCALLTYPE IComponentData_Notify_Stub
( 
    IComponentData __RPC_FAR *This,
    LPDATAOBJECT              piDataObject,
    BOOL                      fSpecialDataObject,
    long                      lSpecialDataObject,
    MMC_NOTIFY_TYPE           event,
    LPARAM                    arg,
    ICDNotifyParam           *pParamUnion
)
{
    if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    return This->lpVtbl->Notify(This, piDataObject,
                                event, arg, pParamUnion->value);
}


HRESULT STDMETHODCALLTYPE IComponentData_CompareObjects_Proxy
( 
    IComponentData __RPC_FAR *This,
    IDataObject              *piDataObjectA,
    IDataObject              *piDataObjectB
)
{
    HRESULT       hr = S_OK;

    BOOL          fIsMultiSelectA = FALSE;
    long          cDataObjectsA = 1L;
    IDataObject **ppiDataObjectsA = NULL;
    BOOL          fSpecialDataObjectA = FALSE;
    long          lSpecialDataObjectA = 0;

    BOOL          fIsMultiSelectB = FALSE;
    long          cDataObjectsB = 1L;
    IDataObject **ppiDataObjectsB = NULL;
    BOOL          fSpecialDataObjectB = FALSE;
    long          lSpecialDataObjectB = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObjectA, &fSpecialDataObjectA, &lSpecialDataObjectA);

    CheckForSpecialDataObjects(&piDataObjectB, &fSpecialDataObjectB, &lSpecialDataObjectB);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObjectA)
    {
        hr = IsMultiSelect(piDataObjectA, &fIsMultiSelectA);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (!fSpecialDataObjectB)
    {
        hr = IsMultiSelect(piDataObjectB, &fIsMultiSelectB);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelectA)
    {
        hr = InterpretMultiSelect(piDataObjectA, &cDataObjectsA, &ppiDataObjectsA);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjectsA = &piDataObjectA;
    }

    if (fIsMultiSelectB)
    {
        hr = InterpretMultiSelect(piDataObjectB, &cDataObjectsB, &ppiDataObjectsB);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjectsB = &piDataObjectB;
    }

    hr = IComponentData_RemCompareObjects_Proxy(This,
                                                cDataObjectsA,
                                                ppiDataObjectsA,
                                                fSpecialDataObjectA,
                                                lSpecialDataObjectA,

                                                cDataObjectsB,
                                                ppiDataObjectsB,
                                                fSpecialDataObjectB,
                                                lSpecialDataObjectB);
Cleanup:
    if ( fIsMultiSelectA && (NULL != ppiDataObjectsA) )
    {
        (void)GlobalFree(ppiDataObjectsA);
    }
    if ( fIsMultiSelectB && (NULL != ppiDataObjectsB) )
    {
        (void)GlobalFree(ppiDataObjectsB);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IComponentData_CompareObjects_Stub
( 
    IComponentData __RPC_FAR         *This,

    long                              cDataObjectsA,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjectsA[  ],
    BOOL                              fSpecialDataObjectA,
    long                              lSpecialDataObjectA,

    long                              cDataObjectsB,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjectsB[  ],
    BOOL                              fSpecialDataObjectB,
    long                              lSpecialDataObjectB
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObjectA = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObjectA = NULL;
    IDataObject *piDataObjectB = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObjectB = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjectsA > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjectsA, cDataObjectsA,
                                      &piMultiSelDataObjectA);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObjectA = piMultiSelDataObjectA;
    }
    else if (fSpecialDataObjectA)
    {
        piDataObjectA = (IDataObject *)lSpecialDataObjectA;
    }
    else
    {
        piDataObjectA = ppiDataObjectsA[0];
    }

    if (cDataObjectsB > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjectsB, cDataObjectsB,
                                      &piMultiSelDataObjectB);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObjectB = piMultiSelDataObjectB;
    }
    else if (fSpecialDataObjectB)
    {
        piDataObjectB = (IDataObject *)lSpecialDataObjectB;
    }
    else
    {
        piDataObjectB = ppiDataObjectsB[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->CompareObjects(This, piDataObjectA, piDataObjectB);

Cleanup:
    if (NULL != piMultiSelDataObjectA)
    {
        piMultiSelDataObjectA->lpVtbl->Release(piMultiSelDataObjectA);
    }
    if (NULL != piMultiSelDataObjectB)
    {
        piMultiSelDataObjectB->lpVtbl->Release(piMultiSelDataObjectB);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IComponent_Notify_Proxy
( 
    IComponent __RPC_FAR *This,
    LPDATAOBJECT          piDataObject,
    MMC_NOTIFY_TYPE       event,
    LPARAM                arg,
    LPARAM                param
)
{
    ICNotifyArg      ArgUnion;
    ICNotifyParam    ParamUnion;
    ICOutParam      *pOutParam = NULL;
    HRESULT          hr = S_OK;
    BOOL             fIsMultiSelect = FALSE;
    long             cDataObjects = 1L;
    IDataObject    **ppiDataObjects = NULL;
    BOOL             fSpecialDataObject = FALSE;
    long             lSpecialDataObject = 0;

    ZeroMemory(&ArgUnion, sizeof(ArgUnion));
    ZeroMemory(&ParamUnion, sizeof(ParamUnion));

    // Switch any potential multiselect data objects with arg/param so that
    // piDataObject always contains the potential multiselect.

    switch (event)
    {
        case MMCN_QUERY_PASTE:
            ArgUnion.pidoQueryPasteTarget = piDataObject;
            piDataObject = (IDataObject *)arg;
            ParamUnion.value = param;
            break;

        case MMCN_PASTE:
            ArgUnion.pidoPasteTarget = piDataObject;
            piDataObject = (IDataObject *)arg;
            // Pass through param as an LPARAM rather than the IDataObject **
            // it really is. This is just to let the stub know whether it is
            // a copy or a move. If it is a move the CUTORMOVE IDataObject will
            // be in the ICOutParam returned from the stub.
            ParamUnion.value = param;
            break;

        case MMCN_RESTORE_VIEW:
            ArgUnion.value = arg;
            // Don't pass param because it is a BOOL * that will not be
            // marshaled. The BOOL will be received in the ICOutParam returned
            // from the stub.
            break;
            
        default:
            ArgUnion.value = arg;
            ParamUnion.value = param;
    }

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IComponent_RemNotify_Proxy(This,
                                    cDataObjects, ppiDataObjects,
                                    fSpecialDataObject, lSpecialDataObject,
                                    event, &ArgUnion, &ParamUnion, &pOutParam);
Cleanup:
    if (NULL != pOutParam)
    {
        if (MMCN_PASTE == event)
        {
            *((IDataObject **)param) = pOutParam->pidoCutOrMove;
        }
        else if (MMCN_RESTORE_VIEW == event)
        {
            *((BOOL *)param) = pOutParam->fRestoreHandled;
        }
        CoTaskMemFree(pOutParam);
    }

    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE IComponent_Notify_Stub
( 
    IComponent __RPC_FAR  *This,
    long                   cDataObjects,
    IDataObject          **ppiDataObjects,
    BOOL                   fSpecialDataObject,
    long                   lSpecialDataObject,
    MMC_NOTIFY_TYPE        event,
    ICNotifyArg           *pArgUnion,
    ICNotifyParam         *pParamUnion,
    ICOutParam           **ppOutParam
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;
    LPARAM       Arg = 0;
    LPARAM       Param = 0;

    *ppOutParam = (ICOutParam *)CoTaskMemAlloc(sizeof(ICOutParam));
    if (NULL == *ppOutParam)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    ZeroMemory(*ppOutParam, sizeof(ICOutParam));

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // If the event required swaping Arg and IDataObject then swap it back
    // before calling into the object. For MMCN_QUERY_PASTE and
    // MMCN_RESTORE_VIEW we need to make Param contain the out pointer.
    
    switch (event)
    {
        case MMCN_PASTE:
            Arg = (LPARAM)piDataObject;
            piDataObject = pArgUnion->pidoPasteTarget;
            if (0 == pParamUnion->value)
            {
                // This is a copy, pass zero in Param so snap-in will know that
                Param = 0;
            }
            else
            {
                // This is a move. Pass the address of the IDataObject in
                // the ICOutParam that we will return to the proxy.
                Param = (LPARAM)&((*ppOutParam)->pidoCutOrMove);
            }
            break;

        case MMCN_QUERY_PASTE:
            Arg = (LPARAM)piDataObject;
            piDataObject = pArgUnion->pidoQueryPasteTarget;
            Param = pParamUnion->value;
            break;

        case MMCN_RESTORE_VIEW:
            Arg = pArgUnion->value;
            Param = (LPARAM)&((*ppOutParam)->fRestoreHandled);
            break;

        default:
            Arg = pArgUnion->value;
            Param = pParamUnion->value;
            break;
    }

    hr = This->lpVtbl->Notify(This, piDataObject, event, Arg, Param);

Cleanup:
    if (FAILED(hr))
    {
        if (NULL != *ppOutParam)
        {
            CoTaskMemFree(*ppOutParam);
            *ppOutParam = NULL;
        }
    }
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IComponent_CompareObjects_Proxy
( 
    IComponent __RPC_FAR *This,
    IDataObject          *piDataObjectA,
    IDataObject          *piDataObjectB
)
{
    HRESULT       hr = S_OK;

    BOOL          fIsMultiSelectA = FALSE;
    long          cDataObjectsA = 1L;
    IDataObject **ppiDataObjectsA = NULL;
    BOOL          fSpecialDataObjectA = FALSE;
    long          lSpecialDataObjectA = 0;

    BOOL          fIsMultiSelectB = FALSE;
    long          cDataObjectsB = 1L;
    IDataObject **ppiDataObjectsB = NULL;
    BOOL          fSpecialDataObjectB = FALSE;
    long          lSpecialDataObjectB = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObjectA, &fSpecialDataObjectA, &lSpecialDataObjectA);

    CheckForSpecialDataObjects(&piDataObjectB, &fSpecialDataObjectB, &lSpecialDataObjectB);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObjectA)
    {
        hr = IsMultiSelect(piDataObjectA, &fIsMultiSelectA);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (!fSpecialDataObjectB)
    {
        hr = IsMultiSelect(piDataObjectB, &fIsMultiSelectB);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelectA)
    {
        hr = InterpretMultiSelect(piDataObjectA, &cDataObjectsA, &ppiDataObjectsA);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjectsA = &piDataObjectA;
    }

    if (fIsMultiSelectB)
    {
        hr = InterpretMultiSelect(piDataObjectB, &cDataObjectsB, &ppiDataObjectsB);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjectsB = &piDataObjectB;
    }

    hr = IComponent_RemCompareObjects_Proxy(This,
                                            cDataObjectsA,
                                            ppiDataObjectsA,
                                            fSpecialDataObjectA,
                                            lSpecialDataObjectA,

                                            cDataObjectsB,
                                            ppiDataObjectsB,
                                            fSpecialDataObjectB,
                                            lSpecialDataObjectB);
Cleanup:
    if ( fIsMultiSelectA && (NULL != ppiDataObjectsA) )
    {
        (void)GlobalFree(ppiDataObjectsA);
    }
    if ( fIsMultiSelectB && (NULL != ppiDataObjectsB) )
    {
        (void)GlobalFree(ppiDataObjectsB);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IComponent_CompareObjects_Stub
( 
    IComponent __RPC_FAR             *This,

    long                              cDataObjectsA,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjectsA[  ],
    BOOL                              fSpecialDataObjectA,
    long                              lSpecialDataObjectA,

    long                              cDataObjectsB,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjectsB[  ],
    BOOL                              fSpecialDataObjectB,
    long                              lSpecialDataObjectB
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObjectA = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObjectA = NULL;
    IDataObject *piDataObjectB = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObjectB = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjectsA > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjectsA, cDataObjectsA,
                                      &piMultiSelDataObjectA);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObjectA = piMultiSelDataObjectA;
    }
    else if (fSpecialDataObjectA)
    {
        piDataObjectA = (IDataObject *)lSpecialDataObjectA;
    }
    else
    {
        piDataObjectA = ppiDataObjectsA[0];
    }

    if (cDataObjectsB > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjectsB, cDataObjectsB,
                                      &piMultiSelDataObjectB);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObjectB = piMultiSelDataObjectB;
    }
    else if (fSpecialDataObjectB)
    {
        piDataObjectB = (IDataObject *)lSpecialDataObjectB;
    }
    else
    {
        piDataObjectB = ppiDataObjectsB[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->CompareObjects(This, piDataObjectA, piDataObjectB);

Cleanup:
    if (NULL != piMultiSelDataObjectA)
    {
        piMultiSelDataObjectA->lpVtbl->Release(piMultiSelDataObjectA);
    }
    if (NULL != piMultiSelDataObjectB)
    {
        piMultiSelDataObjectB->lpVtbl->Release(piMultiSelDataObjectB);
    }
    return hr;
}

//=--------------------------------------------------------------------------=
//
//                      SCOPEDATAITEM Marshaling
//
//
//=--------------------------------------------------------------------------=
// Caveat: When returning a string in SCOPEDATAITEM MMC does not use a
// callee allocate/caller free strategy. When in-proc, the owner of the memory
// must insure that it stays alive for as long as the caller is expected to
// use it (e.g. scope item display name must remain valid for the life of the
// scope item). When out-of-proc, that returned string will be allocated by
// the proxy using CoTaskMemAlloc() and it will never be freed so there will
// be some leaks.
//=--------------------------------------------------------------------------=

static void SCOPEDATAITEM_TO_WIRE
(
    SCOPEDATAITEM      *psdi,
    WIRE_SCOPEDATAITEM *pwsdi
)
{
    pwsdi->mask = psdi->mask;
    pwsdi->nImage = psdi->nImage;
    pwsdi->nOpenImage = psdi->nOpenImage;
    pwsdi->nState = psdi->nState;
    pwsdi->cChildren = psdi->cChildren;
    pwsdi->lParam = psdi->lParam;
    pwsdi->relativeID = psdi->relativeID;
    pwsdi->ID = psdi->ID;

    if ( SDI_STR != (psdi->mask & SDI_STR) )
    {
        pwsdi->pwszDisplayName = NULL;
        pwsdi->fUsingCallbackForString = FALSE;
    }
    else if (MMC_CALLBACK == psdi->displayname)
    {
        pwsdi->pwszDisplayName = NULL;
        pwsdi->fUsingCallbackForString = TRUE;
    }
    else if (NULL == psdi->displayname)
    {
        pwsdi->pwszDisplayName = NULL;
        pwsdi->fUsingCallbackForString = FALSE;
    }
    else
    {
        // A string is being passed. Need to CoTaskMemAlloc() it so that
        // the MIDL generated stub can free it after transmission

        int cbString = (lstrlenW(psdi->displayname) + 1) * sizeof(psdi->displayname[0]);

        pwsdi->pwszDisplayName = (LPOLESTR)CoTaskMemAlloc(cbString);
        if (NULL == pwsdi->pwszDisplayName)
        {
            RpcRaiseException( E_OUTOFMEMORY );
        }
        else
        {
            memcpy(pwsdi->pwszDisplayName, psdi->displayname, cbString);
        }
        pwsdi->fUsingCallbackForString = FALSE;
    }
}


static void WIRE_TO_SCOPEDATAITEM
(
    WIRE_SCOPEDATAITEM *pwsdi,
    SCOPEDATAITEM      *psdi
)
{
    psdi->mask = pwsdi->mask;
    psdi->nImage = pwsdi->nImage;
    psdi->nOpenImage = pwsdi->nOpenImage;
    psdi->nState = pwsdi->nState;
    psdi->cChildren = pwsdi->cChildren;
    psdi->lParam = pwsdi->lParam;
    psdi->relativeID = pwsdi->relativeID;
    psdi->ID = pwsdi->ID;

    if ( SDI_STR != (psdi->mask & SDI_STR) )
    {
        psdi->displayname = NULL;
    }
    else if (pwsdi->fUsingCallbackForString)
    {
        psdi->displayname = MMC_CALLBACK;
    }
    else
    {
        psdi->displayname = pwsdi->pwszDisplayName;
    }
}


HRESULT STDMETHODCALLTYPE IComponentData_GetDisplayInfo_Proxy
( 
    IComponentData __RPC_FAR *This,
    SCOPEDATAITEM __RPC_FAR  *pScopeDataItem
)
{
    WIRE_SCOPEDATAITEM wsdi;
    HRESULT            hr;

    // Make sure the string pointer is NULL so that it is not marshaled as it
    // is never passed from MMC to the snap-in. (MMC might not have initialized
    // the pointer).

    pScopeDataItem->displayname = NULL;

    SCOPEDATAITEM_TO_WIRE(pScopeDataItem, &wsdi);

    hr =  IComponentData_RemGetDisplayInfo_Proxy(This, &wsdi);
    WIRE_TO_SCOPEDATAITEM(&wsdi, pScopeDataItem);

    return hr;
}


HRESULT STDMETHODCALLTYPE IComponentData_GetDisplayInfo_Stub
( 
    IComponentData __RPC_FAR     *This,
    WIRE_SCOPEDATAITEM __RPC_FAR *pwsdi
)
{
    SCOPEDATAITEM sdi;
    HRESULT       hr;

    WIRE_TO_SCOPEDATAITEM(pwsdi, &sdi);
    hr = This->lpVtbl->GetDisplayInfo(This, &sdi);
    SCOPEDATAITEM_TO_WIRE(&sdi, pwsdi);

    return hr;
}



HRESULT STDMETHODCALLTYPE IConsoleNameSpace_InsertItem_Proxy
( 
    IConsoleNameSpace __RPC_FAR *This,
    LPSCOPEDATAITEM              pItem
)
{
    WIRE_SCOPEDATAITEM  wsdi;
    HRESULT             hr;
    HSCOPEITEM          ItemID;

    SCOPEDATAITEM_TO_WIRE(pItem, &wsdi);
    hr = IConsoleNameSpace_RemInsertItem_Proxy(This, &wsdi, &ItemID);

    // The only returned field is the item ID so copy it from the wire
    // structure to the client structure

    pItem->ID = ItemID;

    return hr;
}


HRESULT STDMETHODCALLTYPE IConsoleNameSpace_InsertItem_Stub
( 
    IConsoleNameSpace __RPC_FAR  *This,
    WIRE_SCOPEDATAITEM __RPC_FAR *pwsdi,
    HSCOPEITEM __RPC_FAR         *pItemID
)
{
    SCOPEDATAITEM sdi;
    HRESULT       hr;

    WIRE_TO_SCOPEDATAITEM(pwsdi, &sdi);
    hr = This->lpVtbl->InsertItem(This, &sdi);

    // The only returned field is the itemID.

    *pItemID = sdi.ID;
    return hr;
}

HRESULT STDMETHODCALLTYPE IConsoleNameSpace_SetItem_Proxy
( 
    IConsoleNameSpace __RPC_FAR *This,
    LPSCOPEDATAITEM              pItem
)
{
    WIRE_SCOPEDATAITEM wsdi;

    SCOPEDATAITEM_TO_WIRE(pItem, &wsdi);
    return IConsoleNameSpace_RemSetItem_Proxy(This, &wsdi);
}


HRESULT STDMETHODCALLTYPE IConsoleNameSpace_SetItem_Stub
( 
    IConsoleNameSpace __RPC_FAR  *This,
    WIRE_SCOPEDATAITEM __RPC_FAR *pwsdi
)
{
    SCOPEDATAITEM sdi;

    WIRE_TO_SCOPEDATAITEM(pwsdi, &sdi);
    return This->lpVtbl->SetItem(This, &sdi);
}


HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetItem_Proxy
( 
    IConsoleNameSpace __RPC_FAR *This,
    LPSCOPEDATAITEM              pItem
)
{
    WIRE_SCOPEDATAITEM wsdi;
    HRESULT            hr;

    // Make sure the string pointer is NULL so that it is not marshaled as it
    // is never passed from the snap-in to MMC. (It might not have be
    // initialized).

    pItem->displayname = NULL;

    SCOPEDATAITEM_TO_WIRE(pItem, &wsdi);
    hr = IConsoleNameSpace_RemGetItem_Proxy(This, &wsdi);
    WIRE_TO_SCOPEDATAITEM(&wsdi, pItem);
    return hr;
}


HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetItem_Stub
( 
    IConsoleNameSpace __RPC_FAR  *This,
    WIRE_SCOPEDATAITEM __RPC_FAR *pwsdi
)
{
    SCOPEDATAITEM sdi;
    HRESULT       hr;

    WIRE_TO_SCOPEDATAITEM(pwsdi, &sdi);
    hr = This->lpVtbl->GetItem(This, &sdi);
    SCOPEDATAITEM_TO_WIRE(&sdi, pwsdi);

    return hr;
}






//=--------------------------------------------------------------------------=
//
//                      RESULTDATAITEM Marshaling
//
//
//=--------------------------------------------------------------------------=
// Caveat: When returning a string in RESULTDATAITEM MMC does not use a
// callee allocate/caller free strategy. When in-proc, the owner of the memory
// must insure that it stays alive for as long as the caller is expected to
// use it (e.g. list item column data must remain valid for the life of the
// list item). When out-of-proc, that returned string will be allocated by
// the proxy using SysAllocString() and it will never be freed so there will
// be some leaks.
//=--------------------------------------------------------------------------=

static void RESULTDATAITEM_TO_WIRE
(
    RESULTDATAITEM      *prdi,
    WIRE_RESULTDATAITEM *pwrdi
)
{
    pwrdi->mask = prdi->mask;
    pwrdi->bScopeItem = prdi->bScopeItem;
    pwrdi->itemID = prdi->itemID;
    pwrdi->nIndex = prdi->nIndex;
    pwrdi->nCol = prdi->nCol;
    pwrdi->nImage = prdi->nImage;
    pwrdi->nState = prdi->nState;
    pwrdi->lParam = prdi->lParam;
    pwrdi->iIndent = prdi->iIndent;

    if ( RDI_STR != (prdi->mask & RDI_STR) )
    {
        pwrdi->str = NULL;
        pwrdi->fUsingCallbackForString = FALSE;
    }
    else if (MMC_CALLBACK == prdi->str)
    {
        pwrdi->str = NULL;
        pwrdi->fUsingCallbackForString = TRUE;
    }
    else if (NULL == prdi->str)
    {
        pwrdi->str = NULL;
        pwrdi->fUsingCallbackForString = FALSE;
    }
    else
    {
        // A string is being passed. Need to CoTaskMemAlloc() it so that
        // the MIDL generated stub can free it after transmission

        int cbString = (lstrlenW(prdi->str) + 1) * sizeof(prdi->str[0]);

        pwrdi->str = (LPOLESTR)CoTaskMemAlloc(cbString);
        if (NULL == pwrdi->str)
        {
            RpcRaiseException( E_OUTOFMEMORY );
        }
        else
        {
            memcpy(pwrdi->str, prdi->str, cbString);
        }
        pwrdi->fUsingCallbackForString = FALSE;
    }
}



static void WIRE_TO_RESULTDATAITEM
(
    WIRE_RESULTDATAITEM *pwrdi,
    RESULTDATAITEM      *prdi
)
{
    prdi->mask = pwrdi->mask;
    prdi->bScopeItem = pwrdi->bScopeItem;
    prdi->itemID = pwrdi->itemID;
    prdi->nIndex = pwrdi->nIndex;
    prdi->nCol = pwrdi->nCol;
    prdi->nImage = pwrdi->nImage;
    prdi->nState = pwrdi->nState;
    prdi->lParam = pwrdi->lParam;
    prdi->iIndent = pwrdi->iIndent;

    if ( RDI_STR != (prdi->mask & RDI_STR) )
    {
        prdi->str = NULL;
    }
    else if (pwrdi->fUsingCallbackForString)
    {
        prdi->str = MMC_CALLBACK;
    }
    else
    {
        prdi->str = pwrdi->str;
    }
}

 
HRESULT STDMETHODCALLTYPE IComponent_GetDisplayInfo_Proxy
( 
    IComponent __RPC_FAR     *This,
    RESULTDATAITEM __RPC_FAR *pResultDataItem
)
{
    WIRE_RESULTDATAITEM wrdi;
    HRESULT             hr;

    // Make sure the string pointer is NULL so that it is not marshaled as it
    // is never passed from MMC to the snap-in. (MMC might not have initialized
    // the pointer).

    pResultDataItem->str = NULL;

    RESULTDATAITEM_TO_WIRE(pResultDataItem, &wrdi);

    hr =  IComponent_RemGetDisplayInfo_Proxy(This, &wrdi);
    WIRE_TO_RESULTDATAITEM(&wrdi, pResultDataItem);

    return hr;
}


HRESULT STDMETHODCALLTYPE IComponent_GetDisplayInfo_Stub
( 
    IComponent __RPC_FAR          *This,
    WIRE_RESULTDATAITEM __RPC_FAR *pwrdi
)
{
    RESULTDATAITEM rdi;
    HRESULT        hr;

    WIRE_TO_RESULTDATAITEM(pwrdi, &rdi);
    hr = This->lpVtbl->GetDisplayInfo(This, &rdi);
    RESULTDATAITEM_TO_WIRE(&rdi, pwrdi);

    return hr;
}


HRESULT STDMETHODCALLTYPE IResultData_InsertItem_Proxy
( 
    IResultData __RPC_FAR *This,
    LPRESULTDATAITEM       pItem
)
{
    WIRE_RESULTDATAITEM wrdi;
    HRESULT             hr;
    HRESULTITEM         ItemID;

    RESULTDATAITEM_TO_WIRE(pItem, &wrdi);
    hr = IResultData_RemInsertItem_Proxy(This, &wrdi, &ItemID);

    // The only returned field is the itemID so copy it from the wire
    // structure to the client structure

    pItem->itemID = ItemID;

    return hr;
}


HRESULT STDMETHODCALLTYPE IResultData_InsertItem_Stub
( 
    IResultData __RPC_FAR         *This,
    WIRE_RESULTDATAITEM __RPC_FAR *pwrdi,
    HRESULTITEM __RPC_FAR         *pItemID
)
{
    RESULTDATAITEM rdi;
    HRESULT        hr;

    WIRE_TO_RESULTDATAITEM(pwrdi, &rdi);
    hr = This->lpVtbl->InsertItem(This, &rdi);

    // The only returned field is the itemID.

    *pItemID = rdi.itemID;
    return hr;
}

HRESULT STDMETHODCALLTYPE IResultData_SetItem_Proxy
( 
    IResultData __RPC_FAR *This,
    LPRESULTDATAITEM       pItem
)
{
    WIRE_RESULTDATAITEM wrdi;

    RESULTDATAITEM_TO_WIRE(pItem, &wrdi);
    return IResultData_RemSetItem_Proxy(This, &wrdi);
}


HRESULT STDMETHODCALLTYPE IResultData_SetItem_Stub
( 
    IResultData __RPC_FAR         *This,
    WIRE_RESULTDATAITEM __RPC_FAR *pwrdi
)
{
    RESULTDATAITEM rdi;

    WIRE_TO_RESULTDATAITEM(pwrdi, &rdi);
    return This->lpVtbl->SetItem(This, &rdi);
}

HRESULT STDMETHODCALLTYPE IResultData_GetItem_Proxy
( 
    IResultData __RPC_FAR *This,
    LPRESULTDATAITEM       pItem
)
{
    WIRE_RESULTDATAITEM wrdi;
    HRESULT             hr;

    // Make sure the string pointer is NULL so that it is not marshaled as it
    // is never passed from the snap-in to MMC. (It might not have be
    // initialized).

    pItem->str = NULL;

    RESULTDATAITEM_TO_WIRE(pItem, &wrdi);
    hr = IResultData_RemGetItem_Proxy(This, &wrdi);
    WIRE_TO_RESULTDATAITEM(&wrdi, pItem);
    return hr;
}


HRESULT STDMETHODCALLTYPE IResultData_GetItem_Stub
( 
    IResultData __RPC_FAR         *This,
    WIRE_RESULTDATAITEM __RPC_FAR *pwrdi
)
{
    RESULTDATAITEM rdi;
    HRESULT        hr;

    WIRE_TO_RESULTDATAITEM(pwrdi, &rdi);
    hr = This->lpVtbl->GetItem(This, &rdi);
    RESULTDATAITEM_TO_WIRE(&rdi, pwrdi);

    return hr;
}

HRESULT STDMETHODCALLTYPE IResultData_GetNextItem_Proxy
( 
    IResultData __RPC_FAR *This,
    LPRESULTDATAITEM       pItem
)
{
    WIRE_RESULTDATAITEM wrdi;
    HRESULT             hr;

    // Make sure the string pointer is NULL so that it is not marshaled as it
    // is never passed from the snap-in to MMC. (It might not have be
    // initialized).

    pItem->str = NULL;

    RESULTDATAITEM_TO_WIRE(pItem, &wrdi);
    hr = IResultData_RemGetNextItem_Proxy(This, &wrdi);
    WIRE_TO_RESULTDATAITEM(&wrdi, pItem);
    return hr;
}


HRESULT STDMETHODCALLTYPE IResultData_GetNextItem_Stub
( 
    IResultData __RPC_FAR         *This,
    WIRE_RESULTDATAITEM __RPC_FAR *pwrdi
)
{
    RESULTDATAITEM rdi;
    HRESULT        hr;

    WIRE_TO_RESULTDATAITEM(pwrdi, &rdi);
    hr = This->lpVtbl->GetNextItem(This, &rdi);
    RESULTDATAITEM_TO_WIRE(&rdi, pwrdi);
    return hr;
}


//=--------------------------------------------------------------------------=
//
//                              HICON Marshaling
//
//=--------------------------------------------------------------------------=
// In wtypes.idl HICON is defined with the wire_marshal attribute with its
// 'on-the-wire' type as a pointer to a RemotableHandle. RemotableHandle is
// defined in wtypes.idl as
// 
// typedef union _RemotableHandle switch( long fContext ) u
// {
//     case WDT_INPROC_CALL:   long   hInproc;
//     case WDT_REMOTE_CALL:   long   hRemote;
// } RemotableHandle;
// 
// A wire_marshal type must supply routines to size, marhsal, unmarshal, and
// free marshaling data. Those routines are in ole32.dll but someone forgot to
// export them. (ole32 also has routines to marshal bitmaps, hwnds, etc. that
// are all exported). The code has been plagiarized here from ole32. The source
// is in \\savik\cairo\src\ole32\oleprx32\proxy\transmit.cxx with some macros in
// transmit.h in that same directory.
//
//=--------------------------------------------------------------------------=


//
// The following defines and macros are from transmit.h. Note that
// USER_CALL_CTXT_MASK is from rpcndr.h and WDT_REMOTE_CALL is from wtypes.idl.
//

#define ALIGN( pStuff, cAlign ) \
        pStuff = (unsigned char *)((ULONG_PTR)((pStuff) + (cAlign)) & ~ (cAlign))

#define LENGTH_ALIGN( Length, cAlign ) \
                                    Length = (((Length) + (cAlign)) & ~ (cAlign))

#define PULONG_LV_CAST   *(unsigned long __RPC_FAR * __RPC_FAR *)&


#define DIFFERENT_MACHINE_CALL( Flags)  \
                          (USER_CALL_CTXT_MASK(Flags) == MSHCTX_DIFFERENTMACHINE)

#define WDT_HANDLE_MARKER      WDT_INPROC_CALL




//=--------------------------------------------------------------------------=
// HICON_UserSize
//=--------------------------------------------------------------------------=
//
// Parameters:
//  unsigned long __RPC_FAR *pFlags       [in] data format & context (see below)
//  unsigned long            StartingSize [in] current buffer size
//  HICON __RPC_FAR         *hIcon        [in] HICON to be marshaled
//    
//
// Flags Layout
// ============
//
//----------------------------------------------------------------------
// Bits     Flag                            Value
//----------------------------------------------------------------------
// 31-24    Floating-point representation   0 = IEEE
//                                          1 = VAX
//                                          2 = Cray
//                                          3 = IBM 
//----------------------------------------------------------------------
// 23-20    Integer and floating-point byte
//          order                           0 = Big-endian
//                                          1 = Little-endian 
//----------------------------------------------------------------------
// 19-16    Character representation        0 = ASCII
//                                          1 = EBCDIC 
//----------------------------------------------------------------------
// 15-0     Marshaling context flag         0 = MSHCTX_LOCAL
//                                          1 = MSHCTX_NOSHAREDMEM
//                                          2 = MSHCTX_DIFFERENTMSCHINE
//                                          3 = MSHCTX_INPROC 
//----------------------------------------------------------------------
//
// Output:
//      New buffer size after adding amount needed for HICON marshaled data
//
// Notes:
//
// Called from MIDL generated proxy to determine buffer size needed for 
// marhaled data.
//

unsigned long __RPC_USER HICON_UserSize
(
    unsigned long __RPC_FAR *pFlags,
    unsigned long            StartingSize,
    HICON __RPC_FAR         *hIcon
)
{
    if (NULL == hIcon)
    {
        return StartingSize;
    }

    // If marshaling context is to a different machine then we don't support
    // that.

    if ( DIFFERENT_MACHINE_CALL(*pFlags) )
    {
        RpcRaiseException( RPC_S_INVALID_TAG );
    }

    // Make sure that our data will fall at a long boundary

    LENGTH_ALIGN( StartingSize, 3 );

    //Add the length
    
    return StartingSize + 8;
}


//=--------------------------------------------------------------------------=
// HICON_UserMarhsal
//=--------------------------------------------------------------------------=
//
// Parameters:
//  unsigned long __RPC_FAR  *pFlags  [in] data format & context (see above)
//  unsigned char  __RPC_FAR *pBuffer [in] current buffer size
//  HICON __RPC_FAR          *hIcon   [in] HICON to be marshaled
//    
//
// Output:
//      Pointer to buffer location following HICON's marshaling data
//
// Notes:
//
// Called from MIDL generated proxy to marshal an HICON
//

unsigned char __RPC_FAR * __RPC_USER HICON_UserMarshal
(
    unsigned long __RPC_FAR  *pFlags,
    unsigned char  __RPC_FAR *pBuffer,
    HICON __RPC_FAR          *hIcon
)
{
    if (NULL == hIcon)
    {
        return pBuffer;
    }

    if ( DIFFERENT_MACHINE_CALL(*pFlags) )
    {
        RpcRaiseException( RPC_S_INVALID_TAG );
    }

    // Make sure that our data will fall at a long boundary

    ALIGN( pBuffer, 3 );

    *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
    *( PULONG_LV_CAST pBuffer)++ = *((long *)hIcon);

    return pBuffer;
}

//=--------------------------------------------------------------------------=
// HICON_UserUnmarhsal
//=--------------------------------------------------------------------------=
//
// Parameters:
//  unsigned long __RPC_FAR  *pFlags  [in] data format & context (see above)
//  unsigned char  __RPC_FAR *pBuffer [in] current buffer size
//  HICON __RPC_FAR          *hIcon   [in] HICON to be marshaled
//    
//
// Output:
//      Pointer to buffer location following HICON's marshaling data
//
// Notes:
//
// Called from MIDL generated stub to unmarshal an HICON
//

unsigned char __RPC_FAR *__RPC_USER HICON_UserUnmarshal
(
    unsigned long __RPC_FAR  *pFlags,
    unsigned char  __RPC_FAR *pBuffer,
    HICON __RPC_FAR          *hIcon
)
{
    unsigned long HandleMarker;

    ALIGN( pBuffer, 3 );

    HandleMarker = *( PULONG_LV_CAST pBuffer)++;

    if ( HandleMarker == WDT_HANDLE_MARKER )
        *((long *)hIcon) = *( PULONG_LV_CAST pBuffer)++;
    else
        RpcRaiseException( RPC_S_INVALID_TAG );

    return pBuffer;
}



//=--------------------------------------------------------------------------=
// HICON_UserUnmarhsal
//=--------------------------------------------------------------------------=
//
// Parameters:
//  unsigned long __RPC_FAR  *pFlags  [in] data format & context (see above)
//  HICON __RPC_FAR          *hIcon   [in] HICON that was unmarshaled
//    
//
// Output:
//      None
//
// Notes:
//
// Called from MIDL generated stub to free any associated marshaling data
// allocated during unmarshaling for embedded pointers. Not used for HICON.
//

void __RPC_USER HICON_UserFree
(
    unsigned long __RPC_FAR *pFlags,
    HICON __RPC_FAR         *hIcon
)
{
}



//=--------------------------------------------------------------------------=
//
//                          IImageList Marshaling
//
//
//=--------------------------------------------------------------------------=
// These methods needed call_as because the HICON and HBITMAP parameters are
// specified as long pointers in the original IDL.
//=--------------------------------------------------------------------------=

HRESULT STDMETHODCALLTYPE IImageList_ImageListSetIcon_Proxy
( 
    IImageList __RPC_FAR *This,
    LONG_PTR __RPC_FAR   *pIcon,
    long                  nLoc
)
{
    return IImageList_RemImageListSetIcon_Proxy(This, (HICON)pIcon, nLoc);
}


HRESULT STDMETHODCALLTYPE IImageList_ImageListSetIcon_Stub
( 
    IImageList __RPC_FAR *This,
    HICON                 hIcon,
    long                  nLoc
)
{
    return This->lpVtbl->ImageListSetIcon(This, (LONG_PTR __RPC_FAR*)hIcon, nLoc);
}

HRESULT STDMETHODCALLTYPE IImageList_ImageListSetStrip_Proxy
( 
    IImageList __RPC_FAR *This,
    LONG_PTR __RPC_FAR   *pBMapSm,
    LONG_PTR __RPC_FAR   *pBMapLg,
    long                  nStartLoc,
    COLORREF              cMask
)
{
    return IImageList_RemImageListSetStrip_Proxy(This,
                                                 (HBITMAP)pBMapSm,
                                                 (HBITMAP)pBMapLg,
                                                 nStartLoc,
                                                 cMask);
}


HRESULT STDMETHODCALLTYPE IImageList_ImageListSetStrip_Stub
( 
    IImageList __RPC_FAR *This,
    HBITMAP               hbmSmall,
    HBITMAP               hbmLarge,
    long                  nStartLoc,
    COLORREF              cMask
)
{
    return This->lpVtbl->ImageListSetStrip(This,
                                           (LONG_PTR __RPC_FAR*)hbmSmall,
                                           (LONG_PTR __RPC_FAR*)hbmLarge,
                                           nStartLoc,
                                           cMask);
}

HRESULT STDMETHODCALLTYPE IExtendPropertySheet_CreatePropertyPages_Proxy
( 
    IExtendPropertySheet __RPC_FAR *This,
    LPPROPERTYSHEETCALLBACK         lpProvider,
    LONG_PTR                        handle,
    LPDATAOBJECT                    lpIDataObject
)
{
    HRESULT                      hr = S_OK;
    WIRE_PROPERTYPAGES          *pPages = NULL;
    WIRE_PROPERTYPAGE           *pPage = NULL;
    ULONG                        i = 0;
    ULONG                        j = 0;
    IExtendPropertySheetRemote  *piExtendPropertySheetRemote = NULL;
    IRemotePropertySheetManager *piRemotePropertySheetManager = NULL;

    // Make sure the snap-in knows we are remoted. We do this here because
    // this is the first opportunity for the proxy to inform a property page
    // extension that it is remote and pass it data such as the MMC.exe path
    // and the MMC command line.

    hr = SetRemote((IUnknown *)This);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Call the IExtendPropertySheetRemote method which will return a filled in
    // WIRE_PROPERTYPAGES from the remoted snap-in.

    hr = This->lpVtbl->QueryInterface(This, &IID_IExtendPropertySheetRemote,
                                      (void **)&piExtendPropertySheetRemote);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = piExtendPropertySheetRemote->lpVtbl->CreatePropertyPageDefs(
                            piExtendPropertySheetRemote, lpIDataObject, &pPages);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // If there are pages (snap-in might not have added any) then
    // CoCreateInstance the remote property sheet manager using the clsid
    // returned in WIRE_PROPERTYPAGES. This object will be created in-proc here
    // on the MMC side.

    if (0 == pPages->cPages)
    {
        goto Cleanup;
    }

    hr = CoCreateInstance(&pPages->clsidRemotePropertySheetManager,
                          NULL, // no aggregation,
                          CLSCTX_INPROC_SERVER,
                          &IID_IRemotePropertySheetManager,
                          (void **)&piRemotePropertySheetManager);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Pass the remote property sheet manager the WIRE_PROPERTYPAGES and let it
    // actually create the property pages and add them to the sheet here on the
    // MMC side.

    hr = piRemotePropertySheetManager->lpVtbl->CreateRemotePages(
                                                    piRemotePropertySheetManager,
                                                    lpProvider,
                                                    handle,
                                                    lpIDataObject,
                                                    pPages);
Cleanup:
    if (NULL != piRemotePropertySheetManager)
    {
        piRemotePropertySheetManager->lpVtbl->Release(piRemotePropertySheetManager);
    }

    if (NULL != piExtendPropertySheetRemote)
    {
        piExtendPropertySheetRemote->lpVtbl->Release(piExtendPropertySheetRemote);
    }

    // Free the WIRE_PROPERTYPAGES and all of its contents.

    if (NULL != pPages)
    {
        // Release the object and free the title for each individual page
        
        for (i = 0, pPage = &pPages->aPages[0]; i < pPages->cPages; i++, pPage++)
        {
            if (NULL != pPage->apunkObjects)
            {
                for (j = 0; j < pPage->cObjects; j++)
                {
                    if (NULL != pPage->apunkObjects[j])
                    {
                        pPage->apunkObjects[j]->lpVtbl->Release(pPage->apunkObjects[j]);
                    }
                }
                CoTaskMemFree(pPage->apunkObjects);
            }
            if (NULL != pPage->pwszTitle)
            {
                CoTaskMemFree(pPage->pwszTitle);
            }
        }

        // Free the ProgID prefix

        if (NULL != pPages->pwszProgIDStart)
        {
            CoTaskMemFree(pPages->pwszProgIDStart);
        }

        // Free all of the snap-in's property page info

        if (NULL != pPages->pPageInfos)
        {
            for (i = 0; i < pPages->pPageInfos->cPages; i++)
            {
                if (NULL != pPages->pPageInfos->aPageInfo[i].pwszTitle)
                {
                    CoTaskMemFree(pPages->pPageInfos->aPageInfo[i].pwszTitle);
                }
                if (NULL != pPages->pPageInfos->aPageInfo[i].pwszProgID)
                {
                    CoTaskMemFree(pPages->pPageInfos->aPageInfo[i].pwszProgID);
                }
            }
            CoTaskMemFree(pPages->pPageInfos);
        }

        // Free all of the objects associated with the sheet

        if (NULL != pPages->apunkObjects)
        {
            for (i = 0; i < pPages->cObjects; i++)
            {
                if (NULL != pPages->apunkObjects[i])
                {
                    pPages->apunkObjects[i]->lpVtbl->Release(pPages->apunkObjects[i]);
                }
            }
            CoTaskMemFree(pPages->apunkObjects);
        }


        // Release the extra object and the WIRE_PROPERTYPAGES struct itself

        if (NULL != pPages->punkExtra)
        {
            pPages->punkExtra->lpVtbl->Release(pPages->punkExtra);
        }
        CoTaskMemFree(pPages);
    }

    return hr;
}


//=--------------------------------------------------------------------------=
// IExtendPropertySheet_CreatePropertyPages_Stub
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IExtendPropertySheet __RPC_FAR *This [in] this pointer
//
// Output:
//
// Notes:
//
// This stub is never called because
// IExtendPropertySheet_CreatePropertyPages_Proxy() (see above) reroutes the
// call to IExtendPropertySheetRemote::CreatePropertyPageDefs().
//

HRESULT STDMETHODCALLTYPE IExtendPropertySheet_CreatePropertyPages_Stub
( 
    IExtendPropertySheet __RPC_FAR *This
)
{
    return S_OK;
}



HRESULT STDMETHODCALLTYPE IExtendPropertySheet_QueryPagesFor_Proxy
( 
    IExtendPropertySheet __RPC_FAR *This,
    IDataObject                    *piDataObject
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendPropertySheet_RemQueryPagesFor_Proxy(This,
                                                     cDataObjects,
                                                     ppiDataObjects,
                                                     fSpecialDataObject,
                                                     lSpecialDataObject);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendPropertySheet_QueryPagesFor_Stub
( 
    IExtendPropertySheet __RPC_FAR   *This,
    long                              cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjects[  ],
    BOOL                              fSpecialDataObject,
    long                              lSpecialDataObject
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->QueryPagesFor(This, piDataObject);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}




HRESULT STDMETHODCALLTYPE IExtendPropertySheet2_GetWatermarks_Proxy
( 
    IExtendPropertySheet2 __RPC_FAR *This,
    IDataObject                     *piDataObject,
    HBITMAP                         *lphWatermark,
    HBITMAP                         *lphHeader,
    HPALETTE                        *lphPalette,
    BOOL                            *bStretch
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendPropertySheet2_RemGetWatermarks_Proxy(This,
                                                      cDataObjects,
                                                      ppiDataObjects,
                                                      fSpecialDataObject,
                                                      lSpecialDataObject,
                                                      lphWatermark,
                                                      lphHeader,
                                                      lphPalette,
                                                      bStretch);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendPropertySheet2_GetWatermarks_Stub
( 
    IExtendPropertySheet2 __RPC_FAR   *This,
    long                              cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjects[  ],
    BOOL                              fSpecialDataObject,
    long                              lSpecialDataObject,
    HBITMAP                          *lphWatermark,
    HBITMAP                          *lphHeader,
    HPALETTE                         *lphPalette,
    BOOL                             *bStretch
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->GetWatermarks(This,
                                     piDataObject,
                                     lphWatermark,
                                     lphHeader,
                                     lphPalette,
                                     bStretch);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendPropertySheetRemote_CreatePropertyPageDefs_Proxy
( 
    IExtendPropertySheetRemote __RPC_FAR  *This,
    IDataObject                           *piDataObject,
    WIRE_PROPERTYPAGES                   **ppPages
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendPropertySheetRemote_RemCreatePropertyPageDefs_Proxy(
                                                             This,
                                                             cDataObjects,
                                                             ppiDataObjects,
                                                             fSpecialDataObject,
                                                             lSpecialDataObject,
                                                             ppPages);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendPropertySheetRemote_CreatePropertyPageDefs_Stub
( 
    IExtendPropertySheetRemote __RPC_FAR  *This,
    long                                   cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR       ppiDataObjects[  ],
    BOOL                                   fSpecialDataObject,
    long                                   lSpecialDataObject,
    WIRE_PROPERTYPAGES                   **ppPages
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->CreatePropertyPageDefs(This, piDataObject, ppPages);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}



HRESULT STDMETHODCALLTYPE IPropertySheetProvider_CreatePropertySheet_Proxy
( 
    IPropertySheetProvider __RPC_FAR *This,
    LPCWSTR                           title,
    boolean                           type,
    MMC_COOKIE                        cookie,
    IDataObject                      *piDataObject,
    DWORD                             dwOptions
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IPropertySheetProvider_RemCreatePropertySheet_Proxy(This,
                                                             title,
                                                             type,
                                                             cookie,
                                                             cDataObjects,
                                                             ppiDataObjects,
                                                             fSpecialDataObject,
                                                             lSpecialDataObject,
                                                             dwOptions);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IPropertySheetProvider_CreatePropertySheet_Stub
( 
    IPropertySheetProvider __RPC_FAR *This,
    LPCWSTR                           title,
    boolean                           type,
    MMC_COOKIE                        cookie,
    long                              cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjects[  ],
    BOOL                              fSpecialDataObject,
    long                              lSpecialDataObject,
    DWORD                             dwOptions
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->CreatePropertySheet(This, title, type, cookie, piDataObject, dwOptions);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}



HRESULT STDMETHODCALLTYPE IPropertySheetProvider_FindPropertySheet_Proxy
( 
    IPropertySheetProvider __RPC_FAR *This,
    MMC_COOKIE                        cookie,
    IComponent                       *piComponent,
    IDataObject                      *piDataObject
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IPropertySheetProvider_RemFindPropertySheet_Proxy(This,
                                                           cookie,
                                                           piComponent,
                                                           cDataObjects,
                                                           ppiDataObjects,
                                                           fSpecialDataObject,
                                                           lSpecialDataObject);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IPropertySheetProvider_FindPropertySheet_Stub
( 
    IPropertySheetProvider __RPC_FAR *This,
    MMC_COOKIE                        cookie,
    IComponent                       *piComponent,
    long                              cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjects[  ],
    BOOL                              fSpecialDataObject,
    long                              lSpecialDataObject
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->FindPropertySheet(This, cookie, piComponent, piDataObject);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}







HRESULT STDMETHODCALLTYPE IExtendContextMenu_AddMenuItems_Proxy
( 
    IExtendContextMenu __RPC_FAR *This,
    LPDATAOBJECT                  piDataObject,
    LPCONTEXTMENUCALLBACK         piCallback,
    long __RPC_FAR               *pInsertionAllowed
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Make sure the snap-in knows we are remoted. We do this here because
    // this is the first opportunity for the proxy to inform a context menu
    // extension that it is remote.

    hr = SetRemote((IUnknown *)This);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendContextMenu_RemAddMenuItems_Proxy(This,
                                                  cDataObjects,
                                                  ppiDataObjects,
                                                  fSpecialDataObject,
                                                  lSpecialDataObject,
                                                  piCallback,
                                                  pInsertionAllowed);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendContextMenu_AddMenuItems_Stub
( 
    IExtendContextMenu __RPC_FAR     *This,
    long                              cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjects[  ],
    BOOL                              fSpecialDataObject,
    long                              lSpecialDataObject,
    LPCONTEXTMENUCALLBACK             piCallback,
    long __RPC_FAR                   *pInsertionAllowed
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->AddMenuItems(This, piDataObject,
                                    piCallback, pInsertionAllowed);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE IExtendContextMenu_Command_Proxy
( 
    IExtendContextMenu __RPC_FAR *This,
    long                          lCommandID,
    LPDATAOBJECT                  piDataObject
)
{
    HRESULT       hr = S_OK;
    BOOL          fIsMultiSelect = FALSE;
    long          cDataObjects = 1L;
    IDataObject **ppiDataObjects = NULL;
    BOOL          fSpecialDataObject = FALSE;
    long          lSpecialDataObject = 0;

    // Check for special data objects such DOBJ_CUSTOMWEB etc.

    CheckForSpecialDataObjects(&piDataObject, &fSpecialDataObject, &lSpecialDataObject);

    // If this is a mutliple selection then we need to extract the data
    // objects in the HGLOBAL

    if (!fSpecialDataObject)
    {
        hr = IsMultiSelect(piDataObject, &fIsMultiSelect);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fIsMultiSelect)
    {
        hr = InterpretMultiSelect(piDataObject, &cDataObjects, &ppiDataObjects);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        ppiDataObjects = &piDataObject;
    }

    hr = IExtendContextMenu_RemCommand_Proxy(This,
                                             cDataObjects,
                                             ppiDataObjects,
                                             fSpecialDataObject,
                                             lSpecialDataObject,
                                             lCommandID);
Cleanup:
    if ( fIsMultiSelect && (NULL != ppiDataObjects) )
    {
        (void)GlobalFree(ppiDataObjects);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE IExtendContextMenu_Command_Stub
( 
    IExtendContextMenu __RPC_FAR     *This,
    long                              cDataObjects,
    IDataObject __RPC_FAR *__RPC_FAR  ppiDataObjects[  ],
    BOOL                              fSpecialDataObject,
    long                              lSpecialDataObject,
    long                              lCommandID
)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL; // Not AddRef()ed
    IDataObject *piMultiSelDataObject = NULL;

    // If there is more than one data object then we need to pack them into a
    // a separate data object that appears as a multi-select data object.

    if (cDataObjects > 1L)
    {
        hr = CreateMultiSelDataObject(ppiDataObjects, cDataObjects,
                                      &piMultiSelDataObject);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        piDataObject = piMultiSelDataObject;
    }
    else if (fSpecialDataObject)
    {
        piDataObject = (IDataObject *)lSpecialDataObject;
    }
    else
    {
        piDataObject = ppiDataObjects[0];
    }

    // Call the snap-in

    hr = This->lpVtbl->Command(This, lCommandID, piDataObject);

Cleanup:
    if (NULL != piMultiSelDataObject)
    {
        piMultiSelDataObject->lpVtbl->Release(piMultiSelDataObject);
    }
    return hr;
}



HRESULT STDMETHODCALLTYPE IColumnData_GetColumnConfigData_Proxy
( 
    IColumnData __RPC_FAR                    *This,
    SColumnSetID __RPC_FAR                   *pColID,
    MMC_COLUMN_SET_DATA __RPC_FAR *__RPC_FAR *ppColSetData
)
{
    HRESULT              hr = S_OK;
    size_t               cbColData = 0;
    MMC_COLUMN_SET_DATA *pColSetData = NULL;

    // Call the proxy and get the returned data from MMC

    hr = IColumnData_RemGetColumnConfigData_Proxy(This, pColID, ppColSetData);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // If no data was returned then there is nothing to do

    if (NULL == *ppColSetData)
    {
        goto Cleanup;
    }

    if (NULL == (*ppColSetData)->pColData)
    {
        goto Cleanup;
    }

    // At this point the MIDL-generated proxy has returned an MMC_COLUMN_SET_DATA
    // in which the embedded pointer pColData points to a separate block of
    // memory which must be freed independently. The snap-in thinks that
    // pColData points into the same block of memory so it will only call
    // CoTaskMemFree for the MMC_COLUMN_SET_DATA. We need to allocate a new single
    // block in the format the snap-in is expecting and free the memory returned
    // from the proxy.

    cbColData = sizeof(MMC_COLUMN_DATA) * (*ppColSetData)->nNumCols;

    pColSetData = (MMC_COLUMN_SET_DATA *)CoTaskMemAlloc(
                                        sizeof(MMC_COLUMN_SET_DATA) + cbColData);
    
    if (NULL == pColSetData)
    {
        CoTaskMemFree((*ppColSetData)->pColData);
        CoTaskMemFree(*ppColSetData);
        *ppColSetData = NULL;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Copy the column set data

        memcpy(pColSetData, (*ppColSetData), sizeof(MMC_COLUMN_SET_DATA));

        // Set the embedded pointer to point immediately following the
        // MMC_COLUMN_SET_DATA
        
        pColSetData->pColData = (MMC_COLUMN_DATA *)(pColSetData + 1);

        // Copy the column data

        memcpy(pColSetData->pColData, (*ppColSetData)->pColData, cbColData);

        // Free the data returned from the proxy
        
        CoTaskMemFree((*ppColSetData)->pColData);
        CoTaskMemFree(*ppColSetData);

        // Return the new single block pointer to the snap-in
        
        *ppColSetData = pColSetData;
    }

Cleanup:
    return hr;
}


HRESULT STDMETHODCALLTYPE IColumnData_GetColumnConfigData_Stub
( 
    IColumnData __RPC_FAR                    *This,
    SColumnSetID __RPC_FAR                   *pColID,
    MMC_COLUMN_SET_DATA __RPC_FAR *__RPC_FAR *ppColSetData
)
{
    HRESULT          hr = S_OK;
    size_t           cbColData = 0;
    MMC_COLUMN_DATA *pColData = NULL;

    // Call into MMC and get the returned data

    hr = This->lpVtbl->GetColumnConfigData(This, pColID, ppColSetData);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // If no data was returned then there is nothing to do

    if (NULL == *ppColSetData)
    {
        goto Cleanup;
    }

    if (NULL == (*ppColSetData)->pColData)
    {
        goto Cleanup;
    }

    // At this point MMC has returned a pointer to an MMC_COLUMN_SET_DATA
    // that contains an embedded pointer into the same block of memory (pColData).
    // MMC expects that the caller will make a single call to CoTaskMemFree().
    // The MIDL-generated stub thinks the embedded pointer needs to be freed
    // separately so we need to reconstruct the output to use two separate
    // blocks.

    // Allocate a new MMC_COLUMN_DATA array

    cbColData = sizeof(MMC_COLUMN_DATA) * (*ppColSetData)->nNumCols;

    pColData = (MMC_COLUMN_DATA *)CoTaskMemAlloc(cbColData);
    if (NULL == pColData)
    {
        CoTaskMemFree(*ppColSetData);
        *ppColSetData = NULL;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Copy the column data
        memcpy(pColData, (*ppColSetData)->pColData, cbColData);

        // Overwrite the existing embedded pointer. There will be no memory leak
        // because that pointer pointed into the same block as the
        // MMC_COLUMN_SET_DATA and the stub will free the MMC_COLUMN_SET_DATA pointer.
        // Now both pointers can be freed independently as the stub expects.

        (*ppColSetData)->pColData = pColData;
    }

Cleanup:
    return hr;
}



HRESULT STDMETHODCALLTYPE IColumnData_GetColumnSortData_Proxy
( 
    IColumnData __RPC_FAR                  *This,
    SColumnSetID __RPC_FAR                 *pColID,
    MMC_SORT_SET_DATA __RPC_FAR *__RPC_FAR *ppColSortData
)
{
    HRESULT            hr = S_OK;
    size_t             cbSortData = 0;
    MMC_SORT_SET_DATA *pColSortData = NULL;

    // Call the proxy and get the returned data from MMC

    hr = IColumnData_RemGetColumnSortData_Proxy(This, pColID, ppColSortData);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // If no data was returned then there is nothing to do

    if (NULL == *ppColSortData)
    {
        goto Cleanup;
    }

    if (NULL == (*ppColSortData)->pSortData)
    {
        goto Cleanup;
    }

    // At this point the MIDL-generated proxy has returned an MMC_SORT_SET_DATA
    // in which the embedded pointer pSortData points to a separate block of
    // memory which must be freed independently. The snap-in thinks that
    // pSortData points into the same block of memory so it will only call
    // CoTaskMemFree for the MMC_SORT_SET_DATA. We need to allocate a new single
    // block in the format the snap-in is expecting and free the memory returned
    // from the proxy.

    cbSortData = sizeof(MMC_SORT_DATA) * (*ppColSortData)->nNumItems;

    pColSortData = (MMC_SORT_SET_DATA *)CoTaskMemAlloc(
                                         sizeof(MMC_SORT_SET_DATA) + cbSortData);

    if (NULL == pColSortData)
    {
        CoTaskMemFree((*ppColSortData)->pSortData);
        CoTaskMemFree(*ppColSortData);
        *ppColSortData = NULL;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Copy the sort set data

        memcpy(pColSortData, (*ppColSortData), sizeof(MMC_SORT_SET_DATA));

        // Set the embedded pointer to point immediately following the
        // MMC_SORT_SET_DATA

        pColSortData->pSortData = (MMC_SORT_DATA *)(pColSortData + 1);

        // Copy the sort data

        memcpy(pColSortData->pSortData, (*ppColSortData)->pSortData, cbSortData);

        // Free the data returned from the proxy

        CoTaskMemFree((*ppColSortData)->pSortData);
        CoTaskMemFree(*ppColSortData);

        // Return the new single block pointer to the snap-in

        *ppColSortData = pColSortData;
    }

Cleanup:
    return hr;
}


HRESULT STDMETHODCALLTYPE IColumnData_GetColumnSortData_Stub
( 
    IColumnData __RPC_FAR                  *This,
    SColumnSetID __RPC_FAR                 *pColID,
    MMC_SORT_SET_DATA __RPC_FAR *__RPC_FAR *ppColSortData
)
{
    HRESULT        hr = S_OK;
    size_t         cbSortData = 0;
    MMC_SORT_DATA *pSortData = NULL;

    // Call into MMC and get the returned data

    hr = This->lpVtbl->GetColumnSortData(This, pColID, ppColSortData);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // If no data was returned then there is nothing to do

    if (NULL == *ppColSortData)
    {
        goto Cleanup;
    }

    if (NULL == (*ppColSortData)->pSortData)
    {
        goto Cleanup;
    }

    // At this point MMC has returned a pointer to an MMC_SORT_SET_DATA
    // that contains an embedded pointer into the same block of memory (pSortData).
    // MMC expects that the caller will make a single call to CoTaskMemFree().
    // The MIDL-generated stub thinks the embedded pointer needs to be freed
    // separately so we need to reconstruct the output to use two separate
    // blocks.

    // Allocate a new MMC_SORT_DATA array

    cbSortData = sizeof(MMC_SORT_DATA) * (*ppColSortData)->nNumItems;

    pSortData = (MMC_SORT_DATA *)CoTaskMemAlloc(cbSortData);
    if (NULL == pSortData)
    {
        CoTaskMemFree(*ppColSortData);
        *ppColSortData = NULL;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Copy the column data
        memcpy(pSortData, (*ppColSortData)->pSortData, cbSortData);

        // Overwrite the existing embedded pointer. There will be no memory leak
        // because that pointer pointed into the same block as the
        // MMC_SORT_SET_DATA and the stub will free the MMC_SORT_SET_DATA pointer.
        // Now both pointers can be freed independently as the stub expects.

        (*ppColSortData)->pSortData = pSortData;
    }

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\chklst.cpp ===
//=--------------------------------------------------------------------------------------
// chklst.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Multi-select list box with checkbox-like selection
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "chklst.h"

SZTHISFILE

// Checkbox bitmap selection (sections within the source bitmap):
const int kUnchecked         = 0;
const int kChecked           = 1;
const int kDisabledUnchecked = 2;
const int kDisabledChecked   = 3;

// Bitmap dimensions
const int LBOXCXCHECKBMP	 = 11;
const int LBOXCYCHECKBMP	 = 11;

const int kMaxBuffer         = 512;


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Class to store information about items in the checked list
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

//=--------------------------------------------------------------------------------------
// CCheckedListItem::CCheckedListItem(bSelected)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CCheckedListItem::CCheckedListItem(bool bSelected) : m_bSelected(bSelected)
{
}


//=--------------------------------------------------------------------------------------
// CCheckedListItem::~CCheckedListItem()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CCheckedListItem::~CCheckedListItem()
{
}


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Checked list class
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

//=--------------------------------------------------------------------------------------
// CCheckList::CCheckList(int nCtrlID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CCheckList::CCheckList(int nCtrlID) : m_nCtrlID(nCtrlID), m_hwnd(0), m_oldWinProc(0)
{
}


//=--------------------------------------------------------------------------------------
// CCheckList::~CCheckList()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CCheckList::~CCheckList()
{
}


//=--------------------------------------------------------------------------------------
// CCheckList::Attach(HWND hwnd)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::Attach
(
    HWND hwnd
)
{
    HRESULT hr = S_OK;

    m_hwnd = hwnd;
    if (m_hwnd == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK(hr);
    }

    m_oldWinProc = reinterpret_cast<WNDPROC>(::SetWindowLong(m_hwnd, GWL_WNDPROC, reinterpret_cast<LONG>(ListBoxSubClass)));
    ::SetWindowLong(m_hwnd, GWL_USERDATA, reinterpret_cast<LONG>(this));

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::Detach()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::Detach()
{
    HRESULT hr = S_OK;

    ::SetWindowLong(m_hwnd, GWL_WNDPROC, reinterpret_cast<LONG>(m_oldWinProc));

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::AddString(const char *pszText, int *piIndex)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::AddString
(
    const char *pszText,
    int        *piIndex
)
{
    HRESULT hr = S_OK;
    int     iReturnVal = 0;

    iReturnVal = ::SendMessage(m_hwnd, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(pszText));
    if (iReturnVal == LB_ERR)
    {
        hr = S_FALSE;
    }

    *piIndex = iReturnVal;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::SetItemData(int iIndex, void *pvData)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::SetItemData
(
    int   iIndex,
    void *pvData
)
{
    HRESULT hr = S_OK;
    int     iReturnVal = 0;

    iReturnVal = ::SendMessage(m_hwnd, LB_SETITEMDATA, static_cast<WPARAM>(iIndex), reinterpret_cast<LPARAM>(pvData));
    if (iReturnVal == LB_ERR)
    {
        hr = S_FALSE;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::GetItemData(int iIndex, void **ppvData)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::GetItemData
(
    int    iIndex,
    void **ppvData
)
{
    HRESULT  hr = S_OK;
    void    *pvReturnVal = NULL;

    pvReturnVal = reinterpret_cast<void *>(::SendMessage(m_hwnd, LB_GETITEMDATA, static_cast<WPARAM>(iIndex), 0));
    if (pvReturnVal == reinterpret_cast<void *>(LB_ERR))
    {
        hr = S_FALSE;
    }

    *ppvData = pvReturnVal;
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::GetItemCheck(int iIndex, VARIANT_BOOL &bCheck)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::GetItemCheck(int iIndex, VARIANT_BOOL *pbCheck)
{
    HRESULT     hr = S_OK;
    void                *pvReturnVal = NULL;
    CCheckedListItem    *pItem = NULL;

    pvReturnVal = reinterpret_cast<void *>(::SendMessage(m_hwnd, LB_GETITEMDATA, static_cast<WPARAM>(iIndex), 0));
    if (pvReturnVal == reinterpret_cast<void *>(LB_ERR))
    {
        hr = S_FALSE;
    }

    pItem = reinterpret_cast<CCheckedListItem *>(pvReturnVal);
    *pbCheck = (true == pItem->m_bSelected) ? VARIANT_TRUE : VARIANT_FALSE;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::SetItemCheck(int iIndex, VARIANT_BOOL bCheck)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::SetItemCheck(int iIndex, VARIANT_BOOL bCheck)
{
    HRESULT     hr = S_OK;
    void                *pvReturnVal = NULL;
    CCheckedListItem    *pItem = NULL;

    pvReturnVal = reinterpret_cast<void *>(::SendMessage(m_hwnd, LB_GETITEMDATA, static_cast<WPARAM>(iIndex), 0));
    if (pvReturnVal == reinterpret_cast<void *>(LB_ERR))
    {
        hr = S_FALSE;
    }

    pItem = reinterpret_cast<CCheckedListItem *>(pvReturnVal);
    pItem->m_bSelected = (VARIANT_TRUE == bCheck) ? true : false;


    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::GetNumberOfItems(long *plCount)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::GetNumberOfItems(int *piCount)
{
    HRESULT     hr = S_OK;

    *piCount = ::SendMessage(m_hwnd, LB_GETCOUNT, 0, 0);
    if (LB_ERR == *piCount)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK(hr);
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::DrawCheckbox(HDC hdc, bool fChecked, bool fEnabled, RECT *prc)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::DrawCheckbox
(
    HDC   hdc,
    bool  fChecked,
    bool  fEnabled,
    RECT *prc
)
{
    HRESULT hr = S_OK;
    HBITMAP hbmpCheckmark = NULL;
    int     nBitmap = 0;
    int     cxSource = 0;
    int     cySource = 0;
    RECT    rc;
    HDC     hdcMem = NULL;
    HBITMAP hbmpOld = NULL;

    hbmpCheckmark = ::LoadBitmap(GetResourceHandle(), MAKEINTRESOURCE(IDB_BITMAP_CHECKBOX));
    if (hbmpCheckmark == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK(hr);
    }

    if (fChecked == true)
    {
        if (fEnabled == false)
            nBitmap = kDisabledChecked;
        else
            nBitmap = kChecked;
    }
    else
    {
        if (fEnabled == false)
            nBitmap = kDisabledUnchecked;
        else
            nBitmap = kUnchecked;
    }

    cxSource = nBitmap * LBOXCXCHECKBMP;
    cySource = 0;
    rc = *prc;

    hdcMem = ::CreateCompatibleDC(hdc);
    if (hdcMem == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    // Center and left
    rc.top += (rc.bottom - rc.top - LBOXCYCHECKBMP) / 2;

    hbmpOld = SelectBitmap(hdcMem, hbmpCheckmark);
    ::BitBlt(hdc, rc.left, rc.top, LBOXCXCHECKBMP, LBOXCYCHECKBMP, hdcMem, cxSource, cySource, SRCCOPY);

    SelectBitmap(hdcMem, hbmpOld);
    ::DeleteDC(hdcMem);

    prc->left += LBOXCXCHECKBMP + 2;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::DrawText(DRAWITEMSTRUCT *pDrawItemStruct, RECT rc)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::DrawText
(
    DRAWITEMSTRUCT *pDrawItemStruct,
    RECT            rc
)
{
    HRESULT  hr = S_OK;
    int      iItemID = 0;
    int      iResult = 0;
    HBRUSH   hBrush = NULL;
    COLORREF crBkColor = 0;
    COLORREF crTextColor = 0;
    HPEN     hPenOld = NULL;
    HBRUSH   hBrushOld = NULL;
    char     pszBuffer[kMaxBuffer + 1];

    iItemID = static_cast<int>(pDrawItemStruct->itemID);

    if (iItemID != -1 && pDrawItemStruct->itemAction & (ODA_FOCUS | ODA_DRAWENTIRE))
    {
        // if this item has the focus, or has the caret, use highlight colors.
        // Otherwise, use normal window colors.
        if (pDrawItemStruct->itemState & ODS_FOCUS)
        {
            hBrush = ::CreateSolidBrush(::GetSysColor(COLOR_HIGHLIGHT));
            crBkColor = ::GetSysColor(COLOR_HIGHLIGHT);
            crTextColor = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
        }
        else
        {
            hBrush = ::CreateSolidBrush(::GetSysColor(COLOR_WINDOW));
            crBkColor = ::GetSysColor(COLOR_WINDOW);
            crTextColor = ::GetSysColor(COLOR_WINDOWTEXT);
        }

        ::SetTextColor(pDrawItemStruct->hDC, crTextColor);

        // clear a rectangle for painting text and focus rectangles on
        if (::SetBkColor(pDrawItemStruct->hDC, crBkColor) == CLR_INVALID)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        hPenOld = SelectPen(pDrawItemStruct->hDC, GetStockPen(NULL_PEN));
        if (hPenOld == NULL)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        hBrushOld = SelectBrush(pDrawItemStruct->hDC, hBrush);
        if (hBrushOld == NULL)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        ::Rectangle(pDrawItemStruct->hDC, rc.left, rc.top, rc.right + 1, rc.bottom + 1);

        SelectPen(pDrawItemStruct->hDC, hPenOld);
        SelectBrush(pDrawItemStruct->hDC, hBrushOld);
    }

    pszBuffer[0] = '\0';
    ::SendMessage(m_hwnd,
                  LB_GETTEXT,
                  pDrawItemStruct->itemID,
                  reinterpret_cast<LPARAM>(&pszBuffer));

    if (::strlen(pszBuffer) > 0)
    {
        rc.left++;
        rc.right--;

        iResult = ::DrawText(pDrawItemStruct->hDC,
                             reinterpret_cast<const char *>(&pszBuffer),
                             -1,
                             &rc,
                             DT_VCENTER | DT_LEFT | DT_SINGLELINE | DT_NOPREFIX | DT_NOCLIP);
        if (iResult == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::DrawFocus(DRAWITEMSTRUCT *pDrawItemStruct, RECT rc)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::DrawFocus
(
    DRAWITEMSTRUCT *pDrawItemStruct,
    RECT            rc
)
{
    HRESULT hr = S_OK;

    if ((pDrawItemStruct->itemAction & (ODA_FOCUS | ODA_DRAWENTIRE)) && (pDrawItemStruct->itemState & ODS_FOCUS))
    {
        DrawFocusRect(pDrawItemStruct->hDC, &rc);
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::DrawItem(DRAWITEMSTRUCT *pDrawItemStruct)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::DrawItem
(
    DRAWITEMSTRUCT *pDrawItemStruct,
    bool            fChecked
)
{
    HRESULT hr = S_OK;
    RECT    rc;
    bool    fEnabled = true;

    ::SetRect(&rc,
              pDrawItemStruct->rcItem.left,
              pDrawItemStruct->rcItem.top,
              pDrawItemStruct->rcItem.right,
              pDrawItemStruct->rcItem.bottom);

    hr = DrawCheckbox(pDrawItemStruct->hDC, fChecked, fEnabled, &rc);
    IfFailGo(hr);

    hr = DrawText(pDrawItemStruct, rc);
    IfFailGo(hr);

    hr = DrawFocus(pDrawItemStruct, rc);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::OnButtonDown(int ixPos, int iyPos)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CCheckList::OnButtonDown(int ixPos, int iyPos)
{
    HRESULT           hr = S_OK;
    POINT             pt;
    long              lResult = 0;
    int               iIndex = 0;
    RECT              rc;
    CCheckedListItem *pCheckedListItem = NULL;

    pt.x = ixPos;
    pt.y = iyPos;

    lResult = ::SendMessage(m_hwnd, LB_ITEMFROMPOINT, 0, MAKELPARAM(ixPos, iyPos));
    if (HIWORD(lResult) == 0)
    {
        iIndex = LOWORD(lResult);

        lResult = ::SendMessage(m_hwnd, LB_GETITEMRECT, static_cast<WPARAM>(iIndex), reinterpret_cast<LPARAM>(&rc));
        if (lResult != LB_ERR)
        {
            rc.right = rc.left + LBOXCXCHECKBMP;
            rc.bottom = rc.top + LBOXCYCHECKBMP;

            if (PtInRect(&rc, pt) == TRUE)
            {
                hr = GetItemData(iIndex, reinterpret_cast<void **>(&pCheckedListItem));
                IfFailGo(hr);

                if (pCheckedListItem->m_bSelected == true)
                    pCheckedListItem->m_bSelected = false;
                else
                    pCheckedListItem->m_bSelected = true;

                ::PostMessage(::GetParent(m_hwnd), kCheckBoxChanged, static_cast<WPARAM>(iIndex), 0);
            }
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CCheckList::ListBoxSubClass(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
LRESULT CALLBACK CCheckList::ListBoxSubClass
(
    HWND   hwnd,
    UINT   iMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HRESULT      hr = S_OK;
    CCheckList  *pList = NULL;

    pList = reinterpret_cast<CCheckList *>(::GetWindowLong(hwnd, GWL_USERDATA));
    ASSERT(pList != NULL, "ListBoxSubClass: Cannot recover class");

    switch (iMsg)
    {
    case WM_LBUTTONDOWN:
        hr = pList->OnButtonDown(LOWORD(lParam), HIWORD(lParam));
        IfFailGo(hr);
        break;
    }

Error:
    return ::CallWindowProc(pList->m_oldWinProc, hwnd, iMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\common.h ===
//=--------------------------------------------------------------------------------------
// common.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//=------------------------------------------------------------------------------------=
//
// Common header files for mssnapd that cannot be precompiled
//=-------------------------------------------------------------------------------------=

#include <ad98.h>
#include <ctrlobj.h>
#include <proppage.h>
#include <objext.h>
#include "..\..\mssnapr\mssnapr\error.h"
#include "..\..\mssnapr\mssnapr\errors.h"
#include "mssnapd.h"
#include "snaputil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\help\makefile.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

Module Name:

    makefile.inc

Abstract:

    This file implements the target specified in sources in NTTARGETFILE0.
    It executes a VB tool that generates help ID header files and an RC
    file containing all the help strings used by the design time ODL

!ENDIF

GenHelpIDs:
    SET THUNDER55=..\..\..\vb98
    SET TOOLS=TOOLS
	..\..\tools\idheader.bat mssnapd.id $(O)\mssnapd_helpids.h $(O)\mssnapd_helpstrs.h $(O)\mssnapd_helpstrs.rc -NoIncludePath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\ambients.h ===
//=--------------------------------------------------------------------------=
// ambients.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Class definition for CAmbients.
//

#ifndef _AMBIENTS_H_
#define _AMBIENTS_H_

class CAmbients
{
public:
    CAmbients();
    virtual ~CAmbients();

    void Attach(IDispatch *pDispAmbients);
    BOOL Attached() { return (NULL != m_pDispAmbient); }
    void Detach();
    IDispatch *GetDispatch();
    HRESULT GetProjectDirectory(BSTR *pbstrProjDir);
    HRESULT GetDesignerName(BSTR *pbstrName);
    HRESULT GetSaveMode(long *plSaveMode);
    HRESULT GetAmbientProperty(DISPID  dispid, VARTYPE vt, void *pData);
    HRESULT GetProjectName(BSTR* pbstrProjectName);
    HRESULT GetInteractive(BOOL *pfInteractive);

protected:
    IDispatch *m_pDispAmbient;
};


#endif // _AMBIENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\chklst.h ===
//=--------------------------------------------------------------------------------------
// chklst.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CCheckList definition.
//=-------------------------------------------------------------------------------------=

// CCheckList
// This is a listbox class to for owner-drawn listboxes which have multiple
// selection with check boxes instead of highlighting.
// Concept and code sections borrowed from ruby's VBCheckList class.

#ifndef _CHKLIST_H_
#define _CHKLIST_H_


#define kCheckBoxChanged    WM_USER + 1

class CCheckedListItem : public CtlNewDelete, public CError
{
public:
    CCheckedListItem(bool bSelected);
    virtual ~CCheckedListItem();

public:
    bool    m_bSelected;
};


class CCheckList: public CtlNewDelete, public CError
{
public:
    CCheckList(int nCtrlID);
    ~CCheckList();

    HRESULT Attach(HWND hwnd);
    HRESULT Detach();

    HWND Window()       { return m_hwnd;}

public:
    HRESULT AddString(const char *pszText, int *piIndex);
    HRESULT SetItemData(int iIndex, void *pvData);
    HRESULT GetItemData(int iIndex, void **ppvData);
    HRESULT GetItemCheck(int iIndex, VARIANT_BOOL *pbCheck);
    HRESULT SetItemCheck(int iIndex, VARIANT_BOOL bCheck);
    HRESULT GetNumberOfItems(int *piCount);

    HRESULT DrawItem(DRAWITEMSTRUCT *pDrawItemStruct, bool fChecked);

protected:
    static LRESULT CALLBACK ListBoxSubClass(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam);

protected:
    HRESULT DrawFocus(DRAWITEMSTRUCT *pDrawItemStruct, RECT rc);
    HRESULT DrawCheckbox(HDC hdc, bool fChecked, bool fEnabled, RECT *prc);
    HRESULT DrawText(DRAWITEMSTRUCT *pDrawItemStruct, RECT rc);
    HRESULT OnButtonDown(int ixPos, int iyPos);

protected:
    int     m_nCtrlID;
    HWND    m_hwnd;
    WNDPROC m_oldWinProc;
};

#endif  // _CHKLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\desdebug.cpp ===
//=--------------------------------------------------------------------------------------
// dedebug.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// IDesignerDebugging Implementation.
//=-------------------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "desmain.h"

//=--------------------------------------------------------------------------=
//                  IDesignerDebugging Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CSnapInDesigner::BeforeRun(LPVOID FAR* ppvData)
{
    return S_OK;
}

STDMETHODIMP CSnapInDesigner::AfterRun(LPVOID pvData)
{
    return S_OK;
}


STDMETHODIMP CSnapInDesigner::GetStartupInfo(DESIGNERSTARTUPINFO * pStartupInfo)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\datafmt.cpp ===
//=--------------------------------------------------------------------------------------
// datafmt.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- DataFormat-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------
// Manipulating existing IDataFormat's
// Adding, initializing, renaming, deleting and refreshing
//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::GetNewResourceName(BSTR *pbstrResourceFileName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::GetNewResourceName(BSTR *pbstrResourceFileName)
{
    HRESULT              hr = S_OK;
    OPENFILENAME         ofn;
    TCHAR                szFile[260];

    szFile[0] = 0;

    ::memset(&ofn, 0, sizeof(OPENFILENAME));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = m_hwnd;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFilter = _T("XML Files\0*.xml\0");
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    if (TRUE == ::GetOpenFileName(&ofn))
    {
        hr = BSTRFromANSI(szFile, pbstrResourceFileName);
        IfFailGo(hr);
    }
    else
    {
        hr = S_FALSE;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddResource()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddResource()
{
    HRESULT              hr = S_OK;
    BSTR                 bstrResourceFileName = NULL;
    IDataFormats        *piDataFormats = NULL;
    VARIANT              vtEmpty;
    VARIANT              vtFileName;
    IDataFormat         *piDataFormat = NULL;

    ::VariantInit(&vtEmpty);
    ::VariantInit(&vtFileName);

    hr = GetNewResourceName(&bstrResourceFileName);
    IfFailGo(hr);

    if (S_OK == hr)
    {
        hr = m_piSnapInDesignerDef->get_DataFormats(&piDataFormats);
        IfFailGo(hr);

        if (piDataFormats != NULL)
        {
            vtEmpty.vt = VT_ERROR;
            vtEmpty.scode = DISP_E_PARAMNOTFOUND;

            vtFileName.vt = VT_BSTR;
            vtFileName.bstrVal = ::SysAllocString(bstrResourceFileName);
            if (NULL == vtFileName.bstrVal)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK(hr);
            }

            hr = piDataFormats->Add(vtEmpty, vtEmpty, vtFileName, &piDataFormat);
            IfFailGo(hr);
        }
    }

Error:
    ::VariantClear(&vtFileName);
    ::VariantClear(&vtEmpty);
    FREESTRING(bstrResourceFileName);
    RELEASE(piDataFormat);
    RELEASE(piDataFormats);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddDataFormat(CSelectionHolder *pParent, IDataFormat *piDataFormat)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnAddDataFormat(CSelectionHolder *pParent, IDataFormat *piDataFormat)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pDataFormat = NULL;

    ASSERT(NULL != pParent, "OnAddDataFormat: pParent is NULL");
    ASSERT(SEL_XML_RESOURCES == pParent->m_st, "OnAddDataFormat: pParent is not SEL_XML_RESOURCES");
    ASSERT(NULL != piDataFormat, "OnAddDataFormat: piDataFormat is NULL");

    hr = MakeNewDataFormat(piDataFormat, &pDataFormat);
    IfFailGo(hr);

    hr = pDataFormat->RegisterHolder();
    IfFailGo(hr);

    hr = InsertDataFormatInTree(pDataFormat, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pDataFormat);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pDataFormat);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pDataFormat);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameDataFormat(CSelectionHolder *pDataFormat, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameDataFormat(CSelectionHolder *pDataFormat, BSTR bstrNewName)
{
    HRESULT     hr = S_OK;
    BSTR        bstrOldName = NULL;
    TCHAR      *pszName = NULL;

    ASSERT(SEL_XML_RESOURCE_NAME == pDataFormat->m_st, "RenameToolbar: wrong argument");

    hr = m_piDesignerProgrammability->IsValidIdentifier(bstrNewName);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = pDataFormat->m_piObject.m_piDataFormat->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = m_pTreeView->GetLabel(pDataFormat, &bstrOldName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->ChangeText(pDataFormat, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);
    FREESTRING(bstrOldName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteDataFormat(CSelectionHolder *pDataFormat)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteDataFormat(CSelectionHolder *pDataFormat)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    BSTR                 bstrName = NULL;
    VARIANT              vtKey;

    ::VariantInit(&vtKey);

    // Find out who the parent is
    hr = m_pTreeView->GetParent(pDataFormat, &pParent);
    IfFailGo(hr);

    // Remove the ImageList from the appropriate collection
    ASSERT(SEL_XML_RESOURCES == pParent->m_st, "DeleteToolbar: expected another kind of parent");

    hr = pDataFormat->m_piObject.m_piDataFormat->get_Name(&bstrName);
    IfFailGo(hr);

    if (pParent->m_piObject.m_piDataFormats != NULL)
    {
        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrName);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        hr = pParent->m_piObject.m_piDataFormats->Remove(vtKey);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtKey);
    FREESTRING(bstrName);

    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteDataFormat(CSelectionHolder *pDataFormat)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteDataFormat(CSelectionHolder *pDataFormat)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    IDataFormats        *piDataFormats = NULL;
    long                 lCount = 0;

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pDataFormat, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pDataFormat);
    IfFailGo(hr);

    delete pDataFormat;

    // Select the next selection
    hr = m_piSnapInDesignerDef->get_DataFormats(&piDataFormats);
    IfFailGo(hr);

    if (NULL != piDataFormats)
    {
        hr = piDataFormats->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piDataFormats);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RefreshResource(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RefreshResource(CSelectionHolder *pSelection)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewDataFormat(IDataFormat *piDataFormat, CSelectionHolder **ppDataFormat)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewDataFormat(IDataFormat *piDataFormat, CSelectionHolder **ppDataFormat)
{
    HRESULT              hr = S_OK;

    *ppDataFormat = New CSelectionHolder(piDataFormat);
    if (*ppDataFormat == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewDataFormat(piDataFormat);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewDataFormat(IDataFormat *piDataFormat)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewDataFormat(IDataFormat *piDataFormat)
{
    HRESULT           hr = S_OK;
    int               iResult = 0;
    int               iItemNumber = 1;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    bool              bGood = false;
    CSelectionHolder *pDataFormatClone = NULL;

    hr = GetResourceString(IDS_DATAFORMAT, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    do {
        iResult = _stprintf(szName, _T("%s%d"), szBuffer, iItemNumber++);
        if (iResult == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK(hr);
        }

		hr = m_pTreeView->FindLabelInTree(szName, &pDataFormatClone);
		IfFailGo(hr);

        if (S_FALSE == hr)
        {
			hr = BSTRFromANSI(szName, &bstrName);
			IfFailGo(hr);

            bGood = true;
            break;
        }

        FREESTRING(bstrName);
    } while (false == bGood);

    hr = piDataFormat->put_Name(bstrName);
    IfFailGo(hr);

    hr = piDataFormat->put_Key(bstrName);
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertDataFormatInTree(CSelectionHolder *pDataFormat, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertDataFormatInTree(CSelectionHolder *pDataFormat, CSelectionHolder *pParent)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    TCHAR  *pszName = NULL;

    hr = pDataFormat->m_piObject.m_piDataFormat->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kDataFmtIcon, pDataFormat);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\desmain.h ===
//=--------------------------------------------------------------------------------------
// desmain.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInDesigner definition.
//=-------------------------------------------------------------------------------------=

#ifndef _SNAPINDESIGNER_H_

#include "ambients.h"
#include "TreeView.h"
#include "destlib.h"


// UNDONE: REMOVE: When ssulzer puts this in a public header
// We cannot include this directly from vb98\ruby\errvb.h because
// it will pull in other headers with various macros that are
// defined in vb98ctls\include\macros.h and cause a redefinition error.

#ifndef VB_E_IDADONTREPORTME
#define VB_E_IDADONTREPORTME          0x800AEA5FL
#endif


// Message used in our designer at startup
const int CMD_SHOW_MAIN_PROPERTIES      = (WM_USER + 1);      // show props immediately

// Custom message to select views
const int CMD_ADD_EXISTING_VIEW         = (WM_USER + 2);

// Custom message to handle label renames
const int CMD_RENAME_NODE               = (WM_USER + 3);


// Handy definitions for WinProc handling
#define WinProcHandled(bVal)            hr = S_OK; *lResult = (bVal);


////////////////////////////////////////////////////////////////////////////////////
//
// Class MMCViewMenuInfo
//
////////////////////////////////////////////////////////////////////////////////////
class MMCViewMenuInfo
{
public:
    enum MMCViewMenuInfoType { vmitListView = 0, vmitOCXView, vmitURLView, vmitTaskpad };

    MMCViewMenuInfoType m_vmit;
    union
    {
        IListViewDef    *m_piListViewDef;
        IOCXViewDef     *m_piOCXViewDef;
        IURLViewDef     *m_piURLViewDef;
        ITaskpadViewDef *m_piTaskpadViewDef;
    } m_view;

    MMCViewMenuInfo(IListViewDef *piListViewDef) : m_vmit(vmitListView) {
        m_view.m_piListViewDef = piListViewDef;
    }

    MMCViewMenuInfo(IOCXViewDef *piOCXViewDef) : m_vmit(vmitOCXView) {
        m_view.m_piOCXViewDef = piOCXViewDef;
    }

    MMCViewMenuInfo(IURLViewDef *piURLViewDef) : m_vmit(vmitURLView) {
        m_view.m_piURLViewDef = piURLViewDef;
    }

    MMCViewMenuInfo(ITaskpadViewDef *piTaskpadViewDef) : m_vmit(vmitTaskpad) {
        m_view.m_piTaskpadViewDef = piTaskpadViewDef;
    }

    ~MMCViewMenuInfo() { }
};


//=--------------------------------------------------------------------------=
// CSnapInDesigner - The snap-in designer main class. An object of this
// class is created when the designer is added to a VB project.
//=--------------------------------------------------------------------------=

class CSnapInDesigner : public COleControl,
                        public IDispatch,
                        public IActiveDesigner,
                        public IProvideDynamicClassInfo,
                        public ISelectionContainer,
                        public IDesignerDebugging,
                        public IDesignerRegistration,
                        public IObjectModelHost,
                        public CError
{
public:
    CSnapInDesigner(IUnknown *pUnkOuter);
    virtual ~CSnapInDesigner();

    // Static creation function. All controls must have one of these!
    //
    static IUnknown *Create(IUnknown *);
    static HRESULT PreCreateCheck();

public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IDispatch methods
    //
    DECLARE_STANDARD_DISPATCH();

    // ISupportErrorInfo methods
    //
    DECLARE_STANDARD_SUPPORTERRORINFO();

    // IActiveDesigner methods
    //
    STDMETHOD(GetRuntimeClassID)(THIS_ CLSID *pclsid);
    STDMETHOD(GetRuntimeMiscStatusFlags)(THIS_ DWORD *pdwMiscFlags);
    STDMETHOD(QueryPersistenceInterface)(THIS_ REFIID riidPersist);
    STDMETHOD(SaveRuntimeState)(THIS_ REFIID riidPersist, REFIID riidObjStgMed, void *pObjStgMed);
    STDMETHOD(GetExtensibilityObject)(THIS_ IDispatch **ppvObjOut);

    // IProvideDynamicClassInfo
    //
    STDMETHOD(GetDynamicClassInfo)(ITypeInfo **ppTypeInfo, DWORD *pdwCookie);
    STDMETHOD(FreezeShape)(void);

    // IProvideClassInfo
    //
    STDMETHOD(GetClassInfo)(ITypeInfo **ppTypeInfo);

    // ISelectionContainer
    //
    STDMETHOD(CountObjects)(DWORD dwFlags, ULONG *pc);
    STDMETHOD(GetObjects)(DWORD dwFlags, ULONG cObjects, IUnknown **apUnkObjects);
    STDMETHOD(SelectObjects)(ULONG cSelect, IUnknown **apUnkSelect, DWORD dwFlags);

    // IDesignerDebugging
    //
    STDMETHOD(BeforeRun)(LPVOID FAR* ppvData);
    STDMETHOD(AfterRun)(LPVOID pvData);
    STDMETHOD(GetStartupInfo)(DESIGNERSTARTUPINFO * pStartupInfo);

    // IDesignerRegistration
    //
    STDMETHOD(GetRegistrationInfo)(BYTE** ppbRegInfo, ULONG* pcbRegInfo);

    // IOleControlSite overide
    // 
    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);

    // IPersistStreamInit overide
    //
    STDMETHOD(IsDirty)();

    // IObjectModelHost
    //
    STDMETHOD(Update)(long ObjectCookie, IUnknown *punkObject, DISPID dispid);
    STDMETHOD(Add)(long CollectionCookie, IUnknown *punkNewObject);
    STDMETHOD(Delete)(long ObjectCookie, IUnknown *punkObject);
    STDMETHOD(GetSnapInDesignerDef)(ISnapInDesignerDef **ppiSnapInDesignerDef);
    STDMETHOD(GetRuntime)(BOOL *pfRuntime);

public:

    // Utilities provided by this class for the whole designer

    CAmbients *GetAmbients();
    HRESULT AttachAmbients();
    HRESULT UpdateDesignerName();
    HRESULT ValidateName(BSTR bstrName);

protected:

    // Base Control Overidable - Designer window is to be created
    virtual BOOL    BeforeCreateWindow(DWORD *pdwWindowStyle, DWORD *pdwExWindowStyle, LPSTR pszWindowTitle);
    // Base Control Overidable - Designer window is created
    virtual BOOL    AfterCreateWindow(void);
    // Base Control Overidable - Designer window is about to be destroyed
    void BeforeDestroyWindow();
    // Base Control Overidable - IPersistStreamInit::InitNew was called
    virtual BOOL    InitializeNewState();
    // Base Control Overidable - IViewObject::Draw overidable from base control
    STDMETHOD(OnDraw)(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize);
    // Base Control Overidable - Designer's window procedure
    virtual LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam);
    // Base Control Overidable - Register control Window Classes
    virtual BOOL    RegisterClassData(void);
    // Base Control Overidable - Internal QI
    virtual HRESULT InternalQueryInterface(REFIID, void **);
    // Base Control Overidable - Called when site calls IOleObject::SetClientSite()
    virtual HRESULT OnSetClientSite();

    // Base Control Overidable - Load binary state
    STDMETHOD(LoadBinaryState)(IStream *pStream);
    // Base Control Overidable - Save binary state
    STDMETHOD(SaveBinaryState)(IStream *pStream);
    // Base Control Overidable - Load text state
    STDMETHOD(LoadTextState)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);
    // Base Control Overidable - Save text state
    STDMETHOD(SaveTextState)(IPropertyBag *pPropertyBag, BOOL fWriteDefault);


////////////////////////////////////////////////////////////////////////////////////
// WinProc and friends, implemented in winproc.cpp
protected:
    HRESULT InitializeToolbar();

    HRESULT OnResize(UINT msg, WPARAM wParam, LPARAM lParam);
    HRESULT OnCommand(UINT msg, WPARAM wParam, LPARAM lParam);
    HRESULT OnNotify(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *lResult);
    HRESULT OnNeedText(LPARAM lParam);
    HRESULT OnDoubleClick(CSelectionHolder *pSelection);
    HRESULT OnPrepareToolbar();
    HRESULT OnContextMenu(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    HRESULT DoOnContextMenu(int x, int y);
    HRESULT OnInitMenuPopup(HMENU hmenuPopup);
    HRESULT OnKeyDown(NMTVKEYDOWN *pNMTVKeyDown);
    void OnHelp();

    HRESULT OnInitMenuPopupRoot(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupExtensionRoot(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupExtension(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupMyExtensions(HMENU hmenuPopup);

    HRESULT OnInitMenuPopupStaticNode(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupNodeOther(HMENU hmenuPopup);

    HRESULT OnInitMenuPopupNode(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupNodeChildren(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupNodeViews(HMENU hmenuPopup);

    HRESULT OnInitMenuPopupToolsRoot(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupImageLists(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupImageList(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupMenus(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupMenu(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupToolbars(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupToolbar(HMENU hmenuPopup);

    HRESULT OnInitMenuPopupViews(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupListViews(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupOCXViews(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupURLViews(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupTaskpadViews(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupView(HMENU hmenuPopup);

    HRESULT OnInitMenuPopupResources(HMENU hmenuPopup);
    HRESULT OnInitMenuPopupResourceName(HMENU hmenuPopup);

    // The following helper functions are used to construct the dynamic view menu
    HRESULT AddViewToViewMenu(HMENU hMenu, int iMenuItem, char *pszMenuItemText, MMCViewMenuInfo *pMMCViewMenuInfo);

    HRESULT FindListViewInCollection(BSTR bstrName, IListViewDefs *piListViewDefs);
    HRESULT PopulateListViews(HMENU hMenu, int *piCurrentMenuItem, IListViewDefs *piListViewDefs, IListViewDefs *piTargetListViewDefs);

    HRESULT FindOCXViewInCollection(BSTR bstrName, IOCXViewDefs *piOCXViewDefs);
    HRESULT PopulateOCXViews(HMENU hMenu, int *piCurrentMenuItem, IOCXViewDefs *piOCXViewDefs, IOCXViewDefs *piTargetOCXViewDefs);

    HRESULT FindURLViewInCollection(BSTR bstrName, IURLViewDefs *piURLViewDefs);
    HRESULT PopulateURLViews(HMENU hMenu, int *piCurrentMenuItem, IURLViewDefs *piURLViewDefs, IURLViewDefs *piTargetURLViewDefs);

    HRESULT FindTaskpadViewInCollection(BSTR bstrName, ITaskpadViewDefs *piTaskpadViewDefs);
    HRESULT PopulateTaskpadViews(HMENU hMenu, int *piCurrentMenuItem, ITaskpadViewDefs *piTaskpadViewDefs, ITaskpadViewDefs *piTargetTaskpadViewDefs);

    HRESULT PopulateNodeViewsMenu(HMENU hmenuPopup);
    HRESULT CleanPopupNodeViews(HMENU hmenuPopup, int iCmd);

    HWND                 m_hwdToolbar;
    RECT                 m_rcToolbar;


////////////////////////////////////////////////////////////////////////////////////
// Initializing and populating the tree, implemented in tvpopul.cpp
protected:
    HRESULT CreateTreeView();
    HRESULT InitializePresentation();

    HRESULT CreateExtensionsTree(CSelectionHolder *pRoot);
    HRESULT PopulateExtensions(CSelectionHolder *pExtensionsParent);
    HRESULT CreateExtendedSnapIn(CSelectionHolder *pRoot, IExtendedSnapIn *piExtendedSnapIn);
    HRESULT PopulateExtendedSnapIn(CSelectionHolder *pExtendedSnapIn);
    HRESULT PopulateSnapInExtensions(CSelectionHolder *pRoot, IExtensionDefs *piExtensionDefs);

    HRESULT CreateNodesTree(CSelectionHolder *pRoot);
    HRESULT PopulateNodes(CSelectionHolder *pNodesParent);
    HRESULT PopulateAutoCreateNodes(CSelectionHolder *pAutoCreateNodesParent);
    HRESULT CreateAutoCreateSubTree(CSelectionHolder *pAutoCreateNodesParent);
    HRESULT RemoveAutoCreateSubTree();
    HRESULT DeleteSubTree(CSelectionHolder *pNode);
    HRESULT PopulateStaticNodeTree(CSelectionHolder *pStaticNode);
    HRESULT PopulateOtherNodes(CSelectionHolder *pOtherNodesParent);

    HRESULT CreateToolsTree(CSelectionHolder *pRoot);
    HRESULT InitializeToolsTree(CSelectionHolder *pToolsParent);
    HRESULT PopulateImageLists(CSelectionHolder *pImageListsParent);
    HRESULT PopulateMenus(CSelectionHolder *pMenusParent, IMMCMenus *piMMCMenus);
    HRESULT PopulateToolbars(CSelectionHolder *pToolbarsParent);

    HRESULT CreateViewsTree(CSelectionHolder *pRoot);
    HRESULT InitializeViews(CSelectionHolder *pViewsParent);

    HRESULT CreateDataFormatsTree(CSelectionHolder *pRoot);
    HRESULT PopulateDataFormats(CSelectionHolder *pRoot, IDataFormats *piDataFormats);

    HRESULT PopulateListViews(IViewDefs *piViewDefs, CSelectionHolder *pListViewsParent);
    HRESULT PopulateOCXViews(IViewDefs *piViewDefs, CSelectionHolder *pOCXViewsParent);
    HRESULT PopulateURLViews(IViewDefs *piViewDefs, CSelectionHolder *pURLViewsParent);
    HRESULT PopulateTaskpadViews(IViewDefs *piViewDefs, CSelectionHolder *pTaskpadViewsParent);

    HRESULT RegisterViewCollections(CSelectionHolder *pSelection, IViewDefs *piViewDefs);
    HRESULT PopulateNodeTree(CSelectionHolder *pNodeParent, IScopeItemDef *piScopeItemDef);
    HRESULT GetSnapInName(char **ppszNodeName);

private:
    // Tree nodes we cache throughout the lifetime of the designer
    CSelectionHolder    *m_pRootNode;
    CSelectionHolder    *m_pRootNodes;
    CSelectionHolder    *m_pRootExtensions;
    CSelectionHolder    *m_pRootMyExtensions;
    CSelectionHolder    *m_pStaticNode;
    CSelectionHolder	*m_pAutoCreateRoot;
    CSelectionHolder	*m_pOtherRoot;

    CSelectionHolder    *m_pViewListRoot;
    CSelectionHolder    *m_pViewOCXRoot;
    CSelectionHolder    *m_pViewURLRoot;
    CSelectionHolder    *m_pViewTaskpadRoot;

    CSelectionHolder    *m_pToolImgLstRoot;
    CSelectionHolder    *m_pToolMenuRoot;
    CSelectionHolder    *m_pToolToolbarRoot;


////////////////////////////////////////////////////////////////////////////////////
// Object Model notifications handlers
protected:
    HRESULT OnSnapInChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnMyExtensionsChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnExtendedSnapInChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnScopeItemChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnListViewChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnOCXViewChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnURLViewChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnTaskpadViewChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnImageListChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnMenuChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnToolbarChange(CSelectionHolder *pSelection, DISPID dispid);
    HRESULT OnDataFormatChange(CSelectionHolder *pSelection, DISPID dispid);


////////////////////////////////////////////////////////////////////////////////////
// Command handlers
protected:
    // Command multiplexers, file tvcmd.cpp
    HRESULT AddExistingView(MMCViewMenuInfo *pMMCViewMenuInfo);
    HRESULT DoRename(CSelectionHolder *pSelection, TCHAR *pszNewName);
    HRESULT DoDelete(CSelectionHolder *pSelection);
    HRESULT ShowProperties(CSelectionHolder *pSelection);

    // Manipulating the ISnapInDef, file tvcmd.cpp
    HRESULT RenameSnapIn(CSelectionHolder *pSnapIn, BSTR bstrNewName);
    HRESULT ShowSnapInProperties();
    HRESULT ShowSnapInExtensions();

    //
    // Manipulating IExtendedSnapIn's, implemented in file extend.cpp
    // Extending others
    HRESULT OnAddExtendedSnapIn(CSelectionHolder *pParent, IExtendedSnapIn *piExtendedSnapIn);
    HRESULT RenameExtendedSnapIn(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteExtendedSnapIn(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteExtendedSnapIn(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteExtensionNode(SelectionType stExtensionType,
                                CSelectionHolder *pParent);

    HRESULT DoExtensionNewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDoExtensionNewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DoExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDoExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DoExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDoExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn);
    HRESULT DoExtensionTaskpad(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDoExtensionTaskpad(CSelectionHolder *pExtendedSnapIn);
    HRESULT DoExtensionToolbar(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDoExtensionToolbar(CSelectionHolder *pExtendedSnapIn);
    HRESULT DoExtensionNameSpace(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDoExtensionNameSpace(CSelectionHolder *pExtendedSnapIn);

    HRESULT DeleteExtensionNewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteExtensionNewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteExtensionTaskpad(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteExtensionTaskpad(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteExtensionToolbar(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteExtensionToolbar(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteExtensionNameSpace(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteExtensionNameSpace(CSelectionHolder *pExtendedSnapIn);

    // Extending myself
    HRESULT DoMyExtendsNewMenu(CSelectionHolder *pSelection);
    HRESULT OnDoMyExtendsNewMenu(CSelectionHolder *pMyExtensions);
    HRESULT DoMyExtendsTaskMenu(CSelectionHolder *pSelection);
    HRESULT OnDoMyExtendsTaskMenu(CSelectionHolder *pMyExtensions);
    HRESULT DoMyExtendsTopMenu(CSelectionHolder *pSelection);
    HRESULT OnDoMyExtendsTopMenu(CSelectionHolder *pMyExtensions);
    HRESULT DoMyExtendsViewMenu(CSelectionHolder *pMyExtensions);
    HRESULT OnDoMyExtendsViewMenu(CSelectionHolder *pMyExtensions);
    HRESULT DoMyExtendsPPages(CSelectionHolder *pSelection);
    HRESULT OnDoMyExtendsPPages(CSelectionHolder *pMyExtensions);
    HRESULT DoMyExtendsToolbar(CSelectionHolder *pSelection);
    HRESULT OnDoMyExtendsToolbar(CSelectionHolder *pSelection);
    HRESULT DoMyExtendsNameSpace(CSelectionHolder *pMyExtensions);
    HRESULT OnDoMyExtendsNameSpace(CSelectionHolder *pMyExtensions);

    HRESULT DeleteMyExtendsNewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteMyExtendsNewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteMyExtendsTaskMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteMyExtendsTaskMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteMyExtendsTopMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteMyExtendsTopMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteMyExtendsViewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteMyExtendsViewMenu(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteMyExtendsPPages(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteMyExtendsPPages(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteMyExtendsToolbar(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteMyExtendsToolbar(CSelectionHolder *pExtendedSnapIn);
    HRESULT DeleteMyExtendsNameSpace(CSelectionHolder *pExtendedSnapIn);
    HRESULT OnDeleteMyExtendsNameSpace(CSelectionHolder *pExtendedSnapIn);

    HRESULT FindMyExtension(SelectionType stExtensionType, CSelectionHolder **ppExtension);
    HRESULT FindExtension(CSelectionHolder *pRoot, SelectionType stExtensionType,
                          CSelectionHolder **ppExtension);
    //
    // Manipulating IScopeItemDef's, implemented in file scpitm.cpp
    HRESULT AddNewNode();
    HRESULT OnAddScopeItemDef(CSelectionHolder *pParent, IScopeItemDef *piScopeItemDef);
    HRESULT RenameScopeItem(CSelectionHolder *pScopeItem, BSTR bstrNewName);
    HRESULT DeleteScopeItem(CSelectionHolder *pScopeItem);
    HRESULT CanDeleteScopeItem(CSelectionHolder *pScopeItem);
    HRESULT OnDeleteScopeItem(CSelectionHolder *pScopeItem);
    HRESULT ShowNodeProperties(IScopeItemDef *piScopeItemDef);

    HRESULT MakeNewNode(CSelectionHolder *pParent, IScopeItemDef *piScopeItemDef, CSelectionHolder **ppNode);
    HRESULT InitializeNewAutoCreateNode(IScopeItemDef *piScopeItemDef);
    HRESULT InitializeNewOtherNode(IScopeItemDef *piScopeItemDef);
	HRESULT IsAutoCreateChild(CSelectionHolder *pSelection);
    HRESULT InitializeNewChildNode(IScopeItemDef *piScopeItemDef, IScopeItemDefs *piScopeItemDefs);
    HRESULT InsertNodeInTree(CSelectionHolder *pNode, CSelectionHolder *pParent);

    HRESULT GetScopeItemCollection(CSelectionHolder *pScopeItem, IScopeItemDefs **ppiScopeItemDefs);

    //
    // Manipulating IListViewDefs's, implemented in file listvw.cpp
    HRESULT AddListView();
    HRESULT OnAddListViewDef(CSelectionHolder *pParent, IListViewDef *piListViewDef);
    HRESULT AddExistingListView(IViewDefs *piViewDefs, IListViewDef *piListViewDef);
    HRESULT RenameListView(CSelectionHolder *pListView, BSTR bstrNewName);
    HRESULT DeleteListView(CSelectionHolder *pListView);
    HRESULT OnDeleteListView(CSelectionHolder *pListView);
    HRESULT ShowListViewProperties(IListViewDef *piListViewDef);

    HRESULT MakeNewListView(IListViewDefs *piListViewDefs, IListViewDef *piListViewDef, CSelectionHolder **ppListView);
    HRESULT InitializeNewListView(IListViewDefs *piListViewDefs, CSelectionHolder *pListView);
    HRESULT InsertListViewInTree(CSelectionHolder *pListView, CSelectionHolder *pParent);

    //
    // Manipulating IOCXViewDefs's, implemented in file ocxvw.cpp
    HRESULT AddOCXView();
    HRESULT OnAddOCXViewDef(CSelectionHolder *pParent, IOCXViewDef *piOCXViewDef);
    HRESULT AddExistingOCXView(IViewDefs *piViewDefs, IOCXViewDef *piOCXViewDef);
    HRESULT RenameOCXView(CSelectionHolder *pOCXView, BSTR bstrNewName);
    HRESULT DeleteOCXView(CSelectionHolder *pOCXView);
    HRESULT OnDeleteOCXView(CSelectionHolder *pOCXView);
    HRESULT ShowOCXViewProperties(IOCXViewDef *piOCXViewDef);

    HRESULT MakeNewOCXView(IOCXViewDefs *piOCXViewDefs, IOCXViewDef *piOCXViewDef, CSelectionHolder **ppOCXView);
    HRESULT InitializeNewOCXView(IOCXViewDefs *piOCXViewDefs, CSelectionHolder *pOCXView);
    HRESULT InsertOCXViewInTree(CSelectionHolder *pOCXView, CSelectionHolder *pParent);

    //
    // Manipulating IURLViewDefs's, implemented in file urlvw.cpp
    HRESULT AddURLView();
    HRESULT OnAddURLViewDef(CSelectionHolder *pParent, IURLViewDef *piURLViewDef);
    HRESULT AddExistingURLView(IViewDefs *piViewDefs, IURLViewDef *piURLViewDef);
    HRESULT RenameURLView(CSelectionHolder *pURLView, BSTR bstrNewName);
    HRESULT DeleteURLView(CSelectionHolder *pURLView);
    HRESULT OnDeleteURLView(CSelectionHolder *pURLView);
    HRESULT ShowURLViewProperties(IURLViewDef *piURLViewDef);

    HRESULT MakeNewURLView(IURLViewDefs *piURLViewDefs, IURLViewDef *piURLViewDef, CSelectionHolder **ppURLView);
    HRESULT InitializeNewURLView(IURLViewDefs *piURLViewDefs, CSelectionHolder *pURLView);
    HRESULT InsertURLViewInTree(CSelectionHolder *pURLView, CSelectionHolder *pParent);

    //
    // Manipulating ITaskpadViewDefs's, implemented in file taskpvw.cpp
    HRESULT AddTaskpadView();
    HRESULT OnAddTaskpadViewDef(CSelectionHolder *pParent, ITaskpadViewDef *piTaskpadViewDef);
    HRESULT AddExistingTaskpadView(IViewDefs *piViewDefs, ITaskpadViewDef *piTaskpadViewDef);
    HRESULT RenameTaskpadView(CSelectionHolder *pTaskpadView, BSTR bstrNewName);
    HRESULT DeleteTaskpadView(CSelectionHolder *pTaskpadView);
    HRESULT OnDeleteTaskpadView(CSelectionHolder *pTaskpadView);
    HRESULT ShowTaskpadViewProperties(ITaskpadViewDef *piTaskpadViewDef);

    HRESULT MakeNewTaskpadView(ITaskpadViewDefs *piTaskpadViewDefs, ITaskpadViewDef *piTaskpadViewDef, CSelectionHolder **ppTaskpadView);
    HRESULT InitializeNewTaskpadView(ITaskpadViewDefs *piTaskpadViewDefs, CSelectionHolder *pTaskpadView);
    HRESULT InsertTaskpadViewInTree(CSelectionHolder *pTaskpadView, CSelectionHolder *pParent);

    //
    // IViewDef's helpers, implemented in file taskpvw.cpp
    HRESULT GetOwningViewCollection(IViewDefs **ppiViewDefs);
    HRESULT GetOwningViewCollection(CSelectionHolder *pView, IViewDefs **ppiViewDefs);
    HRESULT IsSatelliteView(CSelectionHolder *pView);
    HRESULT IsSatelliteCollection(CSelectionHolder *pViewCollection);

    //
    // Manipulating IMMCImageList's, implemented in file imglist.cpp
    HRESULT AddImageList();
    HRESULT OnAddMMCImageList(CSelectionHolder *pParent, IMMCImageList *piMMCImageList);
    HRESULT RenameImageList(CSelectionHolder *pImageList, BSTR bstrNewName);
    HRESULT DeleteImageList(CSelectionHolder *pImageList);
    HRESULT OnDeleteImageList(CSelectionHolder *pImageList);
    HRESULT ShowImageListProperties(IMMCImageList *piMMCImageList);

    HRESULT MakeNewImageList(IMMCImageLists *piMMCImageLists, IMMCImageList *piMMCImageList, CSelectionHolder **ppImageList);
    HRESULT InitializeNewImageList(IMMCImageLists *piMMCImageLists, IMMCImageList *piMMCImageList);
    HRESULT InsertImageListInTree(CSelectionHolder *pImageList, CSelectionHolder *pParent);

    //
    // Manipulating IMMCMenu's, implemented in file menu.cpp
    HRESULT AddMenu(CSelectionHolder *pSelection);
    HRESULT DemoteMenu(CSelectionHolder *pMenu);
    HRESULT PromoteMenu(CSelectionHolder *pMenu);
    HRESULT MoveMenuUp(CSelectionHolder *pMenu);
    HRESULT MoveMenuDown(CSelectionHolder *pMenu);
    HRESULT OnAddMMCMenu(CSelectionHolder *pParent, IMMCMenu *piMMCMenu);
    HRESULT RenameMenu(CSelectionHolder *pMenu, BSTR bstrNewName);
    HRESULT DeleteMenu(CSelectionHolder *pMenu);
    HRESULT OnDeleteMenu(CSelectionHolder *pMenu);

    HRESULT MakeNewMenu(IMMCMenu *piMMCMenu, CSelectionHolder **ppMenu);
    HRESULT InitializeNewMenu(IMMCMenu *piMMCMenu);
    HRESULT InsertMenuInTree(CSelectionHolder *pMenu, CSelectionHolder *pParent);
    HRESULT DeleteMenuTreeTypeInfo(IMMCMenu *piMMCMenu);
            
    HRESULT AssignMenuDispID(CSelectionHolder *pMenuTarget, CSelectionHolder *pMenuSrc);
    HRESULT SetMenuKey(CSelectionHolder *pMenu);
	HRESULT UnregisterMenuTree(CSelectionHolder *pMenu);
    HRESULT IsTopLevelMenu(CSelectionHolder *pMenu);
    HRESULT CanPromoteMenu(CSelectionHolder *pMenu);
    HRESULT CanDemoteMenu(CSelectionHolder *pMenu);
    HRESULT CanMoveMenuUp(CSelectionHolder *pMenu);
    HRESULT CanMoveMenuDown(CSelectionHolder *pMenu);

    //
    // Manipulating IMMCToolbar's, implemented in file toolbar.cpp
    HRESULT AddToolbar();
    HRESULT OnAddMMCToolbar(CSelectionHolder *pParent, IMMCToolbar *piMMCToolbar);
    HRESULT RenameToolbar(CSelectionHolder *pToolbar, BSTR bstrNewName);
    HRESULT DeleteToolbar(CSelectionHolder *pToolbar);
    HRESULT OnDeleteToolbar(CSelectionHolder *pToolbar);
    HRESULT ShowToolbarProperties(IMMCToolbar *piMMCToolbar);

    HRESULT MakeNewToolbar(IMMCToolbars *piMMCToolbars, IMMCToolbar *piMMCToolbar, CSelectionHolder **ppToolbar);
    HRESULT InitializeNewToolbar(IMMCToolbars *piMMCToolbars, IMMCToolbar *piMMCToolbar);
    HRESULT InsertToolbarInTree(CSelectionHolder *pToolbar, CSelectionHolder *pParent);

    //
    // Manipulating IDataFormat's, implemented in file datafmt.cpp
    HRESULT AddResource();
    HRESULT OnAddDataFormat(CSelectionHolder *pParent, IDataFormat *piDataFormat);
    HRESULT RenameDataFormat(CSelectionHolder *pDataFormat, BSTR bstrNewName);
    HRESULT DeleteDataFormat(CSelectionHolder *pDataFormat);
    HRESULT OnDeleteDataFormat(CSelectionHolder *pDataFormat);
    HRESULT RefreshResource(CSelectionHolder *pSelection);

    HRESULT GetNewResourceName(BSTR *pbstrResourceFileName);
    HRESULT MakeNewDataFormat(IDataFormat *piDataFormat, CSelectionHolder **ppDataFormat);
    HRESULT InitializeNewDataFormat(IDataFormat *piDataFormat);
    HRESULT InsertDataFormatInTree(CSelectionHolder *pDataFormat, CSelectionHolder *pParent);

    // Dialog Unit converter dialog box (dlgunits.cpp)
    HRESULT ShowDlgUnitConverter();


private:
    int     m_iNextNodeNumber;
    bool    m_bDoingPromoteOrDemote;

////////////////////////////////////////////////////////////////////////////////////
// Selection handling
protected:
    HRESULT OnSelectionChanged(CSelectionHolder *pNewSelection);

private:
    CSelectionHolder    *m_pCurrentSelection;


////////////////////////////////////////////////////////////////////////////////////
// Implementation
private:

    void InitMemberVariables();
    HRESULT InitializeNewDesigner(ISnapInDef *piSnapInDef);

    HRESULT GetHostServices(BOOL fInteractive);
    HRESULT CreateExtensibilityModel();
    HRESULT DestroyExtensibilityModel();
    HRESULT SetObjectModelHost();
    HRESULT AddNodeType(INodeTypes *piNodeTypes, BSTR bstrName, BSTR bstrGUID);
    HRESULT AddNodeTypes(IScopeItemDefs *piScopeItemDefs, INodeTypes *piNodeTypes);
    HRESULT AddListViewNodeTypes(IListViewDefs *piListViewDefs, INodeTypes *piNodeTypes);


    BSTR                      m_bstrName;                  // Name of the designer
    ICodeNavigate2           *m_piCodeNavigate2;           // host service to navigate to code window
    ITrackSelection          *m_piTrackSelection;          // host service to inform VB of selection change
    IProfferTypeLib          *m_piProfferTypeLib;          // host service to add tlb to VB project's references
    IDesignerProgrammability *m_piDesignerProgrammability; // host service used to ensure valid property names
    IHelp                    *m_piHelp;                    // host service to display help topic
    CAmbients                 m_Ambients;                  // ambient dispatch wrapper

    ISnapInDesignerDef       *m_piSnapInDesignerDef;       // top of extensibility object model
    CTreeView                *m_pTreeView;                 // Our tree view
    CSnapInTypeInfo          *m_pSnapInTypeInfo;           // Dynamic type info
    BOOL                      m_bDidLoad;
};



DEFINE_CONTROLOBJECT3(SnapInDesigner,                  // name
                      &CLSID_SnapInDesigner,           // CLSID
                      "SnapIn",                        // ProgID
                      "SnapIn",                        // Registry display name
                      CSnapInDesigner::PreCreateCheck, // pre-create function
                      CSnapInDesigner::Create,         // create function
                      1,                               // major version
                      0,                               // minor version
                      &IID_IDispatch,                  // main interface
                      HELP_FILENAME,                   // help file name
                      NULL,                            // events interface
                      OLEMISC_SETCLIENTSITEFIRST | OLEMISC_ACTIVATEWHENVISIBLE | OLEMISC_RECOMPOSEONRESIZE | OLEMISC_CANTLINKINSIDE | OLEMISC_INSIDEOUT | OLEMISC_INVISIBLEATRUNTIME,
                      0,                               // no IPointerInactive policy by default
                      IDB_TOOLBAR,                     // toolbox bitmap resource ID
                      "SnapInDesignerWndClass",        // Window class name
                      0,                               // no. of property pages
                      NULL,                            // property page GUIDs
                      0,                               // no. of custom verbs
                      NULL,                            // custom verb descriptions
                      TRUE);                           // thread safe


#define _SNAPINDESIGNER_H_
#endif // _SNAPINDESIGNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\dlgunits.cpp ===
//=--------------------------------------------------------------------------------------
// dlgunits.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Dialog Unit Converter Dialog Box
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "desmain.h"
#include "..\..\mssnapr\mssnapr\prpchars.h"

// for ASSERT and FAIL
//
SZTHISFILE



static HRESULT Calc(HWND hwndDlg)
{
    HRESULT hr = S_OK;
    BOOL    fTranslated = FALSE;
    int     xDLUs = 0;
    int     yDLUs = 0;
    UINT    cxChar = 0;
    UINT    cyChar = 0;
    UINT    xPixels = 0;
    UINT    yPixels = 0;
    UINT    xTwips = 0;
    UINT    yTwips = 0;
    UINT    xPoints = 0;
    UINT    yPoints = 0;
    double  xR4Points = 0;
    double  yR4Points = 0;
    HDC     hdc = NULL;

    // Blank out all the calculated fields
    
    IfFalseGo(::SetDlgItemText(hwndDlg, IDC_STATIC_PIXELS_WIDTH, ""), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemText(hwndDlg, IDC_STATIC_PIXELS_HEIGHT, ""), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemText(hwndDlg, IDC_STATIC_TWIPS_WIDTH, ""), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemText(hwndDlg, IDC_STATIC_PIXELS_HEIGHT, ""), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemText(hwndDlg, IDC_STATIC_POINTS_WIDTH, ""), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemText(hwndDlg, IDC_STATIC_POINTS_HEIGHT, ""), HRESULT_FROM_WIN32(::GetLastError()));

    // Get the width and height in dialog units specified by the user

    xDLUs = ::GetDlgItemInt(hwndDlg, IDC_EDIT_WIDTH, &fTranslated, FALSE);
    IfFalseGo(fTranslated, HRESULT_FROM_WIN32(::GetLastError()));

    yDLUs = ::GetDlgItemInt(hwndDlg, IDC_EDIT_HEIGHT, &fTranslated, FALSE);
    IfFalseGo(fTranslated, HRESULT_FROM_WIN32(::GetLastError()));

    // Get the average character height and width in a Win32 property sheet

    IfFailGo(::GetPropSheetCharSizes(&cxChar, &cyChar));

    // Calculate and display the pixel values

    xPixels = (xDLUs * cxChar) / 4;
    yPixels = (yDLUs * cyChar) / 8;

    IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_STATIC_PIXELS_WIDTH, xPixels, FALSE), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_STATIC_PIXELS_HEIGHT, yPixels, FALSE), HRESULT_FROM_WIN32(::GetLastError()));

    // Get a screen DC
    hdc = ::GetDC(NULL);
    IfFalseGo(NULL != hdc, HRESULT_FROM_WIN32(::GetLastError()));

    // Calculate and display the points values.
    // A point = 1/72 inch
    // (Pixels per point) = (pixels per logical inch) / 72.
    // Points = pixels / (pixels per point).

    xR4Points  = (float)xPixels / ((float)::GetDeviceCaps(hdc, LOGPIXELSX) / 72.0);
    yR4Points  = (float)yPixels / ((float)::GetDeviceCaps(hdc, LOGPIXELSY) / 72.0);

    xPoints = (UINT)xR4Points;
    yPoints = (UINT)yR4Points;

    IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_STATIC_POINTS_WIDTH, xPoints, FALSE), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_STATIC_POINTS_HEIGHT, yPoints, FALSE), HRESULT_FROM_WIN32(::GetLastError()));

    // Calculate and display the twips values. A twip is 1/20 of a point so just
    // multiply by 20.

    IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_STATIC_TWIPS_WIDTH, xPoints * 20, FALSE), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_STATIC_TWIPS_HEIGHT, yPoints * 20, FALSE), HRESULT_FROM_WIN32(::GetLastError()));


Error:
    if (NULL != hdc)
    {
        (void)::ReleaseDC(NULL, hdc);
    }
    return hr;
}


static HRESULT CenterDialog(HWND hwndDlg)
{
    HRESULT hr = S_OK;
    int     nScreenWidth = ::GetSystemMetrics(SM_CXSCREEN);
    int     nScreenHeight = ::GetSystemMetrics(SM_CYSCREEN);
    int     nDlgWidth = 0;
    int     nDlgHeight = 0;
    BOOL    fRet = FALSE;

    RECT rectDlg = { 0, 0, 0, 0 };

    IfFalseGo(::GetWindowRect(hwndDlg, &rectDlg), HRESULT_FROM_WIN32(::GetLastError()));

    nDlgWidth = (rectDlg.right - rectDlg.left);
    nDlgHeight = (rectDlg.bottom - rectDlg.top);

    fRet = ::MoveWindow(hwndDlg, 
                        (int)((nScreenWidth - nDlgWidth) / 2), 
                        (int)((nScreenHeight - nDlgHeight) / 2),
                        nDlgWidth,
                        nDlgHeight,
                        FALSE);
    IfFalseGo(fRet, HRESULT_FROM_WIN32(::GetLastError()));

Error:
    RRETURN(hr);
}


static BOOL DlgUnitsDlgProc
(
    HWND   hwndDlg,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    BOOL    fProcessed = FALSE;
    HRESULT hr = S_OK;

    switch (msg)
    {
        case WM_INITDIALOG:
            IfFailGo(::CenterDialog(hwndDlg));
            IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_EDIT_HEIGHT, 218, FALSE), HRESULT_FROM_WIN32(::GetLastError()));
            IfFalseGo(::SetDlgItemInt(hwndDlg, IDC_EDIT_WIDTH, 252, FALSE), HRESULT_FROM_WIN32(::GetLastError()));
            IfFalseGo(::PostMessage(hwndDlg, WM_COMMAND,
                                   MAKEWPARAM(ID_BUTTON_CALC, BN_CLICKED),
                                   (LPARAM)::GetDlgItem(hwndDlg, ID_BUTTON_CALC)),
                      HRESULT_FROM_WIN32(::GetLastError()));
            fProcessed = TRUE;
            break;

        case WM_HELP:
            g_GlobalHelp.ShowHelp(HID_mssnapd_DlgUnits);
            fProcessed = TRUE;
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case ID_BUTTON_CALC:
                    IfFailGo(::Calc(hwndDlg));
                    fProcessed = TRUE;
                    break;

                case IDHELP:
                    g_GlobalHelp.ShowHelp(HID_mssnapd_DlgUnits);
                    fProcessed = TRUE;
                    break;

                case IDOK:
                case IDCANCEL:
                    ::EndDialog(hwndDlg, 0);
                    fProcessed = TRUE;
                    break;

                default:
                    break;
            }
            break;

        default:
            break;
    }

Error:
    if (FAILED(hr))
    {
        ::EndDialog(hwndDlg, static_cast<int>(hr));
    }
    
    return fProcessed;
}



HRESULT CSnapInDesigner::ShowDlgUnitConverter()
{
    HRESULT hr = S_OK;
    int iRc = ::DialogBox(GetResourceHandle(),
                          MAKEINTRESOURCE(IDD_DIALOG_DLGUNITS),
                          m_hwnd,
                          reinterpret_cast<DLGPROC>(DlgUnitsDlgProc));
    if (-1 == iRc)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        hr = static_cast<HRESULT>(iRc);
    }

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\destlib.h ===
//=--------------------------------------------------------------------------------------
// destlib.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Dynamic Type Library encapsulation
//=-------------------------------------------------------------------------------------=

#ifndef _MMCDESIGNER_TYPE_LIB_
#define _MMCDESIGNER_TYPE_LIB_

#include "dtypelib.h"

const DISPID    DISPID_OBJECT_PROPERTY_START = 0x00000500;


class CSnapInTypeInfo : public CDynamicTypeLib
{
public:
    CSnapInTypeInfo();
    virtual ~CSnapInTypeInfo();

    HRESULT InitializeTypeInfo(ISnapInDef *piSnapInDef, BSTR bstrSnapIn);

	inline HRESULT GetTypeInfo(ITypeInfo **ppiTypeInfo)
	{
		return m_pcti2CoClass->QueryInterface(IID_ITypeInfo, reinterpret_cast<void **>(ppiTypeInfo));
	}

    bool ResetDirty()
    {
        bool    bWasDirty = m_bDirty;
        m_bDirty = false;
        return bWasDirty;
    }

    DWORD GetCookie() { return m_dwTICookie; }
    void SetCookie(DWORD dwCookie) { m_dwTICookie = dwCookie; }

    HRESULT RenameSnapIn(BSTR bstrOldName, BSTR bstrNewName);

    HRESULT AddImageList(IMMCImageList *piMMCImageList);
    HRESULT RenameImageList(IMMCImageList *piMMCImageList, BSTR bstrOldName);
    HRESULT DeleteImageList(IMMCImageList *piMMCImageList);

    HRESULT AddToolbar(IMMCToolbar *piMMCToolbar);
    HRESULT RenameToolbar(IMMCToolbar *piMMCToolbar, BSTR bstrOldName);
    HRESULT DeleteToolbar(IMMCToolbar *piMMCToolbar);

    HRESULT AddMenu(IMMCMenu *piMMCMenu);
    HRESULT RenameMenu(IMMCMenu *piMMCMenu, BSTR bstrOldName);
    HRESULT DeleteMenu(IMMCMenu *piMMCMenu);
    HRESULT DeleteMenuNamed(BSTR bstrName);

    HRESULT IsNameDefined(BSTR bstrName);

protected:
	// Utility functions
	HRESULT GetSnapInLib();
    HRESULT GetSnapInTypeInfo(ITypeInfo **pptiSnapIn, ITypeInfo **pptiSnapInEvents);
    HRESULT CloneSnapInEvents(ITypeInfo *ptiSnapInEvents, ICreateTypeInfo **ppiCreateTypeInfo, BSTR bstrName);
    HRESULT MakeDirty();

    HRESULT CreateDefaultInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiTemplate);
    HRESULT CreateEventsInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiTemplate);

protected:
	// SnapInDesignerDef's type library, source of our templates
	ITypeLib			*m_pSnapInTypeLib;

	// CoClass information
	ICreateTypeInfo2	*m_pcti2CoClass;
	GUID				 m_guidCoClass;			

	// SnapInDesignerDef' interfaces
    ICreateTypeInfo		*m_pctiDefaultInterface;
    GUID                 m_guidDefaultInterface;
    ICreateTypeInfo		*m_pctiEventInterface;
    GUID                 m_guidEventInterface;

    DISPID               m_nextMemID;
    bool                 m_bDirty;
    bool                 m_bInitialized;
    DWORD                m_dwTICookie;                // host typeinfo cookie

};


#endif  // _MMCDESIGNER_TYPE_LIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\desreg.cpp ===
//=--------------------------------------------------------------------------------------
// register.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Registration functions.
//=-------------------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "desmain.h"

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
//                  IDesignerRegistration Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetRegistrationInfo         [IDesignerRegistration]
//=--------------------------------------------------------------------------=
//
// Parameters:
//      BYTE  **ppbRegInfo [out] buffer containing data to pass to
//                               DllRegistration (CoTaskMemAlloc()ed)
//      ULONG  *pcbRegInfo [out] length of data
//
// Output:
//      HRESULT
//
// Notes:
//
// Populates the RegInfo object from SnapInDesignerDef and serializes it
// to a stream on an HGLOBAL and then copies it to CoTaskMemAlloc()ed buffer.
//
// RegInfo contains:
//      1) A NodeType collection with an item for each extensible node
//         defined by this snap-in. The first item in this collection is
//         always present and represents the snap-in's static node.
//      2) An ExtendedSnapIn collection with an item for each snap-in extended
//         by this snap-in.


STDMETHODIMP CSnapInDesigner::GetRegistrationInfo
(
    BYTE  **ppbRegInfo,
    ULONG  *pcbRegInfo
)
{
    HRESULT             hr = S_OK;
    IRegInfo           *piRegInfo= NULL;
    IPersistStreamInit *piPersistStreamInit = NULL;
    IPersistStream     *piPersistStream = NULL;
    ISnapInDef         *piSnapInDef = NULL;
    IScopeItemDefs     *piScopeItemDefs = NULL;
    IViewDefs          *piViewDefs = NULL;
    IListViewDefs      *piListViewDefs = NULL;
    INodeTypes         *piNodeTypes = NULL;
    IExtensionDefs     *piExtensionDefs = NULL;
    IExtendedSnapIns   *piExtendedSnapIns = NULL;
    HGLOBAL             hglobal = NULL;
    IStream            *piStream = NULL;
    BYTE               *pbBuffer = NULL;
    ULONG               cbBuffer = 0;
    BSTR                bstrName = NULL;
    BSTR                bstrGUID = NULL;
    SnapInTypeConstants Type = siStandAlone;
    VARIANT_BOOL        fStandAlone = VARIANT_FALSE;
    VARIANT_BOOL        fExtensible = VARIANT_FALSE;

    // Get the RegInfo object and InitNew it so we start clean

    IfFailGo(m_piSnapInDesignerDef->get_RegInfo(&piRegInfo));
    IfFailGo(piRegInfo->QueryInterface(IID_IPersistStreamInit,
                                       reinterpret_cast<void **>(&piPersistStreamInit)));
    IfFailGo(piPersistStreamInit->InitNew());

    // Get sub-objects we need
    
    IfFailGo(m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef));

    // Set the display name

    IfFailGo(piSnapInDef->get_DisplayName(&bstrName));
    IfFailGo(piRegInfo->put_DisplayName(bstrName));
    FREESTRING(bstrName);

    // Set the static node type GUID
    IfFailGo(piSnapInDef->get_NodeTypeGUID(&bstrGUID));
    IfFailGo(piRegInfo->put_StaticNodeTypeGUID(bstrGUID));
    // Don't free GUID here as it may be needed to register the node type

    // Determine whether the snap-in can be created standalone

    IfFailGo(piSnapInDef->get_Type(&Type));
    if (siExtension != Type)
    {
        fStandAlone = VARIANT_TRUE; // either stand-alone or dual-mode
    }
    IfFailGo(piRegInfo->put_StandAlone(fStandAlone));

    // Add an item to the node types collection for each node that is
    // extensible. Check the static node followed by the nodes collections.

    IfFailGo(piRegInfo->get_NodeTypes(&piNodeTypes));

    IfFailGo(piSnapInDef->get_Extensible(&fExtensible));
    if (VARIANT_TRUE == fExtensible)
    {
        IfFailGo(piSnapInDef->get_NodeTypeName(&bstrName));
        IfFailGo(AddNodeType(piNodeTypes, bstrName, bstrGUID));
        FREESTRING(bstrName);
        FREESTRING(bstrGUID);
    }

    IfFailGo(m_piSnapInDesignerDef->get_AutoCreateNodes(&piScopeItemDefs));
    IfFailGo(AddNodeTypes(piScopeItemDefs, piNodeTypes));
    RELEASE(piScopeItemDefs);

    IfFailGo(m_piSnapInDesignerDef->get_OtherNodes(&piScopeItemDefs));
    IfFailGo(AddNodeTypes(piScopeItemDefs, piNodeTypes));

    IfFailGo(m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs));
    IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));
    IfFailGo(AddListViewNodeTypes(piListViewDefs, piNodeTypes));

    // Borrow the extended snap-ins object from the designer for the
    // serialization
    
    IfFailGo(m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs));
    IfFailGo(piExtensionDefs->get_ExtendedSnapIns(&piExtendedSnapIns));
    IfFailGo(piRegInfo->putref_ExtendedSnapIns(piExtendedSnapIns));

    // Serialize the RegInfo object into a GlobalAlloc()ed buffer

    hr = ::CreateStreamOnHGlobal(NULL, // Allocate buffer
                                 TRUE, // Free buffer on release
                                 &piStream);
    EXCEPTION_CHECK_GO(hr);

    IfFailGo(piRegInfo->QueryInterface(IID_IPersistStream,
                                       reinterpret_cast<void **>(&piPersistStream)));
    IfFailGo(::OleSaveToStream(piPersistStream, piStream));

    // Get the HGLOBAL and copy the contents to a CoTaskMemAlloc()ed buffer
    
    hr = ::GetHGlobalFromStream(piStream, &hglobal);
    EXCEPTION_CHECK_GO(hr);

    cbBuffer = (ULONG)::GlobalSize(hglobal);
    if (0 == cbBuffer)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    pbBuffer = (BYTE *)::GlobalLock(hglobal);
    if (NULL == pbBuffer)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    *ppbRegInfo = (BYTE *)::CoTaskMemAlloc(cbBuffer + sizeof(ULONG));
    if (NULL == *ppbRegInfo)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Put the length in the first ULONG followed by the stream contents

    *((ULONG *)(*ppbRegInfo)) = cbBuffer;

    ::memcpy(*ppbRegInfo + sizeof(ULONG), pbBuffer, cbBuffer);
    *pcbRegInfo = cbBuffer + sizeof(ULONG);

Error:
    if (FAILED(hr))
    {
        *ppbRegInfo = NULL;
        *pcbRegInfo = 0;
    }
    QUICK_RELEASE(piRegInfo);
    QUICK_RELEASE(piPersistStreamInit);
    QUICK_RELEASE(piPersistStream);
    QUICK_RELEASE(piSnapInDef);
    QUICK_RELEASE(piScopeItemDefs);
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piListViewDefs);
    QUICK_RELEASE(piNodeTypes);
    QUICK_RELEASE(piExtensionDefs);
    QUICK_RELEASE(piExtendedSnapIns);
    (void)::GlobalUnlock(hglobal);
    QUICK_RELEASE(piStream);
    FREESTRING(bstrName);
    FREESTRING(bstrGUID);
    RRETURN(hr);
}





HRESULT CSnapInDesigner::AddNodeType
(
    INodeTypes *piNodeTypes,
    BSTR        bstrName,
    BSTR        bstrGUID
)
{
    HRESULT    hr = S_OK;
    INodeType *piNodeType = NULL;
    VARIANT    varUnspecified;
    ::VariantInit(&varUnspecified);

    varUnspecified.vt = VT_ERROR;
    varUnspecified.scode = DISP_E_PARAMNOTFOUND;

    IfFailGo(piNodeTypes->Add(varUnspecified, varUnspecified, &piNodeType));
    IfFailGo(piNodeType->put_Name(bstrName));
    IfFailGo(piNodeType->put_GUID(bstrGUID));

Error:
    QUICK_RELEASE(piNodeType);
    RRETURN(hr);
}



HRESULT CSnapInDesigner::AddNodeTypes
(
    IScopeItemDefs *piScopeItemDefs,
    INodeTypes     *piNodeTypes
)
{
    HRESULT         hr = S_OK;
    IScopeItemDef  *piScopeItemDef = NULL;
    IScopeItemDefs *piChildren = NULL;
    long            cItems = 0;
    VARIANT_BOOL    fExtensible = VARIANT_FALSE;
    BSTR            bstrName = NULL;
    BSTR            bstrGUID = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    IfFailGo(piScopeItemDefs->get_Count(&cItems));
    IfFalseGo(0 != cItems, S_OK);

    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;

    while (varIndex.lVal <= cItems)
    {
        IfFailGo(piScopeItemDefs->get_Item(varIndex, &piScopeItemDef));
        IfFailGo(piScopeItemDef->get_Extensible(&fExtensible));
        if (VARIANT_TRUE == fExtensible)
        {
            IfFailGo(piScopeItemDef->get_NodeTypeName(&bstrName));
            IfFailGo(piScopeItemDef->get_NodeTypeGUID(&bstrGUID));
            IfFailGo(AddNodeType(piNodeTypes, bstrName, bstrGUID));
            FREESTRING(bstrName);
            FREESTRING(bstrGUID);
        }

        // NTBUGS 354572 Call this function recursively to process this
        // node's children
        IfFailGo(piScopeItemDef->get_Children(&piChildren));
        IfFailGo(AddNodeTypes(piChildren, piNodeTypes));
        
        RELEASE(piScopeItemDef);
        varIndex.lVal++;
    }

Error:
    QUICK_RELEASE(piScopeItemDef);
    QUICK_RELEASE(piChildren);
    FREESTRING(bstrName);
    FREESTRING(bstrGUID);
    RRETURN(hr);
}



HRESULT CSnapInDesigner::AddListViewNodeTypes
(
    IListViewDefs *piListViewDefs,
    INodeTypes    *piNodeTypes
)
{
    HRESULT        hr = S_OK;
    IListViewDef  *piListViewDef = NULL;
    long           cItems = 0;
    VARIANT_BOOL   fExtensible = VARIANT_FALSE;
    BSTR           bstrName = NULL;
    BSTR           bstrGUID = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    IfFailGo(piListViewDefs->get_Count(&cItems));
    IfFalseGo(0 != cItems, S_OK);

    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;

    while (varIndex.lVal <= cItems)
    {
        IfFailGo(piListViewDefs->get_Item(varIndex, &piListViewDef));
        IfFailGo(piListViewDef->get_Extensible(&fExtensible));
        if (VARIANT_TRUE == fExtensible)
        {
            IfFailGo(piListViewDef->get_Name(&bstrName));
            IfFailGo(piListViewDef->get_DefaultItemTypeGUID(&bstrGUID));
            IfFailGo(AddNodeType(piNodeTypes, bstrName, bstrGUID));
            FREESTRING(bstrName);
            FREESTRING(bstrGUID);
        }
        RELEASE(piListViewDef);
        varIndex.lVal++;
    }

Error:
    QUICK_RELEASE(piListViewDef);
    FREESTRING(bstrName);
    FREESTRING(bstrGUID);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\desmain.cpp ===
//=--------------------------------------------------------------------------------------
// desmain.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation
//=-------------------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "desmain.h"


// for ASSERT and FAIL
//
SZTHISFILE


const int   kMaxBuffer = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PreCreateCheck
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Pre create check used to ensure dev's environment is setup to run
//      the designer
//
HRESULT CSnapInDesigner::PreCreateCheck
(
    void 
)
{
    HRESULT hr = S_OK;
    return hr;
}



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::Create
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Creates a new CSnapInDesigner and intializes it
//
IUnknown *CSnapInDesigner::Create
(
    IUnknown *pUnkOuter     // [in] Outer unknown for aggregation
)
{
    HRESULT          hr = S_OK;
    CSnapInDesigner *pDesigner = NULL;

    // Create the designer

    pDesigner = New CSnapInDesigner(NULL);
    IfFalseGo(NULL != pDesigner, SID_E_OUTOFMEMORY);

    // We initialize the type info here because during command line builds
    // we will receive CSnapInDesigner::GetDynamicClassInfo() calls before
    // the CSnapInDesigner::AfterCreateWindow() call where we populate it.

    pDesigner->m_pSnapInTypeInfo = New CSnapInTypeInfo();
    IfFalseGo(NULL != pDesigner->m_pSnapInTypeInfo, SID_E_OUTOFMEMORY);

Error:

    if (FAILED(hr))
    {
        if (NULL != pDesigner)
        {
            delete pDesigner;
        }
    }

    // make sure we return the private unknown so that we support aggegation
    // correctly!
    //
    return (S_OK == hr) ? pDesigner->PrivateUnknown() : NULL;
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CSnapInDesigner
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      CSnapInDesigner constructor
//

#pragma warning(disable:4355)  // using 'this' in constructor

CSnapInDesigner::CSnapInDesigner(IUnknown *pUnkOuter) :
    COleControl(pUnkOuter, OBJECT_TYPE_SNAPINDESIGNER, (IDispatch *) this),
    CError(dynamic_cast<CAutomationObject *>(this))
{
    // initialize anything here ...
    //
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CSnapInDesigner::~CSnapInDesigner
//=--------------------------------------------------------------------------=
//
// Notes:
//
CSnapInDesigner::~CSnapInDesigner ()
{
    FREESTRING(m_bstrName);
    RELEASE(m_piCodeNavigate2);
    RELEASE(m_piTrackSelection);
    RELEASE(m_piProfferTypeLib);
    RELEASE(m_piDesignerProgrammability);
    RELEASE(m_piHelp);

    if (NULL != m_hwdToolbar)
        ::DestroyWindow(m_hwdToolbar);

    if (NULL != m_pTreeView)
        delete m_pTreeView;

    if (NULL != m_pSnapInTypeInfo)
        delete m_pSnapInTypeInfo;

    (void)DestroyExtensibilityModel();

    InitMemberVariables();
}       


//=--------------------------------------------------------------------------=
// CSnapInDesigner::InitMemberVariables()
//=--------------------------------------------------------------------------=
//
// Notes:
//
void CSnapInDesigner::InitMemberVariables()
{
    m_bstrName = NULL;
    m_piCodeNavigate2 = NULL;
    m_piTrackSelection = NULL;
    m_piProfferTypeLib = NULL;
    m_piDesignerProgrammability = NULL;
    m_piHelp = NULL;
    m_piSnapInDesignerDef = NULL;
    m_pTreeView = NULL;
    m_bDidLoad = FALSE;

    m_pCurrentSelection = NULL;

    m_pRootNode = NULL;
    m_pRootNodes = NULL;
    m_pRootExtensions = NULL;
    m_pRootMyExtensions = NULL;
    m_pStaticNode = NULL;
	m_pAutoCreateRoot = 0;
	m_pOtherRoot = 0;

    m_pViewListRoot = NULL;
    m_pViewOCXRoot = NULL;
    m_pViewURLRoot = NULL;
    m_pViewTaskpadRoot = NULL;
    m_pToolImgLstRoot = NULL;
    m_pToolMenuRoot = NULL;
    m_pToolToolbarRoot = NULL;

    m_pSnapInTypeInfo = NULL;

    m_iNextNodeNumber = 0;
    m_bDoingPromoteOrDemote = false;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetHostServices
//=--------------------------------------------------------------------------=
//
// Parameters:
//    VARIANT_BOOL fvarInteractive - current value of ambient Interactive
//                                   (DISPID_AMBIENT_INTERACTIVE in ad98.h)
//
// Output:
//    HRESULT
//
// Notes:
//    Retrieves all the needed services provided by the designer host:
//    SID_SCodeNavigate
//    SID_STrackSelection
//    SID_DesignerProgrammability,
//    SID_Shelp
//

HRESULT CSnapInDesigner::GetHostServices(BOOL fInteractive)
{
    HRESULT           hr = S_OK;
    IOleClientSite   *piOleClientSite = NULL;
    IServiceProvider *piServiceProvider = NULL;
    ICodeNavigate    *piCodeNavigate = NULL;

    hr = GetClientSite(&piOleClientSite);
    IfFailGo(hr);

    hr = piOleClientSite->QueryInterface(IID_IServiceProvider,
                                         reinterpret_cast<void **>(&piServiceProvider));
    IfFailGo(hr);

    hr = piServiceProvider->QueryService(SID_SCodeNavigate,
                                         IID_ICodeNavigate,
                                         reinterpret_cast<void **>(&piCodeNavigate));
    IfFailGo(hr);

    hr = piCodeNavigate->QueryInterface(IID_ICodeNavigate2,
                                        reinterpret_cast<void **>(&m_piCodeNavigate2));
    IfFailGo(hr);

    hr = piServiceProvider->QueryService(SID_STrackSelection,
                                         IID_ITrackSelection,
                                         reinterpret_cast<void **>(&m_piTrackSelection));
    IfFailGo(hr);

    hr = piServiceProvider->QueryService(SID_SProfferTypeLib,
                                         IID_IProfferTypeLib,
                                         reinterpret_cast<void **>(&m_piProfferTypeLib));
    IfFailGo(hr);

    hr = piServiceProvider->QueryService(SID_DesignerProgrammability,
                                         IID_IDesignerProgrammability,
                                         reinterpret_cast<void **>(&m_piDesignerProgrammability));
    IfFailGo(hr);

    hr = piServiceProvider->QueryService(SID_SHelp, 
                                         IID_IHelp, 
                                         reinterpret_cast<void **>(&m_piHelp));
    IfFailGo(hr);

    // Need to tell VB about the runtime type library so that it will show up
    // in the object browser and in the code window. We only do this if the
    // user has opened the designer window. If VB is not interactive it will
    // return E_FAIL from ProfferTypeLib().

    if (fInteractive)
    {
        hr = m_piProfferTypeLib->ProfferTypeLib(LIBID_SnapInLib, 1, 0, 0);
        IfFailGo(hr);
    }

Error:
    QUICK_RELEASE(piServiceProvider);
    QUICK_RELEASE(piOleClientSite);
    QUICK_RELEASE(piCodeNavigate);

    EXCEPTION_CHECK(hr);

    return hr;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetAmbients
//=--------------------------------------------------------------------------=
//
// Notes:
//
CAmbients *CSnapInDesigner::GetAmbients()
{
    return &m_Ambients;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapInDesigner::InternalQueryInterface
//=--------------------------------------------------------------------------=
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
// Handle QI for interfaces we support directly in this method
//

HRESULT CSnapInDesigner::InternalQueryInterface
(
    REFIID   riid,
    void   **ppvObjOut
)
{
    HRESULT     hr = S_OK;
    IUnknown    *pUnk = NULL;

    *ppvObjOut = NULL;

    // TODO: if you want to support any additional interfaces, then you should
    // indicate that here. Never forget to call COleControl's version in the
    // case where you don't support the given interface.
    //
    if (DO_GUIDS_MATCH(riid, IID_IActiveDesigner))
    {
        pUnk = static_cast<IActiveDesigner *>(this);
        pUnk->AddRef();
        *ppvObjOut = reinterpret_cast<void *>(pUnk);
    }
    else if (DO_GUIDS_MATCH(riid, IID_IDesignerDebugging))
    {
        pUnk = static_cast<IDesignerDebugging *>(this);
        pUnk->AddRef();
        *ppvObjOut = reinterpret_cast<void *>(pUnk);
    }
    else if (DO_GUIDS_MATCH(riid, IID_IDesignerRegistration))
    {
        pUnk = static_cast<IDesignerRegistration *>(this);
        pUnk->AddRef();
        *ppvObjOut = reinterpret_cast<void *>(pUnk);
    }
    else if (DO_GUIDS_MATCH(riid, IID_IProvideClassInfo))
    {
        hr = E_NOINTERFACE;
    }
    else if (DO_GUIDS_MATCH(riid, IID_IProvideDynamicClassInfo))
    {
        pUnk = static_cast<IProvideDynamicClassInfo *>(this);
        pUnk->AddRef();
        *ppvObjOut = reinterpret_cast<void *>(pUnk);
    }
    else if (DO_GUIDS_MATCH(riid, IID_ISelectionContainer))
    {
        pUnk = static_cast<ISelectionContainer *>(this);
        pUnk->AddRef();
        *ppvObjOut = reinterpret_cast<void *>(pUnk);
    }
    else if (DO_GUIDS_MATCH(riid, IID_IObjectModelHost))
    {
        pUnk = static_cast<IObjectModelHost *>(this);
        pUnk->AddRef();
        *ppvObjOut = reinterpret_cast<void *>(pUnk);
    }
    else
    {
        hr = COleControl::InternalQueryInterface(riid, ppvObjOut);
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////////
// IActiveDesigner
///////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetRuntimeClassID    [IActiveDesigner]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    Returns the classid of the runtime class
//
STDMETHODIMP CSnapInDesigner::GetRuntimeClassID
(
    CLSID *pclsid       // [out] runime object's CLSID
)
{
    // UNDONE: need to CLSID tricks for standalone, extension dualmode stuff
    *pclsid = CLSID_SnapIn;

    return S_OK;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetRuntimeMiscStatusFlags    [IActiveDesigner]
//=--------------------------------------------------------------------------=
// Parameters:
//    DWORD *               - [out] duh.
//
// Output:
//    HRESULT
//
// Notes:
//    Returns the misc status flags for the runtime object.
//
STDMETHODIMP CSnapInDesigner::GetRuntimeMiscStatusFlags
(
    DWORD *pdwMiscFlags     // [out] Returns misc status flags
)
{
    *pdwMiscFlags = OLEMISC_INVISIBLEATRUNTIME | OLEMISC_SETCLIENTSITEFIRST; 

    return S_OK;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::QueryPersistenceInterface    [IActiveDesigner]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT               - S_OK yep, S_FALSE nope, otherwise error
//
// Notes:
//      Do we support the given interface for persistence for the runmode object?
//
STDMETHODIMP CSnapInDesigner::QueryPersistenceInterface
(
    REFIID riidPersist      // [in] IID of the runtime persist type
)
{
    HRESULT hr = S_FALSE;

    if (DO_GUIDS_MATCH(riidPersist, IID_IPersistStreamInit))
        hr = S_OK;
    else if (DO_GUIDS_MATCH(riidPersist, IID_IPersistStream))
        hr = S_OK; 
    else if (DO_GUIDS_MATCH(riidPersist, IID_IPersistStorage))
        hr = S_FALSE; 
    else if (DO_GUIDS_MATCH(riidPersist, IID_IPersistPropertyBag))
        hr = S_FALSE; 

    return hr;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::SaveRuntimeState    [IActiveDesigner]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    Given a persistence object and an interface, save out the runtime state
//    using that object.
//
//
STDMETHODIMP CSnapInDesigner::SaveRuntimeState
(
    REFIID riidPersist,         // [in] interface we're saving on
    REFIID riidObjStgMed,       // [in] the interface the object is
    void  *pObjStgMed           // [in] the medium
)
{
    HRESULT         hr = S_OK;
    IPersistStream *piPersistStream = NULL;
    unsigned long   ulTICookie = 0;
    BSTR            bstrProjectName = NULL;

    // Check that we're saving to a stream

    if (IID_IStream != riidObjStgMed)
    {
        EXCEPTION_CHECK_GO(SID_E_UNSUPPORTED_STGMEDIUM);
    }

    if (IID_IPersistStream != riidPersist)
    {
        EXCEPTION_CHECK_GO(SID_E_UNSUPPORTED_STGMEDIUM);
    }

    if (NULL != m_piSnapInDesignerDef)
    {
        // Store the typeinfo cookie. Move it to a ULONG by static cast to
        // catch any size differential during compilation.

        if (NULL != m_pSnapInTypeInfo)
        {
            ulTICookie = static_cast<ULONG>(m_pSnapInTypeInfo->GetCookie());
        }
        IfFailGo(m_piSnapInDesignerDef->put_TypeinfoCookie(static_cast<long>(ulTICookie)));

        // Store the project name for the runtime.

        IfFailGo(AttachAmbients());
        IfFailGo(m_Ambients.GetProjectName(&bstrProjectName));
        IfFailGo(m_piSnapInDesignerDef->put_ProjectName(bstrProjectName));

        // Save the whole shebang to the stream. The SnapInDesigerDef object
        // contains the entire runtime state.

        hr = m_piSnapInDesignerDef->QueryInterface(IID_IPersistStream, reinterpret_cast<void **>(&piPersistStream));
        IfFailGo(hr);

        hr = ::OleSaveToStream(piPersistStream, reinterpret_cast<IStream *>(pObjStgMed));
        piPersistStream->Release();

        // Don't do an exception check for OleSaveToStream() because it just
        // QIs and saves so our code will have set the exception info.
    }

Error:
    FREESTRING(bstrProjectName);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::::GetExtensibilityObject    [IActiveDesigner]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::GetExtensibilityObject
(
    IDispatch **ppvObjOut           // [out] the extensibility object.
)
{
    HRESULT hr = S_OK;

    if (NULL == m_piSnapInDesignerDef)
    {
        *ppvObjOut = NULL;
        hr = E_NOTIMPL;
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(ppvObjOut));
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetDynamicClassInfo    [IProvideDynamicClassInfo]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::GetDynamicClassInfo(ITypeInfo **ppTypeInfo, DWORD *pdwCookie)
{
    HRESULT hr = S_OK;

    if (NULL != ppTypeInfo)
    {
        hr = m_pSnapInTypeInfo->GetTypeInfo(ppTypeInfo);
        IfFailGo(hr);
    }

    if (pdwCookie != NULL)
    {
        m_pSnapInTypeInfo->ResetDirty();
        *pdwCookie = m_pSnapInTypeInfo->GetCookie();
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::FreezeShape    [IProvideDynamicClassInfo]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    TODO: Make sure we don't have to do anything here
//
STDMETHODIMP CSnapInDesigner::FreezeShape(void)
{
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetClassInfo    [IProvideDynamicClassInfo]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    We do dynamic class info so E_NOTIMPL
//
STDMETHODIMP CSnapInDesigner::GetClassInfo(ITypeInfo **ppTypeInfo)
{
    // UNDONE: get rid of this when dynamic typeinfo is in place
/*
    ITypeLib *piTypeLib = NULL;
    HRESULT   hr = S_OK;
    
    IfFalseGo(NULL != ppTypeInfo, S_OK);

    hr = ::LoadRegTypeLib(LIBID_SnapInLib,
                          1,
                          0,
                          LOCALE_SYSTEM_DEFAULT,
                          &piTypeLib);
    IfFailGo(hr);

    hr = piTypeLib->GetTypeInfoOfGuid(CLSID_SnapIn, ppTypeInfo);

Error:
    QUICK_RELEASE(piTypeLib);
    return hr;
*/
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////////
// ISelectionContainer
///////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------=
// CSnapInDesigner::OnSelectionChanged
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    Called by CTreeView when the selection changes
//
HRESULT CSnapInDesigner::OnSelectionChanged(CSelectionHolder *pNewSelection)
{
    HRESULT     hr = S_OK;

    m_pCurrentSelection = pNewSelection;

    hr = OnPrepareToolbar();
    IfFailGo(hr);

    if (NULL != m_piTrackSelection)
    {
        hr = m_piTrackSelection->OnSelectChange(static_cast<ISelectionContainer *>(this));
    }

Error:
    return hr;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::CountObjects    [ISelectionContainer]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    Called by VB to get the number of objects to display in the properties list
//    drop down list or the number of objects selected  
//
HRESULT CSnapInDesigner::CountObjects
(
    DWORD dwFlags,      // [in] Return count of all objects or just selected
    ULONG *pc           // [out] Number of objects
)
{
    HRESULT     hr = S_OK;
    long        lCount = 1;

    *pc = 0;

    // Make sure we have been sited since we need extended dispatch
    //
    if (NULL != m_pControlSite)
    {
        // If VB wants the count of all the objects
        //
        if (GETOBJS_ALL == dwFlags)
        {	
            // get the number of nodes
            //
            hr = m_pTreeView->CountSelectableObjects(&lCount);
            IfFailGo(hr);

            // And add 1 for the designer itself
            //
            *pc = lCount;
        }
        else if (GETOBJS_SELECTED == dwFlags)
            // Otherwise, we only allow one object to be selected at a time
            //
            *pc = 1;
    }

Error:
    return hr;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetObjects    [ISelectionContainer]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    Returns an array of all the objects or the selected object
//
HRESULT CSnapInDesigner::GetObjects
(
    DWORD dwFlags,              // [in] Return all the objects or the selected
    ULONG cObjects,             // [in] Number to return
    IUnknown **apUnkObjects     // [in,out] Array to return them in
)
{
    HRESULT              hr = S_OK;
    ULONG                i;
    IDispatch           *piDisp = NULL;
    IUnknown            *piUnkUs = NULL;
    long                 lOffset = 1;
    CSelectionHolder    *pParent = NULL;

    // Initialize array to NULL
    //
    for (i = 0; i < cObjects; ++i)
    {
        apUnkObjects[i] = NULL;
    }

    // Pass our extended object if we can, so the user can browse extended properties
    //
    if (NULL != m_pControlSite)
    {
        hr = m_pControlSite->GetExtendedControl(&piDisp);
        if SUCCEEDED(hr)
        {
            hr = piDisp->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnkUs));
            IfFailGo(hr);
        }
        else
        {
            piUnkUs = dynamic_cast<IUnknown *>(dynamic_cast<ISelectionContainer *>(this));
            piUnkUs->AddRef();
        }
    }

    // Let the view collect the selection targets
	if (NULL != m_pTreeView)
	{
        if (GETOBJS_ALL == dwFlags)
        {
            hr = m_pRootNode->GetSelectableObject(&(apUnkObjects[0]));
            IfFailGo(hr);

            hr = m_pTreeView->CollectSelectableObjects(apUnkObjects, &lOffset);
            IfFailGo(hr);
        }
        else if (GETOBJS_SELECTED == dwFlags)
        {
            if (NULL != m_pCurrentSelection)
            {
                if (true == m_pCurrentSelection->IsVirtual())
                {
					if (SEL_NODES_ANY_CHILDREN == m_pCurrentSelection->m_st ||
						SEL_NODES_ANY_VIEWS == m_pCurrentSelection->m_st)
					{
                        hr = m_pTreeView->GetParent(m_pCurrentSelection, &pParent);
                        IfFailGo(hr);

						hr = pParent->GetSelectableObject(&(apUnkObjects[0]));
						IfFailGo(hr);
					}
                    else if (m_pCurrentSelection->m_st >= SEL_EEXTENSIONS_CC_ROOT &&
                             m_pCurrentSelection->m_st <= SEL_EEXTENSIONS_NAMESPACE)
                    {
                        hr = m_pCurrentSelection->GetSelectableObject(&(apUnkObjects[0]));
                        IfFailGo(hr);
                    }
                    else if (m_pCurrentSelection->m_st >= SEL_EXTENSIONS_MYNAME &&
                             m_pCurrentSelection->m_st <= SEL_EXTENSIONS_NAMESPACE)
                    {
                        hr = m_pCurrentSelection->GetSelectableObject(&(apUnkObjects[0]));
                        IfFailGo(hr);
                    }
					else
					{
						hr = m_pRootNode->GetSelectableObject(&(apUnkObjects[0]));
						IfFailGo(hr);
					}
                }
                else
                {
                    hr = m_pCurrentSelection->GetSelectableObject(&(apUnkObjects[0]));
                    IfFailGo(hr);
                }
            }
        }
	}

Error:
    RELEASE(piUnkUs)
    RELEASE(piDisp)

    return hr;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::SelectObjects    [ISelectionContainer]
//=--------------------------------------------------------------------------=
// Output:
//    HRESULT
//
// Notes:
//    Called when VB wants the designer's user interface to select a specific 
//    object
//
HRESULT CSnapInDesigner::SelectObjects
(
    ULONG cSelect,              // [in] Number to select
    IUnknown **apUnkSelect,     // [in] Objects to select
    DWORD dwFlags               // 
)
{
    HRESULT             hr = S_OK;
    IUnknown           *piUnkThem = NULL;
    IDispatch          *piDisp = NULL;
    IUnknown           *piUnkUs = NULL;
    BOOL                fSelectRoot = FALSE;
    CSelectionHolder   *pSelection = NULL;

    ASSERT(1 == cSelect, "Can only handle single selection");

	hr = apUnkSelect[0]->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnkThem));	
	IfFailGo(hr);

    // Figure out if the designer itself is the selected object
    //
    hr = m_pControlSite->GetExtendedControl(&piDisp);
    if SUCCEEDED(hr)
    {
        hr = piDisp->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnkUs));
        IfFailGo(hr);
    }
    else
    {
        piUnkUs = dynamic_cast<IUnknown *>(dynamic_cast<ISelectionContainer *>(this));
        piUnkUs->AddRef();
    }

    if (piUnkUs == piUnkThem)
        fSelectRoot = TRUE;

	// Let the view select the object
	//
	if (NULL != m_pTreeView)
	{
        if (TRUE == fSelectRoot)
        {
            hr = m_pTreeView->GetItemParam(TVI_ROOT, &pSelection);
            IfFailGo(hr);

            ::SetActiveWindow(::GetParent(::GetParent(m_pTreeView->TreeViewWindow())));

            return hr;
        }

        // Otherwise, find the node that VB wants to select and select it
        hr = m_pTreeView->FindSelectableObject(piUnkThem, &pSelection);
        IfFailGo(hr);

        if (S_OK == hr)
        {
            hr = m_pTreeView->SelectItem(pSelection);
            IfFailGo(hr);

            m_pCurrentSelection = pSelection;
            hr = OnPrepareToolbar();
            IfFailGo(hr);
        }
	}

Error:
    RELEASE(piUnkUs);
    RELEASE(piDisp);
    RELEASE(piUnkThem);

    return hr;
}


//=--------------------------------------------------------------------------=
//                      IOleControlSite Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapInDesigner::OnAmbientPropertyChange(DISPID dispid)
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::OnAmbientPropertyChange(DISPID dispid)
{
    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      IPersistStreamInit Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapInDesigner::IsDirty()
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::IsDirty()
{
    HRESULT             hr = S_OK;
    IPersistStreamInit *piPersistStreamInit = NULL;

    if (m_fDirty)
    {
        return S_OK;
    }

    if (NULL == m_piSnapInDesignerDef)
    {
        return S_FALSE;
    }
        
    hr = m_piSnapInDesignerDef->QueryInterface(IID_IPersistStreamInit, reinterpret_cast<void **>(&piPersistStreamInit));
    IfFailGo(hr);

    hr = piPersistStreamInit->IsDirty();
    piPersistStreamInit->Release();

Error:    
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      COleControl Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapInDesigner::OnSetClientSite()           [COleControl::OnSetClientSite]
//=--------------------------------------------------------------------------=
//
// Notes:
//
// Called by the framework when the VB calls IOleObject::SetClientSite().
// When the client site is removed as the designer is being shutdown we need
// to release anything that could cause circular ref counts such as
// host interfaces and the object model.

HRESULT CSnapInDesigner::OnSetClientSite()
{
    if (NULL == m_pClientSite) // shutting down
    {
        RELEASE(m_piCodeNavigate2);
        RELEASE(m_piTrackSelection);
        RELEASE(m_piProfferTypeLib);
        RELEASE(m_piDesignerProgrammability);
        RELEASE(m_piHelp);
        (void)DestroyExtensibilityModel();
    }
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CSnapInDesigner::BeforeDestroyWindow()
//=--------------------------------------------------------------------------=
//
// Notes:
//
void CSnapInDesigner::BeforeDestroyWindow()
{
    FREESTRING(m_bstrName);
    RELEASE(m_piCodeNavigate2);
    RELEASE(m_piTrackSelection);
    RELEASE(m_piProfferTypeLib);
    RELEASE(m_piDesignerProgrammability);
    RELEASE(m_piHelp);

    if (NULL != m_pSnapInTypeInfo)
    {
        delete m_pSnapInTypeInfo;
        m_pSnapInTypeInfo = NULL;
    }

    if (NULL != m_hwdToolbar)
    {
        ::DestroyWindow(m_hwdToolbar);
        m_hwdToolbar = NULL;
    }

    if (NULL != m_pTreeView)
    {
        delete m_pTreeView;
        m_pTreeView = NULL;
    }

    (void)DestroyExtensibilityModel();

    g_GlobalHelp.Detach();

    RELEASE(m_piSnapInDesignerDef);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::InitializeNewDesigner(ISnapInDef *piSnapInDef)
//=--------------------------------------------------------------------------=
//
// Notes:
//
HRESULT CSnapInDesigner::InitializeNewDesigner
(
    ISnapInDef *piSnapInDef
)
{
    HRESULT     hr = S_OK;
    int         iResult = 0;
    TCHAR       szBuffer[kMaxBuffer + 1];
    BSTR        bstrProvider = NULL;
    BSTR        bstrVersion = NULL;
    BSTR        bstrDescription = NULL;

    if (NULL != piSnapInDef)
    {
        hr = piSnapInDef->put_Name(m_bstrName);
        IfFailGo(hr);

        hr = piSnapInDef->put_NodeTypeName(m_bstrName);
        IfFailGo(hr);

        hr = piSnapInDef->put_DisplayName(m_bstrName);
        IfFailGo(hr);

        // Provider
        GetResourceString(IDS_DFLT_PROVIDER, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = BSTRFromANSI(szBuffer, &bstrProvider);
        IfFailGo(hr);

        hr = piSnapInDef->put_Provider(bstrProvider);
        IfFailGo(hr);

        // Version
        GetResourceString(IDS_DFLT_VERSION, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = BSTRFromANSI(szBuffer, &bstrVersion);
        IfFailGo(hr);

        hr = piSnapInDef->put_Version(bstrVersion);
        IfFailGo(hr);

        // Description
        GetResourceString(IDS_DFLT_DESCRIPT, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = BSTRFromANSI(szBuffer, &bstrDescription);
        IfFailGo(hr);

        hr = piSnapInDef->put_Description(bstrDescription);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrDescription);
    FREESTRING(bstrVersion);
    FREESTRING(bstrProvider);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::InitializeNewState()
//=--------------------------------------------------------------------------=
//
// Notes:
//
BOOL CSnapInDesigner::InitializeNewState()
{
    HRESULT             hr = S_OK;
    IPersistStreamInit *piPersistStreamInit = NULL;
    ISnapInDef         *piSnapInDef = NULL;

    IfFailGo(CreateExtensibilityModel());

    hr = m_piSnapInDesignerDef->QueryInterface(IID_IPersistStreamInit, reinterpret_cast<void **>(&piPersistStreamInit));
    IfFailGo(hr);

    hr = piPersistStreamInit->InitNew();
    piPersistStreamInit->Release();

    // Set the host now as following InitNew all objects will have created their
    // sub-objects.

    IfFailGo(SetObjectModelHost());

    hr = UpdateDesignerName();
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    hr = InitializeNewDesigner(piSnapInDef);
    IfFailGo(hr);

Error:
    RELEASE(piSnapInDef);

    return SUCCEEDED(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::LoadBinaryState(IStream *piStream)
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::LoadBinaryState
(
    IStream *piStream
)
{
    HRESULT       hr = S_OK;
    unsigned long lRead = 0;
    unsigned long ulTICookie = 0;

    hr = piStream->Read(&m_iNextNodeNumber, sizeof(m_iNextNodeNumber), &lRead);
    ASSERT(sizeof(m_iNextNodeNumber) == lRead, "SaveBinaryState: Error reading from stream");

    // Destroy existing extensibility object model
    IfFailGo(DestroyExtensibilityModel());

    // Load a new one from the stream
    hr = ::OleLoadFromStream(piStream, IID_ISnapInDesignerDef, reinterpret_cast<void **>(&m_piSnapInDesignerDef));

    // Do an exception check because OleLoadFromStream() will call
    // CoCreateInstance(). If something in the object model returned an error
    // and set the exception info then we will probably just set it again
    // (unless there were arguments).
    EXCEPTION_CHECK_GO(hr);

    // Set the designer as object model host in the extensibility model
    hr = SetObjectModelHost();
    IfFailGo(hr);

    // Set the typeinfo cookie from the saved value. Don't read from long
    // property directly into a DWORD so as to avoid size assumptions.
    // If there is a size problem then the static cast will fail compilation.
    
    IfFailGo(m_piSnapInDesignerDef->get_TypeinfoCookie(reinterpret_cast<long *>(&ulTICookie)));
    if (NULL != m_pSnapInTypeInfo)
    {
        m_pSnapInTypeInfo->SetCookie(static_cast<DWORD>(ulTICookie));
    }

    m_bDidLoad = TRUE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::SaveBinaryState(IStream *piStream)
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::SaveBinaryState
(
    IStream *piStream
)
{
    HRESULT       hr = S_OK;
    unsigned long cbWritten = 0;

    hr = piStream->Write(&m_iNextNodeNumber, sizeof(m_iNextNodeNumber), &cbWritten);
    EXCEPTION_CHECK_GO(hr);
    
    if (sizeof(m_iNextNodeNumber) != cbWritten)
    {
        hr = SID_E_INCOMPLETE_WRITE;
        EXCEPTION_CHECK_GO(hr);
    }

    // The remainder of design time state is the same as the runtime.
    
    IfFailGo(SaveRuntimeState(IID_IPersistStream, IID_IStream, piStream));

Error:    
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::LoadTextState(IPropertyBag *piPropertyBag, IErrorLog *piErrorLog)
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::LoadTextState
(
    IPropertyBag *piPropertyBag,
    IErrorLog    *piErrorLog
)
{
    HRESULT              hr = S_OK;
    BSTR                 bstrPropName = NULL;
    VARIANT              vtCounter;
    IPersistPropertyBag *piPersistPropertyBag = NULL;
    unsigned long        ulTICookie = 0;

    ::VariantInit(&vtCounter);

    IfFailGo(CreateExtensibilityModel());

    bstrPropName = ::SysAllocString(L"m_iNextNodeNumber");
    if (NULL == bstrPropName)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piPropertyBag->Read(bstrPropName, &vtCounter, NULL);
    IfFailGo(hr);

    IfFailGo(::VariantChangeType(&vtCounter, &vtCounter, 0, VT_I4));

    m_iNextNodeNumber = vtCounter.lVal;

    hr = m_piSnapInDesignerDef->QueryInterface(IID_IPersistPropertyBag, reinterpret_cast<void **>(&piPersistPropertyBag));
    IfFailGo(hr);

    hr = piPersistPropertyBag->Load(piPropertyBag, piErrorLog);
    piPersistPropertyBag->Release();
    IfFailGo(hr);

    // Set the designer as object model host in the extensibility model

    hr = SetObjectModelHost();

    // Set the typeinfo cookie from the saved value. Don't read from long
    // property directly into a DWORD so as to avoid size assumptions.
    // If there is a size problem then the static cast will fail compilation.

    IfFailGo(m_piSnapInDesignerDef->get_TypeinfoCookie(reinterpret_cast<long *>(&ulTICookie)));
    if (NULL != m_pSnapInTypeInfo)
    {
        m_pSnapInTypeInfo->SetCookie(static_cast<DWORD>(ulTICookie));
    }

    m_bDidLoad = TRUE;

Error:
    ::VariantClear(&vtCounter);
    FREESTRING(bstrPropName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::SaveTextState(IPropertyBag *piPropertyBag, BOOL fWriteDefault)
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::SaveTextState
(
    IPropertyBag *piPropertyBag,
    BOOL          fWriteDefault
)
{
    HRESULT              hr = S_OK;
    BSTR                 bstrPropName = NULL;
    VARIANT              vtCounter;
    IPersistPropertyBag *piPersistPropertyBag = NULL;
    unsigned long        ulTICookie = 0;

    ::VariantInit(&vtCounter);

    bstrPropName = ::SysAllocString(L"m_iNextNodeNumber");
    if (NULL == bstrPropName)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    vtCounter.vt = VT_I4;
    vtCounter.lVal = m_iNextNodeNumber;
    hr = piPropertyBag->Write(bstrPropName, &vtCounter);
    IfFailGo(hr);

    if (NULL != m_piSnapInDesignerDef)
    {
        // Store the typeinfo cookie.

        if (NULL != m_pSnapInTypeInfo)
        {
            ulTICookie = static_cast<ULONG>(m_pSnapInTypeInfo->GetCookie());
        }
        IfFailGo(m_piSnapInDesignerDef->put_TypeinfoCookie(static_cast<long>(ulTICookie)));

        hr = m_piSnapInDesignerDef->QueryInterface(IID_IPersistPropertyBag, reinterpret_cast<void **>(&piPersistPropertyBag));
        IfFailGo(hr);

        hr = piPersistPropertyBag->Save(piPropertyBag,
                                        TRUE, // assume clear dirty
                                        fWriteDefault);
        piPersistPropertyBag->Release();
    }

Error:
    ::VariantClear(&vtCounter);
    FREESTRING(bstrPropName);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      IObjectModelHost Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapInDesigner::Update                  [IObjectModelHost]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    long      ObjectCookie  [in] cookie passed to object's IObjectModel::SetCookie
//    IUnknown *punkObject    [in] IUnknown of the calling object
//    DISPID    dispid        [in] DISPID of the object's property that changed
//
// Output:
//      HRESULT
//
// Notes:
//
// Called from an extensibility object when one of its properties has changed
// that could affect the UI.
//
//
STDMETHODIMP CSnapInDesigner::Update
(
    long      ObjectCookie,
    IUnknown *punkObject,
    DISPID    dispid
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pSelection = NULL;

    pSelection = reinterpret_cast<CSelectionHolder *>(ObjectCookie);

    // The cookie may be zero when loading or creating a snap-in because
    // some properties are set before selection holders are created. For
    // example, AfterCreateWindow() will set SnapInDef.IID which will
    // call IObjectModeHost::Update().
    
    IfFalseGo(NULL != pSelection, S_OK);

    // Check whether the selected item is currently in the middle of an update.
    // This can happen in cases where the selected object is not the same as the
    // object model object. For example, A TaskpadViewDef defines a taskpad but
    // the selected object as VB sees it from ISelectionContainer is
    // TaskpadViewDef.Taskpad. In this case, during a rename operation both
    // TaskpadViewDef.Name and TaskpadViewDef.Taskpad.Name will be changed. The
    // 2nd one will result in a rescursive call to this function because of
    // the IObjectModelHost::Update call generated by setting the property. As
    // the DISPID for any object's name is almost always zero, the functions
    // called from here will mistake the second call for another update of the
    // selected object's name.

    IfFalseGo(!pSelection->InUpdate(), S_OK);

    // Now mark the selection as being in an update

    pSelection->SetInUpdate(TRUE);

    // Invoke object specific handlers

    switch (pSelection->m_st)
    {
    case SEL_SNAPIN_ROOT:
        hr = OnSnapInChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_ROOT:
        hr = OnMyExtensionsChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_EEXTENSIONS_NAME:
        hr = OnExtendedSnapInChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_NAME:
        hr = OnScopeItemChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        hr = OnListViewChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_OCX_NAME:
        hr = OnOCXViewChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_URL_NAME:
        hr = OnURLViewChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        hr = OnTaskpadViewChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        hr = OnImageListChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_MENUS_NAME:
        hr = OnMenuChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        hr = OnToolbarChange(pSelection, dispid);
        IfFailGo(hr);
        break;

    case SEL_XML_RESOURCE_NAME:
        hr = OnDataFormatChange(pSelection, dispid);
        IfFailGo(hr);
        break;
    }

    // The object is no longer in a rename operation so mark it as such

    if (NULL != pSelection)
    {
        pSelection->SetInUpdate(FALSE);
    }

Error:

    if (FAILED(hr))
    {
        // The object is no longer in a rename operation so mark it as such.
        // Note that we cannot just do this blindly without checking for failure
        // because at the top of this function we check the flag and exit with
        // S_OK. If we came down here with no change and reset the flag then
        // further updates to the object (e.g. changing the key along with the
        // name), would see an incorrect value of the flag.

        if (NULL != pSelection)
        {
            pSelection->SetInUpdate(FALSE);
        }

        (void)::SDU_DisplayMessage(IDS_RENAME_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_RenameFailed, hr, AppendErrorInfo, NULL);
    }

    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapInDesigner::Add                  [IObjectModelHost]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    long      CollectionCookie [in] cookie passed to collection object's
//                                    IObjectModel::SetCookie
//    IUnknown *punkNewObject    [in] IUnknown of the newly added object
//
// Output:
//      HRESULT
//
// Notes:
//
// Called from an extensibility collection object when an item has been added
// to it.
//
//
STDMETHODIMP CSnapInDesigner::Add
(
    long      CollectionCookie,
    IUnknown *punkNewObject
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pSelection = NULL;
    IExtendedSnapIn     *piExtendedSnapIn = NULL;
    IScopeItemDef       *piScopeItemDef = NULL;
    IListViewDef        *piListViewDef = NULL;
    IOCXViewDef         *piOCXViewDef = NULL;
    IURLViewDef         *piURLViewDef = NULL;
    ITaskpadViewDef     *piTaskpadViewDef = NULL;
    IMMCImageList       *piMMCImageList = NULL;
    IMMCMenu            *piMMCMenu = NULL;
    IMMCToolbar         *piMMCToolbar = NULL;
    IDataFormat         *piDataFormat = NULL;

    pSelection = reinterpret_cast<CSelectionHolder *>(CollectionCookie);
    if (NULL != pSelection)
    {
        switch (pSelection->m_st)
        {
        case SEL_EXTENSIONS_ROOT:
            // It's got to be an IExtendedSnapIn
            hr = punkNewObject->QueryInterface(IID_IExtendedSnapIn, reinterpret_cast<void **>(&piExtendedSnapIn));
            IfFailGo(hr);

            hr = OnAddExtendedSnapIn(pSelection, piExtendedSnapIn);
            IfFailGo(hr);
            break;

        case SEL_NODES_AUTO_CREATE_RTCH:
        case SEL_NODES_ANY_CHILDREN:
        case SEL_NODES_OTHER:
            // It's got to be an IScopeItemDef
            hr = punkNewObject->QueryInterface(IID_IScopeItemDef, reinterpret_cast<void **>(&piScopeItemDef));
            IfFailGo(hr);

            hr = OnAddScopeItemDef(pSelection, piScopeItemDef);
            IfFailGo(hr);
            break;

        case SEL_NODES_AUTO_CREATE_RTVW:
        case SEL_NODES_ANY_VIEWS:
            // Could be a IListViewDef
            hr = punkNewObject->QueryInterface(IID_IListViewDef, reinterpret_cast<void **>(&piListViewDef));
            if (SUCCEEDED(hr))
            {
                hr = OnAddListViewDef(pSelection, piListViewDef);
                IfFailGo(hr);
                break;
            }

            // or a IOCXViewDef
            hr = punkNewObject->QueryInterface(IID_IOCXViewDef, reinterpret_cast<void **>(&piOCXViewDef));
            if (SUCCEEDED(hr))
            {
                hr = OnAddOCXViewDef(pSelection, piOCXViewDef);
                IfFailGo(hr);
                break;
            }

            // or a IURLViewDef
            hr = punkNewObject->QueryInterface(IID_IURLViewDef, reinterpret_cast<void **>(&piURLViewDef));
            if (SUCCEEDED(hr))
            {
                hr = OnAddURLViewDef(pSelection, piURLViewDef);
                IfFailGo(hr);
                break;
            }

            // or a ITaskpadViewDef
            hr = punkNewObject->QueryInterface(IID_ITaskpadViewDef, reinterpret_cast<void **>(&piTaskpadViewDef));
            if (SUCCEEDED(hr))
            {
                hr = OnAddTaskpadViewDef(pSelection, piTaskpadViewDef);
                IfFailGo(hr);
                break;
            }
            ASSERT(0, "Add: Cannot guess type of view");
            break;

        case SEL_VIEWS_LIST_VIEWS:
            // It's got to be an IListViewDef
            hr = punkNewObject->QueryInterface(IID_IListViewDef, reinterpret_cast<void **>(&piListViewDef));
            IfFailGo(hr);

            hr = OnAddListViewDef(pSelection, piListViewDef);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_OCX:
            // It's got to be an IOCXViewDef
            hr = punkNewObject->QueryInterface(IID_IOCXViewDef, reinterpret_cast<void **>(&piOCXViewDef));
            IfFailGo(hr);

            hr = OnAddOCXViewDef(pSelection, piOCXViewDef);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_URL:
            // It's got to be an IURLViewDef
            hr = punkNewObject->QueryInterface(IID_IURLViewDef, reinterpret_cast<void **>(&piURLViewDef));
            IfFailGo(hr);

            hr = OnAddURLViewDef(pSelection, piURLViewDef);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_TASK_PAD:
            // It's got to be an ITaskpadViewDef
            hr = punkNewObject->QueryInterface(IID_ITaskpadViewDef, reinterpret_cast<void **>(&piTaskpadViewDef));
            IfFailGo(hr);

            hr = OnAddTaskpadViewDef(pSelection, piTaskpadViewDef);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_IMAGE_LISTS:
            // It's got to be an IMMCImageList
            hr = punkNewObject->QueryInterface(IID_IMMCImageList, reinterpret_cast<void **>(&piMMCImageList));
            IfFailGo(hr);

            hr = OnAddMMCImageList(pSelection, piMMCImageList);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_MENUS:
        case SEL_TOOLS_MENUS_NAME:
            // It's got to be an IMMCMenu
            hr = punkNewObject->QueryInterface(IID_IMMCMenu, reinterpret_cast<void **>(&piMMCMenu));
            IfFailGo(hr);

            hr = OnAddMMCMenu(pSelection, piMMCMenu);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_TOOLBARS:
            // It's got to be an ITaskpadViewDef
            hr = punkNewObject->QueryInterface(IID_IMMCToolbar, reinterpret_cast<void **>(&piMMCToolbar));
            IfFailGo(hr);

            hr = OnAddMMCToolbar(pSelection, piMMCToolbar);
            IfFailGo(hr);
            break;

        case SEL_XML_RESOURCES:
            // It's got to be an IDataFormat
            hr = punkNewObject->QueryInterface(IID_IDataFormat, reinterpret_cast<void **>(&piDataFormat));
            IfFailGo(hr);

            hr = OnAddDataFormat(pSelection, piDataFormat);
            IfFailGo(hr);
        }
    }


Error:
    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_ADD_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_AddFailed, hr, AppendErrorInfo, NULL);
    }

    RELEASE(piDataFormat);
    RELEASE(piExtendedSnapIn);
    RELEASE(piMMCToolbar);
    RELEASE(piMMCMenu);
    RELEASE(piMMCImageList);
    RELEASE(piTaskpadViewDef);
    RELEASE(piURLViewDef);
    RELEASE(piOCXViewDef);
    RELEASE(piListViewDef);
    RELEASE(piScopeItemDef);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapInDesigner::Delete                  [IObjectModelHost]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    long      ObjectCookie [in] cookie passed to object's IObjectModel::SetCookie
//    IUnknown *punkObject   [in] IUnknown of the object
//
// Output:
//      HRESULT
//
// Notes:
//
// Called from an extensibility collection object when an item has been deleted
// from it.
//
//
STDMETHODIMP CSnapInDesigner::Delete
(
    long      ObjectCookie,
    IUnknown *punkObject
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pSelection = NULL;

    pSelection = reinterpret_cast<CSelectionHolder *>(ObjectCookie);
    if (NULL != pSelection)
    {
        switch (pSelection->m_st)
        {
        case SEL_NODES_ANY_NAME:
            // An IScopeItemDef has been deleted
            hr = OnDeleteScopeItem(pSelection);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_IMAGE_LISTS_NAME:
            // An IMMCImageList has been deleted
            hr = OnDeleteImageList(pSelection);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_MENUS_NAME:
            // An IMMCMenu has been deleted
            hr = OnDeleteMenu(pSelection);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_TOOLBARS_NAME:
            // An IMMCToolbar has been deleted
            hr = OnDeleteToolbar(pSelection);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_LIST_VIEWS_NAME:
            // An IListViewDef has been deleted
            hr = OnDeleteListView(m_pCurrentSelection);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_URL_NAME:
            // An IURLViewDef has been deleted
            hr = OnDeleteURLView(m_pCurrentSelection);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_OCX_NAME:
            // An IOCXViewDef has been deleted
            hr = OnDeleteOCXView(m_pCurrentSelection);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_TASK_PAD_NAME:
            // An ITaskpadViewDef has been deleted
            hr = OnDeleteTaskpadView(m_pCurrentSelection);
            IfFailGo(hr);
            break;

        case SEL_EEXTENSIONS_NAME:
            // An extended snap-in has been removed
            hr = OnDeleteExtendedSnapIn(pSelection);
            IfFailGo(hr);
            break;

        case SEL_XML_RESOURCE_NAME:
            // An XML data format has been deleted
            hr = OnDeleteDataFormat(m_pCurrentSelection);
            IfFailGo(hr);
            break;
        }
    }

Error:
    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_DELETE_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_DeleteFailed, hr, AppendErrorInfo, NULL);
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnSnapInChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnSnapInChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT         hr = S_OK;
    BSTR            bstrName = NULL;
    IDispatch      *piDispExtendedCtl = NULL;
    unsigned int    uiArgErr = (unsigned int)-1;
    static OLECHAR *pwszExtenderNameProperty = OLESTR("Name");
    DISPID          dispidName = 0;

    DISPPARAMS DispParams;
    ::ZeroMemory(&DispParams, sizeof(DispParams));

    EXCEPINFO ExceptionInfo;
    ::ZeroMemory(&ExceptionInfo, sizeof(ExceptionInfo));

    VARIANTARG arg;
    ::VariantInit(&arg);


    if (DISPID_SNAPIN_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piSnapInDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameSnapIn(pSelection, bstrName);
        IfFailGo(hr);

        // Need to set the extended control's name. This will change VB's notion
        // of the snap-in's name and update the project window.

        hr = m_pControlSite->GetExtendedControl(&piDispExtendedCtl);
        IfFailGo(hr);

        if (NULL == piDispExtendedCtl)
        {
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }

        // Need to do GetIDsOfNames because we can't assume that the extender
        // uses DISPID_VALUE for the name property. (In fact, it doesn't).

        IfFailGo(piDispExtendedCtl->GetIDsOfNames(IID_NULL,
                                                  &pwszExtenderNameProperty,
                                                  1,
                                                  LOCALE_USER_DEFAULT,
                                                  &dispidName));
        arg.vt = VT_BSTR;
        arg.bstrVal = bstrName;

        DispParams.rgdispidNamedArgs = NULL;
        DispParams.rgvarg = &arg;
        DispParams.cArgs = 1;
        DispParams.cNamedArgs = 0;

        IfFailGo(piDispExtendedCtl->Invoke(dispidName,
                                           IID_NULL,
                                           LOCALE_USER_DEFAULT,
                                           DISPATCH_PROPERTYPUT,
                                           &DispParams,
                                           NULL,
                                           &ExceptionInfo,
                                           &uiArgErr));

        // Make sure that the designer's name property is in sync with VB
        hr = UpdateDesignerName();
        IfFailGo(hr);

    }

Error:
    QUICK_RELEASE(piDispExtendedCtl);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnMyExtensionsChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnMyExtensionsChange(CSelectionHolder *pSelection, DISPID dispid)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vbValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_ROOT == pSelection->m_st, "OnMyExtensionsChange: Wrong kind of selection");
    switch (dispid)
    {
    case DISPID_EXTENSIONDEFS_EXTENDS_NEW_MENU:
        hr = pSelection->m_piObject.m_piExtensionDefs->get_ExtendsNewMenu(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoMyExtendsNewMenu(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteMyExtendsNewMenu(pSelection);
            IfFailGo(hr);
        }
        break;
    case DISPID_EXTENSIONDEFS_EXTENDS_TASK_MENU:
        hr = pSelection->m_piObject.m_piExtensionDefs->get_ExtendsTaskMenu(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoMyExtendsTaskMenu(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteMyExtendsTaskMenu(pSelection);
            IfFailGo(hr);
        }
        break;
    case DISPID_EXTENSIONDEFS_EXTENDS_TOP_MENU:
        hr = pSelection->m_piObject.m_piExtensionDefs->get_ExtendsTopMenu(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoMyExtendsTopMenu(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteMyExtendsTopMenu(pSelection);
            IfFailGo(hr);
        }
        break;
    case DISPID_EXTENSIONDEFS_EXTENDS_VIEW_MENU:
        hr = pSelection->m_piObject.m_piExtensionDefs->get_ExtendsViewMenu(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoMyExtendsViewMenu(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteMyExtendsViewMenu(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENSIONDEFS_EXTENDS_PROPERTYPAGES:
        hr = pSelection->m_piObject.m_piExtensionDefs->get_ExtendsPropertyPages(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoMyExtendsPPages(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteMyExtendsPPages(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENSIONDEFS_EXTENDS_TOOLBAR:
        hr = pSelection->m_piObject.m_piExtensionDefs->get_ExtendsToolbar(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoMyExtendsToolbar(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteMyExtendsToolbar(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENSIONDEFS_EXTENDS_NAMESPACE:
        hr = pSelection->m_piObject.m_piExtensionDefs->get_ExtendsNameSpace(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoMyExtendsNameSpace(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteMyExtendsNameSpace(pSelection);
            IfFailGo(hr);
        }
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnExtendedSnapInChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnExtendedSnapInChange(CSelectionHolder *pSelection, DISPID dispid)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vbValue = VARIANT_FALSE;
    BSTR            bstrName = NULL;

    switch (dispid)
    {
    case DISPID_EXTENDEDSNAPIN_NODE_TYPE_NAME:
        hr = RenameExtendedSnapIn(pSelection);
        IfFailGo(hr);
        break;

    case DISPID_EXTENDEDSNAPIN_EXTENDS_NEW_MENU:
        hr = pSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsNewMenu(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoExtensionNewMenu(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteExtensionNewMenu(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENDEDSNAPIN_EXTENDS_TASK_MENU:
        hr = pSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskMenu(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoExtensionTaskMenu(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteExtensionTaskMenu(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENDEDSNAPIN_EXTENDS_PROPERTYPAGES:
        hr = pSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsPropertyPages(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoExtensionPropertyPages(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteExtensionPropertyPages(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENDEDSNAPIN_EXTENDS_TOOLBAR:
        hr = pSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsToolbar(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoExtensionToolbar(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteExtensionToolbar(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENDEDSNAPIN_EXTENDS_TASKPAD:
        hr = pSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskpad(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoExtensionTaskpad(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteExtensionTaskpad(pSelection);
            IfFailGo(hr);
        }
        break;

    case DISPID_EXTENDEDSNAPIN_EXTENDS_NAMESPACE:
        hr = pSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsNameSpace(&vbValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == vbValue)
        {
            hr = OnDoExtensionNameSpace(pSelection);
            IfFailGo(hr);
        }
        else
        {
            hr = OnDeleteExtensionNameSpace(pSelection);
            IfFailGo(hr);
        }
        break;
    }



Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnScopeItemChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnScopeItemChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if (DISPID_SCOPEITEMDEF_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piListViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameScopeItem(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnListViewChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnListViewChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if (DISPID_LISTVIEWDEF_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piListViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameListView(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnOCXViewChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnOCXViewChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if (DISPID_OCXVIEWDEF_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piOCXViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameOCXView(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnURLViewChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnURLViewChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if (DISPID_URLVIEWDEF_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piURLViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameURLView(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnTaskpadViewChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnTaskpadViewChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT		 hr = S_OK;
	ITaskpad	*piTaskpad = NULL;
    BSTR		 bstrName = NULL;

    if (DISPID_TASKPAD_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piTaskpadViewDef->get_Taskpad(&piTaskpad);
        IfFailGo(hr);

		hr = piTaskpad->get_Name(&bstrName);
		IfFailGo(hr);

        hr = RenameTaskpadView(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
	RELEASE(piTaskpad);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnImageListChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnImageListChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if (DISPID_IMAGELIST_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piMMCImageList->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameImageList(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnMenuChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnMenuChange
(
    CSelectionHolder *pMenu,
    DISPID            dispid
)
{
    HRESULT     hr = S_OK;
    BSTR        bstrName = NULL;

    // We only need to concern ourselves with name changes,
    // and then only when the selection holder has been
    // added to the tree.
    if ( (DISPID_MENU_NAME == dispid) && (NULL != pMenu->m_pvData) )
    {
        hr = pMenu->m_piObject.m_piMMCMenu->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameMenu(pMenu, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnToolbarChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnToolbarChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if (DISPID_TOOLBAR_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piMMCToolbar->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameToolbar(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDataFormatChange(CSelectionHolder *pSelection, DISPID dispid)
//=--------------------------------------------------------------------------------------
//  
//  Notes
// 
HRESULT CSnapInDesigner::OnDataFormatChange
(
    CSelectionHolder *pSelection,
    DISPID            dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    if (DISPID_DATAFORMAT_NAME == dispid)
    {
        hr = pSelection->m_piObject.m_piDataFormat->get_Name(&bstrName);
        IfFailGo(hr);

        hr = RenameDataFormat(pSelection, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetSnapInDesignerDef                  [IObjectModelHost]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ISnapInDesignerDef **ppiSnapInDesignerDef [out] return designer's
//                                                    ISnapInDesignerDef here
//    
//
// Output:
//      HRESULT
//
// Notes:
//
// Called from an extensibility object when it needs access to the top of
// the object model.
//
//
STDMETHODIMP CSnapInDesigner::GetSnapInDesignerDef
(
    ISnapInDesignerDef **ppiSnapInDesignerDef
)
{
    HRESULT hr = S_OK;

    if (NULL == m_piSnapInDesignerDef)
    {
        *ppiSnapInDesignerDef = NULL;
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK(hr);
    }
    else
    {
        m_piSnapInDesignerDef->AddRef();
        *ppiSnapInDesignerDef = m_piSnapInDesignerDef;
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetRuntime                  [IObjectModelHost]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    BOOL *pfRuntime [out] return flag indiciating whether host is runtime
//                          or designer
//    
// Output:
//      HRESULT
//
// Notes:
//
// Called from any object when it needs to determine if it is running at runtime
// or at design time.
//


STDMETHODIMP CSnapInDesigner::GetRuntime(BOOL *pfRuntime)
{
    HRESULT hr = S_OK;

    if (NULL == pfRuntime)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK(hr);
    }
    else
    {
        *pfRuntime = FALSE;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      Private Utility Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapInDesigner::CreateExtensibilityModel
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Creates the extensibility model top level object
//
HRESULT CSnapInDesigner::CreateExtensibilityModel()
{
    HRESULT hr = S_OK;

    // Destroy existing extensibility object model

    IfFailGo(DestroyExtensibilityModel());

    // Create the extensibility object model

    hr = ::CoCreateInstance(CLSID_SnapInDesignerDef,
                            NULL, // aggregate extensibility model
                            CLSCTX_INPROC_SERVER,
                            IID_ISnapInDesignerDef,
                            reinterpret_cast<void **>(&m_piSnapInDesignerDef));
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::SetObjectModelHost
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Sets the designer as the object model host in the extensibility model
//
HRESULT CSnapInDesigner::SetObjectModelHost()
{
    HRESULT hr = S_OK;
    IObjectModel *piObjectModel = NULL;

    if (NULL == m_piSnapInDesignerDef)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piSnapInDesignerDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailRet(hr);

    hr = piObjectModel->SetHost(static_cast<IObjectModelHost *>(this));
    piObjectModel->Release();

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::DestroyExtensibilityModel
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Destroys the extensibility model top level object
//
HRESULT CSnapInDesigner::DestroyExtensibilityModel()
{
    HRESULT     hr = S_OK;
    IObjectModel *piObjectModel = NULL;

    // If we have an extensibility model then release it

    if (NULL != m_piSnapInDesignerDef)
    {
        // First remove the host. No need to remove host on subordinate objects
        // as the object itself will do that.

        hr = m_piSnapInDesignerDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
        IfFailRet(hr);

        hr = piObjectModel->SetHost(NULL);
        piObjectModel->Release();
        IfFailRet(hr);

        m_piSnapInDesignerDef->Release();
        m_piSnapInDesignerDef = NULL;
    }

    return hr;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::UpdateDesignerName
//=--------------------------------------------------------------------------=
//
// Notes:
//
HRESULT CSnapInDesigner::UpdateDesignerName()
{
    HRESULT hr = S_OK;
    BOOL    fRet = FALSE;

    FREESTRING(m_bstrName);

    fRet = GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME,
                              VT_BSTR,
                              &m_bstrName);
    IfFailRet(hr);

    return hr;
}

//=--------------------------------------------------------------------------=
// CSnapInDesigner::ValidateName
//=--------------------------------------------------------------------------=
//
// Input:  BSTR bstrNewName [in] name to validate
//
// Output: S_OK - name is valid
//         S_FALSE - name is not valid
//         other - failure occurred
//
// Notes:
//
// Checks that the name is a valid VB identifier and that it is not currently
// in use within the snap-in's typeinfo. Displays message box if either check
// does not pass.
//
HRESULT CSnapInDesigner::ValidateName(BSTR bstrName)
{
    HRESULT hr = S_OK;
    char    szBuffer[1024];

    IfFailGo(m_piDesignerProgrammability->IsValidIdentifier(bstrName));

    if (S_FALSE == hr)
    {
        (void)::SDU_DisplayMessage(IDS_INVALID_IDENTIFIER,
                                   MB_OK | MB_ICONHAND,
                                   HID_mssnapd_InvalidIdentifier, 0,
                                   DontAppendErrorInfo, NULL, bstrName);
        goto Error;
    }
    
    IfFailGo(m_pSnapInTypeInfo->IsNameDefined(bstrName));
    if (S_OK == hr)
    {
        (void)::SDU_DisplayMessage(IDS_IDENTIFIER_IN_USE,
                                   MB_OK | MB_ICONHAND,
                                   HID_mssnapd_IdentifierInUse, 0,
                                   DontAppendErrorInfo, NULL, bstrName);
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Error:
    RRETURN(hr);
}

HRESULT CSnapInDesigner::AttachAmbients()
{
    HRESULT      hr = S_OK;
    VARIANT_BOOL fvarInteractive = VARIANT_FALSE;

    // If we are already attached then just return success

    IfFalseGo(!m_Ambients.Attached(), S_OK);

    // To ensure a good COleControl::m_pDispAmbient we need to fetch a
    // property as that is when the framework initializes it. There is no
    // particular reason for getting this property as opposed to some other.

    IfFalseGo(GetAmbientProperty(DISPID_AMBIENT_INTERACTIVE,
                                 VT_BOOL,
                                 &fvarInteractive), E_FAIL);

    m_Ambients.Attach(m_pDispAmbient);

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\destlib.cpp ===
//=--------------------------------------------------------------------------------------
// destlib.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Snap-In Designer Dynamic Type Library
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "destlib.h"
#include "snaputil.h"


// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::CSnapInTypeInfo()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSnapInTypeInfo::CSnapInTypeInfo() : m_pSnapInTypeLib(0),
  m_pcti2CoClass(0), m_guidCoClass(GUID_NULL),
  m_pctiDefaultInterface(0), m_guidDefaultInterface(GUID_NULL),
  m_pctiEventInterface(0), m_guidEventInterface(GUID_NULL),
  m_nextMemID(DISPID_DYNAMIC_BASE),
  m_bDirty(false), m_bInitialized(false), m_dwTICookie(0)
{
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::~CSnapInTypeInfo()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSnapInTypeInfo::~CSnapInTypeInfo()
{
    RELEASE(m_pctiDefaultInterface);
    RELEASE(m_pctiEventInterface);
    RELEASE(m_pcti2CoClass);
    RELEASE(m_pSnapInTypeLib);
}


/////////////////////////////////////////////////////////////////////////////
// CSnapInTypeInfo::InitializeTypeInfo()
//
// Create a new coclass for ISnapIn, and make it look like:
//
//    [
//      uuid(9C415910-C8C1-11d1-B447-2A9646000000),
//		helpstring("Snap-In Designer")
//    ]
//    coclass SnapIn {
//		[default] interface _ISnapIn;
//		[default, source] dispinterface DSnapInEvents;
//    };

// interface _ISnapIn : ISnapIn {
// };

HRESULT CSnapInTypeInfo::InitializeTypeInfo(ISnapInDef *piSnapInDef, BSTR bstrSnapIn)
{
    HRESULT             hr = S_OK;
    BSTR                bstrSnapInName = NULL;
    ITypeInfo          *ptiSnapIn = NULL;
    ITypeInfo          *ptiSnapInEvents = NULL;
    ICreateTypeInfo    *pctiCoClass = NULL;
    LPOLESTR            pOleStr = NULL;
    BSTR                bstrIID = NULL;

    if (true == m_bInitialized)
	    goto Error;     // been there, done that

    // Create this type library
    hr = Create(L"SnapInDesigner");
    IfFailGo(hr);

    // Create a blank typeinfo for the new coclass.
    bstrSnapInName = ::SysAllocString(L"SnapIn");
    if (NULL == bstrSnapInName)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = CreateCoClassTypeInfo(bstrSnapInName, &pctiCoClass, &m_guidCoClass);
    IfFailGo(hr);

    // Get ISnapIn's interface descriptions
    hr = GetSnapInTypeInfo(&ptiSnapIn, &ptiSnapInEvents);
    IfFailGo(hr);

    // Add the typeinfos for the interface and events
    hr = CreateDefaultInterface(pctiCoClass, ptiSnapIn);
    IfFailGo(hr);

    hr = AddEvents(pctiCoClass, ptiSnapInEvents);
    IfFailGo(hr);

    // Save the IID
    pOleStr = reinterpret_cast<LPOLESTR>(::CoTaskMemAlloc(1024));
    if (NULL == pOleStr)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = StringFromCLSID(m_guidDefaultInterface, &pOleStr);
    IfFailGo(hr);

    bstrIID = ::SysAllocString(pOleStr);
    if (NULL == bstrIID)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = piSnapInDef->put_IID(bstrIID);
    IfFailGo(hr);

    // We've got the typeinfo for our final compilable coclass. That
    // should be about it. Store it away as ICreateTypeInfo2.
    hr = pctiCoClass->QueryInterface(IID_ICreateTypeInfo2, reinterpret_cast<void **>(&m_pcti2CoClass));
    IfFailGo(hr);

    // It's a good idea to always lay out your new typeinfo
    hr = m_pcti2CoClass->LayOut();
    IfFailGo(hr);

    hr = MakeDirty();
    IfFailGo(hr);

    m_bInitialized = true;

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    if (NULL != pOleStr)
        ::CoTaskMemFree(pOleStr);
    FREESTRING(bstrIID);
    RELEASE(ptiSnapInEvents);
    RELEASE(ptiSnapIn);
    RELEASE(pctiCoClass);
    FREESTRING(bstrSnapInName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::RenameSnapIn(BSTR bstrOldName, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::RenameSnapIn(BSTR bstrOldName, BSTR bstrNewName)
{
    HRESULT              hr = S_OK;
    ITypeInfo           *pTypeInfo = NULL;
    ICreateTypeInfo2    *piCreateTypeInfo2 = NULL;

    hr = m_piTypeLib->GetTypeInfoOfGuid(m_guidCoClass, &pTypeInfo);
    IfFailGo(hr);

    hr = pTypeInfo->QueryInterface(IID_ICreateTypeInfo2, reinterpret_cast<void **>(&piCreateTypeInfo2));
    IfFailGo(hr);

    hr = piCreateTypeInfo2->SetName(bstrNewName);
    IfFailGo(hr);

    hr = piCreateTypeInfo2->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RELEASE(piCreateTypeInfo2);
    RELEASE(pTypeInfo);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::CreateDefaultInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiTemplate)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::CreateDefaultInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiTemplate)
{
    HRESULT     hr = S_OK;
    BSTR        bstrBaseName = NULL;
    int         nBaseLen = 0;
    BSTR        bstrRealName = NULL;
    ITypeInfo  *ptiInterfaceTypeInfo = NULL;

    hr = ptiTemplate->GetDocumentation(MEMBERID_NIL, &bstrBaseName, NULL, NULL, NULL);
    IfFailGo(hr);

    nBaseLen = ::SysStringLen(bstrBaseName);
    bstrRealName = ::SysAllocStringLen(NULL, nBaseLen + 1);
    if (NULL == bstrRealName)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::wcscpy(bstrRealName, L"_");
    ::wcscat(&bstrRealName[1], bstrBaseName);

    hr = CreateInterfaceTypeInfo(bstrRealName, &m_pctiDefaultInterface, &m_guidDefaultInterface);
//    hr = CreateVtblInterfaceTypeInfo(bstrRealName, &m_pctiDefaultInterface, &m_guidDefaultInterface);
    IfFailGo(hr);

    hr = CopyDispInterface(m_pctiDefaultInterface, ptiTemplate);
//    hr = SetBaseInterface(m_pctiDefaultInterface, ptiTemplate);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->QueryInterface(IID_ITypeInfo, reinterpret_cast<void **>(&ptiInterfaceTypeInfo));
    IfFailGo(hr);

    hr = AddInterface(pctiCoClass, ptiInterfaceTypeInfo);
    IfFailGo(hr);

Error:
    RELEASE(ptiInterfaceTypeInfo);
    FREESTRING(bstrRealName);
    FREESTRING(bstrBaseName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::CreateEventsInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiTemplate)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::CreateEventsInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiTemplate)
{
    HRESULT     hr = S_OK;
    BSTR        bstrBaseName = NULL;
    int         nBaseLen = 0;
    BSTR        bstrRealName = NULL;
    ITypeInfo  *ptiTargetEvents = NULL;

    hr = ptiTemplate->GetDocumentation(MEMBERID_NIL, &bstrBaseName, NULL, NULL, NULL);
    IfFailGo(hr);

    nBaseLen = ::SysStringLen(bstrBaseName);
    bstrRealName = ::SysAllocStringLen(NULL, nBaseLen + 1);
    if (NULL == bstrRealName)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::wcscpy(bstrRealName, L"_");
    ::wcscat(&bstrRealName[1], bstrBaseName);

    hr = CloneSnapInEvents(ptiTemplate, &m_pctiEventInterface, bstrRealName);
    IfFailGo(hr);

    hr = m_pctiEventInterface->QueryInterface(IID_ITypeInfo, reinterpret_cast<void **>(&ptiTargetEvents));
    IfFailGo(hr);

    hr = AddEvents(pctiCoClass, ptiTargetEvents);
    IfFailGo(hr);

Error:
    RELEASE(ptiTargetEvents);
    FREESTRING(bstrRealName);
    FREESTRING(bstrBaseName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::CloneSnapInEvents(ITypeInfo *ptiSnapInEvents)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::CloneSnapInEvents(ITypeInfo *ptiSnapInEvents, ICreateTypeInfo **ppiCreateTypeInfo, BSTR bstrName)
{
    HRESULT          hr = S_OK;
    ICreateTypeInfo *piCreateTypeInfo = NULL;
    GUID             guidTypeInfo = GUID_NULL;

    hr = CreateInterfaceTypeInfo(bstrName, ppiCreateTypeInfo, &guidTypeInfo);
    IfFailGo(hr);

    hr = CopyDispInterface(*ppiCreateTypeInfo, ptiSnapInEvents);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::GetSnapInLib()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Get a pointer to ISnapInDesigner's type library
//
HRESULT CSnapInTypeInfo::GetSnapInLib()
{
    HRESULT hr = S_OK;
    USHORT  usMajor = 0;
    USHORT  usMinor = 0;

    if (NULL == m_pSnapInTypeLib)		// Do this only once for each instantiation
    {
        hr = GetLatestTypeLibVersion(LIBID_SnapInLib, &usMajor, &usMinor);
        IfFailGo(hr);

        hr = ::LoadRegTypeLib(LIBID_SnapInLib,
                              usMajor,
                              usMinor,
                              LOCALE_SYSTEM_DEFAULT,
                              &m_pSnapInTypeLib);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::GetSnapInTypeInfo()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Get a pointer to the ISnapIn interfaces
//
HRESULT CSnapInTypeInfo::GetSnapInTypeInfo
(
    ITypeInfo **pptiSnapIn,
    ITypeInfo **pptiSnapInEvents
)
{
    HRESULT hr = S_OK;

    ASSERT(NULL != pptiSnapIn, "GetSnapInTypeInfo: pptiSnapIn is NULL");
    ASSERT(NULL != pptiSnapInEvents, "GetSnapInTypeInfo: pptiSnapInEvents is NULL");

    hr = GetSnapInLib();
    IfFailGo(hr);

    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(IID_ISnapIn, pptiSnapIn);
    IfFailGo(hr);

    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(DIID_DSnapInEvents, pptiSnapInEvents);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::MakeDirty()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// If the typeinfo was not dirty then increments the typeinfo cookie and marks
// the typeinfo dirty.
//
HRESULT CSnapInTypeInfo::MakeDirty()
{
    HRESULT hr = S_OK;

    if (!m_bDirty)
    {
        m_dwTICookie++;
        m_bDirty = TRUE;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::AddImageList(IMMCImageList *piMMCImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// interface _ISnapIn : ISnapIn {
//  [propget,source] MMCImageList imageList1();
//  };

HRESULT CSnapInTypeInfo::AddImageList
(
    IMMCImageList *piMMCImageList
)
{
    HRESULT             hr = S_OK;
    IObjectModel       *piObjectModel = NULL;
    DISPID              dispid = 0;
    BSTR                bstrName = NULL;
    ITypeInfo          *ptiReturnType = NULL;

    hr = piMMCImageList->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->GetDISPID(&dispid);
    IfFailGo(hr);

    if (0 == dispid)
    {
        dispid = m_nextMemID;
        ++m_nextMemID;

        hr = piObjectModel->SetDISPID(dispid);
        IfFailGo(hr);
    }
    else
    {
        if (dispid >= m_nextMemID)
            m_nextMemID = dispid + 1;
    }

    // Create a new property with the ImageList's name
    hr = piMMCImageList->get_Name(&bstrName);
    IfFailGo(hr);

    // Initialize the return value
    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(CLSID_MMCImageList, &ptiReturnType);
    IfFailGo(hr);

    hr = AddUserPropertyGet(m_pctiDefaultInterface, bstrName, ptiReturnType, dispid, 0);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RELEASE(piObjectModel);
    RELEASE(ptiReturnType);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::RenameImageList(IMMCImageList *piMMCImageList, BSTR bstrOldName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::RenameImageList
(
    IMMCImageList *piMMCImageList,
    BSTR           bstrOldName
)
{
    HRESULT     hr = S_OK;
    BSTR        bstrName = NULL;
    ITypeInfo  *ptiReturnType = NULL;

    hr = piMMCImageList->get_Name(&bstrName);
    IfFailGo(hr);

    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(CLSID_MMCImageList, &ptiReturnType);
    IfFailGo(hr);

    hr = RenameUserPropertyGet(m_pctiDefaultInterface, bstrOldName, bstrName, ptiReturnType);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RELEASE(ptiReturnType);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::DeleteImageList(IMMCImageList *piMMCImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::DeleteImageList
(
    IMMCImageList *piMMCImageList
)
{
    HRESULT     hr = S_OK;
    BSTR        bstrName = NULL;

    ASSERT(NULL != piMMCImageList, "DeleteImageList: piMMCImageList is NULL");

    hr = piMMCImageList->get_Name(&bstrName);
    IfFailGo(hr);

    hr = DeleteUserPropertyGet(m_pctiDefaultInterface, bstrName);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::AddToolbar(IMMCToolbar *piMMCToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// interface _ISnapIn : ISnapIn {
//  [propget,source] MMCToolbar toolbar1();
//  };

HRESULT CSnapInTypeInfo::AddToolbar
(
    IMMCToolbar *piMMCToolbar
)
{
    HRESULT             hr = S_OK;
    IObjectModel       *piObjectModel = NULL;
    DISPID              dispid = 0;
    BSTR                bstrName = NULL;
    ITypeInfo          *ptiReturnType = NULL;

    hr = piMMCToolbar->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->GetDISPID(&dispid);
    IfFailGo(hr);

    if (0 == dispid)
    {
        dispid = m_nextMemID;
        ++m_nextMemID;

        hr = piObjectModel->SetDISPID(dispid);
        IfFailGo(hr);
    }
    else
    {
        if (dispid >= m_nextMemID)
            m_nextMemID = dispid + 1;
    }

    // Create a new property with the Toolbar's name
    hr = piMMCToolbar->get_Name(&bstrName);
    IfFailGo(hr);

    // Initialize the return value
    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(CLSID_MMCToolbar, &ptiReturnType);
    IfFailGo(hr);

    hr = AddUserPropertyGet(m_pctiDefaultInterface, bstrName, ptiReturnType, dispid, 0);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RELEASE(piObjectModel);
    RELEASE(ptiReturnType);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::RenameToolbar(IMMCToolbar *piMMCToolbar, BSTR bstrOldName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::RenameToolbar
(
    IMMCToolbar *piMMCToolbar,
    BSTR         bstrOldName
)
{
    HRESULT     hr = S_OK;
    BSTR        bstrName = NULL;
    ITypeInfo  *ptiReturnType = NULL;

    hr = piMMCToolbar->get_Name(&bstrName);
    IfFailGo(hr);

    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(CLSID_MMCToolbar, &ptiReturnType);
    IfFailGo(hr);

    hr = RenameUserPropertyGet(m_pctiDefaultInterface, bstrOldName, bstrName, ptiReturnType);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RELEASE(ptiReturnType);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::DeleteToolbar(IMMCToolbar *piMMCToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::DeleteToolbar
(
    IMMCToolbar *piMMCToolbar
)
{
    HRESULT     hr = S_OK;
    BSTR        bstrName = NULL;

    ASSERT(NULL != piMMCToolbar, "DeleteImageList: piMMCToolbar is NULL");

    hr = piMMCToolbar->get_Name(&bstrName);
    IfFailGo(hr);

    hr = DeleteUserPropertyGet(m_pctiDefaultInterface, bstrName);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::AddMenu(IMMCMenu *piMMCMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// interface _ISnapIn : ISnapIn {
//  [propget,source] MMCMenu menu1();
//  };

HRESULT CSnapInTypeInfo::AddMenu
(
    IMMCMenu *piMMCMenu
)
{
    HRESULT             hr = S_OK;
    IObjectModel       *piObjectModel = NULL;
    DISPID              dispid = 0;
    BSTR                bstrName = NULL;
    ITypeInfo          *ptiReturnType = NULL;

    hr = piMMCMenu->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->GetDISPID(&dispid);
    IfFailGo(hr);

    if (0 == dispid)
    {
        dispid = m_nextMemID;
        ++m_nextMemID;

        hr = piObjectModel->SetDISPID(dispid);
        IfFailGo(hr);
    }
    else
    {
        if (dispid >= m_nextMemID)
            m_nextMemID = dispid + 1;
    }

    // Create a new property with the Menu's name
    hr = piMMCMenu->get_Name(&bstrName);
    IfFailGo(hr);

    // Initialize the return value
    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(CLSID_MMCMenu, &ptiReturnType);
    IfFailGo(hr);

    hr = AddUserPropertyGet(m_pctiDefaultInterface, bstrName, ptiReturnType, dispid, 0);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RELEASE(piObjectModel);
    RELEASE(ptiReturnType);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::RenameMenu(IMMCMenu *piMMCMenu, BSTR bstrOldName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::RenameMenu
(
    IMMCMenu *piMMCMenu,
    BSTR      bstrOldName
)
{
    HRESULT     hr = S_OK;
    BSTR        bstrName = NULL;
    ITypeInfo  *ptiReturnType = NULL;

    hr = piMMCMenu->get_Name(&bstrName);
    IfFailGo(hr);

    hr = m_pSnapInTypeLib->GetTypeInfoOfGuid(CLSID_MMCMenu, &ptiReturnType);
    IfFailGo(hr);

    hr = RenameUserPropertyGet(m_pctiDefaultInterface, bstrOldName, bstrName, ptiReturnType);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RELEASE(ptiReturnType);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::DeleteMenu(IMMCMenu *piMMCMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::DeleteMenu
(
    IMMCMenu *piMMCMenu
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    ASSERT(NULL != piMMCMenu, "DeleteMenu: piMMCMenu is NULL");

    hr = piMMCMenu->get_Name(&bstrName);
    IfFailGo(hr);

    hr = DeleteUserPropertyGet(m_pctiDefaultInterface, bstrName);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    FREESTRING(bstrName);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::DeleteMenuNamed(BSTR bstrName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInTypeInfo::DeleteMenuNamed
(
    BSTR bstrName
)
{
    HRESULT hr = S_OK;

    ASSERT(NULL != bstrName, "DeleteMenuNamed: bstrName is NULL");

    hr = DeleteUserPropertyGet(m_pctiDefaultInterface, bstrName);
    IfFailGo(hr);

    hr = m_pctiDefaultInterface->LayOut();
    IfFailGo(hr);

    MakeDirty();

#ifdef DEBUG
    m_piCreateTypeLib2->SaveAllChanges();
#endif

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInTypeInfo::IsNameDefined(IMMCMenu *piMMCMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Return S_OK if name is present in the main interface, S_FALSE otherwise
//
HRESULT CSnapInTypeInfo::IsNameDefined(BSTR bstrName)
{
    HRESULT     hr = S_OK;
    long        lIndex = 0;

    hr = GetNameIndex(m_pctiDefaultInterface, bstrName, &lIndex);
    IfFailGo(hr);

    if (-1 == lIndex)
        hr = S_FALSE;

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\dmenu.cpp ===
//=--------------------------------------------------------------------------------------
// menu.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- Menu-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "snaputil.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddMenu(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddMenu(CSelectionHolder *pSelection)
{
    HRESULT    hr = S_OK;
    IMMCMenus *piMMCMenus = NULL;
    VARIANT    vtEmpty;
    IMMCMenu  *piMMCMenu = NULL;

    ::VariantInit(&vtEmpty);

    if ( (SEL_TOOLS_ROOT == pSelection->m_st) ||
         (SEL_TOOLS_MENUS == pSelection->m_st) )
    {
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == pSelection->m_st)
    {
        hr = pSelection->m_piObject.m_piMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piMMCMenus));
        IfFailGo(hr);
    }

    if (piMMCMenus != NULL)
    {
        vtEmpty.vt = VT_ERROR;
        vtEmpty.scode = DISP_E_PARAMNOTFOUND;

        hr = piMMCMenus->Add(vtEmpty, vtEmpty, &piMMCMenu);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtEmpty);
    RELEASE(piMMCMenus);
    RELEASE(piMMCMenu);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DemoteMenu(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Make this node a child of the preceeding node.
//  If this node is not a leaf, then the whole tree
//  needs to be indented.
HRESULT CSnapInDesigner::DemoteMenu(CSelectionHolder *pMenu)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pPreviousMenu = NULL;
    CSelectionHolder *pParentMenu = NULL;
    IMMCMenus        *piMMCMenus = NULL;
    BSTR              bstrKey = NULL;
    IMMCMenu         *piMMCMenu = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    m_bDoingPromoteOrDemote = TRUE;

    // Get the previous node
    hr = m_pTreeView->GetPreviousNode(pMenu, &pPreviousMenu);
    IfFailGo(hr);

    // Get the menu definition tree for the previous node
    piMMCMenu = pMenu->m_piObject.m_piMMCMenu;
    piMMCMenu->AddRef();

    // Get the parent of this node
    hr = m_pTreeView->GetParent(pMenu, &pParentMenu);
    IfFailGo(hr);

    // Get the menu collection that contains this node
    if (SEL_TOOLS_MENUS == pParentMenu->m_st)
    {
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == pParentMenu->m_st)
    {
        piMMCMenus = pParentMenu->m_piChildrenMenus;
        piMMCMenus->AddRef();
    }

    // Remove this menu from its containing collection
    if (piMMCMenus != NULL)
    {
        hr = pMenu->m_piObject.m_piMMCMenu->get_Key(&bstrKey);
        IfFailGo(hr);

        varKey.vt = VT_BSTR;
        varKey.bstrVal = ::SysAllocString(bstrKey);
        if (NULL == varKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        // Doing a Remove operation on the collection will generate an
        // OnDeleteMenu notification (see below). Because we have set
        // m_bDoingPromoteOrDemote = TRUE, that method won't do anything.

        hr = piMMCMenus->Remove(varKey);
        IfFailGo(hr);
    }

    // Add this menu node to the preceeding node's collection.
    RELEASE(piMMCMenus);

    hr = pPreviousMenu->m_piObject.m_piMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piMMCMenus));
    IfFailGo(hr);

    if (piMMCMenus != NULL)
    {
        // Doing an AddExisting operation on the collection will generate an
        // OnAddMMCMenu notification (see below). Because we have set
        // m_bDoingPromoteOrDemote = TRUE, that method won't do anything. We
        // don't specify an index because in a demotion the new position is
        // following the last child of the new parent which means appending
        // to the end of the collection.

        varIndex.vt = VT_ERROR;
        varIndex.scode = DISP_E_PARAMNOTFOUND;

        hr = piMMCMenus->AddExisting(piMMCMenu, varIndex);
        IfFailGo(hr);
    }

    // Now we need to prune the old subtree from its old parent and graft
    // it to its new parent.
    IfFailGo(m_pTreeView->PruneAndGraft(pMenu, pPreviousMenu, kMenuIcon));

    // Set the selection to this menu in its new position

    IfFailGo(m_pTreeView->SelectItem(pMenu));
    IfFailGo(OnSelectionChanged(pMenu));

Error:
    m_bDoingPromoteOrDemote = FALSE;

    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_DEMOTE_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_DemoteFailed, hr, AppendErrorInfo, NULL);
    }

    RELEASE(piMMCMenu);
    FREESTRING(bstrKey);
    ::VariantClear(&varKey);
    RELEASE(piMMCMenu);

    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PromoteMenu(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Make the currently selected menu a peer of its parent.
//
HRESULT CSnapInDesigner::PromoteMenu(CSelectionHolder *pMenu)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pParentMenu = NULL;
    IMMCMenus        *piMMCMenus = NULL;
    BSTR              bstrKey = NULL;
    CSelectionHolder *pParentParentMenu = NULL;
    IMMCMenu         *piMMCMenu = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    m_bDoingPromoteOrDemote = TRUE;

    // Get the root of the menu tree being promoted
    piMMCMenu = pMenu->m_piObject.m_piMMCMenu;
    piMMCMenu->AddRef();

    // Get the parent of this node
    hr = m_pTreeView->GetParent(pMenu, &pParentMenu);
    IfFailGo(hr);

    // Get the menu collection that contains this node (the parent's child
    // menu collection)
    if (SEL_TOOLS_MENUS == pParentMenu->m_st)
    {
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == pParentMenu->m_st)
    {
        piMMCMenus = pParentMenu->m_piChildrenMenus;
        piMMCMenus->AddRef();
    }

    // Remove this menu from its containing collection
    if (piMMCMenus != NULL)
    {
        hr = pMenu->m_piObject.m_piMMCMenu->get_Key(&bstrKey);
        IfFailGo(hr);

        varKey.vt = VT_BSTR;
        varKey.bstrVal = ::SysAllocString(bstrKey);
        if (NULL == varKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        // Doing a Remove operation on the collection will generate an
        // OnDeleteMenu notification (see below). Because we have set
        // m_bDoingPromoteOrDemote = TRUE, that method won't do anything.

        hr = piMMCMenus->Remove(varKey);
        IfFailGo(hr);
    }

    RELEASE(piMMCMenus);

    // Get the parent's parent
    
    hr = m_pTreeView->GetParent(pParentMenu, &pParentParentMenu);
    IfFailGo(hr);

    // Get the parent's parent's child menu collection

    if (SEL_TOOLS_MENUS == pParentParentMenu->m_st)
    {
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == pParentParentMenu->m_st)
    {
        piMMCMenus = pParentParentMenu->m_piChildrenMenus;
        piMMCMenus->AddRef();
    }

    // Add the node to its parent's parent's child nodes.
    // Ensure that the node has an index that is immediately following its
    // old parent's index. This is so the node will appear in the menu immediately
    // following its parent. That is the user's expectation when promoting a node.
    // For example, given the following menu:
    //
    //  Menus
    //      Menu1
    //          Menu1Child
    //      Menu2
    //
    // If the user promotes Menu1Child they expect the tree to appear as follows:
    //
    //  Menus
    //      Menu1
    //      Menu1Child
    //      Menu2
    //

    if (piMMCMenus != NULL)
    {
        IfFailGo(pParentMenu->m_piObject.m_piMMCMenu->get_Index(&varIndex.lVal));
        varIndex.vt = VT_I4;
        varIndex.lVal++;
        
        // Doing an AddExisting operation on the collection will generate an
        // OnAddMMCMenu notification (see below). Because we have set
        // m_bDoingPromoteOrDemote = TRUE, that method won't do anything.
        hr = piMMCMenus->AddExisting(piMMCMenu, varIndex);
        IfFailGo(hr);
    }

    // Now move the menu node in the treeview to the position immediately
    // following its old parent, (as a peer of its old parent), and re-parent
    // its child menu nodes to the new position.

    IfFailGo(m_pTreeView->MoveNodeAfter(pMenu, pParentParentMenu, pParentMenu,
                                        kMenuIcon));

    // Set the selection to this menu in its new position

    IfFailGo(m_pTreeView->SelectItem(pMenu));
    IfFailGo(OnSelectionChanged(pMenu));

Error:
    m_bDoingPromoteOrDemote = FALSE;

    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_PROMOTE_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_PromoteFailed, hr, AppendErrorInfo, NULL);
    }

    RELEASE(piMMCMenu);
    FREESTRING(bstrKey);
    ::VariantClear(&varKey);
    RELEASE(piMMCMenus);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MoveMenuUp(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Swap previous with current
//
HRESULT CSnapInDesigner::MoveMenuUp(CSelectionHolder *pMenu)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pParentMenu = NULL;
    IMMCMenus        *piMMCMenus = NULL;
    CSelectionHolder *pPreviousMenu = NULL;
    long              lOldIndex = 0;
    long              lNewIndex = 0;

    hr = m_pTreeView->GetParent(pMenu, &pParentMenu);
    IfFailGo(hr);

    if (SEL_TOOLS_MENUS == pParentMenu->m_st)
    {
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == pParentMenu->m_st)
    {
        piMMCMenus = pParentMenu->m_piChildrenMenus;
        piMMCMenus->AddRef();
    }

    // Get the previous node and get the current indices
    hr = m_pTreeView->GetPreviousNode(pMenu, &pPreviousMenu);
    IfFailGo(hr);

    hr = pMenu->m_piObject.m_piMMCMenu->get_Index(&lOldIndex);
    IfFailGo(hr);

    hr = pPreviousMenu->m_piObject.m_piMMCMenu->get_Index(&lNewIndex);
    IfFailGo(hr);

    // Swap them
    hr = piMMCMenus->Swap(lOldIndex, lNewIndex);
    IfFailGo(hr);

    hr = SetMenuKey(pMenu);
    IfFailGo(hr);

    hr = SetMenuKey(pPreviousMenu);
    IfFailGo(hr);

    // Move the previous menu node after the moving menu node and reparent
    // its children

    IfFailGo(m_pTreeView->MoveNodeAfter(pPreviousMenu, pParentMenu, pMenu,
                                        kMenuIcon));

    // Select the moving node
    
    hr = m_pTreeView->SelectItem(pMenu);
    IfFailGo(hr);

    hr = OnSelectionChanged(pMenu);
    IfFailGo(hr);

Error:
    RELEASE(piMMCMenus);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MoveMenuDown(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MoveMenuDown(CSelectionHolder *pMenu)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pParentMenu = NULL;
    IMMCMenus        *piMMCMenus = NULL;
    CSelectionHolder *pNextMenu = NULL;
    long              lOldIndex = 0;
    long              lNewIndex = 0;

    hr = m_pTreeView->GetParent(pMenu, &pParentMenu);
    IfFailGo(hr);

    if (SEL_TOOLS_MENUS == pParentMenu->m_st)
    {
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == pParentMenu->m_st)
    {
        piMMCMenus = pParentMenu->m_piChildrenMenus;
        piMMCMenus->AddRef();
    }

    // Get the next node and get the current indices
    hr = m_pTreeView->GetNextChildNode(pMenu, &pNextMenu);
    IfFailGo(hr);

    hr = pMenu->m_piObject.m_piMMCMenu->get_Index(&lOldIndex);
    IfFailGo(hr);

    hr = pNextMenu->m_piObject.m_piMMCMenu->get_Index(&lNewIndex);
    IfFailGo(hr);

    // Swap them
    hr = piMMCMenus->Swap(lOldIndex, lNewIndex);
    IfFailGo(hr);

    hr = SetMenuKey(pMenu);
    IfFailGo(hr);

    hr = SetMenuKey(pNextMenu);
    IfFailGo(hr);

    // Move the moving menu node after the next menu node and reparent
    // its children

    IfFailGo(m_pTreeView->MoveNodeAfter(pMenu, pParentMenu, pNextMenu, kMenuIcon));

    hr = m_pTreeView->SelectItem(pMenu);
    IfFailGo(hr);

    hr = OnSelectionChanged(pMenu);
    IfFailGo(hr);

Error:
    RELEASE(piMMCMenus);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddMMCMenu(CSelectionHolder *pParent, IMMCMenu *piMMCMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnAddMMCMenu(CSelectionHolder *pParent, IMMCMenu *piMMCMenu)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pMenu = NULL;
    long                 lCount = 0;
    long                 lIndex = 0;
    IMMCMenu            *piMMCChildMenu = NULL;

    VARIANT vtIndex;
    ::VariantInit(&vtIndex);

    IfFalseGo(!m_bDoingPromoteOrDemote, S_OK);

    ASSERT(NULL != pParent, "OnAddMMCMenu: pParent is NULL");
    ASSERT(NULL != piMMCMenu, "OnAddMMCMenu: piMMCMenu is NULL");

    hr = MakeNewMenu(piMMCMenu, &pMenu);
    IfFailGo(hr);

    hr = pMenu->RegisterHolder();
    IfFailGo(hr);

    hr = InsertMenuInTree(pMenu, pParent);
    IfFailGo(hr);

    hr = m_pSnapInTypeInfo->AddMenu(pMenu->m_piObject.m_piMMCMenu);
    IfFailGo(hr);

    // Add the children, if any
    hr = pMenu->m_piChildrenMenus->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = pMenu->m_piChildrenMenus->get_Item(vtIndex, reinterpret_cast<MMCMenu **>(&piMMCChildMenu));
        IfFailGo(hr);

        hr = OnAddMMCMenu(pMenu, piMMCChildMenu);
        IfFailGo(hr);

        RELEASE(piMMCChildMenu);
    }

    // All done. Set the selection
    hr = OnSelectionChanged(pMenu);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pMenu);
    IfFailGo(hr);

    if (false == m_bDoingPromoteOrDemote)
    {
        hr = m_pTreeView->Edit(pMenu);
        IfFailGo(hr);
    }

    m_fDirty = TRUE;

Error:
    ::VariantClear(&vtIndex);
    RELEASE(piMMCChildMenu);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AssignMenuDispID(CSelectionHolder *pMenuTarget, CSelectionHolder *pMenuSrc)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  pMenuTarget->DISPID = pMenuSrc->DISPID
//
HRESULT CSnapInDesigner::AssignMenuDispID(CSelectionHolder *pMenuTarget, CSelectionHolder *pMenuSrc)
{
    HRESULT         hr = S_OK;
    IObjectModel   *piObjectModelTarget = NULL;
    DISPID          dispid = 0;
    IObjectModel   *piObjectModelSrc = NULL;

    ASSERT(NULL != pMenuTarget, "AssignMenuDispID: pMenuTarget is NULL");
    ASSERT(NULL != pMenuSrc, "AssignMenuDispID: pMenuSrc is NULL");

    hr = pMenuTarget->m_piObject.m_piMMCMenu->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModelTarget));
    IfFailGo(hr);

    hr = piObjectModelTarget->GetDISPID(&dispid);
    IfFailGo(hr);

    hr = pMenuSrc->m_piObject.m_piMMCMenu->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModelSrc));
    IfFailGo(hr);

    hr = piObjectModelSrc->SetDISPID(dispid);
    IfFailGo(hr);

Error:
    RELEASE(piObjectModelSrc);
    RELEASE(piObjectModelTarget);

    RRETURN(hr);
}




//=--------------------------------------------------------------------------------------
// CSnapInDesigner::SetMenuKey(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::SetMenuKey(CSelectionHolder *pMenu)
{
    HRESULT     hr = S_OK;
    long        lIndex = 0;

    VARIANT varKey;
    ::VariantInit(&varKey);

    hr = pMenu->m_piObject.m_piMMCMenu->get_Name(&varKey.bstrVal);
    IfFailGo(hr);
    varKey.vt = VT_BSTR;

    hr = pMenu->m_piObject.m_piMMCMenu->put_Key(varKey.bstrVal);
    IfFailGo(hr);

Error:
    ::VariantClear(&varKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameMenu(CSelectionHolder *pMenu, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameMenu(CSelectionHolder *pMenu, BSTR bstrNewName)
{
    HRESULT              hr = S_OK;
    BSTR                 bstrOldName = NULL;
    TCHAR               *pszName = NULL;

    ASSERT(SEL_TOOLS_MENUS_NAME == pMenu->m_st, "RenameMenu: wrong argument");

    // Check that the new name is valid
    IfFailGo(ValidateName(bstrNewName));
    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    // If the new name is already defined, delete the old one,
    // otherwise rename the old one with the new name
    hr = m_pTreeView->GetLabel(pMenu, &bstrOldName);
    IfFailGo(hr);

    hr = m_pSnapInTypeInfo->RenameMenu(pMenu->m_piObject.m_piMMCMenu, bstrOldName);
    IfFailGo(hr);

    // Update the tree
    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->ChangeText(pMenu, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
    {
        CtlFree(pszName);
    }
    FREESTRING(bstrOldName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMenu(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMenu(CSelectionHolder *pMenu)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pParent = NULL;
    IMMCMenus        *piMMCMenus = NULL;
    BSTR              bstrKey = NULL;
    VARIANT           varKey;

    ::VariantInit(&varKey);

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pMenu, &pParent);
    IfFailGo(hr);

    if (SEL_TOOLS_MENUS == pParent->m_st)
    {
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == pParent->m_st)
    {
        piMMCMenus = pParent->m_piChildrenMenus;
        piMMCMenus->AddRef();
    }

    if (piMMCMenus != NULL)
    {
        hr = pMenu->m_piObject.m_piMMCMenu->get_Key(&bstrKey);
        IfFailGo(hr);

        varKey.vt = VT_BSTR;
        varKey.bstrVal = ::SysAllocString(bstrKey);
        if (NULL == varKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        hr = piMMCMenus->Remove(varKey);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&varKey);
    FREESTRING(bstrKey);
    RELEASE(piMMCMenus);

    RRETURN(hr);
}


HRESULT CSnapInDesigner::DeleteMenuTreeTypeInfo(IMMCMenu *piMMCMenu)
{
    HRESULT    hr = S_OK;
    BSTR       bstrName = NULL;
    IMMCMenus *piChildren = NULL;
    IMMCMenu  *piChild = NULL;
    long       cChildren = 0;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    IfFailGo(piMMCMenu->get_Name(&bstrName));

    IfFailGo(m_pSnapInTypeInfo->IsNameDefined(bstrName));

    if (S_OK == hr)
    {
        hr = m_pSnapInTypeInfo->DeleteMenu(piMMCMenu);
        IfFailGo(hr);
    }

    IfFailGo(piMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piChildren)));
    IfFailGo(piChildren->get_Count(&cChildren));

    varIndex.vt = VT_I4;
    for (varIndex.lVal = 1L; varIndex.lVal <= cChildren; varIndex.lVal++)
    {
        IfFailGo(piChildren->get_Item(varIndex, reinterpret_cast<MMCMenu **>(&piChild)));
        IfFailGo(DeleteMenuTreeTypeInfo(piChild));
        RELEASE(piChild);
    }

Error:
    QUICK_RELEASE(piChild);
    QUICK_RELEASE(piChildren);
    FREESTRING(bstrName);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMenu(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMenu(CSelectionHolder *pMenu)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pParent = NULL;
    IMMCMenus        *piMMCMenus = NULL;
    long              lCount = 0;

    IfFalseGo(!m_bDoingPromoteOrDemote, S_OK);

    IfFailGo(DeleteMenuTreeTypeInfo(pMenu->m_piObject.m_piMMCMenu));

    // Clear all cookies for this menu tree
    hr = UnregisterMenuTree(pMenu);
	IfFailGo(hr);

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pMenu, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pMenu);
    IfFailGo(hr);

    delete pMenu;

    // Select the next selection
    switch (pParent->m_st)
    {
    case SEL_TOOLS_MENUS:
        hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
        IfFailGo(hr);
        break;
    }

    if (NULL != piMMCMenus)
    {
        hr = piMMCMenus->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piMMCMenus);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::UnregisterMenuTree(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::UnregisterMenuTree
(
    CSelectionHolder *pMenu
)
{
    HRESULT           hr = S_OK;
	long              lCount = 0;
	long              lIndex = 0;
    VARIANT           vtIndex;
    IMMCMenu         *piMMCMenu = NULL;
	IUnknown         *piUnknown = NULL;
	CSelectionHolder *pChildMenu = NULL;

    ::VariantInit(&vtIndex);

	hr = pMenu->UnregisterHolder();
	IfFailGo(hr);

	hr = pMenu->m_piChildrenMenus->get_Count(&lCount);
	IfFailGo(hr);

	for (lIndex = 1; lIndex <= lCount; ++lIndex)
	{
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

		hr = pMenu->m_piChildrenMenus->get_Item(vtIndex, reinterpret_cast<MMCMenu **>(&piMMCMenu));
		IfFailGo(hr);

		hr = piMMCMenu->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnknown));
		IfFailGo(hr);

		hr = m_pTreeView->FindInTree(piUnknown, &pChildMenu);
        IfFailGo(hr);

		hr = UnregisterMenuTree(pChildMenu);
        IfFailGo(hr);

		RELEASE(piUnknown);
		RELEASE(piMMCMenu);
	}

Error:
	RELEASE(piUnknown);
	RELEASE(piMMCMenu);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewMenu(IMMCMenu *piMMCMenu, CSelectionHolder **ppMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewMenu
(
    IMMCMenu          *piMMCMenu,
    CSelectionHolder **ppMenu
)
{
    HRESULT    hr = S_OK;
    IMMCMenus *piChildren = NULL;

    hr = piMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piChildren));
    IfFailGo(hr);

    *ppMenu = New CSelectionHolder(piMMCMenu, piChildren);
    if (*ppMenu == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewMenu(piMMCMenu);
    IfFailGo(hr);

    hr = SetMenuKey(*ppMenu);
	IfFailGo(hr);

Error:
    RELEASE(piChildren);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewMenu(IMMCMenu *piMMCMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewMenu
(
    IMMCMenu *piMMCMenu
)
{
    HRESULT           hr = S_OK;
    int               iResult = 0;
    int               iItemNumber = 1;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    CSelectionHolder *pMenuClone = NULL;

	hr = piMMCMenu->get_Name(&bstrName);
	IfFailGo(hr);

	if (NULL == bstrName || 0 == ::SysStringLen(bstrName))
	{
		hr = GetResourceString(IDS_MENU, szBuffer, kMaxBuffer);
		IfFailGo(hr);

		do {
			iResult = _stprintf(szName, _T("%s%d"), szBuffer, iItemNumber++);
			if (iResult == 0)
			{
				hr = HRESULT_FROM_WIN32(::GetLastError());
				EXCEPTION_CHECK(hr);
			}

			hr = m_pTreeView->FindLabelInTree(szName, &pMenuClone);
			IfFailGo(hr);

			if (S_FALSE == hr)
			{
				break;
			}
		} while (TRUE);

		FREESTRING(bstrName);
		hr = BSTRFromANSI(szName, &bstrName);
		IfFailGo(hr);
	}

	hr = piMMCMenu->put_Name(bstrName);
	IfFailGo(hr);

	hr = piMMCMenu->put_Caption(bstrName);
	IfFailGo(hr);

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertMenuInTree(CSelectionHolder *pMenu, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertMenuInTree
(
    CSelectionHolder *pMenu,
    CSelectionHolder *pParent
)
{
    HRESULT      hr = S_OK;
    BSTR         bstrName = NULL;
    TCHAR       *pszName = NULL;

    hr = pMenu->m_piObject.m_piMMCMenu->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kMenuIcon, pMenu);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::IsTopLevelMenu(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::IsTopLevelMenu
(
    CSelectionHolder *pMenu
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;

    hr = m_pTreeView->GetParent(pMenu, &pParent);
    IfFailGo(hr);

    if (SEL_TOOLS_MENUS == pParent->m_st)
        hr = S_OK;
    else
        hr = S_FALSE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CanPromoteMenu(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Can only promote (make a peer of preceeding node) this menu if:
//
//  1. It is not the first child of the SEL_TOOLS_MENUS node
//
HRESULT CSnapInDesigner::CanPromoteMenu
(
    CSelectionHolder *pMenu
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;

    hr = m_pTreeView->GetParent(pMenu, &pParent);
    IfFailGo(hr);

    if (SEL_TOOLS_MENUS == pParent->m_st)
        hr = S_FALSE;
    else
        hr = S_OK;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CanDemoteMenu(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Can only demote (make a child of preceeding node) this menu if:
//
//  1. It is not the first child of the parent node
//
HRESULT CSnapInDesigner::CanDemoteMenu
(
    CSelectionHolder *pMenu
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    CSelectionHolder    *pSelection = NULL;

    hr = m_pTreeView->GetParent(pMenu, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->GetFirstChildNode(pParent, &pSelection);
    IfFailGo(hr);

    if (pSelection != pMenu)
        hr = S_OK;
    else
        hr = S_FALSE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CanMoveMenuUp(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Can only move menu up if:
//
//  1. It is not the first child of the parent node
//
HRESULT CSnapInDesigner::CanMoveMenuUp
(
    CSelectionHolder *pMenu
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    CSelectionHolder    *pSelection = NULL;

    hr = m_pTreeView->GetParent(pMenu, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->GetFirstChildNode(pParent, &pSelection);
    IfFailGo(hr);

    if (pSelection != pMenu)
        hr = S_OK;
    else
        hr = S_FALSE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CanMoveMenuDown(CSelectionHolder *pMenu)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Can only move menu down if:
//
//  1. There is another peer after it
//
HRESULT CSnapInDesigner::CanMoveMenuDown
(
    CSelectionHolder *pMenu
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pSelection = NULL;

    hr = m_pTreeView->GetNextChildNode(pMenu, &pSelection);
    IfFailGo(hr);

    if (NULL != pSelection)
        hr = S_OK;
    else
        hr = S_FALSE;

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\dll.cpp ===
//=--------------------------------------------------------------------------=
// dll.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
//
// Various routines et all that aren't in a file for a particular automation
// object, and don't need to be in the generic ole automation code.
//
#include "pch.h"

#include <initguid.h>              // define all the guids.
#define INITOBJECTS                // define AUTOMATIONOBJECTINFO structs
#include "common.h"

#include "desmain.h"
#include "guids.h"
#include "psmain.h"
#include "psextend.h"
#include "psnode.h"
#include "pslistvw.h"
#include "psurl.h"
#include "psocx.h"
#include "pstaskp.h"
#include "psimglst.h"
#include "pstoolbr.h"


// mssnapr punk. We need to ensure the mssnapd DLL is loaded for the duration
// of the mssnapd.ocx load so that DllGetDocumentation works
//
static LPUNKNOWN g_punkMssnapr = NULL;

// needed for ASSERTs and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// Our Libid.  This should be the LIBID from the Type library, or NULL if you
// don't have one.
//
const CLSID *g_pLibid = &LIBID_SnapInLib;

//=--------------------------------------------------------------------------=
// Set this up if you want to have a window proc for your parking window. This
// is really only interesting for Sub-classed controls that want, in design
// mode, certain messages that are sent only to the parent window.
//
WNDPROC g_ParkingWindowProc = NULL;

//=--------------------------------------------------------------------------=
// Localization Information
//
// We need the following two pieces of information:
//    a. whether or not this DLL uses satellite DLLs for localization.  if
//       not, then the lcidLocale is ignored, and we just always get resources
//       from the server module file.
//    b. the ambient LocaleID for this in-proc server.  Controls calling
//       GetResourceHandle() will set this up automatically, but anybody
//       else will need to be sure that it's set up properly.
//
const VARIANT_BOOL g_fSatelliteLocalization =  TRUE;
LCID               g_lcidLocale = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);


//=--------------------------------------------------------------------------=
// your license key and where under HKEY_CLASSES_ROOT_LICENSES it's sitting
//
const WCHAR g_wszLicenseKey [] = L"";
const WCHAR g_wszLicenseLocation [] = L"";

//=--------------------------------------------------------------------------=
// TODO: 
//
// Setting this flag to TRUE will cause your control to be created using
// its runtime license key even if it's created as part of a composite
// control (ie: a VB5-built UserControl) in a design environment.  A user
// of the composite control does not need to acquire or purchase your design-time
// license in order to use the composite control.
//
// The current setting of FALSE means that in order for your control to 
// load as part of a composite control (in a design-time environment), 
// the composite control user will need to acquire or purchase your 
// control's design-time license.  This setting is more restrictive 
// in terms of control distribution and licensing when compared to 
// setting this to TRUE. 
//
const BOOL g_fUseRuntimeLicInCompositeCtl = FALSE;


// TODO: Cleanup this mess
static char szInstanceInfo [] = "CLSID\\{B3E55942-FFD8-11d1-9788-44A620524153}\\Instance CLSID";
static char szRuntimeInstCLSID[] = "{9C415910-C8C1-11d1-B447-2A9646000000}";
static const char szMiscStatusRegKey [] = "CLSID\\{B3E55942-FFD8-11d1-9788-44A620524153}\\MiscStatus\\1";
static const char szMiscStatusValue [] = "1024";
static char szPublicSetting [] = "CLSID\\{B3E55942-FFD8-11d1-9788-44A620524153}\\DesignerFeatures";

static DWORD dwPublicFlag = DESIGNERFEATURE_MUSTBEPUBLIC |
                            DESIGNERFEATURE_CANBEPUBLIC |
                            DESIGNERFEATURE_CANCREATE |
                            DESIGNERFEATURE_NOTIFYAFTERRUN |
                            DESIGNERFEATURE_STARTUPINFO |
                            DESIGNERFEATURE_NOTIFYBEFORERUN |
                            DESIGNERFEATURE_REGISTRATION |
                            DESIGNERFEATURE_INPROCONLY;

static char szImplementedCatsKey [] = "Implemented Categories";

//=--------------------------------------------------------------------------=
// This Table describes all the automatible objects in your automation server.
// See AutomationObject.H for a description of what goes in this structure
// and what it's used for.
//
OBJECTINFO g_ObjectInfo[] = {
    CONTROLOBJECT(SnapInDesigner),

	PROPERTYPAGE(SnapInGeneral),
	PROPERTYPAGE(SnapInImageList),
	PROPERTYPAGE(SnapInAvailNodes),

    PROPERTYPAGE(NodeGeneral),
    PROPERTYPAGE(ScopeItemDefColHdrs),

    PROPERTYPAGE(ListViewGeneral),
	PROPERTYPAGE(ListViewImgLists),
	PROPERTYPAGE(ListViewSorting),
	PROPERTYPAGE(ListViewColHdrs),

    PROPERTYPAGE(URLViewGeneral),
	PROPERTYPAGE(OCXViewGeneral),

	PROPERTYPAGE(ImageListImages),

	PROPERTYPAGE(ToolbarGeneral),
	PROPERTYPAGE(ToolbarButtons),

	PROPERTYPAGE(TaskpadViewGeneral),
	PROPERTYPAGE(TaskpadViewBackground),
	PROPERTYPAGE(TaskpadViewTasks),

    EMPTYOBJECT
};

//=--------------------------------------------------------------------------=
// These are all of the CATID's that the control needs to register.
//
const CATID *g_rgCATIDImplemented[] =
{
  &CATID_Designer,
  &CATID_PersistsToPropertyBag,
  &CATID_PersistsToStreamInit,
  &CATID_PersistsToStorage,
};
extern const int g_ctCATIDImplemented = sizeof(g_rgCATIDImplemented) / 
                                        sizeof(CATID *);
const CATID *g_rgCATIDRequired[] = {NULL};
extern const int g_ctCATIDRequired = 0;

const char g_szLibName[] = "SnapInDesigner";


//=--------------------------------------------------------------------------=
// IntializeLibrary
//=--------------------------------------------------------------------------=
// called from DllMain:DLL_PROCESS_ATTACH.  allows the user to do any sort of
// initialization they want to.
//
// Notes:
//
void InitializeLibrary
(
    void
)
{
    HRESULT hr = S_OK;
    int nRet = 0;
    
    //nRet = LoadString(GetResourceHandle(), IDS_WEBCLASSDESIGNER, g_szDesignerName, sizeof(g_szDesignerName));

}

//=--------------------------------------------------------------------------=
// UninitializeLibrary
//=--------------------------------------------------------------------------=
// called from DllMain:DLL_PROCESS_DETACH.  allows the user to clean up anything
// they want.
//
// Notes:
//
void UninitializeLibrary
(
    void
)
{
    // TODO: uninitialization here.  control window class will be unregistered
    // for you, but anything else needs to be cleaned up manually.
    // Please Note that the Window 95 DLL_PROCESS_DETACH isn't quite as stable
    // as NT's, and you might crash doing certain things here ...
}


//=--------------------------------------------------------------------------=
// CheckForLicense
//=--------------------------------------------------------------------------=
// users can implement this if they wish to support Licensing.  otherwise,
// they can just return TRUE all the time.
//
// Parameters:
//    none
//
// Output:
//    BOOL            - TRUE means the license exists, and we can proceed
//                      FALSE means we're not licensed and cannot proceed
//
// Notes:
//    - implementers should use g_wszLicenseKey and g_wszLicenseLocation
//      from the top of this file to define their licensing [the former
//      is necessary, the latter is recommended]
//
BOOL CheckForLicense
(
    void
)
{
    // TODO: decide whether or not your server is licensed in this function.
    // people who don't want to bother with licensing should just return
    // true here always.  g_wszLicenseKey and g_wszLicenseLocation are
    // used by IClassFactory2 to do some of the licensing work.
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// CheckLicenseKey
//=--------------------------------------------------------------------------=
// when IClassFactory2::CreateInstanceLic is called, a license key is passed
// in, and then passed on to this routine.  users should return a boolean 
// indicating whether it is a valid license key or not
//
// Parameters:
//    LPWSTR          - [in] the key to check
//
// Output:
//    BOOL            - false means it's not valid, true otherwise
//
// Notes:
//
BOOL CheckLicenseKey
(
    LPWSTR pwszKey
)
{
        // Check for the unique license key (key2) or VB4 compatible key (Key1)
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// GetLicenseKey
//=--------------------------------------------------------------------------=
// returns our current license key that should be saved out, and then passed
// back to us in IClassFactory2::CreateInstanceLic
//
// Parameters:
//    none
//
// Output:
//    BSTR                 - key or NULL if Out of memory
//
// Notes:
//
BSTR GetLicenseKey
(
    void
)
{
    // Return our control unique license key
    //
    return SysAllocString(L"");
}

//=--------------------------------------------------------------------------=
// RegisterData
//=--------------------------------------------------------------------------=
// lets the inproc server writer register any data in addition to that in
// any other objects.
//
// Output:
//    BOOL            - false means failure.
//
// Notes:
//
BOOL RegisterData(void)
{
    long    l;
    HKEY    hKey = NULL;

    // We have to register our runtime CLSID, since it's different from the
    //   design-time CLSID.

    l = RegSetValue(HKEY_CLASSES_ROOT,
                    szInstanceInfo,
                    REG_SZ,
                    szRuntimeInstCLSID,
                    sizeof(szRuntimeInstCLSID));
    if (l != ERROR_SUCCESS)
      return FALSE;

    l = RegSetValue(HKEY_CLASSES_ROOT,
                    szMiscStatusRegKey,
                    REG_SZ,
                    szMiscStatusValue,
                    ::lstrlen(szMiscStatusValue));
    if (l != ERROR_SUCCESS)
      return FALSE;
    
    l = ::RegCreateKey(HKEY_CLASSES_ROOT, 
                        szPublicSetting, 
                        &hKey);

    if(l != ERROR_SUCCESS)
        return FALSE;

    l = ::RegSetValueEx(
                    hKey,
                    TEXT("Required"),
                    0,
                    REG_DWORD,
                    (BYTE*) &dwPublicFlag,
                    sizeof(DWORD)
                   );

    ::RegCloseKey(hKey);

    if (l != ERROR_SUCCESS)
      return FALSE;

    // TODO: register any additional data here that you might wish to.
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// UnregisterData
//=--------------------------------------------------------------------------=
// inproc server writers should unregister anything they registered in
// RegisterData() here.
//
// Output:
//    BOOL            - false means failure.
//
// Notes:
//
BOOL UnregisterData
(
    void
)
{
    // TODO: any additional registry cleanup that you might wish to do.
    //
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////////
// CATID Registration stuff
///////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------=
// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed. this is good.
//
// basically, the CRTs define this to suck in a bunch of stuff.  we'll just
// define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//
// extern "C" int __cdecl _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
  FAIL("Pure virtual function called.");
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\dtoolbar.cpp ===
//=--------------------------------------------------------------------------------------
// toolbar.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- Toolbar-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "snaputil.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddToolbar()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddToolbar()
{
    HRESULT              hr = S_OK;
    IMMCToolbars        *piMMCToolbars = NULL;
    VARIANT              vtEmpty;
    IMMCToolbar         *piMMCToolbar = NULL;

    hr = m_piSnapInDesignerDef->get_Toolbars(&piMMCToolbars);
    IfFailGo(hr);

    if (piMMCToolbars != NULL)
    {
        ::VariantInit(&vtEmpty);
        vtEmpty.vt = VT_ERROR;
        vtEmpty.scode = DISP_E_PARAMNOTFOUND;

        hr = piMMCToolbars->Add(vtEmpty, vtEmpty, &piMMCToolbar);
        IfFailGo(hr);
    }

Error:
    RELEASE(piMMCToolbar);
    RELEASE(piMMCToolbars);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddMMCToolbar(CSelectionHolder *pParent, IMMCToolbar *piMMCToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnAddMMCToolbar(CSelectionHolder *pParent, IMMCToolbar *piMMCToolbar)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pToolbar = NULL;

    ASSERT(NULL != pParent, "OnAddMMCToolbar: pParent is NULL");
    ASSERT(SEL_TOOLS_TOOLBARS == pParent->m_st, "OnAddMMCToolbar: pParent is not SEL_TOOLS_TOOLBARS");
    ASSERT(NULL != piMMCToolbar, "OnAddMMCToolbar: piMMCToolbar is NULL");

    hr = MakeNewToolbar(pParent->m_piObject.m_piMMCToolbars, piMMCToolbar, &pToolbar);
    IfFailGo(hr);

    hr = pToolbar->RegisterHolder();
    IfFailGo(hr);

    hr = m_pSnapInTypeInfo->AddToolbar(piMMCToolbar);
    IfFailGo(hr);

    hr = InsertToolbarInTree(pToolbar, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pToolbar);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pToolbar);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pToolbar);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameToolbar(CSelectionHolder *pToolbar, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameToolbar(CSelectionHolder *pToolbar, BSTR bstrNewName)
{
    HRESULT     hr = S_OK;
    BSTR        bstrOldName = NULL;
    TCHAR      *pszName = NULL;

    ASSERT(SEL_TOOLS_TOOLBARS_NAME == pToolbar->m_st, "RenameToolbar: wrong argument");

    // Check that the new name is valid
    IfFailGo(ValidateName(bstrNewName));
    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = m_pTreeView->GetLabel(pToolbar, &bstrOldName);
    IfFailGo(hr);

    hr = m_pSnapInTypeInfo->RenameToolbar(pToolbar->m_piObject.m_piMMCToolbar, bstrOldName);
    IfFailGo(hr);

    hr = pToolbar->m_piObject.m_piMMCToolbar->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->ChangeText(pToolbar, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);
    FREESTRING(bstrOldName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteToolbar(CSelectionHolder *pToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteToolbar(CSelectionHolder *pToolbar)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    BSTR                 bstrName = NULL;
    IMMCToolbars        *piMMCToolbars = NULL;
    VARIANT              vtKey;

    ::VariantInit(&vtKey);

    // Find out who the parent is
    hr = m_pTreeView->GetParent(pToolbar, &pParent);
    IfFailGo(hr);

    // Remove the ImageList from the appropriate collection
    ASSERT(SEL_TOOLS_TOOLBARS == pParent->m_st, "DeleteToolbar: expected another kind of parent");

    hr = pToolbar->m_piObject.m_piMMCToolbar->get_Name(&bstrName);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_Toolbars(&piMMCToolbars);
    IfFailGo(hr);

    if (piMMCToolbars != NULL)
    {
        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrName);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        hr = piMMCToolbars->Remove(vtKey);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtKey);
    FREESTRING(bstrName);
    RELEASE(piMMCToolbars);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteToolbar(CSelectionHolder *pToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteToolbar(CSelectionHolder *pToolbar)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    IMMCToolbars        *piMMCToolbars = NULL;
    long                 lCount = 0;

    // Delete the TypeInfo related property
    hr = m_pSnapInTypeInfo->DeleteToolbar(pToolbar->m_piObject.m_piMMCToolbar);
    IfFailGo(hr);

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pToolbar, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pToolbar);
    IfFailGo(hr);

    delete pToolbar;

    // Select the next selection
    hr = m_piSnapInDesignerDef->get_Toolbars(&piMMCToolbars);
    IfFailGo(hr);

    if (NULL != piMMCToolbars)
    {
        hr = piMMCToolbars->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piMMCToolbars);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowToolbarProperties(IMMCToolbar *piMMCToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowToolbarProperties
(
    IMMCToolbar *piMMCToolbar
)
{
    HRESULT         hr = S_OK;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[2];

    hr = GetResourceString(IDS_TOOLB_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = piMMCToolbar->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_MMCToolbarGeneralPP;
    pageClsID[1] = CLSID_MMCToolbarButtonsPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 2;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = 0;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewToolbar(IMMCToolbars *piMMCToolbars, IMMCToolbar *piMMCToolbar, CSelectionHolder **ppToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewToolbar
(
    IMMCToolbars      *piMMCToolbars,
    IMMCToolbar       *piMMCToolbar,
    CSelectionHolder **ppToolbar
)
{
    HRESULT              hr = S_OK;

    *ppToolbar = New CSelectionHolder(piMMCToolbar);
    if (*ppToolbar == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewToolbar(piMMCToolbars, piMMCToolbar);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewToolbar(IMMCToolbars *piMMCToolbars, IMMCToolbar *piMMCToolbar)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewToolbar
(
    IMMCToolbars *piMMCToolbars,
    IMMCToolbar *piMMCToolbar
)
{
    HRESULT           hr = S_OK;
    int               iResult = 0;
    int               iItemNumber = 1;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    bool              bGood = false;
    CSelectionHolder *pMMCToolbarClone = NULL;

    hr = GetResourceString(IDS_TOOLBAR, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    do {
        iResult = _stprintf(szName, _T("%s%d"), szBuffer, iItemNumber++);
        if (iResult == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK(hr);
        }

		hr = m_pTreeView->FindLabelInTree(szName, &pMMCToolbarClone);
		IfFailGo(hr);

        if (S_FALSE == hr)
        {
			hr = BSTRFromANSI(szName, &bstrName);
			IfFailGo(hr);

            bGood = true;
            break;
        }

        FREESTRING(bstrName);
    } while (false == bGood);

    hr = piMMCToolbar->put_Name(bstrName);
    IfFailGo(hr);

    hr = piMMCToolbar->put_Key(bstrName);
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertToolbarInTree(CSelectionHolder *pToolbar, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertToolbarInTree
(
    CSelectionHolder *pToolbar,
    CSelectionHolder *pParent
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    TCHAR  *pszName = NULL;

    hr = pToolbar->m_piObject.m_piMMCToolbar->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kToolbarIcon, pToolbar);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\dtypelib.cpp ===
//=--------------------------------------------------------------------------------------
// dtypelib.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Dynamic Type Library encapsulation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "dtypelib.h"
#include "snaputil.h"


// for ASSERT and FAIL
//
SZTHISFILE


HRESULT IsReservedMethod(BSTR bstrMethodName);


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CDynamicTypeLib()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CDynamicTypeLib::CDynamicTypeLib() : m_piCreateTypeLib2(0), m_piTypeLib(0), m_guidTypeLib(GUID_NULL)
{
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::~CDynamicTypeLib()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CDynamicTypeLib::~CDynamicTypeLib()
{
    RELEASE(m_piCreateTypeLib2);
    RELEASE(m_piTypeLib);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::Create()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::Create(BSTR bstrName)
{
	HRESULT  hr = S_OK;
    TCHAR    szTempFileName[MAX_PATH] = TEXT("");
    TCHAR    szTempPath[MAX_PATH] = TEXT("");
    WCHAR   *pwszTempFileName = NULL;
    DWORD    cchTempPath = 0;
    UINT     uiRet = 0;

    // get the temp path from the system
    cchTempPath = ::GetTempPath(sizeof(szTempPath), szTempPath);
    if (cchTempPath == 0 || cchTempPath >= sizeof(szTempPath))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK(hr);
    }

    // create the temporary file name
    ::EnterCriticalSection(&g_CriticalSection);
    uiRet = GetTempFileName(szTempPath,      // path - use current directory
                            TEXT("QQ"),      // prefix
                            0,               // system should generate the unique number
                            szTempFileName); // file name returned here
    ::LeaveCriticalSection(&g_CriticalSection);
    if (uiRet == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK(hr);
    }

    // allocate a buffer and convert to UNICODE
    hr = ::WideStrFromANSI(szTempFileName, &pwszTempFileName);
    IfFailGo(hr);

    hr = ::CreateTypeLib2(SYS_WIN32, pwszTempFileName, &m_piCreateTypeLib2);
    IfFailGo(hr);

	hr = ::CoCreateGuid(&m_guidTypeLib);
    IfFailGo(hr);

    hr = m_piCreateTypeLib2->SetGuid(m_guidTypeLib);
    IfFailGo(hr);

    hr = m_piCreateTypeLib2->SetVersion(wctlMajorVerNum, wctlMinorVerNum);
    IfFailGo(hr);

    if (NULL != bstrName)
    {
	    hr = m_piCreateTypeLib2->SetName(bstrName);
        IfFailGo(hr);
    }

	hr = m_piCreateTypeLib2->QueryInterface(IID_ITypeLib, (void **) &m_piTypeLib);
    IfFailGo(hr);

Error:
    if (NULL != pwszTempFileName)
        delete [] pwszTempFileName;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::Attach(ITypeInfo *ptiCoClass)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::Attach
(
	ITypeInfo *ptiCoClass
)
{
	HRESULT hr = S_OK;
	UINT    uiIndex = 0;

	RELEASE(m_piTypeLib);
	RELEASE(m_piCreateTypeLib2);

	hr = ptiCoClass->GetContainingTypeLib(&m_piTypeLib, &uiIndex);
	IfFailGo(hr);

	hr = m_piTypeLib->QueryInterface(IID_ICreateTypeLib2, reinterpret_cast<void **>(&m_piCreateTypeLib2));
	IfFailGo(hr);

Error:
	if (S_OK != hr)
	{
		RELEASE(m_piTypeLib);
		RELEASE(m_piCreateTypeLib2);
	}

    RRETURN(hr);
}


/////////////////////////////////////////////////////////////////////////////
//
// Obtaining information about type libraries
//
/////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::GetClassTypeLibGuid(BSTR bstrClsid, GUID *pguidTypeLib)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Given a CLSID, get the corresponding typelib's GUID. The function
// searches the registry attempting to match a typelib key to the CLSID.
//
HRESULT CDynamicTypeLib::GetClassTypeLibGuid
(
    BSTR  bstrClsid,
    GUID *pguidTypeLib
)
{
    HRESULT     hr = S_OK;
    char       *szClsid = NULL;
    long        lResult = 0;
    char       *lpSubKey = "CLSID";
    HKEY        hClsid = NULL;
    HKEY        hThisClsid = NULL;
    char       *lpTypeLib = "TypeLib";
    HKEY        hTypeLibKey = NULL;
    char       *pszNullValue = "\0\0";
    DWORD       cbType = REG_SZ;
    DWORD       cbSize = 512;
    char        buffer[512];
    BSTR        bstrTypeLibClsid = NULL;

    hr = ANSIFromBSTR(bstrClsid, &szClsid);
    IfFailGo(hr);

    lResult = ::RegOpenKeyEx(HKEY_CLASSES_ROOT, lpSubKey, 0, KEY_READ, &hClsid);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    lResult = ::RegOpenKeyEx(hClsid, szClsid, 0, KEY_READ, &hThisClsid);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    lResult = ::RegOpenKeyEx(hThisClsid, lpTypeLib, 0, KEY_READ, &hTypeLibKey);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK(hr);
    }

    lResult = ::RegQueryValueEx(hTypeLibKey, pszNullValue, NULL, &cbType, reinterpret_cast<unsigned char *>(buffer), &cbSize);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK(hr);
    }

    hr = BSTRFromANSI(buffer, &bstrTypeLibClsid);
    IfFailGo(hr);

    hr = ::CLSIDFromString(bstrTypeLibClsid, pguidTypeLib);
    IfFailGo(hr);

Error:
    FREESTRING(bstrTypeLibClsid);
    if (NULL != hTypeLibKey)
        ::RegCloseKey(hTypeLibKey);
    if (NULL != hThisClsid)
        ::RegCloseKey(hThisClsid);
    if (NULL != hClsid)
        ::RegCloseKey(hClsid);
    if (NULL != szClsid)
        CtlFree(szClsid);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::GetLatestTypeLibVersion(GUID guidTypeLib, int *piMajor, int *piMinor)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Given a TypeLib's GUID, get the major and minor numbers for the most current
// version.
//
HRESULT CDynamicTypeLib::GetLatestTypeLibVersion
(
    GUID    guidTypeLib,
    USHORT *pusMajor,
    USHORT *pusMinor
)
{
    HRESULT     hr = S_OK;
    int         iResult = 0;
    wchar_t     wcBuffer[512];
    char       *szClsid = NULL;
    long        lResult = 0;
    char       *lpSubKey = "TypeLib";
    HKEY        hTypeLibsKey = NULL;
    HKEY        hTypeLibKey = NULL;
    DWORD       dwIndex = 0;
    char        pszKeyName[512];
    DWORD       cbName = 512;
    FILETIME    ftLastWriteTime;
    USHORT      usMajor = 0;
    USHORT      usMinor = 0;

    ASSERT(GUID_NULL != guidTypeLib, "GetLatestTypeLibVersion: guidTypeLib is NULL");
    ASSERT(NULL != pusMajor, "GetLatestTypeLibVersion: pusMajor is NULL");
    ASSERT(NULL != pusMinor, "GetLatestTypeLibVersion: pusMinor is NULL");

    *pusMajor = 0;
    *pusMinor = 0;

    // First covert the GUID to a string representation
    iResult = ::StringFromGUID2(guidTypeLib, wcBuffer, 512);
    if (iResult <= 0)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK(hr);
    }

    hr = ANSIFromWideStr(wcBuffer, &szClsid);
    IfFailGo(hr);

    // Open HKEY_CLASSES_ROOT\TypeLib
    lResult = ::RegOpenKeyEx(HKEY_CLASSES_ROOT, lpSubKey, 0, KEY_READ, &hTypeLibsKey);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    // Open HKEY_CLASSES_ROOT\TypeLib\<TypeLibClsid>
    lResult = ::RegOpenKeyEx(hTypeLibsKey, szClsid, 0, KEY_ENUMERATE_SUB_KEYS, &hTypeLibKey);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    while (ERROR_NO_MORE_ITEMS != lResult)
    {
        lResult = ::RegEnumKeyEx(hTypeLibKey, dwIndex, pszKeyName, &cbName, NULL, NULL, NULL, &ftLastWriteTime);

        if (ERROR_NO_MORE_ITEMS != lResult)
        {
            ::sscanf(pszKeyName, "%hu.%hu", &usMajor, &usMinor);
            if (usMajor > *pusMajor)
            {
                *pusMajor = usMajor;
                *pusMinor = usMinor;
            }
            else if (usMinor > *pusMinor)
            {
                *pusMinor = usMinor;
            }
        }
        ++dwIndex;
    }

Error:
    if (NULL != szClsid)
        CtlFree(szClsid);
    if (NULL != hTypeLibKey)
        ::RegCloseKey(hTypeLibKey);
    if (NULL != hTypeLibsKey)
        ::RegCloseKey(hTypeLibsKey);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::GetClassTypeLib(BSTR bstrClsid, GUID *pguidTypeLib, int *piMajor, int *piMinor, ITypeLib **ptl)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Given a CLSID, get an ITypeLib pointer to its typelib, plus the typelib's
// GUID, major an minor version numbers.
//
HRESULT CDynamicTypeLib::GetClassTypeLib(BSTR bstrClsid, GUID *pguidTypeLib, USHORT *pusMajor, USHORT *pusMinor, ITypeLib **ptl)
{
    HRESULT hr = S_OK;

    hr = GetClassTypeLibGuid(bstrClsid, pguidTypeLib);
    IfFailGo(hr);

    hr = GetLatestTypeLibVersion(*pguidTypeLib, pusMajor, pusMinor);
    IfFailGo(hr);

    hr = ::LoadRegTypeLib(*pguidTypeLib,
                          *pusMajor,
                          *pusMinor,
                          LOCALE_SYSTEM_DEFAULT,
                          ptl);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


/////////////////////////////////////////////////////////////////////////////
//
// Managing coclasses and their interfaces
//
/////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CreateCoClassTypeInfo(BSTR bstrName, ICreateTypeInfo **ppCTInfo, GUID *guidTypeInfo)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Create a new coclass in the type library
//
HRESULT CDynamicTypeLib::CreateCoClassTypeInfo
(
    BSTR              bstrName,
    ICreateTypeInfo **ppCTInfo,
    GUID             *guidTypeInfo
)
{
    HRESULT		hr = S_OK;

    ASSERT(NULL != bstrName, "CreateCoClassTypeInfo: bstrName is NULL");
    ASSERT(::SysStringLen(bstrName) > 0, "CreateCoClassTypeInfo: bstrName is empty");
    ASSERT(ppCTInfo != NULL, "CreateCoClassTypeInfo: ppCTInfo is NULL");
    ASSERT(guidTypeInfo != NULL, "CreateCoClassTypeInfo: guidTypeInfo is NULL");

    hr = m_piCreateTypeLib2->CreateTypeInfo(bstrName,
                                            TKIND_COCLASS,
                                            ppCTInfo);
    IfFailGo(hr);

    if (GUID_NULL == *guidTypeInfo)
    {
        hr = ::CoCreateGuid(guidTypeInfo);
        IfFailGo(hr);
    }

    hr = (*ppCTInfo)->SetGuid(*guidTypeInfo);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CreateInterfaceTypeInfo(BSTR bstrName, ICreateTypeInfo **ppCTInfo, GUID *guidTypeInfo)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Create a new dispatch interface
//
HRESULT CDynamicTypeLib::CreateInterfaceTypeInfo
(
    BSTR              bstrName,
    ICreateTypeInfo **ppCTInfo,
    GUID             *guidTypeInfo
)
{
    HRESULT hr = S_OK;

    ASSERT(NULL != bstrName, "CreateInterfaceTypeInfo: bstrName is NULL");
    ASSERT(::SysStringLen(bstrName) > 0, "CreateInterfaceTypeInfo: bstrName is empty");
    ASSERT(ppCTInfo != NULL, "CreateInterfaceTypeInfo: ppCTInfo is NULL");
    ASSERT(guidTypeInfo != NULL, "CreateInterfaceTypeInfo: guidTypeInfo is NULL");

    hr = m_piCreateTypeLib2->CreateTypeInfo(bstrName,
                                            TKIND_DISPATCH,
                                            ppCTInfo);
    IfFailGo(hr);

    if (GUID_NULL == *guidTypeInfo)
    {
        hr = ::CoCreateGuid(guidTypeInfo);
        IfFailGo(hr);
    }

    hr = (*ppCTInfo)->SetGuid(*guidTypeInfo);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::SetBaseInterface(ICreateTypeInfo *pctiInterface, ITypeInfo *ptiBaseInterface)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Return the default interface for the class pointed by pSrcTypeInfo.
//
HRESULT CDynamicTypeLib::GetDefaultInterface
(
    ITypeInfo  *pSrcTypeInfo,
    ITypeInfo **pptiInterface
)
{
    HRESULT     hr = S_OK;
    TYPEATTR   *pta = NULL;
    int         i = 0;
    int         iTypeImplFlags = 0;
    HREFTYPE    hreftype;

    ASSERT(NULL != pSrcTypeInfo, "GetDefaultInterface: pSrcTypeInfo is NULL");
    ASSERT(NULL != pptiInterface, "GetDefaultInterface: pptiInterface is NULL");

    hr = pSrcTypeInfo->GetTypeAttr(&pta);
    IfFailGo(hr);

    for (i = 0; i < pta->cImplTypes; i++)
    {
        hr = pSrcTypeInfo->GetImplTypeFlags(i, &iTypeImplFlags);
        IfFailGo(hr);

        if (iTypeImplFlags == IMPLTYPEFLAG_FDEFAULT)
        {
            hr = pSrcTypeInfo->GetRefTypeOfImplType(i, &hreftype);
            IfFailGo(hr);

            hr = pSrcTypeInfo->GetRefTypeInfo(hreftype, pptiInterface);
            IfFailGo(hr);
        }
    }

Error:
    if (NULL != pta)
        pSrcTypeInfo->ReleaseTypeAttr(pta);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::GetSourceInterface(ITypeInfo *pSrcTypeInfo, ITypeInfo **pptiInterface)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Return the source (events) interface for the class pointed by pSrcTypeInfo.
//
HRESULT CDynamicTypeLib::GetSourceInterface
(
    ITypeInfo  *pSrcTypeInfo,
    ITypeInfo **pptiInterface
)
{
    HRESULT     hr = S_OK;
    TYPEATTR   *pta = NULL;
    int         i = 0;
    int         iTypeImplFlags = 0;
    HREFTYPE    hreftype;

    ASSERT(NULL != pSrcTypeInfo, "GetSourceInterface: pSrcTypeInfo is NULL");
    ASSERT(NULL != pptiInterface, "GetSourceInterface: pptiInterface is NULL");

    hr = pSrcTypeInfo->GetTypeAttr(&pta);
    IfFailGo(hr);

    for (i = 0; i < pta->cImplTypes; i++)
    {
        hr = pSrcTypeInfo->GetImplTypeFlags(i, &iTypeImplFlags);
        IfFailGo(hr);

        if (iTypeImplFlags == (IMPLTYPEFLAG_FSOURCE | IMPLTYPEFLAG_FDEFAULT))
        {
            hr = pSrcTypeInfo->GetRefTypeOfImplType(i, &hreftype);
            IfFailGo(hr);

            hr = pSrcTypeInfo->GetRefTypeInfo(hreftype, pptiInterface);
            IfFailGo(hr);
        }
    }

Error:
    if (NULL != pta)
        pSrcTypeInfo->ReleaseTypeAttr(pta);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::SetBaseInterface(ICreateTypeInfo *pctiInterface, ITypeInfo *ptiBaseInterface)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::SetBaseInterface
(
	ICreateTypeInfo *pctiInterface,
	ITypeInfo       *ptiBaseInterface
)
{
    HRESULT  hr = S_OK;
    HREFTYPE hreftype = NULL;

    hr = pctiInterface->AddRefTypeInfo(ptiBaseInterface, &hreftype);
    IfFailGo(hr);

    hr = pctiInterface->AddImplType(0, hreftype);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::AddInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiInterface)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Add the interface pointed by ptiInterface as the default interface to the
// class pointed by pctiCoClass.
//
HRESULT CDynamicTypeLib::AddInterface
(
    ICreateTypeInfo *pctiCoClass,
    ITypeInfo       *ptiInterface
)
{
    HRESULT     hr = S_OK;
    HREFTYPE    hreftype;

    ASSERT(NULL != pctiCoClass, "AddInterface: pctiCoClass is NULL");
    ASSERT(NULL != ptiInterface, "AddInterface: ptiInterface is NULL");

    hr = pctiCoClass->AddRefTypeInfo(ptiInterface, &hreftype);
    IfFailGo(hr);

    hr = pctiCoClass->AddImplType(0, hreftype);
    IfFailGo(hr);

    hr = pctiCoClass->SetImplTypeFlags(0, IMPLTYPEFLAG_FDEFAULT);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::AddEvents(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiEvents)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Add the interface pointed by ptiInterface as the default source (events)
// interface to the class pointed by pctiCoClass.
//
HRESULT CDynamicTypeLib::AddEvents
(
    ICreateTypeInfo *pctiCoClass, 
    ITypeInfo       *ptiEvents
)
{
    HRESULT     hr = S_OK;
    HREFTYPE    hreftype;

    ASSERT(NULL != pctiCoClass, "AddEvents: pctiCoClass is NULL");
    ASSERT(NULL != ptiEvents, "AddEvents: ptiEvents is NULL");

    hr = pctiCoClass->AddRefTypeInfo(ptiEvents, &hreftype);
    IfFailGo(hr);

    hr = pctiCoClass->AddImplType(1, hreftype);
    IfFailGo(hr);

    hr = pctiCoClass->SetImplTypeFlags(1, IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::AddUserPropertyGet(ICreateTypeInfo *pctiDispinterface, BSTR bstrName, ITypeInfo *pReturnType, DISPID dispId, long nIndex)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Add a new property with a user-defined return type to an interface of the form:
//
//  HRESULT get_<bstrName>(<pReturnType> ** <bstrName>)
//
HRESULT CDynamicTypeLib::AddUserPropertyGet
(
    ICreateTypeInfo *pctiInterface,
    BSTR             bstrName,
    ITypeInfo       *pReturnType,
    DISPID           dispId,
    long             nIndex
)
{
    HRESULT     hr = S_OK;
    VARIANT     vt;
    PARAMDESCEX pd;
	HREFTYPE	href = NULL;;
    ELEMDESC    ed;
    FUNCDESC    fd;         // new item is a funcdesc
    TYPEDESC    td;

    ASSERT(NULL != pctiInterface, "AddUserPropertyGet: pctiInterface is NULL");
    ASSERT(NULL != bstrName, "AddUserPropertyGet: bstrName is NULL");
    ASSERT(::SysStringLen(bstrName) > 0, "AddUserPropertyGet: bstrName is empty");
    ASSERT(NULL != pReturnType, "AddUserPropertyGet: pReturnType is NULL");

    ::VariantInit(&vt);
    ::memset(&pd, 0, sizeof(PARAMDESCEX));
    ::memset(&ed, 0, sizeof(ELEMDESC));
    ::memset(&fd, 0, sizeof(FUNCDESC));
    ::memset(&td, 0, sizeof(TYPEDESC));

    // Describe the property being returned by this funcion
//    pd.cBytes = 4;
//    pd.varDefaultValue = vt;

	hr = pctiInterface->AddRefTypeInfo(pReturnType, &href);
    IfFailGo(hr);

//    ed.tdesc.hreftype = href;
//    ed.tdesc.vt = VT_USERDEFINED;

//    ed.paramdesc.pparamdescex = &pd;
//    ed.paramdesc.wParamFlags = IDLFLAG_FOUT | IDLFLAG_FRETVAL;

    // Set up the funcdesc
    fd.memid = dispId;                      // Function member ID
    fd.lprgelemdescParam = NULL;            // Parameter information
    fd.funckind = FUNC_DISPATCH;            // Kind of function
    fd.invkind = INVOKE_PROPERTYGET;        // Type of invocation
    fd.callconv = CC_STDCALL;               // Calling convention
	fd.wFuncFlags = FUNCFLAG_FSOURCE;

    // Set up the return value
	td.vt = VT_USERDEFINED;
	td.hreftype = href;
	fd.elemdescFunc.tdesc.lptdesc = &td;
	fd.elemdescFunc.tdesc.vt = VT_PTR;
	fd.elemdescFunc.idldesc.wIDLFlags = IDLFLAG_FOUT | IDLFLAG_FRETVAL;

    // Parameter information
    fd.cParams = 0;                         // Number of parameters
    fd.cParamsOpt = 0;                      // Number of optional parameters

    // Add the function description
    hr = pctiInterface->AddFuncDesc(nIndex, &fd);
    IfFailGo(hr);

    // The &bstrName should really be an array of OLESTR, but since we are setting only
    // one name, we cheat to makes this simpler
    hr =  pctiInterface->SetFuncAndParamNames(nIndex, &bstrName, 1);
    IfFailGo(hr);

    hr = pctiInterface->LayOut();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::GetNameIndex(ICreateTypeInfo *pctiDispinterface, BSTR bstrName, long *nIndex)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Return the memid of the function named bstrName in the typeinfo pointed by pcti.
//
HRESULT CDynamicTypeLib::GetNameIndex(ICreateTypeInfo *pctiDispinterface, BSTR bstrName, long *nIndex)
{
    HRESULT     hr = S_OK;
    ITypeInfo2 *pTypeInfo = NULL;
    TYPEATTR   *pTypeAttr = NULL;
    long        x;
    FUNCDESC   *pFuncDesc = NULL;
    BSTR        bstrFuncName = NULL;
    UINT        cNames = 0;

    ASSERT(NULL != pctiDispinterface, "GetNameIndex: pctiDispinterface is NULL");
    ASSERT(NULL != bstrName, "GetNameIndex: bstrName is NULL");
    ASSERT(::SysStringLen(bstrName) > 0, "GetNameIndex: bstrName is Empty");
    ASSERT(NULL != nIndex, "GetNameIndex: nIndex is NULL");

    *nIndex = -1;

    hr = pctiDispinterface->QueryInterface(IID_ITypeInfo2, (void **) &pTypeInfo);
    IfFailGo(hr);

    hr = pTypeInfo->GetTypeAttr(&pTypeAttr);
    IfFailGo(hr);

    for (x = 0; x < pTypeAttr->cFuncs; x++)
    {
        hr = pTypeInfo->GetFuncDesc(x, &pFuncDesc);
        IfFailGo(hr);

        hr = pTypeInfo->GetNames(pFuncDesc->memid, &bstrFuncName, 1, &cNames);
        IfFailGo(hr);

        if (::_wcsicmp(bstrName, bstrFuncName) == 0)
        {
            *nIndex = x;
            break;
        }

        // Clean up memory after each iteration
        if (NULL != pFuncDesc)
        {
            pTypeInfo->ReleaseFuncDesc(pFuncDesc);
            pFuncDesc = NULL;
        }

        FREESTRING(bstrFuncName);
        bstrFuncName = NULL;
    }

Error:
    FREESTRING(bstrFuncName);
    if (NULL != pFuncDesc)
        pTypeInfo->ReleaseFuncDesc(pFuncDesc);
    if (NULL != pTypeAttr)
        pTypeInfo->ReleaseTypeAttr(pTypeAttr);
    RELEASE(pTypeInfo);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::RenameUserPropertyGet(ICreateTypeInfo *pctiDispinterface, BSTR bstrOldName, BSTR bstrNewName, GUID guidReturnType)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::RenameUserPropertyGet
(
    ICreateTypeInfo *pctiDispinterface,
    BSTR             bstrOldName,
    BSTR             bstrNewName,
    ITypeInfo       *pReturnType
)
{
    HRESULT             hr = S_OK;
    long                lIndex = 0;
    ICreateTypeInfo2   *pCreateTypeInfo2 = NULL;
    FUNCDESC           *pfuncdesc = NULL;           
    ITypeInfo          *pti = NULL;

    ASSERT(NULL != pctiDispinterface, "RenameUserPropertyGet: pctiDispinterface is NULL");
    ASSERT(NULL != bstrOldName, "RenameUserPropertyGet: bstrOldName is NULL");
    ASSERT(::SysStringLen(bstrOldName) > 0, "RenameUserPropertyGet: bstrOldName is Empty");
    ASSERT(NULL != bstrNewName, "RenameUserPropertyGet: bstrNewName is NULL");
    ASSERT(::SysStringLen(bstrNewName) > 0, "RenameUserPropertyGet: bstrNewName is Empty");
    ASSERT(NULL != pReturnType, "RenameUserPropertyGet: pReturnType is NULL");

    hr = GetNameIndex(pctiDispinterface, bstrOldName, &lIndex);
    IfFailGo(hr);

    if (-1 != lIndex)
    {
        hr = pctiDispinterface->QueryInterface(IID_ITypeInfo, reinterpret_cast<void **>(&pti));
        IfFailGo(hr);

        // Get the funcdesc so we can reuse the memid
        hr = pti->GetFuncDesc(lIndex, &pfuncdesc);
        IfFailGo(hr);

        hr = pctiDispinterface->QueryInterface(IID_ICreateTypeInfo2, reinterpret_cast<void **>(&pCreateTypeInfo2));
        IfFailGo(hr);

        // Remove the function from the interface
        hr = pCreateTypeInfo2->DeleteFuncDesc(lIndex);
        IfFailGo(hr);

        // Re-add the function to the interface
        hr = AddUserPropertyGet(pctiDispinterface,
                                bstrNewName,
                                pReturnType,
                                pfuncdesc->memid,
                                lIndex);
        IfFailGo(hr);
    }

Error:
    QUICK_RELEASE(pCreateTypeInfo2);
    if (NULL != pti)
    {
        if (NULL != pfuncdesc)
            pti->ReleaseFuncDesc(pfuncdesc);
    }
    QUICK_RELEASE(pti);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::DeleteUserPropertyGet(ICreateTypeInfo *pctiDispinterface, BSTR bstrName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::DeleteUserPropertyGet
(
    ICreateTypeInfo *pctiDispinterface,
    BSTR             bstrName
)
{
    HRESULT             hr = S_OK;
    long                lIndex = 0;
    ICreateTypeInfo2   *pCreateTypeInfo2 = NULL;
    ITypeInfo          *pReturnType = NULL;

    ASSERT(NULL != pctiDispinterface, "DeleteUserPropertyGet: pctiDispinterface is NULL");
    ASSERT(NULL != bstrName, "DeleteUserPropertyGet: bstrName is NULL");
    ASSERT(::SysStringLen(bstrName) > 0, "DeleteUserPropertyGet: bstrName is Empty");

    hr = GetNameIndex(pctiDispinterface, bstrName, &lIndex);
    IfFailGo(hr);

    if (-1 != lIndex)
    {
	    hr = pctiDispinterface->QueryInterface(IID_ICreateTypeInfo2, (void **) &pCreateTypeInfo2);
        IfFailGo(hr);

	    hr = pCreateTypeInfo2->DeleteFuncDesc(lIndex);
        IfFailGo(hr);
    }

Error:
    QUICK_RELEASE(pReturnType);
    QUICK_RELEASE(pCreateTypeInfo2);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::GetIDispatchTypeInfo(ITypeInfo **pptiDispatch)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::GetIDispatchTypeInfo(ITypeInfo **pptiDispatch)
{
    HRESULT     hr = S_OK;
    ITypeLib   *pTypeLib = NULL;

    hr = ::LoadRegTypeLib(IID_StdOle, STDOLE2_MAJORVERNUM, STDOLE2_MINORVERNUM, STDOLE2_LCID, &pTypeLib);
    IfFailGo(hr);

    hr = pTypeLib->GetTypeInfoOfGuid(IID_IDispatch, pptiDispatch);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(pTypeLib);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CopyDispInterface(ICreateTypeInfo *pcti, ITypeInfo *ptiTemplate)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::CopyDispInterface
(
    ICreateTypeInfo *pcti,
    ITypeInfo       *ptiTemplate
)
{
    HRESULT         hr = S_OK;
    ITypeInfo      *ptiDispatch = NULL;
    HREFTYPE        hreftype;

    ASSERT(NULL != pcti, "CopyDispInterface: pcti is NULL");
    ASSERT(NULL != ptiTemplate, "CopyDispInterface: ptiTemplate is NULL");

    hr = GetIDispatchTypeInfo(&ptiDispatch);
    IfFailGo(hr);

    hr = pcti->AddRefTypeInfo(ptiDispatch, &hreftype);
    IfFailGo(hr);

    hr = pcti->AddImplType(0, hreftype);
    IfFailGo(hr);

    // Make the new interface inherit from our static interface [via cloning]
    hr = CloneInterface(ptiTemplate, pcti);
    IfFailGo(hr);

Error:
	QUICK_RELEASE(ptiDispatch);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CloneInterface(ITypeInfo *piTypeInfo, ICreateTypeInfo *piCreateTypeInfo)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Given a dispinterface typeinfo, copy it into a new one
//
// Parameters:
//    ITypeInfo *           - [in]  dude to copy
//    ICreateTypeInfo *     - [in]  guy to copy to.  should be blank
//
// Output:
//    HRESULT
//
// Notes:
//    - yes, this routine should be a little broader and go create the dest
//      typeinfo and guids itself, but this is a little more straightforward
//
HRESULT CDynamicTypeLib::CloneInterface
(
    ITypeInfo       *piTypeInfo,
    ICreateTypeInfo *piCreateTypeInfo
)
{
    HRESULT             hr = S_OK;
    ITypeInfo2         *piTypeInfo2 = NULL;
    ICreateTypeInfo2   *piCreateTypeInfo2 = NULL;
    TYPEATTR           *pTypeAttr = NULL;
    USHORT              x = 0;
    USHORT              offset = 0;

    ASSERT(NULL != piTypeInfo, "CloneInterface: piTypeInfo is NULL");
    ASSERT(NULL != piCreateTypeInfo, "CloneInterface: piCreateTypeInfo is NULL");

    hr = piTypeInfo->QueryInterface(IID_ITypeInfo2, reinterpret_cast<void **>(&piTypeInfo2));
    IfFailGo(hr);

    hr = piCreateTypeInfo->QueryInterface(IID_ICreateTypeInfo2, reinterpret_cast<void **>(&piCreateTypeInfo2));
    IfFailGo(hr);

    // get some information about the interface we're going to copy:
    hr = piTypeInfo2->GetTypeAttr(&pTypeAttr);
    IfFailGo(hr);

    offset = 0;

    // iterate through the funcdescs and copy them over
    for (x = 0; x < pTypeAttr->cFuncs; x++)
    {
        hr = CopyFunctionDescription(piTypeInfo2, piCreateTypeInfo2, x, &offset);
        IfFailGo(hr);
    }

    // okay, now copy over the vardescs
    //
    for (x = 0; x < pTypeAttr->cVars; x++)
    {
        hr = CopyVarDescription(piTypeInfo2, piCreateTypeInfo2, x);
        IfFailGo(hr);
    }

Error:
    if (NULL != pTypeAttr)
        piTypeInfo2->ReleaseTypeAttr(pTypeAttr);
    RELEASE(piTypeInfo2);
    RELEASE(piCreateTypeInfo2);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CreateVtblInterfaceTypeInfo(BSTR bstrName, ICreateTypeInfo **ppCTInfo, GUID *guidTypeInfo)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::CreateVtblInterfaceTypeInfo
(
    BSTR              bstrName,
    ICreateTypeInfo **ppCTInfo,
    GUID             *guidTypeInfo
)
{
	HRESULT		hr = S_OK;

    ASSERT(NULL != bstrName,             "CreateVtblInterfaceTypeInfo: bstrName is NULL");
    ASSERT(::SysStringLen(bstrName) > 0, "CreateVtblInterfaceTypeInfo: bstrName is empty");
    ASSERT(ppCTInfo != NULL,             "CreateVtblInterfaceTypeInfo: ppCTInfo is NULL");
    ASSERT(guidTypeInfo != NULL,         "CreateVtblInterfaceTypeInfo: guidTypeInfo is NULL");

    hr = m_piCreateTypeLib2->CreateTypeInfo(bstrName, TKIND_INTERFACE, ppCTInfo);
    IfFailGo(hr);

    if (GUID_NULL == *guidTypeInfo)
    {
        hr = ::CoCreateGuid(guidTypeInfo);
        IfFailGo(hr);
    }

    hr = (*ppCTInfo)->SetGuid(*guidTypeInfo);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CopyFunctionDescription(ITypeInfo2 *piTypeInfo2, ICreateTypeInfo2 *piCreateTypeInfo2, USHORT uOffset, USHORT *puRealOffset)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::CopyFunctionDescription
(
    ITypeInfo2       *piTypeInfo2,
    ICreateTypeInfo2 *piCreateTypeInfo2,
    USHORT            uOffset,
    USHORT           *puRealOffset
)
{
    HRESULT     hr = S_OK;
    FUNCDESC   *pFuncDesc = NULL;
    MEMBERID    memid = 0;
    BSTR        rgNames[16] = {NULL};
    UINT        cNames = 0;
    BSTR        bstrDocString = NULL;
    DWORD       ulStringContext = 0;
    USHORT      y;

    ASSERT(NULL != piTypeInfo2, "CopyFunctionDescription: piTypeInfo2 is NULL");
    ASSERT(NULL != piCreateTypeInfo2, "CopyFunctionDescription: piCreateTypeInfo2 is NULL");
    ASSERT(NULL != puRealOffset, "CopyFunctionDescription: puRealOffset is NULL");

    // Get the fundesc
    hr = piTypeInfo2->GetFuncDesc(uOffset, &pFuncDesc);
    IfFailGo(hr);

    memid = pFuncDesc->memid;

    ::memset(rgNames, 0, sizeof(rgNames));
    hr = piTypeInfo2->GetNames(memid, rgNames, 16, &cNames);
    IfFailGo(hr);

    hr = IsReservedMethod(rgNames[0]);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        // copy the fundesc
        hr = FixHrefTypeFuncDesc(piTypeInfo2, piCreateTypeInfo2, pFuncDesc);
        IfFailGo(hr);

        hr = piCreateTypeInfo2->AddFuncDesc(*puRealOffset, pFuncDesc);
        IfFailGo(hr);

        // then copy the names for it.
        hr = piCreateTypeInfo2->SetFuncAndParamNames(*puRealOffset, rgNames, cNames);
        IfFailGo(hr);

        // now copy over the helpstring information
        hr = piTypeInfo2->GetDocumentation2(memid, LOCALE_SYSTEM_DEFAULT, &bstrDocString, &ulStringContext, NULL);
        IfFailGo(hr);

        if (NULL != bstrDocString)
        {
            hr = piCreateTypeInfo2->SetFuncDocString(*puRealOffset, bstrDocString);
            IfFailGo(hr);

            hr = piCreateTypeInfo2->SetFuncHelpStringContext(*puRealOffset, ulStringContext);
            IfFailGo(hr);
        }

        (*puRealOffset)++;
    }

Error:
    if (NULL != pFuncDesc)
        piTypeInfo2->ReleaseFuncDesc(pFuncDesc);

    FREESTRING(bstrDocString);
    for (y = 0; y < sizeof(rgNames) / sizeof(BSTR); y++)
        FREESTRING(rgNames[y]);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CopyVarDescription(ITypeInfo2 *piTypeInfo2, ICreateTypeInfo2 *piCreateTypeInfo2, USHORT uOffset)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CDynamicTypeLib::CopyVarDescription
(
    ITypeInfo2       *piTypeInfo2,
    ICreateTypeInfo2 *piCreateTypeInfo2,
    USHORT            uOffset
)
{
    HRESULT     hr = S_OK;
    VARDESC    *pVarDesc = NULL;
    BSTR        rgNames[16] = {NULL};
    UINT        cNames = 0;
    BSTR        bstrDocString = NULL;
    DWORD       ulStringContext = 0;

    ASSERT(NULL != piTypeInfo2, "CopyVarDescription: piTypeInfo2 is NULL");
    ASSERT(NULL != piCreateTypeInfo2, "CopyVarDescription: piCreateTypeInfo2 is NULL");

    hr = piTypeInfo2->GetVarDesc(uOffset, &pVarDesc);
    IfFailGo(hr);

    hr = FixHrefTypeVarDesc(piTypeInfo2, piCreateTypeInfo2, pVarDesc);
    IfFailGo(hr);

    hr = piCreateTypeInfo2->AddVarDesc(uOffset, pVarDesc);
    IfFailGo(hr);

    // copy the name
    rgNames[0] = NULL;
    hr = piTypeInfo2->GetNames(pVarDesc->memid, rgNames, 1, &cNames);
    IfFailGo(hr);

    hr = piCreateTypeInfo2->SetVarName(uOffset, rgNames[0]);
    IfFailGo(hr);

    // now copy over the documentation
    hr = piTypeInfo2->GetDocumentation2(pVarDesc->memid, LOCALE_SYSTEM_DEFAULT, &bstrDocString, &ulStringContext, NULL);
    IfFailGo(hr);

    hr = piCreateTypeInfo2->SetVarDocString(uOffset, bstrDocString);
    IfFailGo(hr);

    hr = piCreateTypeInfo2->SetVarHelpStringContext(uOffset, ulStringContext);
    IfFailGo(hr);

Error:
    if (NULL != pVarDesc)
        piTypeInfo2->ReleaseVarDesc(pVarDesc);
    FREESTRING(rgNames[0]);
    FREESTRING(bstrDocString);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::FixHrefTypeFuncDesc(ITypeInfo *piTypeInfo, ICreateTypeInfo *piCreateTypeInfo, FUNCDESC *pFuncDesc)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// okay, this is pretty ridiculous.  OLE automation apparantly isn't very
// bright and when we're copying over a funcdesc that has an HREFTYPE in it,
// it can't resolve it.  thus, we have to go and set up the HREFTYPE
// ourselves to make things work.
//
// this is just stupid.
//
// Parameters:
//    ITypeInfo *               - [in]  dude we're copying from
//    ICreateTypeInfo *         - [in]  dude we're copying to
//    FUNCDESC *                - [in]  funcdesc we wanna copy.
//
HRESULT CDynamicTypeLib::FixHrefTypeFuncDesc
(
    ITypeInfo       *piTypeInfo,
    ICreateTypeInfo *piCreateTypeInfo,
    FUNCDESC        *pFuncDesc
)
{
    HRESULT     hr = S_OK;
    ITypeInfo  *pti = NULL;
    TYPEDESC   *ptd = NULL;
    short       x = 0;

    ASSERT(NULL != piTypeInfo, "FixHrefTypeFuncDesc: piTypeInfo is NULL");
    ASSERT(NULL != piCreateTypeInfo, "FixHrefTypeFuncDesc: piCreateTypeInfo is NULL");
    ASSERT(NULL != pFuncDesc, "FixHrefTypeFuncDesc: pFuncDesc is NULL");

    // we have to work with ITypeInfo, not ICreateTypeInfo
    hr = piCreateTypeInfo->QueryInterface(IID_ITypeInfo, reinterpret_cast<void **>(&pti));
    IfFailGo(hr);

    // Now look through the funcdesc to see if there a userdefined
    // type anywhere. First, try the return value.
    ptd = &(pFuncDesc->elemdescFunc.tdesc);
    while (VT_PTR == ptd->vt)
        ptd = ptd->lptdesc;

    // If it's a userdefined type, copy over the hreftype
    if (VT_USERDEFINED == ptd->vt)
    {
        hr = CopyHrefType(piTypeInfo, pti, piCreateTypeInfo, &(ptd->hreftype));
        IfFailGo(hr);
    }

    // Now whip through the parameters:
    for (x = 0; x < pFuncDesc->cParams; x++)
    {
        ptd = &(pFuncDesc->lprgelemdescParam[x].tdesc);
        while (VT_PTR == ptd->vt)
            ptd = ptd->lptdesc;

        // If it's a userdefined type, copy over the hreftype
        if (VT_USERDEFINED == ptd->vt)
        {
            hr = CopyHrefType(piTypeInfo, pti, piCreateTypeInfo, &(ptd->hreftype));
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(pti);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::FixHrefTypeVarDesc(ITypeInfo *piTypeInfo, ICreateTypeInfo *piCreateTypeInfo, VARDESC *pVarDesc)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// check out the comment for FixHrefTypeFuncDesc.  this sucks.
//
// Parameters:
//    ITypeInfo *               - [in]
//    ICreateTypeInfo *         - [in]
//    VARDESC *                 - [in]
//
HRESULT CDynamicTypeLib::FixHrefTypeVarDesc
(
    ITypeInfo       *piTypeInfo,
    ICreateTypeInfo *piCreateTypeInfo,
    VARDESC         *pVarDesc
)
{
    HRESULT     hr = S_OK;
    ITypeInfo  *pti = NULL;
    TYPEDESC   *ptd = NULL;

    ASSERT(NULL != piTypeInfo, "FixHrefTypeVarDesc: piTypeInfo is NULL");
    ASSERT(NULL != piCreateTypeInfo, "FixHrefTypeVarDesc: piCreateTypeInfo is NULL");
    ASSERT(NULL != pVarDesc, "FixHrefTypeVarDesc: pVarDesc is NULL");

    // We have to work with ITypeInfo, not ICreateTypeInfo
    hr = piCreateTypeInfo->QueryInterface(IID_ITypeInfo, reinterpret_cast<void **>(&pti));
    IfFailGo(hr);

    // Look in the vardesc for VT_USERDEFINED
    ptd = &(pVarDesc->elemdescVar.tdesc);
    while (VT_PTR == ptd->vt)
        ptd = ptd->lptdesc;

    if (VT_USERDEFINED == ptd->vt)
    {
        hr = CopyHrefType(piTypeInfo, pti, piCreateTypeInfo, &(ptd->hreftype));
        IfFailGo(hr);
    }

Error:
    RELEASE(pti);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::CopyHrefType(ITypeInfo *ptiSource, ITypeInfo *ptiDest, ICreateTypeInfo *pctiDest, HREFTYPE *phreftype)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// more of the joy that is ole automation.
//
// Parameters:
//    ITypeInfo *           - [in]     source ti
//    ITypeInfo *           - [in]     dest ti
//    ICreateTypeInfo *     - [in]     dest ti
//    HREFTYPE *            - [in/out] hreftype from old typeinfo
//
HRESULT CDynamicTypeLib::CopyHrefType
(
    ITypeInfo       *ptiSource,
    ITypeInfo       *ptiDest,
    ICreateTypeInfo *pctiDest,
    HREFTYPE        *phreftype
)
{
    HRESULT     hr = S_OK;
    ITypeInfo  *ptiRef = NULL;

    ASSERT(NULL != ptiSource, "CopyHrefType: ptiSource is NULL");
    ASSERT(NULL != ptiDest, "CopyHrefType: ptiDest is NULL");
    ASSERT(NULL != pctiDest, "CopyHrefType: pctiDest is NULL");
    ASSERT(NULL != phreftype, "CopyHrefType: phreftype is NULL");

    hr = ptiSource->GetRefTypeInfo(*phreftype, &ptiRef);
    IfFailGo(hr);

    hr = pctiDest->AddRefTypeInfo(ptiRef, phreftype);
    IfFailGo(hr);

Error:
    RELEASE(ptiRef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CDynamicTypeLib::IsReservedMethod(BSTR bstrMethodName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Return true if bstrMethodName belongs to either IUnknown's or IDispatch's
// name space.
//
static char	*g_reserved[] = {
	"QueryInterface",
	"AddRef",
	"Release",
	"GetIDsOfNames",
	"GetTypeInfo",
	"GetTypeInfoCount",
	"Invoke",
	"RemoteInvoke",
	NULL
};


HRESULT CDynamicTypeLib::IsReservedMethod
(
    BSTR bstrMethodName
)
{
    HRESULT  hr = S_OK;
    char    *pszMethodName = NULL;
    int      index = 0;

    hr = ANSIFromBSTR(bstrMethodName, &pszMethodName);
    IfFailGo(hr);

    hr = S_FALSE;

    for (index = 0; g_reserved[index] != NULL; ++index)
    {
        if (0 == ::strcmp(g_reserved[index], pszMethodName))
        {
            hr = S_OK;
            break;
        }
    }

Error:
    if (NULL != pszMethodName)
        CtlFree(pszMethodName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\dtypelib.h ===
//=--------------------------------------------------------------------------------------
// dtypelib.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Dynamic Type Library encapsulation
//=-------------------------------------------------------------------------------------=

#ifndef _DYNAMIC_TYPE_LIB_
#define _DYNAMIC_TYPE_LIB_



const USHORT	wctlMajorVerNum		= 1;
const USHORT	wctlMinorVerNum		= 0;


class CDynamicTypeLib : public CtlNewDelete, public CError
{
public:
    CDynamicTypeLib();
    virtual ~CDynamicTypeLib();

public:
    HRESULT Create(BSTR bstrName);
	HRESULT Attach(ITypeInfo *ptiCoClass);

protected:
	// Obtaining information about type libraries
	HRESULT GetClassTypeLibGuid(BSTR bstrClsid, GUID *pguidTypeLib);
	HRESULT GetLatestTypeLibVersion(GUID guidTypeLib, USHORT *pusMajor, USHORT *pusMinor);
	HRESULT GetClassTypeLib(BSTR bstrClsid, GUID *pguidTypeLib, USHORT *pusMajor, USHORT *pusMinor, ITypeLib **ptl);

	// Managing coclasses and their interfaces
	HRESULT CreateCoClassTypeInfo(BSTR bstrName, ICreateTypeInfo **ppCTInfo, GUID *guidTypeInfo);
	HRESULT CreateInterfaceTypeInfo(BSTR bstrName, ICreateTypeInfo **ppCTInfo, GUID *guidTypeInfo);
	HRESULT CreateVtblInterfaceTypeInfo(BSTR bstrName, ICreateTypeInfo **ppCTInfo, GUID *guidTypeInfo);

	HRESULT GetDefaultInterface(ITypeInfo *pSrcTypeInfo, ITypeInfo **pptiInterface);
	HRESULT GetSourceInterface(ITypeInfo *pSrcTypeInfo, ITypeInfo **pptiInterface);
	HRESULT SetBaseInterface(ICreateTypeInfo* pctiInterface, ITypeInfo* ptiBaseInterface);

	// Assigning interfaces to coclasses
	HRESULT AddInterface(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiInterface);
	HRESULT AddEvents(ICreateTypeInfo *pctiCoClass, ITypeInfo *ptiEvents);

    HRESULT GetNameIndex(ICreateTypeInfo *pctiDispinterface, BSTR bstrName, long *nIndex);

    HRESULT AddUserPropertyGet(ICreateTypeInfo *pctiDispinterface, BSTR bstrName, ITypeInfo *pReturnType, DISPID dispId, long nIndex);
    HRESULT RenameUserPropertyGet(ICreateTypeInfo *pctiDispinterface, BSTR bstrOldName, BSTR bstrNewName, ITypeInfo *pReturnType);
    HRESULT DeleteUserPropertyGet(ICreateTypeInfo *pctiDispinterface, BSTR bstrName);

    // Copying interfaces
    HRESULT GetIDispatchTypeInfo(ITypeInfo **pptiDispatch);
    HRESULT CopyDispInterface(ICreateTypeInfo *pcti, ITypeInfo *ptiTemplate);
    HRESULT CloneInterface(ITypeInfo *piTypeInfo, ICreateTypeInfo *piCreateTypeInfo);
    HRESULT CopyFunctionDescription(ITypeInfo2 *piTypeInfo2, ICreateTypeInfo2 *piCreateTypeInfo2, USHORT uOffset, USHORT *puRealOffset);
    HRESULT CopyVarDescription(ITypeInfo2 *piTypeInfo2, ICreateTypeInfo2 *piCreateTypeInfo2, USHORT uOffset);
    HRESULT FixHrefTypeFuncDesc(ITypeInfo *piTypeInfo, ICreateTypeInfo *piCreateTypeInfo, FUNCDESC *pFuncDesc);
    HRESULT FixHrefTypeVarDesc(ITypeInfo *piTypeInfo, ICreateTypeInfo *piCreateTypeInfo, VARDESC *pVarDesc);
    HRESULT CopyHrefType(ITypeInfo *ptiSource, ITypeInfo *ptiDest, ICreateTypeInfo *pctiDest, HREFTYPE *phreftype);
    HRESULT IsReservedMethod(BSTR bstrMethodName);

protected:
    ICreateTypeLib2     *m_piCreateTypeLib2;
    ITypeLib            *m_piTypeLib;
    GUID                 m_guidTypeLib;
};

#endif  // _DYNAMIC_TYPE_LIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\help.h ===
//---------------------------------------------------------------------------
// help.h
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------
//
// Contains help info needed by the .ODL file and the DECLARE_CONTROLOBJECT
// structure.  Define everything here once so we keep both items in sync. 
//

#ifndef _HELP_H
#define _HELP_H

#define HELP_FILENAME "VBSnapInsGuide.chm"
#define HELP_DLLFILENAME "MSSNAPD.OCX"
#define HELP_PPFILENAME HELP_FILENAME // Property page filename

#define merge(a,b) a ## b
#define WIDESTRINGCONSTANT(x) merge(L,x)
#define HELP_FILENAME_WIDE WIDESTRINGCONSTANT(HELP_FILENAME)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\errors.h ===
//=--------------------------------------------------------------------------=
// errors.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Error Codes Defined by the Designer
//
//=--------------------------------------------------------------------------=


#ifndef _ERRORS_DEFINED_
#define _ERRORS_DEFINED_


// Replacements for framework's macros.h stuff that does not work in header
// files.

#if defined(DEBUG)
extern HRESULT HrDebugTraceReturn(HRESULT hr, char *szFile, int iLine);
#define H_RRETURN(hr) return HrDebugTraceReturn(hr, __FILE__, __LINE__)
#else
#define H_RRETURN(hr) return (hr)
#endif

#define H_IfFailGoto(EXPR, LABEL) \
    { hr = (EXPR); if(FAILEDHR(hr)) goto LABEL; }

#define H_IfFailRet(EXPR) \
    { hr = (EXPR); if(FAILED(hr)) H_RRETURN(hr); }

#define IfFailGo(EXPR) IfFailGoto(EXPR, Error)


#define H_IfFalseRet(EXPR, HR) \
    { if(!(EXPR)) H_RRETURN(HR); }


// Macro to create a return code from an error name in the ID file.
// See below for examples of usage.

#define _MKERR(x)   MAKE_SCODE(SEVERITY_ERROR, FACILITY_CONTROL, x)
#define MKERR(x)    _MKERR(HID_mssnapd_err_##x)


//---------------------------------------------------------------------------
//
// HOW TO ADD A NEW ERROR
//
//
// 1) Add the error to mssnapd.id.  
//    Do *not* use devid to determine the help context id, but rather use
//    the error number itself
// 2) Add a define below for the error, using the MKERR macro
// 3) You may only return Win32 error codes and snap-in defined SID_E_XXXX
//    error codes. Do not use OLE E_XXX error codes directly as the
//    system message table does not have description strings for all of these
//    errors. If any OLE E_XXXX, CO_E_XXX, CTL_E_XXX or other such errors are
//    needed then add them as SID_E errors using the procedure described
//    above. If an error comes from an outside source and you are not sure
//    if error information is available for it then return SIR_E_EXTERNAL
//    and write the error to the event log using CError::WriteEventLog (see
//    error.h).
// 
//---------------------------------------------------------------------------

// Errors defined by the snap-in designer

#define SID_E_EXCEPTION                     MKERR(Exception)
#define SID_E_OUTOFMEMORY                   MKERR(OutOfMemory)
#define SID_E_INVALIDARG                    MKERR(InvalidArg)
#define SID_E_INTERNAL                      MKERR(Internal)


#endif // _ERRORS_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\imglist.cpp ===
//=--------------------------------------------------------------------------------------
// imglist.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- ImageList-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "snaputil.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddImageList()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddImageList()
{
    HRESULT                hr = S_OK;
    IMMCImageLists        *piMMCImageLists = NULL;
    VARIANT                vtEmpty;
    IMMCImageList         *piMMCImageList = NULL;

    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    if (piMMCImageLists != NULL)
    {
        ::VariantInit(&vtEmpty);
        vtEmpty.vt = VT_ERROR;
        vtEmpty.scode = DISP_E_PARAMNOTFOUND;

        hr = piMMCImageLists->Add(vtEmpty, vtEmpty, &piMMCImageList);
        IfFailGo(hr);
    }

Error:
    RELEASE(piMMCImageList);
    RELEASE(piMMCImageLists);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddMMCImageList(CSelectionHolder *pParent, IMMCImageList *piMMCImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnAddMMCImageList(CSelectionHolder *pParent, IMMCImageList *piMMCImageList)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pImageList = NULL;

    ASSERT(NULL != pParent, "OnAddMMCImageList: pParent is NULL");
    ASSERT(SEL_TOOLS_IMAGE_LISTS == pParent->m_st, "OnAddMMCImageList: type is not SEL_TOOLS_IMAGE_LISTS");
    ASSERT(NULL != piMMCImageList, "OnAddMMCImageList: piMMCImageList is NULL");

    hr = MakeNewImageList(pParent->m_piObject.m_piMMCImageLists, piMMCImageList, &pImageList);
    IfFailGo(hr);

    hr = pImageList->RegisterHolder();
    IfFailGo(hr);

    hr = m_pSnapInTypeInfo->AddImageList(piMMCImageList);
    IfFailGo(hr);

    hr = InsertImageListInTree(pImageList, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pImageList);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pImageList);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pImageList);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameImageList(CSelectionHolder *pImageList, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameImageList(CSelectionHolder *pImageList, BSTR bstrNewName)
{
    HRESULT     hr = S_OK;
    BSTR        bstrOldName = NULL;
    TCHAR      *pszName = NULL;

    ASSERT(SEL_TOOLS_IMAGE_LISTS_NAME == pImageList->m_st, "RenameImageList: wrong argument");

    // Check that the new name is valid
    IfFailGo(ValidateName(bstrNewName));
    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = m_pTreeView->GetLabel(pImageList, &bstrOldName);
    IfFailGo(hr);

    hr = m_pSnapInTypeInfo->RenameImageList(pImageList->m_piObject.m_piMMCImageList, bstrOldName);
    IfFailGo(hr);

    hr = pImageList->m_piObject.m_piMMCImageList->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->ChangeText(pImageList, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);
    FREESTRING(bstrOldName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteImageList(CSelectionHolder *pImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteImageList(CSelectionHolder *pImageList)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    BSTR                 bstrName = NULL;
    IMMCImageLists      *piMMCImageLists = NULL;
    VARIANT              vtKey;

    ::VariantInit(&vtKey);

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pImageList, &pParent);
    IfFailGo(hr);

    // Remove the ImageList from the appropriate collection
    ASSERT(SEL_TOOLS_IMAGE_LISTS == pParent->m_st, "DeleteImageList: expected another kind of parent");

    hr = pImageList->m_piObject.m_piMMCImageList->get_Name(&bstrName);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    if (piMMCImageLists != NULL)
    {
        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrName);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        hr = piMMCImageLists->Remove(vtKey);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtKey);
    FREESTRING(bstrName);
    RELEASE(piMMCImageLists);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteImageList(CSelectionHolder *pImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteImageList(CSelectionHolder *pImageList)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    IMMCImageLists      *piMMCImageLists = NULL;
    long                 lCount = 0;

    // Delete the TypeInfo related property
    hr = m_pSnapInTypeInfo->DeleteImageList(pImageList->m_piObject.m_piMMCImageList);
    IfFailGo(hr);

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pImageList, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pImageList);
    IfFailGo(hr);

    delete pImageList;

    // Select the next selection
    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    if (NULL != piMMCImageLists)
    {
        hr = piMMCImageLists->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piMMCImageLists);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowImageListProperties(IMMCImageList *piMMCImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowImageListProperties
(
    IMMCImageList *piMMCImageList
)
{
    HRESULT         hr = S_OK;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[2];

    hr = GetResourceString(IDS_IL_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = piMMCImageList->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_MMCImageListImagesPP;
    pageClsID[1] = CLSID_StockColorPage;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 2;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = 0;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewImageList(IMMCImageLists *piMMCImageLists, IMMCImageList *piMMCImageList, CSelectionHolder **ppImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewImageList
(
    IMMCImageLists    *piMMCImageLists,
    IMMCImageList     *piMMCImageList,
    CSelectionHolder **ppImageList
)
{
    HRESULT                hr = S_OK;

    *ppImageList = New CSelectionHolder(piMMCImageList);
    if (*ppImageList == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewImageList(piMMCImageLists, piMMCImageList);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewImageList(IMMCImageLists *piMMCImageLists, IMMCImageList *piMMCImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewImageList
(
    IMMCImageLists *piMMCImageLists,
    IMMCImageList  *piMMCImageList
)
{
    HRESULT           hr = S_OK;
    int               iResult = 0;
    int               iItemNumber = 1;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    bool              bGood = false;
    CSelectionHolder *pMMCImageListClone = NULL;

    hr = GetResourceString(IDS_IMGLIST, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    do {
        iResult = _stprintf(szName, _T("%s%d"), szBuffer, iItemNumber++);
        if (iResult == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK(hr);
        }

		hr = m_pTreeView->FindLabelInTree(szName, &pMMCImageListClone);
		IfFailGo(hr);

        if (S_FALSE == hr)
        {
			hr = BSTRFromANSI(szName, &bstrName);
			IfFailGo(hr);

            bGood = true;
            break;
        }

        FREESTRING(bstrName);
    } while (false == bGood);

    hr = piMMCImageList->put_Name(bstrName);
    IfFailGo(hr);

    hr = piMMCImageList->put_Key(bstrName);
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertImageListInTree(CSelectionHolder *pImageList, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertImageListInTree
(
    CSelectionHolder *pImageList,
    CSelectionHolder *pParent
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    TCHAR  *pszName = NULL;

    hr = pImageList->m_piObject.m_piMMCImageList->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kImageListIcon, pImageList);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\guids.h ===
//=--------------------------------------------------------------------------------------
// guids.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// GUIDS the Snap-In Designer uses
//=-------------------------------------------------------------------------------------=

#ifndef _DESGUIDS_H_
#define _DESGUIDS_H_

// The Snap-In properties
// {37EC7DD0-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_SnapInDefGeneralPP, 0x37ec7dd0, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DE1-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_SnapInDefImageListPP, 0x37ec7de1, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DD1-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_SnapInDefExtensionsPP, 0x37ec7dd1, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// Node properties
// {37EC7DD2-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_ScopeItemDefGeneralPP, 0x37ec7dd2, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DE1-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_ScopeItemDefColHdrsPP, 0x37ec7de2, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// Views:

// List View
// {37EC7DD3-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_ListViewDefGeneralPP, 0x37ec7dd3, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DD4-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_ListViewDefImgLstsPP, 0x37ec7dd4, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DD5-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_ListViewDefSortingPP, 0x37ec7dd5, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DD6-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_ListViewDefColHdrsPP, 0x37ec7dd6, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// OCX View
// {37EC7DD7-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_OCXViewDefGeneralPP, 0x37ec7dd7, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// URL View
// {37EC7DD8-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_URLViewDefGeneralPP, 0x37ec7dd8, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// Taskpad view
// {37EC7DD9-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_TaskpadViewDefGeneralPP, 0x37ec7dd9, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DDA-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_TaskpadViewDefBackgroundPP, 0x37ec7dda, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DDB-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_TaskpadViewDefTasksPP, 0x37ec7ddb, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// Tools:

// ImageLists
// {37EC7DDC-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_MMCImageListImagesPP, 0x37ec7ddc, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// Color is stock property page

// Toolbars
// {37EC7DDD-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_MMCToolbarGeneralPP, 0x37ec7ddd, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DDE-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_MMCToolbarButtonsPP, 0x37ec7dde, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// {37EC7DDF-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_MMCToolbarPicturePP, 0x37ec7ddf, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);

// Menus
// {37EC7DE0-28B5-11d2-BDB0-00A02463890E}
DEFINE_GUID(CLSID_MMCMenuGeneralPP, 0x37ec7de0, 0x28b5, 0x11d2, 0xbd, 0xb0, 0x0, 0xa0, 0x24, 0x63, 0x89, 0xe);


#endif  // _DESGUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\localobj.h ===
//=--------------------------------------------------------------------------=
// localobj.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// This file is used by automation servers to delcare things that their objects
// need other parts of the server to see.
//
#ifndef _LOCALOBJECTS_H_

//=--------------------------------------------------------------------------=
// these constants are used in conjunction with the g_ObjectInfo table that
// each inproc server defines.  they are used to identify a given  object
// within the server.
//
// **** ADD ALL NEW OBJECTS TO THIS LIST ****
//

#define _LOCALOBJECTS_H_

#define OBJECT_TYPE_SNAPINDESIGNER          0   // SnapIn Designer

#define OBJECT_TYPE_PPGSNAPINGENERAL        1   // SnapIn <General> PP
#define OBJECT_TYPE_PPGSNAPINIL             2   // SnapIn <Image Lists> PP
#define OBJECT_TYPE_PPGSNAPINAVAILNO        3   // SnapIn <Available Nodes> PP

#define OBJECT_TYPE_PPGNODEGENERAL	        4   // ScopeItem <General> PP
#define OBJECT_TYPE_PPGNODECOLHDRS	        5   // ScopeItem <Column Headers> PP

#define OBJECT_TYPE_PPGLSTVIEWGENERAL	    6   // ListView <General> PP
#define OBJECT_TYPE_PPGLSTVIEWIMGLSTS	    7   // ListView <Image Lists> PP
#define OBJECT_TYPE_PPGLSTVIEWSORTING	    8   // ListView <Sorting> PP
#define OBJECT_TYPE_PPGLSTVIEWCOLHDRS	    9   // ListView <Column Headers> PP

#define OBJECT_TYPE_PPGURLVIEWGENERAL	   10   // URLView <General> PP

#define OBJECT_TYPE_PPGOCXVIEWGENERAL      11   // OCXView <General> PP

#define OBJECT_TYPE_PPGIMGLISTSIMAGES      12   // ImageList <Images> PP

#define OBJECT_TYPE_PPGTOOLBRGENERAL       13   // Toolbar <General> PP
#define OBJECT_TYPE_PPGTOOLBRBUTTONS       14   // Toolbar <Buttons> PP

#define OBJECT_TYPE_PPGTASKGENERAL         15   // TaskpadView <General> PP
#define OBJECT_TYPE_PPGTASKBACKGR          16   // TaskpadView <Background> PP
#define OBJECT_TYPE_PPGTASKTASKS           17   // TaskpadView <Tasks> PP

#endif // _LOCALOBJECTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\listvw.cpp ===
//=--------------------------------------------------------------------------------------
// listvw.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- ListView-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "snaputil.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddListView()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddListView()
{
    HRESULT                hr = S_OK;
    IViewDefs             *piViewDefs = NULL;
    IListViewDefs         *piListViewDefs = NULL;
    VARIANT                vtEmpty;
    IListViewDef          *piListViewDef = NULL;

    ::VariantInit(&vtEmpty);

    hr = GetOwningViewCollection(&piViewDefs);
    IfFailGo(hr);

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_ListViews(&piListViewDefs);
        IfFailGo(hr);

        if (piListViewDefs != NULL)
        {
            vtEmpty.vt = VT_ERROR;
            vtEmpty.scode = DISP_E_PARAMNOTFOUND;

            hr = piListViewDefs->Add(vtEmpty, vtEmpty, &piListViewDef);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piListViewDef);
    RELEASE(piListViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddExistingListView(IViewDefs *piViewDefs, IListViewDef *piListViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddExistingListView(IViewDefs *piViewDefs, IListViewDef *piListViewDef)
{
    HRESULT           hr = S_OK;
    IListViewDefs    *piListViewDefs = NULL;

    hr = piViewDefs->get_ListViews(&piListViewDefs);
    IfFailGo(hr);

    hr = piListViewDefs->AddFromMaster(piListViewDef);
    IfFailGo(hr);

Error:
    RELEASE(piListViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddListViewDef(CSelectionHolder *pParent, IListViewDef *piListViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Invoked in response to an IObjectModelHost:Add() notification.
//
HRESULT CSnapInDesigner::OnAddListViewDef(CSelectionHolder *pParent, IListViewDef *piListViewDef)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pListView = NULL;
    IViewDefs           *piViewDefs = NULL;
    IListViewDefs       *piListViewDefs = NULL;

    ASSERT(NULL != pParent, "OnAddListViewDef: pParent is NULL");
    ASSERT(NULL != pParent->m_piObject.m_piListViewDefs, "OnAddListViewDef: pParent->m_piObject.m_piListViewDefs is NULL");

    switch (pParent->m_st)
    {
    case SEL_NODES_AUTO_CREATE_RTVW:
        hr = pParent->m_piObject.m_piSnapInDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_ListViews(&piListViewDefs);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_LIST_VIEWS:
        piListViewDefs = pParent->m_piObject.m_piListViewDefs;
        piListViewDefs->AddRef();
        break;

    case SEL_NODES_ANY_VIEWS:
        hr = pParent->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_ListViews(&piListViewDefs);
        IfFailGo(hr);
        break;

    default:
        ASSERT(0, "OnAddListViewDef: Cannot determine owning collection");
        goto Error;
    }

    hr = MakeNewListView(piListViewDefs, piListViewDef, &pListView);
    IfFailGo(hr);

    hr = InsertListViewInTree(pListView, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pListView);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pListView);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pListView);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RELEASE(piViewDefs);
    RELEASE(piListViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameListView(CSelectionHolder *pListView, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameListView(CSelectionHolder *pListView, BSTR bstrNewName)
{
    HRESULT              hr = S_OK;
    TCHAR               *pszName = NULL;

    ASSERT(SEL_VIEWS_LIST_VIEWS_NAME == pListView->m_st, "RenameListView: wrong argument");

    hr = m_piDesignerProgrammability->IsValidIdentifier(bstrNewName);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = pListView->m_piObject.m_piListViewDef->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    // Rename all satellite views
    hr = m_pTreeView->RenameAllSatelliteViews(pListView, pszName);
    IfFailGo(hr);

    // Rename the actual view
    hr = m_pTreeView->ChangeText(pListView, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteListView(CSelectionHolder *pListView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteListView
(
    CSelectionHolder *pListView
)
{
    HRESULT           hr = S_OK;
    bool              bIsSatelliteView = false;
    IObjectModel     *piObjectModel = NULL;
    long              lUsageCount = 0;
    BSTR              bstrName = NULL;
    IViewDefs        *piViewDefs = NULL;
    IListViewDefs    *piListViewDefs = NULL;
    VARIANT           vtKey;

    ::VariantInit(&vtKey);

    // We allow any satellite view to be deleted
    hr = IsSatelliteView(pListView);
    IfFailGo(hr);

    // But if it's a master with a UsageCount > 0 we don't allow deleting it.
    if (S_FALSE == hr)
    {
        hr = pListView->m_piObject.m_piListViewDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
        IfFailGo(hr);

        hr = piObjectModel->GetUsageCount(&lUsageCount);
        IfFailGo(hr);

        if (lUsageCount > 1)
        {
            (void)::SDU_DisplayMessage(IDS_VIEW_IN_USE, MB_OK | MB_ICONHAND, HID_mssnapd_ViewInUse, 0, DontAppendErrorInfo, NULL);
            goto Error;
        }
    }
    else
        bIsSatelliteView = true;

    hr = pListView->m_piObject.m_piListViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pListView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_ListViews(&piListViewDefs);
        IfFailGo(hr);

        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrName);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        hr = piListViewDefs->Remove(vtKey);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);
    RELEASE(piListViewDefs);
    RELEASE(piViewDefs);
    RELEASE(piObjectModel);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteListView(CSelectionHolder *pListView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  This view will be contained either in the main collection (SnapIn/Views/ListViews/<name>) or
//  or in one of the satellite collections. The former is pointed to by the argument <pListView>,
//  the latter should be <m_pCurrentSelection>,
//  
HRESULT CSnapInDesigner::OnDeleteListView
(
    CSelectionHolder *pListView
)
{
    HRESULT            hr = S_OK;
    CSelectionHolder  *pParent = NULL;
    bool               bIsSatelliteView = false;
    IViewDefs         *piViewDefs = NULL;
    IListViewDefs     *piListViewDefs = NULL;
    long               lCount = 0;

    hr = IsSatelliteView(pListView);
    IfFailGo(hr);

    bIsSatelliteView = (S_OK == hr) ? true : false;

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pListView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pListView, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pListView);
    IfFailGo(hr);

    delete pListView;

    // Select the next selection
    if (NULL != piViewDefs)
    {
        hr = piViewDefs->get_ListViews(&piListViewDefs);
        IfFailGo(hr);

        hr = piListViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piListViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowListViewProperties(IListViewDef *piListViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowListViewProperties
(
    IListViewDef *piListViewDef
)
{
    HRESULT         hr = S_OK;
    int             iResult = 0;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[4];

    hr = GetResourceString(IDS_LISTVIEW_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = piListViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_ListViewDefGeneralPP;
    pageClsID[1] = CLSID_ListViewDefImgLstsPP;
    pageClsID[2] = CLSID_ListViewDefSortingPP;
    pageClsID[3] = CLSID_ListViewDefColHdrsPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 4;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = 0;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewListView(IListViewDefs *piListViewDefs, IListViewDef *piListViewDef, CSelectionHolder **ppListView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewListView
(
    IListViewDefs     *piListViewDefs,
    IListViewDef      *piListViewDef,
    CSelectionHolder **ppListView
)
{
    HRESULT                hr = S_OK;

    *ppListView = New CSelectionHolder(piListViewDef);
    if (*ppListView == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewListView(piListViewDefs, *ppListView);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewListView(IListViewDefs *piListViewDefs, CSelectionHolder *pListView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewListView
(
    IListViewDefs     *piListViewDefs,
    CSelectionHolder  *pListView
)
{
    HRESULT           hr = S_OK;
    IObjectModel     *piObjectModel = NULL;
    CSelectionHolder *pViewCollection = NULL;
    int               iResult = 0;
    int               iItemNumber = 0;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    bool              bGood = false;
    CSelectionHolder *pListViewDefClone = NULL;

    ASSERT(NULL != piListViewDefs, "InitializeNewListView: piListViewDefs is NULL");
    ASSERT(NULL != pListView, "InitializeNewListView: pListView is NULL");

    hr = piListViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->GetCookie(reinterpret_cast<long *>(&pViewCollection));
    IfFailGo(hr);

    ASSERT(NULL != pViewCollection, "InitializeNewListView: Bad Cookie");

    hr = IsSatelliteCollection(pViewCollection);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = GetResourceString(IDS_LIST_VIEW, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        do {
            iResult = _stprintf(szName, _T("%s%d"), szBuffer, ++iItemNumber);
            if (iResult == 0)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK(hr);
            }

			hr = m_pTreeView->FindLabelInTree(szName, &pListViewDefClone);
			IfFailGo(hr);

            if (S_FALSE == hr)
            {
				hr = BSTRFromANSI(szName, &bstrName);
				IfFailGo(hr);

                bGood = true;
                break;
            }

            FREESTRING(bstrName);
        } while (false == bGood);

        hr = pListView->m_piObject.m_piListViewDef->put_Name(bstrName);
        IfFailGo(hr);

        hr = pListView->m_piObject.m_piListViewDef->put_Key(bstrName);
        IfFailGo(hr);
    }

    hr = pListView->RegisterHolder();
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertListViewInTree(CSelectionHolder *pListView, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertListViewInTree
(
    CSelectionHolder *pListView,
    CSelectionHolder *pParent
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    TCHAR  *pszName = NULL;

    hr = pListView->m_piObject.m_piListViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kListViewIcon, pListView);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\extend.cpp ===
//=--------------------------------------------------------------------------------------
// extend.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- Extension-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "snaputil.h"
#include "desmain.h"
#include "guids.h"
#include "psnode.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddExtendedSnapIn(CSelectionHolder *pParent, IExtendedSnapIn *piExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnAddExtendedSnapIn(CSelectionHolder *pParent, IExtendedSnapIn *piExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pExtendedSnapIn = NULL;
    BSTR                 bstrName = NULL;
    TCHAR               *pszName = NULL;

    pExtendedSnapIn = New CSelectionHolder(piExtendedSnapIn);
    if (NULL == pExtendedSnapIn)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Use the key as the name here because this function is called during the
    // update notification when the available nodes dialog (psextend.cpp,
    // CSnapInAvailNodesPage::AddSnapIn()) calls
    // SnapInDesignerDef.ExtensionDefs.ExtendedSnapIns.Add. The key will be the
    // node type GUID.

    hr = piExtendedSnapIn->get_Key(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kClosedFolderIcon, pExtendedSnapIn);
    IfFailGo(hr);

    hr = pExtendedSnapIn->RegisterHolder();
    IfFailGo(hr);

    hr = PopulateExtendedSnapIn(pExtendedSnapIn);
    IfFailGo(hr);

    hr = OnSelectionChanged(pExtendedSnapIn);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pExtendedSnapIn);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    if (NULL != pszName)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}


HRESULT CSnapInDesigner::DeleteExtendedSnapIn(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    IExtendedSnapIns *piExtendedSnapIns = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DeleteExtendedSnapIn: wrong argument");

    // Need to remove the extended snapin from
    // SnapInDesignerDef.ExtensionDefs.ExtendedSnapIns.

    IfFailGo(m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs));

    IfFailGo(piExtensionDefs->get_ExtendedSnapIns(&piExtendedSnapIns));

    IfFailGo(pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_Index(&varIndex.lVal));
    varIndex.vt = VT_I4;

    // The remove call will generate an IObjectModeHost::Delete() call that will
    // be handled in CSnapInDesigner::Delete(). It will in turn call
    // CSnapInDesigner::OnDeleteExtendedSnapIn() (below) which will remove the
    // treeview node.

    IfFailGo(piExtendedSnapIns->Remove(varIndex));

Error:
    QUICK_RELEASE(piExtensionDefs);
    QUICK_RELEASE(piExtendedSnapIns);
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDeleteExtendedSnapIn(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pContextMenus = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DeleteExtendedSnapIn: wrong argument");

    // Need to remove the node and all of its children from the treeview.

    IfFailGo(FindExtension(pExtendedSnapIn, SEL_EEXTENSIONS_CC_ROOT,
                           &pContextMenus));

    IfFailGo(DeleteExtensionNode(SEL_EEXTENSIONS_CC_NEW, pContextMenus));

    IfFailGo(DeleteExtensionNode(SEL_EEXTENSIONS_CC_TASK, pContextMenus));

    IfFailGo(DeleteExtensionNode(SEL_EEXTENSIONS_PP_ROOT, pExtendedSnapIn));

    IfFailGo(DeleteExtensionNode(SEL_EEXTENSIONS_TASKPAD, pExtendedSnapIn));

    IfFailGo(DeleteExtensionNode(SEL_EEXTENSIONS_TOOLBAR, pExtendedSnapIn));

    IfFailGo(DeleteExtensionNode(SEL_EEXTENSIONS_NAMESPACE, pExtendedSnapIn));

    IfFailGo(m_pTreeView->DeleteNode(pExtendedSnapIn));

    delete pExtendedSnapIn;

    // Change the selection to <root>\Extensions

    IfFailGo(OnSelectionChanged(m_pRootExtensions));

    IfFailGo(m_pTreeView->SelectItem(m_pRootExtensions));

Error:
    RRETURN(hr);
}



HRESULT CSnapInDesigner::DeleteExtensionNode
(
    SelectionType     stExtensionType,
    CSelectionHolder *pParent
)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pExtension = NULL;

    IfFailGo(FindExtension(pParent, stExtensionType, &pExtension));

    if (NULL != pExtension)
    {
        IfFailGo(m_pTreeView->DeleteNode(pExtension));

        delete pExtension;
    }

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameExtendedSnapIn(CSelectionHolder *pExtendedSnapIn, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Extendend snap-in names are displayed as the node type GUID followed by the
// node type name
//
HRESULT CSnapInDesigner::RenameExtendedSnapIn(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT  hr = S_OK;
    char    *pszDisplayName = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "RenameExtendedSnapIn: wrong argument");

    IfFailGo(::GetExtendedSnapInDisplayName(pExtendedSnapIn->m_piObject.m_piExtendedSnapIn,
                                            &pszDisplayName));

    hr = m_pTreeView->ChangeText(pExtendedSnapIn, pszDisplayName);
    IfFailGo(hr);

Error:
    if (NULL != pszDisplayName)
        CtlFree(pszDisplayName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteExtensionNewMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteExtensionNewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_CC_NEW == pExtendedSnapIn->m_st, "DeleteExtendedSnCtxMnNew: Wrong argument");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsNewMenu(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteExtensionNewMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteExtensionNewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pNewMenu = NULL;
    CSelectionHolder *pContextMenus = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDeleteExtensionTaskMenu: Wrong argument");

    IfFailGo(FindExtension(pExtendedSnapIn, SEL_EEXTENSIONS_CC_ROOT,
                           &pContextMenus));

    IfFailGo(FindExtension(pContextMenus, SEL_EEXTENSIONS_CC_NEW,
                           &pNewMenu));

    hr = m_pTreeView->DeleteNode(pNewMenu);
    IfFailGo(hr);

    delete pNewMenu;

    hr = OnSelectionChanged(pExtendedSnapIn);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pExtendedSnapIn);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_CC_TASK == pExtendedSnapIn->m_st, "DeleteExtensionTaskMenu: Wrong argument");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsTaskMenu(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pContextMenus = NULL;
    CSelectionHolder *pTaskMenu = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDeleteExtensionTaskMenu: Wrong argument");

    IfFailGo(FindExtension(pExtendedSnapIn, SEL_EEXTENSIONS_CC_ROOT,
                           &pContextMenus));

    IfFailGo(FindExtension(pContextMenus, SEL_EEXTENSIONS_CC_TASK,
                           &pTaskMenu));

    hr = m_pTreeView->DeleteNode(pTaskMenu);
    IfFailGo(hr);

    delete pTaskMenu;

    hr = OnSelectionChanged(pExtendedSnapIn);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pExtendedSnapIn);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_PP_ROOT == pExtendedSnapIn->m_st, "DeleteExtensionPropertyPages: Wrong argument");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsPropertyPages(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pPropertyPages = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDeleteExtensionPropertyPages: Wrong argument");

    IfFailGo(FindExtension(pExtendedSnapIn, SEL_EEXTENSIONS_PP_ROOT,
                           &pPropertyPages));

    hr = m_pTreeView->DeleteNode(pPropertyPages);
    IfFailGo(hr);

    delete pPropertyPages;

    hr = OnSelectionChanged(pExtendedSnapIn);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pExtendedSnapIn);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteExtensionTaskpad(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteExtensionTaskpad(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_TASKPAD == pExtendedSnapIn->m_st, "DeleteExtensionTaskpad: Wrong argument");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskpad(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsTaskpad(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteExtensionTaskpad(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteExtensionTaskpad(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTaskpad = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDeleteExtensionTaskpad: Wrong argument");

    IfFailGo(FindExtension(pExtendedSnapIn, SEL_EEXTENSIONS_TASKPAD,
                           &pTaskpad));

    hr = m_pTreeView->DeleteNode(pTaskpad);
    IfFailGo(hr);

    delete pTaskpad;

    hr = OnSelectionChanged(pExtendedSnapIn);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pExtendedSnapIn);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteExtensionToolbar(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteExtensionToolbar(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_TOOLBAR == pExtendedSnapIn->m_st, "DeleteExtensionToolbar: Wrong argument");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsToolbar(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteExtensionToolbar(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteExtensionToolbar(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pToolbar = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDeleteExtensionToolbar: Wrong argument");

    IfFailGo(FindExtension(pExtendedSnapIn, SEL_EEXTENSIONS_TOOLBAR,
                           &pToolbar));

    hr = m_pTreeView->DeleteNode(pToolbar);
    IfFailGo(hr);

    delete pToolbar;

    hr = OnSelectionChanged(pExtendedSnapIn);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pExtendedSnapIn);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteExtensionNameSpace(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteExtensionNameSpace(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_NAMESPACE == pExtendedSnapIn->m_st, "DeleteExtensionNameSpace: Wrong argument");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsNameSpace(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteExtensionNameSpace(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteExtensionNameSpace(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pNameSpace = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDeleteExtensionNameSpace: Wrong argument");

    IfFailGo(FindExtension(pExtendedSnapIn, SEL_EEXTENSIONS_NAMESPACE,
                           &pNameSpace));

    hr = m_pTreeView->DeleteNode(pNameSpace);
    IfFailGo(hr);

    delete pNameSpace;

    hr = OnSelectionChanged(pExtendedSnapIn);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pExtendedSnapIn);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------
// Extending myself
//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMyExtendsNewMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMyExtendsNewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_NEW_MENU == pExtendedSnapIn->m_st, "DeleteMyExtensdsNewMenu: Wrong argument");

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = piExtensionDefs->put_ExtendsNewMenu(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMyExtendsNewMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMyExtendsNewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTarget = NULL;
    CSelectionHolder *pParent = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pExtendedSnapIn->m_st, "OnDeleteMyExtensdsNewMenu: Wrong argument");

    hr = FindMyExtension(SEL_EXTENSIONS_NEW_MENU, &pTarget);
    IfFailGo(hr);

    hr = m_pTreeView->GetParent(pTarget, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->DeleteNode(pTarget);
    IfFailGo(hr);

    delete pTarget;

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMyExtendsTaskMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMyExtendsTaskMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_TASK_MENU == pExtendedSnapIn->m_st, "DeleteMyExtensdsTaskMenu: Wrong argument");

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = piExtensionDefs->put_ExtendsTaskMenu(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMyExtendsTaskMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMyExtendsTaskMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTarget = NULL;
    CSelectionHolder *pParent = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pExtendedSnapIn->m_st, "OnDeleteMyExtendsTaskMenu: Wrong argument");

    hr = FindMyExtension(SEL_EXTENSIONS_TASK_MENU, &pTarget);
    IfFailGo(hr);

    hr = m_pTreeView->GetParent(pTarget, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->DeleteNode(pTarget);
    IfFailGo(hr);

    delete pTarget;

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMyExtendsTopMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMyExtendsTopMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_TOP_MENU == pExtendedSnapIn->m_st, "DeleteMyExtendsTopMenu: Wrong argument");

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsTopMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = piExtensionDefs->put_ExtendsTopMenu(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMyExtendsTopMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMyExtendsTopMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTarget = NULL;
    CSelectionHolder *pParent = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pExtendedSnapIn->m_st, "OnDeleteMyExtendsTopMenu: Wrong argument");

    hr = FindMyExtension(SEL_EXTENSIONS_TOP_MENU, &pTarget);
    IfFailGo(hr);

    hr = m_pTreeView->GetParent(pTarget, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->DeleteNode(pTarget);
    IfFailGo(hr);

    delete pTarget;

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMyExtendsViewMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMyExtendsViewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_VIEW_MENU == pExtendedSnapIn->m_st, "DeleteMyExtendsViewMenu: Wrong argument");

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsViewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = piExtensionDefs->put_ExtendsViewMenu(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMyExtendsViewMenu(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMyExtendsViewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTarget = NULL;
    CSelectionHolder *pParent = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pExtendedSnapIn->m_st, "OnDeleteMyExtendsViewMenu: Wrong argument");

    hr = FindMyExtension(SEL_EXTENSIONS_VIEW_MENU, &pTarget);
    IfFailGo(hr);

    hr = m_pTreeView->GetParent(pTarget, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->DeleteNode(pTarget);
    IfFailGo(hr);

    delete pTarget;

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMyExtendsPPages(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMyExtendsPPages(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_PPAGES == pExtendedSnapIn->m_st, "DeleteMyExtendsPPages: Wrong argument");

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = piExtensionDefs->put_ExtendsPropertyPages(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMyExtendsPPages(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMyExtendsPPages(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTarget = NULL;
    CSelectionHolder *pParent = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pExtendedSnapIn->m_st, "OnDeleteMyExtendsPPages: Wrong argument");

    hr = FindMyExtension(SEL_EXTENSIONS_PPAGES, &pTarget);
    IfFailGo(hr);

    hr = m_pTreeView->GetParent(pTarget, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->DeleteNode(pTarget);
    IfFailGo(hr);

    delete pTarget;

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMyExtendsToolbar(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMyExtendsToolbar(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_TOOLBAR == pExtendedSnapIn->m_st, "DeleteMyExtendsToolbar: Wrong argument");

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = piExtensionDefs->put_ExtendsToolbar(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMyExtendsToolbar(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMyExtendsToolbar(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTarget = NULL;
    CSelectionHolder *pParent = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pExtendedSnapIn->m_st, "OnDeleteMyExtendsToolbar: Wrong argument");

    hr = FindMyExtension(SEL_EXTENSIONS_TOOLBAR, &pTarget);
    IfFailGo(hr);

    hr = m_pTreeView->GetParent(pTarget, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->DeleteNode(pTarget);
    IfFailGo(hr);

    delete pTarget;

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteMyExtendsNameSpace(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteMyExtendsNameSpace(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    IExtensionDefs   *piExtensionDefs = NULL;
    VARIANT_BOOL      bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_NAMESPACE == pExtendedSnapIn->m_st, "DeleteMyExtendsNameSpace: Wrong argument");

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = piExtensionDefs->put_ExtendsNameSpace(VARIANT_FALSE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteMyExtendsNameSpace(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteMyExtendsNameSpace(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pTarget = NULL;
    CSelectionHolder *pParent = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pExtendedSnapIn->m_st, "OnDeleteMyExtendsNameSpace: Wrong argument");

    hr = FindMyExtension(SEL_EXTENSIONS_NAMESPACE, &pTarget);
    IfFailGo(hr);

    hr = m_pTreeView->GetParent(pTarget, &pParent);
    IfFailGo(hr);

    hr = m_pTreeView->DeleteNode(pTarget);
    IfFailGo(hr);

    delete pTarget;

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::FindMyExtension(SelectionType stExtensionType, CSelectionHolder **ppExtension)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::FindMyExtension(SelectionType stExtensionType, CSelectionHolder **ppExtension)
{
    RRETURN(FindExtension(m_pRootMyExtensions, stExtensionType, ppExtension));
}




//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------
// Extending other Snap-Ins
//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------


HRESULT CSnapInDesigner::DoExtensionNewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DoExtensionCtxMenuNew: pExtendedSnapIn is NULL");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsNewMenu(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoExtensionNewMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pCtxMenuNew = NULL;
    CSelectionHolder    *pChild = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDoExtensionNewMenu: pExtendedSnapIn is NULL");

    hr = m_pTreeView->GetFirstChildNode(pExtendedSnapIn, &pChild);
    IfFailGo(hr);

    while (SEL_EEXTENSIONS_CC_ROOT != pChild->m_st)
    {
        hr = m_pTreeView->GetNextChildNode(pChild, &pChild);
        IfFailGo(hr);
    }

    ASSERT(NULL != pChild, "DoExtensionCtxMenuNew: Could not find parent node");
    ASSERT(SEL_EEXTENSIONS_CC_ROOT == pChild->m_st, "DoExtensionCtxMenuNew: Found wrong parent node");

    // Create the tree node for Extensions/<Extended snap-in>/Context Menus/New
    hr = GetResourceString(IDS_EXT_CTX_MENU_NEW, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pCtxMenuNew = New CSelectionHolder(SEL_EEXTENSIONS_CC_NEW, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
    if (NULL == pCtxMenuNew)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, pChild, kClosedFolderIcon, pCtxMenuNew);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DoExtensionCtxMenuTask: pExtendedSnapIn is NULL");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsTaskMenu(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoExtensionTaskMenu(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pCtxMenuTask = NULL;
    CSelectionHolder    *pChild = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDoExtensionTaskMenu: pExtendedSnapIn is NULL");

    hr = m_pTreeView->GetFirstChildNode(pExtendedSnapIn, &pChild);
    IfFailGo(hr);

    while (SEL_EEXTENSIONS_CC_ROOT != pChild->m_st)
    {
        hr = m_pTreeView->GetNextChildNode(pChild, &pChild);
        IfFailGo(hr);
    }

    ASSERT(NULL != pChild, "DoExtensionCtxMenuTask: Could not find parent node");
    ASSERT(SEL_EEXTENSIONS_CC_ROOT == pChild->m_st, "DoExtensionCtxMenuTask: Found wrong parent node");

    // Create the tree node for Extensions/<Extended snap-in>/Context Menus/New
    hr = GetResourceString(IDS_EXT_CTX_MENU_TASK, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pCtxMenuTask = New CSelectionHolder(SEL_EEXTENSIONS_CC_TASK, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
    if (NULL == pCtxMenuTask)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, pChild, kClosedFolderIcon, pCtxMenuTask);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DoExtensionPropertyPages: pExtendedSnapIn is NULL");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsPropertyPages(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoExtensionPropertyPages(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pPropertyPages = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDoExtensionPropertyPages: pExtendedSnapIn is NULL");

    hr = GetResourceString(IDS_EXT_PROP_PAGES, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pPropertyPages = New CSelectionHolder(SEL_EEXTENSIONS_PP_ROOT, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
    if (NULL == pPropertyPages)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pPropertyPages);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoExtensionTaskpad(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DoExtensionTaskpad: pExtendedSnapIn is NULL");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskpad(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsTaskpad(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoExtensionTaskpad(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pTaskpads = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDoExtensionTaskpad: pExtendedSnapIn is NULL");

    hr = GetResourceString(IDS_EXT_PROP_TASKPAD, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pTaskpads = New CSelectionHolder(SEL_EEXTENSIONS_TASKPAD, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
    if (NULL == pTaskpads)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pTaskpads);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoExtensionToolbar(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DoExtensionToolbar: pExtendedSnapIn is NULL");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsToolbar(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoExtensionToolbar(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pToolbar = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDoExtensionToolbar: pExtendedSnapIn is NULL");

    hr = GetResourceString(IDS_EXT_PROP_TOOLBAR, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pToolbar = New CSelectionHolder(SEL_EEXTENSIONS_TOOLBAR, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
    if (NULL == pToolbar)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pToolbar);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}



HRESULT CSnapInDesigner::DoExtensionNameSpace(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DoExtensionNameSpace: pExtendedSnapIn is NULL");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    // If we haven't yet set this value to True then do it now

    if (VARIANT_FALSE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsNameSpace(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}



HRESULT CSnapInDesigner::OnDoExtensionNameSpace(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pNameSpace = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDoExtensionNameSpace: pExtendedSnapIn is NULL");

    hr = GetResourceString(IDS_EXT_PROP_NAMESPACE, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pNameSpace = New CSelectionHolder(SEL_EEXTENSIONS_NAMESPACE, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
    if (NULL == pNameSpace)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pNameSpace);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::FindExtension(SelectionType stExtensionType, CSelectionHolder **ppExtension)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//

HRESULT CSnapInDesigner::FindExtension
(
    CSelectionHolder  *pRoot,
    SelectionType      stExtensionType,
    CSelectionHolder **ppExtension
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pChild = NULL;

    hr = m_pTreeView->GetFirstChildNode(pRoot, &pChild);
    IfFailGo(hr);

    while (S_OK == hr)
    {
        if (stExtensionType == pChild->m_st)
        {
            *ppExtension = pChild;
            hr = S_OK;
            goto Error;
        }

        hr = m_pTreeView->GetNextChildNode(pChild, &pChild);
        IfFailGo(hr);
    }

    hr = S_FALSE;

Error:
    RRETURN(hr);
}





//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------
// Extending this Snap-In
//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------


HRESULT CSnapInDesigner::DoMyExtendsNewMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_MYNAME == pMyExtensions->m_st, "DoMyExtendsNewMenu: wrong argument");

    hr = pMyExtensions->m_piObject.m_piExtensionDefs->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pMyExtensions->m_piObject.m_piExtensionDefs->put_ExtendsNewMenu(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoMyExtendsNewMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pSelection = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pMyExtensions->m_st, "OnDoMyExtendsNewMenu: wrong argument");

    hr = GetResourceString(IDS_MYEXT_NEW_MENU, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pSelection = New CSelectionHolder(SEL_EXTENSIONS_NEW_MENU, pMyExtensions->m_piObject.m_piExtendedSnapIn);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, m_pRootMyExtensions, kClosedFolderIcon, pSelection);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoMyExtendsTaskMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_MYNAME == pMyExtensions->m_st, "DoMyExtendsTaskMenu: wrong argument");

    hr = pMyExtensions->m_piObject.m_piExtensionDefs->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pMyExtensions->m_piObject.m_piExtensionDefs->put_ExtendsTaskMenu(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoMyExtendsTaskMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pSelection = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pMyExtensions->m_st, "OnDoMyExtendsTaskMenu: wrong argument");

    hr = GetResourceString(IDS_MYEXT_TASK_MENU, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pSelection = New CSelectionHolder(SEL_EXTENSIONS_TASK_MENU, pMyExtensions->m_piObject.m_piExtendedSnapIn);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, m_pRootMyExtensions, kClosedFolderIcon, pSelection);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoMyExtendsTopMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_MYNAME == pMyExtensions->m_st, "DoMyExtendsTopMenu: wrong argument");

    hr = pMyExtensions->m_piObject.m_piExtensionDefs->get_ExtendsTopMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pMyExtensions->m_piObject.m_piExtensionDefs->put_ExtendsTopMenu(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoMyExtendsTopMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pSelection = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pMyExtensions->m_st, "OnDoMyExtendsTopMenu: wrong argument");

    hr = GetResourceString(IDS_MYEXT_TOP_MENU, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pSelection = New CSelectionHolder(SEL_EXTENSIONS_TOP_MENU, pMyExtensions->m_piObject.m_piExtendedSnapIn);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, m_pRootMyExtensions, kClosedFolderIcon, pSelection);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoMyExtendsViewMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_MYNAME == pMyExtensions->m_st, "DoMyExtendsViewMenu: wrong argument");

    hr = pMyExtensions->m_piObject.m_piExtensionDefs->get_ExtendsViewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pMyExtensions->m_piObject.m_piExtensionDefs->put_ExtendsViewMenu(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoMyExtendsViewMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pSelection = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pMyExtensions->m_st, "OnDoMyExtendsViewMenu: wrong argument");

    hr = GetResourceString(IDS_MYEXT_VIEW_MENU, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pSelection = New CSelectionHolder(SEL_EXTENSIONS_VIEW_MENU, pMyExtensions->m_piObject.m_piExtendedSnapIn);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, m_pRootMyExtensions, kClosedFolderIcon, pSelection);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoMyExtendsPPages(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_MYNAME == pMyExtensions->m_st, "DoMyExtendsPPages: wrong argument");

    hr = pMyExtensions->m_piObject.m_piExtensionDefs->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pMyExtensions->m_piObject.m_piExtensionDefs->put_ExtendsPropertyPages(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoMyExtendsPPages(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pSelection = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pMyExtensions->m_st, "OnDoMyExtendsPPages: wrong argument");

    hr = GetResourceString(IDS_MYEXT_PPAGES, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pSelection = New CSelectionHolder(SEL_EXTENSIONS_PPAGES, pMyExtensions->m_piObject.m_piExtendedSnapIn);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, m_pRootMyExtensions, kClosedFolderIcon, pSelection);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoMyExtendsToolbar(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_MYNAME == pMyExtensions->m_st, "DoMyExtendsToolbar: wrong argument");

    hr = pMyExtensions->m_piObject.m_piExtensionDefs->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pMyExtensions->m_piObject.m_piExtensionDefs->put_ExtendsToolbar(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoMyExtendsToolbar(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pSelection = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pMyExtensions->m_st, "OnDoMyExtendsToolbar: wrong argument");

    hr = GetResourceString(IDS_MYEXT_TOOLBAR, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pSelection = New CSelectionHolder(SEL_EXTENSIONS_TOOLBAR, pMyExtensions->m_piObject.m_piExtendedSnapIn);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, m_pRootMyExtensions, kClosedFolderIcon, pSelection);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoMyExtendsNameSpace(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_MYNAME == pMyExtensions->m_st, "DoMyExtendsNameSpace: wrong argument");

    hr = pMyExtensions->m_piObject.m_piExtensionDefs->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pMyExtensions->m_piObject.m_piExtensionDefs->put_ExtendsNameSpace(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoMyExtendsNameSpace(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pSelection = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pMyExtensions->m_st, "OnDoMyExtendsNameSpace: wrong argument");

    hr = GetResourceString(IDS_MYEXT_NAMESPACE, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pSelection = New CSelectionHolder(SEL_EXTENSIONS_NAMESPACE, pMyExtensions->m_piObject.m_piExtendedSnapIn);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, m_pRootMyExtensions, kClosedFolderIcon, pSelection);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\mssnapr_i_wrap.c ===
#include "mssnapr_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\menuedit.h ===
//=--------------------------------------------------------------------------------------
// MenuEdit.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//=------------------------------------------------------------------------------------=
//
// CMenuEditor declaration
//=-------------------------------------------------------------------------------------=

#ifndef _MENUEDITOR_H_
#define _MENUEDITOR_H_




class CMenuEditor : public CError, public CtlNewDelete
{
public:
    CMenuEditor(IMMCMenu *piMMCMenu);
    ~CMenuEditor();

    HRESULT DoModal(HWND hwndParent);

    static BOOL CALLBACK MenuEditorDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    IMMCMenu    *m_piMMCMenu;
};


#endif  // _MENUEDITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\pch.h ===
//=--------------------------------------------------------------------------------------
// pch.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//=------------------------------------------------------------------------------------=
//
// Precompiled header files for mssnapd
//=-------------------------------------------------------------------------------------=

#include <ipserver.h>
#include <localsrv.h>
#include <comcat.h>
#include <commctrl.h>
#include <windowsx.h>
#include <macros.h>
#include <util.h>
#include <tchar.h>
#include <stdio.h>
#include <prsht.h>
#include <MSStkPPg.h>
#include <commdlg.h>

#include "..\..\mssnapr\mssnapr\dispid.h"
#include "mssnapr.h"

#include "resource.h"
#include "help.h"
#include "mssnapd_helpids.h"
#include "localobj.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psextend.cpp ===
//=--------------------------------------------------------------------------------------
// psextend.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//
//=------------------------------------------------------------------------------------=
//
// Snap-In Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "psextend.h"

// for ASSERT and FAIL
//
SZTHISFILE

const int   kMaxBuffer                  = 1024;

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Holder for available MMC Node Types
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

//=--------------------------------------------------------------------------------------
// CMMCNodeType::CMMCNodeType(const char *pszName, const char *pszGuid)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CMMCNodeType::CMMCNodeType
(
    const char *pszName,
    const char *pszGuid
)
: CCheckedListItem(false), m_pszName(0), m_pszGuid(0)
{
    m_pszName = reinterpret_cast<char *>(CtlAlloc(::strlen(pszName) + 1));
    if (NULL != m_pszName)
    {
        ::strcpy(m_pszName, pszName);
    }

    m_pszGuid = reinterpret_cast<char *>(CtlAlloc(::strlen(pszGuid) + 1));
    if (NULL != m_pszGuid)
    {
        ::strcpy(m_pszGuid, pszGuid);
    }
}


//=--------------------------------------------------------------------------------------
// CMMCNodeType::~CMMCNodeType()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CMMCNodeType::~CMMCNodeType()
{
    if (NULL != m_pszName)
        CtlFree(m_pszName);

    if (NULL != m_pszGuid)
        CtlFree(m_pszGuid);
}




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// SnapIn Property Page "Available Nodes"
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CSnapInAvailNodesPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
IUnknown *CSnapInAvailNodesPage::Create(IUnknown *pUnkOuter)
{
        CSnapInAvailNodesPage *pNew = New CSnapInAvailNodesPage(pUnkOuter);
        return pNew->PrivateUnknown();
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::CSnapInAvailNodesPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CSnapInAvailNodesPage::CSnapInAvailNodesPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGSNAPINAVAILNO),
  m_piSnapInDesignerDef(0), m_piSnapInDef(0), m_pCheckList(0), m_pMMCNodeType(0), m_bEnabled(false)
{
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::~CSnapInAvailNodesPage()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CSnapInAvailNodesPage::~CSnapInAvailNodesPage()
{
    RELEASE(m_piSnapInDef);
    RELEASE(m_piSnapInDesignerDef);

    if (NULL != m_pCheckList)
    {
        m_pCheckList->Detach();
        delete m_pCheckList;
    }
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnInitializeDialog()
{
    HRESULT  hr = S_OK;

    m_pCheckList = New CCheckList(IDC_LIST_AVAILABLE_NODES);
    if (NULL == m_pCheckList)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pCheckList->Attach(::GetDlgItem(m_hwnd, IDC_LIST_AVAILABLE_NODES));
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnNewObjects()
{
    HRESULT             hr = S_OK;
    IUnknown           *pUnk = NULL;
    DWORD               dwDummy = 0;
    IObjectModel       *piObjectModel = NULL;
    ISnapInDef         *piSnapInDef = NULL;
    SnapInTypeConstants sitc = siStandAlone;
    TCHAR               szBuffer[kMaxBuffer + 1];

    if (NULL != m_piSnapInDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_ISnapInDef, reinterpret_cast<void **>(&m_piSnapInDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&m_piSnapInDesignerDef);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    hr = piSnapInDef->get_Type(&sitc);
    IfFailGo(hr);

    if (siStandAlone != sitc)
    {
        hr = PopulateAvailNodesDialog();
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_PROPERTIES), FALSE);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_AVAILABLE_NODES), LB_SETCURSEL, 0, 0);

        m_bEnabled = true;
    }
    else
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_ADD), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_PROPERTIES), FALSE);

        hr = GetResourceString(IDS_TT_EXTEND_INSTRUCTIONS, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        ::SetWindowText(::GetDlgItem(m_hwnd, IDC_STATIC_EXTEND_INSTRUCTIONS), szBuffer);
    }

Error:
    RELEASE(piSnapInDef);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnApply()
{
    HRESULT          hr = S_OK;
    int              iCount = 0;
    int              iIndex = 0;
    CMMCNodeType    *pNodeType = NULL;
    VARIANT_BOOL     bCheck = VARIANT_FALSE;
    BSTR             bstrNodeTypeGUID = NULL;
    IExtendedSnapIn *piExtendedSnapIn = NULL;

    ASSERT(NULL != m_piSnapInDef, "OnApply: m_piSnapInDef is NULL");

    m_pCheckList->GetNumberOfItems(&iCount);
    IfFailGo(hr);

    for (iIndex = 0; iIndex < iCount; ++iIndex)
    {
        hr = m_pCheckList->GetItemData(iIndex, reinterpret_cast<void **>(&pNodeType));
        IfFailGo(hr);

        if (NULL == pNodeType)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        hr = m_pCheckList->GetItemCheck(iIndex, &bCheck);
        IfFailGo(hr);

        hr = BSTRFromANSI(pNodeType->m_pszGuid, &bstrNodeTypeGUID);
        IfFailGo(hr);

        if (VARIANT_TRUE == bCheck)
        {
            hr = FindSnapIn(bstrNodeTypeGUID, &piExtendedSnapIn);
            IfFailGo(hr);

            if (S_FALSE == hr)
            {
                hr = AddSnapIn(pNodeType);
                IfFailGo(hr);
            }
        }
        else
        {
            hr = FindSnapIn(bstrNodeTypeGUID, &piExtendedSnapIn);
            IfFailGo(hr);

            if (S_OK == hr)
            {
                hr = RemoveSnapIn(pNodeType);
                IfFailGo(hr);
            }
        }

        FREESTRING(bstrNodeTypeGUID);
        RELEASE(piExtendedSnapIn);
    }

Error:
    FREESTRING(bstrNodeTypeGUID);
    RELEASE(piExtendedSnapIn);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnCtlSelChange
(
    int dlgItemID
)
{
    HRESULT hr = S_OK;
    long    lIndex = 0;

    DebugPrintf("OnCtlSelChange() m_bEnabled=%d\r\n", m_bEnabled);

    if (true == m_bEnabled)
    {
        lIndex = ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_AVAILABLE_NODES), LB_GETCURSEL, 0, 0);
        if (LB_ERR == lIndex)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        if (LB_ERR != lIndex)
        {
            hr = m_pCheckList->GetItemData(lIndex, reinterpret_cast<void **>(&m_pMMCNodeType));
            IfFailGo(hr);

            if (NULL == m_pMMCNodeType)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK_GO(hr);
            }

            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_PROPERTIES), TRUE);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnCtlSetFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnCtlSetFocus
(
    int dlgItemID
)
{
    HRESULT hr = S_OK;
    long    lIndex = 0;

    DebugPrintf("OnCtlSetFocus() m_bEnabled=%d\r\n", m_bEnabled);

    if (true == m_bEnabled)
    {
        lIndex = ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_AVAILABLE_NODES), LB_GETCURSEL, 0, 0);
        if (lIndex == LB_ERR)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        if (LB_ERR != lIndex)
        {
            hr = m_pCheckList->GetItemData(lIndex, reinterpret_cast<void **>(&m_pMMCNodeType));
            IfFailGo(hr);

            if (NULL == m_pMMCNodeType)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK_GO(hr);
            }

            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_PROPERTIES), TRUE);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_BUTTON_ADD:
        hr = OnNewAvailNode();
        IfFailGo(hr);
        break;

    case IDC_BUTTON_PROPERTIES:
        if (NULL != m_pMMCNodeType)
        {
            hr = OnProperties(m_pMMCNodeType);
            IfFailGo(hr);
        }
        break;
    }

    ::SetFocus(::GetDlgItem(m_hwnd, IDC_LIST_AVAILABLE_NODES));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnMeasureItem(MEASUREITEMSTRUCT *pMeasureItemStruct)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnMeasureItem
(
    MEASUREITEMSTRUCT *pMeasureItemStruct
)
{
    HRESULT     hr = S_OK;
    HDC         hdc = NULL;
    BOOL        bResult = FALSE;
    TEXTMETRIC  tm;

    DebugPrintf("OnMeasureItem() m_bEnabled=%d\r\n", m_bEnabled);

    if (true == m_bEnabled)
    {
        hdc = ::GetDC(m_hwnd);
        if (NULL == hdc)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        bResult = ::GetTextMetrics(hdc, &tm);
        if (FALSE == bResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        pMeasureItemStruct->itemWidth = 0;
        pMeasureItemStruct->itemHeight = tm.tmHeight;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnDrawItem(DRAWITEMSTRUCT *pDrawItemStruct)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnDrawItem
(
    DRAWITEMSTRUCT *pDrawItemStruct
)
{
    HRESULT            hr = S_OK;
    CCheckedListItem  *pCheckedListItem = NULL;

    ASSERT(NULL != m_pCheckList, "OnDrawItem: m_pCheckList is NULL");

    DebugPrintf("OnDrawItem() m_bEnabled=%d\r\n", m_bEnabled);

    if (true == m_bEnabled)
    {
        hr = m_pCheckList->GetItemData(pDrawItemStruct->itemID, reinterpret_cast<void **>(&pCheckedListItem));
        IfFailGo(hr);

        hr = m_pCheckList->DrawItem(pDrawItemStruct, pCheckedListItem->m_bSelected);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnDestroy()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnDestroy()
{
    HRESULT            hr = S_OK;
    long               lCount = 0;
    long               lIndex = 0;
    CCheckedListItem  *pCheckedListItem = NULL;

    if (NULL != m_pCheckList)
    {
        lCount = ::SendMessage(m_pCheckList->Window(), LB_GETCOUNT, 0, 0);
        if (LB_ERR != lCount)
        {
            for (lIndex = 0; lIndex < lCount; ++lIndex)
            {
                hr = m_pCheckList->GetItemData(lIndex, reinterpret_cast<void **>(&pCheckedListItem));
                if (NULL != pCheckedListItem)
                    delete pCheckedListItem;
            }
        }

        m_pCheckList->Detach();
        delete m_pCheckList;
        m_pCheckList = NULL;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::AddSnapInToList(HKEY hkeyNodeTypes, const TCHAR *pszKeyName)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::AddSnapInToList
(
    HKEY         hkeyNodeTypes,
    const TCHAR *pszKeyName
)
{
    HRESULT            hr = S_OK;
    long               lResult = 0;
    HKEY               hkeyRegisteredSnapIn = NULL;
    unsigned long      lBufSize = kSIMaxBuffer;
    TCHAR              pszName[kSIMaxBuffer + 1];
    CMMCNodeType      *pMMCNodeType = NULL;
    int                iIndex = 0;
    BSTR               bstrNodeTypeGUID = NULL;
    IExtendedSnapIn   *piExtendedSnapIn = NULL;

    lResult = RegOpenKeyEx(hkeyNodeTypes, pszKeyName, 0, KEY_READ, &hkeyRegisteredSnapIn);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    lResult = RegQueryValue(hkeyRegisteredSnapIn, NULL, pszName, reinterpret_cast<long *>(&lBufSize));
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    pMMCNodeType = New CMMCNodeType(pszName, pszKeyName);
    if (NULL == pMMCNodeType)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    if (0 == _tcslen(pszName))
    {
        hr = m_pCheckList->AddString(pszKeyName, &iIndex);
        IfFailGo(hr);
    }
    else
    {
        hr = m_pCheckList->AddString(pszName, &iIndex);
        IfFailGo(hr);
    }

    hr = m_pCheckList->SetItemData(iIndex, pMMCNodeType);
    IfFailGo(hr);

    hr = BSTRFromANSI(pszKeyName, &bstrNodeTypeGUID);
    IfFailGo(hr);

    hr = FindSnapIn(bstrNodeTypeGUID, &piExtendedSnapIn);
    IfFailGo(hr);

    if (S_OK == hr)
    {
        hr = m_pCheckList->SetItemCheck(iIndex, VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtendedSnapIn);
    FREESTRING(bstrNodeTypeGUID);
    if (NULL != hkeyRegisteredSnapIn)
        RegCloseKey(hkeyRegisteredSnapIn);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::PopulateAvailNodesDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::PopulateAvailNodesDialog()
{
    HRESULT            hr = S_OK;
    long               lResult = 0;
    HKEY               hkeyNodeTypes = 0;
    DWORD              dwIndex = 0;
    TCHAR              pszKeyName[kSIMaxBuffer + 1];
    TCHAR              pszClass[kSIMaxBuffer + 1];
    unsigned long      lBufSize = kSIMaxBuffer;
    FILETIME           fileTime;

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes"), 0, KEY_READ, &hkeyNodeTypes);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    while (1)
    {
        lResult = RegEnumKeyEx(hkeyNodeTypes,
                               dwIndex,
                               pszKeyName,
                               &lBufSize,
                               0,
                               pszClass,
                               &lBufSize,
                               &fileTime);
        if (ERROR_NO_MORE_ITEMS == lResult)
            break;
        if (ERROR_SUCCESS != lResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        hr = AddSnapInToList(hkeyNodeTypes, pszKeyName);
        IfFailGo(hr);

        pszKeyName[0] = '\0';
        pszClass[0] = '\0';
        lBufSize = kSIMaxBuffer;
        ++dwIndex;
    }

Error:
    if (NULL != hkeyNodeTypes)
        RegCloseKey(hkeyNodeTypes);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnNewAvailNode()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnNewAvailNode()
{
    HRESULT       hr = S_OK;
    CMMCNodeType *pMMCNodeType = NULL;
    int           iResult = 0;
    int           iIndex = 0;

    pMMCNodeType = New CMMCNodeType("", "");
    if (NULL == pMMCNodeType)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    iResult = ::DialogBoxParam(GetResourceHandle(),
                               MAKEINTRESOURCE(IDD_DIALOG_ADD_TO_AVAILABLE),
                               m_hwnd,
                               reinterpret_cast<DLGPROC>(NodeTypeDialogProc),
                               reinterpret_cast<LPARAM>(pMMCNodeType));
    if (-1 == iResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (1 == iResult)
    {
        if (0 != ::strlen(pMMCNodeType->m_pszName))
        {
            hr = m_pCheckList->AddString(pMMCNodeType->m_pszName, &iIndex);
            IfFailGo(hr);
        }
        else
        {
            hr = m_pCheckList->AddString(pMMCNodeType->m_pszGuid, &iIndex);
            IfFailGo(hr);
        }

        hr = m_pCheckList->SetItemData(iIndex, pMMCNodeType);
        IfFailGo(hr);

        // Select this node-type.
        hr = m_pCheckList->SetItemCheck(iIndex, VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnProperties(CMMCNodeType *pMMCNodeType)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnProperties
(
    CMMCNodeType *pMMCNodeType
)
{
    HRESULT          hr = S_OK;
    int              iResult = 0;

    iResult = ::DialogBoxParam(GetResourceHandle(),
                               MAKEINTRESOURCE(IDD_DIALOG_ADD_TO_AVAILABLE),
                               m_hwnd,
                               reinterpret_cast<DLGPROC>(NodeTypeDialogProc),
                               reinterpret_cast<LPARAM>(pMMCNodeType));
    if (-1 == iResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::NodeTypeDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
BOOL CALLBACK CSnapInAvailNodesPage::NodeTypeDialogProc
(
    HWND   hwndDlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    CMMCNodeType *pMMCNodeType = NULL;
    TCHAR         pszBuffer[kSIMaxBuffer + 1];
    HRESULT       hr = S_OK;
    WCHAR        *pwszGUID = NULL;
    int           nRet = 0;

    if (WM_INITDIALOG == uMsg)
    {
        pMMCNodeType = reinterpret_cast<CMMCNodeType *>(lParam);
        ::SetWindowLong(hwndDlg, DWL_USER, reinterpret_cast<LONG>(pMMCNodeType));

        if (NULL != pMMCNodeType)
        {
            ::SetDlgItemText(hwndDlg, IDC_EDIT_AVAIL_NODE_GUID, pMMCNodeType->m_pszGuid);
            ::SetDlgItemText(hwndDlg, IDC_EDIT_AVAIL_NODE_NAME, pMMCNodeType->m_pszName);

            // If we are showing properties for an existing node type then disable
            // the edit controls and hide the Cancel button

            if (::strlen(pMMCNodeType->m_pszGuid) > 0)
            {
                ::EnableWindow(::GetDlgItem(hwndDlg, IDC_EDIT_AVAIL_NODE_NAME), FALSE);
                ::EnableWindow(::GetDlgItem(hwndDlg, IDC_EDIT_AVAIL_NODE_GUID), FALSE);
                ::ShowWindow(::GetDlgItem(hwndDlg, IDCANCEL), SW_HIDE);
            }
            else
            {
                // The user has asked to add a new node type. Disable the OK
                // button until something has been typed in.
                ::EnableWindow(::GetDlgItem(hwndDlg, IDOK), FALSE);
            }
        }

        return TRUE;
    }

    pMMCNodeType = reinterpret_cast<CMMCNodeType *>(::GetWindowLong(hwndDlg, DWL_USER));

    switch (uMsg)
    {
    case WM_HELP:
        g_GlobalHelp.ShowHelp(HID_mssnapd_AddToAvailableNodes);
        return TRUE;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
		case IDOK:
		{
            // Get the node type string entered by the user

            ::GetDlgItemText(hwndDlg, IDC_EDIT_AVAIL_NODE_GUID, reinterpret_cast<LPTSTR>(pszBuffer), kSIMaxBuffer);

            // Convert to wide char

            hr = ::WideStrFromANSI(pszBuffer, &pwszGUID);
            if (FAILED(hr))
            {
                //UNDONE: generate error message here
                GLOBAL_EXCEPTION_CHECK(hr);
                ::EndDialog(hwndDlg, 0);
            }

            // Check that the GUID string entered is indeed a GUID

            CLSID clsid = CLSID_NULL;
            hr = ::CLSIDFromString(pwszGUID, &clsid);
            CtlFree(pwszGUID);
            if (CO_E_CLASSSTRING == hr)
            {
                hr = ::SDU_DisplayMessage(IDS_INVALID_GUID,
                                          MB_OK | MB_ICONHAND,
                                          HID_mssnapd_InvalidGuid, 0,
                                          DontAppendErrorInfo, &nRet);
                if (FAILED(hr))
                {
                    GLOBAL_EXCEPTION_CHECK(hr);
                }
                if ( FAILED(hr) || (IDCANCEL == nRet) )
                {
                    ::EndDialog(hwndDlg, 0);
                }
                else
                {
                    return TRUE;
                }
            }

            if (NULL != pMMCNodeType->m_pszGuid)
                CtlFree(pMMCNodeType->m_pszGuid);
            pMMCNodeType->m_pszGuid = reinterpret_cast<char *>(CtlAlloc(::strlen(pszBuffer) + 1));
            if (NULL == pMMCNodeType->m_pszGuid)
            {
                //UNDONE: generate error message here
                GLOBAL_EXCEPTION_CHECK(SID_E_OUTOFMEMORY);
                ::EndDialog(hwndDlg, 0);
                return TRUE;
            }
            ::strcpy(pMMCNodeType->m_pszGuid, pszBuffer);

            ::GetDlgItemText(hwndDlg, IDC_EDIT_AVAIL_NODE_NAME, reinterpret_cast<LPTSTR>(pszBuffer), kSIMaxBuffer);
            if (NULL != pMMCNodeType->m_pszName)
                CtlFree(pMMCNodeType->m_pszName);
            pMMCNodeType->m_pszName = reinterpret_cast<char *>(CtlAlloc(::strlen(pszBuffer) + 1));
            if (NULL == pMMCNodeType->m_pszName)
            {
                //UNDONE: generate error message here
                GLOBAL_EXCEPTION_CHECK(SID_E_OUTOFMEMORY);
                ::EndDialog(hwndDlg, 0);
            }
            ::strcpy(pMMCNodeType->m_pszName, pszBuffer);

             // return 1 to indicate user entered valid data
            ::EndDialog(hwndDlg, 1);
            return TRUE;
            break;
		}

        case IDCANCEL:
            ::EndDialog(hwndDlg, 0);
            return TRUE;
            break;

        case IDHELP:
            g_GlobalHelp.ShowHelp(HID_mssnapd_AddToAvailableNodes);
            return TRUE;
            break;

        case IDC_EDIT_AVAIL_NODE_GUID:
            if (EN_CHANGE == HIWORD(wParam))
            {
                // If the GUID edit field is empty then disable the OK button
                if (0 == ::GetDlgItemText(hwndDlg, IDC_EDIT_AVAIL_NODE_GUID,
                                          pszBuffer, kSIMaxBuffer))
                {
                    ::EnableWindow(::GetDlgItem(hwndDlg, IDOK), FALSE);
                }
                else
                {
                    ::EnableWindow(::GetDlgItem(hwndDlg, IDOK), TRUE);
                }
            }
            break;
        }
        break;
    }

    return FALSE;
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnDefault(UINT uiMsg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnDefault(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;

    switch (uiMsg)
    {
    case kCheckBoxChanged:
        hr = S_OK; // message was handled
        MakeDirty();
        break;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::FindSnapIn(BSTR bstrNodeTypeGUID, IExtendedSnapIn **ppiExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::FindSnapIn(BSTR bstrNodeTypeGUID, IExtendedSnapIn **ppiExtendedSnapIn)
{
    HRESULT              hr = S_FALSE;
    IExtensionDefs      *piExtensionDefs = NULL;
    IExtendedSnapIns    *piExtendedSnapIns = NULL;
    long                 lCount = 0;
    long                 lIndex = 0;
    VARIANT              vtIndex;
    IExtendedSnapIn     *piExtendedSnapIn = NULL;
    BSTR                 bstrThisNodeGUID = NULL;

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendedSnapIns(&piExtendedSnapIns);
    IfFailGo(hr);

    hr = piExtendedSnapIns->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = piExtendedSnapIns->get_Item(vtIndex, &piExtendedSnapIn);
        IfFailGo(hr);

        hr = piExtendedSnapIn->get_NodeTypeGUID(&bstrThisNodeGUID);
        IfFailGo(hr);

        if (0 == ::wcscmp(bstrNodeTypeGUID, bstrThisNodeGUID))
        {
            *ppiExtendedSnapIn = piExtendedSnapIn;
            piExtendedSnapIn->AddRef();
            hr = S_OK;
            goto Error;
        }

        FREESTRING(bstrThisNodeGUID);
        RELEASE(piExtendedSnapIn);
    }

    hr = S_FALSE;

Error:
    FREESTRING(bstrThisNodeGUID);
    ::VariantClear(&vtIndex);
    RELEASE(piExtendedSnapIn);
    RELEASE(piExtendedSnapIns);
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::AddSnapIn(CMMCNodeType *pCMMCNodeType)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::AddSnapIn(CMMCNodeType *pCMMCNodeType)
{
    HRESULT              hr = S_OK;
    BSTR                 bstrNodeTypeGUID = NULL;
    IExtendedSnapIn     *piExtendedSnapIn = NULL;
    IExtensionDefs      *piExtensionDefs = NULL;
    IExtendedSnapIns    *piExtendedSnapIns = NULL;
    VARIANT              vtIndex;
    VARIANT              vtKey;
    BSTR                 bstrNodeTypeName = NULL;

    ASSERT(NULL != pCMMCNodeType, "AddSnapIn: pCMMCNodeType is NULL");

    ::VariantInit(&vtIndex);
    ::VariantInit(&vtKey);

    hr = ::BSTRFromANSI(pCMMCNodeType->m_pszGuid, &bstrNodeTypeGUID);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendedSnapIns(&piExtendedSnapIns);
    IfFailGo(hr);

    vtIndex.vt = VT_ERROR;
    vtIndex.scode = DISP_E_PARAMNOTFOUND;
    vtKey.vt = VT_BSTR;
    vtKey.bstrVal = ::SysAllocString(bstrNodeTypeGUID);
    if (NULL == vtKey.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = piExtendedSnapIns->Add(vtIndex, vtKey, &piExtendedSnapIn);
    IfFailGo(hr);

    hr = piExtendedSnapIn->put_NodeTypeGUID(bstrNodeTypeGUID);
    IfFailGo(hr);

    hr = BSTRFromANSI(pCMMCNodeType->m_pszName, &bstrNodeTypeName);
    IfFailGo(hr);

    hr = piExtendedSnapIn->put_NodeTypeName(bstrNodeTypeName);
    IfFailGo(hr);

Error:
    ::VariantClear(&vtIndex);
    ::VariantClear(&vtKey);
    FREESTRING(bstrNodeTypeName);
    FREESTRING(bstrNodeTypeGUID);
    RELEASE(piExtendedSnapIn);
    RELEASE(piExtendedSnapIns);
    RELEASE(piExtensionDefs);
    FREESTRING(bstrNodeTypeGUID);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::RemoveSnapIn(CMMCNodeType *pCMMCNodeType)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::RemoveSnapIn(CMMCNodeType *pCMMCNodeType)
{
    HRESULT              hr = S_OK;
    BSTR                 bstrNodeTypeGUID = NULL;
    IExtensionDefs      *piExtensionDefs = NULL;
    IExtendedSnapIns    *piExtendedSnapIns = NULL;
    VARIANT              vtKey;

    ASSERT(NULL != pCMMCNodeType, "RemoveSnapIn: pCMMCNodeType is NULL");

    ::VariantInit(&vtKey);

    hr = BSTRFromANSI(pCMMCNodeType->m_pszGuid, &bstrNodeTypeGUID);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendedSnapIns(&piExtendedSnapIns);
    IfFailGo(hr);

    vtKey.vt = VT_BSTR;
    vtKey.bstrVal = ::SysAllocString(bstrNodeTypeGUID);
    if (NULL == vtKey.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = piExtendedSnapIns->Remove(vtKey);
    IfFailGo(hr);

Error:
    ::VariantClear(&vtKey);
    RELEASE(piExtendedSnapIns);
    RELEASE(piExtensionDefs);
    FREESTRING(bstrNodeTypeGUID);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\ppage.h ===
//=--------------------------------------------------------------------------------------
// ppage.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Snap-In Designer Property Page class. All of our property pages subclass this class,
// which is based on the framework's CPropertyPage.
//=-------------------------------------------------------------------------------------=

#ifndef _SIPROPERTYPAGE_H_
#define _SIPROPERTYPAGE_H_

// Size of internal buffer we use for string handling: resource loading and
// string conversion.
const int           kSIMaxBuffer = 512;

// We implement a minimum error handler that returns the following values
// after being invoked:
const int           kSICancelOperation = 1;
const int           kSIDiscardChanges  = 2;

class CSIPropertyPage : public CPropertyPage, public CError
{
public:
    CSIPropertyPage(IUnknown *pUnkOuter, int iObjectType);
    virtual ~CSIPropertyPage();

// Overridable member functions
protected:
    // Delegation from CPropertyPage
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnEditProperty(int iDispID);
    virtual HRESULT OnFreeObjects();

    // Delegation from our WinProc
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnDeltaPos(NMUPDOWN *pNMUpDown);
    virtual HRESULT OnTextChanged(int dlgItemID);
    virtual HRESULT OnKillFocus(int dlgItemID);
    virtual HRESULT OnCtlSelChange(int dlgItemID);
    virtual HRESULT OnCtlSetFocus(int dlgItemID);
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnMeasureItem(MEASUREITEMSTRUCT *pMeasureItemStruct);
    virtual HRESULT OnDrawItem(DRAWITEMSTRUCT *pDrawItemStruct);
    virtual HRESULT OnDefault(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    virtual HRESULT OnDestroy();
    virtual HRESULT OnCBDropDown(int dlgItemID);

protected:
    // Error handling. May be invoked by subclasses.
    HRESULT HandleCantCommit(TCHAR *pszTitle, TCHAR *pszMessage, int *pDisposition);
    HRESULT HandleError(TCHAR *pszTitle, TCHAR *pszMessage);

    // Allows a derived class to determine if the page is dirty
    BOOL IsDirty() {return S_OK == IsPageDirty();}

// Services provided to subclasses
protected:
    HRESULT RegisterTooltip(int iCtrlID, int iStringRsrcID);

    HRESULT InitializeEditCtl(BSTR bstr, int iCtrlID, int iStrRscrID = 0);
    HRESULT InitializeEditCtl(long lValue, int iCtrlID, int iStrRscrID);
    HRESULT InitializeEditCtl(VARIANT vt, int iCtrlID, int iStrRscrID);
    HRESULT InitializeCheckboxCtl(VARIANT_BOOL bValue, int iCtrlID, int iStrRscrID);

    HRESULT GetDlgText(int iDlgItem, BSTR *pBstr);
    HRESULT GetDlgInt(int iDlgItem, int *piInt);
    HRESULT GetDlgVariant(int iDlgItem, VARIANT *pvt);
    HRESULT GetCheckbox(int iDlgItem, VARIANT_BOOL *pbValue);
    HRESULT GetCBSelection(int iDlgItem, BSTR *pBstr);
    HRESULT GetCBSelectedItemData(int iDlgItem, long *plData);

    HRESULT SetDlgText(int iDlgItem, BSTR bstr);
    HRESULT SetDlgText(int iDlgItem, long lValue);
    HRESULT SetDlgText(VARIANT vt, int iCtrlID);
    HRESULT SetCheckbox(int iDlgItem, VARIANT_BOOL bValue);
    HRESULT SetCBItemSelection(int iCtrlID, long lValue);
    HRESULT AddCBBstr(int iCtrlID, BSTR bstr, long lValue = -1);
    HRESULT SelectCBBstr(int iCtrlID, BSTR bstr);

private:
    // Implementation details
    HRESULT InternalOnInitializeDialog(HWND hwndDlg);
    HRESULT InternalOnTextChanged(int dlgItemID);
    HRESULT InternalOnKillFocus(int dlgItemID);
    HRESULT InternalOnDestroy();

    virtual BOOL DialogProc(HWND, UINT, WPARAM, LPARAM);

protected:
    HWND    m_hwndTT;
    bool    m_bInitialized;
    bool    m_bSilentUpdate;
};


#endif  // _SIPROPERTYPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\ppage.cpp ===
//=--------------------------------------------------------------------------------------
// ppage.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Snap-In Designer Property Page implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "ppage.h"

// for ASSERT and FAIL
//
SZTHISFILE


OLECHAR g_wstrEmptyy[] = L"";


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::CSIPropertyPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSIPropertyPage::CSIPropertyPage
(
    IUnknown *pUnkOuter,
    int       iObjectType
)
: CPropertyPage(pUnkOuter, iObjectType), m_bInitialized(false), m_bSilentUpdate(false)
{
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::~CSIPropertyPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSIPropertyPage::~CSIPropertyPage()
{
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::DialogProc()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
BOOL CSIPropertyPage::DialogProc
(
    HWND   hwnd, 
    UINT   uMsg, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    HRESULT     hr = S_OK;
    BOOL        bResult = FALSE;
    HRESULT    *pHr = NULL;
    LPNMHDR     pnmh = NULL;

    switch (uMsg)
    {
    case PPM_NEWOBJECTS:
        // The control has been given some new objects.
        // The control is expected to go and populate its page's controls with information from this object.
        // Using the FirstControl() and NextControl() methods from the CPropertyPage class, the control can
        // get the relevant information.
        hr = OnNewObjects();
        bResult = TRUE;
        if (lParam != NULL)
        {
            pHr = reinterpret_cast<HRESULT *>(lParam);
            *pHr = hr;
        }

        break;

    case PPM_APPLY:
        // The control has to apply any changes that have occurred now.
        // Again, you can use the FirstControl() and NextControl() routines to loop through all the objects
        // for which the property pages were visible and apply the values (note that it's possible for there
        // to be more than one object for which a property page is being displayed).
        // The framework send an PPM_APPLY every time a page is deactivated. We only care for this event
        // if the page is dirty.
        if (IsPageDirty() == S_OK)
        {
            hr = OnApply();
        }
        else
            hr = S_OK;

        if (lParam != NULL)
        {
            pHr = reinterpret_cast<HRESULT *>(lParam);
            *pHr = hr;
        }
        bResult = TRUE;
        break;

    case PPM_EDITPROPERTY:
        // When the control is sent this message, the control is expected to set the focus to the control
        // instance which represents the property of the given dispid.  You will typically only see this
        // message called if you implement IPerPropertyBrowsing and return a value in MapPropertyToPage.
        hr = OnEditProperty(static_cast<int>(wParam));
        bResult = TRUE;
        if (lParam != NULL)
        {
            pHr = reinterpret_cast<HRESULT *>(lParam);
            *pHr = hr;
        }

        break;

    case PPM_FREEOBJECTS:
        // Various people will find it interesting to stash, in some way, the pointers they receive in
        // PPM_NEWOBJECTS.  This message tells them that it is time to free them, as the objects are no 
        // longer valid.  This can be called from the property page's destructor, so people should be careful
        // not to make too many assumptions about the property page.
        hr = OnFreeObjects();
        bResult = TRUE;
        if (lParam != NULL)
        {
            pHr = reinterpret_cast<HRESULT *>(lParam);
            *pHr = hr;
        }

        break;

    case WM_MEASUREITEM:
        hr = OnMeasureItem(reinterpret_cast<LPMEASUREITEMSTRUCT>(lParam));
        IfFailGo(hr);
        bResult = TRUE;
        break;

    case WM_ERASEBKGND:
        if (NULL != m_hwndTT)
        {
            ::SetWindowPos(m_hwndTT,
                           HWND_TOPMOST,
                           0, 0, 0, 0,
                           SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
        }
        bResult = FALSE;
        break;

    case WM_DRAWITEM:
        hr = OnDrawItem(reinterpret_cast<LPDRAWITEMSTRUCT>(lParam));
        IfFailGo(hr);
        bResult = TRUE;
        break;

    case WM_INITDIALOG:
        hr = InternalOnInitializeDialog(hwnd);
        IfFailGo(hr);
        bResult = TRUE;
        break;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case EN_CHANGE:
            hr = InternalOnTextChanged(LOWORD(wParam));
            IfFailGo(hr);
            bResult = TRUE;
            break;

        case EN_KILLFOCUS:
            hr = InternalOnKillFocus(LOWORD(wParam));
            IfFailGo(hr);
            bResult = TRUE;
            break;

        case CBN_SELCHANGE:
        // also handles LBN_SELCHANGE which has the same value as CBN_SELCHANGE
            hr = OnCtlSelChange(LOWORD(wParam));
            IfFailGo(hr);
            bResult = TRUE;
            break;

        case CBN_DROPDOWN:
            hr = OnCBDropDown(LOWORD(wParam));
            IfFailGo(hr);
            bResult = TRUE;
            break;

        case LBN_SETFOCUS:
            hr = OnCtlSetFocus(LOWORD(wParam));
            IfFailGo(hr);
            bResult = TRUE;
            break;

        case BN_CLICKED:
            hr = OnButtonClicked(LOWORD(wParam));
            IfFailGo(hr);
            bResult = TRUE;
            break;
        }
        break;

    case WM_NOTIFY:
        pnmh = reinterpret_cast<LPNMHDR>(lParam);
        switch (pnmh->code)
        {
        case UDN_DELTAPOS:
            hr = OnDeltaPos(reinterpret_cast<NMUPDOWN *>(lParam));
            IfFailGo(hr);
            bResult = TRUE;
            break;
        }
        break;

    case WM_DESTROY:
        hr = InternalOnDestroy();
        IfFailGo(hr);
        bResult = TRUE;
        break;

    default:
        hr = OnDefault(uMsg, wParam, lParam);
        IfFailGo(hr);
        bResult = (hr == S_OK) ? TRUE : FALSE;
        break;
    }

Error:
    return bResult;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InternalOnInitializeDialog(HWND hwndDlg)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InternalOnInitializeDialog
(
    HWND hwndDlg
)
{
    HRESULT                 hr = S_OK;

    ASSERT(hwndDlg != NULL, "InternalOnInitializeDialog: hwndDlg is NULL");

    // Create the tooltip control
    m_hwndTT = ::CreateWindowEx(0,
                                TOOLTIPS_CLASS,
                                reinterpret_cast<LPSTR>(NULL),
                                TTS_ALWAYSTIP,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                hwndDlg,
                                reinterpret_cast<HMENU>(NULL),
                                GetResourceHandle(),
                                NULL);
    if (m_hwndTT == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    ::SendMessage(m_hwndTT, TTM_ACTIVATE, static_cast<WPARAM>(TRUE), 0);

    hr = OnInitializeDialog();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InternalOnTextChanged(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InternalOnTextChanged
(
    int dlgItemID
)
{
    HRESULT hr = S_OK;

    if (m_bInitialized == true)
    {
        hr = OnTextChanged(dlgItemID);
        IfFailGo(hr);
        if (hr == S_OK && true == m_bInitialized && false == m_bSilentUpdate)
            MakeDirty();
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InternalOnKillFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InternalOnKillFocus
(
    int dlgItemID
)
{
    HRESULT hr = S_OK;

    if (m_bInitialized == true)
    {
        hr = OnKillFocus(dlgItemID);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InternalOnDestroy()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InternalOnDestroy()
{
    HRESULT hr = S_OK;

    hr = OnDestroy();
    IfFailGo(hr);

    if (m_hwndTT == NULL)
    {
        ::DestroyWindow(m_hwndTT);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::HandleError(TCHAR *pszTitle, TCHAR *pszMessage)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::HandleError(TCHAR *pszTitle, TCHAR *pszMessage)
{
    HRESULT     hr = S_OK;

    ::MessageBox(m_hwnd, pszMessage, pszTitle, MB_OK | MB_ICONHAND);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::HandleCantCommit(int iCtrlID, int iStringRsrcID, int *pDisposition)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::HandleCantCommit(TCHAR *pszTitle, TCHAR *pszMessage, int *pDisposition)
{
    HRESULT     hr = S_OK;
    int         iDlgResult = 0;

    *pDisposition = 0;
    iDlgResult = ::MessageBox(m_hwnd, pszMessage, pszTitle, MB_YESNO | MB_ICONHAND);
    if (IDYES == iDlgResult)
        *pDisposition = kSIDiscardChanges;
    else
        *pDisposition = kSICancelOperation;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::RegisterTooltip(int iCtrlID, int iStringRsrcID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::RegisterTooltip
(
    int iCtrlID,
    int iStringRsrcID
)
{
    HRESULT     hr = S_OK;
    HWND        hwndCtrl = NULL;
    TOOLINFO    ti;
    RECT        rc;
    BOOL        bReturn = FALSE;

    hwndCtrl = ::GetDlgItem(m_hwnd, iCtrlID);
    if (hwndCtrl == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    bReturn = ::GetWindowRect(hwndCtrl, &rc);
    if (bReturn == FALSE)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::memset(&ti, 0, sizeof(TOOLINFO));

    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_IDISHWND  | TTF_SUBCLASS;
    ti.hwnd = m_hwnd;
    ti.uId = reinterpret_cast<unsigned int>(hwndCtrl);
    ti.rect = rc;
    ti.hinst = GetResourceHandle();
    ti.lpszText = reinterpret_cast<LPTSTR>(iStringRsrcID);
    ti.lParam = reinterpret_cast<LPARAM>(this);

    bReturn = ::SendMessage(m_hwndTT, TTM_ADDTOOL, 0, reinterpret_cast<LPARAM>(reinterpret_cast<LPTOOLINFO>(&ti)));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InitializeEditCtl(BSTR bstr, int iCtrlID, int iStrRscrID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InitializeEditCtl
(
    BSTR bstr,
    int  iCtrlID,
    int  iStrRscrID
)
{
    HRESULT hr = S_OK;
    char   *pstr = NULL;
    BOOL    bResult = FALSE;

    if (bstr != NULL && ::SysStringLen(bstr) > 0)
    {
        hr = ANSIFromBSTR(bstr, &pstr);
        IfFailGo(hr);

        bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pstr);
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else
    {
        bResult = ::SetDlgItemText(m_hwnd, iCtrlID, _T(""));
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }

    if (iStrRscrID != 0)
    {
        hr = RegisterTooltip(iCtrlID, iStrRscrID);
        IfFailGo(hr);
    }

Error:
    if (pstr != NULL)
        CtlFree(pstr);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InitializeEditCtl(long lValue, int iCtrlID, int iStrRscrID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InitializeEditCtl
(
    long lValue,
    int  iCtrlID,
    int  iStrRscrID
)
{
    HRESULT hr = S_OK;
    char    pszBuffer[kSIMaxBuffer];
    BOOL    bResult = FALSE;

    ::sprintf(pszBuffer, "%d", lValue);

    bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pszBuffer);
    if (bResult == FALSE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (iStrRscrID != 0)
    {
        hr = RegisterTooltip(iCtrlID, iStrRscrID);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InitializeEditCtl(VARIANT vt, int iCtrlID, int iStrRscrID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InitializeEditCtl
(
    VARIANT vt,
    int     iCtrlID,
    int     iStrRscrID
)
{
    HRESULT hr = S_OK;
    char    pszBuffer[kSIMaxBuffer];
    BOOL    bResult = FALSE;
    char   *pszAnsi = NULL;

    switch (vt.vt)
    {
    case VT_I2:
        ::sprintf(pszBuffer, "%d", vt.iVal);
        bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pszBuffer);
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case VT_I4:
        ::sprintf(pszBuffer, "%d", vt.lVal);
        bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pszBuffer);
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case VT_BSTR:
        hr = ANSIFromBSTR(vt.bstrVal, &pszAnsi);
        bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pszAnsi);
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        break;
    }

    if (iStrRscrID != 0)
    {
        hr = RegisterTooltip(iCtrlID, iStrRscrID);
        IfFailGo(hr);
    }

Error:
    if (NULL != pszAnsi)
        CtlFree(pszAnsi);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InitializeCheckboxCtl(VARIANT_BOOL bValue, int iCtrlID, int iStrRscrID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InitializeCheckboxCtl
(
    VARIANT_BOOL bValue,
    int          iCtrlID,
    int          iStrRscrID
)
{
    HRESULT hr = S_OK;
    BOOL    bResult = FALSE;

    if (bValue == VARIANT_TRUE)
    {
        ::SendMessage(::GetDlgItem(m_hwnd, iCtrlID), BM_SETCHECK, static_cast<WPARAM>(TRUE), 0);
    }
    else
    {
        ::SendMessage(::GetDlgItem(m_hwnd, iCtrlID), BM_SETCHECK, static_cast<WPARAM>(FALSE), 0);
    }

    if (iStrRscrID != 0)
    {
        hr = RegisterTooltip(iCtrlID, iStrRscrID);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::GetDlgText(int iDlgItem, BSTR *pBstr)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::GetDlgText
(
    int      iDlgItem,
    BSTR    *pBstr
)
{
    HRESULT hr = S_OK;
    char    szBuffer[kSIMaxBuffer + 1];
    UINT    uChars = 0;

    szBuffer[0] = 0;
    uChars = ::GetDlgItemText(m_hwnd, iDlgItem, szBuffer, kSIMaxBuffer);
    if (uChars == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);

        *pBstr = ::SysAllocString(g_wstrEmptyy);
        if (*pBstr == NULL)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        goto Error;
    }

    hr = BSTRFromANSI(szBuffer, pBstr);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::GetDlgInt(int iDlgItem, int *piInt)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Attempts to exract an integer from a control's text. If the text cannot
// be converted to an int then returns E_INVALIDARG.
//
HRESULT CSIPropertyPage::GetDlgInt
(
    int      iDlgItem,
    int     *piInt
)
{
    HRESULT hr = S_OK;
    char    szBuffer[kSIMaxBuffer + 1];
    UINT    uChars = 0;

    uChars = ::GetDlgItemText(m_hwnd, iDlgItem, szBuffer, kSIMaxBuffer);
    if (uChars == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    *piInt = 0;
    if (0 == ::sscanf(szBuffer, "%d", piInt))
    {
        hr = E_INVALIDARG;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::GetDlgVariant(int iDlgItem, VARIANT *pvt)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::GetDlgVariant
(
    int      iDlgItem,
    VARIANT *pvt
)
{
    HRESULT hr = S_OK;
    char    szBuffer[kSIMaxBuffer + 1];
    UINT    uChars = 0;
    bool    isNumeric = true;
    int     iMax = 0;
    int     iIndex = 0;

    ::VariantInit(pvt);

    szBuffer[0] = 0;
    uChars = ::GetDlgItemText(m_hwnd, iDlgItem, szBuffer, kSIMaxBuffer);
    if (uChars == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);

        goto Error;
    }

    iMax = ::strlen(szBuffer);
    for (iIndex = 0; iIndex < iMax; ++iIndex)
    {
        if (0 == ::isdigit(szBuffer[iIndex]))
        {
            isNumeric = false;
            break;
        }
    }

    if (true == isNumeric)
    {
        pvt->vt = VT_I4;
        pvt->lVal = ::atol(szBuffer);
    }
    else
    {
        pvt->vt = VT_BSTR;
        hr = BSTRFromANSI(szBuffer, &pvt->bstrVal);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::GetCheckbox(int iCtrlID, VARIANT_BOOL *pbValue)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::GetCheckbox
(
    int           iDlgItem,
    VARIANT_BOOL *pbValue
)
{
    HRESULT hr = S_OK;
    int     iValue = 0;

    iValue = ::SendMessage(::GetDlgItem(m_hwnd, iDlgItem), BM_GETCHECK, 0, 0);
    if (iValue == BST_CHECKED)
    {
        *pbValue = VARIANT_TRUE;
    }
    else
    {
        *pbValue = VARIANT_FALSE;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::GetCBSelection(int iDlgItem, BSTR *bstr)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::GetCBSelection
(
    int   iDlgItem,
    BSTR *pBstr
)
{
    HRESULT     hr = S_OK;
    HWND        hcb = NULL;
    int         iIndex = 0;
    char        szBuffer[kSIMaxBuffer + 1];
    int         cch = 0;

    hcb = ::GetDlgItem(m_hwnd, iDlgItem);
    if (hcb == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    iIndex = ::SendMessage(hcb, CB_GETCURSEL, 0, 0);
    if (iIndex == CB_ERR)
    {
        // No selection available
        hr = S_FALSE;
        goto Error;
    }

    cch = ::SendMessage(hcb, CB_GETLBTEXT, static_cast<WPARAM>(iIndex), reinterpret_cast<LPARAM>(reinterpret_cast<LPCSTR>(szBuffer)));
    if (cch == CB_ERR)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    hr = BSTRFromANSI(szBuffer, pBstr);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::GetCBSelectedItemData(int iDlgItem, void **pvData)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::GetCBSelectedItemData
(
    int   iDlgItem,
    long *plData
)
{
    HRESULT     hr = S_OK;
    HWND        hcb = NULL;
    int         iIndex = 0;

    *plData = -1;

    hcb = ::GetDlgItem(m_hwnd, iDlgItem);
    if (hcb == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    iIndex = ::SendMessage(hcb, CB_GETCURSEL, 0, 0);
    if (iIndex == CB_ERR)
    {
        // Nothing is selected
        hr = S_FALSE;
        goto Error;
    }

    *plData = ::SendMessage(hcb, CB_GETITEMDATA, static_cast<WPARAM>(iIndex), 0);
    if (*plData == CB_ERR)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::SetDlgText(int iDlgItem, BSTR bstr)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::SetDlgText
(
    int  iDlgItem,
    BSTR bstr
)
{
    HRESULT hr = S_OK;
    char   *pstr = NULL;
    BOOL    bResult = FALSE;

    if ( (bstr != NULL) && (::SysStringLen(bstr) > 0) )
    {
        hr = ANSIFromBSTR(bstr, &pstr);
        IfFailGo(hr);

        bResult = ::SetDlgItemText(m_hwnd, iDlgItem, pstr);
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else
    {
        bResult = ::SetDlgItemText(m_hwnd, iDlgItem, _T(""));
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }

Error:
    if (pstr != NULL)
        CtlFree(pstr);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::SetDlgText(int iDlgItem, long lValue)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::SetDlgText
(
    int  iDlgItem, 
    long lValue
)
{
    HRESULT hr = S_OK;
    char    strBuffer[kSIMaxBuffer + 1];
    BOOL    bResult = FALSE;

    ::sprintf(strBuffer, _T("%d"), lValue);

    bResult = ::SetDlgItemText(m_hwnd, iDlgItem, strBuffer);
    if (bResult == FALSE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::SetDlgText(VARIANT vt, int iCtrlID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::SetDlgText
(
    VARIANT vt,
    int     iCtrlID
)
{
    HRESULT hr = S_OK;
    char    pszBuffer[kSIMaxBuffer];
    BOOL    bResult = FALSE;
    char   *pszAnsi = NULL;

    switch (vt.vt)
    {
    case VT_I2:
        ::sprintf(pszBuffer, "%d", vt.iVal);
        bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pszBuffer);
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case VT_I4:
        ::sprintf(pszBuffer, "%d", vt.lVal);
        bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pszBuffer);
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case VT_BSTR:
        if (::SysStringLen(vt.bstrVal) > 0)
        {
            hr = ANSIFromBSTR(vt.bstrVal, &pszAnsi);
            bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pszAnsi);
            if (bResult == FALSE)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK_GO(hr);
            }
        }
        else
        {
            ::SetDlgItemText(m_hwnd, iCtrlID, _T(""));
        }
        break;
    }

Error:
    if (NULL != pszAnsi)
        CtlFree(pszAnsi);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::SetCheckbox(int iDlgItem, VARIANT_BOOL bValue)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::SetCheckbox
(
    int          iDlgItem, 
    VARIANT_BOOL bValue
)
{
    HRESULT hr = S_OK;

    if (bValue == VARIANT_TRUE)
        ::SendMessage(::GetDlgItem(m_hwnd, iDlgItem), BM_SETCHECK, static_cast<WPARAM>(TRUE), 0);
    else
        ::SendMessage(::GetDlgItem(m_hwnd, iDlgItem), BM_SETCHECK, static_cast<WPARAM>(FALSE), 0);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::SetCBItemSelection(int iCtrlID, long lValue)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::SetCBItemSelection
(
    int  iCtrlID, 
    long lValue
)
{
    HRESULT     hr = S_OK;
    HWND        hCombo = NULL;
    int         iCount = 0;
    int         iIndex = 0;
    long        lTestValue = 0;

    hCombo = ::GetDlgItem(m_hwnd, iCtrlID);
    if (hCombo == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    iCount = ::SendMessage(hCombo, CB_GETCOUNT, 0, 0);
    if (iCount == CB_ERR)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    hr = S_FALSE;
    for (iIndex = 0; iIndex < iCount; ++iIndex)
    {
        lTestValue = ::SendMessage(hCombo, CB_GETITEMDATA, static_cast<WPARAM>(iIndex), 0);
        if (lTestValue == CB_ERR)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        if (lTestValue == lValue)
        {
            ::SendMessage(hCombo, CB_SETCURSEL, static_cast<WPARAM>(iIndex), 0);

            hr = S_OK;
            break;
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::AddCBBstr(int iCtrlID, BSTR bstr, long lValue)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::AddCBBstr
(
    int  iCtrlID, 
    BSTR bstr, 
    long lValue
)
{
    HRESULT     hr = S_OK;
    HWND        hCombo = NULL;
    int         iIndex = 0;
    int         iResult = 0;
    char       *psz = NULL;

    hCombo = ::GetDlgItem(m_hwnd, iCtrlID);
    if (hCombo == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    hr = ANSIFromBSTR(bstr, &psz);
    IfFailGo(hr);

    iIndex = ::SendMessage(hCombo,
                           CB_ADDSTRING,
                           0,
                           reinterpret_cast<LPARAM>(psz));
    if (iIndex == CB_ERR || iIndex == CB_ERRSPACE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (lValue != -1)
    {
        iResult = ::SendMessage(hCombo,
                                CB_SETITEMDATA,
                                iIndex,
                                static_cast<LPARAM>(lValue));
        if (iResult == CB_ERR)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else
    {
        iResult = ::SendMessage(hCombo,
                                CB_SETITEMDATA,
                                iResult,
                                static_cast<LPARAM>(iIndex));
        if (iResult == CB_ERR)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }

Error:
    if (psz != NULL)
        CtlFree(psz);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::SelectCBBstr(int iCtrlID, BSTR bstr)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::SelectCBBstr
(
    int  iCtrlID,
    BSTR bstr
)
{
    HRESULT     hr = S_OK;
    char       *psz = NULL;
    int         iIndex = 0;

    if (NULL != bstr && ::SysStringLen(bstr) > 0)
    {
        hr = ANSIFromBSTR(bstr, &psz);
        IfFailGo(hr);

        iIndex = ::SendMessage(::GetDlgItem(m_hwnd, iCtrlID),
                               CB_FINDSTRINGEXACT,
                               static_cast<WPARAM>(-1),
                               reinterpret_cast<LPARAM>(psz));
        if (iIndex != CB_ERR)
        {
            ::SendMessage(::GetDlgItem(m_hwnd, iCtrlID), CB_SETCURSEL, static_cast<WPARAM>(iIndex), 0);
        }
    }

Error:
    if (psz != NULL)
        CtlFree(psz);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnNewObjects()
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnApply()
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnEditProperty(int iDispID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnEditProperty
(
    int iDispID
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnFreeObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnFreeObjects()
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnInitializeDialog()
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnDeltaPos(NMUPDOWN *pNMUpDown)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnDeltaPos
(
    NMUPDOWN *pNMUpDown
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnTextChanged(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnTextChanged
(
    int dlgItemID
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnKillFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnKillFocus
(
    int dlgItemID
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnCtlSelChange
(
    int dlgItemID
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnCtlSetFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnCtlSetFocus
(
    int dlgItemID
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnButtonClicked
(
    int dlgItemID
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnMeasureItem(MEASUREITEMSTRUCT *pMeasureItemStruct)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnMeasureItem
(
    MEASUREITEMSTRUCT *pMeasureItemStruct
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnDrawItem(DRAWITEMSTRUCT *pDrawItemStruct)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnDrawItem
(
    DRAWITEMSTRUCT *pDrawItemStruct
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnDefault(UINT uiMsg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnDefault(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return S_FALSE;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnDestroy
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnDestroy()
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnCBDropDown
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnCBDropDown(int dlgItemID)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psextend.h ===
//=--------------------------------------------------------------------------------------
// psextend.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Snap-In Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSEXTEND_H_
#define _PSEXTEND_H_

#include "ppage.h"
#include "chklst.h"


////////////////////////////////////////////////////////////////////////////////////
//
// Holder for available MMC Node Types
//
////////////////////////////////////////////////////////////////////////////////////
class CMMCNodeType : public CCheckedListItem
{
public:
    CMMCNodeType(const char *pszName, const char *pszGuid);
    virtual ~CMMCNodeType();

public:
    char    *m_pszName;
    char    *m_pszGuid;
};


////////////////////////////////////////////////////////////////////////////////////
//
// SnapIn Property Page "Available Nodes"
//
////////////////////////////////////////////////////////////////////////////////////


class CSnapInAvailNodesPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CSnapInAvailNodesPage(IUnknown *pUnkOuter);
    virtual ~CSnapInAvailNodesPage();

// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnCtlSelChange(int dlgItemID);
    virtual HRESULT OnCtlSetFocus(int dlgItemID);
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnMeasureItem(MEASUREITEMSTRUCT *pMeasureItemStruct);
    virtual HRESULT OnDrawItem(DRAWITEMSTRUCT *pDrawItemStruct);
    virtual HRESULT OnDefault(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    virtual HRESULT OnDestroy();

// Helpers to get attributes from component
protected:

// Helpers for Apply event
protected:

// Other helpers
protected:
    HRESULT PopulateAvailNodesDialog();
    HRESULT AddSnapInToList(HKEY hkeyNodeTypes, const TCHAR *pszKeyName);

    HRESULT OnNewAvailNode();
    HRESULT OnProperties(CMMCNodeType *pMMCNodeType);
    static BOOL CALLBACK NodeTypeDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT FindSnapIn(BSTR bstrNodeTypeGUID, IExtendedSnapIn **ppiExtendedSnapIn);
    HRESULT AddSnapIn(CMMCNodeType *pCMMCNodeType);
    HRESULT RemoveSnapIn(CMMCNodeType *pCMMCNodeType);

// Instance data
protected:
    ISnapInDesignerDef  *m_piSnapInDesignerDef;
    ISnapInDef          *m_piSnapInDef;
    CCheckList          *m_pCheckList;
    CMMCNodeType        *m_pMMCNodeType;
    bool                 m_bEnabled;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	SnapInAvailNodes,                   // Name
	&CLSID_SnapInDefExtensionsPP,       // Class ID
	"Snap-In Available Nodes Page",     // Registry display name
	CSnapInAvailNodesPage::Create,      // Create function
	IDD_DIALOG_AVAILABLE_NODES,         // Dialog resource ID
	IDS_SNAPINPPG_AVAIL,                // Tab caption
	IDS_SNAPINPPG_AVAIL,                // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_Extensions,             // Help context ID
	FALSE                               // Thread safe
);


#endif  // _PSEXTEND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\ocxvw.cpp ===
//=--------------------------------------------------------------------------------------
// ocxvw.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- OCXView-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "snaputil.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddOCXView()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddOCXView()
{
    HRESULT                hr = S_OK;
    IViewDefs             *piViewDefs = NULL;
    IOCXViewDefs          *piOCXViewDefs = NULL;
    VARIANT                vtEmpty;
    IOCXViewDef           *piOCXViewDef = NULL;

    hr = GetOwningViewCollection(&piViewDefs);
    IfFailGo(hr);

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
        IfFailGo(hr);

        if (piOCXViewDefs != NULL)
        {
            ::VariantInit(&vtEmpty);
            vtEmpty.vt = VT_ERROR;
            vtEmpty.scode = DISP_E_PARAMNOTFOUND;

            hr = piOCXViewDefs->Add(vtEmpty, vtEmpty, &piOCXViewDef);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piOCXViewDef);
    RELEASE(piOCXViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddExistingOCXView(IViewDefs *piViewDefs, IOCXViewDef *piOCXViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddExistingOCXView(IViewDefs *piViewDefs, IOCXViewDef *piOCXViewDef)
{
    HRESULT           hr = S_OK;
    IOCXViewDefs     *piOCXViewDefs = NULL;

    hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
    IfFailGo(hr);

    hr = piOCXViewDefs->AddFromMaster(piOCXViewDef);
    IfFailGo(hr);

Error:
    RELEASE(piOCXViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddOCXViewDef(CSelectionHolder *pParent, IOCXViewDef *piOCXViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Invoked in response to an IObjectModelHost:Add() notification.
//
HRESULT CSnapInDesigner::OnAddOCXViewDef(CSelectionHolder *pParent, IOCXViewDef *piOCXViewDef)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pOCXViewDef = NULL;
    IViewDefs           *piViewDefs = NULL;
    IOCXViewDefs        *piOCXViewDefs = NULL;

    ASSERT(NULL != pParent, "OnAddOCXViewDef: pParent is NULL");
    ASSERT(NULL != piOCXViewDef, "OnAddOCXViewDef: piOCXViewDef is NULL");

    switch (pParent->m_st)
    {
    case SEL_NODES_AUTO_CREATE_RTVW:
        hr = pParent->m_piObject.m_piSnapInDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_OCX:
        piOCXViewDefs = pParent->m_piObject.m_piOCXViewDefs;
        piOCXViewDefs->AddRef();
        break;

    case SEL_NODES_ANY_VIEWS:
        hr = pParent->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
        IfFailGo(hr);
        break;

    default:
        ASSERT(0, "OnAddOCXViewDef: Cannot determine owning collection");
        goto Error;
    }

    hr = MakeNewOCXView(piOCXViewDefs, piOCXViewDef, &pOCXViewDef);
    IfFailGo(hr);

    hr = InsertOCXViewInTree(pOCXViewDef, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pOCXViewDef);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pOCXViewDef);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pOCXViewDef);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RELEASE(piViewDefs);
    RELEASE(piOCXViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameOCXView(CSelectionHolder *pOCXView, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameOCXView(CSelectionHolder *pOCXView, BSTR bstrNewName)
{
    HRESULT              hr = S_OK;
    TCHAR               *pszName = NULL;

    ASSERT(SEL_VIEWS_OCX_NAME == pOCXView->m_st, "RenameOCXView: wrong argument");

    hr = m_piDesignerProgrammability->IsValidIdentifier(bstrNewName);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = pOCXView->m_piObject.m_piOCXViewDef->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    // Rename all satellite views
    hr = m_pTreeView->RenameAllSatelliteViews(pOCXView, pszName);
    IfFailGo(hr);

    // Rename the actual view
    hr = m_pTreeView->ChangeText(pOCXView, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteOCXView(CSelectionHolder *pOCXView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteOCXView
(
    CSelectionHolder *pOCXView
)
{
    HRESULT           hr = S_OK;
    bool              bIsSatelliteView = false;
    IObjectModel     *piObjectModel = NULL;
    long              lUsageCount = 0;
    BSTR              bstrName = NULL;
    IViewDefs        *piViewDefs = NULL;
    IOCXViewDefs     *piOCXViewDefs = NULL;
    VARIANT           vtKey;

    ::VariantInit(&vtKey);

    // We allow any satellite view to be deleted
    hr = IsSatelliteView(pOCXView);
    IfFailGo(hr);

    // But if it's a master with a UsageCount > 0 we don't allow deleting it.
    if (S_FALSE == hr)
    {
        hr = pOCXView->m_piObject.m_piOCXViewDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
        IfFailGo(hr);

        hr = piObjectModel->GetUsageCount(&lUsageCount);
        IfFailGo(hr);

        if (lUsageCount > 1)
        {
            (void)::SDU_DisplayMessage(IDS_VIEW_IN_USE, MB_OK | MB_ICONHAND, HID_mssnapd_ViewInUse, 0, DontAppendErrorInfo, NULL);
            goto Error;
        }
    }
    else
        bIsSatelliteView = true;

    hr = pOCXView->m_piObject.m_piOCXViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pOCXView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
        IfFailGo(hr);

        if (piOCXViewDefs != NULL)
        {
            vtKey.vt = VT_BSTR;
            vtKey.bstrVal = ::SysAllocString(bstrName);
            if (NULL == vtKey.bstrVal)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK(hr);
            }

            hr = piOCXViewDefs->Remove(vtKey);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piOCXViewDefs);
    RELEASE(piViewDefs);
    RELEASE(piObjectModel);
    FREESTRING(bstrName);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteOCXView(CSelectionHolder *pOCXView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteOCXView
(
    CSelectionHolder *pOCXView
)
{
    HRESULT            hr = S_OK;
    CSelectionHolder  *pParent = NULL;
    bool               bIsSatelliteView = false;
    IViewDefs         *piViewDefs = NULL;
    IOCXViewDefs      *piOCXViewDefs = NULL;
    long               lCount = 0;

    hr = IsSatelliteView(pOCXView);
    IfFailGo(hr);

    bIsSatelliteView = (S_OK == hr) ? true : false;

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pOCXView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pOCXView, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pOCXView);
    IfFailGo(hr);

    delete pOCXView;

    // Select the next selection
    if (NULL != piViewDefs)
    {
        hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
        IfFailGo(hr);

        hr = piOCXViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piOCXViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowOCXViewProperties(IOCXViewDef *piOCXViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowOCXViewProperties
(
    IOCXViewDef *piOCXViewDef
)
{
    HRESULT         hr = S_OK;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[1];

    hr = GetResourceString(IDS_OCX_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = piOCXViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_OCXViewDefGeneralPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 1;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = 0;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewOCXView(IOCXViewDefs *piOCXViewDefs, IOCXViewDef *piOCXViewDef, CSelectionHolder **ppOCXView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewOCXView
(
    IOCXViewDefs      *piOCXViewDefs,
    IOCXViewDef       *piOCXViewDef,
    CSelectionHolder **ppOCXView
)
{
    HRESULT                hr = S_OK;

    *ppOCXView = New CSelectionHolder(piOCXViewDef);
    if (*ppOCXView == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewOCXView(piOCXViewDefs, *ppOCXView);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewOCXView(IOCXViewDefs *piOCXViewDefs, CSelectionHolder *pOCXView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewOCXView
(
    IOCXViewDefs     *piOCXViewDefs,
    CSelectionHolder *pOCXView
)
{
    HRESULT           hr = S_OK;
    IObjectModel     *piObjectModel = NULL;
    CSelectionHolder *pViewCollection = NULL;
    int               iResult = 0;
    int               iItemNumber = 1;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    bool              bGood = false;
    CSelectionHolder *pOCXViewDefClone = NULL;

    hr = piOCXViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->GetCookie(reinterpret_cast<long *>(&pViewCollection));
    IfFailGo(hr);

    ASSERT(NULL != pViewCollection, "InitializeNewOCXView: Bad Cookie");

    hr = IsSatelliteCollection(pViewCollection);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = GetResourceString(IDS_OCX_VIEW, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        do {
            iResult = _stprintf(szName, _T("%s%d"), szBuffer, iItemNumber++);
            if (iResult == 0)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK(hr);
            }

			hr = m_pTreeView->FindLabelInTree(szName, &pOCXViewDefClone);
			IfFailGo(hr);

            if (S_FALSE == hr)
            {
				hr = BSTRFromANSI(szName, &bstrName);
				IfFailGo(hr);

                bGood = true;
                break;
            }

            FREESTRING(bstrName);
        } while (false == bGood);

        hr = pOCXView->m_piObject.m_piOCXViewDef->put_Name(bstrName);
        IfFailGo(hr);

        hr = pOCXView->m_piObject.m_piOCXViewDef->put_Key(bstrName);
        IfFailGo(hr);
    }

    hr = pOCXView->RegisterHolder();
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertOCXViewInTree(CSelectionHolder *pOCXView, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertOCXViewInTree
(
    CSelectionHolder *pOCXView,
    CSelectionHolder *pParent
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    TCHAR  *pszName = NULL;

    hr = pOCXView->m_piObject.m_piOCXViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kOCXViewIcon, pOCXView);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psmain.cpp ===
//=--------------------------------------------------------------------------------------
// psmain.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Snap-In Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "psmain.h"

#undef IMAGELIST_FIX

// for ASSERT and FAIL
//
SZTHISFILE


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// SnapIn Property Page "Snap-In Properties"
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CSnapInGeneralPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CSnapInGeneralPage::Create(IUnknown *pUnkOuter)
{
	CSnapInGeneralPage *pNew = New CSnapInGeneralPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::CSnapInGeneralPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSnapInGeneralPage::CSnapInGeneralPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGSNAPINGENERAL), m_piSnapInDesignerDef(0), m_piSnapInDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::~CSnapInGeneralPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSnapInGeneralPage::~CSnapInGeneralPage()
{
    RELEASE(m_piSnapInDesignerDef);
    RELEASE(m_piSnapInDef);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::OnInitializeDialog()
{
    HRESULT             hr = S_OK;

    hr = RegisterTooltip(IDC_RADIO_STAND_ALONE, IDS_TT_SN_STANDALONE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_EXTENSION, IDS_TT_SN_EXTENSION);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_DUAL, IDS_TT_SN_DUAL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_EXTENSIBLE, IDS_TT_SN_EXTENSIBLE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_NAME, IDS_TT_SN_NAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_NODE_TYPE, IDS_TT_SN_TYPENAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_DISPLAY, IDS_TT_SN_DISPLAY);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_PROVIDER, IDS_TT_SN_PROVIDER);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_VERSION, IDS_TT_SN_VERSION);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_DESCRIPTION, IDS_TT_SN_DESCRIPTION);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_VIEWS, IDS_TT_SN_DEFAULTVIEW);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    IObjectModel   *piObjectModel = NULL;
    VARIANT_BOOL    vtBool = VARIANT_FALSE;
    BSTR            bstrName = NULL;
    BSTR            bstrNodeTypeName = NULL;
    BSTR            bstrDisplayName = NULL;
    BSTR            bstrProvider = NULL;
    BSTR            bstrVersion = NULL;
    BSTR            bstrDescription = NULL;

    SnapInTypeConstants sitc = siStandAlone;

    if (NULL != m_piSnapInDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_ISnapInDef, reinterpret_cast<void **>(&m_piSnapInDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piSnapInDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&m_piSnapInDesignerDef);
    IfFailGo(hr);

    hr = InitializeNodeType();
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Extensible(&vtBool);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_EXTENSIBLE, vtBool);
    IfFailGo(hr);

    // If snap-in is extension then disable Extensible check box as there is
    // no static node that can be extensible. Also disable Static Node Type
    // Name edit box as there is no static node.

    IfFailGo(m_piSnapInDef->get_Type(&sitc));
    if (siExtension == sitc)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_EXTENSIBLE), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_NODE_TYPE), FALSE);
    }

    hr = m_piSnapInDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_NAME, bstrName);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_NodeTypeName(&bstrNodeTypeName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_NODE_TYPE, bstrNodeTypeName);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_DisplayName(&bstrDisplayName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_DISPLAY, bstrDisplayName);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Provider(&bstrProvider);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_PROVIDER, bstrProvider);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Version(&bstrVersion);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_VERSION, bstrVersion);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Description(&bstrDescription);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_DESCRIPTION, bstrDescription);
    IfFailGo(hr);

    hr = InitializeViews();
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    FREESTRING(bstrDescription);
    FREESTRING(bstrVersion);
    FREESTRING(bstrProvider);
    FREESTRING(bstrDisplayName);
    FREESTRING(bstrNodeTypeName);
    FREESTRING(bstrName);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::InitializeNodeType()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::InitializeNodeType()
{
    HRESULT             hr = S_OK;
    SnapInTypeConstants sitc = siStandAlone;

    ASSERT(NULL != m_piSnapInDef, "InitializeNodeType: m_piSnapInDef is NULL");

    hr = m_piSnapInDef->get_Type(&sitc);
    IfFailGo(hr);

    switch (sitc)
    {
    case siStandAlone:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_RADIO_STAND_ALONE), BM_SETCHECK, 1, 0);
        break;

    case siExtension:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_RADIO_EXTENSION), BM_SETCHECK, 1, 0);
        break;

    case siDualMode:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_RADIO_DUAL), BM_SETCHECK, 1, 0);
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::InitializeViews()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::InitializeViews()
{
    HRESULT     hr = S_OK;
    BSTR        bstrDefaultView = NULL;

    ASSERT(NULL != m_piSnapInDef, "InitializeViews: m_piSnapInDef is NULL");

    // First populate the combo box
    hr = PopulateViews();
    IfFailGo(hr);

    hr = m_piSnapInDef->get_DefaultView(&bstrDefaultView);
    IfFailGo(hr);

    if (::SysStringLen(bstrDefaultView) > 0)
    {
        hr = SelectCBBstr(IDC_COMBO_VIEWS, bstrDefaultView);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrDefaultView);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::PopulateViews()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::PopulateViews()
{
    HRESULT           hr = S_OK;
    IViewDefs        *piViewDefs = NULL;
    IListViewDefs    *piListViewDefs = NULL;
    IOCXViewDefs     *piOCXViewDefs = NULL;
    IURLViewDefs     *piURLViewDefs = NULL;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;
    long              lCount = 0;

    ASSERT(NULL != m_piSnapInDef, "PopulateViews: m_piSnapInDef is NULL");

    hr = m_piSnapInDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    if (NULL != piViewDefs)
    {
        hr = piViewDefs->get_ListViews(&piListViewDefs);
        IfFailGo(hr);

        hr = PopulateListViews(piListViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
        IfFailGo(hr);

        hr = PopulateOCXViews(piOCXViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_URLViews(&piURLViewDefs);
        IfFailGo(hr);

        hr = PopulateURLViews(piURLViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
        IfFailGo(hr);

        hr = PopulateTaskpadViews(piTaskpadViewDefs);
        IfFailGo(hr);
    }

    lCount = ::SendMessage(::GetDlgItem(m_hwnd, IDC_COMBO_VIEWS), CB_GETCOUNT, 0, 0);
    if (CB_ERR == lCount)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (0 == lCount)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_VIEWS), FALSE);
    }

Error:
    RELEASE(piListViewDefs);
    RELEASE(piOCXViewDefs);
    RELEASE(piURLViewDefs);
    RELEASE(piTaskpadViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::PopulateListViews(IListViewDefs *piListViewDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::PopulateListViews
(
    IListViewDefs *piListViewDefs
)
{
    HRESULT         hr = S_OK;
    long            lCount = 0;
    VARIANT         vtIndex;
    long            lIndex = 0;
    IListViewDef   *piListViewDef = NULL;
    BSTR            bstrName = NULL;

    hr = piListViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piListViewDefs->get_Item(vtIndex, &piListViewDef);
        IfFailGo(hr);

        hr = piListViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrName);
        IfFailGo(hr);

        RELEASE(piListViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piListViewDef);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::PopulateOCXViews(IOCXViewDefs *piOCXViewDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::PopulateOCXViews
(
    IOCXViewDefs *piOCXViewDefs
)
{
    HRESULT         hr = S_OK;
    long            lCount = 0;
    VARIANT         vtIndex;
    long            lIndex = 0;
    IOCXViewDef    *piOCXViewDef = NULL;
    BSTR            bstrName = NULL;

    hr = piOCXViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piOCXViewDefs->get_Item(vtIndex, &piOCXViewDef);
        IfFailGo(hr);

        hr = piOCXViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrName);
        IfFailGo(hr);

        RELEASE(piOCXViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piOCXViewDef);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::PopulateURLViews(IURLViewDefs *piURLViewDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::PopulateURLViews
(
    IURLViewDefs *piURLViewDefs
)
{
    HRESULT         hr = S_OK;
    long            lCount = 0;
    VARIANT         vtIndex;
    long            lIndex = 0;
    IURLViewDef    *piURLViewDef = NULL;
    BSTR            bstrName = NULL;

    hr = piURLViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piURLViewDefs->get_Item(vtIndex, &piURLViewDef);
        IfFailGo(hr);

        hr = piURLViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrName);
        IfFailGo(hr);

        RELEASE(piURLViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piURLViewDef);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::PopulateTaskpadViews(ITaskpadViewDefs *piTaskpadViewDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::PopulateTaskpadViews
(
    ITaskpadViewDefs *piTaskpadViewDefs
)
{
    HRESULT          hr = S_OK;
    long             lCount = 0;
    VARIANT          vtIndex;
    long             lIndex = 0;
    ITaskpadViewDef *piTaskpadViewDef = NULL;
    BSTR             bstrName = NULL;

    hr = piTaskpadViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piTaskpadViewDefs->get_Item(vtIndex, &piTaskpadViewDef);
        IfFailGo(hr);

        hr = piTaskpadViewDef->get_Key(&bstrName);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrName);
        IfFailGo(hr);

        RELEASE(piTaskpadViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piTaskpadViewDef);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(NULL != m_piSnapInDef, "OnApply: m_piSnapInDef is NULL");

    hr = ApplyNodeType();
    IfFailGo(hr);

    hr = ApplyExtensible();
    IfFailGo(hr);

    hr = ApplyName();
    IfFailGo(hr);

    hr = ApplyNodeTypeName();
    IfFailGo(hr);

    hr = ApplyDisplayName();
    IfFailGo(hr);

    hr = ApplyProvider();
    IfFailGo(hr);

    hr = ApplyVersion();
    IfFailGo(hr);

    hr = ApplyDescription();
    IfFailGo(hr);

    hr = ApplyDefaultView();
    IfFailGo(hr);
/*
    hr = ApplyImageList();
    IfFailGo(hr);
*/
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyExtensible()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyExtensible()
{
    HRESULT             hr = S_OK;
    VARIANT_BOOL        vtExtensible = VARIANT_FALSE;
    VARIANT_BOOL        vtSavedExtensible = VARIANT_FALSE;
    SnapInTypeConstants Type = siStandAlone;

    ASSERT(NULL != m_piSnapInDef, "ApplyExtensible: m_piSnapInDef is NULL");

    // If the snap-in is an extension then set SnapInDef.Extensible=False
    // so that a static node type will not be registered in MMC\NodeTypes
    // in the reg db.

    hr = m_piSnapInDef->get_Type(&Type);
    IfFailGo(hr);

    if (Type == siExtension)
    {
        vtExtensible = VARIANT_FALSE;
    }
    else
    {
        hr = GetCheckbox(IDC_CHECK_EXTENSIBLE, &vtExtensible);
        IfFailGo(hr);
    }

    hr = m_piSnapInDef->get_Extensible(&vtSavedExtensible);
    IfFailGo(hr);

    if (vtSavedExtensible != vtExtensible)
    {
        hr = m_piSnapInDef->put_Extensible(vtExtensible);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyNodeType()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyNodeType()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vbChecked = VARIANT_FALSE;

    ASSERT(NULL != m_piSnapInDef, "ApplyNodeType: m_piSnapInDef is NULL");

    hr = GetCheckbox(IDC_RADIO_STAND_ALONE, &vbChecked);
    IfFailGo(hr);

    if (VARIANT_TRUE == vbChecked)
    {
        hr = m_piSnapInDef->put_Type(siStandAlone);
        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_EXTENSION, &vbChecked);
    IfFailGo(hr);

    if (VARIANT_TRUE == vbChecked)
    {
        hr = m_piSnapInDef->put_Type(siExtension);
        goto Error;
    }

    hr = m_piSnapInDef->put_Type(siDualMode);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyName()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyName()
{
    HRESULT  hr = S_OK;
    BSTR     bstrNodeName = NULL;
    BSTR     bstrSavedNodeName = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplyName: m_piSnapInDef is NULL");

    hr = GetDlgText(IDC_EDIT_NAME, &bstrNodeName);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Name(&bstrSavedNodeName);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrNodeName, bstrSavedNodeName))
    {
        hr = m_piSnapInDef->put_Name(bstrNodeName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedNodeName);
    FREESTRING(bstrNodeName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyNodeTypeName()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyNodeTypeName()
{
    HRESULT  hr = S_OK;
    BSTR     bstrNodeTypeName = NULL;
    SnapInTypeConstants Type = siStandAlone;

    ASSERT(NULL != m_piSnapInDef, "ApplyNodeTypeName: m_piSnapInDef is NULL");

    // If the snap-in is an extension then set SnapInDef.NodeTypeName=NULL
    // as there is no static node

    hr = m_piSnapInDef->get_Type(&Type);
    IfFailGo(hr);

    if (Type == siExtension)
    {
        IfFailGo(m_piSnapInDef->put_NodeTypeName(NULL));
    }
    else
    {        
        hr = GetDlgText(IDC_EDIT_NODE_TYPE, &bstrNodeTypeName);
        IfFailGo(hr);

        IfFailGo(m_piSnapInDef->put_NodeTypeName(bstrNodeTypeName));
    }

Error:
     FREESTRING(bstrNodeTypeName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyDisplayName()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyDisplayName()
{
    HRESULT  hr = S_OK;
    BSTR     bstrDisplayName = NULL;
    BSTR     bstrSavedDisplayName = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplyDisplayName: m_piSnapInDef is NULL");

    hr = GetDlgText(IDC_EDIT_DISPLAY, &bstrDisplayName);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_DisplayName(&bstrSavedDisplayName);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrDisplayName, bstrSavedDisplayName))
    {
        hr = m_piSnapInDef->put_DisplayName(bstrDisplayName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedDisplayName);
    FREESTRING(bstrDisplayName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyProvider()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyProvider()
{
    HRESULT  hr = S_OK;
    BSTR     bstrProvider = NULL;
    BSTR     bstrSavedProvider = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplyProvider: m_piSnapInDef is NULL");

    hr = GetDlgText(IDC_EDIT_PROVIDER, &bstrProvider);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Provider(&bstrSavedProvider);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrProvider, bstrSavedProvider))
    {
        hr = m_piSnapInDef->put_Provider(bstrProvider);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedProvider);
    FREESTRING(bstrProvider);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyVersion()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyVersion()
{
    HRESULT  hr = S_OK;
    BSTR     bstrVersion = NULL;
    BSTR     bstrSavedVersion = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplyVersion: m_piSnapInDef is NULL");

    hr = GetDlgText(IDC_EDIT_VERSION, &bstrVersion);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Version(&bstrSavedVersion);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrVersion, bstrSavedVersion))
    {
        hr = m_piSnapInDef->put_Version(bstrVersion);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedVersion);
    FREESTRING(bstrVersion);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyDescription()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyDescription()
{
    HRESULT hr = S_OK;
    BSTR    bstrDescription = NULL;
    BSTR    bstrSavedDescription = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplyDescription: m_piSnapInDef is NULL");

    hr = GetDlgText(IDC_EDIT_DESCRIPTION, &bstrDescription);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Description(&bstrSavedDescription);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrDescription, bstrSavedDescription))
    {
        hr = m_piSnapInDef->put_Description(bstrDescription);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedDescription);
    FREESTRING(bstrDescription);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyDefaultView()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyDefaultView()
{
    HRESULT hr = S_OK;
    BSTR    bstrDefaultView = NULL;
    BSTR    bstrSavedDefaultView = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplyDefaultView: m_piSnapInDef is NULL");

    hr = GetCBSelection(IDC_COMBO_VIEWS, &bstrDefaultView);
    IfFailGo(hr);

    if (NULL != bstrDefaultView)
    {
        hr = m_piSnapInDef->get_DefaultView(&bstrSavedDefaultView);
        IfFailGo(hr);

        if (0 != ::wcscmp(bstrDefaultView, bstrSavedDefaultView))
        {
            hr = m_piSnapInDef->put_DefaultView(bstrDefaultView);
            IfFailGo(hr);
        }
    }

Error:
    FREESTRING(bstrSavedDefaultView);
    FREESTRING(bstrDefaultView);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyImageList()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyImageList()
{
    HRESULT             hr = S_OK;
/*
    BSTR                bstrImageList = NULL;
    IMMCImageList      *piMMCImageList = NULL;
    BSTR                bstrSavedImageList = NULL;
    IObjectModel       *piObjectModel = NULL;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;
    IMMCImageLists     *piMMCImageLists = NULL;
    long                lIndex = 0;
    VARIANT             vtIndex;

    ASSERT(NULL != m_piSnapInDef, "ApplyImageList: m_piSnapInDef is NULL");

    ::VariantInit(&vtIndex);

    hr = GetCBSelection(IDC_COMBO_IMAGELISTS, &bstrImageList);
    IfFailGo(hr);

    if (NULL != bstrImageList)
    {
#if defined(IMAGELIST_FIX)
        hr = m_piSnapInDef->get_Images(&piMMCImageList);
        IfFailGo(hr);
#endif
        if (NULL != piMMCImageList)
        {
            hr = piMMCImageList->get_Name(&bstrSavedImageList);
            IfFailGo(hr);
        }

        if (NULL == piMMCImageList || 0 != ::wcscmp(bstrImageList, bstrSavedImageList))
        {
            hr = m_piSnapInDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
            if (FAILED(hr))
            {
                hr = SID_E_INTERNAL;
                EXCEPTION_CHECK_GO(hr);
            }

            hr = piObjectModel->GetSnapInDesignerDef(&piSnapInDesignerDef);
            if (FAILED(hr))
            {
                hr = SID_E_INTERNAL;
                EXCEPTION_CHECK_GO(hr);
            }

            hr = piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
            IfFailGo(hr);

            hr = GetCBSelectedItemData(IDC_COMBO_IMAGELISTS, &lIndex);
            IfFailGo(hr);

            RELEASE(piMMCImageList);
            vtIndex.vt = VT_I4;
            vtIndex.lVal = lIndex;
            hr = piMMCImageLists->get_Item(vtIndex, &piMMCImageList);
            IfFailGo(hr);

#if defined(IMAGELIST_FIX)
            hr = m_piSnapInDef->putref_Images(piMMCImageList);
            IfFailGo(hr);
#endif
        }
    }

Error:
    ::VariantClear(&vtIndex);
    RELEASE(piMMCImageLists);
    RELEASE(piSnapInDesignerDef);
    RELEASE(piObjectModel);
    FREESTRING(bstrSavedImageList);
    RELEASE(piMMCImageList);
    FREESTRING(bstrImageList);
*/
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::OnEditProperty(int iDispID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::OnEditProperty(int iDispID)
{
    HRESULT hr = S_OK;
    SnapInTypeConstants sitc = siStandAlone;

    switch (iDispID)
    {
    case DISPID_SNAPIN_TYPE:
        hr = m_piSnapInDef->get_Type(&sitc);
        IfFailGo(hr);

        switch (sitc)
        {
        case siStandAlone:
            ::SetFocus(::GetDlgItem(m_hwnd, IDC_RADIO_STAND_ALONE));
            break;

        case siExtension:
            ::SetFocus(::GetDlgItem(m_hwnd, IDC_RADIO_EXTENSION));
            break;

        case siDualMode:
            ::SetFocus(::GetDlgItem(m_hwnd, IDC_RADIO_DUAL));
            break;
        }
        break;

    case DISPID_SNAPIN_EXTENSION_SNAPIN:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_CHECK_EXTENSIBLE));
        break;

    case DISPID_SNAPIN_NAME:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_EDIT_NAME));
        break;

    case DISPID_SNAPIN_NODE_TYPE_NAME:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_EDIT_NODE_TYPE));
        break;

    case DISPID_SNAPIN_DISPLAY_NAME:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_EDIT_DISPLAY));
        break;

    case DISPID_SNAPIN_PROVIDER:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_EDIT_PROVIDER));
        break;

    case DISPID_SNAPIN_VERSION:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_EDIT_VERSION));
        break;

    case DISPID_SNAPIN_DESCRIPTION:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_EDIT_DESCRIPTION));
        break;

    case DISPID_SNAPIN_VIEWS:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_COMBO_VIEWS));
        break;

    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_COMBO_VIEWS:
        MakeDirty();
        break;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::OnButtonClicked(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_RADIO_STAND_ALONE:
    case IDC_RADIO_EXTENSION:
    case IDC_RADIO_DUAL:
    case IDC_CHECK_EXTENSIBLE:
        MakeDirty();
        break;
    }

    // Enable/disable the Extensible check box if the snap-in type has changed
    // Enable/disable the Static Node Type name edit box if type has changed
    
    switch (dlgItemID)
    {
        case IDC_RADIO_STAND_ALONE:
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_EXTENSIBLE), TRUE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_NODE_TYPE), TRUE);
            break;

        case IDC_RADIO_EXTENSION:
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_EXTENSIBLE), FALSE);
            IfFailGo(SetCheckbox(IDC_CHECK_EXTENSIBLE, VARIANT_FALSE));
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_NODE_TYPE), FALSE);
            IfFailGo(SetDlgText(IDC_EDIT_NODE_TYPE, (BSTR)NULL));
            break;

        case IDC_RADIO_DUAL:
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_EXTENSIBLE), TRUE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_NODE_TYPE), TRUE);
            break;
    }    

Error:
    RRETURN(hr);
}



////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// SnapIn Property Page "Image Lists"
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CSnapInImageListPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CSnapInImageListPage::Create(IUnknown *pUnkOuter)
{
	CSnapInImageListPage *pNew = New CSnapInImageListPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::CSnapInImageListPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSnapInImageListPage::CSnapInImageListPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGSNAPINIL), m_piSnapInDesignerDef(0), m_piSnapInDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::~CSnapInImageListPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSnapInImageListPage::~CSnapInImageListPage()
{
    RELEASE(m_piSnapInDesignerDef);
    RELEASE(m_piSnapInDef);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::OnInitializeDialog()
{
    HRESULT             hr = S_OK;

    hr = RegisterTooltip(IDC_COMBO_SMALL_FOLDERS, IDS_TT_SN_SMALL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_SMALL_OPEN_FOLDERS, IDS_TT_SN_SMALL_OPEN);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_LARGE_FOLDERS, IDS_TT_SN_LARGE);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    IObjectModel   *piObjectModel = NULL;

    if (NULL != m_piSnapInDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_ISnapInDef, reinterpret_cast<void **>(&m_piSnapInDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piSnapInDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&m_piSnapInDesignerDef);
    IfFailGo(hr);

    hr = InitializeImageLists();
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::InitImageComboBoxSelection()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//

HRESULT CSnapInImageListPage::InitImageComboBoxSelection
(
    UINT           idComboBox,
    IMMCImageList *piMMCImageList
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    hr = piMMCImageList->get_Name(&bstrName);
    IfFailGo(hr);

    hr = SelectCBBstr(idComboBox, bstrName);
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::InitializeImageLists()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::InitializeImageLists()
{
    HRESULT        hr = S_OK;
    IMMCImageList *piMMCImageList = NULL;

    ASSERT(NULL != m_piSnapInDef, "InitializeImageLists: m_piSnapInDef is NULL");

    // First populate the combo boxes
    hr = PopulateImageLists();
    IfFailGo(hr);

    hr = m_piSnapInDef->get_SmallFolders(&piMMCImageList);
    IfFailGo(hr);

    if (NULL != piMMCImageList)
    {
        hr = InitImageComboBoxSelection(IDC_COMBO_SMALL_FOLDERS, piMMCImageList);
        IfFailGo(hr);
        RELEASE(piMMCImageList);
    }

    hr = m_piSnapInDef->get_SmallFoldersOpen(&piMMCImageList);
    IfFailGo(hr);
    if (NULL != piMMCImageList)
    {
        hr = InitImageComboBoxSelection(IDC_COMBO_SMALL_OPEN_FOLDERS, piMMCImageList);
        IfFailGo(hr);
        RELEASE(piMMCImageList);
    }

    hr = m_piSnapInDef->get_LargeFolders(&piMMCImageList);
    IfFailGo(hr);
    if (NULL != piMMCImageList)
    {
        hr = InitImageComboBoxSelection(IDC_COMBO_LARGE_FOLDERS, piMMCImageList);
        IfFailGo(hr);
    }

Error:
    QUICK_RELEASE(piMMCImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::PopulateImageLists()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::PopulateImageLists()
{
    HRESULT               hr = S_OK;
    IObjectModel         *piObjectModel = NULL;
    ISnapInDesignerDef   *piSnapInDesignerDef = NULL;
    IMMCImageLists       *piMMCImageLists = NULL;
    long                  lCount = 0;
    long                  lIndex = 1;
    VARIANT               vtIndex;
    IMMCImageList        *piMMCImageList = NULL;
    BSTR                  bstrName = NULL;

    ASSERT(NULL != m_piSnapInDef, "InitializeImageLists: m_piSnapInDef is NULL");

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&piSnapInDesignerDef);
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    hr = piMMCImageLists->get_Count(&lCount);
    IfFailGo(hr);

    vtIndex.vt = VT_I4;
    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piMMCImageLists->get_Item(vtIndex, &piMMCImageList);
        IfFailGo(hr);

        hr = piMMCImageList->get_Name(&bstrName);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_SMALL_FOLDERS, bstrName, lIndex);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_SMALL_OPEN_FOLDERS, bstrName, lIndex);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_LARGE_FOLDERS, bstrName, lIndex);
        IfFailGo(hr);

        FREESTRING(bstrName);
        RELEASE(piMMCImageList);
    }

    lCount = ::SendMessage(::GetDlgItem(m_hwnd, IDC_COMBO_SMALL_FOLDERS), CB_GETCOUNT, 0, 0);
    if (CB_ERR == lCount)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (0 == lCount)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_SMALL_FOLDERS), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_SMALL_OPEN_FOLDERS), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_LARGE_FOLDERS), FALSE);
    }

Error:
    FREESTRING(bstrName);
    RELEASE(piMMCImageList);
    ::VariantClear(&vtIndex);
    RELEASE(piMMCImageLists);
    RELEASE(piSnapInDesignerDef);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::OnApply()
{
    HRESULT hr = S_OK;
    IObjectModel         *piObjectModel = NULL;
    ISnapInDesignerDef   *piSnapInDesignerDef = NULL;
    IMMCImageLists       *piMMCImageLists = NULL;

    hr = m_piSnapInDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&piSnapInDesignerDef);
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    hr = ApplySmallImageList(piMMCImageLists);
    IfFailGo(hr);

    hr = ApplySmallOpenImageList(piMMCImageLists);
    IfFailGo(hr);

    hr = ApplyLargeImageList(piMMCImageLists);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piMMCImageLists);
    QUICK_RELEASE(piSnapInDesignerDef);
    QUICK_RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::GetImageList()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::GetImageList
(
    UINT             idComboBox,
    IMMCImageLists  *piMMCImageLists,
    IMMCImageList  **ppiMMCImageList
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    VARIANT varIndex;

	ASSERT(NULL != piMMCImageLists, "GetImageList: piMMCImageLists is NULL");

    ::VariantInit(&varIndex);

    hr = GetCBSelection(idComboBox, &bstrName);
    IfFailGo(hr);

    if (NULL != bstrName)
    {
        varIndex.vt = VT_BSTR;
        varIndex.bstrVal = bstrName;

        hr = piMMCImageLists->get_Item(varIndex, ppiMMCImageList);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::ApplySmallImageList()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::ApplySmallImageList
(
    IMMCImageLists *piMMCImageLists
)
{
    HRESULT        hr = S_OK;
    IMMCImageList *piMMCImageList = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplySmallImageList: m_piSnapInDef is NULL");

    hr = GetImageList(IDC_COMBO_SMALL_FOLDERS, piMMCImageLists, &piMMCImageList);
    IfFailGo(hr);

    hr = m_piSnapInDef->putref_SmallFolders(piMMCImageList);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piMMCImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::ApplySmallOpenImageList()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::ApplySmallOpenImageList
(
    IMMCImageLists *piMMCImageLists
)
{
    HRESULT        hr = S_OK;
    IMMCImageList *piMMCImageList = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplySmallOpenImageList: m_piSnapInDef is NULL");

    hr = GetImageList(IDC_COMBO_SMALL_OPEN_FOLDERS, piMMCImageLists, &piMMCImageList);
    IfFailGo(hr);

    hr = m_piSnapInDef->putref_SmallFoldersOpen(piMMCImageList);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piMMCImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::ApplyLargeImageList()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::ApplyLargeImageList
(
    IMMCImageLists *piMMCImageLists
)
{
    HRESULT        hr = S_OK;
    IMMCImageList *piMMCImageList = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplyLargeImageList: m_piSnapInDef is NULL");

    hr = GetImageList(IDC_COMBO_LARGE_FOLDERS, piMMCImageLists, &piMMCImageList);
    IfFailGo(hr);

    hr = m_piSnapInDef->putref_LargeFolders(piMMCImageList);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piMMCImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_COMBO_SMALL_FOLDERS:
        MakeDirty();
        break;
    case IDC_COMBO_SMALL_OPEN_FOLDERS:
        MakeDirty();
        break;
    case IDC_COMBO_LARGE_FOLDERS:
        MakeDirty();
        break;

    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\pslistvw.cpp ===
//=--------------------------------------------------------------------------------------
// pslistvw.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//
//=------------------------------------------------------------------------------------=
//
// URL View Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "pslistvw.h"

// for ASSERT and FAIL
//
SZTHISFILE


struct ViewModes
{
    TCHAR                   m_pszModeName[kSIMaxBuffer + 1];
    SnapInViewModeConstants m_iIdentifier;
    int                     m_iIndex;
};

struct ViewModes g_viewModes[5] =
{
    { _T(""),  siIcon,        -1, },
    { _T(""),  siSmallIcon,   -1, },
    { _T(""),  siList,        -1, },
    { _T(""),  siReport,      -1, },
    { _T(""),  siFiltered,    -1  }
};

static size_t g_cViewModes = sizeof(g_viewModes) / sizeof(g_viewModes[0]);


struct SortOrder
{
    TCHAR                    m_pszSortOrderName[kSIMaxBuffer + 1];
    SnapInSortOrderConstants m_iIdentifier;
    int                      m_iIndex;
};

struct SortOrder g_sortOrder[2] =
{
    { _T(""),  siAscending,   -1, },
    { _T(""),  siDescending,  -1  }
};



////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page General
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CListViewGeneralPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
IUnknown *CListViewGeneralPage::Create(IUnknown *pUnkOuter)
{
        CListViewGeneralPage *pNew = New CListViewGeneralPage(pUnkOuter);
        return pNew->PrivateUnknown();          
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::CListViewGeneralPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewGeneralPage::CListViewGeneralPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGLSTVIEWGENERAL), m_piListViewDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::~CListViewGeneralPage()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewGeneralPage::~CListViewGeneralPage()
{
    RELEASE(m_piListViewDef);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::OnInitializeDialog()
{
    HRESULT             hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_LV_NAME, IDS_TT_LV1_NAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_LV_VIEWS, IDS_TT_LV1_DFLTVIEW);
    IfFailGo(hr);

    hr = PopulateViewModes();
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_LV_VIRTUAL_LIST, IDS_TT_LV1_VIRTLIST);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_LV_ADDTOVIEWMENU, IDS_TT_LV1_ADDTOVIEWM);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_LV_ADDTOVIEWMENU, IDS_TT_LV1_ADDTOVIEWM);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_LV_STATUSBARTEXT, IDS_TT_LV1_STATUSTXT);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::InitializeViewModes()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::InitializeViewModes()
{
    HRESULT     hr = S_OK;
    int         iResult = 0;
    char        szBuffer[kSIMaxBuffer + 1];

    if (-1 == g_viewModes[0].m_iIndex)
    {
        iResult = ::LoadString(GetResourceHandle(),
                               IDS_LV_VM_LARGE,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_viewModes[0].m_pszModeName, szBuffer);
        g_viewModes[0].m_iIdentifier = siIcon;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_LV_VM_SMALL,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_viewModes[1].m_pszModeName, szBuffer);
        g_viewModes[1].m_iIdentifier = siSmallIcon;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_LV_VM_LIST,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_viewModes[2].m_pszModeName, szBuffer);
        g_viewModes[2].m_iIdentifier = siList;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_LV_VM_REPORT,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_viewModes[3].m_pszModeName, szBuffer);
        g_viewModes[3].m_iIdentifier = siReport;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_LV_VM_FILTERED,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_viewModes[4].m_pszModeName, szBuffer);
        g_viewModes[4].m_iIdentifier = siFiltered;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::PopulateViewModes()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::PopulateViewModes()
{
    HRESULT     hr = S_OK;
    BSTR        bstr = NULL;
    size_t      i = 0;

    hr = InitializeViewModes();
    IfFailGo(hr);

    for (i = 0; i < g_cViewModes; i++)
    {
        hr = BSTRFromANSI(g_viewModes[i].m_pszModeName, &bstr);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_LV_VIEWS, bstr, g_viewModes[i].m_iIdentifier);
        IfFailGo(hr);

        FREESTRING(bstr);
    }

Error:
    FREESTRING(bstr);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    BSTR            bstrName = NULL;
    VARIANT_BOOL    vtBool = VARIANT_FALSE;
    BSTR            bstrMenuText = NULL;
    BSTR            bstrStatusBarText = NULL;

    if (NULL != m_piListViewDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IListViewDef, reinterpret_cast<void **>(&m_piListViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piListViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_NAME, bstrName);
    IfFailGo(hr);

    hr = InitializeDefaultViewMode();
    IfFailGo(hr);

    hr = m_piListViewDef->get_Virtual(&vtBool);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_LV_VIRTUAL_LIST, vtBool);
    IfFailGo(hr);

    hr = m_piListViewDef->get_AddToViewMenu(&vtBool);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_LV_ADDTOVIEWMENU, vtBool);
    IfFailGo(hr);

    if (VARIANT_FALSE == vtBool)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_VIEWMENUTEXT), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_STATUSBARTEXT), FALSE);
    }

    hr = m_piListViewDef->get_ViewMenuText(&bstrMenuText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_VIEWMENUTEXT, bstrMenuText);
    IfFailGo(hr);

    hr = m_piListViewDef->get_ViewMenuStatusBarText(&bstrStatusBarText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_STATUSBARTEXT, bstrStatusBarText);
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    FREESTRING(bstrStatusBarText);
    FREESTRING(bstrMenuText);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::InitializeDefaultViewMode()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::InitializeDefaultViewMode()
{
    HRESULT                 hr = S_OK;
    HWND                    hCombo = NULL;
    SnapInViewModeConstants svmc = siIcon;

    ASSERT(NULL != m_piListViewDef, "InitializeDefaultViewMode: m_piListViewDef is NULL");

    hCombo = ::GetDlgItem(m_hwnd, IDC_COMBO_LV_VIEWS);
    if (NULL == hCombo)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piListViewDef->get_View(&svmc);
    IfFailGo(hr);

    hr = SetCBItemSelection(IDC_COMBO_LV_VIEWS, static_cast<long>(svmc));
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtAddToViewMenu = VARIANT_FALSE;

    switch (dlgItemID)
    {
    case IDC_CHECK_LV_ADDTOVIEWMENU:
        hr = GetCheckbox(IDC_CHECK_LV_ADDTOVIEWMENU, &vtAddToViewMenu);
        IfFailGo(hr);
        if (VARIANT_TRUE == vtAddToViewMenu)
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_VIEWMENUTEXT), TRUE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_STATUSBARTEXT), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_VIEWMENUTEXT), FALSE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_STATUSBARTEXT), FALSE);
        }

        break;

    case IDC_CHECK_LV_VIRTUAL_LIST:
        MakeDirty();
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_COMBO_LV_VIEWS:
        MakeDirty();
        break;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(NULL != m_piListViewDef, "OnApply: m_piListViewDef is NULL");

    hr = ApplyListViewName();
    IfFailGo(hr);

    hr = ApplyDefualtViewMode();
    IfFailGo(hr);

    hr = ApplyVirtualList();
    IfFailGo(hr);

    hr = ApplyAddToViewMenu();
    IfFailGo(hr);

    hr = ApplyViewMenuText();
    IfFailGo(hr);

    hr = ApplyStatusBarText();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::ApplyListViewName()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::ApplyListViewName()
{
    HRESULT  hr = S_OK;
    BSTR     bstrListViewName = NULL;
    BSTR     bstrSavedListViewName = NULL;

    ASSERT(NULL != m_piListViewDef, "ApplyListViewName: m_piListViewDef is NULL");

    hr = GetDlgText(IDC_EDIT_LV_NAME, &bstrListViewName);
    IfFailGo(hr);

    hr = m_piListViewDef->get_Name(&bstrSavedListViewName);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrListViewName, bstrSavedListViewName))
    {
        hr = m_piListViewDef->put_Name(bstrListViewName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedListViewName);
    FREESTRING(bstrListViewName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::ApplyDefualtViewMode()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::ApplyDefualtViewMode()
{
    HRESULT                 hr = S_OK;
    long                    lData = 0;
    SnapInViewModeConstants svmc = siIcon;
    SnapInViewModeConstants savedSvmc = siIcon;

    ASSERT(NULL != m_piListViewDef, "ApplyDefualtViewMode: m_piListViewDef is NULL");

    hr = GetCBSelectedItemData(IDC_COMBO_LV_VIEWS, &lData);
    IfFailGo(hr);

    svmc = static_cast<SnapInViewModeConstants>(lData);

    hr = m_piListViewDef->get_View(&savedSvmc);
    IfFailGo(hr);

    if (svmc != savedSvmc)
    {
        hr = m_piListViewDef->put_View(svmc);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::ApplyVirtualList()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::ApplyVirtualList()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtVirtualList = VARIANT_FALSE;
    VARIANT_BOOL    vtSavedVirtualList = VARIANT_FALSE;

    ASSERT(NULL != m_piListViewDef, "ApplyVirtualList: m_piListViewDef is NULL");

    hr = GetCheckbox(IDC_CHECK_LV_VIRTUAL_LIST, &vtVirtualList);
    IfFailGo(hr);

    hr = m_piListViewDef->get_Virtual(&vtSavedVirtualList);
    IfFailGo(hr);

    if (vtVirtualList != vtSavedVirtualList)
    {
        hr = m_piListViewDef->put_Virtual(vtVirtualList);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::ApplyAddToViewMenu()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::ApplyAddToViewMenu()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtAddToViewMenu = VARIANT_FALSE;
    VARIANT_BOOL    vtSavedAddToViewMenu = VARIANT_FALSE;

    ASSERT(NULL != m_piListViewDef, "ApplyAddToViewMenu: m_piListViewDef is NULL");

    hr = GetCheckbox(IDC_CHECK_LV_ADDTOVIEWMENU, &vtAddToViewMenu);
    IfFailGo(hr);

    hr = m_piListViewDef->get_AddToViewMenu(&vtSavedAddToViewMenu);
    IfFailGo(hr);

    if (vtAddToViewMenu != vtSavedAddToViewMenu)
    {
        hr = m_piListViewDef->put_AddToViewMenu(vtAddToViewMenu);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::ApplyViewMenuText()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::ApplyViewMenuText()
{
    HRESULT  hr = S_OK;
    BSTR     bstrViewMenuText = NULL;
    BSTR     bstrSavedViewMenuText = NULL;

    ASSERT(NULL != m_piListViewDef, "ApplyViewMenuText: m_piListViewDef is NULL");

    hr = GetDlgText(IDC_EDIT_LV_VIEWMENUTEXT, &bstrViewMenuText);
    IfFailGo(hr);

    hr = m_piListViewDef->get_ViewMenuText(&bstrSavedViewMenuText);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrViewMenuText, bstrSavedViewMenuText))
    {
        hr = m_piListViewDef->put_ViewMenuText(bstrViewMenuText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedViewMenuText);
    FREESTRING(bstrViewMenuText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::ApplyStatusBarText()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::ApplyStatusBarText()
{
    HRESULT  hr = S_OK;
    BSTR     bstrStatusBarText = NULL;
    BSTR     bstrSavedStatusBarText = NULL;

    ASSERT(NULL != m_piListViewDef, "ApplyStatusBarText: m_piListViewDef is NULL");

    hr = GetDlgText(IDC_EDIT_LV_STATUSBARTEXT, &bstrStatusBarText);
    IfFailGo(hr);

    hr = m_piListViewDef->get_ViewMenuStatusBarText(&bstrSavedStatusBarText);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrStatusBarText, bstrSavedStatusBarText))
    {
        hr = m_piListViewDef->put_ViewMenuStatusBarText(bstrStatusBarText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedStatusBarText);
    FREESTRING(bstrStatusBarText);

    RRETURN(hr);
}




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page Image Lists
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CListViewImgListsPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
IUnknown *CListViewImgListsPage::Create(IUnknown *pUnkOuter)
{
        CListViewImgListsPage *pNew = New CListViewImgListsPage(pUnkOuter);
        return pNew->PrivateUnknown();          
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::CListViewImgListsPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewImgListsPage::CListViewImgListsPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGLSTVIEWIMGLSTS),
  m_piSnapInDesignerDef(0), m_piListViewDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::~CListViewImgListsPage()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewImgListsPage::~CListViewImgListsPage()
{
    RELEASE(m_piListViewDef);
    RELEASE(m_piSnapInDesignerDef);
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewImgListsPage::OnInitializeDialog()
{
    HRESULT             hr = S_OK;

    hr = RegisterTooltip(IDC_COMBO_LV_LARGE_ICONS, IDS_TT_LV2_LARGE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_LV_SMALL_ICONS, IDS_TT_LV2_SMALL);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewImgListsPage::OnNewObjects()
{
    HRESULT          hr = S_OK;
    IUnknown        *pUnk = NULL;
    DWORD            dwDummy = 0;
    IObjectModel    *piObjectModel = NULL;
    IMMCListView    *piMMCListView = NULL;
    IMMCImageList   *piMMCLrgImageList = NULL;
    BSTR             bstrLargeIcon = NULL;
    IMMCImageList   *piMMCSmlImageList = NULL;
    BSTR             bstrSmallIcon = NULL;

    if (NULL != m_piListViewDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IListViewDef, reinterpret_cast<void **>(&m_piListViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&m_piSnapInDesignerDef);
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeComboBoxes();
    IfFailGo(hr);

    hr = m_piListViewDef->get_ListView(&piMMCListView);
    IfFailGo(hr);

    hr = piMMCListView->get_Icons(reinterpret_cast<MMCImageList **>(&piMMCLrgImageList));
    IfFailGo(hr);

    if (NULL != piMMCLrgImageList)
    {
        hr = piMMCLrgImageList->get_Name(&bstrLargeIcon);
        IfFailGo(hr);

        hr = SelectCBBstr(IDC_COMBO_LV_LARGE_ICONS, bstrLargeIcon);
        IfFailGo(hr);
    }

    hr = piMMCListView->get_SmallIcons(reinterpret_cast<MMCImageList **>(&piMMCSmlImageList));
    IfFailGo(hr);

    if (NULL != piMMCSmlImageList)
    {
        hr = piMMCSmlImageList->get_Name(&bstrSmallIcon);
        IfFailGo(hr);

        hr = SelectCBBstr(IDC_COMBO_LV_SMALL_ICONS, bstrSmallIcon);
        IfFailGo(hr);
    }

    m_bInitialized = true;

Error:
    FREESTRING(bstrSmallIcon);
    RELEASE(piMMCSmlImageList);
    FREESTRING(bstrLargeIcon);
    RELEASE(piMMCLrgImageList);
    RELEASE(piMMCListView);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::InitializeComboBoxes()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewImgListsPage::InitializeComboBoxes()
{
    HRESULT          hr = S_OK;
    IMMCImageLists  *piMMCImageLists = NULL;
    long             lCount = 0;
    int              lIndex = 0;
    VARIANT          vtIndex;
    IMMCImageList   *piMMCImageList = NULL;
    BSTR             bstrILName = NULL;
    int              iResult = 0;

    ASSERT(NULL != m_piSnapInDesignerDef, "InitializeComboBoxes: m_piSnapInDesignerDef is NULL");

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    hr = piMMCImageLists->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = piMMCImageLists->get_Item(vtIndex, &piMMCImageList);
        IfFailGo(hr);

        hr = piMMCImageList->get_Name(&bstrILName);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_LV_LARGE_ICONS, bstrILName, 0);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_LV_SMALL_ICONS, bstrILName, 0);
        IfFailGo(hr);

        FREESTRING(bstrILName);
        RELEASE(piMMCImageList);
    }

Error:
    FREESTRING(bstrILName);
    ::VariantClear(&vtIndex);
    RELEASE(piMMCImageList);
    RELEASE(piMMCImageLists);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::OnApply()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewImgListsPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(NULL != m_piListViewDef, "OnApply: m_piListViewDef is NULL");

    hr = ApplyLargeIcon();
    IfFailGo(hr);

    hr = ApplySmallIcon();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::ApplyLargeIcon()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewImgListsPage::ApplyLargeIcon()
{
    HRESULT          hr = S_OK;
    BSTR             bstrLargeIcons = NULL;
    IMMCListView    *piMMCListView = NULL;
    IMMCImageLists  *piMMCImageLists = NULL;
    IMMCImageList   *piMMCImageList = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    ASSERT(NULL != m_piListViewDef, "ApplyLargeIcon: m_piListViewDef is NULL");

    IfFailGo(GetCBSelection(IDC_COMBO_LV_LARGE_ICONS, &bstrLargeIcons));

    if (NULL != bstrLargeIcons)
    {
        IfFailGo(m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists));

        varKey.vt = VT_BSTR;
        varKey.bstrVal = bstrLargeIcons;
        IfFailGo(piMMCImageLists->get_Item(varKey, &piMMCImageList));
    }

    IfFailGo(m_piListViewDef->get_ListView(&piMMCListView));
    IfFailGo(piMMCListView->putref_Icons(reinterpret_cast<MMCImageList *>(piMMCImageList)));

Error:
    FREESTRING(bstrLargeIcons);
    RELEASE(piMMCListView);
    RELEASE(piMMCImageLists);
    RELEASE(piMMCImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::ApplySmallIcon()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewImgListsPage::ApplySmallIcon()
{
    HRESULT          hr = S_OK;
    BSTR             bstrSmallIcons = NULL;
    IMMCListView    *piMMCListView = NULL;
    IMMCImageLists  *piMMCImageLists = NULL;
    IMMCImageList   *piMMCImageList = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    ASSERT(NULL != m_piListViewDef, "ApplySmallIcon: m_piListViewDef is NULL");

    IfFailGo(GetCBSelection(IDC_COMBO_LV_SMALL_ICONS, &bstrSmallIcons));

    if (NULL != bstrSmallIcons)
    {
        IfFailGo(m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists));

        varKey.vt = VT_BSTR;
        varKey.bstrVal = bstrSmallIcons;
        IfFailGo(piMMCImageLists->get_Item(varKey, &piMMCImageList));
    }

    IfFailGo(m_piListViewDef->get_ListView(&piMMCListView));
    IfFailGo(piMMCListView->putref_SmallIcons(reinterpret_cast<MMCImageList *>(piMMCImageList)));

Error:
    FREESTRING(bstrSmallIcons);
    RELEASE(piMMCListView);
    RELEASE(piMMCImageLists);
    RELEASE(piMMCImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewImgListsPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    MakeDirty();

    RRETURN(hr);
}




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page Sorting
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CListViewSortingPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
IUnknown *CListViewSortingPage::Create(IUnknown *pUnkOuter)
{
        CListViewSortingPage *pNew = New CListViewSortingPage(pUnkOuter);
        return pNew->PrivateUnknown();          
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::CListViewSortingPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewSortingPage::CListViewSortingPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGLSTVIEWSORTING), m_piListViewDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::~CListViewSortingPage()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewSortingPage::~CListViewSortingPage()
{
    RELEASE(m_piListViewDef);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::OnInitializeDialog()
{
    HRESULT             hr = S_OK;

    hr = RegisterTooltip(IDC_CHECK_LV_SORTED, IDS_TT_LV3_SORTED);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_LV_KEY, IDS_TT_LV3_KEY);
    IfFailGo(hr);

    hr = InitializeSortOrder();
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_LV_SORT, IDS_TT_LV3_SORTORDER);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::InitializeSortOrderArray()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::InitializeSortOrderArray()
{
    HRESULT     hr = S_OK;
    int         iResult = 0;
    char        szBuffer[kSIMaxBuffer + 1];

    if (-1 == g_sortOrder[0].m_iIndex)
    {
        iResult = ::LoadString(GetResourceHandle(),
                               IDS_LV_SORT_ASC,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_sortOrder[0].m_pszSortOrderName, szBuffer);
        g_sortOrder[0].m_iIdentifier = siAscending;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_LV_SORT_DESC,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_sortOrder[1].m_pszSortOrderName, szBuffer);
        g_sortOrder[1].m_iIdentifier = siDescending;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::InitializeSortOrder()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::InitializeSortOrder()
{
    HRESULT     hr = S_OK;
    BSTR        bstrSortOrder = NULL;
    int         iIndex = 0;

    hr = InitializeSortOrderArray();
    IfFailGo(hr);

    for (iIndex = 0; iIndex < 2; ++iIndex)
    {
        hr = BSTRFromANSI(g_sortOrder[iIndex].m_pszSortOrderName, &bstrSortOrder);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_LV_SORT, bstrSortOrder, g_sortOrder[iIndex].m_iIdentifier);
        IfFailGo(hr);

        FREESTRING(bstrSortOrder);
    }

Error:
    FREESTRING(bstrSortOrder);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::OnNewObjects()
{
    HRESULT                   hr = S_OK;
    IUnknown                 *pUnk = NULL;
    DWORD                     dwDummy = 0;
    VARIANT_BOOL              vtBool = VARIANT_FALSE;
    SnapInSortOrderConstants  ssoc = siAscending;

    if (NULL != m_piListViewDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IListViewDef, reinterpret_cast<void **>(&m_piListViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piListViewDef->get_Sorted(&vtBool);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_LV_SORTED, vtBool);
    IfFailGo(hr);

    if (VARIANT_FALSE == vtBool)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_LV_KEY), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_LV_SORT), FALSE);
    }

    hr = InitializeKey();
    IfFailGo(hr);

    hr = m_piListViewDef->get_SortOrder(&ssoc);
    IfFailGo(hr);

    hr = SetCBItemSelection(IDC_COMBO_LV_SORT, static_cast<long>(ssoc));
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::InitializeKey
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::InitializeKey()
{
    HRESULT             hr = S_OK;
    IMMCListView       *piMMCListView = NULL;
    IMMCColumnHeaders  *piMMCColumnHeaders = NULL;
    short               sKey = 0;
    long                lIndex = 0;

    ASSERT(NULL != m_piListViewDef, "InitializeKey: m_piListViewDef is NULL");

    hr = m_piListViewDef->get_ListView(&piMMCListView);
    IfFailGo(hr);

    hr = piMMCListView->get_ColumnHeaders(reinterpret_cast<MMCColumnHeaders **>(&piMMCColumnHeaders));
    IfFailGo(hr);

    hr = PopulateKeys(piMMCColumnHeaders);
    IfFailGo(hr);

    if (S_OK == hr)
    {
        hr = m_piListViewDef->get_SortKey(&sKey);
        IfFailGo(hr);

        lIndex = static_cast<long>(sKey);
        hr = SetCBItemSelection(IDC_COMBO_LV_KEY, lIndex);
    }
    else
        hr = S_OK;

Error:
    RELEASE(piMMCColumnHeaders);
    RELEASE(piMMCListView);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::PopulateKeys(IMMCColumnHeaders *piMMCColumnHeaders)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::PopulateKeys(IMMCColumnHeaders *piMMCColumnHeaders)
{
    HRESULT             hr = S_OK;
    VARIANT             vtIndex;
    long                lCount = 0;
    long                lIndex = 0;
    IMMCColumnHeader   *piMMCColumnHeader = NULL;
    int                 iResult = 0;
    BSTR                bstrKey = NULL;

    ASSERT(NULL != m_piListViewDef, "PopulateKeys: m_piListViewDef is NULL");

    ::VariantInit(&vtIndex);

    hr = piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piMMCColumnHeaders->get_Item(vtIndex, reinterpret_cast<MMCColumnHeader **>(&piMMCColumnHeader));
        IfFailGo(hr);

        hr = piMMCColumnHeader->get_Key(&bstrKey);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_LV_KEY, bstrKey, lIndex);
        IfFailGo(hr);

        FREESTRING(bstrKey);
        RELEASE(piMMCColumnHeader);
    }

    hr = (0 == lCount) ? S_FALSE : S_OK;

Error:
    FREESTRING(bstrKey);
    RELEASE(piMMCColumnHeader);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::OnCBDropDown()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
// When user drops down combox box for sort key we need to repopulate the
// list because they may have made changes in the column headers page that we
// have not seen yet. Unfortunately, when the user goes back and forth between
// pages, OnNewObjects() is not called. This is because the OlePropertyFrame
// implementation only forwards the first PSN_SETACTIVE to OLE property pages.
// In order to make sure that we have latest list of column headers, we handle
// this message.

HRESULT CListViewSortingPage::OnCBDropDown(int dlgItemID)
{
    HRESULT hr = S_OK;

    IfFalseGo(IDC_COMBO_LV_KEY == dlgItemID, S_OK);

    // Clear out the combox box

    (void)::SendDlgItemMessage(m_hwnd, IDC_COMBO_LV_KEY, CB_RESETCONTENT, 0, 0);

    // Repopulate it

    IfFailGo(InitializeKey());

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::OnApply()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(NULL != m_piListViewDef, "OnApply: m_piListViewDef is NULL");

    hr = ApplySorted();
    IfFailGo(hr);

    hr = ApplyKey();
    IfFailGo(hr);

    hr = ApplySortOrder();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::ApplySorted()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::ApplySorted()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtSorted = VARIANT_FALSE;
    VARIANT_BOOL    vtSavedSorted = VARIANT_FALSE;

    ASSERT(NULL != m_piListViewDef, "ApplySorted: m_piListViewDef is NULL");

    hr = GetCheckbox(IDC_CHECK_LV_SORTED, &vtSorted);
    IfFailGo(hr);

    hr = m_piListViewDef->get_Sorted(&vtSavedSorted);
    IfFailGo(hr);

    if (vtSorted != vtSavedSorted)
    {
        hr = m_piListViewDef->put_Sorted(vtSorted);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::ApplyKey()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::ApplyKey()
{
    HRESULT     hr = S_OK;
    long        lKey = 0;
    short       sKey = 0;
    short       sSavedKey = 0;

    ASSERT(NULL != m_piListViewDef, "ApplyKey: m_piListViewDef is NULL");

    hr = GetCBSelectedItemData(IDC_COMBO_LV_KEY, &lKey);
    IfFailGo(hr);

    // Do nothing if there's no selection
    if (S_OK == hr)
    {
        sKey = static_cast<short>(lKey);

        hr = m_piListViewDef->get_SortKey(&sSavedKey);
        IfFailGo(hr);

        if (sKey != sSavedKey)
        {
            hr = m_piListViewDef->put_SortKey(sKey);
            IfFailGo(hr);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::ApplySortOrder()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::ApplySortOrder()
{
    HRESULT     hr = S_OK;
    int         iIndex = 0;

    ASSERT(NULL != m_piListViewDef, "ApplySortOrder: m_piListViewDef is NULL");

    iIndex = ::SendMessage(::GetDlgItem(m_hwnd, IDC_COMBO_LV_SORT), CB_GETCURSEL, 0, 0);
    if (CB_ERR == iIndex)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piListViewDef->put_SortOrder(g_sortOrder[iIndex].m_iIdentifier);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtBool = VARIANT_FALSE;

    ASSERT(NULL != m_piListViewDef, "OnButtonClicked: m_piListViewDef is NULL");

    switch (dlgItemID)
    {
    case IDC_CHECK_LV_SORTED:
        hr = GetCheckbox(IDC_CHECK_LV_SORTED, &vtBool);
        IfFailGo(hr);

        if (VARIANT_TRUE == vtBool)
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_LV_KEY), TRUE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_LV_SORT), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_LV_KEY), FALSE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_LV_SORT), FALSE);
        }

        MakeDirty();
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::OnCtlSelChange()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT     hr = S_OK;

    MakeDirty();

    RRETURN(hr);
}




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page Column Headers
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CListViewColHdrsPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
IUnknown *CListViewColHdrsPage::Create(IUnknown *pUnkOuter)
{
        CListViewColHdrsPage *pNew = New CListViewColHdrsPage(pUnkOuter);
        return pNew->PrivateUnknown();          
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::CListViewColHdrsPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewColHdrsPage::CListViewColHdrsPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGLSTVIEWCOLHDRS),
  m_piListViewDef(0), m_piMMCColumnHeaders(0), m_lCurrentIndex(0), m_bSavedLastHeader(true)
{
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::~CListViewColHdrsPage()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewColHdrsPage::~CListViewColHdrsPage()
{
    RELEASE(m_piListViewDef);
    RELEASE(m_piMMCColumnHeaders);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnInitializeDialog()
{
    HRESULT           hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_LV_INDEX, IDS_TT_LV4_INDEX);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_LV_COLUMNTEXT, IDS_TT_LV4_TEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_LV_COLUMNWIDTH, IDS_TT_LV4_WIDTH);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_LV_AUTOWIDTH, IDS_TT_LV4_AUTOWIDTH);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_LV_COLUMNKEY, IDS_TT_LV4_KEY);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnNewObjects()
{
    HRESULT           hr = S_OK;
    IUnknown         *pUnk = NULL;
    DWORD             dwDummy = 0;
    IMMCListView     *piMMCListView = NULL;
    long              lCount = 0;

    if (NULL != m_piListViewDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IListViewDef, reinterpret_cast<void **>(&m_piListViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piListViewDef->get_ListView(&piMMCListView);
    IfFailGo(hr);

    hr = piMMCListView->get_ColumnHeaders(reinterpret_cast<MMCColumnHeaders **>(&m_piMMCColumnHeaders));
    IfFailGo(hr);

    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        m_lCurrentIndex = 1;
        hr = ShowColumnHeader();
        IfFailGo(hr);

        EnableEdits(true);
    }
    else
    {
        hr = SetDlgText(IDC_EDIT_LV_INDEX, m_lCurrentIndex);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_LV_REMOVE_COLUMN), FALSE);
        EnableEdits(false);
    }

    m_bInitialized = true;

Error:
    RELEASE(piMMCListView);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnApply()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnApply()
{
    HRESULT              hr = S_OK;
    long                 lCount = 0;
    int                  disposition = 0;
    IMMCColumnHeader    *piMMCColumnHeader = NULL;

    ASSERT(NULL != m_piListViewDef, "OnApply: m_piListViewDef is NULL");

    if (0 == m_lCurrentIndex)
        goto Error;

    if (false == m_bSavedLastHeader)
    {
        hr = CanCreateNewHeader();
        IfFailGo(hr);

        if (S_FALSE == hr)
        {
            hr = HandleCantCommit(_T("Can\'t create new ColumnHeader"), _T("Would you like to discard your changes?"), &disposition);
            if (kSICancelOperation == disposition)
            {
                hr = E_INVALIDARG;
                goto Error;
            }
            else
            {
                // Discard changes
                hr = ExitDoingNewHeaderState(NULL);
                IfFailGo(hr);

                hr = S_OK;
                goto Error;
            }
        }

        hr = CreateNewHeader(&piMMCColumnHeader);
        IfFailGo(hr);

        hr = ExitDoingNewHeaderState(piMMCColumnHeader);
        IfFailGo(hr);
    }
    else
    {
        hr = GetCurrentHeader(&piMMCColumnHeader);
        IfFailGo(hr);
    }

    hr = ApplyCurrentHeader();
    IfFailGo(hr);

    // Adjust the remove button as necessary
    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (0 == lCount)
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_LV_REMOVE_COLUMN), FALSE);
    else
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_LV_REMOVE_COLUMN), TRUE);

Error:
    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_COLHDR_APPLY_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_ColhdrApplyFailed, 0, DontAppendErrorInfo, NULL);
    }

    RELEASE(piMMCColumnHeader);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::ApplyCurrentHeader()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::ApplyCurrentHeader()
{
    HRESULT             hr = S_OK;
    VARIANT             vtIndex;
    IMMCColumnHeader   *piMMCColumnHeader = NULL;
    BSTR                bstrText = NULL;
    VARIANT_BOOL        bAutoWidth = VARIANT_FALSE;
    int                 iWidth = 0;
    BSTR                bstrKey = NULL;

    ::VariantInit(&vtIndex);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentIndex;

    hr = m_piMMCColumnHeaders->get_Item(vtIndex, reinterpret_cast<MMCColumnHeader **>(&piMMCColumnHeader));
    IfFailGo(hr);

    // The Text property
    hr = GetDlgText(IDC_EDIT_LV_COLUMNTEXT, &bstrText);
    IfFailGo(hr);

    hr = piMMCColumnHeader->put_Text(bstrText);
    IfFailGo(hr);

    // The Column Width property
    hr = GetCheckbox(IDC_CHECK_LV_AUTOWIDTH, &bAutoWidth);
    IfFailGo(hr);

    if (VARIANT_TRUE == bAutoWidth)
    {
        hr = piMMCColumnHeader->put_Width(siColumnAutoWidth);
        IfFailGo(hr);
    }
    else
    {
        hr = GetDlgInt(IDC_EDIT_LV_COLUMNWIDTH, &iWidth);
        IfFailGo(hr);

        hr = piMMCColumnHeader->put_Width(static_cast<short>(iWidth));
        IfFailGo(hr);
    }

    // The Key property
    hr = GetDlgText(IDC_EDIT_LV_COLUMNKEY, &bstrKey);
    IfFailGo(hr);

    if (0 == ::SysStringLen(bstrKey))
    {
        FREESTRING(bstrKey);
    }

    hr = piMMCColumnHeader->put_Key(bstrKey);
    IfFailGo(hr);

Error:
    FREESTRING(bstrKey);
    FREESTRING(bstrText);
    RELEASE(piMMCColumnHeader);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT     hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_BUTTON_LV_INSERT_COLUMN:
        if (S_OK == IsPageDirty())
        {
            hr = OnApply();
            IfFailGo(hr);
        }

        hr = CanEnterDoingNewHeaderState();
        IfFailGo(hr);

        if (S_OK == hr)
        {
            hr = EnterDoingNewHeaderState();
            IfFailGo(hr);
        }
        break;

    case IDC_BUTTON_LV_REMOVE_COLUMN:
        hr = OnRemoveColumn();
        IfFailGo(hr);
        break;

    case IDC_CHECK_LV_AUTOWIDTH:
        hr = OnAutoWidth();
        IfFailGo(hr);
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnRemoveColumn()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnRemoveColumn()
{
    HRESULT             hr = S_OK;
    IMMCColumnHeader   *piMMCColumnHeader = NULL;
    VARIANT             vtKey;
    long                lCount = 0;

    ::VariantInit(&vtKey);

    hr = GetCurrentHeader(&piMMCColumnHeader);
    IfFailGo(hr);

    hr = piMMCColumnHeader->get_Index(&vtKey.lVal);
    IfFailGo(hr);

    vtKey.vt = VT_I4;

    hr = m_piMMCColumnHeaders->Remove(vtKey);
    IfFailGo(hr);

    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        if (m_lCurrentIndex > lCount)
            m_lCurrentIndex = lCount;

        hr = ShowColumnHeader();
        IfFailGo(hr);
    }
    else
    {
        m_lCurrentIndex = 0;

        hr = ClearHeader();
        IfFailGo(hr);

        hr = EnableEdits(false);
        IfFailGo(hr);

                ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_LV_REMOVE_COLUMN), FALSE);
    }


Error:
    ::VariantClear(&vtKey);
    RELEASE(piMMCColumnHeader);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnAutoWidth()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnAutoWidth()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bValue = VARIANT_FALSE;

    hr = GetCheckbox(IDC_CHECK_LV_AUTOWIDTH, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNWIDTH), FALSE);
    else
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNWIDTH), TRUE);

    MakeDirty();

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnKillFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnKillFocus(int dlgItemID)
{
    HRESULT          hr = S_OK;
    int              lIndex = 0;
    long             lCount = 0;

    if (false == m_bSavedLastHeader)
    {
        goto Error;
    }

    switch (dlgItemID)
    {
    case IDC_EDIT_LV_INDEX:
        hr = GetDlgInt(IDC_EDIT_LV_INDEX, &lIndex);
        IfFailGo(hr);

        hr = m_piMMCColumnHeaders->get_Count(&lCount);
        IfFailGo(hr);

        if (lIndex != m_lCurrentIndex)
        {
            if (lIndex >= 1)
            {
                if (lIndex > lCount)
                    m_lCurrentIndex = lCount;
                else
                    m_lCurrentIndex = lIndex;

                hr = ShowColumnHeader();
                IfFailGo(hr);
            }
        }
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::ClearHeader()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::ClearHeader()
{
    HRESULT hr = S_OK;

    hr = SetDlgText(IDC_EDIT_LV_INDEX, m_lCurrentIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_COLUMNTEXT, static_cast<BSTR>(NULL));
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_COLUMNWIDTH, static_cast<BSTR>(NULL));
    IfFailGo(hr);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNWIDTH), TRUE);

    hr = SetCheckbox(IDC_CHECK_LV_AUTOWIDTH, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_COLUMNKEY, static_cast<BSTR>(NULL));
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::EnableEdits(bool bEnable)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::EnableEdits
(
    bool bEnable
)
{
    BOOL    fEnable = false == bEnable ? TRUE : FALSE;

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNTEXT), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNWIDTH), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNKEY), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_LV_AUTOWIDTH), (TRUE == fEnable) ? FALSE : TRUE);

    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::ShowColumnHeader(IMMCColumnHeader *piMMCColumnHeader)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::ShowColumnHeader
(
    IMMCColumnHeader *piMMCColumnHeader
)
{
    HRESULT     hr = S_OK;
    BSTR        bstrText = NULL;
    short       iWidth = 0;
    BSTR        bstrKey = NULL;

    ASSERT(NULL != piMMCColumnHeader, "InitializeIndex: piMMCColumnHeader is NULL");

    m_bSilentUpdate = true;
    hr = piMMCColumnHeader->get_Index(&m_lCurrentIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_INDEX, m_lCurrentIndex);
    IfFailGo(hr);

    hr = piMMCColumnHeader->get_Text(&bstrText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_COLUMNTEXT, bstrText);
    IfFailGo(hr);

    hr = piMMCColumnHeader->get_Width(static_cast<short *>(&iWidth));
    IfFailGo(hr);

    if (siColumnAutoWidth == iWidth)
    {
        hr = SetCheckbox(IDC_CHECK_LV_AUTOWIDTH, VARIANT_TRUE);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNWIDTH), FALSE);
    }
    else
    {
        hr = SetCheckbox(IDC_CHECK_LV_AUTOWIDTH, VARIANT_FALSE);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNWIDTH), TRUE);

        hr = SetDlgText(IDC_EDIT_LV_COLUMNWIDTH, iWidth);
        IfFailGo(hr);
    }

    hr = piMMCColumnHeader->get_Key(&bstrKey);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_COLUMNKEY, bstrKey);
    IfFailGo(hr);

Error:
    FREESTRING(bstrText);
    FREESTRING(bstrKey);
    m_bSilentUpdate = false;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::ShowColumnHeader()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::ShowColumnHeader()
{
    HRESULT             hr = S_OK;
    VARIANT             vtIndex;
    IMMCColumnHeader   *piMMCColumnHeader = NULL;

    ::VariantInit(&vtIndex);

    hr = SetDlgText(IDC_EDIT_LV_INDEX, m_lCurrentIndex);
    IfFailGo(hr);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentIndex;

    hr = m_piMMCColumnHeaders->get_Item(vtIndex, reinterpret_cast<MMCColumnHeader **>(&piMMCColumnHeader));
    IfFailGo(hr);

    hr = ShowColumnHeader(piMMCColumnHeader);
    IfFailGo(hr);
Error:
    RELEASE(piMMCColumnHeader);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnDeltaPos(NMUPDOWN *pNMUpDown)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnDeltaPos
(
    NMUPDOWN *pNMUpDown
)
{
    HRESULT             hr = S_OK;
    long                lCount = 0;

    if (false == m_bSavedLastHeader || S_OK == IsPageDirty())
    {
        hr = OnApply();
        IfFailGo(hr);
    }

    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (pNMUpDown->iDelta < 0)
    {
        if (m_lCurrentIndex < lCount)
        {
            ++m_lCurrentIndex;
            hr = ShowColumnHeader();
            IfFailGo(hr);
        }
    }
    else
    {
        if (m_lCurrentIndex > 1 && m_lCurrentIndex <= lCount)
        {
            --m_lCurrentIndex;
            hr = ShowColumnHeader();
            IfFailGo(hr);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::CanEnterDoingNewHeaderState()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::CanEnterDoingNewHeaderState()
{
    HRESULT     hr = S_FALSE;

    if (true == m_bSavedLastHeader)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::EnterDoingNewHeaderState()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::EnterDoingNewHeaderState()
{
    HRESULT      hr = S_OK;

    ASSERT(NULL != m_piMMCColumnHeaders, "EnterDoingNewHeaderState: m_piMMCColumnHeaders is NULL");

    // Bump up the current button index to keep matters in sync.
    ++m_lCurrentIndex;
    hr = SetDlgText(IDC_EDIT_LV_INDEX, m_lCurrentIndex);
    IfFailGo(hr);

    // We disable the RemoveButton.
    // The InsertButton button remains enabled and acts like an "Apply and New" button
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_LV_REMOVE_COLUMN), FALSE);

    // Enable edits in this area of the dialog and clear all the entries
    hr = EnableEdits(true);
    IfFailGo(hr);

    hr = ClearHeader();
    IfFailGo(hr);

    m_bSavedLastHeader = false;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::CanCreateNewHeader()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::CanCreateNewHeader()
{
    HRESULT      hr = S_OK;
    BSTR         bstrWidth = NULL;
    VARIANT_BOOL bAutoWidth = VARIANT_FALSE;
    VARIANT      vtWidth;

    ::VariantInit(&vtWidth);

    // ColumnWidth must be a short if it is not auto-width.
    // First see if auto-width is checked.

    hr = GetCheckbox(IDC_CHECK_LV_AUTOWIDTH, &bAutoWidth);
    IfFailGo(hr);

    IfFalseGo(VARIANT_TRUE != bAutoWidth, S_OK);

    // Not using auto-width. Make sure that the text box contains a short.

    hr = GetDlgText(IDC_EDIT_LV_COLUMNWIDTH, &bstrWidth);
    IfFailGo(hr);

    vtWidth.vt = VT_BSTR;
    vtWidth.bstrVal = ::SysAllocString(bstrWidth);
    if (NULL == vtWidth.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = ::VariantChangeType(&vtWidth, &vtWidth, 0, VT_I2);
    if (FAILED(hr))
    {
        hr = HandleError(_T("ColumnHeaders"), _T("Column width must be an integer between 1 and 32767."));
        hr = S_FALSE;
    }

Error:
    ::VariantClear(&vtWidth);
    FREESTRING(bstrWidth);


    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::CreateNewHeader()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::CreateNewHeader(IMMCColumnHeader **ppiMMCColumnHeader)
{
    HRESULT              hr = S_OK;
    VARIANT              vtEmpty;
    VARIANT              vtIndex;
    VARIANT              vtKey;
    VARIANT              vtText;
    VARIANT_BOOL         bAutoWidth = VARIANT_FALSE;
    int                  iWidth = 0;
    VARIANT              vtWidth;

    ::VariantInit(&vtEmpty);
    ::VariantInit(&vtIndex);
    ::VariantInit(&vtText);
    ::VariantInit(&vtWidth);
    ::VariantInit(&vtKey);

    vtEmpty.vt = VT_ERROR;
    vtEmpty.scode = DISP_E_PARAMNOTFOUND;

    vtIndex.vt = VT_I4;
    vtIndex.scode = m_lCurrentIndex;

    vtKey.vt = VT_BSTR;
    hr = GetDlgText(IDC_EDIT_LV_COLUMNKEY, &vtKey.bstrVal);
    IfFailGo(hr);

    if (NULL == vtKey.bstrVal)
    {
        vtKey = vtEmpty;
    }
    else if (0 == ::SysStringLen(vtKey.bstrVal))
    {
        hr = ::VariantClear(&vtKey);
        EXCEPTION_CHECK_GO(hr);
        vtKey = vtEmpty;
    }

    vtText.vt = VT_BSTR;
    hr = GetDlgText(IDC_EDIT_LV_COLUMNTEXT, &vtText.bstrVal);
    IfFailGo(hr);

    hr = GetCheckbox(IDC_CHECK_LV_AUTOWIDTH, &bAutoWidth);
    IfFailGo(hr);

    if (VARIANT_FALSE == bAutoWidth)
    {
        hr = GetDlgInt(IDC_EDIT_LV_COLUMNWIDTH, &iWidth);
        IfFailGo(hr);
    }
    else
    {
        iWidth = siColumnAutoWidth;
    }

    vtWidth.vt = VT_I2;
    vtWidth.iVal = static_cast<short>(iWidth);

    hr = m_piMMCColumnHeaders->Add(vtIndex, vtKey, vtText, vtWidth, vtEmpty, reinterpret_cast<MMCColumnHeader **>(ppiMMCColumnHeader));
    IfFailGo(hr);

Error:
    ::VariantClear(&vtEmpty);
    ::VariantClear(&vtIndex);
    ::VariantClear(&vtText);
    ::VariantClear(&vtWidth);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::ExitDoingNewHeaderState(IMMCColumnHeader *piMMCColumnHeader)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::ExitDoingNewHeaderState(IMMCColumnHeader *piMMCColumnHeader)
{
    HRESULT                     hr = S_OK;

    ASSERT(m_piMMCColumnHeaders != NULL, "ExitDoingNewHeaderState: m_piMMCColumnHeaders is NULL");

    if (NULL != piMMCColumnHeader)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_INDEX), TRUE);
    }
    else    // Operation was cancelled
    {
        --m_lCurrentIndex;
        if (m_lCurrentIndex > 0)
        {
            hr = ShowColumnHeader();
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_LV_REMOVE_COLUMN), TRUE);
            IfFailGo(hr);
        }
        else
        {
            hr = EnableEdits(false);
            IfFailGo(hr);

            hr = ClearHeader();
            IfFailGo(hr);
        }
    }

    m_bSavedLastHeader = true;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::GetCurrentHeader()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::GetCurrentHeader(IMMCColumnHeader **ppiMMCColumnHeader)
{

    HRESULT              hr = S_OK;
    VARIANT              vtIndex;
    IMMCColumnHeader    *piMMCColumnHeader = NULL;

    ::VariantInit(&vtIndex);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentIndex;
    hr = m_piMMCColumnHeaders->get_Item(vtIndex, reinterpret_cast<MMCColumnHeader **>(ppiMMCColumnHeader));
    IfFailGo(hr);

Error:
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psnode.cpp ===
//=--------------------------------------------------------------------------------------
// psnode.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Snap-In Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "psnode.h"

// for ASSERT and FAIL
//
SZTHISFILE


const kListVw   = 0;
const kURLVw    = 1;
const kOCXVw    = 2;
const kTaskVw   = 3;


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// ScopeItemDef Property Page General
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CNodeGeneralPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CNodeGeneralPage::Create(IUnknown *pUnkOuter)
{
	CNodeGeneralPage *pNew = New CNodeGeneralPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::CNodeGeneralPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CNodeGeneralPage::CNodeGeneralPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGNODEGENERAL), m_piScopeItemDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::~CNodeGeneralPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CNodeGeneralPage::~CNodeGeneralPage()
{
    RELEASE(m_piScopeItemDef);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnInitializeDialog()
{
    HRESULT             hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_NODE_NAME, IDS_TT_NODE_NAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_NODE_DISPLAY_NAME, IDS_TT_NODE_DISPLAY);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_FOLDER, IDS_TT_NODE_FOLDER);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_VIEWS, IDS_TT_NODE_DEFAULT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_AUTO_CREATE, IDS_TT_NODE_AUTOCR);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    BSTR            bstrName = NULL;
    BSTR            bstrDisplayName = NULL;
    IMMCImageList  *piMMCImageList = NULL;
    BSTR            bstrImageList = NULL;
    VARIANT         vtClosedFolder;
    VARIANT         vtOpenFolder;
    BSTR            bstrDefaultView = NULL;
	VARIANT_BOOL	vtbAutoCreate = VARIANT_FALSE;

    ::VariantInit(&vtClosedFolder);
    ::VariantInit(&vtOpenFolder);

    if (NULL != m_piScopeItemDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IScopeItemDef, reinterpret_cast<void **>(&m_piScopeItemDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    // Initialize the ScopeItemDef's name
    hr = m_piScopeItemDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_NODE_NAME, bstrName);
    IfFailGo(hr);

    // Initialize the ScopeItemDef's display name
    hr = m_piScopeItemDef->get_DisplayName(&bstrDisplayName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_NODE_DISPLAY_NAME, bstrDisplayName);
    IfFailGo(hr);

    // Initialize the ScopeItemDef's folder
    hr = m_piScopeItemDef->get_Folder(&vtClosedFolder);
    IfFailGo(hr);

    hr = SetDlgText(vtClosedFolder, IDC_EDIT_FOLDER);
    IfFailGo(hr);

    // Initialize the ScopeItemDef's default view
    hr = PopulateViews();
    IfFailGo(hr);

    if (S_OK == hr)
    {
        hr = m_piScopeItemDef->get_DefaultView(&bstrDefaultView);
        IfFailGo(hr);

        hr = SelectCBBstr(IDC_COMBO_VIEWS, bstrDefaultView);
        IfFailGo(hr);
    }
    else
    {
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_VIEWS), FALSE);
    }

	// Initialize Auto-Create
	hr = m_piScopeItemDef->get_AutoCreate(&vtbAutoCreate);
	IfFailGo(hr);

	hr = SetCheckbox(IDC_CHECK_AUTO_CREATE, vtbAutoCreate);
	IfFailGo(hr);

    m_bInitialized = true;

Error:
    FREESTRING(bstrDefaultView);
    ::VariantClear(&vtOpenFolder);
    ::VariantClear(&vtClosedFolder);
    FREESTRING(bstrImageList);
    RELEASE(piMMCImageList);
    FREESTRING(bstrDisplayName);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::PopulateViews()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::PopulateViews()
{
    HRESULT            hr = S_OK;
    bool               bGotOneIn = false;
    IViewDefs         *piViewDefs = NULL;
    IListViewDefs     *piListViewDefs = NULL;
    long               lCount = 0;
    long               lIndex = 0;
    VARIANT            vtIndex;
    IListViewDef      *piListViewDef = NULL;
    BSTR               bstrKey = NULL;
    IOCXViewDefs      *piOCXViewDefs = NULL;
    IOCXViewDef       *piOCXViewDef = NULL;
    IURLViewDefs      *piURLViewDefs = NULL;
    IURLViewDef       *piURLViewDef = NULL;
    ITaskpadViewDefs  *piTaskpadViewDefs = NULL;
    ITaskpadViewDef   *piTaskpadViewDef = NULL;

    ASSERT(NULL != m_piScopeItemDef, "PopulateViews: m_piScopeItemDef is NULL");

    ::VariantInit(&vtIndex);

    hr = m_piScopeItemDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    hr = piViewDefs->get_ListViews(&piListViewDefs);
    IfFailGo(hr);

    hr = piListViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (false == bGotOneIn && lCount > 0)
        bGotOneIn = true;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piListViewDefs->get_Item(vtIndex, &piListViewDef);
        IfFailGo(hr);

        hr = piListViewDef->get_Key(&bstrKey);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrKey, MAKELONG(kListVw, static_cast<short>(lIndex)));
        IfFailGo(hr);

        FREESTRING(bstrKey);
        RELEASE(piListViewDef);
    }

    hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
    IfFailGo(hr);

    hr = piOCXViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (false == bGotOneIn && lCount > 0)
        bGotOneIn = true;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piOCXViewDefs->get_Item(vtIndex, &piOCXViewDef);
        IfFailGo(hr);

        hr = piOCXViewDef->get_Key(&bstrKey);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrKey, MAKELONG(kOCXVw, static_cast<short>(lIndex)));
        IfFailGo(hr);

        FREESTRING(bstrKey);
        RELEASE(piOCXViewDef);
    }

    hr = piViewDefs->get_URLViews(&piURLViewDefs);
    IfFailGo(hr);

    hr = piURLViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (false == bGotOneIn && lCount > 0)
        bGotOneIn = true;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piURLViewDefs->get_Item(vtIndex, &piURLViewDef);
        IfFailGo(hr);

        hr = piURLViewDef->get_Key(&bstrKey);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrKey, MAKELONG(kURLVw, static_cast<short>(lIndex)));
        IfFailGo(hr);

        FREESTRING(bstrKey);
        RELEASE(piURLViewDef);
    }

    hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
    IfFailGo(hr);

    hr = piTaskpadViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (false == bGotOneIn && lCount > 0)
        bGotOneIn = true;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piTaskpadViewDefs->get_Item(vtIndex, &piTaskpadViewDef);
        IfFailGo(hr);

        hr = piTaskpadViewDef->get_Key(&bstrKey);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrKey, MAKELONG(kTaskVw, static_cast<short>(lIndex)));
        IfFailGo(hr);

        FREESTRING(bstrKey);
        RELEASE(piTaskpadViewDef);
    }

    hr = (true == bGotOneIn) ? S_OK : S_FALSE;

Error:
    RELEASE(piTaskpadViewDef);
    RELEASE(piTaskpadViewDefs);
    RELEASE(piURLViewDef);
    RELEASE(piURLViewDefs);
    RELEASE(piOCXViewDef);
    RELEASE(piOCXViewDefs);
    FREESTRING(bstrKey);
    RELEASE(piListViewDef);
    ::VariantClear(&vtIndex);
    RELEASE(piListViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(NULL != m_piScopeItemDef, "OnApply: m_piScopeItemDef is NULL");

    hr = ApplyName();
    IfFailGo(hr);

    hr = ApplyDisplayName();
    IfFailGo(hr);

    hr = ApplyFolder();
    IfFailGo(hr);

    hr = ApplyDefaultView();
    IfFailGo(hr);

	hr = ApplyAutoCreate();
	IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::ApplyName()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::ApplyName()
{
    HRESULT hr = S_OK;
    BSTR    bstrNodeName = NULL;
    BSTR    bstrSavedNodeName = NULL;

    ASSERT(NULL != m_piScopeItemDef, "ApplyName: m_piScopeItemDef is NULL");

    hr = GetDlgText(IDC_EDIT_NODE_NAME, &bstrNodeName);
    IfFailGo(hr);

    hr = m_piScopeItemDef->get_Name(&bstrSavedNodeName);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrNodeName, bstrSavedNodeName))
    {
        hr = m_piScopeItemDef->put_Name(bstrNodeName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedNodeName);
    FREESTRING(bstrNodeName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::ApplyDisplayName
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::ApplyDisplayName()
{
    HRESULT hr = S_OK;
    BSTR    bstrDisplayName = NULL;
    BSTR    bstrSavedDisplayName = NULL;

    ASSERT(NULL != m_piScopeItemDef, "ApplyDisplayName: m_piScopeItemDef is NULL");

    hr = GetDlgText(IDC_EDIT_NODE_DISPLAY_NAME, &bstrDisplayName);
    IfFailGo(hr);

    hr = m_piScopeItemDef->get_DisplayName(&bstrSavedDisplayName);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrDisplayName, bstrSavedDisplayName))
    {
        hr = m_piScopeItemDef->put_DisplayName(bstrDisplayName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedDisplayName);
    FREESTRING(bstrDisplayName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::ApplyFolder
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::ApplyFolder()
{
    HRESULT     hr = S_OK;
    BSTR        bstrFolder = NULL;
    VARIANT     vtFolder;

    ASSERT(NULL != m_piScopeItemDef, "ApplyFolder: m_piScopeItemDef is NULL");

    ::VariantInit(&vtFolder);

    hr = GetDlgText(IDC_EDIT_FOLDER, &bstrFolder);
    IfFailGo(hr);

    hr = m_piScopeItemDef->get_Folder(&vtFolder);
    IfFailGo(hr);

    if (VT_BSTR != vtFolder.vt || 0 != ::wcscmp(bstrFolder, vtFolder.bstrVal))
    {
        ::VariantClear(&vtFolder);
        vtFolder.vt = VT_BSTR;
        vtFolder.bstrVal = ::SysAllocString(bstrFolder);
        if (NULL == vtFolder.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        hr = m_piScopeItemDef->put_Folder(vtFolder);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtFolder);
    FREESTRING(bstrFolder);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::ApplyDefaultView()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::ApplyDefaultView()
{
    HRESULT hr = S_OK;
    BSTR    bstrDefaultView = NULL;
    BSTR    bstrSavedDefaultView = NULL;

    ASSERT(NULL != m_piScopeItemDef, "ApplyDisplayName: m_piScopeItemDef is NULL");

    hr = GetCBSelection(IDC_COMBO_VIEWS, &bstrDefaultView);
    IfFailGo(hr);

    if (S_OK == hr)
    {
        hr = m_piScopeItemDef->get_DefaultView(&bstrSavedDefaultView);
        IfFailGo(hr);

        if (0 != ::wcscmp(bstrDefaultView, bstrSavedDefaultView))
        {
            hr = m_piScopeItemDef->put_DefaultView(bstrDefaultView);
            IfFailGo(hr);
        }
    }

Error:
    FREESTRING(bstrSavedDefaultView);
    FREESTRING(bstrDefaultView);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::ApplyAutoCreate()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::ApplyAutoCreate()
{
    HRESULT			hr = S_OK;
	VARIANT_BOOL	vtbAutoCreate = VARIANT_FALSE;
	VARIANT_BOOL	vtbSavedAutoCreate = VARIANT_FALSE;

    ASSERT(NULL != m_piScopeItemDef, "ApplyAutoCreate: m_piScopeItemDef is NULL");

	hr = GetCheckbox(IDC_CHECK_AUTO_CREATE, &vtbAutoCreate);
	IfFailGo(hr);

	hr = m_piScopeItemDef->get_AutoCreate(&vtbSavedAutoCreate);
	IfFailGo(hr);

	if (vtbSavedAutoCreate != vtbAutoCreate)
	{
		hr = m_piScopeItemDef->put_AutoCreate(vtbAutoCreate);
		IfFailGo(hr);
	}

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnTextChanged(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnTextChanged
(
    int dlgItemID
)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_EDIT_NODE_NAME:
    case IDC_EDIT_NODE_DISPLAY_NAME:
    case IDC_EDIT_FOLDER:
        break; 
    }

//Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_CHECK_AUTO_CREATE:
        MakeDirty();
        break;
    }

    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_COMBO_VIEWS:
        hr = OnViewsChangeSelection();
        IfFailGo(hr);
        MakeDirty();
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnClosedChangeSelection()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnClosedChangeSelection()
{
    HRESULT hr = S_OK;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnOpenChangeSelection()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnOpenChangeSelection()
{
    HRESULT hr = S_OK;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnViewsChangeSelection()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnViewsChangeSelection()
{
    HRESULT hr = S_OK;

    RRETURN(hr);
}



////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// ScopeItem Property Page Column Headers
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CScopeItemDefColHdrsPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CScopeItemDefColHdrsPage::Create(IUnknown *pUnkOuter)
{
	CScopeItemDefColHdrsPage *pNew = New CScopeItemDefColHdrsPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::CScopeItemDefColHdrsPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CScopeItemDefColHdrsPage::CScopeItemDefColHdrsPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGNODECOLHDRS),
  m_piScopeItemDef(0), m_piMMCColumnHeaders(0), m_lCurrentIndex(0), m_bSavedLastHeader(true)
{
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::~CScopeItemDefColHdrsPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CScopeItemDefColHdrsPage::~CScopeItemDefColHdrsPage()
{
    RELEASE(m_piScopeItemDef);
    RELEASE(m_piMMCColumnHeaders);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnInitializeDialog()
{
    HRESULT           hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_SI_INDEX, IDS_TT_LV4_INDEX);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_SI_COLUMNTEXT, IDS_TT_LV4_TEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_SI_COLUMNWIDTH, IDS_TT_LV4_WIDTH);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_SI_AUTOWIDTH, IDS_TT_LV4_AUTOWIDTH);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_SI_COLUMNKEY, IDS_TT_LV4_KEY);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnNewObjects()
{
    HRESULT           hr = S_OK;
    IUnknown         *pUnk = NULL;
    DWORD             dwDummy = 0;
    long              lCount = 0;

    if (NULL != m_piScopeItemDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IScopeItemDef, reinterpret_cast<void **>(&m_piScopeItemDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piScopeItemDef->get_ColumnHeaders(&m_piMMCColumnHeaders);
    IfFailGo(hr);

    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        m_lCurrentIndex = 1;
        hr = ShowColumnHeader();
        IfFailGo(hr);

        EnableEdits(true);
    }
    else
    {
        hr = SetDlgText(IDC_EDIT_SI_INDEX, m_lCurrentIndex);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), FALSE);
        EnableEdits(false);
    }

    m_bInitialized = true;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnApply()
{
    HRESULT              hr = S_OK;
    IMMCColumnHeader    *piMMCColumnHeader = NULL;
    int                  disposition = 0;
    long                 lCount = 0;

    ASSERT(NULL != m_piScopeItemDef, "OnApply: m_piScopeItemDef is NULL");
    ASSERT(NULL != m_piMMCColumnHeaders, "OnApply: m_piMMCColumnHeaders is NULL");

    if (0 == m_lCurrentIndex)
        goto Error;

    if (false == m_bSavedLastHeader)
    {
        hr = CanCreateNewHeader();
        IfFailGo(hr);

        if (S_FALSE == hr)
        {
            hr = HandleCantCommit(_T("Can\'t create new ColumnHeader"), _T("Would you like to discard your changes?"), &disposition);
            if (kSICancelOperation == disposition)
            {
                hr = E_INVALIDARG;
                goto Error;
            }
            else
            {
                // Discard changes
                hr = ExitDoingNewHeaderState(NULL);
                IfFailGo(hr);

                hr = S_OK;
                goto Error;
            }
        }

        hr = CreateNewHeader(&piMMCColumnHeader);
        IfFailGo(hr);

        hr = ExitDoingNewHeaderState(piMMCColumnHeader);
        IfFailGo(hr);
    }
    else
    {
        hr = GetCurrentHeader(&piMMCColumnHeader);
        IfFailGo(hr);
    }

    hr = ApplyCurrentHeader();
    IfFailGo(hr);

    // Adjust the remove button as necessary
    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (0 == lCount)
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), FALSE);
    else
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), TRUE);

    m_bSavedLastHeader = true;

Error:
    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_COLHDR_APPLY_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_ColhdrApplyFailed, 0, DontAppendErrorInfo, NULL);
    }

    RELEASE(piMMCColumnHeader);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::ApplyCurrentHeader()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::ApplyCurrentHeader()
{
    HRESULT             hr = S_OK;
    VARIANT             vtIndex;
    IMMCColumnHeader   *piMMCColumnHeader = NULL;
    BSTR                bstrText = NULL;
    VARIANT_BOOL        bAutoWidth = VARIANT_FALSE;
    int                 iWidth = 0;
    BSTR                bstrKey = NULL;

    ::VariantInit(&vtIndex);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentIndex;

    hr = m_piMMCColumnHeaders->get_Item(vtIndex, reinterpret_cast<MMCColumnHeader **>(&piMMCColumnHeader));
    IfFailGo(hr);

    // The Text property
    hr = GetDlgText(IDC_EDIT_SI_COLUMNTEXT, &bstrText);
    IfFailGo(hr);

    hr = piMMCColumnHeader->put_Text(bstrText);
    IfFailGo(hr);

    // The Column Width property
    hr = GetCheckbox(IDC_CHECK_SI_AUTOWIDTH, &bAutoWidth);
    IfFailGo(hr);

    if (VARIANT_TRUE == bAutoWidth)
    {
        hr = piMMCColumnHeader->put_Width(siColumnAutoWidth);
        IfFailGo(hr);
    }
    else
    {
        hr = GetDlgInt(IDC_EDIT_SI_COLUMNWIDTH, &iWidth);
        IfFailGo(hr);

        hr = piMMCColumnHeader->put_Width(static_cast<short>(iWidth));
        IfFailGo(hr);
    }

    // The Key property
    hr = GetDlgText(IDC_EDIT_SI_COLUMNKEY, &bstrKey);
    IfFailGo(hr);

    if (0 == ::SysStringLen(bstrKey))
    {
        FREESTRING(bstrKey);
    }

    hr = piMMCColumnHeader->put_Key(bstrKey);
    IfFailGo(hr);

Error:
    FREESTRING(bstrKey);
    FREESTRING(bstrText);
    RELEASE(piMMCColumnHeader);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT     hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_BUTTON_SI_INSERT_COLUMN:
        if (S_OK == IsPageDirty())
        {
            hr = OnApply();
            IfFailGo(hr);
        }

        hr = CanEnterDoingNewHeaderState();
        IfFailGo(hr);

        if (S_OK == hr)
        {
            hr = EnterDoingNewHeaderState();
            IfFailGo(hr);
        }
        break;

    case IDC_BUTTON_SI_REMOVE_COLUMN:
        hr = OnRemoveColumn();
        IfFailGo(hr);
        break;

    case IDC_CHECK_SI_AUTOWIDTH:
        hr = OnAutoWidth();
        IfFailGo(hr);
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnRemoveColumn()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnRemoveColumn()
{
    HRESULT             hr = S_OK;
    IMMCColumnHeader   *piMMCColumnHeader = NULL;
    VARIANT             vtKey;
    long                lCount = 0;

    ::VariantInit(&vtKey);

    hr = GetCurrentHeader(&piMMCColumnHeader);
    IfFailGo(hr);

    hr = piMMCColumnHeader->get_Index(&vtKey.lVal);
    IfFailGo(hr);

    vtKey.vt = VT_I4;

    hr = m_piMMCColumnHeaders->Remove(vtKey);
    IfFailGo(hr);

    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        if (m_lCurrentIndex > lCount)
            m_lCurrentIndex = lCount;

        hr = ShowColumnHeader();
        IfFailGo(hr);
    }
    else
    {
        m_lCurrentIndex = 0;

        hr = ClearHeader();
        IfFailGo(hr);

        hr = EnableEdits(false);
        IfFailGo(hr);

		::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), FALSE);
    }


Error:
    RELEASE(piMMCColumnHeader);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnAutoWidth()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnAutoWidth()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bValue = VARIANT_FALSE;

    hr = GetCheckbox(IDC_CHECK_SI_AUTOWIDTH, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNWIDTH), FALSE);
    else
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNWIDTH), TRUE);

    MakeDirty();

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnKillFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnKillFocus(int dlgItemID)
{
    HRESULT          hr = S_OK;
    int              lIndex = 0;
    long             lCount = 0;

    if (false == m_bSavedLastHeader)
    {
        goto Error;
    }

    switch (dlgItemID)
    {
    case IDC_EDIT_SI_INDEX:
        hr = GetDlgInt(IDC_EDIT_SI_INDEX, &lIndex);
        IfFailGo(hr);

        hr = m_piMMCColumnHeaders->get_Count(&lCount);
        IfFailGo(hr);

        if (lIndex != m_lCurrentIndex)
        {
            if (lIndex >= 1)
            {
                if (lIndex > lCount)
                    m_lCurrentIndex = lCount;
                else
                    m_lCurrentIndex = lIndex;

                hr = ShowColumnHeader();
                IfFailGo(hr);
            }
        }
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::ClearHeader()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::ClearHeader()
{
    HRESULT hr = S_OK;

    hr = SetDlgText(IDC_EDIT_SI_INDEX, m_lCurrentIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_SI_COLUMNTEXT, static_cast<BSTR>(NULL));
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_SI_COLUMNWIDTH, static_cast<BSTR>(NULL));
    IfFailGo(hr);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNWIDTH), TRUE);

    hr = SetCheckbox(IDC_CHECK_SI_AUTOWIDTH, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_SI_COLUMNKEY, static_cast<BSTR>(NULL));
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::EnableEdits(bool bEnable)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::EnableEdits
(
    bool bEnable
)
{
    BOOL    fEnable = false == bEnable ? TRUE : FALSE;

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNTEXT), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNWIDTH), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNKEY), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_SI_AUTOWIDTH), (TRUE == fEnable) ? FALSE : TRUE);

    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::ShowColumnHeader()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::ShowColumnHeader()
{

    HRESULT              hr = S_OK;
    VARIANT              vtIndex;
    IMMCColumnHeader    *piMMCColumnHeader = NULL;
    BSTR                 bstrText = NULL;
    short                iWidth = 0;
    BSTR                 bstrKey = NULL;

    ASSERT(NULL != m_piMMCColumnHeaders, "ShowColumnHeader: m_piMMCColumnHeaders is NULL");

    ::VariantInit(&vtIndex);

    hr = SetDlgText(IDC_EDIT_SI_INDEX, m_lCurrentIndex);
    IfFailGo(hr);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentIndex;
    hr = m_piMMCColumnHeaders->get_Item(vtIndex, reinterpret_cast<MMCColumnHeader **>(&piMMCColumnHeader));
    IfFailGo(hr);

    hr = piMMCColumnHeader->get_Text(&bstrText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_SI_COLUMNTEXT, bstrText);
    IfFailGo(hr);

    hr = piMMCColumnHeader->get_Width(&iWidth);
    IfFailGo(hr);

    if (siColumnAutoWidth == static_cast<SnapInColumnWidthConstants>(iWidth))
    {
        EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNWIDTH), FALSE);
        iWidth = 0;

        hr = SetCheckbox(IDC_CHECK_SI_AUTOWIDTH, VARIANT_TRUE);
        IfFailGo(hr);
    }
    else
    {
        EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNWIDTH), TRUE);

        hr = SetCheckbox(IDC_CHECK_SI_AUTOWIDTH, VARIANT_FALSE);
        IfFailGo(hr);
    }

    hr = SetDlgText(IDC_EDIT_SI_COLUMNWIDTH, iWidth);
    IfFailGo(hr);

    hr = piMMCColumnHeader->get_Key(&bstrKey);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_SI_COLUMNKEY, bstrKey);
    IfFailGo(hr);

Error:
    FREESTRING(bstrKey);
    FREESTRING(bstrText);
    RELEASE(piMMCColumnHeader);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnDeltaPos(NMUPDOWN *pNMUpDown)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnDeltaPos
(
    NMUPDOWN *pNMUpDown
)
{
    HRESULT             hr = S_OK;
    long                lCount = 0;

    if (false == m_bSavedLastHeader || S_OK == IsPageDirty())
    {
        hr = OnApply();
        IfFailGo(hr);
    }

    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (pNMUpDown->iDelta < 0)
    {
        if (m_lCurrentIndex < lCount)
        {
            ++m_lCurrentIndex;
            hr = ShowColumnHeader();
            IfFailGo(hr);
        }
    }
    else
    {
        if (m_lCurrentIndex > 1 && m_lCurrentIndex <= lCount)
        {
            --m_lCurrentIndex;
            hr = ShowColumnHeader();
            IfFailGo(hr);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::CanEnterDoingNewHeaderState()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::CanEnterDoingNewHeaderState()
{
    HRESULT     hr = S_FALSE;

    if (true == m_bSavedLastHeader)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::EnterDoingNewHeaderState()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::EnterDoingNewHeaderState()
{
    HRESULT      hr = S_OK;

    ASSERT(NULL != m_piScopeItemDef, "EnterDoingNewHeaderState: m_piScopeItemDef is NULL");
    ASSERT(NULL != m_piMMCColumnHeaders, "EnterDoingNewHeaderState: m_piMMCColumnHeaders is NULL");

    // Bump up the current button index to keep matters in sync.
    ++m_lCurrentIndex;
    hr = SetDlgText(IDC_EDIT_SI_INDEX, m_lCurrentIndex);
    IfFailGo(hr);

    // We disable the RemoveButton.
    // The InsertButton button remains enabled and acts like an "Apply and New" button
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), FALSE);

    // Enable edits in this area of the dialog and clear all the entries
    hr = EnableEdits(true);
    IfFailGo(hr);

    hr = ClearHeader();
    IfFailGo(hr);

    m_bSavedLastHeader = false;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::CanCreateNewHeader()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::CanCreateNewHeader()
{
    HRESULT      hr = S_OK;
    BSTR         bstrWidth = NULL;
    VARIANT_BOOL bAutoWidth = VARIANT_FALSE;
    VARIANT      vtWidth;

    ::VariantInit(&vtWidth);

    // ColumnWidth must be a short if it is not auto-width.
    // First see if auto-width is checked.

    hr = GetCheckbox(IDC_CHECK_SI_AUTOWIDTH, &bAutoWidth);
    IfFailGo(hr);

    IfFalseGo(VARIANT_TRUE != bAutoWidth, S_OK);

    // Not using auto-width. Make sure that the text box contains a short.

    hr = GetDlgText(IDC_EDIT_SI_COLUMNWIDTH, &bstrWidth);
    IfFailGo(hr);

    vtWidth.vt = VT_BSTR;
    vtWidth.bstrVal = ::SysAllocString(bstrWidth);
    if (NULL == vtWidth.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = ::VariantChangeType(&vtWidth, &vtWidth, 0, VT_I2);
    if (FAILED(hr))
    {
        hr = HandleError(_T("ColumnHeaders"), _T("Column width must be an integer between 1 and 32767."));
        hr = S_FALSE;
    }

Error:
    ::VariantClear(&vtWidth);
    FREESTRING(bstrWidth);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::CreateNewHeader()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::CreateNewHeader(IMMCColumnHeader **ppiMMCColumnHeader)
{
    HRESULT              hr = S_OK;
    VARIANT              vtIndex;
    VARIANT              vtEmpty;
    VARIANT              vtKey;
    VARIANT              vtText;
    VARIANT_BOOL         bAutoWidth = VARIANT_FALSE;
    int                  iWidth = 0;
    VARIANT              vtWidth;

    ::VariantInit(&vtIndex);
    ::VariantInit(&vtEmpty);
    ::VariantInit(&vtText);
    ::VariantInit(&vtWidth);
    ::VariantInit(&vtKey);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentIndex;

    vtEmpty.vt = VT_ERROR;
    vtEmpty.scode = DISP_E_PARAMNOTFOUND;

    vtKey.vt = VT_BSTR;
    hr = GetDlgText(IDC_EDIT_SI_COLUMNKEY, &vtKey.bstrVal);
    IfFailGo(hr);

    if (NULL == vtKey.bstrVal)
    {
        vtKey = vtEmpty;
    }
    else if (0 == ::SysStringLen(vtKey.bstrVal))
    {
        IfFailGo(::VariantClear(&vtKey));
        vtKey = vtEmpty;
    }

    vtText.vt = VT_BSTR;
    hr = GetDlgText(IDC_EDIT_SI_COLUMNTEXT, &vtText.bstrVal);
    IfFailGo(hr);

    hr = GetCheckbox(IDC_CHECK_SI_AUTOWIDTH, &bAutoWidth);
    IfFailGo(hr);

    if (VARIANT_FALSE == bAutoWidth)
    {
        hr = GetDlgInt(IDC_EDIT_SI_COLUMNWIDTH, &iWidth);
        IfFailGo(hr);
    }
    else
    {
        iWidth = siColumnAutoWidth;
    }

    vtWidth.vt = VT_I2;
    vtWidth.iVal = static_cast<short>(iWidth);

    hr = m_piMMCColumnHeaders->Add(vtIndex, vtKey, vtText, vtWidth, vtEmpty, reinterpret_cast<MMCColumnHeader **>(ppiMMCColumnHeader));
    IfFailGo(hr);

Error:
    ::VariantClear(&vtIndex);
    ::VariantClear(&vtEmpty);
    ::VariantClear(&vtText);
    ::VariantClear(&vtWidth);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::ExitDoingNewHeaderState(IMMCColumnHeader *piMMCColumnHeader)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::ExitDoingNewHeaderState(IMMCColumnHeader *piMMCColumnHeader)
{
    HRESULT                     hr = S_OK;

    ASSERT(m_piScopeItemDef != NULL, "ExitDoingNewHeaderState: m_piScopeItemDef is NULL");
    ASSERT(m_piMMCColumnHeaders != NULL, "ExitDoingNewHeaderState: m_piMMCColumnHeaders is NULL");

    if (NULL != piMMCColumnHeader)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), TRUE);
    }
    else    // Operation was cancelled
    {
        --m_lCurrentIndex;
        if (m_lCurrentIndex > 0)
        {
            hr = ShowColumnHeader();
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), TRUE);
            IfFailGo(hr);
        }
        else
        {
            hr = EnableEdits(false);
            IfFailGo(hr);

            hr = ClearHeader();
            IfFailGo(hr);
        }
    }

    m_bSavedLastHeader = true;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::GetCurrentHeader()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::GetCurrentHeader(IMMCColumnHeader **ppiMMCColumnHeader)
{

    HRESULT              hr = S_OK;
    VARIANT              vtIndex;

    ::VariantInit(&vtIndex);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentIndex;
    hr = m_piMMCColumnHeaders->get_Item(vtIndex, reinterpret_cast<MMCColumnHeader **>(ppiMMCColumnHeader));
    IfFailGo(hr);

Error:
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psimglst.cpp ===
//=--------------------------------------------------------------------------------------
// psimglst.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// ImageList Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "psimglst.h"

// for ASSERT and FAIL
//
SZTHISFILE


const int   CX_IMAGE_HILIGHT    = 2;
const int   CY_IMAGE_HILIGHT    = 2;

const int   CX_IMAGE_BORDER     = CX_IMAGE_HILIGHT * 3;
const int   CY_IMAGE_BORDER     = CY_IMAGE_HILIGHT * 3;

const int   OX_IMAGE_FOCUS      = CX_IMAGE_HILIGHT * 2;
const int   OY_IMAGE_FOCUS      = CY_IMAGE_HILIGHT * 2;


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// ImageLists Property Page Images
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CImageListImagesPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CImageListImagesPage::Create(IUnknown *pUnkOuter)
{
	CImageListImagesPage *pNew = New CImageListImagesPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::CImageListImagesPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CImageListImagesPage::CImageListImagesPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGIMGLISTSIMAGES), m_piMMCImageList(0), m_iCurrentImage(0)
{
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::~CImageListImagesPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CImageListImagesPage::~CImageListImagesPage()
{
    RELEASE(m_piMMCImageList);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnInitializeDialog()
{
    HRESULT      hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_IL_INDEX, IDS_TT_IL_INDEX);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_IL_KEY, IDS_TT_IL_KEY);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_IL_TAG, IDS_TT_IL_TAG);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_IL_IMAGE_COUNT, IDS_TT_IL_COUNT);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    IMMCImages     *piMMCImages = NULL;
    long            lCount = 0;
    VARIANT         vtIndex;
    IMMCImage      *piMMCImage = NULL;
    BSTR            bstrKey = NULL;
    VARIANT         vtTag;
    VARIANT         vtTagBstr;

    ::VariantInit(&vtIndex);
    ::VariantInit(&vtTag);
    ::VariantInit(&vtTagBstr);

    if (m_piMMCImageList != NULL)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IMMCImageList, reinterpret_cast<void **>(&m_piMMCImageList));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
    IfFailGo(hr);

    hr = piMMCImages->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        m_iCurrentImage = 1;

        hr = SetDlgText(IDC_EDIT_IL_INDEX, m_iCurrentImage);
        IfFailGo(hr);

        vtIndex.vt = VT_I4;
        vtIndex.lVal = m_iCurrentImage;
        hr = piMMCImages->get_Item(vtIndex, reinterpret_cast<MMCImage **>(&piMMCImage));
        IfFailGo(hr);

        hr = piMMCImage->get_Key(&bstrKey);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_IL_KEY, bstrKey);
        IfFailGo(hr);

        hr = piMMCImage->get_Tag(&vtTag);
        IfFailGo(hr);

        hr = ::VariantChangeType(&vtTagBstr, &vtTag, 0, VT_BSTR);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_IL_TAG, vtTagBstr.bstrVal);
        IfFailGo(hr);

        hr = UpdateImages();
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_IL_IMAGES), LB_SETCURSEL, 0 ,0);
    }
    else
    {
        hr = SetDlgText(IDC_EDIT_IL_INDEX, m_iCurrentImage);
        IfFailGo(hr);

        hr = EnableInput(false);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_IL_REMOVE_PICTURE), FALSE);
    }

    hr = SetDlgText(IDC_EDIT_IL_IMAGE_COUNT, lCount);
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    ::VariantClear(&vtTagBstr);
    ::VariantClear(&vtTag);
    FREESTRING(bstrKey);
    RELEASE(piMMCImage);
    ::VariantClear(&vtIndex);
    RELEASE(piMMCImages);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnApply()
{
    HRESULT      hr = S_OK;
    IMMCImages  *piMMCImages = NULL;
    VARIANT      vtIndex;
    IMMCImage   *piMMCImage = NULL;
    BSTR         bstrKey = NULL;
    VARIANT      vtTag;

    ASSERT(m_piMMCImageList != NULL, "OnApply: m_piMMCImageList is NULL");

    ::VariantInit(&vtIndex);
    ::VariantInit(&vtTag);

    if (m_iCurrentImage > 0)
    {
        hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
        IfFailGo(hr);

        vtIndex.vt = VT_I4;
        vtIndex.lVal = m_iCurrentImage;
        hr = piMMCImages->get_Item(vtIndex, reinterpret_cast<MMCImage **>(&piMMCImage));

        hr = GetDlgText(IDC_EDIT_IL_KEY, &bstrKey);
        IfFailGo(hr);

        hr = piMMCImage->put_Key(bstrKey);
        IfFailGo(hr);

        vtTag.vt = VT_BSTR;
        hr = GetDlgText(IDC_EDIT_IL_TAG, &vtTag.bstrVal);
        IfFailGo(hr);

        hr = piMMCImage->put_Tag(vtTag);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtTag);
    FREESTRING(bstrKey);
    RELEASE(piMMCImage);
    ::VariantClear(&vtIndex);
    RELEASE(piMMCImages);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnKillFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// If the index field lost focus and the index has changed then do an Apply if dirty and
// move to the requested index if valid.
//
HRESULT CImageListImagesPage::OnKillFocus(int dlgItemID)
{
    HRESULT          hr = S_OK;
    IMMCImages      *piMMCImages = NULL;
    int              lIndex = 0;
    long             lCount = 0;
    VARIANT          vtIndex;
    IMMCImage       *piMMCImage = NULL;

    ::VariantInit(&vtIndex);

    switch (dlgItemID)
    {
    case IDC_EDIT_IL_INDEX:

        // Get the contents of the index field. If the user entered something
        // other than a number then set the index to 1.
        
        hr = GetDlgInt(IDC_EDIT_IL_INDEX, &lIndex);
        if (E_INVALIDARG == hr)
        {
            hr = S_OK;
            lIndex = 1L;
            // Set this to zero so code below will detect a change and
            // refresh dialog which will replace junk in index field with "1"
            m_iCurrentImage = 0;
        }
        IfFailGo(hr);

        hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
        IfFailGo(hr);

        hr = piMMCImages->get_Count(&lCount);
        IfFailGo(hr);

        // If there was no change to the index then ignore it

        IfFalseGo(lIndex != m_iCurrentImage, S_OK);

        // If the user entered an index of zero then switch it to 1 because the
        // collection is one-based

        if (0 == lIndex)
        {
            lIndex = 1L;
        }

        // If the user entered an index that is beyond the end of the list then
        // switch to the last valid index

        if (lIndex > lCount)
        {
            lIndex = lCount;
        }

        // If the old image is dirty then save the changes

        if (IsDirty())
        {
            IfFailGo(Apply());
        }

        // Record the new current index
        
        m_iCurrentImage = lIndex;

        // Get the image at the new index

        vtIndex.vt = VT_I4;
        vtIndex.lVal = m_iCurrentImage;
        hr = piMMCImages->get_Item(vtIndex, reinterpret_cast<MMCImage **>(&piMMCImage));
        IfFailGo(hr);

        // Select and display the new image

        hr = ShowImage(piMMCImage);
        IfFailGo(hr);
        break;
    }

Error:
    RELEASE(piMMCImage);
    RELEASE(piMMCImages);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnButtonClicked(int dlgItemID)
{
    HRESULT     hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_BUTTON_IL_INSERT_PICTURE:
        hr = OnInsertPicture();
        IfFailGo(hr);
        break;

    case IDC_BUTTON_IL_REMOVE_PICTURE:
        hr = OnRemovePicture();
        IfFailGo(hr);
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnInsertPicture
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnInsertPicture()
{
    HRESULT       hr = S_OK;
    TCHAR        *pszFileName = NULL;
    IStream      *piStream = NULL;
    IDispatch    *piPictureDisp = NULL;
    IPicture     *piPicture = NULL;
    IMMCImages   *piMMCImages = NULL;
    long          lCount = 0;
    long          cbPicture = 0;
    VARIANT       vtIndex;
    VARIANT       vtKey;
    VARIANT       vtPicture;
    IMMCImage    *piMMCImage = NULL;
    short         PictureType = PICTYPE_UNINITIALIZED;

    ::VariantInit(&vtIndex);
    ::VariantInit(&vtKey);
    ::VariantInit(&vtPicture);

	// If the current picture is unsaved then save it
	if (IsDirty())
	{
		hr = Apply();
		IfFailGo(hr);
	}

    hr = GetFileName(&pszFileName);
    IfFailGo(hr);

    if (hr == S_OK)
    {
        hr = CreateStreamOnFile(pszFileName, &piStream, &cbPicture);
        IfFailGo(hr);

        hr = ::OleLoadPicture(piStream,
                              0,             // Read entire stream
                              FALSE,         // Keep original format
                              IID_IDispatch, // Interface requested
                              reinterpret_cast<void **>(&piPictureDisp));
        EXCEPTION_CHECK_GO(hr);

        // NTBUGS 349270
        // Despite the fact that we only offer *.bmp extensions in the
        // file open dialog, the user can still type in something else like
        // .ico. Ask the picture for its type and display an error for anything
        // but a bitmap.

        IfFailGo(piPictureDisp->QueryInterface(IID_IPicture,
                                   reinterpret_cast<void **>(&piPicture)));

        IfFailGo(piPicture->get_Type(&PictureType));
        if (PICTYPE_BITMAP != PictureType)
        {
            (void)::SDU_DisplayMessage(IDS_INVALID_PICTURE, MB_OK | MB_ICONHAND, HID_mssnapd_InvalidPicture, 0, DontAppendErrorInfo, NULL);
            hr = SID_E_INVALID_IMAGE_TYPE;
            EXCEPTION_CHECK_GO(hr);
        }

        // END NTBUGS 349270

        hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
        IfFailGo(hr);

        hr = piMMCImages->get_Count(&lCount);
        IfFailGo(hr);

        ++m_iCurrentImage;
        vtIndex.vt = VT_I4;
        vtIndex.lVal = m_iCurrentImage;

        vtKey.vt = VT_ERROR;
        vtKey.scode = DISP_E_PARAMNOTFOUND;

        vtPicture.vt = VT_DISPATCH;
        vtPicture.pdispVal = piPictureDisp;

        hr = piMMCImages->Add(vtIndex, vtKey, vtPicture, reinterpret_cast<MMCImage **>(&piMMCImage));
        IfFailGo(hr);

        hr = UpdateImages();
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_IL_IMAGE_COUNT, lCount + 1);
        IfFailGo(hr);

        hr = EnableInput(true);
        IfFailGo(hr);

        hr = ShowImage(piMMCImage);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_IL_REMOVE_PICTURE), TRUE);
    }

	MakeDirty();

Error:
    QUICK_RELEASE(piMMCImage);
    QUICK_RELEASE(piMMCImages);
    QUICK_RELEASE(piPictureDisp);
    QUICK_RELEASE(piPicture);
    QUICK_RELEASE(piStream);
    if (pszFileName != NULL)
        CtlFree(pszFileName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::GetFileName(char **ppszFileName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::GetFileName(TCHAR **ppszFileName)
{
    HRESULT         hr = S_OK;
    BOOL            bResult = FALSE;
    OPENFILENAME    of;
    TCHAR           pszFilter[] = _T("Bitmaps (*.bmp;*.dib)\0*.bmp;*.dib\0\0");
    TCHAR           pszPath[kSIMaxBuffer + 1];
    TCHAR           pszFileName[kSIMaxBuffer + 1];
    TCHAR           pszTitle[] = _T("Choose an image");
    DWORD           dwReturn = 0;

    pszPath[0] = 0;
    pszFileName[0] = 0;

    ::memset(&of, 0, sizeof(OPENFILENAME));
    of.lStructSize = sizeof(OPENFILENAME);
    of.hwndOwner = m_hwnd;
    of.hInstance = GetResourceHandle();
    of.lpstrFilter = pszFilter;
    of.lpstrFile = pszPath;
    of.nMaxFile = kSIMaxBuffer;
    of.lpstrFileTitle = pszFileName;
    of.nMaxFileTitle = kSIMaxBuffer;
    of.lpstrTitle = pszTitle;
    of.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;

    bResult = ::GetOpenFileName(&of);
    if (bResult == FALSE)
    {
        dwReturn = CommDlgExtendedError();
        hr = HRESULT_FROM_WIN32(dwReturn);
        EXCEPTION_CHECK_GO(hr);
        hr = S_FALSE;
    }
    else
    {
        *ppszFileName = reinterpret_cast<TCHAR *>(CtlAlloc(_tcslen(pszPath) + 1));
        if (*ppszFileName == NULL)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        _tcscpy(*ppszFileName, pszPath);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::CreateStreamOnFile(const TCHAR *lpctFilename, IStream **ppStream, long *pcbPicture)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::CreateStreamOnFile(const TCHAR *lpctFilename, IStream **ppStream, long *pcbPicture)
{
    HRESULT     hr = S_OK;
    HANDLE      hFile = NULL;
    DWORD       dwSize = 0;
    HANDLE      hMem = NULL;
    LPVOID      pMem = NULL;
    DWORD       dwRead = 0;

    *ppStream = NULL;


    hFile = ::CreateFile(lpctFilename,                // filename
                         GENERIC_READ,                // Access mode
                         FILE_SHARE_READ,             // Share mode
                         NULL,                        // Security
                         OPEN_EXISTING,
                         FILE_FLAG_SEQUENTIAL_SCAN,   // flags and attributes
                         NULL);                       // template file handle

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    dwSize = ::GetFileSize(hFile, NULL);
    if (dwSize == 0xFFFFFFFF)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    hMem = ::GlobalAlloc(GMEM_MOVEABLE, dwSize);
    if (hMem == NULL) 
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    pMem = ::GlobalLock(hMem);

    if (!::ReadFile(hFile, pMem, dwSize, &dwRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (dwRead != dwSize)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (::GlobalUnlock(hMem) == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (NOERROR != ::GetLastError())
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }
    pMem = NULL;

    hr = ::CreateStreamOnHGlobal(hMem, TRUE, ppStream);
    IfFailGo(hr);
    hMem = NULL;

    // Use static cast to ensure that DWORD fits into a long.
    // Convert to unsigned long first to avoid sign extension.
    *pcbPicture = (long)(static_cast<unsigned long>(dwSize));

Error:
    if (hFile != NULL)
        ::CloseHandle(hFile);	
    if (FAILED(hr))
    {
        if (pMem != NULL)
            ::GlobalUnlock(hMem);
        if (hMem != NULL)
            ::GlobalFree(hMem);
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnRemovePicture
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnRemovePicture()
{
    HRESULT     hr = S_OK;
    IMMCImages *piMMCImages = NULL;
    long        lCount = 0;
    VARIANT     vtIndex;
    IMMCImage  *piMMCImage = NULL;
    BSTR        bstrNull = NULL;

    ::VariantInit(&vtIndex);

    hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
    IfFailGo(hr);

    hr = piMMCImages->get_Count(&lCount);
    IfFailGo(hr);

    if (m_iCurrentImage > 0 && m_iCurrentImage <= lCount)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = m_iCurrentImage;
        --m_iCurrentImage;

        hr = piMMCImages->Remove(vtIndex);
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_IL_IMAGES), LB_DELETESTRING, static_cast<WPARAM>(m_iCurrentImage), 0);

        hr = UpdateImages();
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_IL_IMAGE_COUNT, lCount - 1);
        IfFailGo(hr);

        if (lCount - 1 > 0)
        {
            if (m_iCurrentImage == 0)
                m_iCurrentImage = 1;
            else if (m_iCurrentImage > lCount - 1)
                m_iCurrentImage = lCount - 1;
        }

        if (m_iCurrentImage > 0)
        {
            ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_IL_IMAGES), LB_SETCURSEL, static_cast<WPARAM>(m_iCurrentImage - 1), 0);

            vtIndex.vt = VT_I4;
            vtIndex.lVal = m_iCurrentImage;

            hr = piMMCImages->get_Item(vtIndex, reinterpret_cast<MMCImage **>(&piMMCImage));
            IfFailGo(hr);

            hr = ShowImage(piMMCImage);
            IfFailGo(hr);
        }
        else
        {
            hr = SetDlgText(IDC_EDIT_IL_INDEX, bstrNull);
            IfFailGo(hr);

            hr = SetDlgText(IDC_EDIT_IL_KEY, bstrNull);
            IfFailGo(hr);

            hr = SetDlgText(IDC_EDIT_IL_TAG, bstrNull);
            IfFailGo(hr);

            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_IL_REMOVE_PICTURE), FALSE);

            hr = EnableInput(false);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piMMCImage);
    ::VariantClear(&vtIndex);
    RELEASE(piMMCImages);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnMeasureItem(MEASUREITEMSTRUCT *pMeasureItemStruct)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnMeasureItem(MEASUREITEMSTRUCT *pMeasureItemStruct)
{
    HRESULT     hr = S_OK;
    RECT        rect;

    ::GetClientRect(::GetDlgItem(m_hwnd, IDC_LIST_IL_IMAGES), &rect);
    pMeasureItemStruct->itemHeight = rect.bottom;
    pMeasureItemStruct->itemWidth = rect.bottom;	

    // VBE#20445: a-cmai 8/1/96 -- Used for the work around
//    m_nVisibleItems = rect.right / rect.bottom;

    return hr;
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnDrawItem(DRAWITEMSTRUCT *pDrawItemStruct)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnDrawItem(DRAWITEMSTRUCT *pDrawItemStruct)
{
    HRESULT     hr = S_OK;
	UINT        uAction = pDrawItemStruct->itemAction;
    HBRUSH      hbr = NULL;
    RECT        rc;

    if (pDrawItemStruct->itemID == -1)
        RRETURN(hr);

    if (uAction == ODA_DRAWENTIRE)
    {
        // Fill background with button face color
        hbr = ::CreateSolidBrush(::GetSysColor(COLOR_BTNFACE));
        if (hbr == NULL)
            ::FillRect(pDrawItemStruct->hDC, &pDrawItemStruct->rcItem, static_cast<HBRUSH>(::GetStockObject(LTGRAY_BRUSH)));
        else
        {
            ::FillRect(pDrawItemStruct->hDC, &pDrawItemStruct->rcItem, hbr);
        }

        // Set up color box rectangle
        ::SetRect(&rc,
                 pDrawItemStruct->rcItem.left + CX_IMAGE_BORDER,
                 pDrawItemStruct->rcItem.top + CY_IMAGE_BORDER, 
                 pDrawItemStruct->rcItem.right - CX_IMAGE_BORDER,
                 pDrawItemStruct->rcItem.bottom - CY_IMAGE_BORDER);

        DrawImage(pDrawItemStruct->hDC, pDrawItemStruct->itemID, rc);

        // Next step is to draw the text with correct selection state
        uAction = ODA_SELECT;
    }

    if (uAction == ODA_SELECT)
    {
        // Set up text rectangle
        ::SetRect(&rc,
                  pDrawItemStruct->rcItem.left,
                  pDrawItemStruct->rcItem.top,
                  pDrawItemStruct->rcItem.right,
                  pDrawItemStruct->rcItem.bottom);

        // Draw selection state
        DrawRectEffect(pDrawItemStruct->hDC, rc, (ODS_SELECTED & pDrawItemStruct->itemState) ? EDGE_RAISED : NULL);

        // If we are to draw the entire item and its has focus then
        // set uAction for drawing the focus 
        //
        if (pDrawItemStruct->itemAction == ODA_DRAWENTIRE && (ODS_FOCUS & pDrawItemStruct->itemState))
            uAction = ODA_FOCUS;
    }    

    if (uAction == ODA_FOCUS)
    {
        // Set up focus rect
        ::SetRect(&rc,
                  pDrawItemStruct->rcItem.left + OX_IMAGE_FOCUS,
                  pDrawItemStruct->rcItem.top + OY_IMAGE_FOCUS,
                  pDrawItemStruct->rcItem.right - OX_IMAGE_FOCUS,
                  pDrawItemStruct->rcItem.bottom - OY_IMAGE_FOCUS);

        DrawRectEffect(pDrawItemStruct->hDC, rc, (ODS_FOCUS & pDrawItemStruct->itemState) ? EDGE_ETCHED : NULL);
    }

    if (hbr != NULL)
        ::DeleteObject(static_cast<HGDIOBJ>(hbr));

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::DrawImage(HDC hdc, int nIndex, const RECT& rcImage)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::DrawImage(HDC hdc, int nIndex, const RECT& rcImage)
{
    HRESULT          hr = S_OK;
    VARIANT          vIndex;
    IMMCImages      *piMMCImages = NULL;
    IMMCImage       *piMMCImage = NULL;
    IPictureDisp    *pPictureDisp = NULL;
    IPicture        *pPicture = NULL;

    ::VariantInit(&vIndex);	

    hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
    IfFailGo(hr);

    vIndex.vt = VT_I4;
    vIndex.lVal = nIndex + 1;
    hr = piMMCImages->get_Item(vIndex, reinterpret_cast<MMCImage **>(&piMMCImage));
    IfFailGo(hr);

    if (piMMCImage != NULL)
    {
        // Get Images(iIndex).Picture
        hr = piMMCImage->get_Picture(&pPictureDisp);
        IfFailGo(hr);

        hr = pPictureDisp->QueryInterface(IID_IPicture, (void **) &pPicture);
        IfFailGo(hr);

        // Draw Images(iIndex).Picture
        if (pPicture != NULL)
            hr = RenderPicture(pPicture, hdc, &rcImage, &rcImage);
    }

Error:
    RELEASE(pPicture);
    RELEASE(pPictureDisp);
    ::VariantClear(&vIndex);
    RELEASE(piMMCImage);
    RELEASE(piMMCImages);

    return TRUE;
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::RenderPicture(IPicture *pPicture, HDC hdc, const RECT *prcRender, const RECT *prcWBounds)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::RenderPicture
(
    IPicture   *pPicture, 
    HDC         hdc, 
    const RECT *prcRender, 
    const RECT *prcWBounds
)
{
    HRESULT     hr = S_OK;
    long        hmWidth = 0;
    long        hmHeight = 0;
    long        lWidth = 0;
    long        lHeight = 0;

    if (pPicture != NULL)
    {
        hr = pPicture->get_Width(&hmWidth);
        hr = pPicture->get_Height(&hmHeight);

        lWidth = prcRender->right - prcRender->left;
        lHeight = prcRender->bottom - prcRender->top;

        if (lWidth < 0)
            lWidth = -lWidth;
        if (lHeight < 0)
            lHeight = -lHeight;

        ASSERT(lWidth >= 0, "Width is negative");
        ASSERT(lHeight >=0, "Height is negative");

        hr = pPicture->Render(hdc,
                              prcRender->left,
                              prcRender->top,
                              lWidth,
                              lHeight,
                              0,
                              hmHeight - 1,
                              hmWidth,
                              -hmHeight,
                              prcWBounds);
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::DrawRectEffect(HDC hdc, const RECT& rc, WORD dwStyle)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::DrawRectEffect(HDC hdc, const RECT& rc, WORD dwStyle)
{
    HRESULT hr = S_OK;
    BOOL    fRet = FALSE;
    HBRUSH  hbr = NULL;
    HBRUSH  hbrOld = NULL;

    if (dwStyle == NULL)
    {
        hbr = ::CreateSolidBrush(::GetSysColor(COLOR_BTNFACE));
        fRet = NULL != hbr;

        if (hbr == NULL)
            hbr = static_cast<HBRUSH>(::GetStockObject(LTGRAY_BRUSH));

        hbrOld = static_cast<HBRUSH>(::SelectObject(hdc, static_cast<HGDIOBJ>(hbr)));

        ::PatBlt(hdc, rc.left, rc.top,     rc.right - rc.left,    CY_IMAGE_HILIGHT,      PATCOPY);
        ::PatBlt(hdc, rc.left, rc.top,     CX_IMAGE_HILIGHT,      rc.bottom - rc.top,    PATCOPY);
        ::PatBlt(hdc, rc.right, rc.bottom, -(rc.right - rc.left), -CY_IMAGE_HILIGHT,     PATCOPY);
        ::PatBlt(hdc, rc.right, rc.bottom, -CX_IMAGE_HILIGHT,     -(rc.bottom - rc.top), PATCOPY);

        ::SelectObject(hdc, static_cast<HGDIOBJ>(hbrOld));

        if (hbr != NULL)
            ::DeleteObject(static_cast<HGDIOBJ>(hbr));
    }	
    else
        fRet = ::DrawEdge(hdc, const_cast<LPRECT>(&rc), dwStyle, BF_RECT);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Called when the user selects a different picture in the listbox
//
HRESULT CImageListImagesPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT      hr = S_OK;
    int          iIndex = 0;
    IMMCImages  *piMMCImages = NULL;
    VARIANT      vtIndex;
    IMMCImage   *piMMCImage = NULL;

    ::VariantInit(&vtIndex);

    // If the current picture is unsaved then save it
    if (IsDirty())
    {
        hr = Apply();
        IfFailGo(hr);
    }

    if (dlgItemID == IDC_LIST_IL_IMAGES)
    {
        iIndex = ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_IL_IMAGES), LB_GETCURSEL, 0, 0);
        if (iIndex == LB_ERR)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        m_iCurrentImage = iIndex + 1;

        hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
        IfFailGo(hr);

        vtIndex.vt = VT_I4;
        vtIndex.lVal = m_iCurrentImage;
        hr = piMMCImages->get_Item(vtIndex, reinterpret_cast<MMCImage **>(&piMMCImage));
        IfFailGo(hr);

        hr = ShowImage(piMMCImage);
        IfFailGo(hr);
    }

Error:
    RELEASE(piMMCImage);
    ::VariantClear(&vtIndex);
    RELEASE(piMMCImages);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::UpdateImages()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::UpdateImages()
{
    HRESULT     hr = S_OK;
    HWND        hwndList = NULL;
    IMMCImages *piMMCImages = NULL;
    long        lCount = 0;
    long        lIndex = 0;

    hwndList = ::GetDlgItem(m_hwnd, IDC_LIST_IL_IMAGES);
    if (hwndList == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    ::SendMessage(hwndList, WM_SETREDRAW, FALSE, 0L);
    ::SendMessage(hwndList, LB_RESETCONTENT, 0, 0L);

    hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
    IfFailGo(hr);

    hr = piMMCImages->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 0; lIndex < lCount; ++lIndex)
    {
        // For each image, we add a place holder to the list
        // OnDrawItem will look up the corresponding IPicture
        ::SendMessage(hwndList, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(_T("")));
    }

    ::SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);
    ::InvalidateRect(hwndList, NULL, TRUE);

Error:
    RELEASE(piMMCImages);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::EnableInput(bool bEnable)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::EnableInput(bool bEnable)
{
    BOOL    fReadOnly = (bEnable == false) ? TRUE : FALSE;

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_IL_INDEX), EM_SETREADONLY, static_cast<WPARAM>(fReadOnly), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_IL_KEY), EM_SETREADONLY, static_cast<WPARAM>(fReadOnly), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_IL_TAG), EM_SETREADONLY, static_cast<WPARAM>(fReadOnly), 0);

    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::ShowImage(IMMCImage *piMMCImage)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::ShowImage(IMMCImage *piMMCImage)
{
    HRESULT     hr = S_OK;
    long        lIndex = 0;
    BSTR        bstrKey = NULL;
    VARIANT     vtTag;
    VARIANT     vtTagBstr;

    ASSERT(piMMCImage != NULL, "ShowImage: piMMCImage is NULL");

    ::VariantInit(&vtTag);
    ::VariantInit(&vtTagBstr);

    m_bSilentUpdate = true;
    hr = piMMCImage->get_Index(&lIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_IL_INDEX, lIndex);
    IfFailGo(hr);

    hr = piMMCImage->get_Key(&bstrKey);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_IL_KEY, bstrKey);
    IfFailGo(hr);

    hr = piMMCImage->get_Tag(&vtTag);
    IfFailGo(hr);

    hr = ::VariantChangeType(&vtTagBstr, &vtTag, 0, VT_BSTR);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_IL_TAG, vtTagBstr.bstrVal);
    IfFailGo(hr);

    // Select the image in the listbox

    if (LB_ERR == ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_IL_IMAGES),
                                             LB_SETCURSEL, lIndex - 1L, 0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    ::VariantClear(&vtTagBstr);
    ::VariantClear(&vtTag);
    FREESTRING(bstrKey);
    m_bSilentUpdate = false;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnTextChanged(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnTextChanged(int dlgItemID)
{
    if ( (IDC_EDIT_IL_KEY == dlgItemID) || (IDC_EDIT_IL_TAG == dlgItemID) )
    {
        MakeDirty();
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psimglst.h ===
//=--------------------------------------------------------------------------------------
// psimglst.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// ImageList Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSIMGLST_H_
#define _PSIMGLST_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// Image List Property Page General
//
////////////////////////////////////////////////////////////////////////////////////


class CImageListImagesPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CImageListImagesPage(IUnknown *pUnkOuter);
    virtual ~CImageListImagesPage();

// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnMeasureItem(MEASUREITEMSTRUCT *pMeasureItemStruct);
    virtual HRESULT OnDrawItem(DRAWITEMSTRUCT *pDrawItemStruct);
    virtual HRESULT OnCtlSelChange(int dlgItemID);
    virtual HRESULT OnKillFocus(int dlgItemID);
    virtual HRESULT OnTextChanged(int dlgItemID);


// Helpers for Apply event
protected:

// Other helpers
protected:
    HRESULT ShowImage(IMMCImage *piMMCImage);
    HRESULT EnableInput(bool bEnable);

    HRESULT OnInsertPicture();
    HRESULT GetFileName(TCHAR **ppszFileName);
    HRESULT CreateStreamOnFile(const TCHAR *lpctFilename, IStream **ppStream, long *pcbPicture);

    HRESULT OnRemovePicture();

// Custom drawing
protected:
    HRESULT DrawImage(HDC hdc, int nIndex, const RECT& rcImage);
    HRESULT RenderPicture(IPicture *pPicture, HDC hdc, const RECT *prcRender, const RECT *prcWBounds);
    HRESULT DrawRectEffect(HDC hdc, const RECT& rc, WORD dwStyle);
    HRESULT UpdateImages();

// Instance data
protected:
    IMMCImageList   *m_piMMCImageList;
    int              m_iCurrentImage;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ImageListImages,                    // Name
	&CLSID_MMCImageListImagesPP,        // Class ID
	"ImageList Images Property Page",   // Registry display name
	CImageListImagesPage::Create,       // Create function
	IDD_PROPPAGE_IL_IMAGES,             // Dialog resource ID
	IDS_IMGLSTPPG_IMG,                  // Tab caption
	IDS_IMGLSTPPG_IMG,                  // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_ImageLists,             // Help context ID
	FALSE                               // Thread safe
);


#endif  // _PSIMGLST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psmain.h ===
//=--------------------------------------------------------------------------------------
// psmain.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Snap-In Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSMAIN_H_
#define _PSMAIN_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// SnapIn Property Page "Snap-In Properties"
//
////////////////////////////////////////////////////////////////////////////////////


class CSnapInGeneralPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CSnapInGeneralPage(IUnknown *pUnkOuter);
    virtual ~CSnapInGeneralPage();

// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnEditProperty(int iDispID);
    virtual HRESULT OnCtlSelChange(int dlgItemID);
    virtual HRESULT OnButtonClicked(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplyExtensible();
    HRESULT ApplyNodeType();
    HRESULT ApplyName();
    HRESULT ApplyNodeTypeName();
    HRESULT ApplyDisplayName();
    HRESULT ApplyProvider();
    HRESULT ApplyVersion();
    HRESULT ApplyDescription();
    HRESULT ApplyDefaultView();
    HRESULT ApplyImageList();

// Other helpers
protected:
    HRESULT InitializeNodeType();
    HRESULT InitializeDescription();

    HRESULT InitializeViews();
    HRESULT PopulateViews();
    HRESULT PopulateListViews(IListViewDefs *piListViewDefs);
    HRESULT PopulateOCXViews(IOCXViewDefs *piOCXViewDefs);
    HRESULT PopulateURLViews(IURLViewDefs *piURLViewDefs);
    HRESULT PopulateTaskpadViews(ITaskpadViewDefs *piTaskpadViewDefs);

// Instance data
protected:
    ISnapInDesignerDef  *m_piSnapInDesignerDef;
    ISnapInDef          *m_piSnapInDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	SnapInGeneral,                      // Name
	&CLSID_SnapInDefGeneralPP,          // Class ID
	"Snap-In General Property Page",    // Registry display name
	CSnapInGeneralPage::Create,         // Create function
	IDD_DIALOG_SNAPIN,                  // Dialog resource ID
	IDS_SNAPINPPG_GEN,                  // Tab caption
	IDS_SNAPINPPG_GEN,                  // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_StaticNode,             // Help context ID
	FALSE                               // Thread safe
);


////////////////////////////////////////////////////////////////////////////////////
//
// SnapIn Property Page "Image Lists"
//
////////////////////////////////////////////////////////////////////////////////////


class CSnapInImageListPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CSnapInImageListPage(IUnknown *pUnkOuter);
    virtual ~CSnapInImageListPage();

// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnCtlSelChange(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplySmallImageList(IMMCImageLists *piMMCImageLists);
    HRESULT ApplySmallOpenImageList(IMMCImageLists *piMMCImageLists);
    HRESULT ApplyLargeImageList(IMMCImageLists *piMMCImageLists);

// Other helpers
protected:
    HRESULT InitializeImageLists();
    HRESULT PopulateImageLists();
    HRESULT InitImageComboBoxSelection(UINT idComboBox,
                                       IMMCImageList *piMMCImageList);
    HRESULT GetImageList(UINT idComboBox, IMMCImageLists *piMMCImageLists,
                         IMMCImageList **ppiMMCImageList);

// Instance data
protected:
    ISnapInDesignerDef  *m_piSnapInDesignerDef;
    ISnapInDef          *m_piSnapInDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	SnapInImageList,                    // Name
	&CLSID_SnapInDefImageListPP,        // Class ID
	"Snap-In Image List Property Page", // Registry display name
	CSnapInImageListPage::Create,       // Create function
	IDD_PROPPAGE_SNAPIN_IL,             // Dialog resource ID
	IDS_SNAPINPPG_IL,                   // Tab caption
	IDS_SNAPINPPG_IL,                   // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_StaticNode,             // Help context ID
	FALSE                               // Thread safe
);


#endif  // _PSMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\pslistvw.h ===
//=--------------------------------------------------------------------------------------
// pslistvw.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// List View Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSLISTVIEW_H_
#define _PSLISTVIEW_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page General
//
////////////////////////////////////////////////////////////////////////////////////
class CListViewGeneralPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CListViewGeneralPage(IUnknown *pUnkOuter);
    virtual ~CListViewGeneralPage();


// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnCtlSelChange(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplyListViewName();
    HRESULT ApplyDefualtViewMode();
    HRESULT ApplyVirtualList();
    HRESULT ApplyAddToViewMenu();
    HRESULT ApplyViewMenuText();
    HRESULT ApplyStatusBarText();

// Other helpers
protected:
    HRESULT InitializeViewModes();
    HRESULT PopulateViewModes();
    HRESULT InitializeDefaultViewMode();

// Instance data
protected:
    IListViewDef  *m_piListViewDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ListViewGeneral,                    // Name
	&CLSID_ListViewDefGeneralPP,        // Class ID
	"List View General Property Page",  // Registry display name
	CListViewGeneralPage::Create,       // Create function
	IDD_PROPPAGE_LV_GENERAL,            // Dialog resource ID
	IDS_LISTVPPG_GEN,                   // Tab caption
	IDS_LISTVPPG_GEN,                   // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_ListViews,              // Help context ID
	FALSE                               // Thread safe
);

////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page Image Lists
//
////////////////////////////////////////////////////////////////////////////////////
class CListViewImgListsPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CListViewImgListsPage(IUnknown *pUnkOuter);
    virtual ~CListViewImgListsPage();


// Inherited from COldPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnCtlSelChange(int dlgItemID);

// Helpers to get attributes from component
protected:

// Helpers for Apply event
protected:
    HRESULT ApplyLargeIcon();
    HRESULT ApplySmallIcon();

// Other helpers
protected:
    HRESULT InitializeComboBoxes();

// Instance data
protected:
    ISnapInDesignerDef  *m_piSnapInDesignerDef;
    IListViewDef        *m_piListViewDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ListViewImgLists,                       // Name
	&CLSID_ListViewDefImgLstsPP,            // Class ID
	"List View Image Lists Property Page",  // Registry display name
	CListViewImgListsPage::Create,          // Create function
	IDD_PROPPAGE_LV_IMAGELISTS,             // Dialog resource ID
	IDS_LISTVPPG_IL,                        // Tab caption
	IDS_LISTVPPG_IL,                        // Doc string
	HELP_FILENAME,                          // Help file
	HID_mssnapd_ListViews,                  // Help context ID
	FALSE                                   // Thread safe
);


////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page Sorting
//
////////////////////////////////////////////////////////////////////////////////////
class CListViewSortingPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CListViewSortingPage(IUnknown *pUnkOuter);
    virtual ~CListViewSortingPage();


// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnCtlSelChange(int dlgItemID);
    virtual HRESULT OnCBDropDown(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplySorted();
    HRESULT ApplyKey();
    HRESULT ApplySortOrder();

// Other helpers
protected:
    HRESULT PopulateKeys(IMMCColumnHeaders *piIMMCColumnHeaders);
    HRESULT InitializeKey();
    HRESULT InitializeSortOrder();
    HRESULT InitializeSortOrderArray();

// Instance data
protected:
    IListViewDef  *m_piListViewDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ListViewSorting,                    // Name
	&CLSID_ListViewDefSortingPP,        // Class ID
	"List View Sorting Property Page",  // Registry display name
	CListViewSortingPage::Create,       // Create function
	IDD_PROPPAGE_LV_SORTING,            // Dialog resource ID
	IDS_LISTVPPG_SORT,                  // Tab caption
	IDS_LISTVPPG_SORT,                  // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_ListViews,             // Help context ID
	FALSE                               // Thread safe
);


////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page Column Headers
//
////////////////////////////////////////////////////////////////////////////////////
class CListViewColHdrsPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CListViewColHdrsPage(IUnknown *pUnkOuter);
    virtual ~CListViewColHdrsPage();


// Inherited from COldPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnDeltaPos(NMUPDOWN *pNMUpDown);
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnKillFocus(int dlgItemID);

    HRESULT OnInsertColumn();
    HRESULT OnRemoveColumn();
    HRESULT OnAutoWidth();

// Helpers for Apply event
protected:
    HRESULT ShowColumnHeader(IMMCColumnHeader *piMMCColumnHeader);
    HRESULT ShowColumnHeader();
    HRESULT AddNewColumnHeader();
    HRESULT ApplyCurrentHeader();
    HRESULT ClearHeader();
    HRESULT GetCurrentHeader(IMMCColumnHeader **ppiMMCColumnHeader);

// Other helpers
protected:
    HRESULT EnableEdits(bool bEnable);

// State transitions
protected:
    HRESULT CanEnterDoingNewHeaderState();
    HRESULT EnterDoingNewHeaderState();
    HRESULT CanCreateNewHeader();
    HRESULT CreateNewHeader(IMMCColumnHeader **ppiMMCColumnHeader);
    HRESULT ExitDoingNewHeaderState(IMMCColumnHeader *piMMCColumnHeader);

// Instance data
protected:
    IListViewDef        *m_piListViewDef;
    IMMCColumnHeaders   *m_piMMCColumnHeaders;
    long                 m_lCurrentIndex;
	bool			     m_bSavedLastHeader;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ListViewColHdrs,                            // Name
	&CLSID_ListViewDefColHdrsPP,                // Class ID
	"List View Column Headers Property Page",   // Registry display name
	CListViewColHdrsPage::Create,               // Create function
	IDD_PROPPAGE_LV_COLUMNS,                    // Dialog resource ID
	IDS_LISTVPPG_CH,                            // Tab caption
	IDS_LISTVPPG_CH,                            // Doc string
	HELP_FILENAME,                              // Help file
	HID_mssnapd_ListViews,                      // Help context ID
	FALSE                                       // Thread safe
);


#endif  // _PSLISTVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psnode.h ===
//=--------------------------------------------------------------------------------------
// psnode.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Node Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSNODE_H_
#define _PSNODE_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// ScopeItemDef Property Page General
//
////////////////////////////////////////////////////////////////////////////////////


class CNodeGeneralPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CNodeGeneralPage(IUnknown *pUnkOuter);
    virtual ~CNodeGeneralPage();


// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnTextChanged(int dlgItemID);
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnCtlSelChange(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplyName();
    HRESULT ApplyDisplayName();
    HRESULT ApplyFolder();
    HRESULT ApplyDefaultView();
    HRESULT ApplyAutoCreate();

// Other helpers
protected:
    HRESULT PopulateViews();

    HRESULT OnClosedChangeSelection();
    HRESULT OnOpenChangeSelection();
    HRESULT OnViewsChangeSelection();

// Instance data
protected:
    IScopeItemDef  *m_piScopeItemDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	NodeGeneral,                        // Name
	&CLSID_ScopeItemDefGeneralPP,       // Class ID
	"Scope Item General Property Page", // Registry display name
	CNodeGeneralPage::Create,           // Create function
	IDD_DIALOG_NEW_NODE,                // Dialog resource ID
	IDS_URLPPG_GEN,                     // Tab caption
	IDS_URLPPG_GEN,                     // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_Node,                   // Help context ID
	FALSE                               // Thread safe
);


////////////////////////////////////////////////////////////////////////////////////
//
// ScopeItemDef Property Page Column Headers
//
////////////////////////////////////////////////////////////////////////////////////
class CScopeItemDefColHdrsPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CScopeItemDefColHdrsPage(IUnknown *pUnkOuter);
    virtual ~CScopeItemDefColHdrsPage();


// Inherited from COldPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnDeltaPos(NMUPDOWN *pNMUpDown);
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnKillFocus(int dlgItemID);

    HRESULT OnRemoveColumn();
    HRESULT OnAutoWidth();

// Helpers for Apply event
protected:
    HRESULT ApplyCurrentHeader();

// Other helpers
protected:
    HRESULT ShowColumnHeader();
    HRESULT EnableEdits(bool bEnable);
    HRESULT ClearHeader();
    HRESULT GetCurrentHeader(IMMCColumnHeader **ppiMMCColumnHeader);

// State transitions
protected:
    HRESULT CanEnterDoingNewHeaderState();
    HRESULT EnterDoingNewHeaderState();
    HRESULT CanCreateNewHeader();
    HRESULT CreateNewHeader(IMMCColumnHeader **ppiMMCColumnHeader);
    HRESULT ExitDoingNewHeaderState(IMMCColumnHeader *piMMCColumnHeader);

// Instance data
protected:
    IScopeItemDef       *m_piScopeItemDef;
    IMMCColumnHeaders   *m_piMMCColumnHeaders;
    long                 m_lCurrentIndex;
	bool			     m_bSavedLastHeader;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ScopeItemDefColHdrs,                        // Name
	&CLSID_ScopeItemDefColHdrsPP,               // Class ID
	"Scope Item Column Headers Property Page",  // Registry display name
	CScopeItemDefColHdrsPage::Create,           // Create function
	IDD_PROPPAGE_SI_COLUMNS,                    // Dialog resource ID
	IDS_NODEPPG_CH,                             // Tab caption
	IDS_NODEPPG_CH,                             // Doc string
	HELP_FILENAME,                              // Help file
	HID_mssnapd_Node,                           // Help context ID
	FALSE                                       // Thread safe
);


#endif  // _PSNODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psocx.h ===
//=--------------------------------------------------------------------------------------
// psocx.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// OCX View Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSOCX_H_
#define _PSOCX_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// OCX View Property Page General
//
////////////////////////////////////////////////////////////////////////////////////


class COCXViewGeneralPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    COCXViewGeneralPage(IUnknown *pUnkOuter);
    virtual ~COCXViewGeneralPage();


// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplyOCXName();
    HRESULT ApplyProgID();
    HRESULT ApplyAddToView();
    HRESULT ApplyViewMenuText();
    HRESULT ApplyStatusBarText();

// Instance data
protected:
    IOCXViewDef  *m_piOCXViewDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	OCXViewGeneral,                     // Name
	&CLSID_OCXViewDefGeneralPP,         // Class ID
	"OCX View General Property Page",   // Registry display name
	COCXViewGeneralPage::Create,        // Create function
	IDD_PROPPAGE_OCX_VIEW,              // Dialog resource ID
	IDS_OCXPPG_GEN,                     // Tab caption
	IDS_OCXPPG_GEN,                     // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_OCXViews,               // Help context ID
	FALSE                               // Thread safe
);

#endif  // _PSOCX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\pstaskp.h ===
//=--------------------------------------------------------------------------------------
// pstaskp.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Taskpad View Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSTASKPAD_H_
#define _PSTASKPAD_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// Taskpad View Property Page General
//
////////////////////////////////////////////////////////////////////////////////////


class CTaskpadViewGeneralPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CTaskpadViewGeneralPage(IUnknown *pUnkOuter);
    virtual ~CTaskpadViewGeneralPage();


// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnCtlSelChange(int dlgItemID);

// Helpers for Apply event
protected:
	HRESULT CanApply();
    HRESULT ApplyName();
    HRESULT ApplyTitle();
    HRESULT ApplyDescription();
    HRESULT ApplyType();
    HRESULT ApplyListpad();
    HRESULT ApplyCustom();
    HRESULT ApplyViewMenu();
    HRESULT ApplyViewMenuText();
    HRESULT ApplyStatusBarText();

// Other helpers
    HRESULT OnUseButton();
    HRESULT OnAddToView();
    HRESULT PopulateListViewCombo();

// Instance data
protected:
    ISnapInDesignerDef *m_piSnapInDesignerDef;
    ITaskpadViewDef    *m_piTaskpadViewDef;
    ITaskpad           *m_piTaskpad;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	TaskpadViewGeneral,                 // Name
	&CLSID_TaskpadViewDefGeneralPP,     // Class ID
	"Taskpad General Property Page",    // Registry display name
	CTaskpadViewGeneralPage::Create,    // Create function
	IDD_PROPPAGE_TP_VIEW_GENERAL,       // Dialog resource ID
	IDS_TASKPAD_GEN,                    // Tab caption
	IDS_TASKPAD_GEN,                    // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_Taskpads,               // Help context ID
	FALSE                               // Thread safe
);


////////////////////////////////////////////////////////////////////////////////////
//
// Taskpad View Property Page Background
//
////////////////////////////////////////////////////////////////////////////////////


class CTaskpadViewBackgroundPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CTaskpadViewBackgroundPage(IUnknown *pUnkOuter);
    virtual ~CTaskpadViewBackgroundPage();


// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT CanApply();
    HRESULT ApplyMouseOverImage();
    HRESULT ApplyFontFamily();
    HRESULT ApplyEOTFile();
    HRESULT ApplySymbolString();

// Instance data
protected:
    ITaskpadViewDef  *m_piTaskpadViewDef;
    ITaskpad         *m_piTaskpad;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	TaskpadViewBackground,              // Name
	&CLSID_TaskpadViewDefBackgroundPP,  // Class ID
	"Taskpad Background Property Page", // Registry display name
	CTaskpadViewBackgroundPage::Create, // Create function
	IDD_PROPPAGE_TP_VIEW_BACKGROUND,    // Dialog resource ID
	IDS_TASKPAD_BACK,                   // Tab caption
	IDS_TASKPAD_BACK,                   // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_Taskpads,               // Help context ID
	FALSE                               // Thread safe
);

////////////////////////////////////////////////////////////////////////////////////
//
// Taskpad View Property Page Tasks
//
////////////////////////////////////////////////////////////////////////////////////


class CTaskpadViewTasksPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CTaskpadViewTasksPage(IUnknown *pUnkOuter);
    virtual ~CTaskpadViewTasksPage();


// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnDeltaPos(NMUPDOWN *pNMUpDown);
    virtual HRESULT OnKillFocus(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplyCurrentTask();
    HRESULT CanApply();

    HRESULT ApplyKey(ITask *piTask);
    HRESULT ApplyText(ITask *piTask);
    HRESULT ApplyHelpString(ITask *piTask);
	HRESULT ApplyTag(ITask *piTask);
    HRESULT ApplyActionType(ITask *piTask);
    HRESULT ApplyURL(ITask *piTask);
    HRESULT ApplyScript(ITask *piTask);
    HRESULT ApplyImageType(ITask *piTask);
    HRESULT ApplyMouseOverImage(ITask *piTask);
    HRESULT ApplyMouseOffImage(ITask *piTask);
    HRESULT ApplyFontFamilyName(ITask *piTask);
    HRESULT ApplyEOTFile(ITask *piTask);
    HRESULT ApplySymbolString(ITask *piTask);

// Other helpers
	HRESULT OnRemoveTask();

    HRESULT ShowTask();
    HRESULT ShowTask(ITask *piTask);
    HRESULT GetCurrentTask(ITask **ppiTask);
	HRESULT ClearTask();
    HRESULT EnableEdits(bool bEnable);

// State transitions
protected:
    HRESULT CanEnterDoingNewTaskState();
    HRESULT EnterDoingNewTaskState();
    HRESULT CanCreateNewTask();
    HRESULT CreateNewTask(ITask **ppiTask);
    HRESULT ExitDoingNewTaskState(ITask *piTask);

// Instance data
protected:
    ITaskpadViewDef  *m_piTaskpadViewDef;
    ITaskpad         *m_piTaskpad;
    long              m_lCurrentTask;
    bool              m_bSavedLastTask;

    SnapInTaskpadImageTypeConstants m_lastImageType;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	TaskpadViewTasks,                   // Name
	&CLSID_TaskpadViewDefTasksPP,       // Class ID
	"Taskpad Tasks Property Page",      // Registry display name
	CTaskpadViewTasksPage::Create,      // Create function
	IDD_PROPPAGE_TP_VIEW_TASKS,         // Dialog resource ID
	IDS_TASKPAD_TASKS,                  // Tab caption
	IDS_TASKPAD_TASKS,                  // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_Taskpads,               // Help context ID
	FALSE                               // Thread safe
);

#endif  // _PSTASKPAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\pstoolbr.cpp ===
//=--------------------------------------------------------------------------------------
// pstoolbr.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//
//=------------------------------------------------------------------------------------=
//
// URL View Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "pstoolbr.h"

// for ASSERT and FAIL
//
SZTHISFILE


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Toolbar Property Page General
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CToolbarGeneralPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
IUnknown *CToolbarGeneralPage::Create(IUnknown *pUnkOuter)
{
        CToolbarGeneralPage *pNew = New CToolbarGeneralPage(pUnkOuter);
        return pNew->PrivateUnknown();
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::CToolbarGeneralPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CToolbarGeneralPage::CToolbarGeneralPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGTOOLBRGENERAL), m_piMMCToolbar(0), m_piSnapInDesignerDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::~CToolbarGeneralPage()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CToolbarGeneralPage::~CToolbarGeneralPage()
{
    RELEASE(m_piMMCToolbar);
    RELEASE(m_piSnapInDesignerDef);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::OnInitializeDialog()
{
    HRESULT     hr = S_OK;

    hr = RegisterTooltip(IDC_COMBO_TB_ILS, IDS_TT_TB_IMAGE_LIST);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_TAG, IDS_TT_TB_TAG);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    IObjectModel   *piObjectModel = NULL;
    VARIANT         vtTag;

    ::VariantInit(&vtTag);

    if (NULL != m_piMMCToolbar)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IMMCToolbar, reinterpret_cast<void **>(&m_piMMCToolbar));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&m_piSnapInDesignerDef);
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeImageListCombo();
    IfFailGo(hr);

    hr = InitializeImageListValue();
    IfFailGo(hr);

    hr = m_piMMCToolbar->get_Tag(&vtTag);
    IfFailGo(hr);

    hr = SetDlgText(vtTag, IDC_EDIT_TB_TAG);
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    ::VariantClear(&vtTag);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::InitializeImageListCombo()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::InitializeImageListCombo()
{
    HRESULT          hr = S_OK;
    IMMCImageLists  *piMMCImageLists = NULL;
    long             lCount = 0;
    int              lIndex = 0;
    VARIANT          varIndex;
    IMMCImageList   *piMMCImageList = NULL;
    BSTR             bstrILName = NULL;
    int              iResult = 0;

    ASSERT(NULL != m_piSnapInDesignerDef, "InitializeImageListCombo: m_piSnapInDesignerDef is NULL");

    ::VariantInit(&varIndex);

    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    hr = piMMCImageLists->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        varIndex.vt = VT_I4;
        varIndex.lVal = lIndex;
        hr = piMMCImageLists->get_Item(varIndex, &piMMCImageList);
        IfFailGo(hr);

        hr = piMMCImageList->get_Name(&bstrILName);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_TB_ILS, bstrILName, 0);
        IfFailGo(hr);

        FREESTRING(bstrILName);
        RELEASE(piMMCImageList);
    }

Error:
    FREESTRING(bstrILName);
    ::VariantClear(&varIndex);
    RELEASE(piMMCImageList);
    RELEASE(piMMCImageLists);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::InitializeImageListValue()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::InitializeImageListValue()
{
    HRESULT          hr = S_OK;
    IMMCImageList   *piMMCImageList = NULL;
    BSTR             bstrName = NULL;

    ASSERT(m_piMMCToolbar != NULL, "InitializeImageListValue: m_piMMCToolbar is NULL");

    hr = m_piMMCToolbar->get_ImageList(reinterpret_cast<MMCImageList **>(&piMMCImageList));
    IfFailGo(hr);

    if (NULL != piMMCImageList)
    {
        hr = piMMCImageList->get_Name(&bstrName);
        IfFailGo(hr);

        hr = SelectCBBstr(IDC_COMBO_TB_ILS, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);
    RELEASE(piMMCImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(m_piMMCToolbar != NULL, "OnApply: m_piMMCToolbar is NULL");

    hr = ApplyImageList();
    IfFailGo(hr);

    hr = ApplyTag();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::ApplyImageList()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::ApplyImageList()
{
    HRESULT          hr = S_OK;
    BSTR             bstrImageList = NULL;
    IMMCImageLists  *piMMCImageLists = NULL;
    IMMCImageList   *piMMCImageList = NULL;
    VARIANT          varIndex;

    ASSERT(m_piMMCToolbar != NULL, "ApplyImageList: m_piMMCToolbar is NULL");

    ::VariantInit(&varIndex);

    hr = GetCBSelection(IDC_COMBO_TB_ILS, &bstrImageList);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    varIndex.vt = VT_BSTR;
    varIndex.bstrVal = ::SysAllocString(bstrImageList);

    hr = piMMCImageLists->get_Item(varIndex, &piMMCImageList);
    IfFailGo(hr);

    hr = m_piMMCToolbar->putref_ImageList(reinterpret_cast<MMCImageList *>(piMMCImageList));
    IfFailGo(hr);

Error:
    ::VariantClear(&varIndex);
    RELEASE(piMMCImageList);
    RELEASE(piMMCImageLists);
    FREESTRING(bstrImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::ApplyTag()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::ApplyTag()
{
    HRESULT hr = S_OK;
    BSTR    bstrTag = NULL;
    VARIANT vtTag;

    ASSERT(m_piMMCToolbar != NULL, "ApplyTag: m_piMMCToolbar is NULL");

    ::VariantInit(&vtTag);

    hr = GetDlgText(IDC_EDIT_TB_TAG, &bstrTag);
    IfFailGo(hr);

    vtTag.vt = VT_BSTR;
    vtTag.bstrVal = ::SysAllocString(bstrTag);

    hr = m_piMMCToolbar->put_Tag(vtTag);
    IfFailGo(hr);

Error:
    ::VariantClear(&vtTag);
    FREESTRING(bstrTag);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch(dlgItemID)
    {
    case IDC_COMBO_TB_ILS:
        MakeDirty();
        break;
    }

    RRETURN(hr);
}


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Toolbar Property Page Buttons
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


struct ButtonStyles
{
    TCHAR                      m_pszStyleName[kSIMaxBuffer + 1];
    SnapInButtonStyleConstants m_iIdentifier;
    int                        m_iIndex;
};

ButtonStyles    g_buttonStyles[5] = {
    _T(""),  siDefault,        -1,
    _T(""),  siCheck,          -1,
    _T(""),  siButtonGroup,    -1,
    _T(""),  siSeparator,      -1,
    _T(""),  siDropDown,       -1
};


struct ButtonValues
{
    TCHAR                      m_pszValueName[kSIMaxBuffer + 1];
    SnapInButtonValueConstants m_iIdentifier;
    int                        m_iIndex;
};

ButtonValues    g_buttonValues[2] = {
    _T(""),  siUnpressed,      -1,
    _T(""),  siPressed,        -1,
};


//=--------------------------------------------------------------------------------------
// IUnknown *CToolbarButtonsPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
IUnknown *CToolbarButtonsPage::Create(IUnknown *pUnkOuter)
{
        CToolbarButtonsPage *pNew = New CToolbarButtonsPage(pUnkOuter);
        return pNew->PrivateUnknown();
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CToolbarButtonsPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CToolbarButtonsPage::CToolbarButtonsPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGTOOLBRBUTTONS), m_piMMCToolbar(0), m_lCurrentButtonIndex(0),
  m_lCurrentButtonMenuIndex(0), m_bSavedLastButton(true), m_bSavedLastButtonMenu(true)
{
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::~CToolbarButtonsPage()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CToolbarButtonsPage::~CToolbarButtonsPage()
{
    RELEASE(m_piMMCToolbar);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnInitializeDialog()
{
    HRESULT     hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_TB_INDEX, IDS_TT_TB_BTN_INDEX);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_CAPTION, IDS_TT_TB_BTN_CAPTION);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_KEY, IDS_TT_TB_BTN_KEY);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_TB_BUTTON_VALUE, IDS_TT_TB_BTN_VALUE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_TB_BUTTON_STYLE, IDS_TT_TB_BTN_STYLE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_TOOLTIP_TEXT, IDS_TT_TB_BTN_TT_TEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_IMAGE, IDS_TT_TB_BTN_IMAGE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_BUTTON_TAG, IDS_TT_TB_BTN_TAG);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_VISIBLE, IDS_TT_TB_BTN_VISIBLE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_ENABLED, IDS_TT_TB_BTN_ENABLED);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MIXED_STATE, IDS_TT_TB_BTN_MIXED);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_MENU_INDEX, IDS_TT_TB_BTNM_INDEX);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_MENU_TEXT, IDS_TT_TB_BTNM_TEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_MENU_KEY, IDS_TT_TB_BTNM_KEY);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_MENU_TAG, IDS_TT_TB_BTNM_TAG);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MENU_ENABLED, IDS_TT_TB_BTNM_ENABLED);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MENU_VISIBLE, IDS_TT_TB_BTNM_VISIBLE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MENU_CHECKED, IDS_TT_TB_BTN_CHECKED);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MENU_GRAYED, IDS_TT_TB_BTN_GRAYED);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MENU_SEPARATOR, IDS_TT_TB_BTN_SEPRTR);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MENU_BREAK, IDS_TT_TB_BTN_MENUBR);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MENU_BAR_BREAK, IDS_TT_TB_BTN_MENUBARB);
    IfFailGo(hr);

    hr = PopulateButtonStyles();
    IfFailGo(hr);

    hr = PopulateButtonValues();
    IfFailGo(hr);

    hr = EnableButtonEdits(false);
    IfFailGo(hr);

    hr = EnableButtonMenuEdits(false);
    IfFailGo(hr);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON), FALSE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), FALSE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), FALSE);

    hr = SetDlgText(IDC_EDIT_TB_INDEX, m_lCurrentButtonIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_MENU_INDEX, m_lCurrentButtonMenuIndex);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::InitializeButtonValues()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::InitializeButtonValues()
{
    HRESULT     hr = S_OK;
    int         iResult = 0;
    char        szBuffer[kSIMaxBuffer + 1];

    if (-1 == g_buttonValues[0].m_iIndex)
    {
        iResult = ::LoadString(GetResourceHandle(),
                               IDS_TB_BV_UNPRESSED,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_buttonValues[0].m_pszValueName, szBuffer);
        g_buttonValues[0].m_iIdentifier = siUnpressed;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_TB_BV_PRESSED,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_buttonValues[1].m_pszValueName, szBuffer);
        g_buttonValues[1].m_iIdentifier = siPressed;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::PopulateButtonValues()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::PopulateButtonValues()
{
    HRESULT     hr = S_OK;
    BSTR        bstr = NULL;
    int         iIndex = 0;

    hr = InitializeButtonValues();
    IfFailGo(hr);

    for (iIndex = 0; iIndex < 2; ++iIndex)
    {
        hr = BSTRFromANSI(g_buttonValues[iIndex].m_pszValueName, &bstr);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_TB_BUTTON_VALUE, bstr, g_buttonValues[iIndex].m_iIdentifier);
        IfFailGo(hr);

        FREESTRING(bstr);
    }

Error:
    FREESTRING(bstr);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::InitializeButtonStyles()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::InitializeButtonStyles()
{
    HRESULT     hr = S_OK;
    int         iResult = 0;
    char        szBuffer[kSIMaxBuffer + 1];

    if (-1 == g_buttonStyles[0].m_iIndex)
    {
        iResult = ::LoadString(GetResourceHandle(),
                               IDS_TB_BS_DEFAULT,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_buttonStyles[0].m_pszStyleName, szBuffer);
        g_buttonStyles[0].m_iIdentifier = siDefault;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_TB_BS_CHECK,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_buttonStyles[1].m_pszStyleName, szBuffer);
        g_buttonStyles[1].m_iIdentifier = siCheck;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_TB_BS_GROUP,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_buttonStyles[2].m_pszStyleName, szBuffer);
        g_buttonStyles[2].m_iIdentifier = siButtonGroup;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_TB_BS_SEPARATOR,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_buttonStyles[3].m_pszStyleName, szBuffer);
        g_buttonStyles[3].m_iIdentifier = siSeparator;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_TB_BS_DROPDOWN,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_buttonStyles[4].m_pszStyleName, szBuffer);
        g_buttonStyles[4].m_iIdentifier = siDropDown;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::PopulateButtonStyles()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::PopulateButtonStyles()
{
    HRESULT     hr = S_OK;
    BSTR        bstr = NULL;
    int         iIndex = 0;

    hr = InitializeButtonStyles();
    IfFailGo(hr);

    for (iIndex = 0; iIndex < 5; ++iIndex)
    {
        hr = BSTRFromANSI(g_buttonStyles[iIndex].m_pszStyleName, &bstr);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_TB_BUTTON_STYLE, bstr, g_buttonStyles[iIndex].m_iIdentifier);
        IfFailGo(hr);

        FREESTRING(bstr);
    }

Error:
    FREESTRING(bstr);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    IMMCButtons    *piMMCButtons = NULL;
    long            lCount = 0;
    IMMCButton     *piMMCButton = NULL;

    if (NULL != m_piMMCToolbar)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IMMCToolbar, reinterpret_cast<void **>(&m_piMMCToolbar));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons));
    IfFailGo(hr);

    hr = piMMCButtons->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        m_lCurrentButtonIndex = 1;

        hr = GetCurrentButton(&piMMCButton);
        IfFailGo(hr);

        hr = ShowButton(piMMCButton);
        IfFailGo(hr);

        hr = EnableButtonEdits(true);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON), TRUE);
    }
    else
    {
        // There are no buttons so disable the button and button menu index
        // edit controls
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_INDEX), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_MENU_INDEX), FALSE);
    }

    m_bInitialized = true;

Error:
    RELEASE(piMMCButton);
    RELEASE(piMMCButtons);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnApply()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
//  Scenarios:
//  1. The user is in the middle of creating a new Button
//  2. The user is modifying an exising button
HRESULT CToolbarButtonsPage::OnApply()
{
    HRESULT                     hr = S_OK;
    IMMCButton                 *piMMCButton = NULL;
    long                        lCount = 0;
    int                         disposition = 0;
    IMMCButtonMenu             *piMMCButtonMenu = NULL;
    SnapInButtonStyleConstants  Style = siDefault;

    ASSERT(m_piMMCToolbar != NULL, "OnApply: m_piMMCToolbar is NULL");

    if (0 == m_lCurrentButtonIndex)
        goto Error;

    if (!m_bSavedLastButton)
    {
        hr = CanCreateNewButton();
        IfFailGo(hr);

        if (S_FALSE == hr)
        {
            hr = HandleCantCommit(_T("Can\'t create new Button"), _T("Would you like to discard your changes?"), &disposition);
            if (kSICancelOperation == disposition)
            {
                hr = E_INVALIDARG;
                goto Error;
            }
            else
            {
                // Discard changes
                hr = ExitDoingNewButtonState(NULL);
                IfFailGo(hr);

                hr = S_OK;
                goto Error;
            }
        }

        hr = CreateNewButton(&piMMCButton);
        IfFailGo(hr);

        hr = ExitDoingNewButtonState(piMMCButton);
        IfFailGo(hr);
    }
    else
    {
        hr = GetCurrentButton(&piMMCButton);
        IfFailGo(hr);
    }


    // Check the style. If it is dropdown and we haven't yet created a
    // button menu for it then do so now

    IfFailGo(piMMCButton->get_Style(&Style));

    if ( (siDropDown == Style) && (!m_bSavedLastButtonMenu) )
    {
        hr = CanCreateNewButtonMenu();
        IfFailGo(hr);

        if (S_FALSE == hr)
        {
            hr = HandleCantCommit(_T("Can\'t create new ButtonMenu"), _T("Would you like to discard your changes?"), &disposition);
            if (kSICancelOperation == disposition)
            {
                hr = E_INVALIDARG;
                goto Error;
            }
            else
            {
                // Discard changes
                hr = ExitDoingNewButtonMenuState(NULL, NULL);
                IfFailGo(hr);

                hr = S_OK;
                goto Error;
            }
        }

        hr = CreateNewButtonMenu(piMMCButton, &piMMCButtonMenu);
        IfFailGo(hr);

        hr = ExitDoingNewButtonMenuState(piMMCButton, piMMCButtonMenu);
        IfFailGo(hr);
    }

    hr = ApplyCurrentButton();
    IfFailGo(hr);

Error:
    RELEASE(piMMCButtonMenu);
    RELEASE(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyCurrentButton()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyCurrentButton()
{
    HRESULT                     hr = S_OK;
    IMMCButton                 *piMMCButton = NULL;

    ASSERT(m_piMMCToolbar != NULL, "ApplyCurrentButton: m_piMMCToolbar is NULL");

    hr = CanCreateNewButton();
    IfFailGo(hr);

    if (S_FALSE == hr) {
        hr = E_INVALIDARG;
        goto Error;
    }

    hr = GetCurrentButton(&piMMCButton);
    IfFailGo(hr);

    hr = ApplyCaption(piMMCButton);
    IfFailGo(hr);

    hr = ApplyKey(piMMCButton);
    IfFailGo(hr);

    hr = ApplyStyle(piMMCButton);
    IfFailGo(hr);

    hr = ApplyImage(piMMCButton);
    IfFailGo(hr);

    hr = ApplyValue(piMMCButton);
    IfFailGo(hr);

    hr = ApplyTooltipText(piMMCButton);
    IfFailGo(hr);

    hr = ApplyTag(piMMCButton);
    IfFailGo(hr);

    hr = ApplyVisible(piMMCButton);
    IfFailGo(hr);

    hr = ApplyEnabled(piMMCButton);
    IfFailGo(hr);

    hr = ApplyMixedState(piMMCButton);
    IfFailGo(hr);

    hr = ApplyCurrentButtonMenu(piMMCButton);
    IfFailGo(hr);

Error:
    RELEASE(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyCurrentButtonMenu(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyCurrentButtonMenu(IMMCButton *piMMCButton)
{
    HRESULT                     hr = S_OK;
    SnapInButtonStyleConstants  bscStyle = siDefault;
    IMMCButtonMenu             *piMMCButtonMenu = NULL;

    ASSERT(m_piMMCToolbar != NULL, "ApplyCurrentButtonMenu: m_piMMCToolbar is NULL");
    ASSERT(piMMCButton != NULL, "ApplyCurrentButtonMenu: piMMCButton is NULL");

    hr = piMMCButton->get_Style(&bscStyle);
    IfFailGo(hr);

    if (siDropDown == bscStyle)
    {
        hr = GetCurrentButtonMenu(piMMCButton, &piMMCButtonMenu);
        IfFailGo(hr);

        if (NULL != piMMCButtonMenu)
        {
            hr = ApplyButtonMenuText(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuKey(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuTag(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuEnabled(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuVisible(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuChecked(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuGrayed(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuSeparator(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuBreak(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuBarBreak(piMMCButtonMenu);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piMMCButtonMenu);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyCaption(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyCaption(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    BSTR            bstrCaption = NULL;
    BSTR            bstrSavedCaption = NULL;

    ASSERT(NULL != piMMCButton, "ApplyCaption: piMMCButton is NULL");

    hr = GetDlgText(IDC_EDIT_TB_CAPTION, &bstrCaption);
    IfFailGo(hr);

    hr = piMMCButton->get_Caption(&bstrSavedCaption);
    IfFailGo(hr);

    if (NULL == bstrSavedCaption || 0 != ::wcscmp(bstrCaption, bstrSavedCaption))
    {
        hr = piMMCButton->put_Caption(bstrCaption);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedCaption);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyKey(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyKey(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    BSTR            bstrKey = NULL;
    BSTR            bstrSavedKey = NULL;

    ASSERT(NULL != piMMCButton, "ApplyKey: piMMCButton is NULL");

    hr = GetDlgText(IDC_EDIT_TB_KEY, &bstrKey);
    IfFailGo(hr);

    if ( (NULL == bstrKey) || (0 == ::SysStringLen(bstrKey)) )
    {
        hr = piMMCButton->put_Key(NULL);
        IfFailGo(hr);
    }
    else
    {
        hr = piMMCButton->get_Key(&bstrSavedKey);
        IfFailGo(hr);

        if ( (NULL == bstrSavedKey) || (0 != ::wcscmp(bstrKey, bstrSavedKey)) )
        {
            hr = piMMCButton->put_Key(bstrKey);
            IfFailGo(hr);
        }
    }

Error:
    FREESTRING(bstrSavedKey);
    FREESTRING(bstrKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyValue(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyValue(IMMCButton *piMMCButton)
{
    HRESULT                                             hr = S_OK;
    long                                                lValue = 0;
    SnapInButtonValueConstants  bvcValue = siUnpressed;
    SnapInButtonValueConstants  bvcSavedValue = siUnpressed;

    ASSERT(NULL != m_piMMCToolbar, "ApplyValue: m_piMMCToolbar is NULL");

    hr = GetCBSelectedItemData(IDC_COMBO_TB_BUTTON_VALUE, &lValue);
    IfFailGo(hr);

    bvcValue = static_cast<SnapInButtonValueConstants>(lValue);

    hr = piMMCButton->get_Value(&bvcSavedValue);
    IfFailGo(hr);

    if (bvcValue != bvcSavedValue)
    {
        hr = piMMCButton->put_Value(bvcValue);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyStyle(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyStyle(IMMCButton *piMMCButton)
{
    HRESULT                     hr = S_OK;
    long                        lValue = 0;
    long                        cButtons = 0;
    SnapInButtonStyleConstants  NewStyle = siDefault;
    SnapInButtonStyleConstants  SavedStyle = siDefault;

    ASSERT(NULL != piMMCButton, "ApplyStyle: piMMCButton is NULL");

    hr = GetCBSelectedItemData(IDC_COMBO_TB_BUTTON_STYLE, &lValue);
    IfFailGo(hr);

    NewStyle = static_cast<SnapInButtonStyleConstants>(lValue);

    hr = piMMCButton->get_Style(&SavedStyle);
    IfFailGo(hr);

    if (NewStyle != SavedStyle)
    {
        hr = piMMCButton->put_Style(NewStyle);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyTooltipText(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyTooltipText(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    BSTR            bstrTooltipText = NULL;
    BSTR            bstrSavedTooltipText = NULL;

    ASSERT(NULL != m_piMMCToolbar, "ApplyTooltipText: m_piMMCToolbar is NULL");

    hr = GetDlgText(IDC_EDIT_TB_TOOLTIP_TEXT, &bstrTooltipText);
    IfFailGo(hr);

    hr = piMMCButton->get_ToolTipText(&bstrSavedTooltipText);
    IfFailGo(hr);

    if (NULL == bstrSavedTooltipText || 0 != ::wcscmp(bstrTooltipText, bstrSavedTooltipText))
    {
        hr = piMMCButton->put_ToolTipText(bstrTooltipText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedTooltipText);
    FREESTRING(bstrTooltipText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyImage(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyImage(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    VARIANT         vtNewImage;

    ASSERT(NULL != piMMCButton, "ApplyImage: piMMCButton is NULL");

    ::VariantInit(&vtNewImage);

    hr = GetDlgVariant(IDC_EDIT_TB_IMAGE, &vtNewImage);
    IfFailGo(hr);

    if (VT_EMPTY != vtNewImage.vt)
    {
        hr = piMMCButton->put_Image(vtNewImage);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtNewImage);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyTag(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyTag(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    BSTR            bstrTag = NULL;
    VARIANT         vtNewTag;

    ASSERT(NULL != m_piMMCToolbar, "ApplyTag: m_piMMCToolbar is NULL");

    ::VariantInit(&vtNewTag);

    hr = GetDlgText(IDC_EDIT_TB_BUTTON_TAG, &bstrTag);
    IfFailGo(hr);

    vtNewTag.vt = VT_BSTR;
    vtNewTag.bstrVal = ::SysAllocString(bstrTag);
    if (NULL == vtNewTag.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piMMCButton->put_Tag(vtNewTag);
    IfFailGo(hr);

Error:
    ::VariantClear(&vtNewTag);
    FREESTRING(bstrTag);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyVisible(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyVisible(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbVisible = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedVisible = VARIANT_FALSE;

    ASSERT(NULL != m_piMMCToolbar, "ApplyVisible: m_piMMCToolbar is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_VISIBLE, &vtbVisible);
    IfFailGo(hr);

    hr = piMMCButton->get_Visible(&vtbSavedVisible);
    IfFailGo(hr);

    if (vtbVisible != vtbSavedVisible)
    {
        hr = piMMCButton->put_Visible(vtbVisible);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyEnabled(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyEnabled(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbEnabled = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedEnabled = VARIANT_FALSE;

    ASSERT(NULL != m_piMMCToolbar, "ApplyEnabled: m_piMMCToolbar is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_ENABLED, &vtbEnabled);
    IfFailGo(hr);

    hr = piMMCButton->get_Enabled(&vtbSavedEnabled);
    IfFailGo(hr);

    if (vtbEnabled != vtbSavedEnabled)
    {
        hr = piMMCButton->put_Enabled(vtbEnabled);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyMixedState(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyMixedState(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbMixedState = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedMixedState = VARIANT_FALSE;

    ASSERT(NULL != m_piMMCToolbar, "ApplyMixedState: m_piMMCToolbar is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MIXED_STATE, &vtbMixedState);
    IfFailGo(hr);

    hr = piMMCButton->get_MixedState(&vtbSavedMixedState);
    IfFailGo(hr);

    if (vtbMixedState != vtbSavedMixedState)
    {
        hr = piMMCButton->put_MixedState(vtbMixedState);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuText(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuText(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    BSTR            bstrButtonMenuText = NULL;
    BSTR            bstrSavedButtonMenuText = NULL;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuText: piMMCButtonMenu is NULL");

    hr = GetDlgText(IDC_EDIT_TB_MENU_TEXT, &bstrButtonMenuText);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Text(&bstrSavedButtonMenuText);
    IfFailGo(hr);

    if (NULL == bstrSavedButtonMenuText || 0 != ::wcscmp(bstrButtonMenuText, bstrSavedButtonMenuText))
    {
        hr = piMMCButtonMenu->put_Text(bstrButtonMenuText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedButtonMenuText);
    FREESTRING(bstrButtonMenuText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuKey(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuKey(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    BSTR            bstrButtonMenuKey = NULL;
    BSTR            bstrSavedButtonMenuKey = NULL;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuKey: piMMCButtonMenu is NULL");

    hr = GetDlgText(IDC_EDIT_TB_MENU_KEY, &bstrButtonMenuKey);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Key(&bstrSavedButtonMenuKey);
    IfFailGo(hr);

    if (NULL == bstrSavedButtonMenuKey || 0 != ::wcscmp(bstrButtonMenuKey, bstrSavedButtonMenuKey))
    {
        hr = piMMCButtonMenu->put_Key(bstrButtonMenuKey);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedButtonMenuKey);
    FREESTRING(bstrButtonMenuKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuTag(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuTag(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    BSTR            bstrTag = NULL;
    VARIANT         vtNewTag;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuTag: piMMCButtonMenu is NULL");

    ::VariantInit(&vtNewTag);

    hr = GetDlgText(IDC_EDIT_TB_MENU_TAG, &bstrTag);
    IfFailGo(hr);

    vtNewTag.vt = VT_BSTR;
    vtNewTag.bstrVal = ::SysAllocString(bstrTag);
    if (NULL == vtNewTag.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piMMCButtonMenu->put_Tag(vtNewTag);
    IfFailGo(hr);

Error:
    ::VariantClear(&vtNewTag);
    FREESTRING(bstrTag);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuEnabled(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuEnabled(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbEnabled = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedEnabled = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuEnabled: piMMCButtonMenu is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MENU_ENABLED, &vtbEnabled);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Enabled(&vtbSavedEnabled);
    IfFailGo(hr);

    if (vtbEnabled != vtbSavedEnabled)
    {
        hr = piMMCButtonMenu->put_Enabled(vtbEnabled);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuVisible(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuVisible(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbVisible = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedVisible = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuVisible: piMMCButtonMenu is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MENU_VISIBLE, &vtbVisible);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Visible(&vtbSavedVisible);
    IfFailGo(hr);

    if (vtbVisible != vtbSavedVisible)
    {
        hr = piMMCButtonMenu->put_Visible(vtbVisible);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuChecked(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuChecked(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbChecked = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedChecked = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuChecked: piMMCButtonMenu is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MENU_CHECKED, &vtbChecked);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Checked(&vtbSavedChecked);
    IfFailGo(hr);

    if (vtbChecked != vtbSavedChecked)
    {
        hr = piMMCButtonMenu->put_Checked(vtbChecked);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuGrayed(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuGrayed(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbGrayed = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedGrayed = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuGrayed: piMMCButtonMenu is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MENU_GRAYED, &vtbGrayed);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Grayed(&vtbSavedGrayed);
    IfFailGo(hr);

    if (vtbGrayed != vtbSavedGrayed)
    {
        hr = piMMCButtonMenu->put_Grayed(vtbGrayed);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuSeparator(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuSeparator(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbSeparator = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedSeparator = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuSeparator: piMMCButtonMenu is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MENU_SEPARATOR, &vtbSeparator);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Separator(&vtbSavedSeparator);
    IfFailGo(hr);

    if (vtbSeparator != vtbSavedSeparator)
    {
        hr = piMMCButtonMenu->put_Separator(vtbSeparator);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuBreak(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuBreak(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbMenuBreak = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedMenuBreak = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuBreak: piMMCButtonMenu is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MENU_BREAK, &vtbMenuBreak);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_MenuBreak(&vtbSavedMenuBreak);
    IfFailGo(hr);

    if (vtbMenuBreak != vtbSavedMenuBreak)
    {
        hr = piMMCButtonMenu->put_MenuBreak(vtbMenuBreak);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuBarBreak(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuBarBreak(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbMenuBarBreak = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedMenuBarBreak = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuBarBreak: piMMCButtonMenu is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MENU_BAR_BREAK, &vtbMenuBarBreak);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_MenuBarBreak(&vtbSavedMenuBarBreak);
    IfFailGo(hr);

    if (vtbMenuBarBreak != vtbSavedMenuBarBreak)
    {
        hr = piMMCButtonMenu->put_MenuBarBreak(vtbMenuBarBreak);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;
    IMMCButton     *piMMCButton = NULL;

    switch(dlgItemID)
    {
    case IDC_BUTTON_INSERT_BUTTON:
        if (S_OK == IsPageDirty())
        {
            hr = OnApply();
            IfFailGo(hr);
        }

        hr = CanEnterDoingNewButtonState();
        IfFailGo(hr);

        if (S_OK == hr)
        {
            hr = EnterDoingNewButtonState();
            IfFailGo(hr);
        }
        break;

    case IDC_BUTTON_REMOVE_BUTTON:
        hr = OnRemoveButton();
        IfFailGo(hr);
        break;

    case IDC_BUTTON_INSERT_BUTTON_MENU:
        if (S_OK == IsPageDirty())
        {
            hr = OnApply();
            IfFailGo(hr);
        }

        hr = CanEnterDoingNewButtonMenuState();
        IfFailGo(hr);

        if (S_OK == hr)
        {
            hr = GetCurrentButton(&piMMCButton);
            IfFailGo(hr);

            hr = EnterDoingNewButtonMenuState(piMMCButton);
            IfFailGo(hr);
        }
        break;

    case IDC_BUTTON_REMOVE_BUTTON_MENU:
        hr = OnRemoveButtonMenu();
        IfFailGo(hr);
        break;

    case IDC_CHECK_TB_VISIBLE:
    case IDC_CHECK_TB_ENABLED:
    case IDC_CHECK_TB_MIXED_STATE:
    case IDC_CHECK_TB_MENU_ENABLED:
    case IDC_CHECK_TB_MENU_VISIBLE:
    case IDC_CHECK_TB_MENU_CHECKED:
    case IDC_CHECK_TB_MENU_GRAYED:
    case IDC_CHECK_TB_MENU_SEPARATOR:
    case IDC_CHECK_TB_MENU_BREAK:
    case IDC_CHECK_TB_MENU_BAR_BREAK:
        MakeDirty();
        break;
    }

Error:
    RELEASE(piMMCButton);
    if (FAILED(hr))
        HandleError(_T("Apply Error"), _T("There was an error applying values for this Toolbar."));

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnRemoveButton()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnRemoveButton()
{
    HRESULT         hr = S_OK;
    IMMCButtons    *piMMCButtons = NULL;
    IMMCButton     *piMMCButton = NULL;
    VARIANT         varIndex;
    long            lCount = 0;

    ASSERT(NULL != m_piMMCToolbar, "OnRemoveButton: m_piMMCToolbar is NULL");

    ::VariantInit(&varIndex);

    hr = m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons));
    IfFailGo(hr);

    varIndex.vt = VT_I4;
    varIndex.lVal = m_lCurrentButtonIndex;
    hr = piMMCButtons->Remove(varIndex);
    IfFailGo(hr);

    hr = piMMCButtons->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        if (m_lCurrentButtonIndex > lCount)
            m_lCurrentButtonIndex = lCount;

        hr = GetCurrentButton(&piMMCButton);
        IfFailGo(hr);

        hr = ShowButton(piMMCButton);
        IfFailGo(hr);
    }
    else
    {
        m_lCurrentButtonIndex = 0;

        hr = ClearButton();
        IfFailGo(hr);

        hr = EnableButtonEdits(false);
        IfFailGo(hr);

        hr = EnableButtonMenuEdits(false);
        IfFailGo(hr);

                ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON), FALSE);
                ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), FALSE);
                ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), FALSE);
    }

    m_bSavedLastButton = TRUE;
    m_bSavedLastButtonMenu = TRUE;

Error:
    ::VariantClear(&varIndex);
    RELEASE(piMMCButton);
    RELEASE(piMMCButtons);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnRemoveButtonMenu()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnRemoveButtonMenu()
{
    HRESULT          hr = S_OK;
    IMMCButton      *piMMCButton = NULL;
    IMMCButtonMenu  *piMMCButtonMenu = NULL;
    IMMCButtonMenus *piMMCButtonMenus = NULL;
    VARIANT          varIndex;
    long             lCount = 0;

    ASSERT(NULL != m_piMMCToolbar, "OnRemoveButtonMenu: m_piMMCToolbar is NULL");

    ::VariantInit(&varIndex);

    hr = GetCurrentButton(&piMMCButton);
    IfFailGo(hr);

    hr = piMMCButton->get_ButtonMenus(reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus));
    IfFailGo(hr);

    varIndex.vt = VT_I4;
    varIndex.lVal = m_lCurrentButtonMenuIndex;
    hr = piMMCButtonMenus->Remove(varIndex);
    IfFailGo(hr);

    hr = piMMCButtonMenus->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        if (m_lCurrentButtonMenuIndex > lCount)
            m_lCurrentButtonMenuIndex = lCount;

        hr = GetCurrentButtonMenu(piMMCButton, &piMMCButtonMenu);
        IfFailGo(hr);

        hr = ShowButtonMenu(piMMCButtonMenu);
        IfFailGo(hr);
    }
    else
    {
        m_lCurrentButtonMenuIndex = 0;

        hr = ClearButtonMenu();
        IfFailGo(hr);

        hr = EnableButtonMenuEdits(false);
        IfFailGo(hr);

                ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), FALSE);
    }

Error:
    ::VariantClear(&varIndex);
    RELEASE(piMMCButtonMenus);
    RELEASE(piMMCButtonMenu);
    RELEASE(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ClearButton()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ClearButton()
{
    HRESULT     hr = S_OK;
    BSTR        bstrNull = NULL;
    long        lData = 0;

    hr = SetDlgText(IDC_EDIT_TB_INDEX, m_lCurrentButtonIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_CAPTION, bstrNull);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_KEY, bstrNull);
    IfFailGo(hr);

    lData = 0;  // siUnpressed;
    hr = SetCBItemSelection(IDC_COMBO_TB_BUTTON_VALUE, lData);
    IfFailGo(hr);

    lData = 0;  // siDefault;
    hr = SetCBItemSelection(IDC_COMBO_TB_BUTTON_STYLE, lData);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_TOOLTIP_TEXT, bstrNull);
    IfFailGo(hr);

    // Initialize the image index to the button index.
    hr = SetDlgText(IDC_EDIT_TB_IMAGE, m_lCurrentButtonIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_BUTTON_TAG, bstrNull);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_VISIBLE, VARIANT_TRUE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_ENABLED, VARIANT_TRUE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MIXED_STATE, VARIANT_FALSE);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ClearButtonMenu()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ClearButtonMenu()
{
    HRESULT     hr = S_OK;
    BSTR        bstrNull = NULL;

    hr = SetDlgText(IDC_EDIT_TB_MENU_INDEX, m_lCurrentButtonMenuIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_MENU_TEXT, bstrNull);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_MENU_KEY, bstrNull);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_MENU_TAG, bstrNull);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_ENABLED, VARIANT_TRUE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_VISIBLE, VARIANT_TRUE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_CHECKED, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_GRAYED, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_SEPARATOR, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_BREAK, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_BAR_BREAK, VARIANT_FALSE);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch(dlgItemID)
    {
    case IDC_COMBO_TB_BUTTON_VALUE:
        MakeDirty();
        break;

    case IDC_COMBO_TB_BUTTON_STYLE:
        hr = OnButtonStyle();
        IfFailGo(hr);

        MakeDirty();
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnButtonStyle()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnButtonStyle()
{
    HRESULT                     hr = S_OK;
    long                        lData = 0;
    SnapInButtonStyleConstants  bscStyle = siDefault;
    IMMCButton                 *piMMCButton = NULL;
    IMMCButtonMenus            *piMMCButtonMenus = NULL;
    long                        lCount = 0;

    ASSERT(NULL != m_piMMCToolbar, "ApplyEnabled: OnButtonStyle is NULL");

    IfFailGo(GetCBSelectedItemData(IDC_COMBO_TB_BUTTON_STYLE, &lData));

    bscStyle = static_cast<SnapInButtonStyleConstants>(lData);

    IfFailGo(GetCurrentButton(&piMMCButton));

    if (NULL != piMMCButton)
    {
        IfFailGo(piMMCButton->get_ButtonMenus(reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus)));
    }

    switch (bscStyle)
    {
    case siDropDown:
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_CAPTION), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_IMAGE), FALSE);
        IfFailGo(SetDlgText(IDC_EDIT_TB_IMAGE, (BSTR)NULL));
        break;

    default:
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_IMAGE), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_CAPTION), FALSE);
        IfFailGo(SetDlgText(IDC_EDIT_TB_CAPTION, (BSTR)NULL));
        IfFailGo(EnableButtonMenuEdits(FALSE));

        // Revert the button to a state where it has no button menus

        m_lCurrentButtonMenuIndex = 0;
        IfFailGo(ClearButtonMenu());
        if (NULL != piMMCButton)
        {
            IfFailGo(piMMCButton->put_Caption(NULL));
        }
        if (NULL != piMMCButtonMenus)
        {
            IfFailGo(piMMCButtonMenus->Clear());
        }
        m_bSavedLastButtonMenu = TRUE;
        break;
    }

Error:
    RELEASE(piMMCButtonMenus);
    RELEASE(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnDeltaPos(NMUPDOWN *pNMUpDown)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnDeltaPos(NMUPDOWN *pNMUpDown)
{
    HRESULT       hr = S_OK;

    switch (pNMUpDown->hdr.idFrom)
    {
    case IDC_SPIN_TB_INDEX:
        hr = OnButtonDeltaPos(pNMUpDown);
        IfFailGo(hr);
        break;

    case IDC_SPIN_TB_MENU_INDEX:
        hr = OnButtonMenuDeltaPos(pNMUpDown);
        IfFailGo(hr);
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnButtonDeltaPos(NMUPDOWN *pNMUpDown)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnButtonDeltaPos(NMUPDOWN *pNMUpDown)
{
    HRESULT       hr = S_OK;
    IMMCButtons  *piMMCButtons = NULL;
    long          lCount = 0;
    IMMCButton   *piMMCButton = NULL;

    ASSERT(NULL != m_piMMCToolbar, "OnButtonDeltaPos: m_piMMCToolbar is NULL");

    if (false == m_bSavedLastButton || S_OK == IsPageDirty())
    {
        hr = OnApply();
        IfFailGo(hr);
    }

    hr = m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons));
    IfFailGo(hr);

    hr = piMMCButtons->get_Count(&lCount);
    IfFailGo(hr);

    if (pNMUpDown->iDelta < 0)
    {
        if (m_lCurrentButtonIndex < lCount)
        {
            ++m_lCurrentButtonIndex;
            hr = GetCurrentButton(&piMMCButton);
            IfFailGo(hr);

            hr = ShowButton(piMMCButton);
            IfFailGo(hr);
        }
    }
    else
    {
        if (m_lCurrentButtonIndex > 1 && m_lCurrentButtonIndex <= lCount)
        {
            --m_lCurrentButtonIndex;
            hr = GetCurrentButton(&piMMCButton);
            IfFailGo(hr);

            hr = ShowButton(piMMCButton);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piMMCButton);
    RELEASE(piMMCButtons);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnButtonMenuDeltaPos(NMUPDOWN *pNMUpDown)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnButtonMenuDeltaPos(NMUPDOWN *pNMUpDown)
{
    HRESULT          hr = S_OK;
    long             lCount = 0;
    IMMCButton      *piMMCButton = NULL;
    IMMCButtonMenus *piMMCButtonMenus = NULL;
    IMMCButtonMenu  *piMMCButtonMenu = NULL;

    ASSERT(NULL != m_piMMCToolbar, "OnButtonMenuDeltaPos: m_piMMCToolbar is NULL");

    if (false == m_bSavedLastButtonMenu || S_OK == IsPageDirty())
    {
        hr = OnApply();
        IfFailGo(hr);
    }

    hr = GetCurrentButton(&piMMCButton);
    IfFailGo(hr);

    hr = piMMCButton->get_ButtonMenus(reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus));
    IfFailGo(hr);

    hr = piMMCButtonMenus->get_Count(&lCount);
    IfFailGo(hr);

    if (pNMUpDown->iDelta < 0)
    {
        if (m_lCurrentButtonMenuIndex < lCount)
        {
            ++m_lCurrentButtonMenuIndex;
            hr = GetCurrentButtonMenu(piMMCButton, &piMMCButtonMenu);
            IfFailGo(hr);

            hr = ShowButtonMenu(piMMCButtonMenu);
            IfFailGo(hr);
        }
    }
    else
    {
        if (m_lCurrentButtonMenuIndex > 1 && m_lCurrentButtonMenuIndex <= lCount)
        {
            --m_lCurrentButtonMenuIndex;
            hr = GetCurrentButtonMenu(piMMCButton, &piMMCButtonMenu);
            IfFailGo(hr);

            hr = ShowButtonMenu(piMMCButtonMenu);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piMMCButtonMenu);
    RELEASE(piMMCButtonMenus);
    RELEASE(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnKillFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnKillFocus(int dlgItemID)
{
    HRESULT          hr = S_OK;
    int              lIndex = 0;
    IMMCButtons     *piMMCButtons = NULL;
    long             lCount = 0;
    IMMCButton      *piMMCButton = NULL;
    IMMCButtonMenus *piMMCButtonMenus = NULL;
    IMMCButtonMenu  *piMMCButtonMenu = NULL;

    if (false == m_bSavedLastButton)
    {
        goto Error;
    }

    switch (dlgItemID)
    {
    case IDC_EDIT_TB_INDEX:

        // Get the contents of the index field. If the user entered something
        // other than a number then set the index to 1.

        hr = GetDlgInt(IDC_EDIT_TB_INDEX, &lIndex);
        if (E_INVALIDARG == hr)
        {
            hr = S_OK;
            lIndex = 1L;
            // Set this to zero so code below will detect a change and
            // refresh dialog which will replace junk in index field with "1"
            m_lCurrentButtonIndex = 0;
        }
        IfFailGo(hr);

        hr = m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons));
        IfFailGo(hr);

        hr = piMMCButtons->get_Count(&lCount);
        IfFailGo(hr);

        // If the user entered an index of zero then switch it to 1 because the
        // collection is one-based

        if (0 == lIndex)
        {
            lIndex = 1L;
            // Set this to zero so code below will detect a change and
            // refresh dialog which will replace junk in index field with "1"
            m_lCurrentButtonIndex = 0;
        }

        // If the user entered an index that is beyond the end of the list then
        // switch to the last valid index

        if (lIndex > lCount)
        {
            lIndex = lCount;
            // Set this to zero so code below will detect a change and
            // refresh dialog which will replace junk in index field with "1"
            m_lCurrentButtonIndex = 0;
        }

        if (lIndex != m_lCurrentButtonIndex)
        {
            m_lCurrentButtonIndex = lIndex;

            hr = GetCurrentButton(&piMMCButton);
            IfFailGo(hr);

            hr = ShowButton(piMMCButton);
            IfFailGo(hr);
        }
        break;

    case IDC_EDIT_TB_MENU_INDEX:
        // Get the contents of the index field. If the user entered something
        // other than a number then set the index to 1.

        hr = GetDlgInt(IDC_EDIT_TB_MENU_INDEX, &lIndex);
        if (E_INVALIDARG == hr)
        {
            hr = S_OK;
            lIndex = 1L;
            // Set this to zero so code below will detect a change and
            // refresh dialog which will replace junk in index field with "1"
            m_lCurrentButtonMenuIndex = 0;
        }
        IfFailGo(hr);

        hr = GetCurrentButton(&piMMCButton);
        IfFailGo(hr);

        hr = piMMCButton->get_ButtonMenus(reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus));
        IfFailGo(hr);

        hr = piMMCButtonMenus->get_Count(&lCount);
        IfFailGo(hr);

        // If the user entered an index of zero then switch it to 1 because the
        // collection is one-based

        if (0 == lIndex)
        {
            lIndex = 1L;
            // Set this to zero so code below will detect a change and
            // refresh dialog which will replace junk in index field with "1"
            m_lCurrentButtonMenuIndex = 0;
        }

        // If the user entered an index that is beyond the end of the list then
        // switch to the last valid index

        if (lIndex > lCount)
        {
            lIndex = lCount;
            // Set this to zero so code below will detect a change and
            // refresh dialog which will replace junk in index field with "1"
            m_lCurrentButtonMenuIndex = 0;
        }

        if (lIndex != m_lCurrentButtonMenuIndex)
        {
            m_lCurrentButtonMenuIndex = lIndex;

            hr = GetCurrentButtonMenu(piMMCButton, &piMMCButtonMenu);
            IfFailGo(hr);

            hr = ShowButtonMenu(piMMCButtonMenu);
            IfFailGo(hr);
        }
        break;
    }

Error:
    RELEASE(piMMCButtonMenu);
    RELEASE(piMMCButtonMenus);
    RELEASE(piMMCButtons);
    RELEASE(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ShowButton(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ShowButton
(
    IMMCButton *piMMCButton
)
{
    HRESULT                     hr = S_OK;
    BSTR                        bstrCaption = NULL;
    BSTR                        bstrKey = NULL;
    SnapInButtonValueConstants  bvcValue = siUnpressed;
    SnapInButtonStyleConstants  bscStyle = siDefault;
    BSTR                        bstrTooltipText = NULL;
    VARIANT                     vtImage;
    VARIANT                     vtTag;
    VARIANT_BOOL                vtbVisible = VARIANT_FALSE;
    VARIANT_BOOL                vtbEnabled = VARIANT_FALSE;
    VARIANT_BOOL                vtbMixedState = VARIANT_FALSE;
    IMMCButtonMenus            *piMMCButtonMenus = NULL;
    long                        lCount = 0;
    IMMCButtonMenu             *piMMCButtonMenu = NULL;

    ASSERT(NULL != piMMCButton, "ShowButton: piMMCButton is NULL");

    ::VariantInit(&vtImage);
    ::VariantInit(&vtTag);

    m_lCurrentButtonMenuIndex = 0;
    m_bSilentUpdate = true;

    hr = SetDlgText(IDC_EDIT_TB_INDEX, m_lCurrentButtonIndex);
    IfFailGo(hr);

    hr = piMMCButton->get_Caption(&bstrCaption);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_CAPTION, bstrCaption);
    IfFailGo(hr);

    hr = piMMCButton->get_Key(&bstrKey);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_KEY, bstrKey);
    IfFailGo(hr);

    hr = piMMCButton->get_Value(&bvcValue);
    IfFailGo(hr);

    hr = SetCBItemSelection(IDC_COMBO_TB_BUTTON_VALUE, static_cast<long>(bvcValue));
    IfFailGo(hr);

    hr = piMMCButton->get_Style(&bscStyle);
    IfFailGo(hr);

    hr = SetCBItemSelection(IDC_COMBO_TB_BUTTON_STYLE, static_cast<long>(bscStyle));
    IfFailGo(hr);

    hr = piMMCButton->get_ToolTipText(&bstrTooltipText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_TOOLTIP_TEXT, bstrTooltipText);
    IfFailGo(hr);

    hr = piMMCButton->get_Image(&vtImage);
    IfFailGo(hr);

    hr = SetDlgText(vtImage, IDC_EDIT_TB_IMAGE);
    IfFailGo(hr);

    hr = piMMCButton->get_Tag(&vtTag);
    IfFailGo(hr);

    hr = SetDlgText(vtTag, IDC_EDIT_TB_BUTTON_TAG);
    IfFailGo(hr);

    hr = piMMCButton->get_Visible(&vtbVisible);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_VISIBLE, vtbVisible);
    IfFailGo(hr);

    hr = piMMCButton->get_Enabled(&vtbEnabled);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_ENABLED, vtbEnabled);
    IfFailGo(hr);

    hr = piMMCButton->get_MixedState(&vtbMixedState);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MIXED_STATE, vtbMixedState);
    IfFailGo(hr);

    hr = EnableButtonEdits(TRUE);
    IfFailGo(hr);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_INDEX), TRUE);

    if (siDropDown == bscStyle)
    {
                ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_CAPTION), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_IMAGE), FALSE);

        hr = SetDlgText(IDC_EDIT_TB_IMAGE, (BSTR)NULL);
        IfFailGo(hr);

        hr = piMMCButton->get_ButtonMenus(reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus));
        IfFailGo(hr);

        hr = piMMCButtonMenus->get_Count(&lCount);
        IfFailGo(hr);

        if (lCount > 0)
        {
            m_lCurrentButtonMenuIndex = 1;
            hr = GetCurrentButtonMenu(piMMCButton, &piMMCButtonMenu);
            IfFailGo(hr);

            hr = ShowButtonMenu(piMMCButtonMenu);
            IfFailGo(hr);

            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), TRUE);

            hr = EnableButtonMenuEdits(true);
            IfFailGo(hr);
        }
    }
    else
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), FALSE);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_CAPTION), FALSE);
        hr = SetDlgText(IDC_EDIT_TB_CAPTION, (BSTR)NULL);
        IfFailGo(hr);

                m_lCurrentButtonMenuIndex = 0;
                hr = ClearButtonMenu();
                IfFailGo(hr);

        hr = EnableButtonMenuEdits(false);
        IfFailGo(hr);
    }

Error:
    RELEASE(piMMCButtonMenu);
    RELEASE(piMMCButtonMenus);
    ::VariantClear(&vtTag);
    ::VariantClear(&vtImage);
    FREESTRING(bstrTooltipText);
    FREESTRING(bstrKey);
    FREESTRING(bstrCaption);
    m_bSilentUpdate = false;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ShowButtonMenu(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ShowButtonMenu(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT      hr = S_OK;
    BSTR         bstrText = NULL;
    BSTR         bstrKey = NULL;
    VARIANT      vtTag;
    VARIANT_BOOL vtbEnabled = VARIANT_FALSE;
    VARIANT_BOOL vtbVisible = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ShowButtonMenu: piMMCButtonMenu is NULL");

    ::VariantInit(&vtTag);

    hr = SetDlgText(IDC_EDIT_TB_MENU_INDEX, m_lCurrentButtonMenuIndex);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Text(&bstrText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_MENU_TEXT, bstrText);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Key(&bstrKey);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_MENU_KEY, bstrKey);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Tag(&vtTag);
    IfFailGo(hr);

    hr = SetDlgText(vtTag, IDC_EDIT_TB_MENU_TAG);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Enabled(&vtbEnabled);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_ENABLED, vtbEnabled);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Visible(&vtbVisible);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_VISIBLE, vtbVisible);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Checked(&vtbVisible);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_CHECKED, vtbVisible);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Grayed(&vtbVisible);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_GRAYED, vtbVisible);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Separator(&vtbVisible);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_SEPARATOR, vtbVisible);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_MenuBreak(&vtbVisible);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_BREAK, vtbVisible);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_MenuBarBreak(&vtbVisible);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_BAR_BREAK, vtbVisible);
    IfFailGo(hr);

Error:
    ::VariantClear(&vtTag);
    FREESTRING(bstrKey);
    FREESTRING(bstrText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::EnableButtonEdits(bool bEnable)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::EnableButtonEdits
(
    bool bEnable
)
{
    BOOL    fEnableEdit = ((false == bEnable) ? TRUE : FALSE);
    BOOL    fEnableWindow = ((true == bEnable) ? TRUE : FALSE);

//    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TB_INDEX), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_SPIN_TB_INDEX),        fEnableWindow);

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TB_CAPTION), EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TB_KEY),     EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_TB_BUTTON_VALUE), fEnableWindow);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_TB_BUTTON_STYLE), fEnableWindow);

    ::SendMessage(::GetDlgItem(m_hwnd,  IDC_EDIT_TB_TOOLTIP_TEXT), EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);
    ::SendMessage(::GetDlgItem(m_hwnd,  IDC_EDIT_TB_IMAGE),        EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_IMAGE),        fEnableWindow);
    ::SendMessage(::GetDlgItem(m_hwnd,  IDC_EDIT_TB_BUTTON_TAG),   EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_VISIBLE),        fEnableWindow);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_ENABLED),        fEnableWindow);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MIXED_STATE),    fEnableWindow);

    return S_OK;
}

//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::EnableButtonMenuEdits(bool bEnable)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::EnableButtonMenuEdits
(
    bool bEnable
)
{
    BOOL    fEnableEdit = ((false == bEnable) ? TRUE : FALSE);
    BOOL    fEnableWindow = ((true == bEnable) ? TRUE : FALSE);
    int     iRetValue = 0;

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TB_MENU_INDEX), EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);

    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_SPIN_TB_MENU_INDEX),        fEnableWindow);

    iRetValue = ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TB_MENU_TEXT), EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);
    iRetValue = ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TB_MENU_KEY),  EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);
    iRetValue = ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TB_MENU_TAG),  EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);

    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MENU_ENABLED),   fEnableWindow);
    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MENU_VISIBLE),   fEnableWindow);
    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MENU_CHECKED),   fEnableWindow);
    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MENU_GRAYED),    fEnableWindow);
    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MENU_SEPARATOR), fEnableWindow);
    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MENU_BREAK),     fEnableWindow);
    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MENU_BAR_BREAK), fEnableWindow);

    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CanEnterDoingNewButtonState()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::CanEnterDoingNewButtonState()
{
    HRESULT     hr = S_FALSE;

    if (m_bSavedLastButton && m_bSavedLastButtonMenu)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::EnterDoingNewButtonState()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::EnterDoingNewButtonState()
{
    HRESULT      hr = S_OK;

    ASSERT(NULL != m_piMMCToolbar, "EnterDoingNewButtonState: m_piMMCToolbar is NULL");

    // Bump up the current button index to keep matters in sync.
    ++m_lCurrentButtonIndex;
    hr = SetDlgText(IDC_EDIT_TB_INDEX, m_lCurrentButtonIndex);
    IfFailGo(hr);

    // Don't let the user change index on a new button

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_INDEX), FALSE);

    // We disable the RemoveButton, InsertButtonMenu and RemoveButtonMenu buttons.
    // The InsertButton button remains enabled and acts like an "Apply and New" button
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON), FALSE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), FALSE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), FALSE);

    // Enable edits in this area of the dialog and clear all the entries
    hr = EnableButtonEdits(TRUE);
    IfFailGo(hr);

    // Disable and clear the Caption field as the default style is siDefault and
    // Caption is only used for a menu button (siDropDown)

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_CAPTION), FALSE);

    hr = ClearButton();
    IfFailGo(hr);

    // Reinitialize button menu stuff for this button
        m_lCurrentButtonMenuIndex = 0;
        hr = ClearButtonMenu();
        IfFailGo(hr);

        hr = EnableButtonMenuEdits(FALSE);
        IfFailGo(hr);

    // Visible and Enabled should be on by default
    m_bSavedLastButton = FALSE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CanCreateNewButton()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::CanCreateNewButton()
{
    HRESULT     hr = S_OK;
    long        lData = 0;
    VARIANT     vtImageIndex;

    ::VariantInit(&vtImageIndex);

    // Got to have an image which is a string or an index > 0, unless it's a drop-down,
    // in which case we ignore this value.
    hr = GetCBSelectedItemData(IDC_COMBO_TB_BUTTON_STYLE, &lData);
    IfFailGo(hr);

    if (siDropDown != static_cast<SnapInButtonStyleConstants>(lData))
    {
        hr = GetDlgVariant(IDC_EDIT_TB_IMAGE, &vtImageIndex);
        IfFailGo(hr);

        if (VT_I4 == vtImageIndex.vt)
        {
            if (vtImageIndex.lVal <= 0)
            {
                HandleError(_T("Cannot Create New Button"), _T("ImageIndex has to be greater than zero"));
                hr = S_FALSE;
                goto Error;
            }
        }
        else if (VT_BSTR == vtImageIndex.vt)
        {
            if (0 == ::SysStringLen(vtImageIndex.bstrVal))
            {
                HandleError(_T("Cannot Create New Button"), _T("ImageIndex cannot be an empty string"));
                hr = S_FALSE;
                goto Error;
            }
        }
        else
        {
            HandleError(_T("Cannot Create New Button"), _T("Cannot determine type of ImageIndex"));
            hr = S_FALSE;
            goto Error;
        }

    }

Error:
    ::VariantClear(&vtImageIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CreateNewButton()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::CreateNewButton(IMMCButton **ppiMMCButton)
{
    HRESULT         hr = S_OK;
    IMMCButtons    *piMMCButtons = NULL;
    VARIANT         varIndex;
    BSTR            bstrKey = NULL;
    VARIANT         vtKey;
    BSTR            bstrCaption = NULL;
    VARIANT         vtCaption;
    BSTR            bstrTooltipText = NULL;
    VARIANT         vtTooltipText;
    VARIANT         vtStyle;
    long            lData = 0;
    BSTR            bstrImage = NULL;
    VARIANT         vtImage;

    ::VariantInit(&varIndex);
    ::VariantInit(&vtKey);
    ::VariantInit(&vtCaption);
    ::VariantInit(&vtTooltipText);
    ::VariantInit(&vtStyle);
    ::VariantInit(&vtImage);

    varIndex.vt = VT_I4;
    varIndex.lVal = m_lCurrentButtonIndex;

    hr = GetDlgText(IDC_EDIT_TB_KEY, &bstrKey);
    IfFailGo(hr);

    if (NULL == bstrKey || 0 == ::SysStringLen(bstrKey))
    {
        vtKey.vt = VT_ERROR;
        vtKey.scode = DISP_E_PARAMNOTFOUND;
    }
    else
    {
        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrKey);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    hr = GetDlgText(IDC_EDIT_TB_CAPTION, &bstrCaption);
    IfFailGo(hr);

    vtCaption.vt = VT_BSTR;
    vtCaption.bstrVal = ::SysAllocString(bstrCaption);
    if (NULL == vtCaption.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetDlgText(IDC_EDIT_TB_TOOLTIP_TEXT, &bstrTooltipText);
    IfFailGo(hr);

    vtTooltipText.vt = VT_BSTR;
    vtTooltipText.bstrVal = ::SysAllocString(bstrTooltipText);
    if (NULL == vtTooltipText.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetCBSelectedItemData(IDC_COMBO_TB_BUTTON_STYLE, &lData);
    IfFailGo(hr);

    vtStyle.vt = VT_I4;
    vtStyle.lVal = lData;

    hr = GetDlgText(IDC_EDIT_TB_IMAGE, &bstrImage);
    IfFailGo(hr);

    vtImage.vt = VT_BSTR;
    vtImage.bstrVal = ::SysAllocString(bstrImage);
    if (NULL == vtImage.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons));
    IfFailGo(hr);

    hr = piMMCButtons->Add(varIndex, vtKey, vtCaption, vtStyle, vtImage,
                           vtTooltipText,
                           reinterpret_cast<MMCButton **>(ppiMMCButton));
    IfFailGo(hr);

Error:
    ::VariantClear(&vtImage);
    FREESTRING(bstrImage);
    ::VariantClear(&vtStyle);
    ::VariantClear(&vtCaption);
    FREESTRING(bstrCaption);
    ::VariantClear(&vtTooltipText);
    FREESTRING(bstrTooltipText);
    ::VariantClear(&vtKey);
    FREESTRING(bstrKey);
    ::VariantClear(&varIndex);
    RELEASE(piMMCButtons);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ExitDoingNewButtonState()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ExitDoingNewButtonState(IMMCButton *piMMCButton)
{
    HRESULT                     hr = S_OK;
    SnapInButtonStyleConstants  sibsc = siDefault;

    ASSERT(m_piMMCToolbar != NULL, "ExitDoingNewButtonState: m_piMMCToolbar is NULL");

    if (NULL != piMMCButton)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON), TRUE);

        hr = piMMCButton->get_Style(&sibsc);
        IfFailGo(hr);

        if (siDropDown == sibsc)
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), TRUE);
        }
    }
    else    // Operation was cancelled
    {
        --m_lCurrentButtonIndex;
        if (m_lCurrentButtonIndex > 0)
        {
            hr = GetCurrentButton(&piMMCButton);
            IfFailGo(hr);

            hr = ShowButton(piMMCButton);
            IfFailGo(hr);

            RELEASE(piMMCButton);
        }
        else
        {
            hr = EnableButtonEdits(false);
            IfFailGo(hr);

            hr = ClearButton();
            IfFailGo(hr);
        }
    }

    m_bSavedLastButton = true;
    m_bSavedLastButtonMenu = true;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CanEnterDoingNewButtonMenuState()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::CanEnterDoingNewButtonMenuState()
{
    HRESULT     hr = S_FALSE;

    if (m_bSavedLastButton && m_bSavedLastButtonMenu)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::EnterDoingNewButtonMenuState(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::EnterDoingNewButtonMenuState(IMMCButton *piMMCButton)
{
    HRESULT          hr = S_OK;
    long             lCount = 0;

    ASSERT(NULL != piMMCButton, "EnterDoingNewButtonMenuState: piMMCButton is NULL");

    // Bump up the current button index to keep matters in sync.
    ++m_lCurrentButtonMenuIndex;
    hr = SetDlgText(IDC_EDIT_TB_MENU_INDEX, m_lCurrentButtonMenuIndex);
    IfFailGo(hr);

    // We disable the InsertButton, RemoveButton, and RemoveButtonMenu buttons.
    // The InsertButton button remains enabled and acts like an "Apply and New" button
    //::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON), FALSE);
    //::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON), FALSE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), FALSE);

    hr = EnableButtonMenuEdits(true);
    IfFailGo(hr);

        hr = ClearButtonMenu();
    IfFailGo(hr);

    m_bSavedLastButtonMenu = FALSE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CanCreateNewButtonMenu()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::CanCreateNewButtonMenu()
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CreateNewButtonMenu(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::CreateNewButtonMenu(IMMCButton *piMMCButton, IMMCButtonMenu **ppiMMCButtonMenu)
{
    HRESULT           hr = S_OK;
    IMMCButtonMenus  *piMMCButtonMenus = NULL;
    VARIANT           varIndex;
    BSTR              bstrKey = NULL;
    VARIANT           vtKey;
    BSTR              bstrText = NULL;
    VARIANT           vtText;

    ::VariantInit(&varIndex);
    ::VariantInit(&vtKey);
    ::VariantInit(&vtText);

    hr = piMMCButton->get_ButtonMenus(reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus));
    IfFailGo(hr);

    varIndex.vt = VT_I4;
    varIndex.lVal = m_lCurrentButtonMenuIndex;

    hr = GetDlgText(IDC_EDIT_TB_MENU_KEY, &bstrKey);
    IfFailGo(hr);

    if (NULL != bstrKey && ::SysStringLen(bstrKey) > 0)
    {
        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrKey);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else
    {
        vtKey.vt = VT_ERROR;
        vtKey.scode = DISP_E_PARAMNOTFOUND;
    }

    hr = GetDlgText(IDC_EDIT_TB_MENU_TEXT, &bstrText);
    IfFailGo(hr);

    vtText.vt = VT_BSTR;
    vtText.bstrVal = ::SysAllocString(bstrText);
    if (NULL == vtText.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piMMCButtonMenus->Add(varIndex, vtKey, vtText, reinterpret_cast<MMCButtonMenu **>(ppiMMCButtonMenu));
    IfFailGo(hr);

Error:
    ::VariantClear(&vtText);
    FREESTRING(bstrText);
    ::VariantClear(&vtKey);
    FREESTRING(bstrKey);
    ::VariantClear(&varIndex);
    RELEASE(piMMCButtonMenus);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ExitDoingNewButtonMenuState(IMMCButton *piMMCButton, IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ExitDoingNewButtonMenuState(IMMCButton *piMMCButton, IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT     hr = S_OK;

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON), TRUE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON), TRUE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), TRUE);

    m_bSavedLastButtonMenu = true;

//Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::GetCurrentButton(IMMCButton **ppiMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
// Returns: S_OK - button found and returned in *ppiMMCButton
//          S_FALSE - button not found, *ppiMMCButton=NULL
//
HRESULT CToolbarButtonsPage::GetCurrentButton(IMMCButton **ppiMMCButton)
{
    HRESULT      hr = S_OK;
    IMMCButtons *piMMCButtons = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    *ppiMMCButton = NULL;

    ASSERT(NULL != m_piMMCToolbar, "GetCurrentButton: m_piMMCToolbar is NULL");

    if (m_lCurrentButtonIndex > 0)
    {
        hr = m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons));
        IfFailGo(hr);

        varIndex.vt = VT_I4;
        varIndex.lVal = m_lCurrentButtonIndex;
        hr = piMMCButtons->get_Item(varIndex, reinterpret_cast<MMCButton **>(ppiMMCButton));
        if (SID_E_INDEX_OUT_OF_RANGE == hr)
        {
            // User did Insert Button but has not yet applied so it it not
            // in the collection.
            hr = S_FALSE;
        }
        IfFailGo(hr);
    }
    else
    {
        hr = S_FALSE;
    }

Error:
    RELEASE(piMMCButtons);
    ::VariantClear(&varIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::GetCurrentButtonMenu(IMMCButton *piMMCButton, IMMCButtonMenu **ppiMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::GetCurrentButtonMenu(IMMCButton *piMMCButton, IMMCButtonMenu **ppiMMCButtonMenu)
{
    HRESULT          hr = S_OK;
    IMMCButtonMenus *piMMCButtonMenus = NULL;
    VARIANT          varIndex;

    ASSERT(NULL != piMMCButton, "GetCurrentButton: piMMCButton is NULL");

    ::VariantInit(&varIndex);

    if (m_lCurrentButtonMenuIndex > 0)
    {
        hr = piMMCButton->get_ButtonMenus(reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus));
        IfFailGo(hr);

        varIndex.vt = VT_I4;
        varIndex.lVal = m_lCurrentButtonMenuIndex;
        hr = piMMCButtonMenus->get_Item(varIndex, reinterpret_cast<MMCButtonMenu **>(ppiMMCButtonMenu));
        IfFailGo(hr);
    }

Error:
    RELEASE(piMMCButtonMenus);
    ::VariantClear(&varIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnDestroy()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnDestroy()
{
    HRESULT          hr = S_OK;

    IfFailGo(CheckButtonStyles());

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CheckButtonStyles()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
// Checks that all buttons are either dropdown or something else as MMC does not
// allow mixing toolbar buttons and menu buttons. If styles are not consistent
// displays message telling user to fix it up before running the snap-in or a
// runtime error will occur.
//
HRESULT CToolbarButtonsPage::CheckButtonStyles()
{
    HRESULT                     hr = S_OK;
    long                        cButtons = 0;
    SnapInButtonStyleConstants  Style = siDefault;
    SnapInButtonStyleConstants  LastStyle = siDefault;
    IMMCButtons                *piMMCButtons = NULL;
    IMMCButton                 *piMMCButton = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    IfFailGo(m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons)));
    IfFailGo(piMMCButtons->get_Count(&cButtons));

    varIndex.vt = VT_I4;

    for (varIndex.lVal = 1L; varIndex.lVal <= cButtons; varIndex.lVal++)
    {
        IfFailGo(piMMCButtons->get_Item(varIndex, reinterpret_cast<MMCButton **>(&piMMCButton)));
        IfFailGo(piMMCButton->get_Style(&Style));

        if (varIndex.lVal != 1L)
        {
            if (siDropDown == Style)
            {
                if (siDropDown != LastStyle)
                {
                    hr = SID_E_TOOLBAR_INCONSISTENT;
                    goto Error;
                }
            }
            else // This button is not drop-down
            {
                if (siDropDown == LastStyle)
                {
                    hr = SID_E_TOOLBAR_INCONSISTENT;
                    goto Error;
                }
            }
        }
        LastStyle = Style;
        RELEASE(piMMCButton);
    }

Error:
    if (SID_E_TOOLBAR_INCONSISTENT == hr)
    {
        HandleError("Toolbar Definition Inconsistent", "A toolbar's buttons must all be drop-down style or all must be something else. MMC does not allow mixing toolbar buttons and menu buttons within a toolbar. If you do not make the styles consistent before running your snap-in the toolbar will not appear.");
    }
    QUICK_RELEASE(piMMCButtons);
    QUICK_RELEASE(piMMCButton);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psurl.h ===
//=--------------------------------------------------------------------------------------
// psurl.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// URL View Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSURL_H_
#define _PSURL_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// URL View Property Page General
//
////////////////////////////////////////////////////////////////////////////////////


class CURLViewGeneralPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CURLViewGeneralPage(IUnknown *pUnkOuter);
    virtual ~CURLViewGeneralPage();

// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplyURLName();
    HRESULT ApplyURLUrl();
    HRESULT ApplyAddToView();
    HRESULT ApplyViewMenuText();
    HRESULT ApplyStatusBarText();

// Instance data
protected:
    IURLViewDef  *m_piURLViewDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	URLViewGeneral,                     // Name
	&CLSID_URLViewDefGeneralPP,         // Class ID
	"URL View General Property Page",   // Registry display name
	CURLViewGeneralPage::Create,        // Create function
	IDD_PROPPAGE_URL_VIEW,              // Dialog resource ID
	IDS_URLPPG_GEN,                     // Tab caption
	IDS_URLPPG_GEN,                     // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_URLViews,               // Help context ID
	FALSE                               // Thread safe
);


#endif  // _PSURL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psocx.cpp ===
//=--------------------------------------------------------------------------------------
// psocx.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// OCX View Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "psocx.h"

// for ASSERT and FAIL
//
SZTHISFILE


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// OCX View Property Page
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *COCXViewGeneralPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *COCXViewGeneralPage::Create(IUnknown *pUnkOuter)
{
	COCXViewGeneralPage *pNew = New COCXViewGeneralPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::COCXViewGeneralPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
COCXViewGeneralPage::COCXViewGeneralPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGOCXVIEWGENERAL), m_piOCXViewDef(0)
{
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::~COCXViewGeneralPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
COCXViewGeneralPage::~COCXViewGeneralPage()
{
    RELEASE(m_piOCXViewDef);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::OnInitializeDialog()
{
    HRESULT     hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_OCX_NAME, IDS_TT_OCX_NAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_OCX_PROGID, IDS_TT_OCX_PROGID);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_OCX_ADDTOVIEWMENU, IDS_TT_OCX_ATVMENU);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_OCX_VIEWMENUTEXT, IDS_TT_OCX_VMTEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_OCX_STATUSBARTEXT, IDS_TT_OCX_SBTEXT);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    BSTR            bstrName = NULL;
    BSTR            bstrProgID = NULL;
    VARIANT_BOOL    vtBool = VARIANT_FALSE;
    BSTR            bstrViewMenuText = NULL;
    BSTR            bstrStatusBarText = NULL;

    if (m_piOCXViewDef != NULL)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IOCXViewDef, reinterpret_cast<void **>(&m_piOCXViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piOCXViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_OCX_NAME, bstrName);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_ProgID(&bstrProgID);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_OCX_PROGID, bstrProgID);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_AddToViewMenu(&vtBool);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_OCX_ADDTOVIEWMENU, vtBool);
    IfFailGo(hr);

    // Initialize the state of View Menu Text
    if (vtBool == VARIANT_FALSE)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_OCX_VIEWMENUTEXT), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_OCX_STATUSBARTEXT), FALSE);
    }

    hr = m_piOCXViewDef->get_ViewMenuText(&bstrViewMenuText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_OCX_VIEWMENUTEXT, bstrViewMenuText);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_ViewMenuStatusBarText(&bstrStatusBarText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_OCX_STATUSBARTEXT, bstrStatusBarText);
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    FREESTRING(bstrStatusBarText);
    FREESTRING(bstrViewMenuText);
    FREESTRING(bstrProgID);
    FREESTRING(bstrName);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(m_piOCXViewDef != NULL, "OnApply: m_piOCXViewDef is NULL");

    hr = ApplyOCXName();
    IfFailGo(hr);

    hr = ApplyProgID();
    IfFailGo(hr);

    hr = ApplyAddToView();
    IfFailGo(hr);

    hr = ApplyViewMenuText();
    IfFailGo(hr);

    hr = ApplyStatusBarText();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::ApplyOCXName
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::ApplyOCXName()
{
    HRESULT  hr = S_OK;
    BSTR     bstrOCXName = NULL;
    BSTR     bstrSavedOCXName = NULL;

    hr = GetDlgText(IDC_EDIT_OCX_NAME, &bstrOCXName);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_Name(&bstrSavedOCXName);
    IfFailGo(hr);

    if (::wcscmp(bstrOCXName, bstrSavedOCXName) != 0)
    {
        hr = m_piOCXViewDef->put_Name(bstrOCXName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedOCXName);
    FREESTRING(bstrOCXName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::ApplyProgID
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::ApplyProgID()
{
    HRESULT  hr = S_OK;
    BSTR     bstrProgID = NULL;
    BSTR     bstrSavedProgID = NULL;

    hr = GetDlgText(IDC_EDIT_OCX_PROGID, &bstrProgID);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_ProgID(&bstrSavedProgID);
    IfFailGo(hr);

    if (::wcscmp(bstrProgID, bstrSavedProgID) != 0)
    {
        hr = m_piOCXViewDef->put_ProgID(bstrProgID);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedProgID);
    FREESTRING(bstrProgID);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::ApplyAddToView
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::ApplyAddToView()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtAddToView = VARIANT_FALSE;
    VARIANT_BOOL    vtSavedAddToView = VARIANT_FALSE;

    hr = GetCheckbox(IDC_CHECK_OCX_ADDTOVIEWMENU, &vtAddToView);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_AddToViewMenu(&vtSavedAddToView);
    IfFailGo(hr);

    if (vtAddToView != vtSavedAddToView)
    {
        hr = m_piOCXViewDef->put_AddToViewMenu(vtAddToView);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::ApplyViewMenuText
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::ApplyViewMenuText()
{
    HRESULT  hr = S_OK;
    BSTR     bstrViewMenuText = NULL;
    BSTR     bstrSavedViewMenuText = NULL;

    hr = GetDlgText(IDC_EDIT_OCX_VIEWMENUTEXT, &bstrViewMenuText);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_ViewMenuText(&bstrSavedViewMenuText);
    IfFailGo(hr);

    if (::wcscmp(bstrViewMenuText, bstrSavedViewMenuText) != 0)
    {
        hr = m_piOCXViewDef->put_ViewMenuText(bstrViewMenuText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedViewMenuText);
    FREESTRING(bstrViewMenuText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::ApplyStatusBarText
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::ApplyStatusBarText()
{
    HRESULT  hr = S_OK;
    BSTR     bstrStatusBarText = NULL;
    BSTR     bstrSavedStatusBarText = NULL;

    hr = GetDlgText(IDC_EDIT_OCX_STATUSBARTEXT, &bstrStatusBarText);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_ViewMenuStatusBarText(&bstrSavedStatusBarText);
    IfFailGo(hr);

    if (::wcscmp(bstrStatusBarText, bstrSavedStatusBarText) != 0)
    {
        hr = m_piOCXViewDef->put_ViewMenuStatusBarText(bstrStatusBarText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedStatusBarText);
    FREESTRING(bstrStatusBarText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtAddToViewMenu = VARIANT_FALSE;

    switch (dlgItemID)
    {
    case IDC_CHECK_OCX_ADDTOVIEWMENU:
        hr = GetCheckbox(IDC_CHECK_OCX_ADDTOVIEWMENU, &vtAddToViewMenu);
        IfFailGo(hr);

        if (vtAddToViewMenu == VARIANT_TRUE)
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_OCX_VIEWMENUTEXT), TRUE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_OCX_STATUSBARTEXT), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_OCX_VIEWMENUTEXT), FALSE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_OCX_STATUSBARTEXT), FALSE);
        }

    }

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\pstoolbr.h ===
//=--------------------------------------------------------------------------------------
// pstoolbr.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Toolbar Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSTOOLBAR_H_
#define _PSTOOLBAR_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// Toolbar Property Page General
//
////////////////////////////////////////////////////////////////////////////////////


class CToolbarGeneralPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CToolbarGeneralPage(IUnknown *pUnkOuter);
    virtual ~CToolbarGeneralPage();

// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnCtlSelChange(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplyImageList();
    HRESULT ApplyTag();

// Initialization
    HRESULT InitializeImageListCombo();
    HRESULT InitializeImageListValue();

// Instance data
protected:
    IMMCToolbar         *m_piMMCToolbar;
    ISnapInDesignerDef  *m_piSnapInDesignerDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ToolbarGeneral,                     // Name
	&CLSID_MMCToolbarGeneralPP,         // Class ID
	"Toolbar General Property Page",    // Registry display name
	CToolbarGeneralPage::Create,        // Create function
	IDD_PROPPAGE_TOOLBAR_GENERAL,       // Dialog resource ID
	IDS_TOOLBPPG_GEN,                   // Tab caption
	IDS_TOOLBPPG_GEN,                   // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_Toolbars,               // Help context ID
	FALSE                               // Thread safe
);


////////////////////////////////////////////////////////////////////////////////////
//
// Toolbar Property Page Buttons
//
// We handle insertion, deletion, modification and navigation of IMMCButton's and
// the IMMCButtonMenu's owned by them. This is one of the most involved property
// pages in the whole designer.
//
////////////////////////////////////////////////////////////////////////////////////


class CToolbarButtonsPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CToolbarButtonsPage(IUnknown *pUnkOuter);
    virtual ~CToolbarButtonsPage();

// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnCtlSelChange(int dlgItemID);
    virtual HRESULT OnDeltaPos(NMUPDOWN *pNMUpDown);
    virtual HRESULT OnKillFocus(int dlgItemID);
    virtual HRESULT OnDestroy();

// Helpers for Apply event
protected:
    // IMMCButton's
    HRESULT CreateNewButton(IMMCButton **ppiMMCButton);
    HRESULT GetCurrentButton(IMMCButton **ppiMMCButton);
    HRESULT ShowButton(IMMCButton *piMMCButton);
    HRESULT EnableButtonEdits(bool bEnable);
    HRESULT ClearButton();
    HRESULT ApplyCurrentButton();

    HRESULT ApplyCaption(IMMCButton *piMMCButton);
    HRESULT ApplyKey(IMMCButton *piMMCButton);
    HRESULT ApplyValue(IMMCButton *piMMCButton);
    HRESULT ApplyStyle(IMMCButton *piMMCButton);
    HRESULT ApplyTooltipText(IMMCButton *piMMCButton);
    HRESULT ApplyImage(IMMCButton *piMMCButton);
    HRESULT ApplyTag(IMMCButton *piMMCButton);
    HRESULT ApplyVisible(IMMCButton *piMMCButton);
    HRESULT ApplyEnabled(IMMCButton *piMMCButton);
    HRESULT ApplyMixedState(IMMCButton *piMMCButton);
    HRESULT CheckButtonStyles();

    // IMMCButtonMenu's
    HRESULT CreateNewButtonMenu(IMMCButton *piMMCButton, IMMCButtonMenu **ppiMMCButtonMenu);
    HRESULT GetCurrentButtonMenu(IMMCButton *piMMCButton, IMMCButtonMenu **ppiMMCButtonMenu);
    HRESULT ShowButtonMenu(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT EnableButtonMenuEdits(bool bEnable);
	HRESULT ClearButtonMenu();
    HRESULT ApplyCurrentButtonMenu(IMMCButton *piMMCButton);

    HRESULT ApplyButtonMenuText(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuKey(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuTag(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuEnabled(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuVisible(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuChecked(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuGrayed(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuSeparator(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuBreak(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuBarBreak(IMMCButtonMenu *piMMCButtonMenu);

// Other helpers
protected:
    // Helpers called at initialization time
    HRESULT InitializeButtonValues();
    HRESULT PopulateButtonValues();
    HRESULT PopulateButtonStyles();
    HRESULT InitializeButtonStyles();

    // Combo box notifications
    HRESULT OnButtonStyle();

    // Button Handlers
    HRESULT OnRemoveButton();
    HRESULT OnRemoveButtonMenu();

    // Spin Button Handlers
    HRESULT OnButtonDeltaPos(NMUPDOWN *pNMUpDown);
    HRESULT OnButtonMenuDeltaPos(NMUPDOWN *pNMUpDown);

// State transitions
protected:
    HRESULT CanEnterDoingNewButtonState();
    HRESULT EnterDoingNewButtonState();
    HRESULT CanCreateNewButton();
    HRESULT ExitDoingNewButtonState(IMMCButton *piMMCButton);

    HRESULT CanEnterDoingNewButtonMenuState();
    HRESULT EnterDoingNewButtonMenuState(IMMCButton *piMMCButton);
    HRESULT CanCreateNewButtonMenu();
    HRESULT ExitDoingNewButtonMenuState(IMMCButton *piMMCButton, IMMCButtonMenu *piMMCButtonMenu);

// Instance data
protected:
    IMMCToolbar  *m_piMMCToolbar;
    long          m_lCurrentButtonIndex;
    long          m_lCurrentButtonMenuIndex;
    bool          m_bSavedLastButton;
    bool          m_bSavedLastButtonMenu;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ToolbarButtons,                     // Name
	&CLSID_MMCToolbarButtonsPP,         // Class ID
	"Toolbar Buttons Property Page",    // Registry display name
	CToolbarButtonsPage::Create,        // Create function
	IDD_PROPPAGE_TOOLBAR_BUTTONS,       // Dialog resource ID
	IDS_TOOLBPPG_BUTTONS,               // Tab caption
	IDS_TOOLBPPG_BUTTONS,               // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_Toolbars,               // Help context ID
	FALSE                               // Thread safe
);


#endif  // _PSTOOLBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\pstaskp.cpp ===
//=--------------------------------------------------------------------------------------
// pstaskp.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// OCX View Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "pstaskp.h"

// for ASSERT and FAIL
//
SZTHISFILE


BOOL IsValidURL(const TCHAR *pszString)
{
    if (NULL != pszString)
    {
        if (0 != ::_tcslen(pszString))
        {
            return TRUE;
        }
    }
    return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Taskpad View General Property Page
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CTaskpadViewGeneralPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CTaskpadViewGeneralPage::Create(IUnknown *pUnkOuter)
{
	CTaskpadViewGeneralPage *pNew = New CTaskpadViewGeneralPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::CTaskpadViewGeneralPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CTaskpadViewGeneralPage::CTaskpadViewGeneralPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGTASKGENERAL),
m_piTaskpadViewDef(NULL),
m_piTaskpad(NULL),
m_piSnapInDesignerDef(NULL)
{
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::~CTaskpadViewGeneralPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CTaskpadViewGeneralPage::~CTaskpadViewGeneralPage()
{
    RELEASE(m_piTaskpad);
    RELEASE(m_piTaskpadViewDef);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::OnInitializeDialog()
{
    HRESULT     hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_TP_NAME, IDS_TT_TP_GEN_NAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_TITLE, IDS_TT_TP_GEN_TITLE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_DESCRIPTIVE_TEXT, IDS_TT_TP_GEN_TEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_DEFAULT, IDS_TT_TP_GEN_DEFAULT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_LISTPAD, IDS_TT_TP_GEN_LISTPAD);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_LP_TITLE, IDS_TT_TP_GEN_LIST_TI);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TP_USE_BUTTON, IDS_TT_TP_GEN_USE_BTN);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_LP_BUTTON_TEXT, IDS_TT_TP_GEN_BTN_TEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_CUSTOM, IDS_TT_TP_GEN_CUSTOM);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_URL, IDS_TT_TP_GEN_URL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TP_USER_PREFERRED, IDS_TT_TP_GEN_PREFERRED);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TP_ADD_TO_VIEW, IDS_TT_TP_GEN_ADDTOVW);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_VIEW_MENUTXT, IDS_TT_TP_GEN_VWMNTEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_TP_LISTVIEW, IDS_TT_TP_GEN_LISTVIEW);
    IfFailGo(hr);

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_LP_TITLE), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TP_USE_BUTTON), FALSE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_TP_LISTVIEW), FALSE);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_LP_BUTTON_TEXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_URL), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_VIEW_MENUTXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_STATUSBARTEXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::OnNewObjects()
{
    HRESULT                    hr = S_OK;
    IUnknown                  *pUnk = NULL;
    IObjectModel              *piObjectModel = NULL;
    DWORD                      dwDummy = 0;
    BSTR                       bstrName = NULL;
    BSTR                       bstrTitle = NULL;
    BSTR                       bstrText = NULL;
    SnapInTaskpadTypeConstants sittc = Default;
    BSTR                       bstrListpadTitle = NULL;
    VARIANT_BOOL               bHasButton = VARIANT_FALSE;
    BSTR                       bstrButtonText = NULL;
    BSTR                       bstrURL = NULL;
    VARIANT_BOOL               bUsePreferred = VARIANT_FALSE;
    VARIANT_BOOL               bAddToView = VARIANT_FALSE;
    BSTR                       bstrViewMenuText = NULL;
    BSTR                       bstrStatusBarText = NULL;

    if (m_piTaskpadViewDef != NULL)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_ITaskpadViewDef, reinterpret_cast<void **>(&m_piTaskpadViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&m_piSnapInDesignerDef);
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piTaskpadViewDef->get_Taskpad(&m_piTaskpad);
    IfFailGo(hr);

    hr = m_piTaskpad->get_Name(&bstrName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_NAME, bstrName);
    IfFailGo(hr);

    hr = m_piTaskpad->get_Title(&bstrTitle);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TITLE, bstrTitle);
    IfFailGo(hr);

    hr = m_piTaskpad->get_DescriptiveText(&bstrText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_DESCRIPTIVE_TEXT, bstrText);
    IfFailGo(hr);

    hr = m_piTaskpad->get_Type(&sittc);
    IfFailGo(hr);

    switch (sittc)
    {
    case Default:
        hr = SetCheckbox(IDC_RADIO_TP_DEFAULT, VARIANT_TRUE);
        IfFailGo(hr);
        break;

    case Listpad:
        hr = SetCheckbox(IDC_RADIO_TP_LISTPAD, VARIANT_TRUE);
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_LP_TITLE), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        hr = m_piTaskpad->get_ListpadTitle(&bstrListpadTitle);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_LP_TITLE, bstrListpadTitle);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TP_USE_BUTTON), TRUE);
        hr = m_piTaskpad->get_ListpadHasButton(&bHasButton);
        IfFailGo(hr);

        hr = SetCheckbox(IDC_CHECK_TP_USE_BUTTON, bHasButton);
        IfFailGo(hr);

        if (VARIANT_TRUE == bHasButton)
        {
            ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_LP_BUTTON_TEXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
            hr = m_piTaskpad->get_ListpadButtonText(&bstrButtonText);
            IfFailGo(hr);

            hr = SetDlgText(IDC_EDIT_TP_LP_BUTTON_TEXT, bstrButtonText);
            IfFailGo(hr);
        }

        IfFailGo(PopulateListViewCombo());

        break;

    case Custom:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TITLE), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_DESCRIPTIVE_TEXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

        hr = SetCheckbox(IDC_RADIO_TP_CUSTOM, VARIANT_TRUE);
        IfFailGo(hr);

        hr = m_piTaskpad->get_URL(&bstrURL);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_URL, bstrURL);
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_URL), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        break;
    }

    hr = m_piTaskpadViewDef->get_UseWhenTaskpadViewPreferred(&bUsePreferred);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TP_USER_PREFERRED, bUsePreferred);
    IfFailGo(hr);

    hr = m_piTaskpadViewDef->get_AddToViewMenu(&bAddToView);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TP_ADD_TO_VIEW, bAddToView);
    IfFailGo(hr);

    if (VARIANT_TRUE == bAddToView)
    {
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_VIEW_MENUTXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_STATUSBARTEXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);

        hr = m_piTaskpadViewDef->get_ViewMenuText(&bstrViewMenuText);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_VIEW_MENUTXT, bstrViewMenuText);
        IfFailGo(hr);

        hr = m_piTaskpadViewDef->get_ViewMenuStatusBarText(&bstrStatusBarText);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_STATUSBARTEXT, bstrStatusBarText);
        IfFailGo(hr);
    }

    m_bInitialized = true;

Error:
    FREESTRING(bstrStatusBarText);
    FREESTRING(bstrViewMenuText);
    FREESTRING(bstrURL);
    FREESTRING(bstrButtonText);
    FREESTRING(bstrListpadTitle);
    FREESTRING(bstrText);
    FREESTRING(bstrTitle);
    FREESTRING(bstrName);
    QUICK_RELEASE(piObjectModel);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::PopulateListViewCombo()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::PopulateListViewCombo()
{
    HRESULT        hr = S_OK;
    BSTR           bstrListView = NULL;
    IViewDefs     *piViewDefs = NULL;
    IListViewDefs *piListViewDefs = NULL;
    IListViewDef  *piListViewDef = NULL;
    long           cListViewDefs = 0;
    long           i = 0;
    long           iListView = 0;
    BSTR           bstrNextListView = NULL;
    BOOL           fFoundListView = FALSE;

    VARIANT varKey;
    ::VariantInit(&varKey);

    IfFailGo(m_piTaskpad->get_ListView(&bstrListView));
    if (NULL != bstrListView)
    {
        if (0 == ::wcslen(bstrListView))
        {
            // Zero length string is the same as none at all
            FREESTRING(bstrListView);
        }
    }

    // Get the ListViewDefs collection

    IfFailGo(m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs));
    IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));
    IfFailGo(piListViewDefs->get_Count(&cListViewDefs));

        // If there is anything in it then enable the combobox and populate it

    if (cListViewDefs > 0)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_TP_LISTVIEW), TRUE);
    }

    varKey.vt = VT_I4;;

    for (i = 1L; i <= cListViewDefs; i++)
    {
        varKey.lVal = i;
        IfFailGo(piListViewDefs->get_Item(varKey, &piListViewDef));
        IfFailGo(piListViewDef->get_Name(&bstrNextListView));
        if (NULL != bstrListView)
        {
            if (0 == ::wcscmp(bstrListView, bstrNextListView))
            {
                iListView = i - 1L;
                fFoundListView = TRUE;
            }
        }
        IfFailGo(AddCBBstr(IDC_COMBO_TP_LISTVIEW, bstrNextListView, 0));
        RELEASE(piListViewDef);
    }

    // If there is a Taskpad.ListView and we didn't find it then reset
    // the property to NULL

    if ( (NULL != bstrListView) && (!fFoundListView) )
    {
        IfFailGo(m_piTaskpad->put_ListView(NULL));
    }

    // If Taskpad.ListView was found then select it

    if (fFoundListView)
    {
        if (CB_ERR == ::SendDlgItemMessage(m_hwnd,
                                           IDC_COMBO_TP_LISTVIEW,
                                           CB_SETCURSEL,
                                           static_cast<WPARAM>(iListView), 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else if (cListViewDefs > 0)
    {
        // Make sure that the first item is visible

        if (CB_ERR == ::SendDlgItemMessage(m_hwnd,
                                           IDC_COMBO_TP_LISTVIEW,
                                           CB_SETTOPINDEX,
                                           static_cast<WPARAM>(iListView), 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }


Error:
    FREESTRING(bstrListView);
    FREESTRING(bstrNextListView);
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piListViewDefs);
    QUICK_RELEASE(piListViewDef);
    RRETURN(hr);
}



HRESULT CTaskpadViewGeneralPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
        case IDC_COMBO_TP_LISTVIEW:
            MakeDirty();
            break;
    }

    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(m_piTaskpadViewDef != NULL, "OnApply: m_piTaskpadViewDef is NULL");

	hr = CanApply();
	IfFailGo(hr);

	if (S_OK == hr)
	{
		hr = ApplyName();
		IfFailGo(hr);

		hr = ApplyTitle();
		IfFailGo(hr);

		hr = ApplyDescription();
		IfFailGo(hr);

		hr = ApplyType();
		IfFailGo(hr);

		hr = ApplyViewMenu();
		IfFailGo(hr);
	}

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::CanApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::CanApply()
{
    HRESULT         hr = S_OK;
	BSTR            bstrViewName = NULL;
    VARIANT_BOOL    bValue = VARIANT_FALSE;
    BSTR            bstrButtonText = NULL;
    BSTR            bstrURL = NULL;
    TCHAR          *pszURL = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "CanApply: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "CanApply: m_piTaskpad is NULL");

	// Name must not be empty
    hr = GetDlgText(IDC_EDIT_TP_NAME, &bstrViewName);
    IfFailGo(hr);

	if (NULL == bstrViewName || 0 == ::SysStringLen(bstrViewName))
	{
        HandleError(_T("Apply Taskpad"), _T("Taskpad must have a name"));
        hr = E_INVALIDARG;
        goto Error;
	}

    // Check type consistency
    hr = GetCheckbox(IDC_RADIO_TP_LISTPAD, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = GetCheckbox(IDC_CHECK_TP_USE_BUTTON, &bValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == bValue)
        {
            hr = GetDlgText(IDC_EDIT_TP_LP_BUTTON_TEXT, &bstrButtonText);
            IfFailGo(hr);

	        if (NULL == bstrButtonText || 0 == ::SysStringLen(bstrButtonText))
	        {
                HandleError(_T("Apply Taskpad"), _T("Button text cannot be empty"));
                hr = E_INVALIDARG;
                goto Error;
            }
        }
    }

    hr = GetCheckbox(IDC_RADIO_TP_CUSTOM, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = GetDlgText(IDC_EDIT_TP_URL, &bstrURL);
        IfFailGo(hr);

	    if (NULL == bstrURL || 0 == ::SysStringLen(bstrURL))
	    {
            HandleError(_T("Apply Taskpad"), _T("URL cannot be empty"));
            hr = E_INVALIDARG;
            goto Error;
        }

        hr = ANSIFromBSTR(bstrURL, &pszURL);
        IfFailGo(hr);

        if (false == IsValidURL(pszURL))
        {
            HandleError(_T("Apply Taskpad"), _T("URL must have \'res://\' format"));
            hr = E_INVALIDARG;
            goto Error;
        }
    }

Error:
    if (NULL != pszURL)
        CtlFree(pszURL);
    FREESTRING(bstrURL);
    FREESTRING(bstrButtonText);
	FREESTRING(bstrViewName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyName()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyName()
{
    HRESULT  hr = S_OK;
    BSTR     bstrViewName = NULL;
    BSTR     bstrSavedViewName = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyName: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyName: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_NAME, &bstrViewName);
    IfFailGo(hr);

    hr = m_piTaskpad->get_Name(&bstrSavedViewName);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrViewName, bstrSavedViewName))
    {
        hr = m_piTaskpadViewDef->put_Key(bstrViewName);
        IfFailGo(hr);

        hr = m_piTaskpadViewDef->put_Name(bstrViewName);
        IfFailGo(hr);

        hr = m_piTaskpad->put_Name(bstrViewName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedViewName);
    FREESTRING(bstrViewName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyTitle()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyTitle()
{
    HRESULT  hr = S_OK;
    BSTR     bstrTitle = NULL;
    BSTR     bstrSavedTitle = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyTitle: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyTitle: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_TITLE, &bstrTitle);
    IfFailGo(hr);

    hr = m_piTaskpad->get_Title(&bstrSavedTitle);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrTitle, bstrSavedTitle))
    {
        hr = m_piTaskpad->put_Title(bstrTitle);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedTitle);
    FREESTRING(bstrTitle);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyDescription()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyDescription()
{
    HRESULT  hr = S_OK;
    BSTR     bstrDescription = NULL;
    BSTR     bstrSavedDescription = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyDescription: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyDescription: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_DESCRIPTIVE_TEXT, &bstrDescription);
    IfFailGo(hr);

    hr = m_piTaskpad->get_DescriptiveText(&bstrSavedDescription);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrDescription, bstrSavedDescription))
    {
        hr = m_piTaskpad->put_DescriptiveText(bstrDescription);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedDescription);
    FREESTRING(bstrDescription);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyType()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyType()
{
    HRESULT  hr = S_OK;
    VARIANT_BOOL    bValue = VARIANT_FALSE;
    SnapInTaskpadTypeConstants  sittc = Default;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyType: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyType: m_piTaskpad is NULL");

    hr = GetCheckbox(IDC_RADIO_TP_DEFAULT, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = m_piTaskpad->put_Type(Default);
        IfFailGo(hr);

        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_TP_LISTPAD, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = m_piTaskpad->put_Type(Listpad);
        IfFailGo(hr);

        hr = ApplyListpad();
        IfFailGo(hr);
        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_TP_CUSTOM, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = m_piTaskpad->put_Type(Custom);
        IfFailGo(hr);

        hr = ApplyCustom();
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyListpad()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyListpad()
{
    HRESULT         hr = S_OK;
    BSTR            bstrListpadTitle = NULL;
    BSTR            bstrSavedListpadTitle = NULL;
    VARIANT_BOOL    bValue = VARIANT_FALSE;
    VARIANT_BOOL    bSavedValue = VARIANT_FALSE;
    BSTR            bstrButtonText = NULL;
    BSTR            bstrSavedButtonText = NULL;
    BSTR            bstrSavedListView = NULL;
    BSTR            bstrListView = NULL;
    long            iSelectedListView = 0;
    BOOL            fUpdateListView = FALSE;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyListpad: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyListpad: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_LP_TITLE, &bstrListpadTitle);
    IfFailGo(hr);

    hr = m_piTaskpad->get_ListpadTitle(&bstrSavedListpadTitle);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrListpadTitle, bstrSavedListpadTitle))
    {
        hr = m_piTaskpad->put_ListpadTitle(bstrListpadTitle);
        IfFailGo(hr);
    }

    hr = GetCheckbox(IDC_CHECK_TP_USE_BUTTON, &bValue);
    IfFailGo(hr);

    hr = m_piTaskpad->get_ListpadHasButton(&bSavedValue);
    IfFailGo(hr);

    if (bValue != bSavedValue)
    {
        hr = m_piTaskpad->put_ListpadHasButton(bValue);
        IfFailGo(hr);
    }

    hr = GetDlgText(IDC_EDIT_TP_LP_BUTTON_TEXT, &bstrButtonText);
    IfFailGo(hr);

    hr = m_piTaskpad->get_ListpadButtonText(&bstrSavedButtonText);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrButtonText, bstrSavedButtonText))
    {
        hr = m_piTaskpad->put_ListpadButtonText(bstrButtonText);
        IfFailGo(hr);
    }

    // Get the current value of Taskpad.ListView

    IfFailGo(m_piTaskpad->get_ListView(&bstrSavedListView));

    // Check if something is selected in the combobox
    
    iSelectedListView = ::SendDlgItemMessage(m_hwnd,
                                             IDC_COMBO_TP_LISTVIEW,
                                             CB_GETCURSEL, 0, 0);
    if (CB_ERR != iSelectedListView)
    {
        // Something is selected. Get its text.
        
        IfFailGo(GetDlgText(IDC_COMBO_TP_LISTVIEW, &bstrListView));
    }

    // If the selection changed then update Taskpad.ListView
    // If nothing is selected then bstrListView will be NULL and the property
    // will be set to NULL.

    // If there is a current Taskpad.ListView and the user selected something
    // then compare them. If different then update Taskpad.ListView.

    if ( (NULL != bstrListView) && (NULL != bstrSavedListView) )
    {
        if (0 != ::wcscmp(bstrListView, bstrSavedListView))
        {
            fUpdateListView = TRUE;
        }
    }
    else if ( (NULL == bstrListView) && (NULL != bstrSavedListView) )
    {
        // The user did not select anything but there is a current
        // Taskpad.ListView. Need to set Taskpad.ListView to NULL.

        fUpdateListView = TRUE;
    }
    else if (NULL != bstrListView)
    {
        // The is no current Taskpad.ListView and the user has now selected one.

        fUpdateListView = TRUE;
    }

    if (fUpdateListView)
    {
        IfFailGo(m_piTaskpad->put_ListView(bstrListView));
    }

Error:
    FREESTRING(bstrSavedListView);
    FREESTRING(bstrListView);
    FREESTRING(bstrSavedButtonText);
    FREESTRING(bstrButtonText);
    FREESTRING(bstrSavedListpadTitle);
    FREESTRING(bstrListpadTitle);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyCustom()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyCustom()
{
    HRESULT         hr = S_OK;
    BSTR            bstrURL = NULL;
    BSTR            bstrSavedURL = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyCustom: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyCustom: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_URL, &bstrURL);
    IfFailGo(hr);

    hr = m_piTaskpad->get_URL(&bstrSavedURL);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrURL, bstrSavedURL))
    {
        hr = m_piTaskpad->put_URL(bstrURL);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedURL);
    FREESTRING(bstrURL);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyViewMenu()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyViewMenu()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bValue = VARIANT_FALSE;
    VARIANT_BOOL    bSavedValue = VARIANT_FALSE;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyViewMenu: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyViewMenu: m_piTaskpad is NULL");

    hr = GetCheckbox(IDC_CHECK_TP_USER_PREFERRED, &bValue);
    IfFailGo(hr);

    hr = m_piTaskpadViewDef->get_UseWhenTaskpadViewPreferred(&bSavedValue);
    IfFailGo(hr);

    if (bValue != bSavedValue)
    {
        hr = m_piTaskpadViewDef->put_UseWhenTaskpadViewPreferred(bValue);
        IfFailGo(hr);
    }

    hr = GetCheckbox(IDC_CHECK_TP_ADD_TO_VIEW, &bValue);
    IfFailGo(hr);

    hr = m_piTaskpadViewDef->get_AddToViewMenu(&bSavedValue);
    IfFailGo(hr);

    if (bValue != bSavedValue)
    {
        hr = m_piTaskpadViewDef->put_AddToViewMenu(bValue);
        IfFailGo(hr);
    }

    hr = ApplyViewMenuText();
    IfFailGo(hr);

    hr = ApplyStatusBarText();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyViewMenuText()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyViewMenuText()
{
    HRESULT         hr = S_OK;
    BSTR            bstrViewMenuText = NULL;
    BSTR            bstrSavedViewMenuText = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyListpad: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyListpad: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_VIEW_MENUTXT, &bstrViewMenuText);
    IfFailGo(hr);

    hr = m_piTaskpadViewDef->get_ViewMenuText(&bstrSavedViewMenuText);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrViewMenuText, bstrSavedViewMenuText))
    {
        hr = m_piTaskpadViewDef->put_ViewMenuText(bstrViewMenuText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedViewMenuText);
    FREESTRING(bstrViewMenuText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyStatusBarText()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyStatusBarText()
{
    HRESULT         hr = S_OK;
    BSTR            bstrStatusBarText = NULL;
    BSTR            bstrSavedStatusBarText = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyStatusBarText: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyStatusBarText: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_STATUSBARTEXT, &bstrStatusBarText);
    IfFailGo(hr);

    hr = m_piTaskpadViewDef->get_ViewMenuStatusBarText(&bstrSavedStatusBarText);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrStatusBarText, bstrSavedStatusBarText))
    {
        hr = m_piTaskpadViewDef->put_ViewMenuStatusBarText(bstrStatusBarText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedStatusBarText);
    FREESTRING(bstrStatusBarText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_RADIO_TP_DEFAULT:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TITLE), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_DESCRIPTIVE_TEXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);

        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_LP_TITLE, EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_LP_TITLE, (BSTR)NULL));

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TP_USE_BUTTON), FALSE);
        IfFailGo(SetCheckbox(IDC_CHECK_TP_USE_BUTTON, VARIANT_FALSE));

        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_LP_BUTTON_TEXT, EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_LP_BUTTON_TEXT, (BSTR)NULL));

        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_URL, EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_URL, (BSTR)NULL));

        ::SendDlgItemMessage(m_hwnd, IDC_COMBO_TP_LISTVIEW, CB_RESETCONTENT, 0, 0);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_TP_LISTVIEW), FALSE);
        break;

    case IDC_RADIO_TP_LISTPAD:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TITLE), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_DESCRIPTIVE_TEXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);

        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_LP_TITLE, EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TP_USE_BUTTON), TRUE);

        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_URL, EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_URL, (BSTR)NULL));
        
        IfFailGo(PopulateListViewCombo());
        hr = OnUseButton();
        IfFailGo(hr);
        break;

    case IDC_RADIO_TP_CUSTOM:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TITLE), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_TITLE, (BSTR)NULL));

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_DESCRIPTIVE_TEXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_DESCRIPTIVE_TEXT, (BSTR)NULL));

        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_LP_TITLE, EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_LP_TITLE, (BSTR)NULL));

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TP_USE_BUTTON), FALSE);
        IfFailGo(SetCheckbox(IDC_CHECK_TP_USE_BUTTON, VARIANT_FALSE));
        
        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_LP_BUTTON_TEXT, EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_LP_BUTTON_TEXT, (BSTR)NULL));

        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_URL, EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_URL, (BSTR)NULL));

        ::SendDlgItemMessage(m_hwnd, IDC_COMBO_TP_LISTVIEW, CB_RESETCONTENT, 0, 0);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_TP_LISTVIEW), FALSE);
        break;

    case IDC_CHECK_TP_USE_BUTTON:
        hr = OnUseButton();
        IfFailGo(hr);
        break;

    case IDC_CHECK_TP_ADD_TO_VIEW:
        hr = OnAddToView();
        IfFailGo(hr);
        break;
    }

    MakeDirty();

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::OnUseButton()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::OnUseButton()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bSet = VARIANT_FALSE;

    hr = GetCheckbox(IDC_CHECK_TP_USE_BUTTON, &bSet);
    IfFailGo(hr);

    if (VARIANT_TRUE == bSet)
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_LP_BUTTON_TEXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
    else
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_LP_BUTTON_TEXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::OnAddToView(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::OnAddToView()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bSet = VARIANT_FALSE;

    hr = GetCheckbox(IDC_CHECK_TP_ADD_TO_VIEW, &bSet);
    IfFailGo(hr);

    if (VARIANT_TRUE == bSet)
    {
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_VIEW_MENUTXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_STATUSBARTEXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
    }
    else
    {
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_VIEW_MENUTXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_STATUSBARTEXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    }

Error:
    RRETURN(hr);
}




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Taskpad View Background Property Page
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CTaskpadViewBackgroundPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CTaskpadViewBackgroundPage::Create(IUnknown *pUnkOuter)
{
	CTaskpadViewBackgroundPage *pNew = New CTaskpadViewBackgroundPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::CTaskpadViewBackgroundPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CTaskpadViewBackgroundPage::CTaskpadViewBackgroundPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGTASKBACKGR), m_piTaskpadViewDef(0), m_piTaskpad(0)
{
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::~CTaskpadViewBackgroundPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CTaskpadViewBackgroundPage::~CTaskpadViewBackgroundPage()
{
    RELEASE(m_piTaskpad);
    RELEASE(m_piTaskpadViewDef);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::OnInitializeDialog()
{
    HRESULT     hr = S_OK;

    hr = RegisterTooltip(IDC_RADIO_TP_NONE, IDS_TT_TP_BK_NONE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_BITMAP, IDS_TT_TP_BK_BITMAP);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_MOUSE_OVER, IDS_TT_TP_BK_MOUSE_OVR);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_VANILLA, IDS_TT_TP_BK_VANILLA);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_CHOCOLATE, IDS_TT_TP_BK_CHOCOL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_SYMBOL, IDS_TT_TP_BK_SYMBOL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_FONT_FAMILY, IDS_TT_TP_BK_FFNAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_EOT, IDS_TT_TP_BK_EOT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_SYMBOL_STRING, IDS_TT_TP_BK_SYM_STR);
    IfFailGo(hr);

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::OnNewObjects()
{
    HRESULT                         hr = S_OK;
    IUnknown                       *pUnk = NULL;
    DWORD                           dwDummy = 0;
    SnapInTaskpadImageTypeConstants sititc = siNoImage;
    BSTR                            bstrMouseOverImage = NULL;
    BSTR                            bstrFontFamily = NULL;
    BSTR                            bstrEOTFile = NULL;
    BSTR                            bstrSymbolString = NULL;

    if (m_piTaskpadViewDef != NULL)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_ITaskpadViewDef, reinterpret_cast<void **>(&m_piTaskpadViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piTaskpadViewDef->get_Taskpad(&m_piTaskpad);
    IfFailGo(hr);

    hr = m_piTaskpad->get_BackgroundType(&sititc);
    IfFailGo(hr);

    switch (sititc)
    {
    case siNoImage:
        hr = SetCheckbox(IDC_RADIO_TP_NONE, VARIANT_TRUE);
        IfFailGo(hr);
        break;

    case siSymbol:
        hr = SetCheckbox(IDC_RADIO_TP_SYMBOL, VARIANT_TRUE);
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_EOT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);

        hr = m_piTaskpad->get_FontFamily(&bstrFontFamily);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_FONT_FAMILY, bstrFontFamily);
        IfFailGo(hr);

        hr = m_piTaskpad->get_EOTFile(&bstrEOTFile);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_EOT, bstrEOTFile);
        IfFailGo(hr);

        hr = m_piTaskpad->get_SymbolString(&bstrSymbolString);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_SYMBOL_STRING, bstrSymbolString);
        IfFailGo(hr);
        break;

    case siVanillaGIF:
        hr = SetCheckbox(IDC_RADIO_TP_VANILLA, VARIANT_TRUE);
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        hr = m_piTaskpad->get_MouseOverImage(&bstrMouseOverImage);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_MOUSE_OVER, bstrMouseOverImage);
        IfFailGo(hr);
        break;

    case siChocolateGIF:
        hr = SetCheckbox(IDC_RADIO_TP_CHOCOLATE, VARIANT_TRUE);
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        hr = m_piTaskpad->get_MouseOverImage(&bstrMouseOverImage);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_MOUSE_OVER, bstrMouseOverImage);
        IfFailGo(hr);
        break;

    case siBitmap:
        hr = SetCheckbox(IDC_RADIO_TP_BITMAP, VARIANT_TRUE);
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        hr = m_piTaskpad->get_MouseOverImage(&bstrMouseOverImage);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_MOUSE_OVER, bstrMouseOverImage);
        IfFailGo(hr);
        break;
    }

    m_bInitialized = true;

Error:
    FREESTRING(bstrSymbolString);
    FREESTRING(bstrEOTFile);
    FREESTRING(bstrFontFamily);
    FREESTRING(bstrMouseOverImage);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::OnApply()
{
    HRESULT             hr = S_OK;
    VARIANT_BOOL        bValue = VARIANT_FALSE;

    ASSERT(NULL != m_piTaskpadViewDef, "OnApply: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "OnApply: m_piTaskpad is NULL");

    hr = CanApply();
    IfFailGo(hr);

    if (S_OK == hr)
    {
        hr = GetCheckbox(IDC_RADIO_TP_NONE, &bValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == bValue)
        {
            hr = m_piTaskpad->put_BackgroundType(siNoImage);
            IfFailGo(hr);

            goto Error;
        }

        hr = GetCheckbox(IDC_RADIO_TP_BITMAP, &bValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == bValue)
        {
            hr = m_piTaskpad->put_BackgroundType(siBitmap);
            IfFailGo(hr);

            hr = ApplyMouseOverImage();
            IfFailGo(hr);
            goto Error;
        }

        hr = GetCheckbox(IDC_RADIO_TP_VANILLA, &bValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == bValue)
        {
            hr = m_piTaskpad->put_BackgroundType(siVanillaGIF);
            IfFailGo(hr);

            hr = ApplyMouseOverImage();
            IfFailGo(hr);
            goto Error;
        }

        hr = GetCheckbox(IDC_RADIO_TP_CHOCOLATE, &bValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == bValue)
        {
            hr = m_piTaskpad->put_BackgroundType(siChocolateGIF);
            IfFailGo(hr);

            hr = ApplyMouseOverImage();
            IfFailGo(hr);
            goto Error;
        }

        hr = GetCheckbox(IDC_RADIO_TP_SYMBOL, &bValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == bValue)
        {
            hr = m_piTaskpad->put_BackgroundType(siSymbol);
            IfFailGo(hr);

            hr = ApplyFontFamily();
            IfFailGo(hr);

            hr = ApplyEOTFile();
            IfFailGo(hr);

            hr = ApplySymbolString();
            IfFailGo(hr);
            goto Error;
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::CanApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::CanApply()
{
    HRESULT             hr = S_OK;
    VARIANT_BOOL        bBitmap = VARIANT_FALSE;
    VARIANT_BOOL        bVanilla = VARIANT_FALSE;
    VARIANT_BOOL        bChocolate = VARIANT_FALSE;
    BSTR                bstrMouseOverImage = NULL;
    TCHAR              *pszMouseOver = NULL;
    VARIANT_BOOL        bSymbol = VARIANT_FALSE;
    BSTR                bstrFontFamily = NULL;
    BSTR                bstrEOTFile = NULL;
    TCHAR              *pszEOTFile = NULL;
    BSTR                bstrSymbolString = NULL;

    // Check type consistency
    hr = GetCheckbox(IDC_RADIO_TP_BITMAP, &bBitmap);
    IfFailGo(hr);

    hr = GetCheckbox(IDC_RADIO_TP_VANILLA, &bVanilla);
    IfFailGo(hr);

    hr = GetCheckbox(IDC_RADIO_TP_CHOCOLATE, &bChocolate);
    IfFailGo(hr);

    if (VARIANT_TRUE == bBitmap || VARIANT_TRUE == bVanilla || VARIANT_TRUE == bChocolate)
    {
        hr = GetDlgText(IDC_EDIT_TP_MOUSE_OVER, &bstrMouseOverImage);
        IfFailGo(hr);

	    if (NULL == bstrMouseOverImage || 0 == ::SysStringLen(bstrMouseOverImage))
	    {
            HandleError(_T("Apply Taskpad"), _T("Mouse over image cannot be empty"));
            hr = E_INVALIDARG;
            goto Error;
	    }

        hr = ANSIFromBSTR(bstrMouseOverImage, &pszMouseOver);
        IfFailGo(hr);

        if (false == IsValidURL(pszMouseOver))
        {
            HandleError(_T("Apply Taskpad"), _T("Mouse over image must have \'res://\' format"));
            hr = E_INVALIDARG;
            goto Error;
        }
    }

    // Check if symbol
    hr = GetCheckbox(IDC_RADIO_TP_SYMBOL, &bSymbol);
    IfFailGo(hr);

    if (VARIANT_TRUE == bSymbol)
    {
        hr = GetDlgText(IDC_EDIT_TP_FONT_FAMILY, &bstrFontFamily);
        IfFailGo(hr);

	    if (NULL == bstrFontFamily || 0 == ::SysStringLen(bstrFontFamily))
	    {
            HandleError(_T("Apply Taskpad"), _T("Font family cannot be empty"));
            hr = E_INVALIDARG;
            goto Error;
	    }

        hr = GetDlgText(IDC_EDIT_TP_EOT, &bstrEOTFile);
        IfFailGo(hr);

	    if (NULL == bstrEOTFile || 0 == ::SysStringLen(bstrEOTFile))
	    {
            HandleError(_T("Apply Taskpad"), _T("EOT file cannot be empty"));
            hr = E_INVALIDARG;
            goto Error;
	    }

        hr = ANSIFromBSTR(bstrEOTFile, &pszEOTFile);
        IfFailGo(hr);

        if (false == IsValidURL(pszEOTFile))
        {
            HandleError(_T("Apply Taskpad"), _T("EOT file must have \'res://\' format"));
            hr = E_INVALIDARG;
            goto Error;
        }

        hr = GetDlgText(IDC_EDIT_TP_SYMBOL_STRING, &bstrSymbolString);
        IfFailGo(hr);

	    if (NULL == bstrSymbolString || 0 == ::SysStringLen(bstrSymbolString))
	    {
            HandleError(_T("Apply Taskpad"), _T("Symbol string cannot be empty"));
            hr = E_INVALIDARG;
            goto Error;
	    }
    }

Error:
    FREESTRING(bstrSymbolString);
    if (NULL != pszEOTFile)
        CtlFree(pszEOTFile);
    FREESTRING(bstrEOTFile);
    FREESTRING(bstrFontFamily);
    if (NULL != pszMouseOver)
        CtlFree(pszMouseOver);
    FREESTRING(bstrMouseOverImage);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::ApplyMouseOverImage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::ApplyMouseOverImage()
{
    HRESULT     hr = S_OK;
    BSTR        bstrMouseOverImage = NULL;
    BSTR        bstrSavedMouseOverImage = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyMouseOverImage: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyMouseOverImage: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_MOUSE_OVER, &bstrMouseOverImage);
    IfFailGo(hr);

    hr = m_piTaskpad->get_MouseOverImage(&bstrSavedMouseOverImage);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrMouseOverImage, bstrSavedMouseOverImage))
    {
        hr = m_piTaskpad->put_MouseOverImage(bstrMouseOverImage);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedMouseOverImage);
    FREESTRING(bstrMouseOverImage);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::ApplyFontFamily()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::ApplyFontFamily()
{
    HRESULT     hr = S_OK;
    BSTR        bstrFontFamily = NULL;
    BSTR        bstrSavedFontFamily = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyFontFamily: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyFontFamily: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_FONT_FAMILY, &bstrFontFamily);
    IfFailGo(hr);

    hr = m_piTaskpad->get_FontFamily(&bstrSavedFontFamily);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrFontFamily, bstrSavedFontFamily))
    {
        hr = m_piTaskpad->put_FontFamily(bstrFontFamily);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedFontFamily);
    FREESTRING(bstrFontFamily);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::ApplyEOTFile()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::ApplyEOTFile()
{
    HRESULT     hr = S_OK;
    BSTR        bstrEOTFile = NULL;
    BSTR        bstrSavedEOTFile = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyEOTFile: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyEOTFile: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_EOT, &bstrEOTFile);
    IfFailGo(hr);

    hr = m_piTaskpad->get_EOTFile(&bstrSavedEOTFile);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrEOTFile, bstrSavedEOTFile))
    {
        hr = m_piTaskpad->put_EOTFile(bstrEOTFile);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedEOTFile);
    FREESTRING(bstrEOTFile);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::ApplySymbolString()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::ApplySymbolString()
{
    HRESULT     hr = S_OK;
    BSTR        bstrSymbolString = NULL;
    BSTR        bstrSavedSymbolString = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplySymbolString: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplySymbolString: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_SYMBOL_STRING, &bstrSymbolString);
    IfFailGo(hr);

    hr = m_piTaskpad->get_SymbolString(&bstrSavedSymbolString);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrSymbolString, bstrSavedSymbolString))
    {
        hr = m_piTaskpad->put_SymbolString(bstrSymbolString);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedSymbolString);
    FREESTRING(bstrSymbolString);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_RADIO_TP_NONE:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        break;

    case IDC_RADIO_TP_BITMAP:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        break;

    case IDC_RADIO_TP_VANILLA:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        break;

    case IDC_RADIO_TP_CHOCOLATE:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        break;

    case IDC_RADIO_TP_SYMBOL:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_EOT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        break;
    }

    MakeDirty();

//Error:
    RRETURN(hr);
}




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Taskpad View Tasks Property Page
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CTaskpadViewTasksPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CTaskpadViewTasksPage::Create(IUnknown *pUnkOuter)
{
	CTaskpadViewTasksPage *pNew = New CTaskpadViewTasksPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::CTaskpadViewTasksPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CTaskpadViewTasksPage::CTaskpadViewTasksPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGTASKTASKS), m_piTaskpadViewDef(0), m_piTaskpad(0), m_lCurrentTask(0), m_bSavedLastTask(true)
{
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::~CTaskpadViewTasksPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CTaskpadViewTasksPage::~CTaskpadViewTasksPage()
{
    RELEASE(m_piTaskpad);
    RELEASE(m_piTaskpadViewDef);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::OnInitializeDialog()
{
    HRESULT     hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_TP_TASK_INDEX, IDS_TT_TP_TSK_INDEX);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_TASK_KEY, IDS_TT_TP_TSK_KEY);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_TASK_TEXT, IDS_TT_TP_TSK_TEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_TASK_HELP_STRING, IDS_TT_TP_TSK_HELP);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_TASK_NOTIFY, IDS_TT_TP_TSK_NOTIFY);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_TASK_URL, IDS_TT_TP_TSK_URL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_TASK_SCRIPT, IDS_TT_TP_TSK_SCRIPT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_TASK_URL, IDS_TT_TP_TSK_U_URL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_TASK_SCRIPT, IDS_TT_TP_TSK_S_SCRIPT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TPT_VANILLA, IDS_TT_TP_TSK_VANILLA);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TPT_CHOCOLATE, IDS_TT_TP_TSK_CHOCOL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TPT_BITMAP, IDS_TT_TP_TSK_BITMAP);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TPT_SYMBOL, IDS_TT_TP_TSK_SYMBOL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TPT_MOUSE_OVER, IDS_TT_TP_TSK_MOUSE_OVR);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TPT_MOUSE_OFF, IDS_TT_TP_TSK_MOUSE_OFF);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TPT_FONT_FAMILY, IDS_TT_TP_TSK_FFNAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TPT_EOT, IDS_TT_TP_TSK_EOT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TPT_SYMBOL_STRING, IDS_TT_TP_TSK_SYM_STR);
    IfFailGo(hr);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_TP_REMOVE_TASK), FALSE);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    ITasks         *piTasks = NULL;
    long            lCount = 0;
    VARIANT         vtVariant;
    ITask          *piTask = NULL;

    ::VariantInit(&vtVariant);

    if (m_piTaskpadViewDef != NULL)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_ITaskpadViewDef, reinterpret_cast<void **>(&m_piTaskpadViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piTaskpadViewDef->get_Taskpad(&m_piTaskpad);
    IfFailGo(hr);

    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

    hr = piTasks->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        m_lCurrentTask = 1;
        vtVariant.vt = VT_I4;
        vtVariant.lVal = m_lCurrentTask;

        hr = piTasks->get_Item(vtVariant, reinterpret_cast<Task **>(&piTask));
        IfFailGo(hr);

        hr = ShowTask(piTask);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_TASK_INDEX, m_lCurrentTask);
        IfFailGo(hr);

        hr = EnableEdits(true);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_TP_REMOVE_TASK), TRUE);
    }
    else
    {
        hr = SetDlgText(IDC_EDIT_TP_TASK_INDEX, m_lCurrentTask);
        IfFailGo(hr);

        hr = EnableEdits(false);
        IfFailGo(hr);
    }

    m_bInitialized = true;

Error:
    RELEASE(piTask);
    ::VariantClear(&vtVariant);
    RELEASE(piTasks);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::OnApply()
{
    HRESULT      hr = S_OK;
    int          disposition = 0;
    ITasks      *piTasks = NULL;
    long         lCount = 0;
    ITask       *piTask = NULL;

    ASSERT(m_piTaskpadViewDef != NULL, "OnApply: m_piTaskpadViewDef is NULL");
    ASSERT(m_piTaskpad != NULL, "OnApply: m_piTaskpad is NULL");

    if (0 == m_lCurrentTask)
        goto Error;

    if (false == m_bSavedLastTask)
    {
        hr = CanCreateNewTask();
        IfFailGo(hr);

        if (S_FALSE == hr)
        {
            hr = HandleCantCommit(_T("Can\'t create new Task"), _T("Would you like to discard your changes?"), &disposition);
            if (kSICancelOperation == disposition)
            {
                hr = E_INVALIDARG;
                goto Error;
            }
            else
            {
                // Discard changes
                hr = ExitDoingNewTaskState(NULL);
                IfFailGo(hr);

                hr = S_OK;
                goto Error;
            }
        }

        hr = CreateNewTask(&piTask);
        IfFailGo(hr);

        hr = ExitDoingNewTaskState(piTask);
        IfFailGo(hr);
    }
    else
    {
        hr = GetCurrentTask(&piTask);
        IfFailGo(hr);
    }

    hr = ApplyCurrentTask();
    IfFailGo(hr);

    // Adjust the remove button as necessary
    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

    hr = piTasks->get_Count(&lCount);
    IfFailGo(hr);

    if (0 == lCount)
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), FALSE);
    else
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), TRUE);

    m_bSavedLastTask = true;

Error:
    RELEASE(piTask);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyCurrentTask()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyCurrentTask()
{
    HRESULT                         hr = S_OK;
    ITasks                         *piTasks = NULL;
    VARIANT                         vtIndex;
    ITask                          *piTask = NULL;
    SnapInActionTypeConstants       sictc = siNotify;
    SnapInTaskpadImageTypeConstants sititc = siNoImage;

    ASSERT(m_piTaskpadViewDef != NULL, "ApplyCurrentTask: m_piTaskpadViewDef is NULL");
    ASSERT(m_piTaskpad != NULL, "ApplyCurrentTask: m_piTaskpad is NULL");

    ::VariantInit(&vtIndex);

    hr = CanApply();
    IfFailGo(hr);

    if (S_FALSE == hr) {
        hr = E_INVALIDARG;
        goto Error;
    }

    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentTask;
    hr = piTasks->get_Item(vtIndex, reinterpret_cast<Task **>(&piTask));
    IfFailGo(hr);

    hr = ApplyKey(piTask);
    IfFailGo(hr);

    hr = ApplyText(piTask);
    IfFailGo(hr);

    hr = ApplyHelpString(piTask);
    IfFailGo(hr);

	hr = ApplyTag(piTask);
	IfFailGo(hr);

    hr = ApplyActionType(piTask);
    IfFailGo(hr);

    hr = piTask->get_ActionType(&sictc);
    IfFailGo(hr);

    switch (sictc)
    {
    case siNotify:
        hr = piTask->put_URL(NULL);
        IfFailGo(hr);

        hr = piTask->put_Script(NULL);
        IfFailGo(hr);
        break;

    case siURL:
        hr = ApplyURL(piTask);
        IfFailGo(hr);

        hr = piTask->put_Script(NULL);
        IfFailGo(hr);
        break;

    case siScript:
        hr = ApplyScript(piTask);
        IfFailGo(hr);

        hr = piTask->put_URL(NULL);
        IfFailGo(hr);
        break;
    }

    hr = ApplyImageType(piTask);
    IfFailGo(hr);

    hr = piTask->get_ImageType(&sititc);
    IfFailGo(hr);

    switch (sititc)
    {
    case siSymbol:
        hr = ApplyFontFamilyName(piTask);
        IfFailGo(hr);

        hr = ApplyEOTFile(piTask);
        IfFailGo(hr);

        hr = ApplySymbolString(piTask);
        IfFailGo(hr);

        hr = piTask->put_MouseOverImage(NULL);
        hr = piTask->put_MouseOffImage(NULL);
        break;

    case siVanillaGIF:
    case siChocolateGIF:
    case siBitmap:
        hr = ApplyMouseOverImage(piTask);
        IfFailGo(hr);

        hr = ApplyMouseOffImage(piTask);
        IfFailGo(hr);

        hr = piTask->put_FontFamily(NULL);
        hr = piTask->put_EOTFile(NULL);
        hr = piTask->put_SymbolString(NULL);
        break;
    }


Error:
    RELEASE(piTask);
    ::VariantClear(&vtIndex);
    RELEASE(piTasks);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyKey(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyKey(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrKey = NULL;
    BSTR         bstrSavedKey = NULL;

    ASSERT(piTask != NULL, "ApplyKey: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TP_TASK_KEY, &bstrKey);
    IfFailGo(hr);

    if (NULL == bstrKey || 0 == ::SysStringLen(bstrKey))
    {
        hr = piTask->put_Key(NULL);
        IfFailGo(hr);
    }
    else
    {
        hr = piTask->get_Key(&bstrSavedKey);
        IfFailGo(hr);

        if (NULL == bstrSavedKey || 0 != ::wcscmp(bstrSavedKey, bstrKey))
        {
            hr = piTask->put_Key(bstrKey);
            IfFailGo(hr);
        }
    }

Error:
    FREESTRING(bstrSavedKey);
    FREESTRING(bstrKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyText(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyText(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrText = NULL;
    BSTR         bstrSavedText = NULL;

    ASSERT(piTask != NULL, "ApplyText: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TP_TASK_TEXT, &bstrText);
    IfFailGo(hr);

    hr = piTask->get_Text(&bstrSavedText);
    IfFailGo(hr);

    if (NULL == bstrSavedText || 0 != ::wcscmp(bstrSavedText, bstrText))
    {
        hr = piTask->put_Text(bstrText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedText);
    FREESTRING(bstrText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyHelpString(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyHelpString(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrHelpString = NULL;
    BSTR         bstrSavedHelpString = NULL;

    ASSERT(piTask != NULL, "ApplyHelpString: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TP_TASK_HELP_STRING, &bstrHelpString);
    IfFailGo(hr);

    hr = piTask->get_HelpString(&bstrSavedHelpString);
    IfFailGo(hr);

    if (NULL == bstrSavedHelpString || 0 != ::wcscmp(bstrSavedHelpString, bstrHelpString))
    {
        hr = piTask->put_HelpString(bstrHelpString);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedHelpString);
    FREESTRING(bstrHelpString);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyTag(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyTag(ITask *piTask)
{
    HRESULT      hr = S_OK;
    VARIANT      vtTag;

    ASSERT(piTask != NULL, "ApplyTag: piTask is NULL");

	::VariantInit(&vtTag);

    hr = GetDlgVariant(IDC_EDIT_TP_TASK_TAG, &vtTag);
    IfFailGo(hr);

	if (VT_EMPTY != vtTag.vt)
	{
		hr = piTask->put_Tag(vtTag);
		IfFailGo(hr);
	}

Error:
	::VariantClear(&vtTag);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyActionType(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyActionType(ITask *piTask)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bVal = VARIANT_FALSE;

    ASSERT(piTask != NULL, "ApplyActionType: piTask is NULL");

    hr = GetCheckbox(IDC_RADIO_TP_TASK_NOTIFY, &bVal);
    IfFailGo(hr);

    if (VARIANT_TRUE == bVal)
    {
        hr = piTask->put_ActionType(siNotify);
        IfFailGo(hr);

        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_TP_TASK_URL, &bVal);
    IfFailGo(hr);

    if (VARIANT_TRUE == bVal)
    {
        hr = piTask->put_ActionType(siURL);
        IfFailGo(hr);

        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_TP_TASK_SCRIPT, &bVal);
    IfFailGo(hr);

    if (VARIANT_TRUE == bVal)
    {
        hr = piTask->put_ActionType(siScript);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyURL(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyURL(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrURL = NULL;
    BSTR         bstrSavedURL = NULL;

    ASSERT(piTask != NULL, "ApplyURL: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TP_TASK_URL, &bstrURL);
    IfFailGo(hr);

    hr = piTask->get_URL(&bstrSavedURL);
    IfFailGo(hr);

    if (NULL == bstrSavedURL || 0 != ::wcscmp(bstrURL, bstrSavedURL))
    {
        hr = piTask->put_URL(bstrURL);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedURL);
    FREESTRING(bstrURL);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyScript(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyScript(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrScript = NULL;
    BSTR         bstrSavedScript = NULL;

    ASSERT(piTask != NULL, "ApplyScript: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TP_TASK_SCRIPT, &bstrScript);
    IfFailGo(hr);

    hr = piTask->get_Script(&bstrSavedScript);
    IfFailGo(hr);

    if (NULL == bstrSavedScript || 0 != ::wcscmp(bstrScript, bstrSavedScript))
    {
        hr = piTask->put_Script(bstrScript);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedScript);
    FREESTRING(bstrScript);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyImageType(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyImageType(ITask *piTask)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bVal = VARIANT_FALSE;

    ASSERT(piTask != NULL, "ApplyImageType: piTask is NULL");

    hr = GetCheckbox(IDC_RADIO_TPT_VANILLA, &bVal);
    IfFailGo(hr);

    if (VARIANT_TRUE == bVal)
    {
        hr = piTask->put_ImageType(siVanillaGIF);
        IfFailGo(hr);

        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_TPT_CHOCOLATE, &bVal);
    IfFailGo(hr);

    if (VARIANT_TRUE == bVal)
    {
        hr = piTask->put_ImageType(siChocolateGIF);
        IfFailGo(hr);

        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_TPT_BITMAP, &bVal);
    IfFailGo(hr);

    if (VARIANT_TRUE == bVal)
    {
        hr = piTask->put_ImageType(siBitmap);
        IfFailGo(hr);

        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_TPT_SYMBOL, &bVal);
    IfFailGo(hr);

    if (VARIANT_TRUE == bVal)
    {
        hr = piTask->put_ImageType(siSymbol);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyMouseOverImage(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyMouseOverImage(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrMouseOver = NULL;
    BSTR         bstrSavedMouseOver = NULL;

    ASSERT(piTask != NULL, "ApplyMouseOverImage: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TPT_MOUSE_OVER, &bstrMouseOver);
    IfFailGo(hr);

    hr = piTask->get_MouseOverImage(&bstrSavedMouseOver);
    IfFailGo(hr);

    if (NULL == bstrSavedMouseOver || 0 != ::wcscmp(bstrMouseOver, bstrSavedMouseOver))
    {
        hr = piTask->put_MouseOverImage(bstrMouseOver);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedMouseOver);
    FREESTRING(bstrMouseOver);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyMouseOffImage(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyMouseOffImage(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrMouseOff = NULL;
    BSTR         bstrSavedMouseOff = NULL;

    ASSERT(piTask != NULL, "ApplyMouseOffImage: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TPT_MOUSE_OFF, &bstrMouseOff);
    IfFailGo(hr);

    hr = piTask->get_MouseOffImage(&bstrSavedMouseOff);
    IfFailGo(hr);

    if (NULL == bstrSavedMouseOff || 0 != ::wcscmp(bstrMouseOff, bstrSavedMouseOff))
    {
        hr = piTask->put_MouseOffImage(bstrMouseOff);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedMouseOff);
    FREESTRING(bstrMouseOff);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyFontFamilyName(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyFontFamilyName(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrFontFamily = NULL;
    BSTR         bstrSavedFontFamily = NULL;

    ASSERT(piTask != NULL, "ApplyFontFamilyName: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TPT_FONT_FAMILY, &bstrFontFamily);
    IfFailGo(hr);

    hr = piTask->get_FontFamily(&bstrSavedFontFamily);
    IfFailGo(hr);

    if (NULL == bstrSavedFontFamily || 0 != ::wcscmp(bstrFontFamily, bstrSavedFontFamily))
    {
        hr = piTask->put_FontFamily(bstrFontFamily);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedFontFamily);
    FREESTRING(bstrFontFamily);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyEOTFile(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyEOTFile(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrEOTFile = NULL;
    BSTR         bstrSavedEOTFile = NULL;

    ASSERT(piTask != NULL, "ApplyEOTFile: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TPT_EOT, &bstrEOTFile);
    IfFailGo(hr);

    hr = piTask->get_EOTFile(&bstrSavedEOTFile);
    IfFailGo(hr);

    if (NULL == bstrSavedEOTFile || 0 != ::wcscmp(bstrEOTFile, bstrSavedEOTFile))
    {
        hr = piTask->put_EOTFile(bstrEOTFile);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedEOTFile);
    FREESTRING(bstrEOTFile);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplySymbolString(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplySymbolString(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrSymbolString = NULL;
    BSTR         bstrSavedSymbolString = NULL;

    ASSERT(piTask != NULL, "ApplySymbolString: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, &bstrSymbolString);
    IfFailGo(hr);

    hr = piTask->get_SymbolString(&bstrSavedSymbolString);
    IfFailGo(hr);

    if (NULL == bstrSavedSymbolString || 0 != ::wcscmp(bstrSymbolString, bstrSavedSymbolString))
    {
        hr = piTask->put_SymbolString(bstrSymbolString);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedSymbolString);
    FREESTRING(bstrSymbolString);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;
    BSTR            bstrNull = NULL;

    switch (dlgItemID)
    {
    case IDC_BUTTON_TP_INSERT_TASK:
        if (S_OK == IsPageDirty())
        {
            hr = OnApply();
            IfFailGo(hr);
        }

        hr = CanEnterDoingNewTaskState();
        IfFailGo(hr);

        if (S_OK == hr)
        {
            hr = EnterDoingNewTaskState();
            IfFailGo(hr);
        }
        break;

    case IDC_BUTTON_TP_REMOVE_TASK:
		hr = OnRemoveTask();
		IfFailGo(hr);
        break;

    case IDC_RADIO_TP_TASK_NOTIFY:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_URL), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_SCRIPT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        break;

    case IDC_RADIO_TP_TASK_URL:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_URL), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_SCRIPT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        break;

    case IDC_RADIO_TP_TASK_SCRIPT:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_URL), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_SCRIPT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        break;

    case IDC_RADIO_TPT_VANILLA:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

        if (siSymbol == m_lastImageType)
        {
            hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OVER, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OFF, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_FONT_FAMILY, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_EOT, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, bstrNull);
        }
        m_lastImageType = siVanillaGIF;
        break;

    case IDC_RADIO_TPT_CHOCOLATE:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

        if (siSymbol == m_lastImageType)
        {
            hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OVER, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OFF, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_FONT_FAMILY, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_EOT, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, bstrNull);
        }
        m_lastImageType = siChocolateGIF;
        break;

    case IDC_RADIO_TPT_BITMAP:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

        if (siSymbol == m_lastImageType)
        {
            hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OVER, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OFF, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_FONT_FAMILY, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_EOT, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, bstrNull);
        }
        m_lastImageType = siBitmap;
        break;

    case IDC_RADIO_TPT_SYMBOL:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);

        hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OVER, bstrNull);
        hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OFF, bstrNull);
        hr = SetDlgText(IDC_EDIT_TPT_FONT_FAMILY, bstrNull);
        hr = SetDlgText(IDC_EDIT_TPT_EOT, bstrNull);
        hr = SetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, bstrNull);

        m_lastImageType = siSymbol;
        break;
    }

    MakeDirty();

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::OnRemoveTask()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::OnRemoveTask()
{
    HRESULT         hr = S_OK;
    ITasks         *piTasks = NULL;
	VARIANT			vtIndex;
	ITask		   *piTask = NULL;
    long            lCount = 0;

    ASSERT(NULL != m_piTaskpadViewDef, "OnRemoveTask: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "OnRemoveTask: m_piTaskpad is NULL");

	::VariantInit(&vtIndex);

    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

	vtIndex.vt = VT_I4;
	vtIndex.lVal = m_lCurrentTask;
	hr = piTasks->Remove(vtIndex);
	IfFailGo(hr);

    hr = piTasks->get_Count(&lCount);
    IfFailGo(hr);

	if (lCount > 0)
	{
        if (m_lCurrentTask > lCount)
            m_lCurrentTask = lCount;

		hr = SetDlgText(IDC_EDIT_TP_TASK_INDEX, m_lCurrentTask);
		IfFailGo(hr);

		vtIndex.vt = VT_I4;
		vtIndex.lVal = m_lCurrentTask;
		hr = piTasks->get_Item(vtIndex, reinterpret_cast<Task **>(&piTask));
		IfFailGo(hr);

		hr = ShowTask(piTask);
		IfFailGo(hr);
	}
	else
	{
		m_lCurrentTask = 0;
		hr = SetDlgText(IDC_EDIT_TP_TASK_INDEX, m_lCurrentTask);
		IfFailGo(hr);

		hr = ClearTask();
		IfFailGo(hr);

		hr = EnableEdits(false);
		IfFailGo(hr);
	}

Error:
	RELEASE(piTask);
	::VariantClear(&vtIndex);
    RELEASE(piTasks);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::OnKillFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::OnKillFocus(int dlgItemID)
{
    HRESULT          hr = S_OK;
    ITasks          *piTasks = NULL;
    int              lIndex = 0;
    long             lCount = 0;

    if (false == m_bSavedLastTask)
    {
        goto Error;
    }

    switch (dlgItemID)
    {
    case IDC_EDIT_TP_TASK_INDEX:
        hr = GetDlgInt(IDC_EDIT_TP_TASK_INDEX, &lIndex);
        IfFailGo(hr);

        hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
        IfFailGo(hr);

        hr = piTasks->get_Count(&lCount);
        IfFailGo(hr);

        if (lIndex != m_lCurrentTask)
        {
            if (lIndex >= 1)
            {
                if (lIndex > lCount)
                    m_lCurrentTask = lCount;
                else
                    m_lCurrentTask = lIndex;

                hr = ShowTask();
                IfFailGo(hr);
            }
        }
        break;
    }

Error:
    RELEASE(piTasks);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ClearTask()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ClearTask()
{
    HRESULT                         hr = S_OK;
    BSTR                            bstrNull = NULL;

    hr = SetDlgText(IDC_EDIT_TP_TASK_KEY, bstrNull);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_TEXT, bstrNull);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_HELP_STRING, bstrNull);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_TAG, bstrNull);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_RADIO_TP_TASK_NOTIFY, VARIANT_TRUE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_RADIO_TP_TASK_URL, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_RADIO_TP_TASK_SCRIPT, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_URL, bstrNull);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_SCRIPT, bstrNull);
    IfFailGo(hr);

    //
    hr = SetCheckbox(IDC_RADIO_TPT_VANILLA, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_RADIO_TPT_CHOCOLATE, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_RADIO_TPT_BITMAP, VARIANT_TRUE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_RADIO_TPT_SYMBOL, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OVER, bstrNull);
    IfFailGo(hr);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);

    hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OFF, bstrNull);
    IfFailGo(hr);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);

    hr = SetDlgText(IDC_EDIT_TPT_FONT_FAMILY, bstrNull);
    IfFailGo(hr);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

    hr = SetDlgText(IDC_EDIT_TPT_EOT, bstrNull);
    IfFailGo(hr);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

    hr = SetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, bstrNull);
    IfFailGo(hr);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::EnableEdits(bool bEnable)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::EnableEdits
(
    bool bEnable
)
{
    HRESULT         hr = S_OK;
    BOOL            fEnable = (true == bEnable) ? FALSE : TRUE;
    VARIANT_BOOL    bValue = VARIANT_FALSE;

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_KEY), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_TEXT), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_HELP_STRING), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_TAG), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);

    GetCheckbox(IDC_RADIO_TP_TASK_URL, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_URL), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
    }
    else
    {
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_URL), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    }

    GetCheckbox(IDC_RADIO_TP_TASK_SCRIPT, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_SCRIPT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
    }
    else
    {
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_SCRIPT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    }

    if (true == bEnable)
    {
		GetCheckbox(IDC_RADIO_TPT_SYMBOL, &bValue);
		IfFailGo(hr);

		if (VARIANT_TRUE == bValue)
		{
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
		}
		else
		{
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
		}
	}
	else
	{
		::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
		::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
		::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
		::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
		::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
	}

    if (false == bEnable)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TP_TASK_NOTIFY), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TP_TASK_URL), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TP_TASK_SCRIPT), FALSE);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_VANILLA), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_CHOCOLATE), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_BITMAP), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_SYMBOL), FALSE);
    }
    else
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TP_TASK_NOTIFY), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TP_TASK_URL), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TP_TASK_SCRIPT), TRUE);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_VANILLA), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_CHOCOLATE), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_BITMAP), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_SYMBOL), TRUE);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ShowTask()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ShowTask()
{
    HRESULT     hr = S_OK;
    ITasks     *piTasks = NULL;
    VARIANT     vtIndex;
    ITask      *piTask = NULL;

    ASSERT(m_piTaskpadViewDef != NULL, "ShowTask: m_piTaskpadViewDef is NULL");
    ASSERT(m_piTaskpad != NULL, "ShowTask: m_piTaskpad is NULL");

    ::VariantInit(&vtIndex);

    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentTask;

    hr = piTasks->get_Item(vtIndex, reinterpret_cast<Task **>(&piTask));
    IfFailGo(hr);

    hr = ShowTask(piTask);
    IfFailGo(hr);

Error:
    RELEASE(piTask);
    RELEASE(piTasks);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ShowTask(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ShowTask
(
    ITask *piTask
)
{
    HRESULT                         hr = S_OK;
    BSTR                            bstrKey = NULL;
    BSTR                            bstrText = NULL;
    BSTR                            bstrHelpString = NULL;
	VARIANT							vtTag;
    SnapInActionTypeConstants       siatc = siNotify;
    SnapInTaskpadImageTypeConstants sititc = siNoImage;
    BSTR                            bstrURL = NULL;
    BSTR                            bstrScript = NULL;
    BSTR                            bstrMouseOver = NULL;
    BSTR                            bstrMouseOff = NULL;
    BSTR                            bstrFontFamily = NULL;
    BSTR                            bstrEOTFile = NULL;
    BSTR                            bstrSymbolString = NULL;

    ASSERT(m_piTaskpadViewDef != NULL, "ShowTask: m_piTaskpadViewDef is NULL");
    ASSERT(m_piTaskpad != NULL, "ShowTask: m_piTaskpad is NULL");

	::VariantInit(&vtTag);

    hr = SetDlgText(IDC_EDIT_TP_TASK_INDEX, m_lCurrentTask);
    IfFailGo(hr);

    hr = piTask->get_Key(&bstrKey);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_KEY, bstrKey);
    IfFailGo(hr);

    hr = piTask->get_Text(&bstrText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_TEXT, bstrText);
    IfFailGo(hr);

    hr = piTask->get_HelpString(&bstrHelpString);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_HELP_STRING, bstrHelpString);
    IfFailGo(hr);

    hr = piTask->get_Tag(&vtTag);
    IfFailGo(hr);

    hr = SetDlgText(vtTag, IDC_EDIT_TP_TASK_TAG);
    IfFailGo(hr);

    hr = piTask->get_ActionType(&siatc);
    IfFailGo(hr);

    switch (siatc)
    {
    case siNotify:
        hr = SetCheckbox(IDC_RADIO_TP_TASK_NOTIFY, VARIANT_TRUE);
        hr = SetCheckbox(IDC_RADIO_TP_TASK_URL, VARIANT_FALSE);
        hr = SetCheckbox(IDC_RADIO_TP_TASK_SCRIPT, VARIANT_FALSE);
        IfFailGo(hr);
        break;

    case siURL:
        hr = SetCheckbox(IDC_RADIO_TP_TASK_NOTIFY, VARIANT_FALSE);
        hr = SetCheckbox(IDC_RADIO_TP_TASK_URL, VARIANT_TRUE);
        hr = SetCheckbox(IDC_RADIO_TP_TASK_SCRIPT, VARIANT_FALSE);
        IfFailGo(hr);
        break;

    case siScript:
        hr = SetCheckbox(IDC_RADIO_TP_TASK_NOTIFY, VARIANT_FALSE);
        hr = SetCheckbox(IDC_RADIO_TP_TASK_URL, VARIANT_FALSE);
        hr = SetCheckbox(IDC_RADIO_TP_TASK_SCRIPT, VARIANT_TRUE);
        IfFailGo(hr);
        break;
    }

    hr = piTask->get_URL(&bstrURL);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_URL, bstrURL);
    IfFailGo(hr);

    hr = piTask->get_Script(&bstrScript);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_SCRIPT, bstrScript);
    IfFailGo(hr);

    hr = piTask->get_ImageType(&sititc);
    IfFailGo(hr);

    m_lastImageType = sititc;

    hr = SetCheckbox(IDC_RADIO_TPT_VANILLA, VARIANT_FALSE);
    hr = SetCheckbox(IDC_RADIO_TPT_CHOCOLATE, VARIANT_FALSE);
    hr = SetCheckbox(IDC_RADIO_TPT_BITMAP, VARIANT_FALSE);
    hr = SetCheckbox(IDC_RADIO_TPT_SYMBOL, VARIANT_FALSE);

    switch (sititc)
    {
    case siVanillaGIF:
        hr = SetCheckbox(IDC_RADIO_TPT_VANILLA, VARIANT_TRUE);
        IfFailGo(hr);
        break;

    case siChocolateGIF:
        hr = SetCheckbox(IDC_RADIO_TPT_CHOCOLATE, VARIANT_TRUE);
        IfFailGo(hr);
        break;

    case siBitmap:
        hr = SetCheckbox(IDC_RADIO_TPT_BITMAP, VARIANT_TRUE);
        IfFailGo(hr);
        break;

    case siSymbol:
        hr = SetCheckbox(IDC_RADIO_TPT_SYMBOL, VARIANT_TRUE);
        IfFailGo(hr);
        break;
    }

    hr = piTask->get_MouseOverImage(&bstrMouseOver);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OVER, bstrMouseOver);
    IfFailGo(hr);

    hr = piTask->get_MouseOffImage(&bstrMouseOff);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OFF, bstrMouseOff);
    IfFailGo(hr);

    hr = piTask->get_FontFamily(&bstrFontFamily);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TPT_FONT_FAMILY, bstrFontFamily);
    IfFailGo(hr);

    hr = piTask->get_EOTFile(&bstrEOTFile);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TPT_EOT, bstrEOTFile);
    IfFailGo(hr);

    hr = piTask->get_SymbolString(&bstrSymbolString);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, bstrSymbolString);
    IfFailGo(hr);

    hr = EnableEdits(true);
    IfFailGo(hr);

Error:
    FREESTRING(bstrSymbolString);
    FREESTRING(bstrEOTFile);
    FREESTRING(bstrFontFamily);
    FREESTRING(bstrMouseOff);
    FREESTRING(bstrMouseOver);
    FREESTRING(bstrScript);
    FREESTRING(bstrURL);
	::VariantClear(&vtTag);
    FREESTRING(bstrHelpString);
    FREESTRING(bstrText);
    FREESTRING(bstrKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::OnDeltaPos(NMUPDOWN *pNMUpDown)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::OnDeltaPos(NMUPDOWN *pNMUpDown)
{
    HRESULT       hr = S_OK;
    ITasks       *piTasks = NULL;
    long          lCount = 0;

    ASSERT(NULL != m_piTaskpadViewDef, "OnButtonDeltaPos: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "OnButtonDeltaPos: m_piTaskpad is NULL");

    if (false == m_bSavedLastTask || S_OK == IsPageDirty())
    {
        hr = OnApply();
        IfFailGo(hr);
    }

    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

    hr = piTasks->get_Count(&lCount);
    IfFailGo(hr);

    if (pNMUpDown->iDelta < 0)
    {
        if (m_lCurrentTask < lCount)
        {
            ++m_lCurrentTask;
            hr = ShowTask();
            IfFailGo(hr);
        }
    }
    else
    {
        if (m_lCurrentTask > 1 && m_lCurrentTask <= lCount)
        {
            --m_lCurrentTask;
            hr = ShowTask();
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piTasks);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::CanEnterDoingNewTaskState()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::CanEnterDoingNewTaskState()
{
    HRESULT     hr = S_FALSE;

    if (true == m_bSavedLastTask)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::EnterDoingNewTaskState()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::EnterDoingNewTaskState()
{
    HRESULT      hr = S_OK;

    ASSERT(NULL != m_piTaskpadViewDef, "EnterDoingNewTaskState: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "EnterDoingNewTaskState: m_piTaskpad is NULL");

    // Bump up the current button index to keep matters in sync.
    ++m_lCurrentTask;
    hr = SetDlgText(IDC_EDIT_TP_TASK_INDEX, m_lCurrentTask);
    IfFailGo(hr);

    // We disable the RemoveButton.
    // The InsertButton button remains enabled and acts like an "Apply and New" button
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_TP_REMOVE_TASK), FALSE);

    // Enable edits in this area of the dialog and clear all the entries
    hr = EnableEdits(true);
    IfFailGo(hr);

    hr = ClearTask();
    IfFailGo(hr);

    m_lastImageType = siBitmap;
    m_bSavedLastTask = false;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::CanCreateNewTask()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::CanCreateNewTask()
{
    HRESULT      hr = S_OK;
    BSTR         bstrText = NULL;

    // Got to have some text
    hr = GetDlgText(IDC_EDIT_TP_TASK_TEXT, &bstrText);
    IfFailGo(hr);

    if (NULL == bstrText || 0 == ::SysStringLen(bstrText))
    {
        HandleError(_T("Cannot Create New Task"), _T("Task must have some text"));
        hr = S_FALSE;
        goto Error;
    }

Error:
    FREESTRING(bstrText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::CanApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::CanApply()
{
    HRESULT         hr = S_OK;
    BSTR            bstrText = NULL;
    BSTR            bstrHelpString = NULL;
    VARIANT_BOOL    bValue = VARIANT_FALSE;
    BSTR            bstrURL  = NULL;
    BSTR            bstrScript = NULL;
    BSTR            bstrMouseOver = NULL;
    bool            bMouseOverEmpty = false;
    BSTR            bstrMouseOff = NULL;
    bool            bMouseOffEmpty = false;
    TCHAR          *pszMouseOver = NULL;
    TCHAR          *pszMouseOff = NULL;
    BSTR            bstrFontFamily = NULL;
    BSTR            bstrEOTFile = NULL;
    TCHAR          *pszEOTFile = NULL;
    BSTR            bstrSymbolString = NULL;

    // Got to have some text
    hr = GetDlgText(IDC_EDIT_TP_TASK_TEXT, &bstrText);
    IfFailGo(hr);

    if (NULL == bstrText || 0 == ::SysStringLen(bstrText))
    {
        HandleError(_T("Apply Taskpad"), _T("Task must have some text"));
        hr = S_FALSE;
        goto Error;
    }

    // Got to have a help string
    hr = GetDlgText(IDC_EDIT_TP_TASK_HELP_STRING, &bstrHelpString);
    IfFailGo(hr);

    if (NULL == bstrHelpString || 0 == ::SysStringLen(bstrHelpString))
    {
        HandleError(_T("Apply Taskpad"), _T("Task must have a help string"));
        hr = S_FALSE;
        goto Error;
    }

    // Check URL consistency
    hr = GetCheckbox(IDC_RADIO_TP_TASK_URL, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = GetDlgText(IDC_EDIT_TP_TASK_URL, &bstrURL);
        IfFailGo(hr);

        if (NULL == bstrURL || 0 == ::SysStringLen(bstrURL))
        {
            HandleError(_T("Apply Taskpad"), _T("URL cannot be empty"));
            hr = S_FALSE;
            goto Error;
        }
    }

    // Check Script consistency
    hr = GetCheckbox(IDC_RADIO_TP_TASK_SCRIPT, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = GetDlgText(IDC_EDIT_TP_TASK_SCRIPT, &bstrScript);
        IfFailGo(hr);

        if (NULL == bstrScript || 0 == ::SysStringLen(bstrScript))
        {
            HandleError(_T("Apply Taskpad"), _T("Script name cannot be empty"));
            hr = S_FALSE;
            goto Error;
        }
    }

    // If we're not a symbol, certain restrictions apply
    hr = GetCheckbox(IDC_RADIO_TPT_SYMBOL, &bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = GetDlgText(IDC_EDIT_TPT_MOUSE_OVER, &bstrMouseOver);
        IfFailGo(hr);

        if (NULL == bstrMouseOver || 0 == ::SysStringLen(bstrMouseOver))
            bMouseOverEmpty = true;

        hr = GetDlgText(IDC_EDIT_TPT_MOUSE_OFF, &bstrMouseOff);
        IfFailGo(hr);

        if (NULL == bstrMouseOff || 0 == ::SysStringLen(bstrMouseOff))
            bMouseOffEmpty = true;

        if (true == bMouseOverEmpty && true == bMouseOffEmpty)
        {
            HandleError(_T("Apply Taskpad"), _T("Mouse over and mouse off cannot both be empty"));
            hr = S_FALSE;
            goto Error;
        }

        if (false == bMouseOverEmpty)
        {
            hr = ANSIFromBSTR(bstrMouseOver, &pszMouseOver);
            IfFailGo(hr);

            if (false == IsValidURL(pszMouseOver))
            {
                HandleError(_T("Apply Taskpad"), _T("Mouse over must have \'res://\' format"));
                hr = S_FALSE;
                goto Error;
            }
        }

        if (false == bMouseOffEmpty)
        {
            hr = ANSIFromBSTR(bstrMouseOff, &pszMouseOff);
            IfFailGo(hr);

            if (false == IsValidURL(pszMouseOff))
            {
                HandleError(_T("Apply Taskpad"), _T("Mouse off must have \'res://\' format"));
                hr = S_FALSE;
                goto Error;
            }
        }

    }
    // And if we ARE a symbol, then other restrictions apply
    else
    {
        hr = GetDlgText(IDC_EDIT_TPT_FONT_FAMILY, &bstrFontFamily);
        IfFailGo(hr);

        if (NULL == bstrFontFamily || 0 == ::SysStringLen(bstrFontFamily))
        {
            HandleError(_T("Apply Taskpad"), _T("Font family cannot be empty"));
            hr = S_FALSE;
            goto Error;
        }

        hr = GetDlgText(IDC_EDIT_TPT_EOT, &bstrEOTFile);
        IfFailGo(hr);

        if (NULL == bstrEOTFile || 0 == ::SysStringLen(bstrEOTFile))
        {
            HandleError(_T("Apply Taskpad"), _T("EOT file cannot be empty"));
            hr = S_FALSE;
            goto Error;
        }

        hr = ANSIFromBSTR(bstrEOTFile, &pszEOTFile);
        IfFailGo(hr);

        if (false == IsValidURL(pszEOTFile))
        {
            HandleError(_T("Apply Taskpad"), _T("EOT file must have \'res://\' format"));
            hr = S_FALSE;
            goto Error;
        }

        hr = GetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, &bstrSymbolString);
        IfFailGo(hr);

        if (NULL == bstrSymbolString || 0 == ::SysStringLen(bstrSymbolString))
        {
            HandleError(_T("Apply Taskpad"), _T("Symbol string cannot be empty"));
            hr = S_FALSE;
            goto Error;
        }
    }

Error:
    FREESTRING(bstrSymbolString);
    if (NULL != pszEOTFile)
        CtlFree(pszEOTFile);
    FREESTRING(bstrEOTFile);
    FREESTRING(bstrFontFamily);
    if (NULL != pszMouseOff)
        CtlFree(pszMouseOff);
    if (NULL != pszMouseOver)
        CtlFree(pszMouseOver);
    FREESTRING(bstrMouseOff);
    FREESTRING(bstrMouseOver);
    FREESTRING(bstrScript);
    FREESTRING(bstrURL);
    FREESTRING(bstrHelpString);
    FREESTRING(bstrText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::CreateNewTask(ITask **ppiTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::CreateNewTask(ITask **ppiTask)
{
    HRESULT      hr = S_OK;
    ITasks      *piTasks = NULL;
    VARIANT      vtIndex;
    VARIANT      vtKey;
    VARIANT      vtText;
    BSTR         bstrKey = NULL;
    BSTR         bstrText = NULL;

    ASSERT(m_piTaskpadViewDef != NULL, "CreateNewTask: m_piTaskpadViewDef is NULL");
    ASSERT(m_piTaskpad != NULL, "CreateNewTask: m_piTaskpad is NULL");

    ::VariantInit(&vtIndex);
    ::VariantInit(&vtKey);
    ::VariantInit(&vtText);

    vtIndex.vt = VT_ERROR;
    vtIndex.scode = DISP_E_PARAMNOTFOUND;

    hr = GetDlgText(IDC_EDIT_TP_TASK_KEY, &bstrKey);
    IfFailGo(hr);

    if (NULL == bstrKey || 0 == ::SysStringLen(bstrKey))
    {
        vtKey.vt = VT_ERROR;
        vtKey.scode = DISP_E_PARAMNOTFOUND;
    }
    else
    {
        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrKey);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    hr = GetDlgText(IDC_EDIT_TP_TASK_TEXT, &bstrText);
    IfFailGo(hr);

    vtText.vt = VT_BSTR;
    vtText.bstrVal = ::SysAllocString(bstrText);
    if (NULL == vtText.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

    hr = piTasks->Add(vtIndex, vtKey, vtText, reinterpret_cast<Task **>(ppiTask));
    IfFailGo(hr);

Error:
    FREESTRING(bstrText);
    FREESTRING(bstrKey);
    ::VariantClear(&vtIndex);
    ::VariantClear(&vtKey);
    ::VariantClear(&vtText);
    RELEASE(piTasks);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ExitDoingNewTaskState(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ExitDoingNewTaskState(ITask *piTask)
{
    HRESULT                     hr = S_OK;

    ASSERT(m_piTaskpadViewDef != NULL, "ExitDoingNewTaskState: m_piTaskpadViewDef is NULL");
    ASSERT(m_piTaskpad != NULL, "ExitDoingNewTaskState: m_piTaskpad is NULL");

    if (NULL != piTask)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_TP_REMOVE_TASK), TRUE);
    }
    else    // Operation was cancelled
    {
        --m_lCurrentTask;
        if (m_lCurrentTask > 0)
        {
            hr = ShowTask();
            IfFailGo(hr);
        }
        else
        {
            hr = EnableEdits(false);
            IfFailGo(hr);

            hr = ClearTask();
            IfFailGo(hr);
        }
    }

    m_bSavedLastTask = true;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::GetCurrentTask()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::GetCurrentTask(ITask **ppiTask)
{

    HRESULT      hr = S_OK;
    ITasks      *piTasks = NULL;
    VARIANT      vtIndex;

    ::VariantInit(&vtIndex);

    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentTask;
    hr = piTasks->get_Item(vtIndex, reinterpret_cast<Task **>(ppiTask));
    IfFailGo(hr);

Error:
    RELEASE(piTasks);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psurl.cpp ===
//=--------------------------------------------------------------------------------------
// psurl.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// URL View Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "psurl.h"

// for ASSERT and FAIL
//
SZTHISFILE


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// URL View Property Page
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CURLViewGeneralPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CURLViewGeneralPage::Create(IUnknown *pUnkOuter)
{
	CURLViewGeneralPage *pNew = New CURLViewGeneralPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::CURLViewGeneralPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CURLViewGeneralPage::CURLViewGeneralPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGURLVIEWGENERAL), m_piURLViewDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::~CURLViewGeneralPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CURLViewGeneralPage::~CURLViewGeneralPage()
{
    RELEASE(m_piURLViewDef);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::OnInitializeDialog()
{
    HRESULT     hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_URL_NAME, IDS_TT_URL_NAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_URL_URL, IDS_TT_URL_URL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_URL_ADDTOVIEWMENU, IDS_TT_URL_ATVMENU);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_URL_VIEWMENUTEXT, IDS_TT_URL_VMTEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_URL_STATUSBARTEXT, IDS_TT_URL_SBTEXT);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    BSTR            bstrName = NULL;
    BSTR            bstrURL = NULL;
    VARIANT_BOOL    vtBool = VARIANT_FALSE;
    BSTR            bstrViewMenuText = NULL;
    BSTR            bstrStatusBarText = NULL;

    if (m_piURLViewDef != NULL)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IURLViewDef, reinterpret_cast<void **>(&m_piURLViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piURLViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_URL_NAME, bstrName);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_URL(&bstrURL);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_URL_URL, bstrURL);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_AddToViewMenu(&vtBool);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_URL_ADDTOVIEWMENU, vtBool);
    IfFailGo(hr);

    // Initialize the state of View Menu Text
    if (vtBool == VARIANT_FALSE)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_URL_VIEWMENUTEXT), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_URL_STATUSBARTEXT), FALSE);
    }

    hr = m_piURLViewDef->get_ViewMenuText(&bstrViewMenuText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_URL_VIEWMENUTEXT, bstrViewMenuText);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_ViewMenuStatusBarText(&bstrStatusBarText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_URL_STATUSBARTEXT, bstrStatusBarText);
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    FREESTRING(bstrStatusBarText);
    FREESTRING(bstrViewMenuText);
    FREESTRING(bstrURL);
    FREESTRING(bstrName);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(m_piURLViewDef != NULL, "OnApply: m_piURLViewDef is NULL");

    hr = ApplyURLName();
    IfFailGo(hr);

    hr = ApplyURLUrl();
    IfFailGo(hr);

    hr = ApplyAddToView();
    IfFailGo(hr);

    hr = ApplyViewMenuText();
    IfFailGo(hr);

    hr = ApplyStatusBarText();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::ApplyURLName()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::ApplyURLName()
{
    HRESULT  hr = S_OK;
    BSTR     bstrURLName = NULL;
    BSTR     bstrSavedURLName = NULL;

    hr = GetDlgText(IDC_EDIT_URL_NAME, &bstrURLName);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_Name(&bstrSavedURLName);
    IfFailGo(hr);

    if (::wcscmp(bstrURLName, bstrSavedURLName) != 0)
    {
        hr = m_piURLViewDef->put_Name(bstrURLName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedURLName);
    FREESTRING(bstrURLName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::ApplyURLUrl()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::ApplyURLUrl()
{
    HRESULT  hr = S_OK;
    BSTR     bstrURLUrl = NULL;
    BSTR     bstrSavedURLUrl = NULL;

    hr = GetDlgText(IDC_EDIT_URL_URL, &bstrURLUrl);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_URL(&bstrSavedURLUrl);
    IfFailGo(hr);

    if (::wcscmp(bstrURLUrl, bstrSavedURLUrl) != 0)
    {
        hr = m_piURLViewDef->put_URL(bstrURLUrl);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedURLUrl);
    FREESTRING(bstrURLUrl);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::ApplyAddToView()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::ApplyAddToView()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtAddToViewMenu = VARIANT_FALSE;
    VARIANT_BOOL    vtSavedAddToViewMenu = VARIANT_FALSE;

    hr = GetCheckbox(IDC_CHECK_URL_ADDTOVIEWMENU, &vtAddToViewMenu);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_AddToViewMenu(&vtSavedAddToViewMenu);
    IfFailGo(hr);

    if (vtAddToViewMenu != vtSavedAddToViewMenu)
    {
        hr = m_piURLViewDef->put_AddToViewMenu(vtAddToViewMenu);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::ApplyViewMenuText()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::ApplyViewMenuText()
{
    HRESULT  hr = S_OK;
    BSTR     bstrViewMenuText = NULL;
    BSTR     bstrSavedViewMenuText = NULL;

    hr = GetDlgText(IDC_EDIT_URL_VIEWMENUTEXT, &bstrViewMenuText);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_ViewMenuText(&bstrSavedViewMenuText);
    IfFailGo(hr);

    if (::wcscmp(bstrViewMenuText, bstrSavedViewMenuText) != 0)
    {
        hr = m_piURLViewDef->put_ViewMenuText(bstrViewMenuText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedViewMenuText);
    FREESTRING(bstrViewMenuText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::ApplyStatusBarText()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::ApplyStatusBarText()
{
    HRESULT  hr = S_OK;
    BSTR     bstrStatusBarText = NULL;
    BSTR     bstrSavedStatusBarText = NULL;

    hr = GetDlgText(IDC_EDIT_URL_STATUSBARTEXT, &bstrStatusBarText);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_ViewMenuStatusBarText(&bstrSavedStatusBarText);
    IfFailGo(hr);

    if (::wcscmp(bstrStatusBarText, bstrSavedStatusBarText) != 0)
    {
        hr = m_piURLViewDef->put_ViewMenuStatusBarText(bstrStatusBarText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedStatusBarText);
    FREESTRING(bstrStatusBarText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtAddToViewMenu = VARIANT_FALSE;

    switch (dlgItemID)
    {
    case IDC_CHECK_URL_ADDTOVIEWMENU:
        hr = GetCheckbox(IDC_CHECK_URL_ADDTOVIEWMENU, &vtAddToViewMenu);
        IfFailGo(hr);

        if (vtAddToViewMenu == VARIANT_TRUE)
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_URL_VIEWMENUTEXT), TRUE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_URL_STATUSBARTEXT), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_URL_VIEWMENUTEXT), FALSE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_URL_STATUSBARTEXT), FALSE);
        }

        MakeDirty();
        break;
    }

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\resource.h ===
//=--------------------------------------------------------------------------=
// resource.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
//      Snap-in designer runtime resource IDs
//

#ifndef _RESOURCE_H_


//=--------------------------------------------------------------------------=
//                              Bitmaps
//=--------------------------------------------------------------------------=

#define IDB_TOOLBAR                     1
#define IDB_BITMAP_CLOSED_FOLDER        2
#define IDB_BITMAP_OPEN_FOLDER          3
#define IDB_BITMAP_SCOPE_ITEM           4
#define IDB_BITMAP_IMAGE_LIST           5
#define IDB_BITMAP_MENU                 6
#define IDB_BITMAP_TOOLBAR              7
#define IDB_BITMAP_LIST_VIEW            8
#define IDB_BITMAP_OCX_VIEW             9
#define IDB_BITMAP_URL_VIEW            10
#define IDB_BITMAP_TASKPAD             11
#define IDB_BITMAP_DATAFMT             12
#define IDB_BITMAP_CHECKBOX            13

//=--------------------------------------------------------------------------=
//                              Strings
//=--------------------------------------------------------------------------=

#define IDS_DESIGNER_NAME               0

// This is defined for all inproc servers that use satellite localization. It
// must be 1001
//
#define IDS_SERVERBASENAME              1001
#define IDS_SNAPIN_PROPS                1002
#define IDS_NODE_PROPS                  1003
#define IDS_LISTVIEW_PROPS              1004
#define IDS_OCX_PROPS                   1005
#define IDS_URL_PROPS                   1006
#define IDS_TASK_PROPS                  1007
#define IDS_IL_PROPS                    1008
#define IDS_MENU_PROPS                  1009
#define IDS_TOOLB_PROPS                 1010

#define IDS_DFLT_PROVIDER               1020
#define IDS_DFLT_VERSION                1021
#define IDS_DFLT_DESCRIPT               1022

#define IDS_SNAPINPPG_GEN               1030
#define IDS_SNAPINPPG_IL				1031
#define IDS_SNAPINPPG_AVAIL             1032
#define IDS_NODEPPG_GEN                 1033
#define IDS_NODEPPG_CH                  1034
#define IDS_URLPPG_GEN                  1035
#define IDS_OCXPPG_GEN                  1036
#define IDS_LISTVPPG_GEN                1037
#define IDS_LISTVPPG_IL                 1038
#define IDS_LISTVPPG_SORT               1039
#define IDS_LISTVPPG_CH                 1040
#define IDS_IMGLSTPPG_IMG               1041
#define IDS_TOOLBPPG_GEN                1042
#define IDS_TOOLBPPG_BUTTONS            1043
#define IDS_TASKPAD_GEN                 1044
#define IDS_TASKPAD_BACK                1045
#define IDS_TASKPAD_TASKS               1046

#define IDS_NODE                        1100
#define IDS_LIST_VIEW                   1101
#define IDS_URL_VIEW                    1102
#define IDS_OCX_VIEW                    1103
#define IDS_TASK_VIEW                   1104
#define IDS_IMGLIST                     1105
#define IDS_MENU                        1106
#define IDS_TOOLBAR                     1107
#define IDS_DATAFORMAT                  1108

#define IDS_EXTENSIONS_ROOT             1201
#define IDS_NODES_ROOT                  1202
#define IDS_NODES_AUTO_CREATE           1203
#define IDS_NODES_OTHER                 1204
#define IDS_NODES_STATIC                1205
#define IDS_CHILDREN                    1206
#define IDS_VIEWS                       1207
#define IDS_TOOLS                       1208
#define IDS_IMAGE_LISTS                 1209
#define IDS_MENUS                       1210
#define IDS_TOOLBARS                    1211
#define IDS_LISTVIEWS                   1212
#define IDS_OCXVIEWS                    1213
#define IDS_URLVIEWS                    1214
#define IDS_TASKPADS                    1215
#define IDS_DATAFORMATS                 1216

#define IDS_LV_VM_LARGE                 1300
#define IDS_LV_VM_SMALL                 1301
#define IDS_LV_VM_LIST                  1302
#define IDS_LV_VM_REPORT                1303
#define IDS_LV_VM_FILTERED              1304
#define IDS_LV_SORT_ASC                 1305
#define IDS_LV_SORT_DESC                1306

#define IDS_TB_BS_DEFAULT               1310
#define IDS_TB_BS_CHECK                 1311
#define IDS_TB_BS_GROUP                 1312
#define IDS_TB_BS_SEPARATOR             1313
#define IDS_TB_BS_DROPDOWN              1314

#define IDS_TB_BV_UNPRESSED             1320
#define IDS_TB_BV_PRESSED               1321

#define IDS_EXT_CONTEXT_MENUS           1400
#define IDS_EXT_CTX_MENU_NEW            1401
#define IDS_EXT_CTX_MENU_TASK           1402
#define IDS_EXT_PROP_PAGES              1403
#define IDS_EXT_PROP_TASKPAD            1404
#define IDS_EXT_PROP_TOOLBAR            1405
#define IDS_EXT_PROP_NAMESPACE          1406

#define IDS_MYEXT_NEW_MENU              1410
#define IDS_MYEXT_TASK_MENU             1411
#define IDS_MYEXT_TOP_MENU              1412
#define IDS_MYEXT_VIEW_MENU             1413
#define IDS_MYEXT_PPAGES                1414
#define IDS_MYEXT_TOOLBAR               1415
#define IDS_MYEXT_NAMESPACE             1416

#define IDS_TT_ADD_NODE                  200
#define IDS_TT_ADD_LISTVIEW              201
#define IDS_TT_ADD_TASKPAD               202
#define IDS_TT_ADD_OCX_VIEW              203
#define IDS_TT_ADD_WEB_VIEW              204
#define IDS_TT_ADD_IMAGE_LIST            205
#define IDS_TT_ADD_TOOLBAR               206
#define IDS_TT_ADD_MENU                  207
#define IDS_TT_PROMOTE                   208
#define IDS_TT_DEMOTE                    209
#define IDS_TT_MOVE_UP                   210
#define IDS_TT_MOVE_DOWN                 211
#define IDS_TT_VIEW_PROPERTIES           212
#define IDS_TT_DELETE                    213

#define IDS_TT_SN_STANDALONE             220
#define IDS_TT_SN_EXTENSION              221
#define IDS_TT_SN_DUAL                   222
#define IDS_TT_SN_EXTENSIBLE             223
#define IDS_TT_SN_NAME                   224
#define IDS_TT_SN_TYPENAME               225
#define IDS_TT_SN_DISPLAY                226
#define IDS_TT_SN_PROVIDER               227
#define IDS_TT_SN_VERSION                228
#define IDS_TT_SN_DESCRIPTION            229
#define IDS_TT_SN_DEFAULTVIEW            230
#define IDS_TT_SN_SMALL                  231
#define IDS_TT_SN_SMALL_OPEN             232
#define IDS_TT_SN_LARGE                  233

#define IDS_TT_LV1_NAME                  401
#define IDS_TT_LV1_DFLTVIEW              402
#define IDS_TT_LV1_VIRTLIST              403
#define IDS_TT_LV1_ADDTOVIEWM            404
#define IDS_TT_LV1_VIEWMENUTXT           405
#define IDS_TT_LV1_STATUSTXT             406

#define IDS_TT_LV2_LARGE                 410
#define IDS_TT_LV2_SMALL                 411

#define IDS_TT_LV3_SORTED                415
#define IDS_TT_LV3_KEY                   416
#define IDS_TT_LV3_SORTORDER             417

#define IDS_TT_LV4_INDEX                 420
#define IDS_TT_LV4_TEXT                  421
#define IDS_TT_LV4_WIDTH                 422
#define IDS_TT_LV4_AUTOWIDTH             423
#define IDS_TT_LV4_KEY                   424

#define IDS_TT_OCX_NAME                  430
#define IDS_TT_OCX_PROGID                431
#define IDS_TT_OCX_ATVMENU               432
#define IDS_TT_OCX_VMTEXT                433
#define IDS_TT_OCX_SBTEXT                434

#define IDS_TT_URL_NAME                  440
#define IDS_TT_URL_URL                   441
#define IDS_TT_URL_ATVMENU               442
#define IDS_TT_URL_VMTEXT                443
#define IDS_TT_URL_SBTEXT                444

#define IDS_TT_NODE_NAME                 450
#define IDS_TT_NODE_DISPLAY              451
#define IDS_TT_NODE_IMAGEL               452
#define IDS_TT_NODE_FOLDER               453
#define IDS_TT_NODE_DEFAULT              455
#define IDS_TT_NODE_AUTOCR               456

#define IDS_TT_IL_INDEX                  460
#define IDS_TT_IL_KEY                    461
#define IDS_TT_IL_TAG                    462
#define IDS_TT_IL_COUNT                  463

#define IDS_TT_TB_IMAGE_LIST             480
#define IDS_TT_TB_TAG                    481

#define IDS_TT_TB_BTN_INDEX              485
#define IDS_TT_TB_BTN_CAPTION            486
#define IDS_TT_TB_BTN_KEY                487
#define IDS_TT_TB_BTN_VALUE              488
#define IDS_TT_TB_BTN_STYLE              489
#define IDS_TT_TB_BTN_TT_TEXT            490
#define IDS_TT_TB_BTN_IMAGE              491
#define IDS_TT_TB_BTN_TAG                492
#define IDS_TT_TB_BTN_VISIBLE            493
#define IDS_TT_TB_BTN_ENABLED            494
#define IDS_TT_TB_BTN_MIXED              495
#define IDS_TT_TB_BTN_CHECKED            496
#define IDS_TT_TB_BTN_GRAYED             497
#define IDS_TT_TB_BTN_SEPRTR             498
#define IDS_TT_TB_BTN_MENUBR             499
#define IDS_TT_TB_BTN_MENUBARB           500
#define IDS_TT_TB_BTNM_INDEX             501
#define IDS_TT_TB_BTNM_TEXT              502
#define IDS_TT_TB_BTNM_KEY               503
#define IDS_TT_TB_BTNM_TAG               504
#define IDS_TT_TB_BTNM_ENABLED           505
#define IDS_TT_TB_BTNM_VISIBLE           506

#define IDS_TT_TP_GEN_NAME               600
#define IDS_TT_TP_GEN_TITLE              601
#define IDS_TT_TP_GEN_TEXT               602
#define IDS_TT_TP_GEN_DEFAULT            603
#define IDS_TT_TP_GEN_LISTPAD            604
#define IDS_TT_TP_GEN_CUSTOM             605
#define IDS_TT_TP_GEN_LIST_TI            606
#define IDS_TT_TP_GEN_USE_BTN            607
#define IDS_TT_TP_GEN_BTN_TEXT           608
#define IDS_TT_TP_GEN_URL                609
#define IDS_TT_TP_GEN_ADDTOVW            610
#define IDS_TT_TP_GEN_VWMNTEXT           611
#define IDS_TT_TP_GEN_LISTVIEW           612
#define IDS_TT_TP_GEN_PREFERRED          613

#define IDS_TT_TP_BK_NONE                620
#define IDS_TT_TP_BK_SYMBOL              621
#define IDS_TT_TP_BK_VANILLA             622
#define IDS_TT_TP_BK_CHOCOL              623
#define IDS_TT_TP_BK_BITMAP              624
#define IDS_TT_TP_BK_MOUSE_OVR           625
#define IDS_TT_TP_BK_FFNAME              626
#define IDS_TT_TP_BK_EOT                 627
#define IDS_TT_TP_BK_SYM_STR             628

#define IDS_TT_TP_TSK_INDEX              630
#define IDS_TT_TP_TSK_KEY                631
#define IDS_TT_TP_TSK_TEXT               632
#define IDS_TT_TP_TSK_HELP               633
#define IDS_TT_TP_TSK_NOTIFY             634
#define IDS_TT_TP_TSK_URL                635
#define IDS_TT_TP_TSK_SCRIPT             636
#define IDS_TT_TP_TSK_U_URL              637
#define IDS_TT_TP_TSK_S_SCRIPT           638
#define IDS_TT_TP_TSK_SYMBOL             639
#define IDS_TT_TP_TSK_VANILLA            640
#define IDS_TT_TP_TSK_CHOCOL             641
#define IDS_TT_TP_TSK_BITMAP             642
#define IDS_TT_TP_TSK_MOUSE_OVR          643
#define IDS_TT_TP_TSK_MOUSE_OFF          644
#define IDS_TT_TP_TSK_FFNAME             645
#define IDS_TT_TP_TSK_EOT                646
#define IDS_TT_TP_TSK_SYM_STR            647

#define IDS_TT_EXTEND_INSTRUCTIONS       700


// Error messages

#define IDS_RENAME_FAILED                800
#define IDS_DELETE_FAILED                801
#define IDS_INVALID_IDENTIFIER           802
#define IDS_IDENTIFIER_IN_USE            803
#define IDS_ADD_FAILED                   804
#define IDS_DEMOTE_FAILED                805
#define IDS_PROMOTE_FAILED               806
#define IDS_VIEW_IN_USE                  807
#define IDS_INVALID_GUID                 808
#define IDS_INVALID_PICTURE              809
#define IDS_COLHDR_APPLY_FAILED          810
#define IDS_NODE_HAS_CHILDREN            811





//=--------------------------------------------------------------------------=
//                          Property Sheets
//=--------------------------------------------------------------------------=
#define IDC_STATIC                        -1

// Snap-In Properties Page 1
#define IDD_DIALOG_SNAPIN               1000
#define IDC_RADIO_STAND_ALONE           1001
#define IDC_RADIO_EXTENSION             1002
#define IDC_RADIO_DUAL                  1003
#define IDC_EDIT_NAME                   1004
#define IDC_EDIT_NODE_TYPE              1005
#define IDC_EDIT_DISPLAY                1006
#define IDC_EDIT_PROVIDER               1007
#define IDC_EDIT_VERSION                1008
#define IDC_EDIT_DESCRIPTION            1009
#define IDC_COMBO_VIEWS                 1010
#define IDC_CHECK_EXTENSIBLE            1011

// Snap-In Properties Page 2
#define IDD_PROPPAGE_SNAPIN_IL			1015
#define IDC_COMBO_SMALL_FOLDERS			1016
#define IDC_COMBO_SMALL_OPEN_FOLDERS	1017
#define IDC_COMBO_LARGE_FOLDERS			1018

// Snap-In Properties Page 3
#define IDD_DIALOG_AVAILABLE_NODES      1020
#define IDC_LIST_AVAILABLE_NODES        1021
#define IDC_BUTTON_ADD                  1022
#define IDC_BUTTON_PROPERTIES           1023
#define IDC_STATIC_EXTEND_INSTRUCTIONS  1024

#define IDD_DIALOG_ADD_TO_AVAILABLE     1025
#define IDAPPLY                         1026
#define IDC_EDIT_AVAIL_NODE_GUID        1027
#define IDC_EDIT_AVAIL_NODE_NAME        1028

// ScopeItemDef's Properties Page 1
#define IDD_DIALOG_NEW_NODE             1030
#define IDC_EDIT_NODE_NAME              1031
#define IDC_EDIT_NODE_DISPLAY_NAME      1032
#define IDC_EDIT_FOLDER		            1033
#define IDC_COMBO_IMAGE_LISTS           1034
#define IDC_CHECK_AUTO_CREATE           1035

// ScopeItemDef's Properties Page 2
#define IDD_PROPPAGE_SI_COLUMNS         1040
#define IDC_EDIT_SI_INDEX               1041
#define IDC_EDIT_SI_COLUMNTEXT          1042
#define IDC_EDIT_SI_COLUMNWIDTH         1043
#define IDC_CHECK_SI_AUTOWIDTH          1044
#define IDC_EDIT_SI_COLUMNKEY           1045
#define IDC_SPIN_SI_INDEX               1046
#define IDC_BUTTON_SI_INSERT_COLUMN     1047
#define IDC_BUTTON_SI_REMOVE_COLUMN     1048

// ListView Property Page 1
#define IDD_PROPPAGE_LV_GENERAL         1050
#define IDC_EDIT_LV_NAME                1051
#define IDC_EDIT_LV_VIEWMENUTEXT        1052
#define IDC_COMBO_LV_VIEWS              1053
#define IDC_CHECK_LV_VIRTUAL_LIST       1054
#define IDC_CHECK_LV_ADDTOVIEWMENU      1055
#define IDC_EDIT_LV_STATUSBARTEXT       1056

// ListView Property Page 2
#define IDD_PROPPAGE_LV_IMAGELISTS      1057
#define IDC_COMBO_LV_LARGE_ICONS        1058
#define IDC_COMBO_LV_SMALL_ICONS        1059

// ListView Property Page 3
#define IDD_PROPPAGE_LV_SORTING         1060
#define IDC_CHECK_LV_SORTED             1061
#define IDC_COMBO_LV_KEY                1062
#define IDC_COMBO_LV_SORT               1063

// ListView Property Page 4
#define IDD_PROPPAGE_LV_COLUMNS         1065
#define IDC_EDIT_LV_COLUMNTEXT          1066
#define IDC_EDIT_LV_INDEX               1067
#define IDC_SPIN_LV_INDEX               1068
#define IDC_BUTTON_LV_INSERT_COLUMN     1069
#define IDC_BUTTON_LV_REMOVE_COLUMN     1070
#define IDC_EDIT_LV_COLUMNWIDTH         1071
#define IDC_EDIT_LV_COLUMNKEY           1072
#define IDC_CHECK_LV_AUTOWIDTH          1073

// URL View Property Page 1
#define IDD_PROPPAGE_URL_VIEW           1080
#define IDC_EDIT_URL_NAME               1081
#define IDC_EDIT_URL_URL                1082
#define IDC_CHECK_URL_ADDTOVIEWMENU     1083
#define IDC_EDIT_URL_VIEWMENUTEXT       1084
#define IDC_EDIT_URL_STATUSBARTEXT      1085

// OCX View Property Page 1
#define IDD_PROPPAGE_OCX_VIEW           1090
#define IDC_EDIT_OCX_NAME               1091
#define IDC_EDIT_OCX_PROGID             1092
#define IDC_CHECK_OCX_ADDTOVIEWMENU     1093
#define IDC_EDIT_OCX_VIEWMENUTEXT       1094
#define IDC_EDIT_OCX_STATUSBARTEXT      1095

// Image List Property Page 1
#define IDD_PROPPAGE_IL_IMAGES          1110
#define IDC_EDIT_IL_INDEX               1111
#define IDC_EDIT_IL_KEY                 1112
#define IDC_EDIT_IL_TAG                 1113
#define IDC_LIST_IL_IMAGES              1114
#define IDC_BUTTON_IL_INSERT_PICTURE    1115
#define IDC_BUTTON_IL_REMOVE_PICTURE    1116
#define IDC_EDIT_IL_IMAGE_COUNT         1117

// Taskpad View Property Page 1
#define IDD_PROPPAGE_TP_VIEW_GENERAL    1200
#define IDC_EDIT_TP_NAME                1201
#define IDC_EDIT_TP_TITLE               1202
#define IDC_EDIT_TP_DESCRIPTIVE_TEXT    1203
#define IDC_RADIO_TP_DEFAULT            1204
#define IDC_RADIO_TP_LISTPAD            1205
#define IDC_EDIT_TP_LP_TITLE            1206
#define IDC_CHECK_TP_USE_BUTTON         1207
#define IDC_EDIT_TP_LP_BUTTON_TEXT      1208
#define IDC_RADIO_TP_CUSTOM             1209
#define IDC_EDIT_TP_URL                 1210
#define IDC_CHECK_TP_USER_PREFERRED     1211
#define IDC_CHECK_TP_ADD_TO_VIEW        1212
#define IDC_EDIT_TP_VIEW_MENUTXT        1213
#define IDC_EDIT_TP_STATUSBARTEXT       1214

// Taskpad View Property Page 2
#define IDD_PROPPAGE_TP_VIEW_BACKGROUND 1220
#define IDC_RADIO_TP_NONE               1221
#define IDC_RADIO_TP_VANILLA            1222
#define IDC_RADIO_TP_CHOCOLATE          1223
#define IDC_RADIO_TP_BITMAP             1224
#define IDC_RADIO_TP_SYMBOL             1225
#define IDC_EDIT_TP_MOUSE_OVER          1226
#define IDC_EDIT_TP_FONT_FAMILY         1227
#define IDC_EDIT_TP_EOT                 1228
#define IDC_EDIT_TP_SYMBOL_STRING       1229

// Taskpad View Property Page 2
#define IDD_PROPPAGE_TP_VIEW_TASKS      1230
#define IDC_EDIT_TP_TASK_INDEX          1231
#define IDC_SPIN_TP_INDEX               1232
#define IDC_BUTTON_TP_INSERT_TASK       1233
#define IDC_BUTTON_TP_REMOVE_TASK       1234
#define IDC_EDIT_TP_TASK_KEY            1235
#define IDC_EDIT_TP_TASK_TEXT           1236
#define IDC_EDIT_TP_TASK_HELP_STRING    1237
#define IDC_EDIT_TP_TASK_TAG			1238
#define IDC_RADIO_TP_TASK_NOTIFY        1239
#define IDC_RADIO_TP_TASK_URL           1240
#define IDC_RADIO_TP_TASK_SCRIPT        1241
#define IDC_EDIT_TP_TASK_URL            1242
#define IDC_EDIT_TP_TASK_SCRIPT         1243
#define IDC_RADIO_TPT_VANILLA           1244
#define IDC_RADIO_TPT_CHOCOLATE         1245
#define IDC_RADIO_TPT_BITMAP            1246
#define IDC_RADIO_TPT_SYMBOL            1247
#define IDC_EDIT_TPT_MOUSE_OVER         1248
#define IDC_EDIT_TPT_MOUSE_OFF          1249
#define IDC_EDIT_TPT_FONT_FAMILY        1250
#define IDC_EDIT_TPT_EOT                1251
#define IDC_EDIT_TPT_SYMBOL_STRING      1252
#define IDC_COMBO_TP_LISTVIEW           1253

// Toolbar Property Page 1
#define IDD_PROPPAGE_TOOLBAR_GENERAL    1300
#define IDC_COMBO_TB_ILS                1301
#define IDC_EDIT_TB_TAG                 1302

// Toolbar Property Page 2
#define IDD_PROPPAGE_TOOLBAR_BUTTONS    1310
#define IDC_EDIT_TB_INDEX               1311
#define IDC_SPIN_TB_INDEX               1312
#define IDC_BUTTON_INSERT_BUTTON        1313
#define IDC_BUTTON_REMOVE_BUTTON        1314
#define IDC_EDIT_TB_CAPTION             1315
#define IDC_EDIT_TB_KEY                 1316
#define IDC_COMBO_TB_BUTTON_VALUE       1317
#define IDC_COMBO_TB_BUTTON_STYLE       1318
#define IDC_EDIT_TB_TOOLTIP_TEXT        1319
#define IDC_EDIT_TB_IMAGE               1320
#define IDC_EDIT_TB_BUTTON_TAG          1321
#define IDC_CHECK_TB_VISIBLE            1322
#define IDC_CHECK_TB_ENABLED            1323
#define IDC_CHECK_TB_MIXED_STATE        1324
#define IDC_EDIT_TB_MENU_INDEX          1325
#define IDC_SPIN_TB_MENU_INDEX          1326
#define IDC_BUTTON_INSERT_BUTTON_MENU   1327
#define IDC_BUTTON_REMOVE_BUTTON_MENU   1328
#define IDC_EDIT_TB_MENU_TEXT           1329
#define IDC_EDIT_TB_MENU_KEY            1330
#define IDC_EDIT_TB_MENU_TAG            1331
#define IDC_CHECK_TB_MENU_ENABLED       1332
#define IDC_CHECK_TB_MENU_VISIBLE       1333
#define IDC_CHECK_TB_MENU_CHECKED       1334
#define IDC_CHECK_TB_MENU_GRAYED        1335
#define IDC_CHECK_TB_MENU_SEPARATOR     1336
#define IDC_CHECK_TB_MENU_BREAK         1337
#define IDC_CHECK_TB_MENU_BAR_BREAK     1338


// Dialog Unit Converter
#define IDD_DIALOG_DLGUNITS             1400
#define IDC_EDIT_HEIGHT                 1401
#define IDC_EDIT_WIDTH                  1402
#define ID_BUTTON_CALC                  1403
#define IDC_STATIC_TWIPS_HEIGHT         1404
#define IDC_STATIC_POINTS_HEIGHT        1405
#define IDC_STATIC_PIXELS_HEIGHT        1406
#define IDC_STATIC_TWIPS_WIDTH          1407
#define IDC_STATIC_POINTS_WIDTH         1408
#define IDC_STATIC_PIXELS_WIDTH         1409




//=--------------------------------------------------------------------------=
//                                Menus
//=--------------------------------------------------------------------------=
#define IDR_MENU_ROOT                   2000
#define IDR_MENU_NODE                   2001
#define IDR_MENU_VIEW                   2002
#define IDR_NODE_CHILDREN               2003
#define IDR_NODE_VIEWS                  2004
#define IDR_NODE_OTHER                  2005
#define IDR_MENU_IMAGE_LIST             2006
#define IDR_MENU_MENU                   2007
#define IDR_MENU_TOOLBAR                2008
#define IDR_MENU_TOOLS                  2009
#define IDR_MENU_IMAGE_LISTS            2010
#define IDR_MENU_MENUS                  2011
#define IDR_MENU_TOOLBARS               2012
#define IDR_MENU_VIEWS                  2013
#define IDR_MENU_LIST_VIEWS             2014
#define IDR_MENU_TASKPAD_VIEWS          2015
#define IDR_MENU_OCX_VIEWS              2016
#define IDR_MENU_URL_VIEWS              2017
#define IDR_MENU_STATIC_NODE            2018
#define IDR_MENU_EXTENSIONS_ROOT        2019
#define IDR_MENU_EXTENSIONS             2020
#define IDR_MENU_THIS_EXTENSIONS        2021
#define IDR_MENU_RESOURCES              2022
#define IDR_MENU_RESOURCE               2023

//=--------------------------------------------------------------------------=
//                              Commands
//=--------------------------------------------------------------------------=
#define CMD_ADD_NODE                    3000
#define CMD_ADD_LISTVIEW                3001
#define CMD_ADD_TASKPAD                 3002
#define CMD_ADD_OCX_VIEW                3003
#define CMD_ADD_WEB_VIEW                3004

#define CMD_ADD_IMAGE_LIST              3010
#define CMD_ADD_TOOLBAR                 3011
#define CMD_ADD_MENU                    3012

#define CMD_VIEW_PROPERTIES             3020
#define CMD_DELETE                      3021
#define CMD_RENAME                      3022
#define CMD_ADD_CHILD_MENU              3023
#define CMD_PROMOTE                     3024
#define CMD_DEMOTE                      3025
#define CMD_MOVE_UP                     3026
#define CMD_MOVE_DOWN                   3027
#define CMD_VIEW_DLGUNITS               3028

#define CMD_EXT_CM_NEW                  3050
#define CMD_EXT_CM_TASK                 3051
#define CMD_EXT_PPAGES                  3052
#define CMD_EXT_TASKPAD                 3053
#define CMD_EXT_TOOLBAR                 3054
#define CMD_EXT_NAMESPACE               3055

#define CMD_EXTE_NEW_MENU               3060
#define CMD_EXTE_TASK_MENU              3061
#define CMD_EXTE_TOP_MENU               3062
#define CMD_EXTE_VIEW_MENU              3063
#define CMD_EXTE_PPAGES                 3064
#define CMD_EXTE_TOOLBAR                3065
#define CMD_EXTE_NAMESPACE              3066

#define CMD_ADD_RESOURCE                3070
#define CMD_VIEW_RESOURCE_REFRESH       3071

#endif // _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\scpitm.cpp ===
//=--------------------------------------------------------------------------------------
// scpitm.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- Command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "desmain.h"
#include "guids.h"
#include "psnode.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddNewNode()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  This function is invoked in response to a user clicking on the toolbar or selecting
//  a menu item. IObjectModelHost will have triggered an Add() notification, and the
//  notification will be serviced before this function returns.
//
HRESULT CSnapInDesigner::AddNewNode()
{
    HRESULT              hr = S_OK;
    IScopeItemDefs      *piScopeItemDefs = NULL;
    VARIANT              vtEmpty;
    IScopeItemDef       *piScopeItemDef = NULL;

    ::VariantInit(&vtEmpty);

    hr = GetScopeItemCollection(m_pCurrentSelection, &piScopeItemDefs);
    IfFailGo(hr);

    vtEmpty.vt = VT_ERROR;
    vtEmpty.scode = DISP_E_PARAMNOTFOUND;

    hr = piScopeItemDefs->Add(vtEmpty, vtEmpty, &piScopeItemDef);
    IfFailGo(hr);

Error:
    ::VariantClear(&vtEmpty);
    RELEASE(piScopeItemDef);
    RELEASE(piScopeItemDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddScopeItemDef(pSelection, piScopeItemDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Invoked in response to an IObjectModelHost:Add() notification.
//
HRESULT CSnapInDesigner::OnAddScopeItemDef(CSelectionHolder *pParent, IScopeItemDef *piScopeItemDef)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pScopeItem = NULL;

    hr = MakeNewNode(pParent, piScopeItemDef, &pScopeItem);
    IfFailGo(hr);

    hr = pScopeItem->RegisterHolder();
    IfFailGo(hr);

    hr = InsertNodeInTree(pScopeItem, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pScopeItem);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pScopeItem);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pScopeItem);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameScopeItem(CSelectionHolder *pScopeItem, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Invoked in response to an IObjectModelHost::Update() notification.
//
HRESULT CSnapInDesigner::RenameScopeItem(CSelectionHolder *pScopeItem, BSTR bstrNewName)
{
    HRESULT     hr = S_OK;
    TCHAR      *pszName = NULL;

    ASSERT(SEL_NODES_ANY_NAME == pScopeItem->m_st, "RenameScopeItem: wrong argument");

    hr = m_piDesignerProgrammability->IsValidIdentifier(bstrNewName);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = pScopeItem->m_piObject.m_piScopeItemDef->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = pScopeItem->m_piObject.m_piScopeItemDef->put_NodeTypeName(bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->ChangeText(pScopeItem, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteScopeItem(CSelectionHolder *pScopeItem)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteScopeItem(CSelectionHolder *pScopeItem)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    IScopeItemDefs      *piScopeItemDefs = NULL;
    long                 lIndex = 0;
    VARIANT              vtIndex;

    ::VariantInit(&vtIndex);

    hr = CanDeleteScopeItem(pScopeItem);
    IfFailGo(hr);

    if (S_FALSE == hr)
        goto Error;

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pScopeItem, &pParent);
    IfFailGo(hr);

    // Delete from the appropriate object model collection
    hr = GetScopeItemCollection(pParent, &piScopeItemDefs);
    IfFailGo(hr);

    if (NULL != piScopeItemDefs)
    {
        hr = pScopeItem->m_piObject.m_piScopeItemDef->get_Index(&lIndex);
        IfFailGo(hr);

        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = piScopeItemDefs->Remove(vtIndex);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtIndex);
    RELEASE(piScopeItemDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CanDeleteScopeItem(CSelectionHolder *pScopeItem)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::CanDeleteScopeItem(CSelectionHolder *pScopeItem)
{
    HRESULT           hr = S_OK;
    IScopeItemDefs   *piScopeItemDefs = NULL;
    long              lCount = 0;
    IViewDefs        *piViewDefs = NULL;
    IListViewDefs    *piListViewDefs = NULL;
    IOCXViewDefs     *piOCXViewDefs = NULL;
    IURLViewDefs     *piURLViewDefs = NULL;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;

    hr = pScopeItem->m_piObject.m_piScopeItemDef->get_Children(&piScopeItemDefs);
    IfFailGo(hr);

    piScopeItemDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        hr = S_FALSE;
        goto Error;
    }

    hr = pScopeItem->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    hr = piViewDefs->get_ListViews(&piListViewDefs);
    IfFailGo(hr);

    hr = piListViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        hr = S_FALSE;
        goto Error;
    }

    hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
    IfFailGo(hr);

    hr = piOCXViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        hr = S_FALSE;
        goto Error;
    }

    hr = piViewDefs->get_URLViews(&piURLViewDefs);
    IfFailGo(hr);

    hr = piURLViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        hr = S_FALSE;
        goto Error;
    }

    hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
    IfFailGo(hr);

    hr = piTaskpadViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        hr = S_FALSE;
        goto Error;
    }

Error:
    if (S_FALSE == hr)
    {
        (void)::SDU_DisplayMessage(IDS_NODE_HAS_CHILDREN, MB_OK | MB_ICONHAND, HID_mssnapd_NodeHasChildren, 0, DontAppendErrorInfo, NULL);
    }

    RELEASE(piTaskpadViewDefs);
    RELEASE(piURLViewDefs);
    RELEASE(piOCXViewDefs);
    RELEASE(piListViewDefs);
    RELEASE(piViewDefs);
    RELEASE(piScopeItemDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteScopeItem(CSelectionHolder *pScopeItem)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteScopeItem(CSelectionHolder *pScopeItem)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    CSelectionHolder    *pChildren = NULL;
    CSelectionHolder    *pViews = NULL;
    IScopeItemDefs      *piScopeItemDefs = NULL;
    long                 lCount = 0;

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pScopeItem, &pParent);
    IfFailGo(hr);

    // Need to delete the children and views folders
    hr = m_pTreeView->GetFirstChildNode(pScopeItem, &pViews);
    IfFailGo(hr);

    ASSERT(SEL_NODES_ANY_VIEWS == pViews->m_st, "OnDeleteScopeItem: Expected a different child");

    hr = m_pTreeView->GetNextChildNode(pViews, &pChildren);
    IfFailGo(hr);

    ASSERT(SEL_NODES_ANY_CHILDREN == pChildren->m_st, "OnDeleteScopeItem: Expected a different child");

    delete pChildren;
    delete pViews;

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pScopeItem);
    IfFailGo(hr);

    delete pScopeItem;

    // Select the next selection
    hr = GetScopeItemCollection(pParent, &piScopeItemDefs);
    IfFailGo(hr);

    if (NULL != piScopeItemDefs)
    {
        hr = piScopeItemDefs->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piScopeItemDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowNodeProperties(IScopeItemDef *piScopeItemDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowNodeProperties
(
    IScopeItemDef *piScopeItemDef
)
{
    HRESULT         hr = S_OK;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[2];

    hr = GetResourceString(IDS_NODE_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = piScopeItemDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_ScopeItemDefGeneralPP;
    pageClsID[1] = CLSID_ScopeItemDefColHdrsPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 2;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = 0;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewNode(CSelectionHolder  *pParent, IScopeItemDef *piScopeItemDef, CSelectionHolder **ppNode)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewNode
(
    CSelectionHolder  *pParent,
    IScopeItemDef     *piScopeItemDef,
    CSelectionHolder **ppNode
)
{
    HRESULT              hr = S_OK;

    *ppNode = New CSelectionHolder(SEL_NODES_ANY_NAME, piScopeItemDef);
    if (*ppNode == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    switch (pParent->m_st)
    {
    case SEL_NODES_AUTO_CREATE_RTCH:
        hr = InitializeNewAutoCreateNode(piScopeItemDef);
        IfFailGo(hr);
        break;

    case SEL_NODES_OTHER:
        hr = InitializeNewOtherNode(piScopeItemDef);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_CHILDREN:
        hr = InitializeNewChildNode(piScopeItemDef, pParent->m_piObject.m_piScopeItemDefs);
        IfFailGo(hr);
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewAutoCreateNode(IScopeItemDef *piScopeItemDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewAutoCreateNode
(
    IScopeItemDef *piScopeItemDef
)
{
    HRESULT           hr = S_OK;
    int               iResult = 0;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    bool              bGood = false;
    IScopeItemDefs   *piAutoScopeItemDefs = NULL;
    CSelectionHolder *pScopeItemDefClone = NULL;
    BSTR              bstrName = NULL;

    hr = GetResourceString(IDS_NODE, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_AutoCreateNodes(&piAutoScopeItemDefs);
    IfFailGo(hr);

    do {
        iResult = _stprintf(szName, _T("%s%d"), szBuffer, ++m_iNextNodeNumber);
        if (iResult == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK(hr);
        }

		hr = m_pTreeView->FindLabelInTree(szName, &pScopeItemDefClone);
		IfFailGo(hr);

        if (S_FALSE == hr)
        {
			hr = BSTRFromANSI(szName, &bstrName);
			IfFailGo(hr);

            bGood = true;
            break;
        }

        FREESTRING(bstrName);
    } while (false == bGood);

    hr = piScopeItemDef->put_Name(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_Key(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_NodeTypeName(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_